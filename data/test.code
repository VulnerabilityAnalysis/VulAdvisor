IonRuntime :: initialize ( JSContext * cx ) { AutoEnterAtomsCompartment ac ( cx ) ; IonContext ictx ( cx , NULL ) ; AutoFlushCache afc ( "IonRuntime::initialize" ) ; execAlloc_ = cx -> runtime ( ) -> getExecAlloc ( cx ) ; if ( ! execAlloc_ ) return false ; if ( ! cx -> compartment ( ) -> ensureIonCompartmentExists ( cx ) ) return false ; functionWrappers_ = cx -> new_ < VMWrapperMap > ( cx ) ; if ( ! functionWrappers_ || ! functionWrappers_ -> init ( ) ) return false ; exceptionTail_ = generateExceptionTailStub ( cx ) ; if ( ! exceptionTail_ ) return false ; if ( cx -> runtime ( ) -> jitSupportsFloatingPoint ) { if ( ! bailoutTables_ . reserve ( FrameSizeClass :: ClassLimit ( ) . classId ( ) ) ) return false ; for ( uint32_t id = 0 ; ; id ++ ) { FrameSizeClass class_ = FrameSizeClass :: FromClass ( id ) ; if ( class_ == FrameSizeClass :: ClassLimit ( ) ) break ; bailoutTables_ . infallibleAppend ( ( IonCode * ) NULL ) ; bailoutTables_ [ id ] = generateBailoutTable ( cx , id ) ; if ( ! bailoutTables_ [ id ] ) return false ; } bailoutHandler_ = generateBailoutHandler ( cx ) ; if ( ! bailoutHandler_ ) return false ; invalidator_ = generateInvalidator ( cx ) ; if ( ! invalidator_ ) return false ; } argumentsRectifier_ = generateArgumentsRectifier ( cx , SequentialExecution , & argumentsRectifierReturnAddr_ ) ; if ( ! argumentsRectifier_ ) return false ; #ifdef JS_THREADSAFE parallelArgumentsRectifier_ = generateArgumentsRectifier ( cx , ParallelExecution , NULL ) ; if ( ! parallelArgumentsRectifier_ ) return false ; #endif enterJIT_ = generateEnterJIT ( cx , EnterJitOptimized ) ; if ( ! enterJIT_ ) return false ; enterBaselineJIT_ = generateEnterJIT ( cx , EnterJitBaseline ) ; if ( ! enterBaselineJIT_ ) return false ; valuePreBarrier_ = generatePreBarrier ( cx , MIRType_Value ) ; if ( ! valuePreBarrier_ ) return false ; shapePreBarrier_ = generatePreBarrier ( cx , MIRType_Shape ) ; if ( ! shapePreBarrier_ ) return false ; for ( VMFunction * fun = VMFunction :: functions ; fun ; fun = fun -> next ) { if ( ! generateVMWrapper ( cx , * fun ) ) return false ; } return true ; }
__xmlOutputBufferCreateFilename ( const char * URI , xmlCharEncodingHandlerPtr encoder , int compression ATTRIBUTE_UNUSED ) { xmlOutputBufferPtr ret ; xmlURIPtr puri ; int i = 0 ; void * context = NULL ; char * unescaped = NULL ; #ifdef HAVE_ZLIB_H int is_file_uri = 1 ; #endif if ( xmlOutputCallbackInitialized == 0 ) xmlRegisterDefaultOutputCallbacks ( ) ; if ( URI == NULL ) return ( NULL ) ; puri = xmlParseURI ( URI ) ; if ( puri != NULL ) { #ifdef HAVE_ZLIB_H if ( ( puri -> scheme != NULL ) && ( ! xmlStrEqual ( BAD_CAST puri -> scheme , BAD_CAST "file" ) ) ) is_file_uri = 0 ; #endif if ( ( puri -> scheme == NULL ) || ( xmlStrEqual ( BAD_CAST puri -> scheme , BAD_CAST "file" ) ) ) unescaped = xmlURIUnescapeString ( URI , 0 , NULL ) ; xmlFreeURI ( puri ) ; } if ( unescaped != NULL ) { #ifdef HAVE_ZLIB_H if ( ( compression > 0 ) && ( compression <= 9 ) && ( is_file_uri == 1 ) ) { context = xmlGzfileOpenW ( unescaped , compression ) ; if ( context != NULL ) { ret = xmlAllocOutputBufferInternal ( encoder ) ; if ( ret != NULL ) { ret -> context = context ; ret -> writecallback = xmlGzfileWrite ; ret -> closecallback = xmlGzfileClose ; } xmlFree ( unescaped ) ; return ( ret ) ; } } #endif for ( i = xmlOutputCallbackNr - 1 ; i >= 0 ; i -- ) { if ( ( xmlOutputCallbackTable [ i ] . matchcallback != NULL ) && ( xmlOutputCallbackTable [ i ] . matchcallback ( unescaped ) != 0 ) ) { #if defined(LIBXML_HTTP_ENABLED) && defined(HAVE_ZLIB_H) if ( xmlOutputCallbackTable [ i ] . matchcallback == xmlIOHTTPMatch ) context = xmlIOHTTPOpenW ( unescaped , compression ) ; else #endif context = xmlOutputCallbackTable [ i ] . opencallback ( unescaped ) ; if ( context != NULL ) break ; } } xmlFree ( unescaped ) ; } if ( context == NULL ) { #ifdef HAVE_ZLIB_H if ( ( compression > 0 ) && ( compression <= 9 ) && ( is_file_uri == 1 ) ) { context = xmlGzfileOpenW ( URI , compression ) ; if ( context != NULL ) { ret = xmlAllocOutputBufferInternal ( encoder ) ; if ( ret != NULL ) { ret -> context = context ; ret -> writecallback = xmlGzfileWrite ; ret -> closecallback = xmlGzfileClose ; } return ( ret ) ; } } #endif for ( i = xmlOutputCallbackNr - 1 ; i >= 0 ; i -- ) { if ( ( xmlOutputCallbackTable [ i ] . matchcallback != NULL ) && ( xmlOutputCallbackTable [ i ] . matchcallback ( URI ) != 0 ) ) { #if defined(LIBXML_HTTP_ENABLED) && defined(HAVE_ZLIB_H) if ( xmlOutputCallbackTable [ i ] . matchcallback == xmlIOHTTPMatch ) context = xmlIOHTTPOpenW ( URI , compression ) ; else #endif context = xmlOutputCallbackTable [ i ] . opencallback ( URI ) ; if ( context != NULL ) break ; } } } if ( context == NULL ) { return ( NULL ) ; } ret = xmlAllocOutputBufferInternal ( encoder ) ; if ( ret != NULL ) { ret -> context = context ; ret -> writecallback = xmlOutputCallbackTable [ i ] . writecallback ; ret -> closecallback = xmlOutputCallbackTable [ i ] . closecallback ; } return ( ret ) ; }
void PasswordGenerationAgent :: ShowGenerationPopup ( ) { if ( ! render_frame ( ) ) return ; Send ( new AutofillHostMsg_ShowPasswordGenerationPopup ( routing_id ( ) , render_frame ( ) -> GetRenderView ( ) -> ElementBoundsInWindow ( generation_element_ ) , generation_element_ . maxLength ( ) , generation_element_ . nameForAutofill ( ) , is_manually_triggered_ , * generation_form_data_ -> form ) ) ; generation_popup_shown_ = true ; }
String string_number_format ( double d , int dec , const String & dec_point , const String & thousand_sep ) { char * tmpbuf = nullptr , * resbuf ; char * s , * t ; char * dp ; int integral ; int tmplen , reslen = 0 ; int count = 0 ; int is_negative = 0 ; if ( d < 0 ) { is_negative = 1 ; d = - d ; } if ( dec < 0 ) dec = 0 ; d = php_math_round ( d , dec ) ; String tmpstr ( 63 , ReserveString ) ; tmpbuf = tmpstr . mutableData ( ) ; tmplen = snprintf ( tmpbuf , 64 , "%.*F" , dec , d ) ; if ( tmplen < 0 ) return empty_string ( ) ; if ( tmpbuf == nullptr || ! isdigit ( ( int ) tmpbuf [ 0 ] ) ) { tmpstr . setSize ( tmplen ) ; return tmpstr ; } if ( tmplen >= 64 ) { tmpstr = String ( tmplen , ReserveString ) ; tmpbuf = tmpstr . mutableData ( ) ; tmplen = snprintf ( tmpbuf , tmplen + 1 , "%.*F" , dec , d ) ; if ( tmplen < 0 ) return empty_string ( ) ; if ( tmpbuf == nullptr || ! isdigit ( ( int ) tmpbuf [ 0 ] ) ) { tmpstr . setSize ( tmplen ) ; return tmpstr ; } } if ( dec ) { dp = strpbrk ( tmpbuf , ".," ) ; } else { dp = nullptr ; } if ( dp ) { integral = dp - tmpbuf ; } else { integral = tmplen ; } if ( ! thousand_sep . empty ( ) ) { if ( integral + thousand_sep . size ( ) * ( ( integral - 1 ) / 3 ) < integral ) { raise_error ( "String overflow" ) ; } integral += ( ( integral - 1 ) / 3 ) * thousand_sep . size ( ) ; } reslen = integral ; if ( dec ) { reslen += dec ; if ( ! dec_point . empty ( ) ) { if ( reslen + dec_point . size ( ) < dec_point . size ( ) ) { raise_error ( "String overflow" ) ; } reslen += dec_point . size ( ) ; } } if ( is_negative ) { reslen ++ ; } String resstr ( reslen , ReserveString ) ; resbuf = resstr . mutableData ( ) ; s = tmpbuf + tmplen - 1 ; t = resbuf + reslen - 1 ; if ( dec ) { int declen = dp ? s - dp : 0 ; int topad = dec > declen ? dec - declen : 0 ; while ( topad -- ) { * t -- = '0' ; } if ( dp ) { s -= declen + 1 ; t -= declen ; memcpy ( t + 1 , dp + 1 , declen ) ; } if ( ! dec_point . empty ( ) ) { memcpy ( t + ( 1 - dec_point . size ( ) ) , dec_point . data ( ) , dec_point . size ( ) ) ; t -= dec_point . size ( ) ; } } while ( s >= tmpbuf ) { * t -- = * s -- ; if ( thousand_sep && ( ++ count % 3 ) == 0 && s >= tmpbuf ) { memcpy ( t + ( 1 - thousand_sep . size ( ) ) , thousand_sep . data ( ) , thousand_sep . size ( ) ) ; t -= thousand_sep . size ( ) ; } } if ( is_negative ) { * t -- = '-' ; } resstr . setSize ( reslen ) ; return resstr ; }
static void copyTrespass ( short * , const int * const * , unsigned , unsigned ) { TRESPASS ( ) ; }
uint32_t WasmModuleBuilder :: AllocateIndirectFunctions ( uint32_t count ) { uint32_t index = static_cast < uint32_t > ( indirect_functions_ . size ( ) ) ; DCHECK_GE ( FLAG_wasm_max_table_size , index ) ; if ( count > FLAG_wasm_max_table_size - index ) { return std :: numeric_limits < uint32_t > :: max ( ) ; } indirect_functions_ . resize ( indirect_functions_ . size ( ) + count ) ; return index ; }
void Builtins :: Generate_ArgumentsAdaptorTrampoline ( MacroAssembler * masm ) { Label invoke , dont_adapt_arguments , stack_overflow ; Label enough , too_few ; __ Branch ( & dont_adapt_arguments , eq , a2 , Operand ( SharedFunctionInfo :: kDontAdaptArgumentsSentinel ) ) ; __ Branch ( & too_few , Uless , a0 , Operand ( a2 ) ) ; { __ bind ( & enough ) ; EnterArgumentsAdaptorFrame ( masm ) ; Generate_StackOverflowCheck ( masm , a2 , t1 , kScratchReg , & stack_overflow ) ; __ Lsa ( a0 , fp , a0 , kPointerSizeLog2 - kSmiTagSize ) ; __ Addu ( a0 , a0 , Operand ( 2 * kPointerSize ) ) ; __ sll ( t1 , a2 , kPointerSizeLog2 ) ; __ subu ( t1 , a0 , t1 ) ; Label copy ; __ bind ( & copy ) ; __ lw ( t0 , MemOperand ( a0 ) ) ; __ push ( t0 ) ; __ Branch ( USE_DELAY_SLOT , & copy , ne , a0 , Operand ( t1 ) ) ; __ addiu ( a0 , a0 , - kPointerSize ) ; __ jmp ( & invoke ) ; } { __ bind ( & too_few ) ; EnterArgumentsAdaptorFrame ( masm ) ; Generate_StackOverflowCheck ( masm , a2 , t1 , kScratchReg , & stack_overflow ) ; __ Lsa ( a0 , fp , a0 , kPointerSizeLog2 - kSmiTagSize ) ; __ Addu ( a0 , a0 , Operand ( 2 * kPointerSize ) ) ; __ Addu ( t3 , fp , kPointerSize ) ; Label copy ; __ bind ( & copy ) ; __ lw ( t0 , MemOperand ( a0 ) ) ; __ Subu ( sp , sp , kPointerSize ) ; __ Subu ( a0 , a0 , kPointerSize ) ; __ Branch ( USE_DELAY_SLOT , & copy , ne , a0 , Operand ( t3 ) ) ; __ sw ( t0 , MemOperand ( sp ) ) ; __ LoadRoot ( t0 , Heap :: kUndefinedValueRootIndex ) ; __ sll ( t2 , a2 , kPointerSizeLog2 ) ; __ Subu ( t1 , fp , Operand ( t2 ) ) ; __ Subu ( t1 , t1 , Operand ( ArgumentsAdaptorFrameConstants :: kFixedFrameSizeFromFp + kPointerSize ) ) ; Label fill ; __ bind ( & fill ) ; __ Subu ( sp , sp , kPointerSize ) ; __ Branch ( USE_DELAY_SLOT , & fill , ne , sp , Operand ( t1 ) ) ; __ sw ( t0 , MemOperand ( sp ) ) ; } __ bind ( & invoke ) ; __ mov ( a0 , a2 ) ; static_assert ( kJavaScriptCallCodeStartRegister == a2 , "ABI mismatch" ) ; __ lw ( a2 , FieldMemOperand ( a1 , JSFunction :: kCodeOffset ) ) ; __ Addu ( a2 , a2 , Code :: kHeaderSize - kHeapObjectTag ) ; __ Call ( a2 ) ; masm -> isolate ( ) -> heap ( ) -> SetArgumentsAdaptorDeoptPCOffset ( masm -> pc_offset ( ) ) ; LeaveArgumentsAdaptorFrame ( masm ) ; __ Ret ( ) ; __ bind ( & dont_adapt_arguments ) ; static_assert ( kJavaScriptCallCodeStartRegister == a2 , "ABI mismatch" ) ; __ lw ( a2 , FieldMemOperand ( a1 , JSFunction :: kCodeOffset ) ) ; __ Addu ( a2 , a2 , Code :: kHeaderSize - kHeapObjectTag ) ; __ Jump ( a2 ) ; __ bind ( & stack_overflow ) ; { FrameScope frame ( masm , StackFrame :: MANUAL ) ; __ CallRuntime ( Runtime :: kThrowStackOverflow ) ; __ break_ ( 0xCC ) ; } }
TfLiteStatus EvalImpl ( TfLiteContext * context , TfLiteNode * node ) { auto * params = reinterpret_cast < TfLiteDepthwiseConvParams * > ( node -> builtin_data ) ; OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; const TfLiteTensor * filter = GetInput ( context , node , kFilterTensor ) ; const TfLiteTensor * bias = ( NumInputs ( node ) == 3 ) ? GetInput ( context , node , kBiasTensor ) : nullptr ; TFLITE_DCHECK_EQ ( input_type , input -> type ) ; switch ( input_type ) { case kTfLiteFloat32 : if ( filter -> type == kTfLiteFloat32 ) { return EvalFloat < kernel_type > ( context , node , params , data , input , filter , bias , output ) ; } else if ( filter -> type == kTfLiteInt8 ) { return EvalHybridPerChannel < kernel_type > ( context , node , params , data , input , filter , bias , output ) ; } else { TF_LITE_KERNEL_LOG ( context , "Type %s with filter type %s not currently supported." , TfLiteTypeGetName ( input -> type ) , TfLiteTypeGetName ( filter -> type ) ) ; return kTfLiteError ; } break ; case kTfLiteUInt8 : return EvalQuantized < kernel_type > ( context , node , params , data , input , filter , bias , output ) ; break ; case kTfLiteInt8 : return EvalQuantizedPerChannel < kernel_type > ( context , node , params , data , input , filter , bias , output ) ; break ; case kTfLiteInt16 : return EvalQuantizedPerChannel16x8 ( params , data , input , filter , bias , output ) ; break ; default : context -> ReportError ( context , "Type %d not currently supported." , input -> type ) ; return kTfLiteError ; } }
static int mincore_unmapped_range ( unsigned long addr , unsigned long end , struct mm_walk * walk ) { walk -> private += __mincore_unmapped_range ( addr , end , walk -> vma , walk -> private ) ; return 0 ; }
void DebugCodegen :: GenerateFrameDropperTrampoline ( MacroAssembler * masm ) { __ LoadRR ( fp , r3 ) ; __ LoadP ( r3 , MemOperand ( fp , JavaScriptFrameConstants :: kFunctionOffset ) ) ; __ LeaveFrame ( StackFrame :: INTERNAL ) ; __ LoadP ( r2 , FieldMemOperand ( r3 , JSFunction :: kSharedFunctionInfoOffset ) ) ; __ LoadLogicalHalfWordP ( r2 , FieldMemOperand ( r2 , SharedFunctionInfo :: kFormalParameterCountOffset ) ) ; __ LoadRR ( r4 , r2 ) ; ParameterCount dummy1 ( r4 ) ; ParameterCount dummy2 ( r2 ) ; __ InvokeFunction ( r3 , dummy1 , dummy2 , JUMP_FUNCTION ) ; }
Reduction JSCallReducer :: ReducePromisePrototypeThen ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSCall , node -> opcode ( ) ) ; CallParameters const & p = CallParametersOf ( node -> op ( ) ) ; if ( p . speculation_mode ( ) == SpeculationMode :: kDisallowSpeculation ) { return NoChange ( ) ; } Node * receiver = NodeProperties :: GetValueInput ( node , 1 ) ; Node * on_fulfilled = node -> op ( ) -> ValueInputCount ( ) > 2 ? NodeProperties :: GetValueInput ( node , 2 ) : jsgraph ( ) -> UndefinedConstant ( ) ; Node * on_rejected = node -> op ( ) -> ValueInputCount ( ) > 3 ? NodeProperties :: GetValueInput ( node , 3 ) : jsgraph ( ) -> UndefinedConstant ( ) ; Node * context = NodeProperties :: GetContextInput ( node ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; Node * frame_state = NodeProperties :: GetFrameStateInput ( node ) ; if ( ! isolate ( ) -> IsPromiseHookProtectorIntact ( ) ) return NoChange ( ) ; if ( ! isolate ( ) -> IsPromiseSpeciesLookupChainIntact ( ) ) return NoChange ( ) ; ZoneHandleSet < Map > receiver_maps ; NodeProperties :: InferReceiverMapsResult infer_receiver_maps_result = NodeProperties :: InferReceiverMaps ( isolate ( ) , receiver , effect , & receiver_maps ) ; if ( infer_receiver_maps_result == NodeProperties :: kNoReceiverMaps ) { return NoChange ( ) ; } DCHECK_NE ( 0 , receiver_maps . size ( ) ) ; for ( Handle < Map > receiver_map : receiver_maps ) { if ( ! receiver_map -> IsJSPromiseMap ( ) ) return NoChange ( ) ; if ( receiver_map -> prototype ( ) != native_context ( ) -> promise_prototype ( ) ) { return NoChange ( ) ; } } dependencies ( ) -> DependOnProtector ( PropertyCellRef ( js_heap_broker ( ) , factory ( ) -> promise_hook_protector ( ) ) ) ; dependencies ( ) -> DependOnProtector ( PropertyCellRef ( js_heap_broker ( ) , factory ( ) -> promise_species_protector ( ) ) ) ; if ( infer_receiver_maps_result == NodeProperties :: kUnreliableReceiverMaps ) { effect = graph ( ) -> NewNode ( simplified ( ) -> CheckMaps ( CheckMapsFlag :: kNone , receiver_maps , p . feedback ( ) ) , receiver , effect , control ) ; } on_fulfilled = graph ( ) -> NewNode ( common ( ) -> Select ( MachineRepresentation :: kTagged , BranchHint :: kTrue ) , graph ( ) -> NewNode ( simplified ( ) -> ObjectIsCallable ( ) , on_fulfilled ) , on_fulfilled , jsgraph ( ) -> UndefinedConstant ( ) ) ; on_rejected = graph ( ) -> NewNode ( common ( ) -> Select ( MachineRepresentation :: kTagged , BranchHint :: kTrue ) , graph ( ) -> NewNode ( simplified ( ) -> ObjectIsCallable ( ) , on_rejected ) , on_rejected , jsgraph ( ) -> UndefinedConstant ( ) ) ; Node * result = effect = graph ( ) -> NewNode ( javascript ( ) -> CreatePromise ( ) , context , effect ) ; result = effect = graph ( ) -> NewNode ( javascript ( ) -> PerformPromiseThen ( ) , receiver , on_fulfilled , on_rejected , result , context , frame_state , effect , control ) ; ReplaceWithValue ( node , result , effect , control ) ; return Replace ( result ) ; }
void BytecodeGraphBuilder :: VisitConstruct ( ) { PrepareEagerCheckpoint ( ) ; interpreter :: Register callee_reg = bytecode_iterator ( ) . GetRegisterOperand ( 0 ) ; interpreter :: Register first_reg = bytecode_iterator ( ) . GetRegisterOperand ( 1 ) ; size_t reg_count = bytecode_iterator ( ) . GetRegisterCountOperand ( 2 ) ; int const slot_id = bytecode_iterator ( ) . GetIndexOperand ( 3 ) ; VectorSlotPair feedback = CreateVectorSlotPair ( slot_id ) ; Node * new_target = environment ( ) -> LookupAccumulator ( ) ; Node * callee = environment ( ) -> LookupRegister ( callee_reg ) ; CallFrequency frequency = ComputeCallFrequency ( slot_id ) ; const Operator * op = javascript ( ) -> Construct ( static_cast < uint32_t > ( reg_count + 2 ) , frequency , feedback ) ; int arg_count = static_cast < int > ( reg_count ) ; Node * const * args = GetConstructArgumentsFromRegister ( callee , new_target , first_reg , arg_count ) ; JSTypeHintLowering :: LoweringResult lowering = TryBuildSimplifiedConstruct ( op , args , static_cast < int > ( arg_count ) , feedback . slot ( ) ) ; if ( lowering . IsExit ( ) ) return ; Node * node = nullptr ; if ( lowering . IsSideEffectFree ( ) ) { node = lowering . value ( ) ; } else { DCHECK ( ! lowering . Changed ( ) ) ; node = ProcessConstructArguments ( op , args , 2 + arg_count ) ; } environment ( ) -> BindAccumulator ( node , Environment :: kAttachFrameState ) ; }
size_t JSTypedArray :: element_size ( ) { switch ( elements ( ) -> map ( ) -> instance_type ( ) ) { #define INSTANCE_TYPE_TO_ELEMENT_SIZE(Type, type, TYPE, ctype) \  case FIXED_##TYPE##_ARRAY_TYPE:                              \  return sizeof(ctype); TYPED_ARRAYS ( INSTANCE_TYPE_TO_ELEMENT_SIZE ) #undef INSTANCE_TYPE_TO_ELEMENT_SIZE default : UNREACHABLE ( ) ; } }
HTTPserver :: HTTPserver ( const char * _docs_dir , const char * _scripts_dir ) { struct mg_callbacks callbacks ; static char ports [ 256 ] , ssl_cert_path [ MAX_PATH ] = { 0 } , access_log_path [ MAX_PATH ] = { 0 } ; const char * http_binding_addr = ntop -> getPrefs ( ) -> get_http_binding_address ( ) ; const char * https_binding_addr = ntop -> getPrefs ( ) -> get_https_binding_address ( ) ; char tmpBuf [ 8 ] ; bool use_ssl = false ; bool use_http = true ; struct stat statsBuf ; int stat_rc ; static char * http_options [ ] = { ( char * ) "listening_ports" , ports , ( char * ) "enable_directory_listing" , ( char * ) "no" , ( char * ) "document_root" , ( char * ) _docs_dir , ( char * ) "num_threads" , ( char * ) "5" , NULL , NULL , NULL , NULL , NULL } ; docs_dir = strdup ( _docs_dir ) , scripts_dir = strdup ( _scripts_dir ) ; httpserver = this ; if ( ntop -> getPrefs ( ) -> get_http_port ( ) == 0 ) use_http = false ; if ( use_http ) { snprintf ( ports , sizeof ( ports ) , "%s%s%d" , http_binding_addr , ( http_binding_addr [ 0 ] == '\0' ) ? "" : ":" , ntop -> getPrefs ( ) -> get_http_port ( ) ) ; } snprintf ( ssl_cert_path , sizeof ( ssl_cert_path ) , "%s/ssl/%s" , docs_dir , CONST_HTTPS_CERT_NAME ) ; stat_rc = stat ( ssl_cert_path , & statsBuf ) ; if ( ( ntop -> getPrefs ( ) -> get_https_port ( ) > 0 ) && ( stat_rc == 0 ) ) { int i ; use_ssl = true ; if ( use_http ) snprintf ( ports , sizeof ( ports ) , "%s%s%d,%s%s%ds" , http_binding_addr , ( http_binding_addr [ 0 ] == '\0' ) ? "" : ":" , ntop -> getPrefs ( ) -> get_http_port ( ) , https_binding_addr , ( https_binding_addr [ 0 ] == '\0' ) ? "" : ":" , ntop -> getPrefs ( ) -> get_https_port ( ) ) ; else snprintf ( ports , sizeof ( ports ) , "%s%s%ds" , https_binding_addr , ( https_binding_addr [ 0 ] == '\0' ) ? "" : ":" , ntop -> getPrefs ( ) -> get_https_port ( ) ) ; ntop -> getTrace ( ) -> traceEvent ( TRACE_INFO , "Found SSL certificate %s" , ssl_cert_path ) ; for ( i = 0 ; http_options [ i ] != NULL ; i ++ ) ; http_options [ i ] = ( char * ) "ssl_certificate" , http_options [ i + 1 ] = ssl_cert_path ; ssl_enabled = true ; } else { if ( stat_rc != 0 ) ntop -> getTrace ( ) -> traceEvent ( TRACE_NORMAL , "HTTPS Disabled: missing SSL certificate %s" , ssl_cert_path ) ; ntop -> getTrace ( ) -> traceEvent ( TRACE_NORMAL , "Please read https://github.com/ntop/ntopng/blob/dev/doc/README.SSL if you want to enable SSL." ) ; ssl_enabled = false ; } if ( use_http && ntop -> getPrefs ( ) -> get_alt_http_port ( ) ) { snprintf ( & ports [ strlen ( ports ) ] , sizeof ( ports ) - strlen ( ports ) - 1 , ",%s%s%d" , http_binding_addr , ( http_binding_addr [ 0 ] == '\0' ) ? "" : ":" , ntop -> getPrefs ( ) -> get_alt_http_port ( ) ) ; } if ( ( ! use_http ) && ( ! use_ssl ) & ( ! ssl_enabled ) ) { if ( stat_rc != 0 ) ntop -> getTrace ( ) -> traceEvent ( TRACE_WARNING , "Unable to start HTTP server: HTTP is disabled and the SSL certificate is missing." ) ; ntop -> getTrace ( ) -> traceEvent ( TRACE_WARNING , "Starting the HTTP server on the default port" ) ; snprintf ( ports , sizeof ( ports ) , "%d" , ntop -> getPrefs ( ) -> get_http_port ( ) ) ; use_http = true ; } ntop -> getRedis ( ) -> get ( ( char * ) SPLASH_HTTP_PORT , tmpBuf , sizeof ( tmpBuf ) , true ) ; if ( tmpBuf [ 0 ] != '\0' ) { http_splash_port = atoi ( tmpBuf ) ; if ( http_splash_port > 0 ) { snprintf ( & ports [ strlen ( ports ) ] , sizeof ( ports ) - strlen ( ports ) - 1 , ",%s%s%d" , http_binding_addr , ( http_binding_addr [ 0 ] == '\0' ) ? "" : ":" , http_splash_port ) ; http_splash_port = ntohs ( http_splash_port ) ; } else ntop -> getTrace ( ) -> traceEvent ( TRACE_WARNING , "Ignoring HTTP splash port (%s)" , tmpBuf ) ; } else http_splash_port = 0 ; if ( ntop -> getPrefs ( ) -> is_access_log_enabled ( ) ) { int i ; snprintf ( access_log_path , sizeof ( access_log_path ) , "%s/ntopng_access.log" , ntop -> get_working_dir ( ) ) ; for ( i = 0 ; http_options [ i ] != NULL ; i ++ ) ; http_options [ i ] = ( char * ) "access_log_file" , http_options [ i + 1 ] = access_log_path ; ntop -> getTrace ( ) -> traceEvent ( TRACE_NORMAL , "HTTP logs will be stored on %s" , access_log_path ) ; } memset ( & callbacks , 0 , sizeof ( callbacks ) ) ; callbacks . begin_request = handle_lua_request ; callbacks . log_message = handle_http_message ; http_prefix = ntop -> getPrefs ( ) -> get_http_prefix ( ) , http_prefix_len = strlen ( ntop -> getPrefs ( ) -> get_http_prefix ( ) ) ; httpd_v4 = mg_start ( & callbacks , NULL , ( const char * * ) http_options ) ; if ( httpd_v4 == NULL ) { ntop -> getTrace ( ) -> traceEvent ( TRACE_ERROR , "Unable to start HTTP server (IPv4) on ports %s" , ports ) ; if ( errno ) ntop -> getTrace ( ) -> traceEvent ( TRACE_ERROR , "%s" , strerror ( errno ) ) ; exit ( - 1 ) ; } ntop -> getTrace ( ) -> traceEvent ( TRACE_NORMAL , "Web server dirs [%s][%s]" , docs_dir , scripts_dir ) ; if ( use_http ) ntop -> getTrace ( ) -> traceEvent ( TRACE_NORMAL , "HTTP server listening on port(s) %s" , ports ) ; if ( use_ssl & ssl_enabled ) ntop -> getTrace ( ) -> traceEvent ( TRACE_NORMAL , "HTTPS server listening on port %d" , ntop -> getPrefs ( ) -> get_https_port ( ) ) ; } ;
lyd_new_output_leaf ( struct lyd_node * parent , const struct lys_module * module , const char * name , const char * val_str ) { const struct lys_node * snode = NULL , * siblings ; if ( ( ! parent && ! module ) || ! name ) { LOGARG ; return NULL ; } siblings = lyd_new_find_schema ( parent , module , 1 ) ; if ( ! siblings ) { LOGARG ; return NULL ; } if ( lys_getnext_data ( module , lys_parent ( siblings ) , name , strlen ( name ) , LYS_LEAFLIST | LYS_LEAF , & snode ) || ! snode ) { LOGERR ( siblings -> module -> ctx , LY_EINVAL , "Failed to find \"%s\" as a sibling to \"%s:%s\"." , name , lys_node_module ( siblings ) -> name , siblings -> name ) ; return NULL ; } return _lyd_new_leaf ( parent , snode , val_str , 0 , 0 ) ; }
ReplaceRegExpCallback ( JSContext * cx , RegExpStatics * res , size_t count , void * p ) { ReplaceData & rdata = * static_cast < ReplaceData * > ( p ) ; rdata . calledBack = true ; size_t leftoff = rdata . leftIndex ; size_t leftlen = res -> matchStart ( ) - leftoff ; rdata . leftIndex = res -> matchLimit ( ) ; size_t replen = 0 ; if ( ! FindReplaceLength ( cx , res , rdata , & replen ) ) return false ; size_t growth = leftlen + replen ; if ( ! rdata . sb . reserve ( rdata . sb . length ( ) + growth ) ) return false ; JSLinearString & str = rdata . str -> asLinear ( ) ; const jschar * left = str . chars ( ) + leftoff ; rdata . sb . infallibleAppend ( left , leftlen ) ; DoReplace ( res , rdata ) ; return true ; }
void SetSnapshotFromFile ( StartupData * snapshot_blob ) { base :: LockGuard < base :: Mutex > lock_guard ( external_startup_data_mutex . Pointer ( ) ) ; DCHECK ( snapshot_blob ) ; DCHECK ( snapshot_blob -> data ) ; DCHECK_GT ( snapshot_blob -> raw_size , 0 ) ; DCHECK ( ! external_startup_blob . data ) ; DCHECK ( Snapshot :: SnapshotIsValid ( snapshot_blob ) ) ; external_startup_blob = * snapshot_blob ; }
static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , u64 nr , int nmi , struct perf_sample_data * data , struct pt_regs * regs ) { struct swevent_htable * swhash = & __get_cpu_var ( swevent_htable ) ; struct perf_event * event ; struct hlist_node * node ; struct hlist_head * head ; rcu_read_lock ( ) ; head = find_swevent_head_rcu ( swhash , type , event_id ) ; if ( ! head ) goto end ; hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { if ( perf_swevent_match ( event , type , event_id , data , regs ) ) perf_swevent_event ( event , nr , nmi , data , regs ) ; } end : rcu_read_unlock ( ) ; }
static char * parse_note ( char * p , int flags ) { struct SYMBOL * s ; char * q ; int pit = 0 , len , acc , nostem , chord , j , m , n ; if ( flags & ABC_F_GRACE ) { s = abc_new ( ABC_T_NOTE , NULL ) ; } else { s = abc_new ( ABC_T_NOTE , gchord ) ; if ( gchord ) gchord = NULL ; } s -> flags |= flags ; s -> u . note . notes [ 0 ] . color = - 1 ; if ( ! lyric_started ) { lyric_started = 1 ; s -> flags |= ABC_F_LYRIC_START ; } if ( * p != 'X' && * p != 'Z' && ! ( flags & ABC_F_GRACE ) ) { if ( ! deco_start ) deco_start = s ; } chord = 0 ; switch ( * p ) { case 'X' : s -> flags |= ABC_F_INVIS ; case 'Z' : s -> abc_type = ABC_T_MREST ; p ++ ; len = 1 ; if ( isdigit ( ( unsigned char ) * p ) ) { len = strtol ( p , & q , 10 ) ; if ( len == 0 || len > 100 ) { syntax ( "Bad number of measures" , p ) ; len = 1 ; } p = q ; } s -> u . bar . type = 0 ; s -> u . bar . len = len ; goto add_deco ; case 'y' : s -> abc_type = ABC_T_REST ; s -> flags |= ABC_F_INVIS ; p ++ ; if ( isdigit ( ( unsigned char ) * p ) || * p == '-' ) { s -> u . note . notes [ 0 ] . shhd = strtol ( p , & q , 10 ) ; p = q ; } else { s -> u . note . notes [ 0 ] . shhd = 10 ; } goto add_deco ; case 'x' : s -> flags |= ABC_F_INVIS ; case 'z' : s -> abc_type = ABC_T_REST ; p = parse_len ( p + 1 , ulen , & len ) ; s -> u . note . notes [ 0 ] . len = len ; goto do_brhythm ; case '[' : chord = 1 ; p ++ ; break ; } q = p ; m = 0 ; nostem = 0 ; for ( ; ; ) { if ( chord ) { if ( m >= MAXHD ) { syntax ( "Too many notes in chord" , p ) ; m -- ; } n = 0 ; if ( * p == '.' ) { n = SL_DOTTED ; p ++ ; } if ( * p == '(' ) { p ++ ; switch ( * p ) { case '\'' : n += SL_ABOVE ; p ++ ; break ; case ',' : n += SL_BELOW ; p ++ ; break ; default : n += SL_AUTO ; break ; } s -> u . note . notes [ m ] . sl1 = ( s -> u . note . notes [ m ] . sl1 < < 3 ) + n ; } } p = parse_deco ( p , & dc , m ) ; p = parse_acc_pit ( p , & pit , & acc ) ; if ( * p == '0' ) { nostem = 1 ; p ++ ; } p = parse_len ( p , ( flags & ABC_F_GRACE ) ? BASE_LEN / 8 : ulen , & len ) ; s -> u . note . notes [ m ] . pit = pit ; s -> pits [ m ] = pit ; s -> u . note . notes [ m ] . len = len ; s -> u . note . notes [ m ] . acc = acc ; s -> u . note . notes [ m ] . color = - 1 ; if ( chord ) { for ( ; ; ) { if ( * p == '.' ) { if ( p [ 1 ] != '-' ) break ; p ++ ; } if ( * p == '-' ) { switch ( p [ 1 ] ) { case '\'' : s -> u . note . notes [ m ] . ti1 = SL_ABOVE ; p ++ ; break ; case ',' : s -> u . note . notes [ m ] . ti1 = SL_BELOW ; p ++ ; break ; default : s -> u . note . notes [ m ] . ti1 = SL_AUTO ; break ; } } else if ( * p == ')' ) { s -> u . note . notes [ m ] . sl2 ++ ; } else { break ; } p ++ ; } } if ( acc >= 0 ) m ++ ; if ( ! chord ) break ; if ( * p == ']' ) { p ++ ; if ( * p == '0' ) { nostem = 1 ; p ++ ; } if ( * p == '/' || isdigit ( ( unsigned char ) * p ) ) { p = parse_len ( p , ulen , & len ) ; for ( j = 0 ; j < m ; j ++ ) { s -> u . note . notes [ j ] . len = len * s -> u . note . notes [ j ] . len / ulen ; } } break ; } if ( * p == '\0' ) { syntax ( "Chord not closed" , q ) ; break ; } } if ( nostem ) s -> flags |= ABC_F_STEMLESS ; if ( m == 0 ) goto err ; s -> u . note . microscale = microscale ; s -> nhd = m - 1 ; do_brhythm : if ( curvoice -> last_note && curvoice -> last_note -> u . note . brhythm != 0 ) broken_rhythm ( s , - curvoice -> last_note -> u . note . brhythm ) ; add_deco : if ( dc . n > 0 ) { memcpy ( s -> abc_type != ABC_T_MREST ? & s -> u . note . dc : & s -> u . bar . dc , & dc , sizeof dc ) ; dc . n = 0 ; } if ( s -> abc_type != ABC_T_NOTE && ( flags & ABC_F_GRACE ) ) { syntax ( "Not a note in grace note sequence" , p ) ; goto err ; } return p ; err : if ( ( parse . last_sym = s -> abc_prev ) == NULL ) { parse . first_sym = NULL ; } else { s -> abc_prev -> abc_next = NULL ; s -> abc_prev -> flags |= ( s -> flags & ABC_F_ERROR ) ; } return p ; }
static struct dir * squashfs_opendir ( unsigned int block_start , unsigned int offset , struct inode * * i ) { squashfs_dir_header_3 dirh ; char buffer [ sizeof ( squashfs_dir_entry_3 ) + SQUASHFS_NAME_LEN + 1 ] __attribute__ ( ( aligned ) ) ; squashfs_dir_entry_3 * dire = ( squashfs_dir_entry_3 * ) buffer ; long long start ; int bytes ; int dir_count , size ; struct dir_ent * new_dir ; struct dir * dir ; TRACE ( "squashfs_opendir: inode start block %d, offset %d\n" , block_start , offset ) ; * i = read_inode ( block_start , offset ) ; dir = malloc ( sizeof ( struct dir ) ) ; if ( dir == NULL ) EXIT_UNSQUASH ( "squashfs_opendir: malloc failed!\n" ) ; dir -> dir_count = 0 ; dir -> cur_entry = 0 ; dir -> mode = ( * i ) -> mode ; dir -> uid = ( * i ) -> uid ; dir -> guid = ( * i ) -> gid ; dir -> mtime = ( * i ) -> time ; dir -> xattr = ( * i ) -> xattr ; dir -> dirs = NULL ; if ( ( * i ) -> data == 3 ) return dir ; start = sBlk . s . directory_table_start + ( * i ) -> start ; bytes = lookup_entry ( directory_table_hash , start ) ; if ( bytes == - 1 ) EXIT_UNSQUASH ( "squashfs_opendir: directory block %d not " "found!\n" , block_start ) ; bytes += ( * i ) -> offset ; size = ( * i ) -> data + bytes - 3 ; while ( bytes < size ) { if ( swap ) { squashfs_dir_header_3 sdirh ; memcpy ( & sdirh , directory_table + bytes , sizeof ( sdirh ) ) ; SQUASHFS_SWAP_DIR_HEADER_3 ( & dirh , & sdirh ) ; } else memcpy ( & dirh , directory_table + bytes , sizeof ( dirh ) ) ; dir_count = dirh . count + 1 ; TRACE ( "squashfs_opendir: Read directory header @ byte position " "%d, %d directory entries\n" , bytes , dir_count ) ; bytes += sizeof ( dirh ) ; if ( dir_count > SQUASHFS_DIR_COUNT ) { ERROR ( "File system corrupted: too many entries in directory\n" ) ; goto corrupted ; } while ( dir_count -- ) { if ( swap ) { squashfs_dir_entry_3 sdire ; memcpy ( & sdire , directory_table + bytes , sizeof ( sdire ) ) ; SQUASHFS_SWAP_DIR_ENTRY_3 ( dire , & sdire ) ; } else memcpy ( dire , directory_table + bytes , sizeof ( * dire ) ) ; bytes += sizeof ( * dire ) ; if ( dire -> size >= SQUASHFS_NAME_LEN ) { ERROR ( "File system corrupted: filename too long\n" ) ; goto corrupted ; } memcpy ( dire -> name , directory_table + bytes , dire -> size + 1 ) ; dire -> name [ dire -> size + 1 ] = '\0' ; TRACE ( "squashfs_opendir: directory entry %s, inode " "%d:%d, type %d\n" , dire -> name , dirh . start_block , dire -> offset , dire -> type ) ; if ( ( dir -> dir_count % DIR_ENT_SIZE ) == 0 ) { new_dir = realloc ( dir -> dirs , ( dir -> dir_count + DIR_ENT_SIZE ) * sizeof ( struct dir_ent ) ) ; if ( new_dir == NULL ) EXIT_UNSQUASH ( "squashfs_opendir: " "realloc failed!\n" ) ; dir -> dirs = new_dir ; } strcpy ( dir -> dirs [ dir -> dir_count ] . name , dire -> name ) ; dir -> dirs [ dir -> dir_count ] . start_block = dirh . start_block ; dir -> dirs [ dir -> dir_count ] . offset = dire -> offset ; dir -> dirs [ dir -> dir_count ] . type = dire -> type ; dir -> dir_count ++ ; bytes += dire -> size + 1 ; } } return dir ; corrupted : free ( dir -> dirs ) ; free ( dir ) ; return NULL ; }
static int elo_probe ( struct hid_device * hdev , const struct hid_device_id * id ) { struct elo_priv * priv ; int ret ; struct usb_device * udev ; if ( ! hid_is_usb ( hdev ) ) return - EINVAL ; priv = kzalloc ( sizeof ( * priv ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ; INIT_DELAYED_WORK ( & priv -> work , elo_work ) ; udev = interface_to_usbdev ( to_usb_interface ( hdev -> dev . parent ) ) ; priv -> usbdev = usb_get_dev ( udev ) ; hid_set_drvdata ( hdev , priv ) ; ret = hid_parse ( hdev ) ; if ( ret ) { hid_err ( hdev , "parse failed\n" ) ; goto err_free ; } ret = hid_hw_start ( hdev , HID_CONNECT_DEFAULT ) ; if ( ret ) { hid_err ( hdev , "hw start failed\n" ) ; goto err_free ; } if ( elo_broken_firmware ( priv -> usbdev ) ) { hid_info ( hdev , "broken firmware found, installing workaround\n" ) ; queue_delayed_work ( wq , & priv -> work , ELO_PERIODIC_READ_INTERVAL ) ; } return 0 ; err_free : kfree ( priv ) ; return ret ; }
static void vp8_init_ctx ( vpx_codec_ctx_t * ctx , const vpx_codec_mmap_t * mmap ) { int i ; ctx -> priv = mmap -> base ; ctx -> priv -> sz = sizeof ( * ctx -> priv ) ; ctx -> priv -> iface = ctx -> iface ; ctx -> priv -> alg_priv = mmap -> base ; for ( i = 0 ; i < NELEMENTS ( ctx -> priv -> alg_priv -> mmaps ) ; i ++ ) ctx -> priv -> alg_priv -> mmaps [ i ] . id = vp8_mem_req_segs [ i ] . id ; ctx -> priv -> alg_priv -> mmaps [ 0 ] = * mmap ; ctx -> priv -> alg_priv -> si . sz = sizeof ( ctx -> priv -> alg_priv -> si ) ; ctx -> priv -> alg_priv -> decrypt_cb = NULL ; ctx -> priv -> alg_priv -> decrypt_state = NULL ; ctx -> priv -> init_flags = ctx -> init_flags ; if ( ctx -> config . dec ) { ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ; ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ; } }
void MetaData :: typed_data :: setData ( uint32_t type , const void * data , size_t size ) { clear ( ) ; mType = type ; allocateStorage ( size ) ; memcpy ( storage ( ) , data , size ) ; }
parse_memory ( VALUE klass , VALUE data , VALUE encoding ) { htmlParserCtxtPtr ctxt ; if ( NIL_P ( data ) ) { rb_raise ( rb_eArgError , "data cannot be nil" ) ; } if ( ! ( int ) RSTRING_LEN ( data ) ) { rb_raise ( rb_eRuntimeError , "data cannot be empty" ) ; } ctxt = htmlCreateMemoryParserCtxt ( StringValuePtr ( data ) , ( int ) RSTRING_LEN ( data ) ) ; if ( ctxt -> sax ) { xmlFree ( ctxt -> sax ) ; ctxt -> sax = NULL ; } if ( RTEST ( encoding ) ) { xmlCharEncodingHandlerPtr enc = xmlFindCharEncodingHandler ( StringValueCStr ( encoding ) ) ; if ( enc != NULL ) { xmlSwitchToEncoding ( ctxt , enc ) ; if ( ctxt -> errNo == XML_ERR_UNSUPPORTED_ENCODING ) { rb_raise ( rb_eRuntimeError , "Unsupported encoding %s" , StringValueCStr ( encoding ) ) ; } } } return Data_Wrap_Struct ( klass , NULL , deallocate , ctxt ) ; }
bool Channel :: ChannelImpl :: EnqueueHelloMessage ( ) { mozilla :: UniquePtr < Message > m = mozilla :: MakeUnique < Message > ( MSG_ROUTING_NONE , HELLO_MESSAGE_TYPE , IPC :: Message :: PRIORITY_NORMAL ) ; if ( ! m -> WriteInt ( GetCurrentProcessId ( ) ) ) { CloseHandle ( pipe_ ) ; pipe_ = INVALID_HANDLE_VALUE ; return false ; } OutputQueuePush ( m . release ( ) ) ; return true ; }
static int ___sys_recvmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned int flags , int nosec ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct iovec iovstack [ UIO_FASTIOV ] ; struct iovec * iov = iovstack ; unsigned long cmsg_ptr ; int err , total_len , len ; struct sockaddr_storage addr ; struct sockaddr __user * uaddr ; int __user * uaddr_len ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else { err = copy_msghdr_from_user ( msg_sys , msg ) ; if ( err ) return err ; } if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , GFP_KERNEL ) ; if ( ! iov ) goto out ; } uaddr = ( __force void __user * ) msg_sys -> msg_name ; uaddr_len = COMPAT_NAMELEN ( msg ) ; if ( MSG_CMSG_COMPAT & flags ) { err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; } else err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; cmsg_ptr = ( unsigned long ) msg_sys -> msg_control ; msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = ( nosec ? sock_recvmsg_nosec : sock_recvmsg ) ( sock , msg_sys , total_len , flags ) ; if ( err < 0 ) goto out_freeiov ; len = err ; if ( uaddr != NULL ) { err = move_addr_to_user ( & addr , msg_sys -> msg_namelen , uaddr , uaddr_len ) ; if ( err < 0 ) goto out_freeiov ; } err = __put_user ( ( msg_sys -> msg_flags & ~ MSG_CMSG_COMPAT ) , COMPAT_FLAGS ( msg ) ) ; if ( err ) goto out_freeiov ; if ( MSG_CMSG_COMPAT & flags ) err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg_compat -> msg_controllen ) ; else err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg -> msg_controllen ) ; if ( err ) goto out_freeiov ; err = len ; out_freeiov : if ( iov != iovstack ) kfree ( iov ) ; out : return err ; }
void TestGetSelectedTextReply ( GURL url , bool expect_success ) { ui_test_utils :: NavigateToURL ( browser ( ) , url ) ; content :: WebContents * web_contents = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ; ASSERT_TRUE ( pdf_extension_test_util :: EnsurePDFHasLoaded ( web_contents ) ) ; content :: BrowserPluginGuestManager * guest_manager = web_contents -> GetBrowserContext ( ) -> GetGuestManager ( ) ; content :: WebContents * guest_contents = nullptr ; ASSERT_NO_FATAL_FAILURE ( guest_manager -> ForEachGuest ( web_contents , base :: Bind ( & GetGuestCallback , & guest_contents ) ) ) ; ASSERT_TRUE ( guest_contents ) ; ASSERT_TRUE ( content :: ExecuteScript ( guest_contents , "var oldSendScriptingMessage = " "    PDFViewer.prototype.sendScriptingMessage_;" "PDFViewer.prototype.sendScriptingMessage_ = function(message) {" "  oldSendScriptingMessage.bind(this)(message);" "  if (message.type == 'getSelectedTextReply')" "    this.parentWindow_.postMessage('flush', '*');" "}" ) ) ; bool success = false ; ASSERT_TRUE ( content :: ExecuteScriptAndExtractBool ( web_contents , "window.addEventListener('message', function(event) {" "  if (event.data == 'flush')" "    window.domAutomationController.send(false);" "  if (event.data.type == 'getSelectedTextReply')" "    window.domAutomationController.send(true);" "});" "document.getElementsByTagName('embed')[0].postMessage(" "    {type: 'getSelectedText'});" , & success ) ) ; ASSERT_EQ ( expect_success , success ) ; }
static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , "Bad return from REPLY_ADD_STA (0x%08X)\n" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , "Processing response for adding station %u\n" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , "REPLY_ADD_STA PASSED\n" ) ; iwl_sta_ucode_activate ( priv , sta_id ) ; ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , "Adding station %d failed, no room in table.\n" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , "Adding station %d failed, no block ack " "resource.\n" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , "Attempting to modify non-existing station %d\n" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , "Received REPLY_ADD_STA:(0x%08X)\n" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , "%s station id %u addr %pM\n" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? "Modified" : "Added" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , "%s station according to cmd buffer %pM\n" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? "Modified" : "Added" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }
NS_IMPL_ISUPPORTS ( MediaDevice , nsIMediaDevice ) MediaDevice :: MediaDevice ( const RefPtr < MediaEngineSource > & aSource , const nsString & aName , const nsString & aID , const nsString & aGroupID , const nsString & aRawID ) : mSource ( aSource ) , mSinkInfo ( nullptr ) , mKind ( ( mSource && MediaEngineSource :: IsVideo ( mSource -> GetMediaSource ( ) ) ) ? MediaDeviceKind :: Videoinput : MediaDeviceKind :: Audioinput ) , mScary ( mSource -> GetScary ( ) ) , mIsFake ( mSource -> IsFake ( ) ) , mType ( NS_ConvertASCIItoUTF16 ( dom :: MediaDeviceKindValues :: GetString ( mKind ) ) ) , mName ( aName ) , mID ( aID ) , mGroupID ( aGroupID ) , mRawID ( aRawID ) { MOZ_ASSERT ( mSource ) ; }
void __fastcall TSessionData :: Load ( THierarchicalStorage * Storage , bool PuttyImport ) { bool RewritePassword = false ; if ( Storage -> OpenSubKey ( InternalStorageKey , False ) ) { ClearSessionPasswords ( ) ; FProxyPassword = L"" ; DoLoad ( Storage , PuttyImport , RewritePassword ) ; Storage -> CloseSubKey ( ) ; } if ( RewritePassword ) { TStorageAccessMode AccessMode = Storage -> AccessMode ; Storage -> AccessMode = smReadWrite ; try { if ( Storage -> OpenSubKey ( InternalStorageKey , true ) ) { Storage -> DeleteValue ( L"PasswordPlain" ) ; if ( ! Password . IsEmpty ( ) ) { Storage -> WriteBinaryDataAsString ( L"Password" , FPassword ) ; } Storage -> DeleteValue ( L"TunnelPasswordPlain" ) ; if ( ! TunnelPassword . IsEmpty ( ) ) { Storage -> WriteBinaryDataAsString ( L"TunnelPassword" , FTunnelPassword ) ; } Storage -> DeleteValue ( L"EncryptKeyPlain" ) ; if ( ! EncryptKey . IsEmpty ( ) ) { Storage -> WriteBinaryDataAsString ( L"EncryptKey" , FEncryptKey ) ; } Storage -> CloseSubKey ( ) ; } } catch ( ... ) { } Storage -> AccessMode = AccessMode ; } FModified = false ; FSource = ssStored ; }
static int crypto_ccm_auth ( struct aead_request * req , struct scatterlist * plain , unsigned int cryptlen ) { struct crypto_ccm_req_priv_ctx * pctx = crypto_ccm_reqctx ( req ) ; struct crypto_aead * aead = crypto_aead_reqtfm ( req ) ; struct crypto_ccm_ctx * ctx = crypto_aead_ctx ( aead ) ; AHASH_REQUEST_ON_STACK ( ahreq , ctx -> mac ) ; unsigned int assoclen = req -> assoclen ; struct scatterlist sg [ 3 ] ; u8 odata [ 16 ] ; u8 idata [ 16 ] ; int ilen , err ; err = format_input ( odata , req , cryptlen ) ; if ( err ) goto out ; sg_init_table ( sg , 3 ) ; sg_set_buf ( & sg [ 0 ] , odata , 16 ) ; if ( assoclen ) { ilen = format_adata ( idata , assoclen ) ; sg_set_buf ( & sg [ 1 ] , idata , ilen ) ; sg_chain ( sg , 3 , req -> src ) ; } else { ilen = 0 ; sg_chain ( sg , 2 , req -> src ) ; } ahash_request_set_tfm ( ahreq , ctx -> mac ) ; ahash_request_set_callback ( ahreq , pctx -> flags , NULL , NULL ) ; ahash_request_set_crypt ( ahreq , sg , NULL , assoclen + ilen + 16 ) ; err = crypto_ahash_init ( ahreq ) ; if ( err ) goto out ; err = crypto_ahash_update ( ahreq ) ; if ( err ) goto out ; ilen = 16 - ( assoclen + ilen ) % 16 ; if ( ilen < 16 ) { memset ( idata , 0 , ilen ) ; sg_init_table ( sg , 2 ) ; sg_set_buf ( & sg [ 0 ] , idata , ilen ) ; if ( plain ) sg_chain ( sg , 2 , plain ) ; plain = sg ; cryptlen += ilen ; } ahash_request_set_crypt ( ahreq , plain , pctx -> odata , cryptlen ) ; err = crypto_ahash_finup ( ahreq ) ; out : return err ; }
TPM2B_Unmarshal ( TPM2B * target , UINT16 targetSize , BYTE * * buffer , INT32 * size ) { TPM_RC rc = TPM_RC_SUCCESS ; if ( rc == TPM_RC_SUCCESS ) { rc = UINT16_Unmarshal ( & target -> size , buffer , size ) ; } if ( rc == TPM_RC_SUCCESS ) { if ( target -> size > targetSize ) { rc = TPM_RC_SIZE ; } } if ( rc == TPM_RC_SUCCESS ) { rc = Array_Unmarshal ( target -> buffer , target -> size , buffer , size ) ; } return rc ; }
static int yam_siocdevprivate ( struct net_device * dev , struct ifreq * ifr , void __user * data , int cmd ) { struct yam_port * yp = netdev_priv ( dev ) ; struct yamdrv_ioctl_cfg yi ; struct yamdrv_ioctl_mcs * ym ; int ioctl_cmd ; if ( copy_from_user ( & ioctl_cmd , data , sizeof ( int ) ) ) return - EFAULT ; if ( yp -> magic != YAM_MAGIC ) return - EINVAL ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd != SIOCDEVPRIVATE ) return - EINVAL ; switch ( ioctl_cmd ) { case SIOCYAMRESERVED : return - EINVAL ; case SIOCYAMSMCS : if ( netif_running ( dev ) ) return - EINVAL ; ym = memdup_user ( data , sizeof ( struct yamdrv_ioctl_mcs ) ) ; if ( IS_ERR ( ym ) ) return PTR_ERR ( ym ) ; if ( ym -> cmd != SIOCYAMSMCS ) return - EINVAL ; if ( ym -> bitrate > YAM_MAXBITRATE ) { kfree ( ym ) ; return - EINVAL ; } add_mcs ( ym -> bits , ym -> bitrate , 0 ) ; kfree ( ym ) ; break ; case SIOCYAMSCFG : if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM ; if ( copy_from_user ( & yi , data , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; if ( yi . cmd != SIOCYAMSCFG ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_IOBASE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_IRQ ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BITRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BAUDRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( yi . cfg . mask & YAM_IOBASE ) { yp -> iobase = yi . cfg . iobase ; dev -> base_addr = yi . cfg . iobase ; } if ( yi . cfg . mask & YAM_IRQ ) { if ( yi . cfg . irq > 15 ) return - EINVAL ; yp -> irq = yi . cfg . irq ; dev -> irq = yi . cfg . irq ; } if ( yi . cfg . mask & YAM_BITRATE ) { if ( yi . cfg . bitrate > YAM_MAXBITRATE ) return - EINVAL ; yp -> bitrate = yi . cfg . bitrate ; } if ( yi . cfg . mask & YAM_BAUDRATE ) { if ( yi . cfg . baudrate > YAM_MAXBAUDRATE ) return - EINVAL ; yp -> baudrate = yi . cfg . baudrate ; } if ( yi . cfg . mask & YAM_MODE ) { if ( yi . cfg . mode > YAM_MAXMODE ) return - EINVAL ; yp -> dupmode = yi . cfg . mode ; } if ( yi . cfg . mask & YAM_HOLDDLY ) { if ( yi . cfg . holddly > YAM_MAXHOLDDLY ) return - EINVAL ; yp -> holdd = yi . cfg . holddly ; } if ( yi . cfg . mask & YAM_TXDELAY ) { if ( yi . cfg . txdelay > YAM_MAXTXDELAY ) return - EINVAL ; yp -> txd = yi . cfg . txdelay ; } if ( yi . cfg . mask & YAM_TXTAIL ) { if ( yi . cfg . txtail > YAM_MAXTXTAIL ) return - EINVAL ; yp -> txtail = yi . cfg . txtail ; } if ( yi . cfg . mask & YAM_PERSIST ) { if ( yi . cfg . persist > YAM_MAXPERSIST ) return - EINVAL ; yp -> pers = yi . cfg . persist ; } if ( yi . cfg . mask & YAM_SLOTTIME ) { if ( yi . cfg . slottime > YAM_MAXSLOTTIME ) return - EINVAL ; yp -> slot = yi . cfg . slottime ; yp -> slotcnt = yp -> slot / 10 ; } break ; case SIOCYAMGCFG : memset ( & yi , 0 , sizeof ( yi ) ) ; yi . cfg . mask = 0xffffffff ; yi . cfg . iobase = yp -> iobase ; yi . cfg . irq = yp -> irq ; yi . cfg . bitrate = yp -> bitrate ; yi . cfg . baudrate = yp -> baudrate ; yi . cfg . mode = yp -> dupmode ; yi . cfg . txdelay = yp -> txd ; yi . cfg . holddly = yp -> holdd ; yi . cfg . txtail = yp -> txtail ; yi . cfg . persist = yp -> pers ; yi . cfg . slottime = yp -> slot ; if ( copy_to_user ( data , & yi , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; break ; default : return - EINVAL ; } return 0 ; }
void KeyedStoreGenericAssembler :: TryRewriteElements ( Node * receiver , Node * receiver_map , Node * elements , Node * native_context , ElementsKind from_kind , ElementsKind to_kind , Label * bailout ) { DCHECK ( IsFastPackedElementsKind ( from_kind ) ) ; ElementsKind holey_from_kind = GetHoleyElementsKind ( from_kind ) ; ElementsKind holey_to_kind = GetHoleyElementsKind ( to_kind ) ; if ( AllocationSite :: ShouldTrack ( from_kind , to_kind ) ) { TrapAllocationMemento ( receiver , bailout ) ; } Label perform_transition ( this ) , check_holey_map ( this ) ; VARIABLE ( var_target_map , MachineRepresentation :: kTagged ) ; { Node * packed_map = LoadJSArrayElementsMap ( from_kind , native_context ) ; GotoIf ( WordNotEqual ( receiver_map , packed_map ) , & check_holey_map ) ; var_target_map . Bind ( LoadContextElement ( native_context , Context :: ArrayMapIndex ( to_kind ) ) ) ; Goto ( & perform_transition ) ; } BIND ( & check_holey_map ) ; { Node * holey_map = LoadContextElement ( native_context , Context :: ArrayMapIndex ( holey_from_kind ) ) ; GotoIf ( WordNotEqual ( receiver_map , holey_map ) , bailout ) ; var_target_map . Bind ( LoadContextElement ( native_context , Context :: ArrayMapIndex ( holey_to_kind ) ) ) ; Goto ( & perform_transition ) ; } BIND ( & perform_transition ) ; { if ( IsDoubleElementsKind ( from_kind ) != IsDoubleElementsKind ( to_kind ) ) { Node * capacity = SmiUntag ( LoadFixedArrayBaseLength ( elements ) ) ; GrowElementsCapacity ( receiver , elements , from_kind , to_kind , capacity , capacity , INTPTR_PARAMETERS , bailout ) ; } StoreMap ( receiver , var_target_map . value ( ) ) ; } }
void JSHeapBroker :: SerializeStandardObjects ( ) { Trace ( "Serializing standard objects.\n" ) ; Builtins * const b = isolate ( ) -> builtins ( ) ; Factory * const f = isolate ( ) -> factory ( ) ; GetOrCreateData ( f -> empty_fixed_array ( ) ) ; GetOrCreateData ( f -> block_context_map ( ) ) ; GetOrCreateData ( f -> catch_context_map ( ) ) ; GetOrCreateData ( f -> eval_context_map ( ) ) ; GetOrCreateData ( f -> fixed_array_map ( ) ) ; GetOrCreateData ( f -> fixed_double_array_map ( ) ) ; GetOrCreateData ( f -> function_context_map ( ) ) ; GetOrCreateData ( f -> many_closures_cell_map ( ) ) ; GetOrCreateData ( f -> mutable_heap_number_map ( ) ) ; GetOrCreateData ( f -> name_dictionary_map ( ) ) ; GetOrCreateData ( f -> one_pointer_filler_map ( ) ) ; GetOrCreateData ( f -> sloppy_arguments_elements_map ( ) ) ; GetOrCreateData ( f -> with_context_map ( ) ) ; GetOrCreateData ( f -> boolean_string ( ) ) ; GetOrCreateData ( f -> number_string ( ) ) ; GetOrCreateData ( f -> string_string ( ) ) ; GetOrCreateData ( f -> bigint_string ( ) ) ; GetOrCreateData ( f -> symbol_string ( ) ) ; GetOrCreateData ( f -> undefined_string ( ) ) ; GetOrCreateData ( f -> object_string ( ) ) ; GetOrCreateData ( f -> function_string ( ) ) ; GetOrCreateData ( f -> length_string ( ) ) ; Builtins :: Name builtins [ ] = { Builtins :: kArgumentsAdaptorTrampoline , Builtins :: kCallFunctionForwardVarargs , Builtins :: kStringAdd_CheckNone_NotTenured , Builtins :: kStringAdd_CheckNone_Tenured , Builtins :: kStringAdd_ConvertLeft_NotTenured , Builtins :: kStringAdd_ConvertRight_NotTenured , } ; for ( auto id : builtins ) { GetOrCreateData ( b -> builtin_handle ( id ) ) ; } for ( int32_t id = 0 ; id < Builtins :: builtin_count ; ++ id ) { if ( Builtins :: KindOf ( id ) == Builtins :: TFJ ) { GetOrCreateData ( b -> builtin_handle ( id ) ) ; } } Trace ( "Finished serializing standard objects.\n" ) ; }
TF_BUILTIN ( SetPrototypeDelete , CollectionsBuiltinsAssembler ) { Node * const receiver = Parameter ( Descriptor :: kReceiver ) ; Node * key = Parameter ( Descriptor :: kKey ) ; Node * const context = Parameter ( Descriptor :: kContext ) ; ThrowIfNotInstanceType ( context , receiver , JS_SET_TYPE , "Set.prototype.delete" ) ; TNode < OrderedHashSet > const table = CAST ( LoadObjectField ( receiver , JSMap :: kTableOffset ) ) ; VARIABLE ( entry_start_position_or_hash , MachineType :: PointerRepresentation ( ) , IntPtrConstant ( 0 ) ) ; Label entry_found ( this ) , not_found ( this ) ; TryLookupOrderedHashTableIndex < OrderedHashSet > ( table , key , context , & entry_start_position_or_hash , & entry_found , & not_found ) ; BIND ( & not_found ) ; Return ( FalseConstant ( ) ) ; BIND ( & entry_found ) ; StoreFixedArrayElement ( table , entry_start_position_or_hash . value ( ) , TheHoleConstant ( ) , UPDATE_WRITE_BARRIER , kPointerSize * OrderedHashSet :: kHashTableStartIndex ) ; TNode < Smi > const number_of_elements = SmiSub ( CAST ( LoadObjectField ( table , OrderedHashSet :: kNumberOfElementsOffset ) ) , SmiConstant ( 1 ) ) ; StoreObjectFieldNoWriteBarrier ( table , OrderedHashSet :: kNumberOfElementsOffset , number_of_elements ) ; TNode < Smi > const number_of_deleted = SmiAdd ( CAST ( LoadObjectField ( table , OrderedHashSet :: kNumberOfDeletedElementsOffset ) ) , SmiConstant ( 1 ) ) ; StoreObjectFieldNoWriteBarrier ( table , OrderedHashSet :: kNumberOfDeletedElementsOffset , number_of_deleted ) ; TNode < Smi > const number_of_buckets = CAST ( LoadFixedArrayElement ( table , OrderedHashSet :: kNumberOfBucketsIndex ) ) ; Label shrink ( this ) ; GotoIf ( SmiLessThan ( SmiAdd ( number_of_elements , number_of_elements ) , number_of_buckets ) , & shrink ) ; Return ( TrueConstant ( ) ) ; BIND ( & shrink ) ; CallRuntime ( Runtime :: kSetShrink , context , receiver ) ; Return ( TrueConstant ( ) ) ; }
Reduction MachineOperatorReducer :: ReduceWord32Shr ( Node * node ) { Uint32BinopMatcher m ( node ) ; if ( m . right ( ) . Is ( 0 ) ) return Replace ( m . left ( ) . node ( ) ) ; if ( m . IsFoldable ( ) ) { return ReplaceInt32 ( m . left ( ) . Value ( ) > > m . right ( ) . Value ( ) ) ; } if ( m . left ( ) . IsWord32And ( ) && m . right ( ) . HasValue ( ) ) { Uint32BinopMatcher mleft ( m . left ( ) . node ( ) ) ; if ( mleft . right ( ) . HasValue ( ) ) { uint32_t shift = m . right ( ) . Value ( ) & 0x1F ; uint32_t mask = mleft . right ( ) . Value ( ) ; if ( ( mask > > shift ) == 0 ) { return ReplaceInt32 ( 0 ) ; } } } return ReduceWord32Shifts ( node ) ; }
long VideoTrack :: Parse ( Segment * pSegment , const Info & info , long long element_start , long long element_size , VideoTrack * & pResult ) { if ( pResult ) return - 1 ; if ( info . type != Track :: kVideo ) return - 1 ; long long width = 0 ; long long height = 0 ; double rate = 0.0 ; IMkvReader * const pReader = pSegment -> m_pReader ; const Settings & s = info . settings ; assert ( s . start >= 0 ) ; assert ( s . size >= 0 ) ; long long pos = s . start ; assert ( pos >= 0 ) ; const long long stop = pos + s . size ; while ( pos < stop ) { long long id , size ; const long status = ParseElementHeader ( pReader , pos , stop , id , size ) ; if ( status < 0 ) return status ; if ( id == 0x30 ) { width = UnserializeUInt ( pReader , pos , size ) ; if ( width <= 0 ) return E_FILE_FORMAT_INVALID ; } else if ( id == 0x3A ) { height = UnserializeUInt ( pReader , pos , size ) ; if ( height <= 0 ) return E_FILE_FORMAT_INVALID ; } else if ( id == 0x0383E3 ) { const long status = UnserializeFloat ( pReader , pos , size , rate ) ; if ( status < 0 ) return status ; if ( rate <= 0 ) return E_FILE_FORMAT_INVALID ; } pos += size ; assert ( pos <= stop ) ; } assert ( pos == stop ) ; VideoTrack * const pTrack = new ( std :: nothrow ) VideoTrack ( pSegment , element_start , element_size ) ; if ( pTrack == NULL ) return - 1 ; const int status = info . Copy ( pTrack -> m_info ) ; if ( status ) { delete pTrack ; return status ; } pTrack -> m_width = width ; pTrack -> m_height = height ; pTrack -> m_rate = rate ; pResult = pTrack ; return 0 ; }
void nw_buf_free ( nw_buf_pool * pool , nw_buf * buf ) { if ( pool -> free < pool -> free_total ) { pool -> free_arr [ pool -> free ++ ] = buf ; } else { uint32_t new_free_total = pool -> free_total * 2 ; void * new_arr = realloc ( pool -> free_arr , new_free_total * sizeof ( nw_buf * ) ) ; if ( new_arr ) { pool -> free_total = new_free_total ; pool -> free_arr = new_arr ; pool -> free_arr [ pool -> free ++ ] = buf ; } else { free ( buf ) ; } } }
status_t SurfaceFlinger :: onLayerRemoved ( const sp < Client > & client , const sp < IBinder > & handle ) { Mutex :: Autolock _l ( mStateLock ) ; status_t err = NO_ERROR ; sp < Layer > l = fromHandle ( handle ) ; if ( l != nullptr || client -> isAttached ( handle ) ) { mInterceptor -> saveSurfaceDeletion ( l ) ; err = removeLayerLocked ( mStateLock , l ) ; ALOGE_IF ( err < 0 && err != NAME_NOT_FOUND , "error removing layer=%p (%s)" , l . get ( ) , strerror ( - err ) ) ; } return err ; }
void AllocateDevices ( ) { MOZ_ASSERT ( ! NS_IsMainThread ( ) ) ; MOZ_ASSERT ( mDeviceChosen ) ; LOG ( "GetUserMediaTask::Run()" ) ; nsresult rv ; const char * errorMsg = nullptr ; const char * badConstraint = nullptr ; if ( mAudioDevice ) { auto & constraints = GetInvariant ( mConstraints . mAudio ) ; rv = mAudioDevice -> Allocate ( constraints , mPrefs , mWindowID , & badConstraint ) ; if ( NS_FAILED ( rv ) ) { errorMsg = "Failed to allocate audiosource" ; if ( rv == NS_ERROR_NOT_AVAILABLE && ! badConstraint ) { nsTArray < RefPtr < MediaDevice > > devices ; devices . AppendElement ( mAudioDevice ) ; badConstraint = MediaConstraintsHelper :: SelectSettings ( NormalizedConstraints ( constraints ) , devices , mIsChrome ) ; } } } if ( ! errorMsg && mVideoDevice ) { auto & constraints = GetInvariant ( mConstraints . mVideo ) ; rv = mVideoDevice -> Allocate ( constraints , mPrefs , mWindowID , & badConstraint ) ; if ( NS_FAILED ( rv ) ) { errorMsg = "Failed to allocate videosource" ; if ( rv == NS_ERROR_NOT_AVAILABLE && ! badConstraint ) { nsTArray < RefPtr < MediaDevice > > devices ; devices . AppendElement ( mVideoDevice ) ; badConstraint = MediaConstraintsHelper :: SelectSettings ( NormalizedConstraints ( constraints ) , devices , mIsChrome ) ; } if ( mAudioDevice ) { mAudioDevice -> Deallocate ( ) ; } } else { if ( ! mIsChrome ) { if ( mShouldFocusSource ) { rv = mVideoDevice -> FocusOnSelectedSource ( ) ; if ( NS_FAILED ( rv ) ) { LOG ( "FocusOnSelectedSource failed" ) ; } } } } } if ( errorMsg ) { LOG ( "%s %" PRIu32 , errorMsg , static_cast < uint32_t > ( rv ) ) ; if ( badConstraint ) { Fail ( MediaMgrError :: Name :: OverconstrainedError , ""_ns , NS_ConvertUTF8toUTF16 ( badConstraint ) ) ; } else { Fail ( MediaMgrError :: Name :: NotReadableError , nsCString ( errorMsg ) ) ; } NS_DispatchToMainThread ( NS_NewRunnableFunction ( "MediaManager::SendPendingGUMRequest" , [ ] ( ) { MediaManager * manager = MediaManager :: GetIfExists ( ) ; if ( ! manager ) { return ; } manager -> SendPendingGUMRequest ( ) ; } ) ) ; return ; } NS_DispatchToMainThread ( NewRunnableMethod ( "GetUserMediaTask::PrepareDOMStream" , this , & GetUserMediaTask :: PrepareDOMStream ) ) ; }
ion :: Invalidate ( types :: TypeCompartment & types , FreeOp * fop , const Vector < types :: RecompileInfo > & invalid , bool resetUses ) { IonSpew ( IonSpew_Invalidate , "Start invalidation." ) ; AutoFlushCache afc ( "Invalidate" ) ; bool anyInvalidation = false ; for ( size_t i = 0 ; i < invalid . length ( ) ; i ++ ) { const types :: CompilerOutput & co = * invalid [ i ] . compilerOutput ( types ) ; switch ( co . kind ( ) ) { case types :: CompilerOutput :: Ion : case types :: CompilerOutput :: ParallelIon : JS_ASSERT ( co . isValid ( ) ) ; IonSpew ( IonSpew_Invalidate , " Invalidate %s:%u, IonScript %p" , co . script -> filename ( ) , co . script -> lineno , co . ion ( ) ) ; co . ion ( ) -> incref ( ) ; anyInvalidation = true ; } } if ( ! anyInvalidation ) { IonSpew ( IonSpew_Invalidate , " No IonScript invalidation." ) ; return ; } for ( JitActivationIterator iter ( fop -> runtime ( ) ) ; ! iter . done ( ) ; ++ iter ) InvalidateActivation ( fop , iter . jitTop ( ) , false ) ; for ( size_t i = 0 ; i < invalid . length ( ) ; i ++ ) { types :: CompilerOutput & co = * invalid [ i ] . compilerOutput ( types ) ; ExecutionMode executionMode = SequentialExecution ; switch ( co . kind ( ) ) { case types :: CompilerOutput :: Ion : break ; case types :: CompilerOutput :: ParallelIon : executionMode = ParallelExecution ; break ; } JS_ASSERT ( co . isValid ( ) ) ; JSScript * script = co . script ; IonScript * ionScript = GetIonScript ( script , executionMode ) ; Zone * zone = script -> zone ( ) ; if ( zone -> needsBarrier ( ) ) { IonScript :: Trace ( zone -> barrierTracer ( ) , ionScript ) ; } ionScript -> detachDependentAsmJSModules ( fop ) ; ionScript -> decref ( fop ) ; SetIonScript ( script , executionMode , NULL ) ; co . invalidate ( ) ; if ( resetUses && executionMode != ParallelExecution ) script -> resetUseCount ( ) ; } }
Maybe < std :: string > Intl :: CanonicalizeLanguageTag ( Isolate * isolate , Handle < Object > locale_in ) { Handle < String > locale_str ; if ( locale_in -> IsString ( ) ) { locale_str = Handle < String > :: cast ( locale_in ) ; } else if ( locale_in -> IsJSReceiver ( ) ) { ASSIGN_RETURN_ON_EXCEPTION_VALUE ( isolate , locale_str , Object :: ToString ( isolate , locale_in ) , Nothing < std :: string > ( ) ) ; } else { THROW_NEW_ERROR_RETURN_VALUE ( isolate , NewTypeError ( MessageTemplate :: kLanguageID ) , Nothing < std :: string > ( ) ) ; } std :: string locale ( locale_str -> ToCString ( ) . get ( ) ) ; if ( ( IsTwoLetterLanguage ( locale ) && ! IsDeprecatedLanguage ( locale ) ) || locale == "fil" ) { return Just ( locale ) ; } std :: transform ( locale . begin ( ) , locale . end ( ) , locale . begin ( ) , AsciiToLower ) ; if ( ! IsStructurallyValidLanguageTag ( isolate , locale ) ) { THROW_NEW_ERROR_RETURN_VALUE ( isolate , NewRangeError ( MessageTemplate :: kInvalidLanguageTag , locale_str ) , Nothing < std :: string > ( ) ) ; } if ( IsGrandfatheredTagWithoutPreferredVaule ( locale ) ) { return Just ( locale ) ; } UErrorCode error = U_ZERO_ERROR ; char icu_result [ ULOC_FULLNAME_CAPACITY ] ; uloc_forLanguageTag ( locale . c_str ( ) , icu_result , ULOC_FULLNAME_CAPACITY , nullptr , & error ) ; if ( U_FAILURE ( error ) || error == U_STRING_NOT_TERMINATED_WARNING ) { THROW_NEW_ERROR_RETURN_VALUE ( isolate , NewRangeError ( MessageTemplate :: kInvalidLanguageTag , locale_str ) , Nothing < std :: string > ( ) ) ; } char result [ ULOC_FULLNAME_CAPACITY ] ; int32_t result_len = uloc_toLanguageTag ( icu_result , result , ULOC_FULLNAME_CAPACITY , TRUE , & error ) ; if ( U_FAILURE ( error ) ) { THROW_NEW_ERROR_RETURN_VALUE ( isolate , NewRangeError ( MessageTemplate :: kInvalidLanguageTag , locale_str ) , Nothing < std :: string > ( ) ) ; } return Just ( std :: string ( result , result_len ) ) ; }
TfLiteStatus SimpleStatefulOp :: Invoke ( TfLiteContext * context , TfLiteNode * node ) { OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; * data -> invoke_count += 1 ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; const uint8_t * input_data = GetTensorData < uint8_t > ( input ) ; int size = NumElements ( input -> dims ) ; uint8_t * sorting_buffer = reinterpret_cast < uint8_t * > ( context -> GetScratchBuffer ( context , data -> sorting_buffer ) ) ; for ( int i = 0 ; i < size ; i ++ ) { sorting_buffer [ i ] = input_data [ i ] ; } for ( int i = 1 ; i < size ; i ++ ) { for ( int j = i ; j > 0 && sorting_buffer [ j ] < sorting_buffer [ j - 1 ] ; j -- ) { std :: swap ( sorting_buffer [ j ] , sorting_buffer [ j - 1 ] ) ; } } TfLiteTensor * median = GetOutput ( context , node , kMedianTensor ) ; uint8_t * median_data = GetTensorData < uint8_t > ( median ) ; TfLiteTensor * invoke_count = GetOutput ( context , node , kInvokeCount ) ; int32_t * invoke_count_data = GetTensorData < int32_t > ( invoke_count ) ; median_data [ 0 ] = sorting_buffer [ size / 2 ] ; invoke_count_data [ 0 ] = * data -> invoke_count ; return kTfLiteOk ; }
TF_BUILTIN ( TypedArrayPrototypeByteOffset , TypedArrayBuiltinsAssembler ) { Node * context = Parameter ( Descriptor :: kContext ) ; Node * receiver = Parameter ( Descriptor :: kReceiver ) ; GenerateTypedArrayPrototypeGetter ( context , receiver , "get TypedArray.prototype.byteOffset" , JSTypedArray :: kByteOffsetOffset ) ; }
void DeclarationVisitor :: Visit ( SpecializationDeclaration * decl ) { if ( ( decl -> body != nullptr ) == decl -> external ) { std :: stringstream stream ; stream < < "specialization of " < < decl -> name < < " must either be marked 'extern' or have a body" ; ReportError ( stream . str ( ) ) ; } GenericList * generic_list = declarations ( ) -> LookupGeneric ( decl -> name ) ; CallableNode * matching_callable = nullptr ; SpecializationKey matching_key ; Signature signature_with_types = MakeSignature ( decl -> signature . get ( ) ) ; for ( Generic * generic : generic_list -> list ( ) ) { SpecializationKey key = { generic , GetTypeVector ( decl -> generic_parameters ) } ; CallableNode * callable_candidate = generic -> declaration ( ) -> callable ; Declarations :: CleanNodeScopeActivator specialization_activator ( declarations ( ) , decl ) ; DeclareSpecializedTypes ( key ) ; Signature generic_signature_with_types = MakeSignature ( generic -> declaration ( ) -> callable -> signature . get ( ) ) ; if ( signature_with_types . HasSameTypesAs ( generic_signature_with_types ) ) { if ( matching_callable != nullptr ) { std :: stringstream stream ; stream < < "specialization of " < < callable_candidate -> name < < " is ambigous, it matches more than one generic declaration (" < < * matching_key . first < < " and " < < * key . first < < ")" ; ReportError ( stream . str ( ) ) ; } matching_callable = callable_candidate ; matching_key = key ; } } if ( matching_callable == nullptr ) { std :: stringstream stream ; stream < < "specialization of " < < decl -> name < < " doesn't match any generic declaration" ; ReportError ( stream . str ( ) ) ; } { Declarations :: CleanNodeScopeActivator specialization_activator ( declarations ( ) , decl ) ; DeclareSpecializedTypes ( matching_key ) ; } SpecializeGeneric ( { matching_key , matching_callable , decl -> signature . get ( ) , decl -> body , decl -> pos } ) ; }
status_t OMXNodeInstance :: allocateBufferWithBackup ( OMX_U32 portIndex , const sp < IMemory > & params , OMX :: buffer_id * buffer , OMX_U32 allottedSize ) { if ( params == NULL || buffer == NULL ) { ALOGE ( "b/25884056" ) ; return BAD_VALUE ; } Mutex :: Autolock autoLock ( mLock ) ; if ( allottedSize > params -> size ( ) || portIndex >= NELEM ( mNumPortBuffers ) ) { return BAD_VALUE ; } bool copy = mMetadataType [ portIndex ] == kMetadataBufferTypeInvalid ; BufferMeta * buffer_meta = new BufferMeta ( params , portIndex , ( portIndex == kPortIndexInput ) && copy , ( portIndex == kPortIndexOutput ) && copy , NULL ) ; OMX_BUFFERHEADERTYPE * header ; OMX_ERRORTYPE err = OMX_AllocateBuffer ( mHandle , & header , portIndex , buffer_meta , allottedSize ) ; if ( err != OMX_ErrorNone ) { CLOG_ERROR ( allocateBufferWithBackup , err , SIMPLE_BUFFER ( portIndex , ( size_t ) allottedSize , params -> pointer ( ) ) ) ; delete buffer_meta ; buffer_meta = NULL ; * buffer = 0 ; return StatusFromOMXError ( err ) ; } CHECK_EQ ( header -> pAppPrivate , buffer_meta ) ; * buffer = makeBufferID ( header ) ; addActiveBuffer ( portIndex , * buffer ) ; sp < GraphicBufferSource > bufferSource ( getGraphicBufferSource ( ) ) ; if ( bufferSource != NULL && portIndex == kPortIndexInput ) { bufferSource -> addCodecBuffer ( header ) ; } CLOG_BUFFER ( allocateBufferWithBackup , NEW_BUFFER_FMT ( * buffer , portIndex , "%zu@%p :> %u@%p" , params -> size ( ) , params -> pointer ( ) , allottedSize , header -> pBuffer ) ) ; return OK ; }
char * dexOptGenerateCacheFileName ( const char * fileName , const char * subFileName ) { char nameBuf [ 512 ] ; char absoluteFile [ sizeof ( nameBuf ) ] ; const size_t kBufLen = sizeof ( nameBuf ) - 1 ; const char * dataRoot ; char * cp ; absoluteFile [ 0 ] = '\0' ; if ( fileName [ 0 ] != '/' ) { if ( getcwd ( absoluteFile , kBufLen ) == NULL ) { ALOGE ( "Can't get CWD while opening jar file" ) ; return NULL ; } strncat ( absoluteFile , "/" , kBufLen ) ; } strncat ( absoluteFile , fileName , kBufLen ) ; if ( subFileName != NULL ) { strncat ( absoluteFile , "/" , kBufLen ) ; strncat ( absoluteFile , subFileName , kBufLen ) ; } cp = absoluteFile + 1 ; while ( * cp != '\0' ) { if ( * cp == '/' ) { * cp = '@' ; } cp ++ ; } dataRoot = getenv ( "ANDROID_DATA" ) ; if ( dataRoot == NULL ) dataRoot = "/data" ; snprintf ( nameBuf , kBufLen , "%s/%s" , dataRoot , kCacheDirectoryName ) ; if ( strcmp ( dataRoot , "/data" ) != 0 ) { int result = dexOptMkdir ( nameBuf , 0700 ) ; if ( result != 0 && errno != EEXIST ) { ALOGE ( "Failed to create dalvik-cache directory %s: %s" , nameBuf , strerror ( errno ) ) ; return NULL ; } } snprintf ( nameBuf , kBufLen , "%s/%s/%s" , dataRoot , kCacheDirectoryName , kInstructionSet ) ; if ( strcmp ( dataRoot , "/data" ) != 0 ) { int result = dexOptMkdir ( nameBuf , 0700 ) ; if ( result != 0 && errno != EEXIST ) { ALOGE ( "Failed to create dalvik-cache directory %s: %s" , nameBuf , strerror ( errno ) ) ; return NULL ; } } strncat ( nameBuf , absoluteFile , kBufLen ) ; ALOGV ( "Cache file for '%s' '%s' is '%s'" , fileName , subFileName , nameBuf ) ; return strdup ( nameBuf ) ; }
void PrintLocation ( Variable * var ) { switch ( var -> location ( ) ) { case VariableLocation :: UNALLOCATED : break ; case VariableLocation :: PARAMETER : PrintF ( "parameter[%d]" , var -> index ( ) ) ; break ; case VariableLocation :: LOCAL : PrintF ( "local[%d]" , var -> index ( ) ) ; break ; case VariableLocation :: CONTEXT : PrintF ( "context[%d]" , var -> index ( ) ) ; break ; case VariableLocation :: LOOKUP : PrintF ( "lookup" ) ; break ; case VariableLocation :: MODULE : PrintF ( "module" ) ; break ; } }
void Scanner :: SeekNext ( size_t position ) { for ( TokenDesc & token : token_storage_ ) { token . token = Token :: UNINITIALIZED ; token . contextual_token = Token :: UNINITIALIZED ; } source_ -> Seek ( position ) ; c0_ = source_ -> Advance ( ) ; next ( ) . after_line_terminator = false ; Scan ( ) ; DCHECK_EQ ( next ( ) . location . beg_pos , static_cast < int > ( position ) ) ; }
void IncrementalMarkingJob :: Task :: RunInternal ( ) { VMState < GC > state ( isolate ( ) ) ; TRACE_EVENT_CALL_STATS_SCOPED ( isolate ( ) , "v8" , "V8.Task" ) ; Heap * heap = isolate ( ) -> heap ( ) ; IncrementalMarking * incremental_marking = heap -> incremental_marking ( ) ; if ( incremental_marking -> IsStopped ( ) ) { if ( heap -> IncrementalMarkingLimitReached ( ) != Heap :: IncrementalMarkingLimit :: kNoLimit ) { heap -> StartIncrementalMarking ( heap -> GCFlagsForIncrementalMarking ( ) , GarbageCollectionReason :: kIdleTask , kGCCallbackScheduleIdleGarbageCollection ) ; } } job_ -> task_pending_ = false ; if ( ! incremental_marking -> IsStopped ( ) ) { Step ( heap ) ; if ( ! incremental_marking -> IsStopped ( ) ) { job_ -> ScheduleTask ( heap ) ; } } }
inline bool Visit ( HeapObject * object , int size ) override { if ( TryEvacuateWithoutCopy ( object ) ) return true ; HeapObject * target_object = nullptr ; if ( heap_ -> ShouldBePromoted ( object -> address ( ) ) && TryEvacuateObject ( OLD_SPACE , object , size , & target_object ) ) { promoted_size_ += size ; return true ; } heap_ -> UpdateAllocationSite ( object -> map ( ) , object , local_pretenuring_feedback_ ) ; HeapObject * target = nullptr ; AllocationSpace space = AllocateTargetObject ( object , size , & target ) ; MigrateObject ( HeapObject :: cast ( target ) , object , size , space ) ; semispace_copied_size_ += size ; return true ; }
RUNTIME_FUNCTION ( Runtime_OptimizeOsr ) { HandleScope scope ( isolate ) ; DCHECK ( args . length ( ) == 0 || args . length ( ) == 1 ) ; Handle < JSFunction > function ; int stack_depth = args . length ( ) == 1 ? args . smi_at ( 0 ) : 0 ; JavaScriptFrameIterator it ( isolate ) ; while ( ! it . done ( ) && stack_depth -- ) it . Advance ( ) ; if ( ! it . done ( ) ) function = handle ( it . frame ( ) -> function ( ) , isolate ) ; if ( function . is_null ( ) ) return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; if ( function -> IsOptimized ( ) ) return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; if ( ! function -> HasOptimizedCode ( ) ) { if ( FLAG_trace_osr ) { PrintF ( "[OSR - OptimizeOsr marking " ) ; function -> ShortPrint ( ) ; PrintF ( " for non-concurrent optimization]\n" ) ; } function -> MarkForOptimization ( ConcurrencyMode :: kNotConcurrent ) ; } if ( it . frame ( ) -> type ( ) == StackFrame :: INTERPRETED ) { isolate -> runtime_profiler ( ) -> AttemptOnStackReplacement ( it . frame ( ) , AbstractCode :: kMaxLoopNestingMarker ) ; } return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
int mount_proc_if_needed ( const char * rootfs ) { char path [ MAXPATHLEN ] ; char link [ 20 ] ; int linklen , ret ; int mypid ; ret = snprintf ( path , MAXPATHLEN , "%s/proc/self" , rootfs ) ; if ( ret < 0 || ret >= MAXPATHLEN ) { SYSERROR ( "proc path name too long" ) ; return - 1 ; } memset ( link , 0 , 20 ) ; linklen = readlink ( path , link , 20 ) ; mypid = ( int ) getpid ( ) ; INFO ( "I am %d, /proc/self points to '%s'" , mypid , link ) ; ret = snprintf ( path , MAXPATHLEN , "%s/proc" , rootfs ) ; if ( ret < 0 || ret >= MAXPATHLEN ) { SYSERROR ( "proc path name too long" ) ; return - 1 ; } if ( linklen < 0 ) goto domount ; if ( atoi ( link ) != mypid ) { umount2 ( path , MNT_DETACH ) ; goto domount ; } return 0 ; domount : if ( mount ( "proc" , path , "proc" , 0 , NULL ) ) return - 1 ; INFO ( "Mounted /proc in container for security transition" ) ; return 1 ; }
DLLEXPORT int tjDestroy ( tjhandle handle ) { getinstance ( handle ) ; if ( setjmp ( this -> jerr . setjmp_buffer ) ) return - 1 ; if ( this -> init & COMPRESS ) jpeg_destroy_compress ( cinfo ) ; if ( this -> init & DECOMPRESS ) jpeg_destroy_decompress ( dinfo ) ; free ( this ) ; return 0 ; }
void Schedule :: AddThrow ( BasicBlock * block , Node * input ) { DCHECK_EQ ( BasicBlock :: kNone , block -> control ( ) ) ; block -> set_control ( BasicBlock :: kThrow ) ; SetControlInput ( block , input ) ; if ( block != end ( ) ) AddSuccessor ( block , end ( ) ) ; }
usage ( void ) { fprintf ( stderr , "usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\n" "                 [-t life] [command [arg ...]]\n" "       ssh-agent [-c | -s] -k\n" ) ; exit ( 1 ) ; }
void Builtins :: Generate_Call ( MacroAssembler * masm , ConvertReceiverMode mode ) { Label non_callable , non_function , non_smi ; __ JumpIfSmi ( a1 , & non_callable ) ; __ bind ( & non_smi ) ; __ GetObjectType ( a1 , t1 , t2 ) ; __ Jump ( masm -> isolate ( ) -> builtins ( ) -> CallFunction ( mode ) , RelocInfo :: CODE_TARGET , eq , t2 , Operand ( JS_FUNCTION_TYPE ) ) ; __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , CallBoundFunction ) , RelocInfo :: CODE_TARGET , eq , t2 , Operand ( JS_BOUND_FUNCTION_TYPE ) ) ; __ lbu ( t1 , FieldMemOperand ( t1 , Map :: kBitFieldOffset ) ) ; __ And ( t1 , t1 , Operand ( Map :: IsCallableBit :: kMask ) ) ; __ Branch ( & non_callable , eq , t1 , Operand ( zero_reg ) ) ; __ Branch ( & non_function , ne , t2 , Operand ( JS_PROXY_TYPE ) ) ; __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , CallProxy ) , RelocInfo :: CODE_TARGET ) ; __ bind ( & non_function ) ; __ Lsa ( kScratchReg , sp , a0 , kPointerSizeLog2 ) ; __ sw ( a1 , MemOperand ( kScratchReg ) ) ; __ LoadNativeContextSlot ( Context :: CALL_AS_FUNCTION_DELEGATE_INDEX , a1 ) ; __ Jump ( masm -> isolate ( ) -> builtins ( ) -> CallFunction ( ConvertReceiverMode :: kNotNullOrUndefined ) , RelocInfo :: CODE_TARGET ) ; __ bind ( & non_callable ) ; { FrameScope scope ( masm , StackFrame :: INTERNAL ) ; __ Push ( a1 ) ; __ CallRuntime ( Runtime :: kThrowCalledNonCallable ) ; } }
Type OperationTyper :: MultiplyRanger ( Type lhs , Type rhs ) { double results [ 4 ] ; double lmin = lhs . AsRange ( ) -> Min ( ) ; double lmax = lhs . AsRange ( ) -> Max ( ) ; double rmin = rhs . AsRange ( ) -> Min ( ) ; double rmax = rhs . AsRange ( ) -> Max ( ) ; results [ 0 ] = lmin * rmin ; results [ 1 ] = lmin * rmax ; results [ 2 ] = lmax * rmin ; results [ 3 ] = lmax * rmax ; bool maybe_nan = ( lhs . Maybe ( cache_ . kSingletonZero ) && ( rmin == - V8_INFINITY || rmax == + V8_INFINITY ) ) || ( rhs . Maybe ( cache_ . kSingletonZero ) && ( lmin == - V8_INFINITY || lmax == + V8_INFINITY ) ) ; if ( maybe_nan ) return cache_ . kIntegerOrMinusZeroOrNaN ; bool maybe_minuszero = ( lhs . Maybe ( cache_ . kSingletonZero ) && rmin < 0 ) || ( rhs . Maybe ( cache_ . kSingletonZero ) && lmin < 0 ) ; Type range = Type :: Range ( array_min ( results , 4 ) , array_max ( results , 4 ) , zone ( ) ) ; return maybe_minuszero ? Type :: Union ( range , Type :: MinusZero ( ) , zone ( ) ) : range ; }
GlobalHelperThreadState :: finishParseTask ( JSContext * maybecx , JSRuntime * rt , void * token ) { ScopedJSDeletePtr < ParseTask > parseTask ; { AutoLockHelperThreadState lock ; ParseTaskVector & finished = parseFinishedList ( ) ; for ( size_t i = 0 ; i < finished . length ( ) ; i ++ ) { if ( finished [ i ] == token ) { parseTask = finished [ i ] ; remove ( finished , & i ) ; break ; } } } MOZ_ASSERT ( parseTask ) ; if ( ! maybecx ) { LeaveParseTaskZone ( rt , parseTask ) ; return nullptr ; } JSContext * cx = maybecx ; MOZ_ASSERT ( cx -> compartment ( ) ) ; Rooted < GlobalObject * > global ( cx , & cx -> global ( ) -> as < GlobalObject > ( ) ) ; if ( ! EnsureConstructor ( cx , global , JSProto_Object ) || ! EnsureConstructor ( cx , global , JSProto_Array ) || ! EnsureConstructor ( cx , global , JSProto_Function ) || ! EnsureConstructor ( cx , global , JSProto_RegExp ) || ! EnsureConstructor ( cx , global , JSProto_Iterator ) ) { LeaveParseTaskZone ( rt , parseTask ) ; return nullptr ; } mergeParseTaskCompartment ( rt , parseTask , global , cx -> compartment ( ) ) ; if ( ! parseTask -> finish ( cx ) ) return nullptr ; RootedScript script ( rt , parseTask -> script ) ; assertSameCompartment ( cx , script ) ; for ( size_t i = 0 ; i < parseTask -> errors . length ( ) ; i ++ ) parseTask -> errors [ i ] -> throwError ( cx ) ; if ( parseTask -> overRecursed ) ReportOverRecursed ( cx ) ; if ( cx -> isExceptionPending ( ) ) return nullptr ; if ( script ) { Debugger :: onNewScript ( cx , script ) ; if ( script -> scriptSource ( ) -> hasCompressedSource ( ) ) script -> scriptSource ( ) -> updateCompressedSourceSet ( rt ) ; } return script ; }
bool IsCompatible ( MachineRepresentation expected , MachineRepresentation actual ) { switch ( expected ) { case MachineRepresentation :: kTagged : return ( actual == MachineRepresentation :: kTagged || actual == MachineRepresentation :: kTaggedSigned || actual == MachineRepresentation :: kTaggedPointer ) ; case MachineRepresentation :: kTaggedSigned : case MachineRepresentation :: kTaggedPointer : case MachineRepresentation :: kFloat32 : case MachineRepresentation :: kFloat64 : case MachineRepresentation :: kSimd128 : case MachineRepresentation :: kBit : case MachineRepresentation :: kWord8 : case MachineRepresentation :: kWord16 : case MachineRepresentation :: kWord64 : return expected == actual ; break ; case MachineRepresentation :: kWord32 : return ( actual == MachineRepresentation :: kBit || actual == MachineRepresentation :: kWord8 || actual == MachineRepresentation :: kWord16 || actual == MachineRepresentation :: kWord32 ) ; case MachineRepresentation :: kNone : UNREACHABLE ( ) ; } return false ; }
enum nss_status _nss_mymachines_getpwnam_r ( const char * name , struct passwd * pwd , char * buffer , size_t buflen , int * errnop ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; _cleanup_bus_message_unref_ sd_bus_message * reply = NULL ; _cleanup_bus_flush_close_unref_ sd_bus * bus = NULL ; const char * p , * e , * machine ; uint32_t mapped ; uid_t uid ; size_t l ; int r ; assert ( name ) ; assert ( pwd ) ; p = startswith ( name , "vu-" ) ; if ( ! p ) goto not_found ; e = strrchr ( p , '-' ) ; if ( ! e || e == p ) goto not_found ; r = parse_uid ( e + 1 , & uid ) ; if ( r < 0 ) goto not_found ; machine = strndupa ( p , e - p ) ; if ( ! machine_name_is_valid ( machine ) ) goto not_found ; r = sd_bus_open_system ( & bus ) ; if ( r < 0 ) goto fail ; r = sd_bus_call_method ( bus , "org.freedesktop.machine1" , "/org/freedesktop/machine1" , "org.freedesktop.machine1.Manager" , "MapFromMachineUser" , & error , & reply , "su" , machine , ( uint32_t ) uid ) ; if ( r < 0 ) { if ( sd_bus_error_has_name ( & error , BUS_ERROR_NO_SUCH_USER_MAPPING ) ) goto not_found ; goto fail ; } r = sd_bus_message_read ( reply , "u" , & mapped ) ; if ( r < 0 ) goto fail ; l = strlen ( name ) ; if ( buflen < l + 1 ) { * errnop = ENOMEM ; return NSS_STATUS_TRYAGAIN ; } memcpy ( buffer , name , l + 1 ) ; pwd -> pw_name = buffer ; pwd -> pw_uid = mapped ; pwd -> pw_gid = 65534 ; pwd -> pw_gecos = buffer ; pwd -> pw_passwd = ( char * ) "*" ; pwd -> pw_dir = ( char * ) "/" ; pwd -> pw_shell = ( char * ) "/sbin/nologin" ; * errnop = 0 ; return NSS_STATUS_SUCCESS ; not_found : * errnop = 0 ; return NSS_STATUS_NOTFOUND ; fail : * errnop = - r ; return NSS_STATUS_UNAVAIL ; }
FeedbackSlot BytecodeGenerator :: GetCachedLoadICSlot ( const Expression * expr , const AstRawString * name ) { if ( ! FLAG_ignition_share_named_property_feedback ) { return feedback_spec ( ) -> AddLoadICSlot ( ) ; } FeedbackSlotKind slot_kind = FeedbackSlotKind :: kLoadProperty ; if ( ! expr -> IsVariableProxy ( ) ) { return feedback_spec ( ) -> AddLoadICSlot ( ) ; } const VariableProxy * proxy = expr -> AsVariableProxy ( ) ; FeedbackSlot slot = feedback_slot_cache ( ) -> Get ( slot_kind , proxy -> var ( ) -> index ( ) , name ) ; if ( ! slot . IsInvalid ( ) ) { return slot ; } slot = feedback_spec ( ) -> AddLoadICSlot ( ) ; feedback_slot_cache ( ) -> Put ( slot_kind , proxy -> var ( ) -> index ( ) , name , slot ) ; return slot ; }
long Chapters :: Edition :: Parse ( IMkvReader * pReader , long long pos , long long size ) { const long long stop = pos + size ; while ( pos < stop ) { long long id , size ; long status = ParseElementHeader ( pReader , pos , stop , id , size ) ; if ( status < 0 ) return status ; if ( size == 0 ) continue ; if ( id == 0x36 ) { status = ParseAtom ( pReader , pos , size ) ; if ( status < 0 ) return status ; } pos += size ; assert ( pos <= stop ) ; } assert ( pos == stop ) ; return 0 ; }
xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ; args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ; if ( retval ) return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }
void Builtins :: Generate_ReflectConstruct ( MacroAssembler * masm ) { { Label skip ; Register arg_size = r7 ; Register new_sp = r6 ; __ ShiftLeftP ( arg_size , r2 , Operand ( kPointerSizeLog2 ) ) ; __ AddP ( new_sp , sp , arg_size ) ; __ LoadRoot ( r3 , Heap :: kUndefinedValueRootIndex ) ; __ LoadRR ( r4 , r3 ) ; __ LoadRR ( r5 , r3 ) ; __ StoreP ( r3 , MemOperand ( new_sp , 0 ) ) ; __ CmpP ( arg_size , Operand ( kPointerSize ) ) ; __ blt ( & skip ) ; __ LoadP ( r3 , MemOperand ( new_sp , 1 * - kPointerSize ) ) ; __ LoadRR ( r5 , r3 ) ; __ beq ( & skip ) ; __ LoadP ( r4 , MemOperand ( new_sp , 2 * - kPointerSize ) ) ; __ CmpP ( arg_size , Operand ( 2 * kPointerSize ) ) ; __ beq ( & skip ) ; __ LoadP ( r5 , MemOperand ( new_sp , 3 * - kPointerSize ) ) ; __ bind ( & skip ) ; __ LoadRR ( sp , new_sp ) ; } __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , ConstructWithArrayLike ) , RelocInfo :: CODE_TARGET ) ; }
kg_unseal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int * conf_state , gss_qop_t * qop_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; OM_uint32 code ; ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; if ( ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_STREAM ) != NULL ) { code = kg_unseal_stream_iov ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } else { code = kg_unseal_iov_token ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } return code ; }
xmlFdClose ( void * context ) { int ret ; ret = close ( ( int ) ( long ) context ) ; if ( ret < 0 ) xmlIOErr ( 0 , "close()" ) ; return ( ret ) ; }
nsTSubstring_CharT :: SetLength ( size_type length ) { if ( SetCapacity ( length ) ) mLength = length ; }
HLSDecoder :: GetCurrentPrincipal ( ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; nsCOMPtr < nsIPrincipal > principal ; nsIScriptSecurityManager * secMan = nsContentUtils :: GetSecurityManager ( ) ; if ( ! secMan || ! mChannel ) { return nullptr ; } secMan -> GetChannelResultPrincipal ( mChannel , getter_AddRefs ( principal ) ) ; return principal . forget ( ) ; }
png_warning ( png_const_structrp png_ptr , png_const_charp warning_message ) { int offset = 0 ; if ( png_ptr != NULL ) { #ifdef PNG_ERROR_NUMBERS_SUPPORTED if ( png_ptr -> flags & ( PNG_FLAG_STRIP_ERROR_NUMBERS | PNG_FLAG_STRIP_ERROR_TEXT ) ) #endif { if ( * warning_message == PNG_LITERAL_SHARP ) { for ( offset = 1 ; offset < 15 ; offset ++ ) if ( warning_message [ offset ] == ' ' ) break ; } } } if ( png_ptr != NULL && png_ptr -> warning_fn != NULL ) ( * ( png_ptr -> warning_fn ) ) ( png_constcast ( png_structrp , png_ptr ) , warning_message + offset ) ; else png_default_warning ( png_ptr , warning_message + offset ) ; }
Reduction JSCallReducer :: ReduceMathClz32 ( Node * node ) { CallParameters const & p = CallParametersOf ( node -> op ( ) ) ; if ( p . speculation_mode ( ) == SpeculationMode :: kDisallowSpeculation ) { return NoChange ( ) ; } if ( node -> op ( ) -> ValueInputCount ( ) < 3 ) { Node * value = jsgraph ( ) -> Constant ( 32 ) ; ReplaceWithValue ( node , value ) ; return Replace ( value ) ; } Node * input = NodeProperties :: GetValueInput ( node , 2 ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; input = effect = graph ( ) -> NewNode ( simplified ( ) -> SpeculativeToNumber ( NumberOperationHint :: kNumberOrOddball , p . feedback ( ) ) , input , effect , control ) ; input = graph ( ) -> NewNode ( simplified ( ) -> NumberToUint32 ( ) , input ) ; Node * value = graph ( ) -> NewNode ( simplified ( ) -> NumberClz32 ( ) , input ) ; ReplaceWithValue ( node , value , effect ) ; return Replace ( value ) ; }
void HeaderMapImpl :: appendToHeader ( HeaderString & header , absl :: string_view data ) { if ( data . empty ( ) ) { return ; } if ( ! header . empty ( ) ) { header . append ( "," , 1 ) ; } header . append ( data . data ( ) , data . size ( ) ) ; }
PluginAsyncSurrogate :: DestroyAsyncStream ( NPStream * aStream ) { MOZ_ASSERT ( aStream ) ; nsNPAPIPluginStreamListener * streamListener = GetStreamListener ( aStream ) ; MOZ_ASSERT ( streamListener ) ; streamListener -> ResumeRequest ( ) ; parent :: _destroystream ( mInstance , aStream , NPRES_DONE ) ; }
void DefaultPlatform :: RunIdleTasks ( v8 :: Isolate * isolate , double idle_time_in_seconds ) { DCHECK_EQ ( IdleTaskSupport :: kEnabled , idle_task_support_ ) ; std :: shared_ptr < DefaultForegroundTaskRunner > task_runner ; { base :: LockGuard < base :: Mutex > guard ( & lock_ ) ; if ( foreground_task_runner_map_ . find ( isolate ) == foreground_task_runner_map_ . end ( ) ) { return ; } task_runner = foreground_task_runner_map_ [ isolate ] ; } double deadline_in_seconds = MonotonicallyIncreasingTime ( ) + idle_time_in_seconds ; while ( deadline_in_seconds > MonotonicallyIncreasingTime ( ) ) { std :: unique_ptr < IdleTask > task = task_runner -> PopTaskFromIdleQueue ( ) ; if ( ! task ) return ; task -> Run ( deadline_in_seconds ) ; } }
otError Commissioner :: GeneratePskc ( const char * aPassPhrase , const char * aNetworkName , const Mac :: ExtendedPanId & aExtPanId , Pskc & aPskc ) { otError error = OT_ERROR_NONE ; const char * saltPrefix = "Thread" ; uint8_t salt [ OT_PBKDF2_SALT_MAX_LEN ] ; uint16_t saltLen = 0 ; VerifyOrExit ( ( strlen ( aPassPhrase ) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE ) && ( strlen ( aPassPhrase ) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE ) , error = OT_ERROR_INVALID_ARGS ) ; memset ( salt , 0 , sizeof ( salt ) ) ; memcpy ( salt , saltPrefix , strlen ( saltPrefix ) ) ; saltLen += static_cast < uint16_t > ( strlen ( saltPrefix ) ) ; memcpy ( salt + saltLen , aExtPanId . m8 , sizeof ( aExtPanId ) ) ; saltLen += OT_EXT_PAN_ID_SIZE ; memcpy ( salt + saltLen , aNetworkName , strlen ( aNetworkName ) ) ; saltLen += static_cast < uint16_t > ( strlen ( aNetworkName ) ) ; otPbkdf2Cmac ( reinterpret_cast < const uint8_t * > ( aPassPhrase ) , static_cast < uint16_t > ( strlen ( aPassPhrase ) ) , reinterpret_cast < const uint8_t * > ( salt ) , saltLen , 16384 , OT_PSKC_MAX_SIZE , aPskc . m8 ) ; exit : return error ; }
regexp_compile_impl ( JSContext * cx , const CallArgs & args ) { MOZ_ASSERT ( IsRegExpObject ( args . thisv ( ) ) ) ; Rooted < RegExpObject * > regexp ( cx , & args . thisv ( ) . toObject ( ) . as < RegExpObject > ( ) ) ; RootedValue patternValue ( cx , args . get ( 0 ) ) ; ESClassValue cls ; if ( ! GetClassOfValue ( cx , patternValue , & cls ) ) return false ; if ( cls == ESClass_RegExp ) { if ( args . hasDefined ( 1 ) ) { JS_ReportErrorNumber ( cx , GetErrorMessage , nullptr , JSMSG_NEWREGEXP_FLAGGED ) ; return false ; } RootedObject patternObj ( cx , & patternValue . toObject ( ) ) ; RootedAtom sourceAtom ( cx ) ; RegExpFlag flags ; { RegExpGuard g ( cx ) ; if ( ! RegExpToShared ( cx , patternObj , & g ) ) return false ; sourceAtom = g -> getSource ( ) ; flags = g -> getFlags ( ) ; } if ( ! RegExpObject :: initFromAtom ( cx , regexp , sourceAtom , flags ) ) return false ; args . rval ( ) . setObject ( * regexp ) ; return true ; } RootedValue P ( cx , patternValue ) ; RootedValue F ( cx , args . get ( 1 ) ) ; if ( ! RegExpInitialize ( cx , regexp , P , F , UseRegExpStatics ) ) return false ; args . rval ( ) . setObject ( * regexp ) ; return true ; }
Sprinter :: Sprinter ( JSContext * cx ) : context ( cx ) , #ifdef DEBUG initialized ( false ) , #endif base ( NULL ) , size ( 0 ) , offset ( 0 ) { }
TfLiteStatus AverageEval ( TfLiteContext * context , TfLiteNode * node ) { auto * params = reinterpret_cast < TfLitePoolParams * > ( node -> builtin_data ) ; OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; TfLiteTensor * output = GetOutput ( context , node , 0 ) ; const TfLiteTensor * input = GetInput ( context , node , 0 ) ; switch ( input -> type ) { case kTfLiteFloat32 : AverageEvalFloat < kernel_type > ( context , node , params , data , input , output ) ; break ; case kTfLiteUInt8 : AverageEvalQuantizedUint8 < kernel_type > ( context , node , params , data , input , output ) ; break ; case kTfLiteInt8 : AverageEvalQuantizedInt8 < kernel_type > ( context , node , params , data , input , output ) ; break ; case kTfLiteInt16 : AverageEvalQuantizedInt16 < kernel_type > ( context , node , params , data , input , output ) ; break ; default : TF_LITE_KERNEL_LOG ( context , "Type %s not currently supported." , TfLiteTypeGetName ( input -> type ) ) ; return kTfLiteError ; } return kTfLiteOk ; }
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; }
static int gs_usb_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct gs_usb * dev ; int rc = - ENOMEM ; unsigned int icount , i ; struct gs_host_config hconf = { . byte_order = 0x0000beef , } ; struct gs_device_config dconf ; rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , & hconf , sizeof ( hconf ) , 1000 ) ; if ( rc < 0 ) { dev_err ( & intf -> dev , "Couldn't send data format (err=%d)\n" , rc ) ; return rc ; } rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , & dconf , sizeof ( dconf ) , 1000 ) ; if ( rc < 0 ) { dev_err ( & intf -> dev , "Couldn't get device config: (err=%d)\n" , rc ) ; return rc ; } icount = dconf . icount + 1 ; dev_info ( & intf -> dev , "Configuring for %d interfaces\n" , icount ) ; if ( icount > GS_MAX_INTF ) { dev_err ( & intf -> dev , "Driver cannot handle more that %d CAN interfaces\n" , GS_MAX_INTF ) ; return - EINVAL ; } dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; init_usb_anchor ( & dev -> rx_submitted ) ; atomic_set ( & dev -> active_channels , 0 ) ; usb_set_intfdata ( intf , dev ) ; dev -> udev = interface_to_usbdev ( intf ) ; for ( i = 0 ; i < icount ; i ++ ) { dev -> canch [ i ] = gs_make_candev ( i , intf , & dconf ) ; if ( IS_ERR_OR_NULL ( dev -> canch [ i ] ) ) { rc = PTR_ERR ( dev -> canch [ i ] ) ; icount = i ; for ( i = 0 ; i < icount ; i ++ ) gs_destroy_candev ( dev -> canch [ i ] ) ; usb_kill_anchored_urbs ( & dev -> rx_submitted ) ; kfree ( dev ) ; return rc ; } dev -> canch [ i ] -> parent = dev ; } return 0 ; }
WebGLContext :: TexSubImage2D ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLenum format , GLenum type , ImageData * pixels , ErrorResult & rv ) { if ( IsContextLost ( ) ) return ; if ( ! pixels ) return ErrorInvalidValue ( "texSubImage2D: pixels must not be null!" ) ; Uint8ClampedArray arr ( pixels -> GetDataObject ( ) ) ; return TexSubImage2D_base ( target , level , xoffset , yoffset , pixels -> Width ( ) , pixels -> Height ( ) , 4 * pixels -> Width ( ) , format , type , arr . Data ( ) , arr . Length ( ) , - 1 , WebGLTexelFormat :: RGBA8 , false ) ; }
Type OperationTyper :: NumberDivide ( Type lhs , Type rhs ) { DCHECK ( lhs . Is ( Type :: Number ( ) ) ) ; DCHECK ( rhs . Is ( Type :: Number ( ) ) ) ; if ( lhs . IsNone ( ) || rhs . IsNone ( ) ) return Type :: None ( ) ; if ( lhs . Is ( Type :: NaN ( ) ) || rhs . Is ( Type :: NaN ( ) ) ) return Type :: NaN ( ) ; bool maybe_nan = lhs . Maybe ( Type :: NaN ( ) ) || rhs . Maybe ( cache_ . kZeroish ) || ( ( lhs . Min ( ) == - V8_INFINITY || lhs . Max ( ) == + V8_INFINITY ) && ( rhs . Min ( ) == - V8_INFINITY || rhs . Max ( ) == + V8_INFINITY ) ) ; lhs = Type :: Intersect ( lhs , Type :: OrderedNumber ( ) , zone ( ) ) ; DCHECK ( ! lhs . IsNone ( ) ) ; rhs = Type :: Intersect ( rhs , Type :: OrderedNumber ( ) , zone ( ) ) ; DCHECK ( ! rhs . IsNone ( ) ) ; bool maybe_minuszero = ! lhs . Is ( cache_ . kInteger ) || ( lhs . Maybe ( cache_ . kZeroish ) && rhs . Min ( ) < 0.0 ) || ( rhs . Min ( ) == - V8_INFINITY || rhs . Max ( ) == + V8_INFINITY ) ; Type type = Type :: PlainNumber ( ) ; if ( maybe_minuszero ) type = Type :: Union ( type , Type :: MinusZero ( ) , zone ( ) ) ; if ( maybe_nan ) type = Type :: Union ( type , Type :: NaN ( ) , zone ( ) ) ; return type ; }
bool DNP3_Base :: AddToBuffer ( Endpoint * endp , int target_len , const u_char * * data , int * len ) { if ( ! target_len ) return true ; int to_copy = min ( * len , target_len - endp -> buffer_len ) ; memcpy ( endp -> buffer + endp -> buffer_len , * data , to_copy ) ; * data += to_copy ; * len -= to_copy ; endp -> buffer_len += to_copy ; return endp -> buffer_len == target_len ; }
v8 :: Local < v8 :: Object > CreateNativeEvent ( v8 :: Isolate * isolate , v8 :: Local < v8 :: Object > sender , content :: RenderFrameHost * frame , electron :: mojom :: ElectronBrowser :: MessageSyncCallback callback ) { v8 :: Local < v8 :: Object > event ; if ( frame && callback ) { gin :: Handle < Event > native_event = Event :: Create ( isolate ) ; native_event -> SetCallback ( std :: move ( callback ) ) ; event = v8 :: Local < v8 :: Object > :: Cast ( native_event . ToV8 ( ) ) ; } else { event = CreateEvent ( isolate ) ; } Dictionary dict ( isolate , event ) ; dict . Set ( "sender" , sender ) ; if ( frame ) dict . Set ( "frameId" , frame -> GetRoutingID ( ) ) ; return event ; }
nsresult nsContentUtils :: ParseFragmentHTML ( const nsAString & aSourceBuffer , nsIContent * aTargetNode , nsAtom * aContextLocalName , int32_t aContextNamespace , bool aQuirks , bool aPreventScriptExecution , int32_t aFlags ) { AutoTimelineMarker m ( aTargetNode -> OwnerDoc ( ) -> GetDocShell ( ) , "Parse HTML" ) ; if ( nsContentUtils :: sFragmentParsingActive ) { MOZ_ASSERT_UNREACHABLE ( "Re-entrant fragment parsing attempted." ) ; return NS_ERROR_DOM_INVALID_STATE_ERR ; } mozilla :: AutoRestore < bool > guard ( nsContentUtils :: sFragmentParsingActive ) ; nsContentUtils :: sFragmentParsingActive = true ; if ( ! sHTMLFragmentParser ) { NS_ADDREF ( sHTMLFragmentParser = new nsHtml5StringParser ( ) ) ; } nsCOMPtr < nsIPrincipal > nodePrincipal = aTargetNode -> NodePrincipal ( ) ; #ifdef DEBUG if ( aFlags < 0 ) { DOMSecurityMonitor :: AuditParsingOfHTMLXMLFragments ( nodePrincipal , aSourceBuffer ) ; } #endif nsIContent * target = aTargetNode ; RefPtr < DocumentFragment > fragment ; bool shouldSanitize = nodePrincipal -> IsSystemPrincipal ( ) || nodePrincipal -> SchemeIs ( "about" ) || aFlags >= 0 ; if ( shouldSanitize ) { if ( ! AllowsUnsanitizedContentForAboutNewTab ( nodePrincipal ) ) { fragment = new ( aTargetNode -> OwnerDoc ( ) -> NodeInfoManager ( ) ) DocumentFragment ( aTargetNode -> OwnerDoc ( ) -> NodeInfoManager ( ) ) ; target = fragment ; } } nsresult rv = sHTMLFragmentParser -> ParseFragment ( aSourceBuffer , target , aContextLocalName , aContextNamespace , aQuirks , aPreventScriptExecution ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( fragment ) { uint32_t sanitizationFlags = computeSanitizationFlags ( nodePrincipal , aFlags ) ; nsAutoScriptBlockerSuppressNodeRemoved scriptBlocker ; nsTreeSanitizer sanitizer ( sanitizationFlags ) ; sanitizer . Sanitize ( fragment ) ; ErrorResult error ; aTargetNode -> AppendChild ( * fragment , error ) ; rv = error . StealNSResult ( ) ; } return rv ; }
const Operator * CommonOperatorBuilder :: ExternalConstant ( const ExternalReference & value ) { return new ( zone ( ) ) Operator1 < ExternalReference > ( IrOpcode :: kExternalConstant , Operator :: kPure , "ExternalConstant" , 0 , 0 , 0 , 1 , 0 , 0 , value ) ; }
do_ssh2_kex ( void ) { char * myproposal [ PROPOSAL_MAX ] = { KEX_SERVER } ; struct kex * kex ; int r ; myproposal [ PROPOSAL_KEX_ALGS ] = compat_kex_proposal ( options . kex_algorithms ) ; myproposal [ PROPOSAL_ENC_ALGS_CTOS ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_ENC_ALGS_STOC ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ; if ( options . compression == COMP_NONE ) { myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = "none" ; } else if ( options . compression == COMP_DELAYED ) { myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = "none,zlib@openssh.com" ; } if ( options . rekey_limit || options . rekey_interval ) packet_set_rekey_limits ( options . rekey_limit , ( time_t ) options . rekey_interval ) ; myproposal [ PROPOSAL_SERVER_HOST_KEY_ALGS ] = compat_pkalg_proposal ( list_hostkey_types ( ) ) ; if ( ( r = kex_setup ( active_state , myproposal ) ) != 0 ) fatal ( "kex_setup: %s" , ssh_err ( r ) ) ; kex = active_state -> kex ; #ifdef WITH_OPENSSL kex -> kex [ KEX_DH_GRP1_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA256 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP16_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP18_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GEX_SHA1 ] = kexgex_server ; kex -> kex [ KEX_DH_GEX_SHA256 ] = kexgex_server ; kex -> kex [ KEX_ECDH_SHA2 ] = kexecdh_server ; #endif kex -> kex [ KEX_C25519_SHA256 ] = kexc25519_server ; kex -> server = 1 ; kex -> client_version_string = client_version_string ; kex -> server_version_string = server_version_string ; kex -> load_host_public_key = & get_hostkey_public_by_type ; kex -> load_host_private_key = & get_hostkey_private_by_type ; kex -> host_key_index = & get_hostkey_index ; kex -> sign = sshd_hostkey_sign ; dispatch_run ( DISPATCH_BLOCK , & kex -> done , active_state ) ; session_id2 = kex -> session_id ; session_id2_len = kex -> session_id_len ; #ifdef DEBUG_KEXDH packet_start ( SSH2_MSG_IGNORE ) ; packet_put_cstring ( "markus" ) ; packet_send ( ) ; packet_write_wait ( ) ; #endif debug ( "KEX done" ) ; }
ft_gzip_stream_close ( FT_Stream stream ) { FT_GZipFile zip = ( FT_GZipFile ) stream -> descriptor . pointer ; FT_Memory memory = stream -> memory ; if ( zip ) { ft_gzip_file_done ( zip ) ; FT_FREE ( zip ) ; stream -> descriptor . pointer = NULL ; } }
static tBTA_AG_PEER_CODEC bta_ag_parse_bac ( tBTA_AG_SCB * p_scb , char * p_s ) { tBTA_AG_PEER_CODEC retval = BTA_AG_CODEC_NONE ; uint16_t uuid_codec ; char * p ; while ( p_s ) { for ( p = p_s ; * p != ',' && * p != 0 ; p ++ ) ; bool cont = false ; if ( * p != 0 ) { * p = 0 ; cont = true ; } uuid_codec = utl_str2int ( p_s ) ; switch ( uuid_codec ) { case UUID_CODEC_CVSD : retval |= BTA_AG_CODEC_CVSD ; break ; case UUID_CODEC_MSBC : retval |= BTA_AG_CODEC_MSBC ; break ; default : APPL_TRACE_ERROR ( "Unknown Codec UUID(%d) received" , uuid_codec ) ; break ; } if ( cont ) p_s = p + 1 ; else break ; } return ( retval ) ; }
void Compute ( OpKernelContext * context ) override { const Tensor & tensor_in = context -> input ( 0 ) ; const Tensor & tensor_out = context -> input ( 1 ) ; const Tensor & out_grad_backprop = context -> input ( 2 ) ; OP_REQUIRES ( context , tensor_in . dims ( ) == 4 , errors :: InvalidArgument ( "tensor_in must be 4-dimensional 4" ) ) ; OP_REQUIRES ( context , tensor_out . dims ( ) == 4 , errors :: InvalidArgument ( "tensor_out must be 4-dimensional" ) ) ; OP_REQUIRES ( context , out_grad_backprop . dims ( ) == 4 , errors :: InvalidArgument ( "out_grad_backprop must be 4-dimensional" ) ) ; Tensor * output = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , tensor_out . shape ( ) , & output ) ) ; std :: vector < int32 > ksize = ksize_ ; std :: vector < int32 > stride = stride_ ; if ( context -> num_inputs ( ) == 5 ) { const Tensor & tensor_ksize = context -> input ( 3 ) ; auto value_ksize = tensor_ksize . flat < int32 > ( ) ; ksize . resize ( tensor_ksize . shape ( ) . num_elements ( ) ) ; std :: copy_n ( & value_ksize ( 0 ) , ksize . size ( ) , ksize . begin ( ) ) ; const Tensor & tensor_stride = context -> input ( 4 ) ; auto value_stride = tensor_stride . flat < int32 > ( ) ; stride . resize ( tensor_stride . shape ( ) . num_elements ( ) ) ; std :: copy_n ( & value_stride ( 0 ) , stride . size ( ) , stride . begin ( ) ) ; } OP_REQUIRES ( context , ksize . size ( ) == 4 , errors :: InvalidArgument ( "Sliding window ksize field must " "specify 4 dimensions" ) ) ; OP_REQUIRES ( context , stride . size ( ) == 4 , errors :: InvalidArgument ( "Sliding window strides field must " "specify 4 dimensions" ) ) ; const int32_t ksize_n = GetTensorDim ( ksize , data_format_ , 'N' ) ; const int32_t stride_n = GetTensorDim ( stride , data_format_ , 'N' ) ; OP_REQUIRES ( context , ksize_n == 1 && stride_n == 1 , errors :: Unimplemented ( "Pooling is not yet supported on the batch dimension." ) ) ; PoolParameters params { context , ksize , stride , padding_ , { } , data_format_ , tensor_in . shape ( ) } ; functor :: MaxPoolGradBackwardNoMask < T > ( ) ( data_format_ , tensor_in . flat < T > ( ) . data ( ) , tensor_out . flat < T > ( ) . data ( ) , params . tensor_in_batch , params . out_height , params . out_width , params . depth , params . tensor_in_rows , params . tensor_in_cols , params . window_rows , params . window_cols , params . row_stride , params . col_stride , params . pad_top , params . pad_left , out_grad_backprop . flat < T > ( ) . data ( ) , output -> flat < T > ( ) . data ( ) , context -> eigen_device < Eigen :: GpuDevice > ( ) ) ; }
base :: Optional < ParseResult > MakeBinaryOperator ( ParseResultIterator * child_results ) { auto left = child_results -> NextAs < Expression * > ( ) ; auto op = child_results -> NextAs < std :: string > ( ) ; auto right = child_results -> NextAs < Expression * > ( ) ; Expression * result = MakeNode < CallExpression > ( op , true , TypeList { } , std :: vector < Expression * > { left , right } , std :: vector < std :: string > { } ) ; return ParseResult { result } ; }
int tipc_nl_publ_dump ( struct sk_buff * skb , struct netlink_callback * cb ) { int err ; u32 tsk_portid = cb -> args [ 0 ] ; u32 last_publ = cb -> args [ 1 ] ; u32 done = cb -> args [ 2 ] ; struct net * net = sock_net ( skb -> sk ) ; struct tipc_sock * tsk ; if ( ! tsk_portid ) { struct nlattr * * attrs ; struct nlattr * sock [ TIPC_NLA_SOCK_MAX + 1 ] ; err = tipc_nlmsg_parse ( cb -> nlh , & attrs ) ; if ( err ) return err ; err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock [ TIPC_NLA_SOCK_REF ] ) return - EINVAL ; tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ; lock_sock ( & tsk -> sk ) ; err = __tipc_nl_list_sk_publ ( skb , cb , tsk , & last_publ ) ; if ( ! err ) done = 1 ; release_sock ( & tsk -> sk ) ; sock_put ( & tsk -> sk ) ; cb -> args [ 0 ] = tsk_portid ; cb -> args [ 1 ] = last_publ ; cb -> args [ 2 ] = done ; return skb -> len ; }
TEST ( HeaderMapImplTest , InlineInsert ) { HeaderMapImpl headers ; EXPECT_TRUE ( headers . empty ( ) ) ; EXPECT_EQ ( 0 , headers . size ( ) ) ; EXPECT_EQ ( nullptr , headers . Host ( ) ) ; headers . insertHost ( ) . value ( std :: string ( "hello" ) ) ; EXPECT_FALSE ( headers . empty ( ) ) ; EXPECT_EQ ( 1 , headers . size ( ) ) ; EXPECT_EQ ( ":authority" , headers . Host ( ) -> key ( ) . getStringView ( ) ) ; EXPECT_EQ ( "hello" , headers . Host ( ) -> value ( ) . getStringView ( ) ) ; EXPECT_EQ ( "hello" , headers . get ( Headers :: get ( ) . Host ) -> value ( ) . getStringView ( ) ) ; }
static int dr_domain_init_resources ( struct mlx5dr_domain * dmn ) { int ret ; dmn -> ste_ctx = mlx5dr_ste_get_ctx ( dmn -> info . caps . sw_format_ver ) ; if ( ! dmn -> ste_ctx ) { mlx5dr_err ( dmn , "SW Steering on this device is unsupported\n" ) ; return - EOPNOTSUPP ; } ret = mlx5_core_alloc_pd ( dmn -> mdev , & dmn -> pdn ) ; if ( ret ) { mlx5dr_err ( dmn , "Couldn't allocate PD, ret: %d" , ret ) ; return ret ; } dmn -> uar = mlx5_get_uars_page ( dmn -> mdev ) ; if ( ! dmn -> uar ) { mlx5dr_err ( dmn , "Couldn't allocate UAR\n" ) ; ret = - ENOMEM ; goto clean_pd ; } dmn -> ste_icm_pool = mlx5dr_icm_pool_create ( dmn , DR_ICM_TYPE_STE ) ; if ( ! dmn -> ste_icm_pool ) { mlx5dr_err ( dmn , "Couldn't get icm memory\n" ) ; ret = - ENOMEM ; goto clean_uar ; } dmn -> action_icm_pool = mlx5dr_icm_pool_create ( dmn , DR_ICM_TYPE_MODIFY_ACTION ) ; if ( ! dmn -> action_icm_pool ) { mlx5dr_err ( dmn , "Couldn't get action icm memory\n" ) ; ret = - ENOMEM ; goto free_ste_icm_pool ; } ret = mlx5dr_send_ring_alloc ( dmn ) ; if ( ret ) { mlx5dr_err ( dmn , "Couldn't create send-ring\n" ) ; goto free_action_icm_pool ; } return 0 ; free_action_icm_pool : mlx5dr_icm_pool_destroy ( dmn -> action_icm_pool ) ; free_ste_icm_pool : mlx5dr_icm_pool_destroy ( dmn -> ste_icm_pool ) ; clean_uar : mlx5_put_uars_page ( dmn -> mdev , dmn -> uar ) ; clean_pd : mlx5_core_dealloc_pd ( dmn -> mdev , dmn -> pdn ) ; return ret ; }
static void first_pass_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const MV * ref_mv , MV * best_mv , int * best_motion_err ) { MACROBLOCKD * const xd = & x -> e_mbd ; MV tmp_mv = { 0 , 0 } ; MV ref_mv_full = { ref_mv -> row > > 3 , ref_mv -> col > > 3 } ; int num00 , tmp_err , n , sr = 0 ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ bsize ] ; int new_mv_mode_penalty = 256 ; const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ; while ( ( quart_frm < < sr ) < MAX_FULL_PEL_VAL ) ++ sr ; step_param += sr ; further_steps -= sr ; v_fn_ptr . vf = get_block_variance_fn ( bsize ) ; tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> nmvjointcost , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . row ; best_mv -> col = tmp_mv . col ; } n = num00 ; num00 = 0 ; while ( n < further_steps ) { ++ n ; if ( num00 ) { -- num00 ; } else { tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> nmvjointcost , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . row ; best_mv -> col = tmp_mv . col ; } } } }
int CJSON_CDECL main ( void ) { UNITY_BEGIN ( ) ; RUN_TEST ( cjson_array_foreach_should_loop_over_arrays ) ; RUN_TEST ( cjson_array_foreach_should_not_dereference_null_pointer ) ; RUN_TEST ( cjson_get_object_item_should_get_object_items ) ; RUN_TEST ( cjson_get_object_item_case_sensitive_should_get_object_items ) ; RUN_TEST ( typecheck_functions_should_check_type ) ; RUN_TEST ( cjson_should_not_parse_to_deeply_nested_jsons ) ; RUN_TEST ( cjson_set_number_value_should_set_numbers ) ; RUN_TEST ( cjson_detach_item_via_pointer_should_detach_items ) ; RUN_TEST ( cjson_replace_item_via_pointer_should_replace_items ) ; RUN_TEST ( cjson_replace_item_in_object_should_preserve_name ) ; RUN_TEST ( cjson_functions_shouldnt_crash_with_null_pointers ) ; RUN_TEST ( ensure_should_fail_on_failed_realloc ) ; RUN_TEST ( skip_utf8_bom_should_skip_bom ) ; RUN_TEST ( skip_utf8_bom_should_not_skip_bom_if_not_at_beginning ) ; RUN_TEST ( cjson_get_string_value_should_get_a_string ) ; RUN_TEST ( cjson_create_string_reference_should_create_a_string_reference ) ; RUN_TEST ( cjson_create_object_reference_should_create_an_object_reference ) ; RUN_TEST ( cjson_create_array_reference_should_create_an_array_reference ) ; RUN_TEST ( cjson_add_item_to_object_should_not_use_after_free_when_string_is_aliased ) ; return UNITY_END ( ) ; }
CopyRect ( DataSourceSurface * aSrc , DataSourceSurface * aDest , IntRect aSrcRect , IntPoint aDestPoint ) { if ( aSrcRect . Overflows ( ) || IntRect ( aDestPoint , aSrcRect . Size ( ) ) . Overflows ( ) ) { MOZ_CRASH ( "we should never be getting invalid rects at this point" ) ; } MOZ_ASSERT ( aSrc -> GetFormat ( ) == aDest -> GetFormat ( ) , "different surface formats" ) ; MOZ_ASSERT ( IntRect ( IntPoint ( ) , aSrc -> GetSize ( ) ) . Contains ( aSrcRect ) , "source rect too big for source surface" ) ; MOZ_ASSERT ( IntRect ( IntPoint ( ) , aDest -> GetSize ( ) ) . Contains ( aSrcRect - aSrcRect . TopLeft ( ) + aDestPoint ) , "dest surface too small" ) ; if ( aSrcRect . IsEmpty ( ) ) { return ; } uint8_t * sourceData = DataAtOffset ( aSrc , aSrcRect . TopLeft ( ) ) ; uint32_t sourceStride = aSrc -> Stride ( ) ; uint8_t * destData = DataAtOffset ( aDest , aDestPoint ) ; uint32_t destStride = aDest -> Stride ( ) ; if ( BytesPerPixel ( aSrc -> GetFormat ( ) ) == 4 ) { for ( int32_t y = 0 ; y < aSrcRect . height ; y ++ ) { PodCopy ( ( int32_t * ) destData , ( int32_t * ) sourceData , aSrcRect . width ) ; sourceData += sourceStride ; destData += destStride ; } } else if ( BytesPerPixel ( aSrc -> GetFormat ( ) ) == 1 ) { for ( int32_t y = 0 ; y < aSrcRect . height ; y ++ ) { PodCopy ( destData , sourceData , aSrcRect . width ) ; sourceData += sourceStride ; destData += destStride ; } } }
UpdateThreadFunc ( void * param ) { int rv ; if ( sReplaceRequest ) { rv = ProcessReplaceRequest ( ) ; } else { NS_tchar dataFile [ MAXPATHLEN ] ; rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ) ; if ( rv == OK ) { rv = gArchiveReader . Open ( dataFile ) ; } #ifdef MOZ_VERIFY_MAR_SIGNATURE if ( rv == OK ) { rv = gArchiveReader . VerifySignature ( ) ; } if ( rv == OK ) { NS_tchar installDir [ MAXPATHLEN ] ; if ( sStagedUpdate ) { if ( ! GetInstallationDir ( installDir ) ) { rv = NO_INSTALLDIR_ERROR ; } } else { NS_tstrcpy ( installDir , gDestinationPath ) ; } if ( rv == OK ) { NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; NS_tsnprintf ( updateSettingsPath , sizeof ( updateSettingsPath ) / sizeof ( updateSettingsPath [ 0 ] ) , NS_T ( "%s/update-settings.ini" ) , installDir ) ; MARChannelStringTable MARStrings ; if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK ) { MARStrings . MARChannelID [ 0 ] = '\0' ; } rv = gArchiveReader . VerifyProductInformation ( MARStrings . MARChannelID , MOZ_APP_VERSION ) ; } } #endif if ( rv == OK && sStagedUpdate && ! sIsOSUpdate ) { rv = CopyInstallDirToDestDir ( ) ; } if ( rv == OK ) { rv = DoUpdate ( ) ; gArchiveReader . Close ( ) ; } } bool reportRealResults = true ; if ( sReplaceRequest && rv && ! getenv ( "MOZ_NO_REPLACE_FALLBACK" ) ) { NS_tchar installDir [ MAXPATHLEN ] ; if ( GetInstallationDir ( installDir ) ) { NS_tchar stageDir [ MAXPATHLEN ] ; NS_tsnprintf ( stageDir , sizeof ( stageDir ) / sizeof ( stageDir [ 0 ] ) , #ifdef XP_MACOSX NS_T ( "%s/Updated.app" ) , #else NS_T ( "%s/updated" ) , #endif installDir ) ; ensure_remove_recursive ( stageDir ) ; WriteStatusFile ( sUsingService ? "pending-service" : "pending" ) ; char processUpdates [ ] = "MOZ_PROCESS_UPDATES=" ; putenv ( processUpdates ) ; reportRealResults = false ; } } if ( reportRealResults ) { if ( rv ) { LOG ( ( "failed: %d" , rv ) ) ; } else { #ifdef XP_MACOSX char * cwd = getcwd ( nullptr , 0 ) ; if ( cwd ) { if ( utimes ( cwd , nullptr ) != 0 ) { LOG ( ( "Couldn't set access/modification time on application bundle." ) ) ; } free ( cwd ) ; } else { LOG ( ( "Couldn't get current working directory for setting " "access/modification time on application bundle." ) ) ; } #endif LOG ( ( "succeeded" ) ) ; } WriteStatusFile ( rv ) ; } LOG ( ( "calling QuitProgressUI" ) ) ; QuitProgressUI ( ) ; }
static void loongarch_cpu_reset ( DeviceState * dev ) { CPUState * cs = CPU ( dev ) ; LoongArchCPU * cpu = LOONGARCH_CPU ( cs ) ; LoongArchCPUClass * lacc = LOONGARCH_CPU_GET_CLASS ( cpu ) ; CPULoongArchState * env = & cpu -> env ; lacc -> parent_reset ( dev ) ; env -> fcsr0_mask = FCSR0_M1 | FCSR0_M2 | FCSR0_M3 ; env -> fcsr0 = 0x0 ; int n ; env -> CSR_CRMD = FIELD_DP64 ( env -> CSR_CRMD , CSR_CRMD , PLV , 0 ) ; env -> CSR_CRMD = FIELD_DP64 ( env -> CSR_CRMD , CSR_CRMD , IE , 0 ) ; env -> CSR_CRMD = FIELD_DP64 ( env -> CSR_CRMD , CSR_CRMD , DA , 1 ) ; env -> CSR_CRMD = FIELD_DP64 ( env -> CSR_CRMD , CSR_CRMD , PG , 0 ) ; env -> CSR_CRMD = FIELD_DP64 ( env -> CSR_CRMD , CSR_CRMD , DATF , 1 ) ; env -> CSR_CRMD = FIELD_DP64 ( env -> CSR_CRMD , CSR_CRMD , DATM , 1 ) ; env -> CSR_EUEN = FIELD_DP64 ( env -> CSR_EUEN , CSR_EUEN , FPE , 0 ) ; env -> CSR_EUEN = FIELD_DP64 ( env -> CSR_EUEN , CSR_EUEN , SXE , 0 ) ; env -> CSR_EUEN = FIELD_DP64 ( env -> CSR_EUEN , CSR_EUEN , ASXE , 0 ) ; env -> CSR_EUEN = FIELD_DP64 ( env -> CSR_EUEN , CSR_EUEN , BTE , 0 ) ; env -> CSR_MISC = 0 ; env -> CSR_ECFG = FIELD_DP64 ( env -> CSR_ECFG , CSR_ECFG , VS , 0 ) ; env -> CSR_ECFG = FIELD_DP64 ( env -> CSR_ECFG , CSR_ECFG , LIE , 0 ) ; env -> CSR_ESTAT = env -> CSR_ESTAT & ( ~ MAKE_64BIT_MASK ( 0 , 2 ) ) ; env -> CSR_RVACFG = FIELD_DP64 ( env -> CSR_RVACFG , CSR_RVACFG , RBITS , 0 ) ; env -> CSR_TCFG = FIELD_DP64 ( env -> CSR_TCFG , CSR_TCFG , EN , 0 ) ; env -> CSR_LLBCTL = FIELD_DP64 ( env -> CSR_LLBCTL , CSR_LLBCTL , KLO , 0 ) ; env -> CSR_TLBRERA = FIELD_DP64 ( env -> CSR_TLBRERA , CSR_TLBRERA , ISTLBR , 0 ) ; env -> CSR_MERRCTL = FIELD_DP64 ( env -> CSR_MERRCTL , CSR_MERRCTL , ISMERR , 0 ) ; env -> CSR_PRCFG3 = FIELD_DP64 ( env -> CSR_PRCFG3 , CSR_PRCFG3 , TLB_TYPE , 2 ) ; env -> CSR_PRCFG3 = FIELD_DP64 ( env -> CSR_PRCFG3 , CSR_PRCFG3 , MTLB_ENTRY , 63 ) ; env -> CSR_PRCFG3 = FIELD_DP64 ( env -> CSR_PRCFG3 , CSR_PRCFG3 , STLB_WAYS , 7 ) ; env -> CSR_PRCFG3 = FIELD_DP64 ( env -> CSR_PRCFG3 , CSR_PRCFG3 , STLB_SETS , 8 ) ; for ( n = 0 ; n < 4 ; n ++ ) { env -> CSR_DMW [ n ] = FIELD_DP64 ( env -> CSR_DMW [ n ] , CSR_DMW , PLV0 , 0 ) ; env -> CSR_DMW [ n ] = FIELD_DP64 ( env -> CSR_DMW [ n ] , CSR_DMW , PLV1 , 0 ) ; env -> CSR_DMW [ n ] = FIELD_DP64 ( env -> CSR_DMW [ n ] , CSR_DMW , PLV2 , 0 ) ; env -> CSR_DMW [ n ] = FIELD_DP64 ( env -> CSR_DMW [ n ] , CSR_DMW , PLV3 , 0 ) ; } #ifndef CONFIG_USER_ONLY env -> pc = 0x1c000000 ; #endif restore_fp_status ( env ) ; cs -> exception_index = - 1 ; }
static void * btif_hl_select_thread ( void * arg ) { fd_set org_set , curr_set ; int r , max_curr_s , max_org_s ; UNUSED ( arg ) ; BTIF_TRACE_DEBUG ( "entered btif_hl_select_thread" ) ; FD_ZERO ( & org_set ) ; max_org_s = btif_hl_select_wakeup_init ( & org_set ) ; BTIF_TRACE_DEBUG ( "max_s=%d " , max_org_s ) ; for ( ; ; ) { r = 0 ; BTIF_TRACE_DEBUG ( "set curr_set = org_set " ) ; curr_set = org_set ; max_curr_s = max_org_s ; int ret = select ( ( max_curr_s + 1 ) , & curr_set , NULL , NULL , NULL ) ; BTIF_TRACE_DEBUG ( "select unblocked ret=%d" , ret ) ; if ( ret == - 1 ) { BTIF_TRACE_DEBUG ( "select() ret -1, exit the thread" ) ; btif_hl_thread_cleanup ( ) ; select_thread_id = - 1 ; return 0 ; } else if ( ret ) { BTIF_TRACE_DEBUG ( "btif_hl_select_wake_signaled, signal ret=%d" , ret ) ; if ( btif_hl_select_wake_signaled ( & curr_set ) ) { r = btif_hl_select_wake_reset ( ) ; BTIF_TRACE_DEBUG ( "btif_hl_select_wake_signaled, signal:%d" , r ) ; if ( r == btif_hl_signal_select_wakeup || r == btif_hl_signal_select_close_connected ) { btif_hl_select_wakeup_callback ( & org_set , r ) ; } else if ( r == btif_hl_signal_select_exit ) { btif_hl_thread_cleanup ( ) ; BTIF_TRACE_DEBUG ( "Exit hl_select_thread for btif_hl_signal_select_exit" ) ; return 0 ; } } btif_hl_select_monitor_callback ( & curr_set , & org_set ) ; max_org_s = btif_hl_update_maxfd ( max_org_s ) ; } else BTIF_TRACE_DEBUG ( "no data, select ret: %d\n" , ret ) ; } BTIF_TRACE_DEBUG ( "leaving hl_select_thread" ) ; return 0 ; }
void FilterManager :: maybeEndEncode ( bool end_stream ) { if ( end_stream ) { filter_manager_callbacks_ . endStream ( ) ; } }
void WebAssemblyGlobal ( const v8 :: FunctionCallbackInfo < v8 :: Value > & args ) { v8 :: Isolate * isolate = args . GetIsolate ( ) ; i :: Isolate * i_isolate = reinterpret_cast < i :: Isolate * > ( isolate ) ; HandleScope scope ( isolate ) ; ScheduledErrorThrower thrower ( i_isolate , "WebAssembly.Global()" ) ; if ( ! args . IsConstructCall ( ) ) { thrower . TypeError ( "WebAssembly.Global must be invoked with 'new'" ) ; return ; } if ( ! args [ 0 ] -> IsObject ( ) ) { thrower . TypeError ( "Argument 0 must be a global descriptor" ) ; return ; } Local < Context > context = isolate -> GetCurrentContext ( ) ; Local < v8 :: Object > descriptor = Local < Object > :: Cast ( args [ 0 ] ) ; bool is_mutable = false ; { Local < String > mutable_key = v8_str ( isolate , "mutable" ) ; v8 :: MaybeLocal < v8 :: Value > maybe = descriptor -> Get ( context , mutable_key ) ; v8 :: Local < v8 :: Value > value ; if ( maybe . ToLocal ( & value ) ) { if ( ! value -> BooleanValue ( context ) . To ( & is_mutable ) ) return ; } } i :: wasm :: ValueType type ; { v8 :: MaybeLocal < v8 :: Value > maybe = descriptor -> Get ( context , v8_str ( isolate , "value" ) ) ; v8 :: Local < v8 :: Value > value ; if ( ! maybe . ToLocal ( & value ) ) return ; v8 :: Local < v8 :: String > string ; if ( ! value -> ToString ( context ) . ToLocal ( & string ) ) return ; if ( string -> StringEquals ( v8_str ( isolate , "i32" ) ) ) { type = i :: wasm :: kWasmI32 ; } else if ( string -> StringEquals ( v8_str ( isolate , "f32" ) ) ) { type = i :: wasm :: kWasmF32 ; } else if ( string -> StringEquals ( v8_str ( isolate , "f64" ) ) ) { type = i :: wasm :: kWasmF64 ; } else { thrower . TypeError ( "Descriptor property 'value' must be 'i32', 'f32', or 'f64'" ) ; return ; } } const uint32_t offset = 0 ; i :: MaybeHandle < i :: WasmGlobalObject > maybe_global_obj = i :: WasmGlobalObject :: New ( i_isolate , i :: MaybeHandle < i :: JSArrayBuffer > ( ) , type , offset , is_mutable ) ; i :: Handle < i :: WasmGlobalObject > global_obj ; if ( ! maybe_global_obj . ToHandle ( & global_obj ) ) { thrower . RangeError ( "could not allocate memory" ) ; return ; } Local < v8 :: Value > value = Local < Value > :: Cast ( args [ 1 ] ) ; switch ( type ) { case i :: wasm :: kWasmI32 : { int32_t i32_value = 0 ; if ( ! value -> IsUndefined ( ) ) { v8 :: Local < v8 :: Int32 > int32_value ; if ( ! value -> ToInt32 ( context ) . ToLocal ( & int32_value ) ) return ; if ( ! int32_value -> Int32Value ( context ) . To ( & i32_value ) ) return ; } global_obj -> SetI32 ( i32_value ) ; break ; } case i :: wasm :: kWasmF32 : { float f32_value = 0 ; if ( ! value -> IsUndefined ( ) ) { double f64_value = 0 ; v8 :: Local < v8 :: Number > number_value ; if ( ! value -> ToNumber ( context ) . ToLocal ( & number_value ) ) return ; if ( ! number_value -> NumberValue ( context ) . To ( & f64_value ) ) return ; f32_value = static_cast < float > ( f64_value ) ; } global_obj -> SetF32 ( f32_value ) ; break ; } case i :: wasm :: kWasmF64 : { double f64_value = 0 ; if ( ! value -> IsUndefined ( ) ) { v8 :: Local < v8 :: Number > number_value ; if ( ! value -> ToNumber ( context ) . ToLocal ( & number_value ) ) return ; if ( ! number_value -> NumberValue ( context ) . To ( & f64_value ) ) return ; } global_obj -> SetF64 ( f64_value ) ; break ; } default : UNREACHABLE ( ) ; } i :: Handle < i :: JSObject > global_js_object ( global_obj ) ; args . GetReturnValue ( ) . Set ( Utils :: ToLocal ( global_js_object ) ) ; }
int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; if ( vm_flags & VM_NORESERVE ) return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 ) return chg ; if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) return - ENOSPC ; ret = hugetlb_acct_memory ( h , chg ) ; if ( ret < 0 ) { hugetlb_put_quota ( inode -> i_mapping , chg ) ; return ret ; } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; }
nsGenericElement :: doInsertChildAt ( nsIContent * aKid , PRUint32 aIndex , PRBool aNotify , nsIContent * aParent , nsIDocument * aDocument , nsAttrAndChildArray & aChildArray ) { NS_PRECONDITION ( aParent || aDocument , "Must have document if no parent!" ) ; NS_PRECONDITION ( ! aParent || aParent -> GetCurrentDoc ( ) == aDocument , "Incorrect aDocument" ) ; nsresult rv ; nsINode * container = NODE_FROM ( aParent , aDocument ) ; if ( ! container -> HasSameOwnerDoc ( aKid ) ) { nsCOMPtr < nsIDOMNode > kid = do_QueryInterface ( aKid , & rv ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; PRUint16 nodeType = 0 ; rv = kid -> GetNodeType ( & nodeType ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIDOM3Document > domDoc = do_QueryInterface ( container -> GetOwnerDoc ( ) ) ; if ( domDoc && ( nodeType != nsIDOMNode :: DOCUMENT_TYPE_NODE || aKid -> GetOwnerDoc ( ) ) ) { nsCOMPtr < nsIDOMNode > adoptedKid ; rv = domDoc -> AdoptNode ( kid , getter_AddRefs ( adoptedKid ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; NS_ASSERTION ( adoptedKid == kid , "Uh, adopt node changed nodes?" ) ; } } PRUint32 childCount = aChildArray . ChildCount ( ) ; NS_ENSURE_TRUE ( aIndex <= childCount , NS_ERROR_ILLEGAL_VALUE ) ; nsMutationGuard :: DidMutate ( ) ; PRBool isAppend = ( aIndex == childCount ) ; mozAutoDocUpdate updateBatch ( aDocument , UPDATE_CONTENT_MODEL , aNotify ) ; rv = aChildArray . InsertChildAt ( aKid , aIndex ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aKid -> BindToTree ( aDocument , aParent , nsnull , PR_TRUE ) ; if ( NS_FAILED ( rv ) ) { aChildArray . RemoveChildAt ( aIndex ) ; aKid -> UnbindFromTree ( ) ; return rv ; } NS_ASSERTION ( aKid -> GetNodeParent ( ) == container , "Did we run script inappropriately?" ) ; if ( aNotify ) { if ( aParent && isAppend ) { nsNodeUtils :: ContentAppended ( aParent , aIndex ) ; } else { nsNodeUtils :: ContentInserted ( container , aKid , aIndex ) ; } if ( nsContentUtils :: HasMutationListeners ( aKid , NS_EVENT_BITS_MUTATION_NODEINSERTED , container ) ) { mozAutoRemovableBlockerRemover blockerRemover ; nsMutationEvent mutation ( PR_TRUE , NS_MUTATION_NODEINSERTED ) ; mutation . mRelatedNode = do_QueryInterface ( container ) ; mozAutoSubtreeModified subtree ( container -> GetOwnerDoc ( ) , container ) ; nsEventDispatcher :: Dispatch ( aKid , nsnull , & mutation ) ; } } return NS_OK ; }
void Scavenger :: Finalize ( ) { heap ( ) -> MergeAllocationSitePretenuringFeedback ( local_pretenuring_feedback_ ) ; heap ( ) -> IncrementSemiSpaceCopiedObjectSize ( copied_size_ ) ; heap ( ) -> IncrementPromotedObjectsSize ( promoted_size_ ) ; allocator_ . Finalize ( ) ; }
IGNITION_HANDLER ( JumpIfToBooleanTrue , InterpreterAssembler ) { Node * value = GetAccumulator ( ) ; Node * relative_jump = BytecodeOperandUImmWord ( 0 ) ; Label if_true ( this ) , if_false ( this ) ; BranchIfToBooleanIsTrue ( value , & if_true , & if_false ) ; BIND ( & if_true ) ; Jump ( relative_jump ) ; BIND ( & if_false ) ; Dispatch ( ) ; }
void RegExpMacroAssemblerX64 :: SetCurrentPositionFromEnd ( int by ) { Label after_position ; __ cmpp ( rdi , Immediate ( - by * char_size ( ) ) ) ; __ j ( greater_equal , & after_position , Label :: kNear ) ; __ movq ( rdi , Immediate ( - by * char_size ( ) ) ) ; LoadCurrentCharacterUnchecked ( - 1 , 1 ) ; __ bind ( & after_position ) ; }
static bool IsMarkedInternal ( T * thingp ) { bool rv = true ; * thingp = DispatchTyped ( IsMarkedFunctor < T > ( ) , * thingp , & rv ) ; return rv ; } bool
int common_timer_set ( struct k_itimer * timr , int flags , struct itimerspec64 * new_setting , struct itimerspec64 * old_setting ) { const struct k_clock * kc = timr -> kclock ; bool sigev_none ; ktime_t expires ; if ( old_setting ) common_timer_get ( timr , old_setting ) ; timr -> it_interval = 0 ; if ( kc -> timer_try_to_cancel ( timr ) < 0 ) return TIMER_RETRY ; timr -> it_active = 0 ; timr -> it_requeue_pending = ( timr -> it_requeue_pending + 2 ) & ~ REQUEUE_PENDING ; timr -> it_overrun_last = 0 ; if ( ! new_setting -> it_value . tv_sec && ! new_setting -> it_value . tv_nsec ) return 0 ; timr -> it_interval = timespec64_to_ktime ( new_setting -> it_interval ) ; expires = timespec64_to_ktime ( new_setting -> it_value ) ; sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ; timr -> it_active = ! sigev_none ; return 0 ; }
int crypto_reportstat ( struct sk_buff * in_skb , struct nlmsghdr * in_nlh , struct nlattr * * attrs ) { struct net * net = sock_net ( in_skb -> sk ) ; struct crypto_user_alg * p = nlmsg_data ( in_nlh ) ; struct crypto_alg * alg ; struct sk_buff * skb ; struct crypto_dump_info info ; int err ; if ( ! null_terminated ( p -> cru_name ) || ! null_terminated ( p -> cru_driver_name ) ) return - EINVAL ; alg = crypto_alg_match ( p , 0 ) ; if ( ! alg ) return - ENOENT ; err = - ENOMEM ; skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) goto drop_alg ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = in_nlh -> nlmsg_seq ; info . nlmsg_flags = 0 ; err = crypto_reportstat_alg ( alg , & info ) ; drop_alg : crypto_mod_put ( alg ) ; if ( err ) return err ; return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ; }
EFFECT_DEPENDENT_OP_LIST ( GET_FROM_CACHE ) CHECKED_OP_LIST ( GET_FROM_CACHE ) GET_FROM_CACHE ( ArrayBufferWasNeutered ) GET_FROM_CACHE ( ArgumentsFrame ) GET_FROM_CACHE ( FindOrderedHashMapEntry ) GET_FROM_CACHE ( FindOrderedHashMapEntryForInt32Key ) GET_FROM_CACHE ( LoadFieldByIndex ) #undef GET_FROM_CACHE #define GET_FROM_CACHE_WITH_FEEDBACK(Name, value_input_count,               \                                      value_output_count)                    \  const Operator* SimplifiedOperatorBuilder::Name(                          \  const VectorSlotPair& feedback) {                                     \  if (!feedback.IsValid()) {                                              \  return &cache_.k##Name;                                               \  }                                                                       \  return new (zone()) Operator1<CheckParameters>(                         \  IrOpcode::k##Name, Operator::kFoldable | Operator::kNoThrow, #Name, \         value_input_count, 1, 1, value_output_count, 1, 0,                  \  CheckParameters(feedback));                                         \  } CHECKED_WITH_FEEDBACK_OP_LIST ( GET_FROM_CACHE_WITH_FEEDBACK ) #undef GET_FROM_CACHE_WITH_FEEDBACK bool IsCheckedWithFeedback ( const Operator * op ) { #define CASE(Name, ...) case IrOpcode::k##Name: switch ( op -> opcode ( ) ) { CHECKED_WITH_FEEDBACK_OP_LIST ( CASE ) return true ; default : return false ; } #undef CASE }
void Deserializer < AllocatorT > :: Initialize ( Isolate * isolate ) { DCHECK_NULL ( isolate_ ) ; DCHECK_NOT_NULL ( isolate ) ; isolate_ = isolate ; DCHECK_NULL ( external_reference_table_ ) ; external_reference_table_ = isolate -> heap ( ) -> external_reference_table ( ) ; #ifdef DEBUG num_api_references_ = 0 ; if ( isolate_ -> api_external_references ( ) != nullptr ) { while ( isolate_ -> api_external_references ( ) [ num_api_references_ ] != 0 ) { num_api_references_ ++ ; } } #endif // DEBUG CHECK_EQ ( magic_number_ , SerializedData :: ComputeMagicNumber ( external_reference_table_ ) ) ; }
future < fragmented_temporary_buffer > cql_server :: connection :: read_and_decompress_frame ( size_t length , uint8_t flags ) { using namespace compression_buffers ; if ( flags & cql_frame_flags :: compression ) { if ( _compression == cql_compression :: lz4 ) { if ( length < 4 ) { throw std :: runtime_error ( fmt :: format ( "CQL frame truncated: expected to have at least 4 bytes, got {}" , length ) ) ; } return _buffer_reader . read_exactly ( _read_buf , length ) . then ( [ this ] ( fragmented_temporary_buffer buf ) { auto linearization_buffer = bytes_ostream ( ) ; int32_t uncomp_len = request_reader ( buf . get_istream ( ) , linearization_buffer ) . read_int ( ) ; if ( uncomp_len < 0 ) { throw std :: runtime_error ( "CQL frame uncompressed length is negative: " + std :: to_string ( uncomp_len ) ) ; } buf . remove_prefix ( 4 ) ; auto in = input_buffer . get_linearized_view ( fragmented_temporary_buffer :: view ( buf ) ) ; auto uncomp = output_buffer . make_fragmented_temporary_buffer ( uncomp_len , fragmented_temporary_buffer :: default_fragment_size , [ & ] ( bytes_mutable_view out ) { auto ret = LZ4_decompress_safe ( reinterpret_cast < const char * > ( in . data ( ) ) , reinterpret_cast < char * > ( out . data ( ) ) , in . size ( ) , out . size ( ) ) ; if ( ret < 0 ) { throw std :: runtime_error ( "CQL frame LZ4 uncompression failure" ) ; } return out . size ( ) ; } ) ; on_compression_buffer_use ( ) ; return uncomp ; } ) ; } else if ( _compression == cql_compression :: snappy ) { return _buffer_reader . read_exactly ( _read_buf , length ) . then ( [ this ] ( fragmented_temporary_buffer buf ) { auto in = input_buffer . get_linearized_view ( fragmented_temporary_buffer :: view ( buf ) ) ; size_t uncomp_len ; if ( snappy_uncompressed_length ( reinterpret_cast < const char * > ( in . data ( ) ) , in . size ( ) , & uncomp_len ) != SNAPPY_OK ) { throw std :: runtime_error ( "CQL frame Snappy uncompressed size is unknown" ) ; } auto uncomp = output_buffer . make_fragmented_temporary_buffer ( uncomp_len , fragmented_temporary_buffer :: default_fragment_size , [ & ] ( bytes_mutable_view out ) { size_t output_len = out . size ( ) ; if ( snappy_uncompress ( reinterpret_cast < const char * > ( in . data ( ) ) , in . size ( ) , reinterpret_cast < char * > ( out . data ( ) ) , & output_len ) != SNAPPY_OK ) { throw std :: runtime_error ( "CQL frame Snappy uncompression failure" ) ; } return output_len ; } ) ; on_compression_buffer_use ( ) ; return uncomp ; } ) ; } else { throw exceptions :: protocol_exception ( format ( "Unknown compression algorithm" ) ) ; } } return _buffer_reader . read_exactly ( _read_buf , length ) ; }
Node * SimplifiedLowering :: Uint32Mod ( Node * const node ) { Uint32BinopMatcher m ( node ) ; Node * const minus_one = jsgraph ( ) -> Int32Constant ( - 1 ) ; Node * const zero = jsgraph ( ) -> Uint32Constant ( 0 ) ; Node * const lhs = m . left ( ) . node ( ) ; Node * const rhs = m . right ( ) . node ( ) ; if ( m . right ( ) . Is ( 0 ) ) { return zero ; } else if ( m . right ( ) . HasValue ( ) ) { return graph ( ) -> NewNode ( machine ( ) -> Uint32Mod ( ) , lhs , rhs , graph ( ) -> start ( ) ) ; } const Operator * const merge_op = common ( ) -> Merge ( 2 ) ; const Operator * const phi_op = common ( ) -> Phi ( MachineRepresentation :: kWord32 , 2 ) ; Node * check0 = graph ( ) -> NewNode ( machine ( ) -> Word32Equal ( ) , rhs , zero ) ; Node * branch0 = graph ( ) -> NewNode ( common ( ) -> Branch ( BranchHint :: kFalse ) , check0 , graph ( ) -> start ( ) ) ; Node * if_true0 = graph ( ) -> NewNode ( common ( ) -> IfTrue ( ) , branch0 ) ; Node * true0 = zero ; Node * if_false0 = graph ( ) -> NewNode ( common ( ) -> IfFalse ( ) , branch0 ) ; Node * false0 ; { Node * msk = graph ( ) -> NewNode ( machine ( ) -> Int32Add ( ) , rhs , minus_one ) ; Node * check1 = graph ( ) -> NewNode ( machine ( ) -> Word32And ( ) , rhs , msk ) ; Node * branch1 = graph ( ) -> NewNode ( common ( ) -> Branch ( ) , check1 , if_false0 ) ; Node * if_true1 = graph ( ) -> NewNode ( common ( ) -> IfTrue ( ) , branch1 ) ; Node * true1 = graph ( ) -> NewNode ( machine ( ) -> Uint32Mod ( ) , lhs , rhs , if_true1 ) ; Node * if_false1 = graph ( ) -> NewNode ( common ( ) -> IfFalse ( ) , branch1 ) ; Node * false1 = graph ( ) -> NewNode ( machine ( ) -> Word32And ( ) , lhs , msk ) ; if_false0 = graph ( ) -> NewNode ( merge_op , if_true1 , if_false1 ) ; false0 = graph ( ) -> NewNode ( phi_op , true1 , false1 , if_false0 ) ; } Node * merge0 = graph ( ) -> NewNode ( merge_op , if_true0 , if_false0 ) ; return graph ( ) -> NewNode ( phi_op , true0 , false0 , merge0 ) ; }
TF_BUILTIN ( WeakCollectionDelete , WeakCollectionsBuiltinsAssembler ) { TNode < Context > context = CAST ( Parameter ( Descriptor :: kContext ) ) ; TNode < JSWeakCollection > collection = CAST ( Parameter ( Descriptor :: kCollection ) ) ; TNode < Object > key = CAST ( Parameter ( Descriptor :: kKey ) ) ; Label call_runtime ( this ) , if_not_found ( this ) ; GotoIfNotJSReceiver ( key , & if_not_found ) ; TNode < IntPtrT > hash = LoadJSReceiverIdentityHash ( key , & if_not_found ) ; TNode < EphemeronHashTable > table = LoadTable ( collection ) ; TNode < IntPtrT > capacity = LoadTableCapacity ( table ) ; TNode < IntPtrT > key_index = FindKeyIndexForKey ( table , key , hash , EntryMask ( capacity ) , & if_not_found ) ; TNode < IntPtrT > number_of_elements = LoadNumberOfElements ( table , - 1 ) ; GotoIf ( ShouldShrink ( capacity , number_of_elements ) , & call_runtime ) ; RemoveEntry ( table , key_index , number_of_elements ) ; Return ( TrueConstant ( ) ) ; BIND ( & if_not_found ) ; Return ( FalseConstant ( ) ) ; BIND ( & call_runtime ) ; Return ( CallRuntime ( Runtime :: kWeakCollectionDelete , context , collection , key , SmiTag ( hash ) ) ) ; }
void ChangeToPureOp ( Node * node , const Operator * new_op ) { DCHECK ( new_op -> HasProperty ( Operator :: kPure ) ) ; if ( node -> op ( ) -> EffectInputCount ( ) > 0 ) { DCHECK_LT ( 0 , node -> op ( ) -> ControlInputCount ( ) ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; ReplaceEffectControlUses ( node , effect , control ) ; node -> TrimInputCount ( new_op -> ValueInputCount ( ) ) ; } else { DCHECK_EQ ( 0 , node -> op ( ) -> ControlInputCount ( ) ) ; } NodeProperties :: ChangeOp ( node , new_op ) ; }
void GCExtension :: GC ( const v8 :: FunctionCallbackInfo < v8 :: Value > & args ) { args . GetIsolate ( ) -> RequestGarbageCollectionForTesting ( args [ 0 ] -> BooleanValue ( args . GetIsolate ( ) -> GetCurrentContext ( ) ) . FromMaybe ( false ) ? v8 :: Isolate :: kMinorGarbageCollection : v8 :: Isolate :: kFullGarbageCollection ) ; }
static int __pyx_pw_17clickhouse_driver_14bufferedreader_20BufferedSocketReader_1__init__ ( PyObject * __pyx_v_self , PyObject * __pyx_args , PyObject * __pyx_kwds ) { PyObject * __pyx_v_sock = 0 ; PyObject * __pyx_v_bufsize = 0 ; int __pyx_r ; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext ( "__init__ (wrapper)" , 0 ) ; { static PyObject * * __pyx_pyargnames [ ] = { & __pyx_n_s_sock , & __pyx_n_s_bufsize , 0 } ; PyObject * values [ 2 ] = { 0 , 0 } ; if ( unlikely ( __pyx_kwds ) ) { Py_ssize_t kw_args ; const Py_ssize_t pos_args = PyTuple_GET_SIZE ( __pyx_args ) ; switch ( pos_args ) { case 2 : values [ 1 ] = PyTuple_GET_ITEM ( __pyx_args , 1 ) ; CYTHON_FALLTHROUGH ; case 1 : values [ 0 ] = PyTuple_GET_ITEM ( __pyx_args , 0 ) ; CYTHON_FALLTHROUGH ; case 0 : break ; default : goto __pyx_L5_argtuple_error ; } kw_args = PyDict_Size ( __pyx_kwds ) ; switch ( pos_args ) { case 0 : if ( likely ( ( values [ 0 ] = __Pyx_PyDict_GetItemStr ( __pyx_kwds , __pyx_n_s_sock ) ) != 0 ) ) kw_args -- ; else goto __pyx_L5_argtuple_error ; CYTHON_FALLTHROUGH ; case 1 : if ( likely ( ( values [ 1 ] = __Pyx_PyDict_GetItemStr ( __pyx_kwds , __pyx_n_s_bufsize ) ) != 0 ) ) kw_args -- ; else { __Pyx_RaiseArgtupleInvalid ( "__init__" , 1 , 2 , 2 , 1 ) ; __PYX_ERR ( 0 , 183 , __pyx_L3_error ) } } if ( unlikely ( kw_args > 0 ) ) { if ( unlikely ( __Pyx_ParseOptionalKeywords ( __pyx_kwds , __pyx_pyargnames , 0 , values , pos_args , "__init__" ) < 0 ) ) __PYX_ERR ( 0 , 183 , __pyx_L3_error ) } } else if ( PyTuple_GET_SIZE ( __pyx_args ) != 2 ) { goto __pyx_L5_argtuple_error ; } else { values [ 0 ] = PyTuple_GET_ITEM ( __pyx_args , 0 ) ; values [ 1 ] = PyTuple_GET_ITEM ( __pyx_args , 1 ) ; } __pyx_v_sock = values [ 0 ] ; __pyx_v_bufsize = values [ 1 ] ; } goto __pyx_L4_argument_unpacking_done ; __pyx_L5_argtuple_error : ; __Pyx_RaiseArgtupleInvalid ( "__init__" , 1 , 2 , 2 , PyTuple_GET_SIZE ( __pyx_args ) ) ; __PYX_ERR ( 0 , 183 , __pyx_L3_error ) __pyx_L3_error : ; __Pyx_AddTraceback ( "clickhouse_driver.bufferedreader.BufferedSocketReader.__init__" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __Pyx_RefNannyFinishContext ( ) ; return - 1 ; __pyx_L4_argument_unpacking_done : ; __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedreader_20BufferedSocketReader___init__ ( ( ( struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedSocketReader * ) __pyx_v_self ) , __pyx_v_sock , __pyx_v_bufsize ) ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
WebGLContext :: CompileShader ( nsIWebGLShader * sobj ) { if ( mContextLost ) return NS_OK ; WebGLShader * shader ; WebGLuint shadername ; if ( ! GetConcreteObjectAndGLName ( "compileShader" , sobj , & shader , & shadername ) ) return NS_OK ; MakeContextCurrent ( ) ; #if defined(USE_ANGLE) if ( shader -> NeedsTranslation ( ) && mShaderValidation ) { ShHandle compiler = 0 ; ShBuiltInResources resources ; memset ( & resources , 0 , sizeof ( ShBuiltInResources ) ) ; resources . MaxVertexAttribs = mGLMaxVertexAttribs ; resources . MaxVertexUniformVectors = mGLMaxVertexUniformVectors ; resources . MaxVaryingVectors = mGLMaxVaryingVectors ; resources . MaxVertexTextureImageUnits = mGLMaxVertexTextureImageUnits ; resources . MaxCombinedTextureImageUnits = mGLMaxTextureUnits ; resources . MaxTextureImageUnits = mGLMaxTextureImageUnits ; resources . MaxFragmentUniformVectors = mGLMaxFragmentUniformVectors ; resources . MaxDrawBuffers = 1 ; if ( mEnabledExtensions [ WebGL_OES_standard_derivatives ] ) resources . OES_standard_derivatives = 1 ; compiler = ShConstructCompiler ( ( ShShaderType ) shader -> ShaderType ( ) , SH_WEBGL_SPEC , gl -> IsGLES2 ( ) ? SH_ESSL_OUTPUT : SH_GLSL_OUTPUT , & resources ) ; StripComments stripComments ( shader -> Source ( ) ) ; const nsAString & cleanSource = nsString ( stripComments . result ( ) . Elements ( ) , stripComments . length ( ) ) ; if ( ! ValidateGLSLString ( cleanSource , "compileShader" ) ) return NS_OK ; const nsPromiseFlatString & flatSource = PromiseFlatString ( cleanSource ) ; const nsCString & sourceCString = NS_LossyConvertUTF16toASCII ( flatSource ) ; const PRUint32 maxSourceLength = ( PRUint32 ( 1 ) < < 18 ) - 1 ; if ( sourceCString . Length ( ) > maxSourceLength ) return ErrorInvalidValue ( "compileShader: source has more than %d characters" , maxSourceLength ) ; const char * s = sourceCString . get ( ) ; int compileOptions = SH_OBJECT_CODE ; #ifdef XP_MACOSX PRInt32 version = 0 ; OSErr err = :: Gestalt ( gestaltSystemVersion , & version ) ; if ( err != noErr ) { version = 0 ; } else { version &= 0xFFFF ; } if ( version < 0x1070 && gl -> Vendor ( ) == gl :: GLContext :: VendorATI ) compileOptions |= SH_EMULATE_BUILT_IN_FUNCTIONS ; #endif if ( ! ShCompile ( compiler , & s , 1 , compileOptions ) ) { int len = 0 ; ShGetInfo ( compiler , SH_INFO_LOG_LENGTH , & len ) ; if ( len ) { nsCAutoString info ; info . SetLength ( len ) ; ShGetInfoLog ( compiler , info . BeginWriting ( ) ) ; shader -> SetTranslationFailure ( info ) ; } else { shader -> SetTranslationFailure ( NS_LITERAL_CSTRING ( "Internal error: failed to get shader info log" ) ) ; } ShDestruct ( compiler ) ; return NS_OK ; } if ( ! gl -> IsGLES2 ( ) ) { int len = 0 ; ShGetInfo ( compiler , SH_OBJECT_CODE_LENGTH , & len ) ; nsCAutoString translatedSrc ; translatedSrc . SetLength ( len ) ; ShGetObjectCode ( compiler , translatedSrc . BeginWriting ( ) ) ; nsPromiseFlatCString translatedSrc2 ( translatedSrc ) ; const char * ts = translatedSrc2 . get ( ) ; gl -> fShaderSource ( shadername , 1 , & ts , NULL ) ; } else { gl -> fShaderSource ( shadername , 1 , & s , NULL ) ; } shader -> SetTranslationSuccess ( ) ; ShDestruct ( compiler ) ; gl -> fCompileShader ( shadername ) ; } #endif return NS_OK ; }
static pj_status_t STATUS_FROM_SSL_ERR ( char * action , pj_ssl_sock_t * ssock , unsigned long err ) { int level = 0 ; int len = 0 ; ERROR_LOG ( "STATUS_FROM_SSL_ERR" , err , ssock ) ; level ++ ; if ( err == SSL_ERROR_SSL ) { err = ERR_get_error ( ) ; ERROR_LOG ( "STATUS_FROM_SSL_ERR" , err , ssock ) ; } ssock -> last_err = err ; return GET_STATUS_FROM_SSL_ERR ( err ) ; }
Status KeyStoreService :: getKeyCharacteristics ( const String16 & name , const :: android :: security :: keymaster :: KeymasterBlob & clientId , const :: android :: security :: keymaster :: KeymasterBlob & appData , int32_t uid , :: android :: security :: keymaster :: KeyCharacteristics * outCharacteristics , int32_t * aidl_return ) { if ( ! outCharacteristics ) { * aidl_return = static_cast < int32_t > ( KeyStoreServiceReturnCode ( ErrorCode :: UNEXPECTED_NULL_POINTER ) ) ; return Status :: ok ( ) ; } uid_t targetUid = getEffectiveUid ( uid ) ; uid_t callingUid = IPCThreadState :: self ( ) -> getCallingUid ( ) ; if ( ! is_granted_to ( callingUid , targetUid ) ) { ALOGW ( "uid %d not permitted to act for uid %d in getKeyCharacteristics" , callingUid , targetUid ) ; * aidl_return = static_cast < int32_t > ( ResponseCode :: PERMISSION_DENIED ) ; return Status :: ok ( ) ; } Blob keyBlob ; String8 name8 ( name ) ; KeyStoreServiceReturnCode rc = mKeyStore -> getKeyForName ( & keyBlob , name8 , targetUid , TYPE_KEYMASTER_10 ) ; if ( rc == ResponseCode :: UNINITIALIZED ) { rc = mKeyStore -> getKeyForName ( & keyBlob , name8 , targetUid , TYPE_KEY_CHARACTERISTICS ) ; if ( ! rc . isOk ( ) ) { * aidl_return = static_cast < int32_t > ( rc ) ; return Status :: ok ( ) ; } AuthorizationSet keyCharacteristics ; std :: string charBuffer ( reinterpret_cast < const char * > ( keyBlob . getValue ( ) ) , keyBlob . getLength ( ) ) ; std :: stringstream charStream ( charBuffer ) ; keyCharacteristics . Deserialize ( & charStream ) ; outCharacteristics -> softwareEnforced = KeymasterArguments ( keyCharacteristics . hidl_data ( ) ) ; * aidl_return = static_cast < int32_t > ( rc ) ; return Status :: ok ( ) ; } else if ( ! rc . isOk ( ) ) { * aidl_return = static_cast < int32_t > ( rc ) ; return Status :: ok ( ) ; } auto hidlKeyBlob = blob2hidlVec ( keyBlob ) ; auto dev = mKeyStore -> getDevice ( keyBlob ) ; KeyStoreServiceReturnCode error ; auto hidlCb = [ & ] ( ErrorCode ret , const KeyCharacteristics & keyCharacteristics ) { error = ret ; if ( ! error . isOk ( ) ) { if ( error == ErrorCode :: INVALID_KEY_BLOB ) { log_key_integrity_violation ( name8 , targetUid ) ; } return ; } * outCharacteristics = :: android :: security :: keymaster :: KeyCharacteristics ( keyCharacteristics ) ; } ; rc = KS_HANDLE_HIDL_ERROR ( dev -> getKeyCharacteristics ( hidlKeyBlob , clientId . getData ( ) , appData . getData ( ) , hidlCb ) ) ; if ( ! rc . isOk ( ) ) { * aidl_return = static_cast < int32_t > ( rc ) ; return Status :: ok ( ) ; } if ( error == ErrorCode :: KEY_REQUIRES_UPGRADE ) { AuthorizationSet upgradeParams ; if ( clientId . getData ( ) . size ( ) ) { upgradeParams . push_back ( TAG_APPLICATION_ID , clientId . getData ( ) ) ; } if ( appData . getData ( ) . size ( ) ) { upgradeParams . push_back ( TAG_APPLICATION_DATA , appData . getData ( ) ) ; } rc = upgradeKeyBlob ( name , targetUid , upgradeParams , & keyBlob ) ; if ( ! rc . isOk ( ) ) { * aidl_return = static_cast < int32_t > ( rc ) ; return Status :: ok ( ) ; } auto upgradedHidlKeyBlob = blob2hidlVec ( keyBlob ) ; rc = KS_HANDLE_HIDL_ERROR ( dev -> getKeyCharacteristics ( upgradedHidlKeyBlob , clientId . getData ( ) , appData . getData ( ) , hidlCb ) ) ; if ( ! rc . isOk ( ) ) { * aidl_return = static_cast < int32_t > ( rc ) ; return Status :: ok ( ) ; } } * aidl_return = static_cast < int32_t > ( KeyStoreServiceReturnCode ( error ) ) ; return Status :: ok ( ) ; }
static int __f2fs_set_acl ( struct inode * inode , int type , struct posix_acl * acl , struct page * ipage ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; if ( error < 0 ) return error ; set_acl_inode ( inode , inode -> i_mode ) ; if ( error == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = f2fs_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) { clear_inode_flag ( inode , FI_ACL_MODE ) ; return ( int ) PTR_ERR ( value ) ; } } error = f2fs_setxattr ( inode , name_index , "" , value , size , ipage , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; clear_inode_flag ( inode , FI_ACL_MODE ) ; return error ; }
WorkerPrivate :: ReportError ( JSContext * aCx , const char * aFallbackMessage , JSErrorReport * aReport ) { AssertIsOnWorkerThread ( ) ; if ( ! MayContinueRunning ( ) || mErrorHandlerRecursionCount == 2 ) { return ; } NS_ASSERTION ( mErrorHandlerRecursionCount == 0 || mErrorHandlerRecursionCount == 1 , "Bad recursion logic!" ) ; JS_ClearPendingException ( aCx ) ; nsString message , filename , line ; uint32_t lineNumber , columnNumber , flags , errorNumber ; JSExnType exnType = JSEXN_ERR ; bool mutedError = aReport && aReport -> isMuted ; if ( aReport ) { xpc :: ErrorReport :: ErrorReportToMessageString ( aReport , message ) ; filename = NS_ConvertUTF8toUTF16 ( aReport -> filename ) ; line = aReport -> uclinebuf ; lineNumber = aReport -> lineno ; columnNumber = aReport -> uctokenptr - aReport -> uclinebuf ; flags = aReport -> flags ; errorNumber = aReport -> errorNumber ; MOZ_ASSERT ( aReport -> exnType >= JSEXN_NONE && aReport -> exnType < JSEXN_LIMIT ) ; exnType = JSExnType ( aReport -> exnType ) ; } else { lineNumber = columnNumber = errorNumber = 0 ; flags = nsIScriptError :: errorFlag | nsIScriptError :: exceptionFlag ; } if ( message . IsEmpty ( ) ) { nsDependentCString fallbackMessage ( aFallbackMessage ) ; if ( ! AppendUTF8toUTF16 ( fallbackMessage , message , mozilla :: fallible ) ) { nsDependentCString truncatedFallbackMessage ( aFallbackMessage , 1024 ) ; AppendUTF8toUTF16 ( truncatedFallbackMessage , message ) ; } } mErrorHandlerRecursionCount ++ ; bool fireAtScope = mErrorHandlerRecursionCount == 1 && ! mCloseHandlerStarted && errorNumber != JSMSG_OUT_OF_MEMORY && JS :: CurrentGlobalOrNull ( aCx ) ; ReportErrorRunnable :: ReportError ( aCx , this , fireAtScope , nullptr , message , filename , line , lineNumber , columnNumber , flags , errorNumber , exnType , mutedError , 0 ) ; mErrorHandlerRecursionCount -- ; }
Event_job_data :: execute ( THD * thd , bool drop ) { String sp_sql ; #ifndef NO_EMBEDDED_ACCESS_CHECKS Security_context event_sctx , * save_sctx = NULL ; #endif List < Item > empty_item_list ; bool ret = TRUE ; DBUG_ENTER ( "Event_job_data::execute" ) ; thd -> reset_for_next_command ( ) ; thd -> set_db ( dbname . str , dbname . length ) ; lex_start ( thd ) ; #ifndef NO_EMBEDDED_ACCESS_CHECKS if ( event_sctx . change_security_context ( thd , & definer_user , & definer_host , & dbname , & save_sctx ) ) { sql_print_error ( "Event Scheduler: " "[%s].[%s.%s] execution failed, " "failed to authenticate the user." , definer . str , dbname . str , name . str ) ; goto end ; } #endif if ( check_access ( thd , EVENT_ACL , dbname . str , NULL , NULL , 0 , 0 ) ) { sql_print_error ( "Event Scheduler: " "[%s].[%s.%s] execution failed, " "user no longer has EVENT privilege." , definer . str , dbname . str , name . str ) ; goto end ; } if ( construct_sp_sql ( thd , & sp_sql ) ) goto end ; thd -> variables . sql_mode = sql_mode ; thd -> variables . time_zone = time_zone ; thd -> set_query ( sp_sql . c_ptr_safe ( ) , sp_sql . length ( ) ) ; { Parser_state parser_state ; if ( parser_state . init ( thd , thd -> query ( ) , thd -> query_length ( ) ) ) goto end ; if ( parse_sql ( thd , & parser_state , creation_ctx ) ) { sql_print_error ( "Event Scheduler: " "%serror during compilation of %s.%s" , thd -> is_fatal_error ? "fatal " : "" , ( const char * ) dbname . str , ( const char * ) name . str ) ; goto end ; } } { sp_head * sphead = thd -> lex -> sphead ; DBUG_ASSERT ( sphead ) ; sphead -> m_flags |= sp_head :: LOG_SLOW_STATEMENTS ; sphead -> m_flags |= sp_head :: LOG_GENERAL_LOG ; sphead -> set_info ( 0 , 0 , & thd -> lex -> sp_chistics , sql_mode ) ; sphead -> set_creation_ctx ( creation_ctx ) ; sphead -> optimize ( ) ; ret = sphead -> execute_procedure ( thd , & empty_item_list ) ; } end : if ( drop && ! thd -> is_fatal_error ) { sql_print_information ( "Event Scheduler: Dropping %s.%s" , ( const char * ) dbname . str , ( const char * ) name . str ) ; if ( construct_drop_event_sql ( thd , & sp_sql ) ) ret = 1 ; else { ulong saved_master_access ; thd -> set_query ( sp_sql . c_ptr_safe ( ) , sp_sql . length ( ) ) ; saved_master_access = thd -> security_ctx -> master_access ; thd -> security_ctx -> master_access |= SUPER_ACL ; bool save_tx_read_only = thd -> tx_read_only ; thd -> tx_read_only = false ; if ( WSREP ( thd ) ) { thd -> lex -> sql_command = SQLCOM_DROP_EVENT ; WSREP_TO_ISOLATION_BEGIN ( WSREP_MYSQL_DB , NULL , NULL ) ; } ret = Events :: drop_event ( thd , dbname , name , FALSE ) ; WSREP_TO_ISOLATION_END ; #ifdef WITH_WSREP error : #endif thd -> tx_read_only = save_tx_read_only ; thd -> security_ctx -> master_access = saved_master_access ; } } #ifndef NO_EMBEDDED_ACCESS_CHECKS if ( save_sctx ) event_sctx . restore_security_context ( thd , save_sctx ) ; #endif thd -> lex -> unit . cleanup ( ) ; thd -> end_statement ( ) ; thd -> cleanup_after_query ( ) ; thd -> reset_query ( ) ; DBUG_PRINT ( "info" , ( "EXECUTED %s.%s  ret: %d" , dbname . str , name . str , ret ) ) ; DBUG_RETURN ( ret ) ; }
DOMSVGNumberList :: EnsureItemAt ( uint32_t aIndex ) { if ( ! mItems [ aIndex ] ) { mItems [ aIndex ] = new DOMSVGNumber ( this , AttrEnum ( ) , aIndex , IsAnimValList ( ) ) ; } }
GetInfoFromCookie ( nsCookie * aCookie , CookieStruct & aCookieStruct ) { aCookieStruct . name ( ) = aCookie -> Name ( ) ; aCookieStruct . value ( ) = aCookie -> Value ( ) ; aCookieStruct . host ( ) = aCookie -> Host ( ) ; aCookieStruct . path ( ) = aCookie -> Path ( ) ; aCookieStruct . expiry ( ) = aCookie -> Expiry ( ) ; aCookieStruct . lastAccessed ( ) = aCookie -> LastAccessed ( ) ; aCookieStruct . creationTime ( ) = aCookie -> CreationTime ( ) ; aCookieStruct . isSession ( ) = aCookie -> IsSession ( ) ; aCookieStruct . isSecure ( ) = aCookie -> IsSecure ( ) ; aCookieStruct . sameSite ( ) = aCookie -> SameSite ( ) ; }
jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; box -> info = boxinfo ; box -> ops = & boxinfo -> ops ; box -> len = len ; if ( box -> len == 1 ) { if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( "warning: cannot handle large 64-bit box length\n" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { jas_eprintf ( "cannot copy box data\n" ) ; goto error ; } jas_stream_rewind ( tmpstream ) ; if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( "cannot parse box data\n" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }
int cap_bprm_set_creds ( struct linux_binprm * bprm ) { const struct cred * old = current_cred ( ) ; struct cred * new = bprm -> cred ; bool effective , has_cap = false ; int ret ; effective = false ; ret = get_file_caps ( bprm , & effective , & has_cap ) ; if ( ret < 0 ) return ret ; if ( ! issecure ( SECURE_NOROOT ) ) { if ( has_cap && new -> uid != 0 && new -> euid == 0 ) { warn_setuid_and_fcaps_mixed ( bprm -> filename ) ; goto skip ; } if ( new -> euid == 0 || new -> uid == 0 ) { new -> cap_permitted = cap_combine ( old -> cap_bset , old -> cap_inheritable ) ; } if ( new -> euid == 0 ) effective = true ; } skip : if ( ( new -> euid != old -> uid || new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) { if ( ! capable ( CAP_SETUID ) ) { new -> euid = new -> uid ; new -> egid = new -> gid ; } new -> cap_permitted = cap_intersect ( new -> cap_permitted , old -> cap_permitted ) ; } new -> suid = new -> fsuid = new -> euid ; new -> sgid = new -> fsgid = new -> egid ; if ( effective ) new -> cap_effective = new -> cap_permitted ; else cap_clear ( new -> cap_effective ) ; bprm -> cap_effective = effective ; if ( ! cap_isclear ( new -> cap_effective ) ) { if ( ! cap_issubset ( CAP_FULL_SET , new -> cap_effective ) || new -> euid != 0 || new -> uid != 0 || issecure ( SECURE_NOROOT ) ) { ret = audit_log_bprm_fcaps ( bprm , new , old ) ; if ( ret < 0 ) return ret ; } } new -> securebits &= ~ issecure_mask ( SECURE_KEEP_CAPS ) ; return 0 ; }
BytecodeGenerator :: BytecodeGenerator ( UnoptimizedCompilationInfo * info , const AstStringConstants * ast_string_constants , ZoneVector < FunctionLiteral * > * eager_inner_literals ) : zone_ ( info -> zone ( ) ) , builder_ ( zone ( ) , info -> num_parameters_including_this ( ) , info -> scope ( ) -> num_stack_slots ( ) , info -> feedback_vector_spec ( ) , info -> SourcePositionRecordingMode ( ) ) , info_ ( info ) , ast_string_constants_ ( ast_string_constants ) , closure_scope_ ( info -> scope ( ) ) , current_scope_ ( info -> scope ( ) ) , eager_inner_literals_ ( eager_inner_literals ) , feedback_slot_cache_ ( new ( zone ( ) ) FeedbackSlotCache ( zone ( ) ) ) , globals_builder_ ( new ( zone ( ) ) GlobalDeclarationsBuilder ( zone ( ) ) ) , block_coverage_builder_ ( nullptr ) , global_declarations_ ( 0 , zone ( ) ) , function_literals_ ( 0 , zone ( ) ) , native_function_literals_ ( 0 , zone ( ) ) , object_literals_ ( 0 , zone ( ) ) , array_literals_ ( 0 , zone ( ) ) , class_literals_ ( 0 , zone ( ) ) , template_objects_ ( 0 , zone ( ) ) , execution_control_ ( nullptr ) , execution_context_ ( nullptr ) , execution_result_ ( nullptr ) , incoming_new_target_or_generator_ ( ) , dummy_feedback_slot_ ( ) , generator_jump_table_ ( nullptr ) , suspend_count_ ( 0 ) , loop_depth_ ( 0 ) , catch_prediction_ ( HandlerTable :: UNCAUGHT ) { DCHECK_EQ ( closure_scope ( ) , closure_scope ( ) -> GetClosureScope ( ) ) ; if ( info -> has_source_range_map ( ) ) { block_coverage_builder_ = new ( zone ( ) ) BlockCoverageBuilder ( zone ( ) , builder ( ) , info -> source_range_map ( ) ) ; } }
AsmJSModule :: clone ( JSContext * cx , ScopedJSDeletePtr < AsmJSModule > * moduleOut ) const { * moduleOut = cx -> new_ < AsmJSModule > ( scriptSource_ , srcStart_ , srcBodyStart_ , pod . strict_ , pod . usesSignalHandlers_ ) ; if ( ! * moduleOut ) return false ; AsmJSModule & out = * * moduleOut ; out . pod = pod ; out . code_ = AllocateExecutableMemory ( cx , pod . totalBytes_ ) ; if ( ! out . code_ ) return false ; memcpy ( out . code_ , code_ , pod . codeBytes_ ) ; out . globalArgumentName_ = globalArgumentName_ ; out . importArgumentName_ = importArgumentName_ ; out . bufferArgumentName_ = bufferArgumentName_ ; if ( ! CloneVector ( cx , globals_ , & out . globals_ ) || ! CloneVector ( cx , exits_ , & out . exits_ ) || ! CloneVector ( cx , exports_ , & out . exports_ ) || ! ClonePodVector ( cx , callSites_ , & out . callSites_ ) || ! ClonePodVector ( cx , codeRanges_ , & out . codeRanges_ ) || ! ClonePodVector ( cx , funcPtrTables_ , & out . funcPtrTables_ ) || ! ClonePodVector ( cx , builtinThunkOffsets_ , & out . builtinThunkOffsets_ ) || ! CloneVector ( cx , names_ , & out . names_ ) || ! ClonePodVector ( cx , heapAccesses_ , & out . heapAccesses_ ) || ! staticLinkData_ . clone ( cx , & out . staticLinkData_ ) ) { return false ; } out . loadedFromCache_ = loadedFromCache_ ; out . profilingEnabled_ = profilingEnabled_ ; out . setAutoFlushICacheRange ( ) ; out . restoreToInitialState ( maybeHeap_ , code_ , cx ) ; return true ; }
ICSetProp_TypedObject :: Compiler :: generateStubCode ( MacroAssembler & masm ) { MOZ_ASSERT ( engine_ == Engine :: Baseline ) ; Label failure ; CheckForTypedObjectWithDetachedStorage ( cx , masm , & failure ) ; masm . branchTestObject ( Assembler :: NotEqual , R0 , & failure ) ; AllocatableGeneralRegisterSet regs ( availableGeneralRegs ( 2 ) ) ; Register scratch = regs . takeAny ( ) ; Register object = masm . extractObject ( R0 , ExtractTemp0 ) ; masm . loadPtr ( Address ( ICStubReg , ICSetProp_TypedObject :: offsetOfShape ( ) ) , scratch ) ; masm . branchTestObjShape ( Assembler :: NotEqual , object , scratch , & failure ) ; masm . loadPtr ( Address ( ICStubReg , ICSetProp_TypedObject :: offsetOfGroup ( ) ) , scratch ) ; masm . branchPtr ( Assembler :: NotEqual , Address ( object , JSObject :: offsetOfGroup ( ) ) , scratch , & failure ) ; if ( needsUpdateStubs ( ) ) { masm . push ( object ) ; masm . push ( ICStubReg ) ; EmitStowICValues ( masm , 2 ) ; masm . moveValue ( R1 , R0 ) ; if ( ! callTypeUpdateIC ( masm , sizeof ( Value ) ) ) return false ; EmitUnstowICValues ( masm , 2 ) ; masm . pop ( ICStubReg ) ; masm . pop ( object ) ; LiveGeneralRegisterSet saveRegs ; saveRegs . add ( R0 ) ; saveRegs . add ( R1 ) ; saveRegs . addUnchecked ( object ) ; saveRegs . add ( ICStubReg ) ; emitPostWriteBarrierSlot ( masm , object , R1 , scratch , saveRegs ) ; } Label failurePopRHS ; masm . pushValue ( R1 ) ; regs = availableGeneralRegs ( 1 ) ; regs . takeUnchecked ( object ) ; regs . take ( scratch ) ; Register secondScratch = regs . takeAny ( ) ; LoadTypedThingData ( masm , layout_ , object , scratch ) ; masm . load32 ( Address ( ICStubReg , ICSetProp_TypedObject :: offsetOfFieldOffset ( ) ) , secondScratch ) ; masm . addPtr ( secondScratch , scratch ) ; Address dest ( scratch , 0 ) ; Address value ( masm . getStackPointer ( ) , 0 ) ; if ( fieldDescr_ -> is < ScalarTypeDescr > ( ) ) { Scalar :: Type type = fieldDescr_ -> as < ScalarTypeDescr > ( ) . type ( ) ; StoreToTypedArray ( cx , masm , type , value , dest , secondScratch , & failurePopRHS , & failurePopRHS ) ; masm . popValue ( R1 ) ; } else { ReferenceTypeDescr :: Type type = fieldDescr_ -> as < ReferenceTypeDescr > ( ) . type ( ) ; masm . popValue ( R1 ) ; switch ( type ) { case ReferenceTypeDescr :: TYPE_ANY : EmitPreBarrier ( masm , dest , MIRType_Value ) ; masm . storeValue ( R1 , dest ) ; break ; case ReferenceTypeDescr :: TYPE_OBJECT : { EmitPreBarrier ( masm , dest , MIRType_Object ) ; Label notObject ; masm . branchTestObject ( Assembler :: NotEqual , R1 , & notObject ) ; Register rhsObject = masm . extractObject ( R1 , ExtractTemp0 ) ; masm . storePtr ( rhsObject , dest ) ; EmitReturnFromIC ( masm ) ; masm . bind ( & notObject ) ; masm . branchTestNull ( Assembler :: NotEqual , R1 , & failure ) ; masm . storePtr ( ImmWord ( 0 ) , dest ) ; break ; } case ReferenceTypeDescr :: TYPE_STRING : { EmitPreBarrier ( masm , dest , MIRType_String ) ; masm . branchTestString ( Assembler :: NotEqual , R1 , & failure ) ; Register rhsString = masm . extractString ( R1 , ExtractTemp0 ) ; masm . storePtr ( rhsString , dest ) ; break ; } default : MOZ_CRASH ( ) ; } } masm . moveValue ( R1 , R0 ) ; EmitReturnFromIC ( masm ) ; masm . bind ( & failurePopRHS ) ; masm . popValue ( R1 ) ; masm . bind ( & failure ) ; EmitStubGuardFailure ( masm ) ; return true ; }
void GetDevices ( const RefPtr < MediaManager :: MediaDeviceSetRefCnt > & aOutDevices ) { for ( auto & l : mActiveListeners ) { if ( RefPtr < MediaDevice > device = l -> GetAudioDevice ( ) ) { aOutDevices -> AppendElement ( device ) ; } if ( RefPtr < MediaDevice > device = l -> GetVideoDevice ( ) ) { aOutDevices -> AppendElement ( device ) ; } } }
void SMILAnimationController :: RemoveChild ( SMILTimeContainer & aChild ) { mChildContainerTable . RemoveEntry ( & aChild ) ; if ( ! mPauseState && mChildContainerTable . Count ( ) == 0 ) { StopSampling ( GetRefreshDriver ( ) ) ; } }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 2 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; TF_LITE_ENSURE_TYPES_EQ ( context , input -> type , output -> type ) ; const TfLiteTensor * multipliers = GetInput ( context , node , kInputMultipliers ) ; if ( multipliers -> type != kTfLiteInt32 && multipliers -> type != kTfLiteInt64 ) { context -> ReportError ( context , "Multipliers of type '%s' are not supported by tile." , TfLiteTypeGetName ( multipliers -> type ) ) ; return kTfLiteError ; } if ( IsConstantTensor ( multipliers ) ) { TF_LITE_ENSURE_OK ( context , ResizeOutput ( context , node ) ) ; } else { SetTensorToDynamic ( output ) ; } return kTfLiteOk ; }
RUNTIME_FUNCTION ( Runtime_NeverOptimizeFunction ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 1 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( Object , function_object , 0 ) ; if ( ! function_object -> IsJSFunction ( ) ) { return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; } Handle < JSFunction > function = Handle < JSFunction > :: cast ( function_object ) ; function -> shared ( ) -> DisableOptimization ( BailoutReason :: kOptimizationDisabledForTest ) ; return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
void ServerFeature :: collectOptions ( std :: shared_ptr < ProgramOptions > options ) { options -> addOption ( "--console" , "start a JavaScript emergency console" , new BooleanParameter ( & _console ) ) ; options -> addSection ( "server" , "server features" ) ; options -> addOption ( "--server.rest-server" , "start a rest-server" , new BooleanParameter ( & _restServer ) , arangodb :: options :: makeDefaultFlags ( arangodb :: options :: Flags :: Hidden ) ) ; options -> addOption ( "--server.validate-utf8-strings" , "perform UTF-8 string validation for incoming JSON and VelocyPack data" , new BooleanParameter ( & _validateUtf8Strings ) , arangodb :: options :: makeDefaultFlags ( arangodb :: options :: Flags :: Hidden ) ) . setIntroducedIn ( 30700 ) ; options -> addOption ( "--javascript.script" , "run scripts and exit" , new VectorParameter < StringParameter > ( & _scripts ) ) ; #if _WIN32 options -> addOption ( "--console.code-page" , "Windows code page to use; defaults to UTF8" , new UInt16Parameter ( & _codePage ) , arangodb :: options :: makeDefaultFlags ( arangodb :: options :: Flags :: Hidden ) ) ; #endif options -> addSection ( "vst" , "VelocyStream protocol" , "" , true , true ) ; options -> addObsoleteOption ( "--vst.maxsize" , "maximal size (in bytes) " "for a VelocyPack chunk" , true ) ; options -> addObsoleteOption ( "--server.session-timeout" , "timeout of web interface server sessions (in seconds)" , true ) ; options -> addSection ( "wal" , "WAL of the MMFiles engine" , "" , true , true ) ; options -> addObsoleteOption ( "--wal.allow-oversize-entries" , "allow entries that are bigger than '--wal.logfile-size'" , false ) ; options -> addObsoleteOption ( "--wal.use-mlock" , "mlock WAL logfiles in memory (may require elevated privileges or limits)" , false ) ; options -> addObsoleteOption ( "--wal.directory" , "logfile directory" , true ) ; options -> addObsoleteOption ( "--wal.historic-logfiles" , "maximum number of historic logfiles to keep after collection" , true ) ; options -> addObsoleteOption ( "--wal.ignore-logfile-errors" , "ignore logfile errors. this will read recoverable data from corrupted logfiles but ignore any unrecoverable data" , false ) ; options -> addObsoleteOption ( "--wal.ignore-recovery-errors" , "continue recovery even if re-applying operations fails" , false ) ; options -> addObsoleteOption ( "--wal.flush-timeout" , "flush timeout (in milliseconds)" , true ) ; options -> addObsoleteOption ( "--wal.logfile-size" , "size of each logfile (in bytes)" , true ) ; options -> addObsoleteOption ( "--wal.open-logfiles" , "maximum number of parallel open logfiles" , true ) ; options -> addObsoleteOption ( "--wal.reserve-logfiles" , "maximum number of reserve logfiles to maintain" , true ) ; options -> addObsoleteOption ( "--wal.slots" , "number of logfile slots to use" , true ) ; options -> addObsoleteOption ( "--wal.sync-interval" , "interval for automatic, non-requested disk syncs (in milliseconds)" , true ) ; options -> addObsoleteOption ( "--wal.throttle-when-pending" , "throttle writes when at least this many operations are waiting for collection (set to 0 to deactivate write-throttling)" , true ) ; options -> addObsoleteOption ( "--wal.throttle-wait" , "maximum wait time per operation when write-throttled (in milliseconds)" , true ) ; }
static int lg_probe ( struct hid_device * hdev , const struct hid_device_id * id ) { struct usb_interface * iface = to_usb_interface ( hdev -> dev . parent ) ; __u8 iface_num = iface -> cur_altsetting -> desc . bInterfaceNumber ; unsigned int connect_mask = HID_CONNECT_DEFAULT ; struct lg_drv_data * drv_data ; int ret ; if ( ( hdev -> product == USB_DEVICE_ID_LOGITECH_G29_WHEEL ) && ( iface_num != 0 ) ) { dbg_hid ( "%s: ignoring ifnum %d\n" , __func__ , iface_num ) ; return - ENODEV ; } drv_data = kzalloc ( sizeof ( struct lg_drv_data ) , GFP_KERNEL ) ; if ( ! drv_data ) { hid_err ( hdev , "Insufficient memory, cannot allocate driver data\n" ) ; return - ENOMEM ; } drv_data -> quirks = id -> driver_data ; hid_set_drvdata ( hdev , ( void * ) drv_data ) ; if ( drv_data -> quirks & LG_NOGET ) hdev -> quirks |= HID_QUIRK_NOGET ; ret = hid_parse ( hdev ) ; if ( ret ) { hid_err ( hdev , "parse failed\n" ) ; goto err_free ; } if ( drv_data -> quirks & ( LG_FF | LG_FF2 | LG_FF3 | LG_FF4 ) ) connect_mask &= ~ HID_CONNECT_FF ; ret = hid_hw_start ( hdev , connect_mask ) ; if ( ret ) { hid_err ( hdev , "hw start failed\n" ) ; goto err_free ; } if ( hdev -> product == USB_DEVICE_ID_LOGITECH_WII_WHEEL ) { static const unsigned char cbuf [ ] = { 0x00 , 0xAF , 0x01 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; u8 * buf = kmemdup ( cbuf , sizeof ( cbuf ) , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto err_stop ; } ret = hid_hw_raw_request ( hdev , buf [ 0 ] , buf , sizeof ( cbuf ) , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret >= 0 ) { wait_queue_head_t wait ; init_waitqueue_head ( & wait ) ; wait_event_interruptible_timeout ( wait , 0 , msecs_to_jiffies ( 40 ) ) ; buf [ 1 ] = 0xB2 ; get_random_bytes ( & buf [ 2 ] , 2 ) ; ret = hid_hw_raw_request ( hdev , buf [ 0 ] , buf , sizeof ( cbuf ) , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; } kfree ( buf ) ; } if ( drv_data -> quirks & LG_FF ) ret = lgff_init ( hdev ) ; else if ( drv_data -> quirks & LG_FF2 ) ret = lg2ff_init ( hdev ) ; else if ( drv_data -> quirks & LG_FF3 ) ret = lg3ff_init ( hdev ) ; else if ( drv_data -> quirks & LG_FF4 ) ret = lg4ff_init ( hdev ) ; if ( ret ) goto err_stop ; return 0 ; err_stop : hid_hw_stop ( hdev ) ; err_free : kfree ( drv_data ) ; return ret ; }
static int tiocspgrp ( struct tty_struct * tty , struct tty_struct * real_tty , pid_t __user * p ) { struct pid * pgrp ; pid_t pgrp_nr ; int retval = tty_check_change ( real_tty ) ; if ( retval == - EIO ) return - ENOTTY ; if ( retval ) return retval ; if ( ! current -> signal -> tty || ( current -> signal -> tty != real_tty ) || ( real_tty -> session != task_session ( current ) ) ) return - ENOTTY ; if ( get_user ( pgrp_nr , p ) ) return - EFAULT ; if ( pgrp_nr < 0 ) return - EINVAL ; rcu_read_lock ( ) ; pgrp = find_vpid ( pgrp_nr ) ; retval = - ESRCH ; if ( ! pgrp ) goto out_unlock ; retval = - EPERM ; if ( session_of_pgrp ( pgrp ) != task_session ( current ) ) goto out_unlock ; retval = 0 ; spin_lock_irq ( & tty -> ctrl_lock ) ; put_pid ( real_tty -> pgrp ) ; real_tty -> pgrp = get_pid ( pgrp ) ; spin_unlock_irq ( & tty -> ctrl_lock ) ; out_unlock : rcu_read_unlock ( ) ; return retval ; }
SWTPM_NVRAM_CheckHeader ( unsigned char * data , uint32_t length , uint32_t * dataoffset , uint16_t * hdrflags , uint8_t * hdrversion , bool quiet ) { blobheader * bh = ( blobheader * ) data ; if ( length < sizeof ( bh ) ) { if ( ! quiet ) logprintf ( STDERR_FILENO , "not enough bytes for header: %u\n" , length ) ; return TPM_BAD_PARAMETER ; } if ( ntohl ( bh -> totlen ) != length ) { if ( ! quiet ) logprintf ( STDERR_FILENO , "broken header: bh->totlen %u != %u\n" , htonl ( bh -> totlen ) , length ) ; return TPM_BAD_PARAMETER ; } if ( bh -> min_version > BLOB_HEADER_VERSION ) { if ( ! quiet ) logprintf ( STDERR_FILENO , "Minimum required version for the blob is %d, we " "only support version %d\n" , bh -> min_version , BLOB_HEADER_VERSION ) ; return TPM_BAD_VERSION ; } * hdrversion = bh -> version ; * dataoffset = ntohs ( bh -> hdrsize ) ; * hdrflags = ntohs ( bh -> flags ) ; return TPM_SUCCESS ; }
void AstPrinter :: VisitFunctionDeclaration ( FunctionDeclaration * node ) { PrintIndented ( "FUNCTION " ) ; PrintLiteral ( node -> proxy ( ) -> raw_name ( ) , true ) ; Print ( " = function " ) ; PrintLiteral ( node -> fun ( ) -> raw_name ( ) , false ) ; Print ( "\n" ) ; }
static void vdbeVComment ( Vdbe * p , const char * zFormat , va_list ap ) { assert ( p -> nOp > 0 || p -> aOp == 0 ) ; assert ( p -> aOp == 0 || p -> aOp [ p -> nOp - 1 ] . zComment == 0 || p -> db -> mallocFailed ) ; if ( p -> nOp ) { assert ( p -> aOp ) ; sqlite3DbFree ( p -> db , p -> aOp [ p -> nOp - 1 ] . zComment ) ; p -> aOp [ p -> nOp - 1 ] . zComment = sqlite3VMPrintf ( p -> db , zFormat , ap ) ; } }
int exfat_mount ( struct exfat * ef , const char * spec , const char * options ) { int rc ; enum exfat_mode mode ; exfat_tzset ( ) ; memset ( ef , 0 , sizeof ( struct exfat ) ) ; parse_options ( ef , options ) ; if ( match_option ( options , "ro" ) ) mode = EXFAT_MODE_RO ; else if ( match_option ( options , "ro_fallback" ) ) mode = EXFAT_MODE_ANY ; else mode = EXFAT_MODE_RW ; ef -> dev = exfat_open ( spec , mode ) ; if ( ef -> dev == NULL ) return - EIO ; if ( exfat_get_mode ( ef -> dev ) == EXFAT_MODE_RO ) { if ( mode == EXFAT_MODE_ANY ) ef -> ro = - 1 ; else ef -> ro = 1 ; } ef -> sb = malloc ( sizeof ( struct exfat_super_block ) ) ; if ( ef -> sb == NULL ) { exfat_close ( ef -> dev ) ; exfat_error ( "failed to allocate memory for the super block" ) ; return - ENOMEM ; } memset ( ef -> sb , 0 , sizeof ( struct exfat_super_block ) ) ; if ( exfat_pread ( ef -> dev , ef -> sb , sizeof ( struct exfat_super_block ) , 0 ) < 0 ) { exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( "failed to read boot sector" ) ; return - EIO ; } if ( memcmp ( ef -> sb -> oem_name , "EXFAT   " , 8 ) != 0 ) { exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( "exFAT file system is not found" ) ; return - EIO ; } ef -> zero_cluster = malloc ( CLUSTER_SIZE ( * ef -> sb ) ) ; if ( ef -> zero_cluster == NULL ) { exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( "failed to allocate zero sector" ) ; return - ENOMEM ; } if ( ! verify_vbr_checksum ( ef -> dev , ef -> zero_cluster , SECTOR_SIZE ( * ef -> sb ) ) ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; return - EIO ; } memset ( ef -> zero_cluster , 0 , CLUSTER_SIZE ( * ef -> sb ) ) ; if ( ef -> sb -> version . major != 1 || ef -> sb -> version . minor != 0 ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; exfat_error ( "unsupported exFAT version: %hhu.%hhu" , ef -> sb -> version . major , ef -> sb -> version . minor ) ; free ( ef -> sb ) ; return - EIO ; } if ( ef -> sb -> fat_count != 1 ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; exfat_error ( "unsupported FAT count: %hhu" , ef -> sb -> fat_count ) ; free ( ef -> sb ) ; return - EIO ; } if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; exfat_error ( "too big cluster size: 2^%d" , ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( le64_to_cpu ( ef -> sb -> sector_count ) * SECTOR_SIZE ( * ef -> sb ) > exfat_get_size ( ef -> dev ) ) { exfat_warn ( "file system is larger than underlying device: " "%"PRIu64 " > %"PRIu64 , le64_to_cpu ( ef -> sb -> sector_count ) * SECTOR_SIZE ( * ef -> sb ) , exfat_get_size ( ef -> dev ) ) ; } ef -> root = malloc ( sizeof ( struct exfat_node ) ) ; if ( ef -> root == NULL ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( "failed to allocate root node" ) ; return - ENOMEM ; } memset ( ef -> root , 0 , sizeof ( struct exfat_node ) ) ; ef -> root -> flags = EXFAT_ATTRIB_DIR ; ef -> root -> start_cluster = le32_to_cpu ( ef -> sb -> rootdir_cluster ) ; ef -> root -> fptr_cluster = ef -> root -> start_cluster ; ef -> root -> name [ 0 ] = cpu_to_le16 ( '\0' ) ; ef -> root -> size = rootdir_size ( ef ) ; if ( ef -> root -> size == 0 ) { free ( ef -> root ) ; free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; return - EIO ; } ef -> root -> mtime = 0 ; ef -> root -> atime = 0 ; exfat_get_node ( ef -> root ) ; rc = exfat_cache_directory ( ef , ef -> root ) ; if ( rc != 0 ) goto error ; if ( ef -> upcase == NULL ) { exfat_error ( "upcase table is not found" ) ; goto error ; } if ( ef -> cmap . chunk == NULL ) { exfat_error ( "clusters bitmap is not found" ) ; goto error ; } if ( prepare_super_block ( ef ) != 0 ) goto error ; return 0 ; error : exfat_put_node ( ef , ef -> root ) ; exfat_reset_cache ( ef ) ; free ( ef -> root ) ; free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; return - EIO ; }
DocAccessible :: MoveChild ( Accessible * aChild , Accessible * aNewParent , int32_t aIdxInParent ) { MOZ_ASSERT ( aChild , "No child" ) ; MOZ_ASSERT ( aChild -> Parent ( ) , "No parent" ) ; Accessible * curParent = aChild -> Parent ( ) ; #ifdef A11Y_LOG logging :: TreeInfo ( "move child" , 0 , "old parent" , curParent , "new parent" , aNewParent , "child" , aChild , nullptr ) ; #endif if ( aChild -> IsRelocated ( ) ) { nsTArray < RefPtr < Accessible > > * children = mARIAOwnsHash . Get ( curParent ) ; children -> RemoveElement ( aChild ) ; } NotificationController :: MoveGuard mguard ( mNotificationController ) ; if ( curParent == aNewParent ) { MOZ_ASSERT ( aChild -> IndexInParent ( ) != aIdxInParent , "No move case" ) ; curParent -> MoveChild ( aIdxInParent , aChild ) ; #ifdef A11Y_LOG logging :: TreeInfo ( "move child: parent tree after" , logging :: eVerbose , curParent ) ; #endif return true ; } if ( ! aNewParent -> IsAcceptableChild ( aChild -> GetContent ( ) ) ) { return false ; } TreeMutation rmut ( curParent ) ; rmut . BeforeRemoval ( aChild , TreeMutation :: kNoShutdown ) ; curParent -> RemoveChild ( aChild ) ; rmut . Done ( ) ; if ( aIdxInParent == - 1 ) { return true ; } TreeMutation imut ( aNewParent ) ; aNewParent -> InsertChildAt ( aIdxInParent , aChild ) ; imut . AfterInsertion ( aChild ) ; imut . Done ( ) ; #ifdef A11Y_LOG logging :: TreeInfo ( "move child: old parent tree after" , logging :: eVerbose , curParent ) ; logging :: TreeInfo ( "move child: new parent tree after" , logging :: eVerbose , aNewParent ) ; #endif return true ; }
LocalAllocationBuffer & LocalAllocationBuffer :: operator = ( const LocalAllocationBuffer & other ) { Close ( ) ; heap_ = other . heap_ ; allocation_info_ = other . allocation_info_ ; const_cast < LocalAllocationBuffer & > ( other ) . allocation_info_ . Reset ( kNullAddress , kNullAddress ) ; return * this ; }
void _luac_build_info ( LuaProto * proto , LuacBinInfo * info ) { char * section_name ; char * symbol_name ; char * proto_name ; char * * upvalue_names = NULL ; RzListIter * iter ; int i = 0 ; ut64 current_offset ; ut64 current_size ; if ( proto -> name_size == 0 || proto -> proto_name == NULL ) { proto_name = rz_str_newf ( "fcn.%08llx" , proto -> offset ) ; } else { proto_name = rz_str_new ( ( char * ) proto -> proto_name ) ; } current_offset = proto -> offset ; current_size = proto -> size ; section_name = rz_str_newf ( "%s.header" , proto_name ) ; luac_add_section ( info -> section_list , section_name , current_offset , current_size , false ) ; RZ_FREE ( section_name ) ; current_offset = proto -> code_offset ; current_size = proto -> code_size ; section_name = rz_str_newf ( "%s.code" , proto_name ) ; luac_add_section ( info -> section_list , section_name , current_offset , current_size , true ) ; RZ_FREE ( section_name ) ; current_offset = proto -> const_offset ; current_size = proto -> const_size ; section_name = rz_str_newf ( "%s.const" , proto_name ) ; luac_add_section ( info -> section_list , section_name , current_offset , current_size , false ) ; RZ_FREE ( section_name ) ; current_offset = proto -> upvalue_offset ; current_size = proto -> upvalue_size ; section_name = rz_str_newf ( "%s.upvalues" , proto_name ) ; luac_add_section ( info -> section_list , section_name , current_offset , current_size , false ) ; RZ_FREE ( section_name ) ; current_offset = proto -> inner_proto_offset ; current_size = proto -> inner_proto_size ; section_name = rz_str_newf ( "%s.protos" , proto_name ) ; luac_add_section ( info -> section_list , section_name , current_offset , current_size , false ) ; RZ_FREE ( section_name ) ; current_offset = proto -> debug_offset ; current_size = proto -> debug_size ; section_name = rz_str_newf ( "%s.debug" , proto_name ) ; luac_add_section ( info -> section_list , section_name , current_offset , current_size , false ) ; RZ_FREE ( section_name ) ; LuaLocalVarEntry * local_var_entry ; rz_list_foreach ( proto -> local_var_info_entries , iter , local_var_entry ) { luac_add_string ( info -> string_list , ( char * ) local_var_entry -> varname , local_var_entry -> offset , local_var_entry -> varname_len ) ; } size_t real_upvalue_cnt = rz_list_length ( proto -> upvalue_entries ) ; if ( real_upvalue_cnt > 0 ) { LuaDbgUpvalueEntry * debug_upv_entry ; upvalue_names = RZ_NEWS0 ( char * , real_upvalue_cnt ) ; if ( ! upvalue_names ) { free ( proto_name ) ; return ; } i = 0 ; rz_list_foreach ( proto -> dbg_upvalue_entries , iter , debug_upv_entry ) { upvalue_names [ i ] = ( char * ) debug_upv_entry -> upvalue_name ; luac_add_string ( info -> string_list , upvalue_names [ i ] , debug_upv_entry -> offset , debug_upv_entry -> name_len ) ; i ++ ; } } LuaConstEntry * const_entry ; rz_list_foreach ( proto -> const_entries , iter , const_entry ) { symbol_name = get_constant_symbol_name ( proto_name , const_entry ) ; luac_add_symbol ( info -> symbol_list , symbol_name , const_entry -> offset , const_entry -> data_len , get_tag_string ( const_entry -> tag ) ) ; if ( const_entry -> tag == LUA_VLNGSTR || const_entry -> tag == LUA_VSHRSTR ) { luac_add_string ( info -> string_list , ( char * ) const_entry -> data , const_entry -> offset , const_entry -> data_len ) ; } RZ_FREE ( symbol_name ) ; } LuaUpvalueEntry * upvalue_entry ; i = 0 ; rz_list_foreach ( proto -> upvalue_entries , iter , upvalue_entry ) { symbol_name = get_upvalue_symbol_name ( proto_name , upvalue_entry , upvalue_names [ i ++ ] ) ; luac_add_symbol ( info -> symbol_list , symbol_name , upvalue_entry -> offset , 3 , "UPVALUE" ) ; RZ_FREE ( symbol_name ) ; } LuaProto * sub_proto ; rz_list_foreach ( proto -> proto_entries , iter , sub_proto ) { _luac_build_info ( sub_proto , info ) ; } free ( upvalue_names ) ; free ( proto_name ) ; }
check_restricted ( void ) { if ( restricted ) { emsg ( _ ( "E145: Shell commands not allowed in rvim" ) ) ; return TRUE ; } return FALSE ; }
nsClipboardProxy :: GetData ( nsITransferable * aTransferable , int32_t aWhichClipboard ) { nsTArray < nsCString > types ; aTransferable -> FlavorsTransferableCanImport ( types ) ; IPCDataTransfer dataTransfer ; ContentChild :: GetSingleton ( ) -> SendGetClipboard ( types , aWhichClipboard , & dataTransfer ) ; return nsContentUtils :: IPCTransferableToTransferable ( dataTransfer , false , aTransferable ) ; }
HttpBaseChannel :: SetupReplacementChannel ( nsIURI * newURI , nsIChannel * newChannel , bool preserveMethod ) { LOG ( ( "HttpBaseChannel::SetupReplacementChannel " "[this=%p newChannel=%p preserveMethod=%d]" , this , newChannel , preserveMethod ) ) ; uint32_t newLoadFlags = mLoadFlags | LOAD_REPLACE ; bool usingSSL = false ; nsresult rv = mURI -> SchemeIs ( "https" , & usingSSL ) ; if ( NS_SUCCEEDED ( rv ) && usingSSL ) newLoadFlags &= ~ INHIBIT_PERSISTENT_CACHING ; newLoadFlags &= ~ nsICachingChannel :: LOAD_CHECK_OFFLINE_CACHE ; newChannel -> SetLoadGroup ( mLoadGroup ) ; newChannel -> SetNotificationCallbacks ( mCallbacks ) ; newChannel -> SetLoadFlags ( newLoadFlags ) ; if ( mPrivateBrowsingOverriden ) { nsCOMPtr < nsIPrivateBrowsingChannel > newPBChannel = do_QueryInterface ( newChannel ) ; if ( newPBChannel ) { newPBChannel -> SetPrivate ( mPrivateBrowsing ) ; } } nsCOMPtr < nsIHttpChannel > httpChannel = do_QueryInterface ( newChannel ) ; if ( ! httpChannel ) return NS_OK ; if ( preserveMethod ) { nsCOMPtr < nsIUploadChannel > uploadChannel = do_QueryInterface ( httpChannel ) ; nsCOMPtr < nsIUploadChannel2 > uploadChannel2 = do_QueryInterface ( httpChannel ) ; if ( mUploadStream && ( uploadChannel2 || uploadChannel ) ) { nsCOMPtr < nsISeekableStream > seekable = do_QueryInterface ( mUploadStream ) ; if ( seekable ) seekable -> Seek ( nsISeekableStream :: NS_SEEK_SET , 0 ) ; if ( uploadChannel2 ) { const char * ctype = mRequestHead . PeekHeader ( nsHttp :: Content_Type ) ; if ( ! ctype ) ctype = "" ; const char * clen = mRequestHead . PeekHeader ( nsHttp :: Content_Length ) ; int64_t len = clen ? nsCRT :: atoll ( clen ) : - 1 ; uploadChannel2 -> ExplicitSetUploadStream ( mUploadStream , nsDependentCString ( ctype ) , len , mRequestHead . Method ( ) , mUploadStreamHasHeaders ) ; } else { if ( mUploadStreamHasHeaders ) { uploadChannel -> SetUploadStream ( mUploadStream , EmptyCString ( ) , - 1 ) ; } else { const char * ctype = mRequestHead . PeekHeader ( nsHttp :: Content_Type ) ; const char * clen = mRequestHead . PeekHeader ( nsHttp :: Content_Length ) ; if ( ! ctype ) { ctype = "application/octet-stream" ; } if ( clen ) { uploadChannel -> SetUploadStream ( mUploadStream , nsDependentCString ( ctype ) , nsCRT :: atoll ( clen ) ) ; } } } } httpChannel -> SetRequestMethod ( mRequestHead . Method ( ) ) ; } if ( mReferrer ) httpChannel -> SetReferrer ( mReferrer ) ; httpChannel -> SetAllowPipelining ( mAllowPipelining ) ; httpChannel -> SetRedirectionLimit ( mRedirectionLimit - 1 ) ; { nsAutoCString oldAcceptValue ; nsresult hasHeader = mRequestHead . GetHeader ( nsHttp :: Accept , oldAcceptValue ) ; if ( NS_SUCCEEDED ( hasHeader ) ) { httpChannel -> SetRequestHeader ( NS_LITERAL_CSTRING ( "Accept" ) , oldAcceptValue , false ) ; } } nsCOMPtr < nsIHttpChannelInternal > httpInternal = do_QueryInterface ( newChannel ) ; if ( httpInternal ) { httpInternal -> SetForceAllowThirdPartyCookie ( mForceAllowThirdPartyCookie ) ; httpInternal -> SetAllowSpdy ( mAllowSpdy ) ; if ( newURI && ( mURI == mDocumentURI ) ) httpInternal -> SetDocumentURI ( newURI ) ; else httpInternal -> SetDocumentURI ( mDocumentURI ) ; if ( mRedirectedCachekeys ) { LOG ( ( "HttpBaseChannel::SetupReplacementChannel " "[this=%p] transferring chain of redirect cache-keys" , this ) ) ; httpInternal -> SetCacheKeysRedirectChain ( mRedirectedCachekeys . forget ( ) ) ; } for ( int32_t i = 0 ; i < mRedirects . Count ( ) ; ++ i ) { #ifdef PR_LOGGING nsCOMPtr < nsIURI > uri ; mRedirects [ i ] -> GetURI ( getter_AddRefs ( uri ) ) ; nsCString spec ; uri -> GetSpec ( spec ) ; LOG ( ( "HttpBaseChannel::SetupReplacementChannel adding redirect %s " "[this=%p]" , spec . get ( ) , this ) ) ; #endif httpInternal -> AddRedirect ( mRedirects [ i ] ) ; } nsCOMPtr < nsIPrincipal > principal = GetPrincipal ( false ) ; httpInternal -> AddRedirect ( principal ) ; } nsCOMPtr < nsIApplicationCacheChannel > appCacheChannel = do_QueryInterface ( newChannel ) ; if ( appCacheChannel ) { appCacheChannel -> SetApplicationCache ( mApplicationCache ) ; appCacheChannel -> SetInheritApplicationCache ( mInheritApplicationCache ) ; } nsCOMPtr < nsIWritablePropertyBag > bag ( do_QueryInterface ( newChannel ) ) ; if ( bag ) mPropertyHash . EnumerateRead ( CopyProperties , bag . get ( ) ) ; nsCOMPtr < nsITimedChannel > newTimedChannel ( do_QueryInterface ( newChannel ) ) ; nsCOMPtr < nsITimedChannel > oldTimedChannel ( do_QueryInterface ( static_cast < nsIHttpChannel * > ( this ) ) ) ; if ( oldTimedChannel && newTimedChannel ) { newTimedChannel -> SetTimingEnabled ( mTimingEnabled ) ; newTimedChannel -> SetRedirectCount ( mRedirectCount + 1 ) ; if ( mRedirectStartTimeStamp . IsNull ( ) ) { TimeStamp asyncOpen ; oldTimedChannel -> GetAsyncOpen ( & asyncOpen ) ; newTimedChannel -> SetRedirectStart ( asyncOpen ) ; } else { newTimedChannel -> SetRedirectStart ( mRedirectStartTimeStamp ) ; } TimeStamp prevResponseEnd ; oldTimedChannel -> GetResponseEnd ( & prevResponseEnd ) ; newTimedChannel -> SetRedirectEnd ( prevResponseEnd ) ; newTimedChannel -> SetAllRedirectsSameOrigin ( mAllRedirectsSameOrigin && SameOriginWithOriginalUri ( newURI ) ) ; } return NS_OK ; }
IGNITION_HANDLER ( CreateClosure , InterpreterAssembler ) { Node * shared = LoadConstantPoolEntryAtOperandIndex ( 0 ) ; Node * flags = BytecodeOperandFlag ( 2 ) ; Node * context = GetContext ( ) ; Node * slot = BytecodeOperandIdx ( 1 ) ; Node * feedback_vector = LoadFeedbackVector ( ) ; TNode < Object > feedback_cell = CAST ( LoadFeedbackVectorSlot ( feedback_vector , slot ) ) ; Label if_fast ( this ) , if_slow ( this , Label :: kDeferred ) ; Branch ( IsSetWord32 < CreateClosureFlags :: FastNewClosureBit > ( flags ) , & if_fast , & if_slow ) ; BIND ( & if_fast ) ; { Node * result = CallBuiltin ( Builtins :: kFastNewClosure , context , shared , feedback_cell ) ; SetAccumulator ( result ) ; Dispatch ( ) ; } BIND ( & if_slow ) ; { Label if_newspace ( this ) , if_oldspace ( this ) ; Branch ( IsSetWord32 < CreateClosureFlags :: PretenuredBit > ( flags ) , & if_oldspace , & if_newspace ) ; BIND ( & if_newspace ) ; { Node * result = CallRuntime ( Runtime :: kNewClosure , context , shared , feedback_cell ) ; SetAccumulator ( result ) ; Dispatch ( ) ; } BIND ( & if_oldspace ) ; { Node * result = CallRuntime ( Runtime :: kNewClosure_Tenured , context , shared , feedback_cell ) ; SetAccumulator ( result ) ; Dispatch ( ) ; } } }
Telephony :: GetCalls ( jsval * aCalls ) { JSObject * calls = mCallsArray ; if ( ! calls ) { nsresult rv ; nsIScriptContext * sc = GetContextForEventHandlers ( & rv ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( sc ) { rv = nsTArrayToJSArray ( sc -> GetNativeContext ( ) , mCalls , & calls ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! mRooted ) { NS_HOLD_JS_OBJECTS ( this , Telephony ) ; mRooted = true ; } mCallsArray = calls ; } else { NS_ENSURE_SUCCESS ( rv , rv ) ; } } aCalls -> setObject ( * calls ) ; return NS_OK ; }
acceptor_start ( OM_uint32 * minor_status , gss_ctx_id_t * context_handle , gss_const_cred_id_t acceptor_cred_handle , const gss_buffer_t input_token_buffer , const gss_channel_bindings_t input_chan_bindings , gss_name_t * src_name , gss_OID * mech_type , gss_buffer_t output_token , OM_uint32 * ret_flags , OM_uint32 * time_rec , gss_cred_id_t * delegated_cred_handle ) { OM_uint32 ret , junk ; NegotiationToken nt ; size_t nt_len ; NegTokenInit * ni ; gss_buffer_desc data ; gss_buffer_t mech_input_token = GSS_C_NO_BUFFER ; gss_buffer_desc mech_output_token ; gss_buffer_desc mech_buf ; gss_OID preferred_mech_type = GSS_C_NO_OID ; gssspnego_ctx ctx ; int get_mic = 0 ; int first_ok = 0 ; mech_output_token . value = NULL ; mech_output_token . length = 0 ; mech_buf . value = NULL ; if ( input_token_buffer -> length == 0 ) return send_supported_mechs ( minor_status , output_token ) ; ret = _gss_spnego_alloc_sec_context ( minor_status , context_handle ) ; if ( ret != GSS_S_COMPLETE ) return ret ; ctx = ( gssspnego_ctx ) * context_handle ; ret = gss_decapsulate_token ( input_token_buffer , GSS_SPNEGO_MECHANISM , & data ) ; if ( ret ) return ret ; ret = decode_NegotiationToken ( data . value , data . length , & nt , & nt_len ) ; gss_release_buffer ( minor_status , & data ) ; if ( ret ) { * minor_status = ret ; return GSS_S_DEFECTIVE_TOKEN ; } if ( nt . element != choice_NegotiationToken_negTokenInit ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } ni = & nt . u . negTokenInit ; if ( ni -> mechTypes . len < 1 ) { free_NegotiationToken ( & nt ) ; * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } HEIMDAL_MUTEX_lock ( & ctx -> ctx_id_mutex ) ; ret = copy_MechTypeList ( & ni -> mechTypes , & ctx -> initiator_mech_types ) ; if ( ret ) { HEIMDAL_MUTEX_unlock ( & ctx -> ctx_id_mutex ) ; free_NegotiationToken ( & nt ) ; * minor_status = ret ; return GSS_S_FAILURE ; } ret = select_mech ( minor_status , & ni -> mechTypes . val [ 0 ] , 0 , & preferred_mech_type ) ; if ( ret == 0 && ni -> mechToken != NULL ) { gss_buffer_desc ibuf ; ibuf . length = ni -> mechToken -> length ; ibuf . value = ni -> mechToken -> data ; mech_input_token = & ibuf ; if ( ctx -> mech_src_name != GSS_C_NO_NAME ) gss_release_name ( & junk , & ctx -> mech_src_name ) ; ret = gss_accept_sec_context ( minor_status , & ctx -> negotiated_ctx_id , acceptor_cred_handle , mech_input_token , input_chan_bindings , & ctx -> mech_src_name , & ctx -> negotiated_mech_type , & mech_output_token , & ctx -> mech_flags , & ctx -> mech_time_rec , delegated_cred_handle ) ; if ( ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED ) { ctx -> preferred_mech_type = preferred_mech_type ; if ( ret == GSS_S_COMPLETE ) ctx -> open = 1 ; ret = acceptor_complete ( minor_status , ctx , & get_mic , & mech_buf , mech_input_token , & mech_output_token , ni -> mechListMIC , output_token ) ; if ( ret != GSS_S_COMPLETE ) goto out ; first_ok = 1 ; } else { gss_mg_collect_error ( preferred_mech_type , ret , * minor_status ) ; } } if ( ! first_ok && ni -> mechToken != NULL ) { size_t j ; preferred_mech_type = GSS_C_NO_OID ; for ( j = 1 ; j < ni -> mechTypes . len ; ++ j ) { ret = select_mech ( minor_status , & ni -> mechTypes . val [ j ] , 1 , & preferred_mech_type ) ; if ( ret == 0 ) break ; } if ( preferred_mech_type == GSS_C_NO_OID ) { HEIMDAL_MUTEX_unlock ( & ctx -> ctx_id_mutex ) ; free_NegotiationToken ( & nt ) ; return ret ; } ctx -> preferred_mech_type = preferred_mech_type ; } ret = send_accept ( minor_status , ctx , & mech_output_token , 1 , get_mic ? & mech_buf : NULL , output_token ) ; if ( ret ) goto out ; out : if ( mech_output_token . value != NULL ) gss_release_buffer ( & junk , & mech_output_token ) ; if ( mech_buf . value != NULL ) { free ( mech_buf . value ) ; mech_buf . value = NULL ; } free_NegotiationToken ( & nt ) ; if ( ret == GSS_S_COMPLETE ) { if ( src_name != NULL && ctx -> mech_src_name != NULL ) { spnego_name name ; name = calloc ( 1 , sizeof ( * name ) ) ; if ( name ) { name -> mech = ctx -> mech_src_name ; ctx -> mech_src_name = NULL ; * src_name = ( gss_name_t ) name ; } } } if ( mech_type != NULL ) * mech_type = ctx -> negotiated_mech_type ; if ( ret_flags != NULL ) * ret_flags = ctx -> mech_flags ; if ( time_rec != NULL ) * time_rec = ctx -> mech_time_rec ; if ( ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED ) { HEIMDAL_MUTEX_unlock ( & ctx -> ctx_id_mutex ) ; return ret ; } _gss_spnego_internal_delete_sec_context ( & junk , context_handle , GSS_C_NO_BUFFER ) ; return ret ; }
static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } } DPRINTF ( "Data ready tag=0x%x len=%zd\n" , r -> req . tag , r -> iov . iov_len ) ; n = r -> iov . iov_len / 512 ; r -> sector += n ; r -> sector_count -= n ; scsi_req_data ( & r -> req , r -> iov . iov_len ) ; }
ReportErrorRunnable ( WorkerPrivate * aWorkerPrivate , const nsString & aMessage , const nsString & aFilename , const nsString & aLine , uint32_t aLineNumber , uint32_t aColumnNumber , uint32_t aFlags , uint32_t aErrorNumber , JSExnType aExnType ) : WorkerRunnable ( aWorkerPrivate , ParentThreadUnchangedBusyCount ) , mMessage ( aMessage ) , mFilename ( aFilename ) , mLine ( aLine ) , mLineNumber ( aLineNumber ) , mColumnNumber ( aColumnNumber ) , mFlags ( aFlags ) , mErrorNumber ( aErrorNumber ) , mExnType ( aExnType ) { }
buffer [ 2 ] = ( unsigned char ) ( value > > 16 ) ; buffer [ 3 ] = ( unsigned char ) ( value > > 24 ) ; return ( fwrite ( buffer , 1 , 4 , file ) ) ; } static Image * ReadGROUP4Image ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; size_t length ; ssize_t offset , strip_offset ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) ThrowImageException ( FileOpenError , "UnableToCreateTemporaryFile" ) ; length = fwrite ( "\111\111\052\000\010\000\000\000\016\000" , 1 , 10 , file ) ; length = fwrite ( "\376\000\003\000\001\000\000\000\000\000\000\000" , 1 , 12 , file ) ; length = fwrite ( "\000\001\004\000\001\000\000\000" , 1 , 8 , file ) ; length = WriteLSBLong ( file , image -> columns ) ; length = fwrite ( "\001\001\004\000\001\000\000\000" , 1 , 8 , file ) ; length = WriteLSBLong ( file , image -> rows ) ; length = fwrite ( "\002\001\003\000\001\000\000\000\001\000\000\000" , 1 , 12 , file ) ; length = fwrite ( "\003\001\003\000\001\000\000\000\004\000\000\000" , 1 , 12 , file ) ; length = fwrite ( "\006\001\003\000\001\000\000\000\000\000\000\000" , 1 , 12 , file ) ; length = fwrite ( "\021\001\003\000\001\000\000\000" , 1 , 8 , file ) ; strip_offset = 10 + ( 12 * 14 ) + 4 + 8 ; length = WriteLSBLong ( file , ( size_t ) strip_offset ) ; length = fwrite ( "\022\001\003\000\001\000\000\000" , 1 , 8 , file ) ; length = WriteLSBLong ( file , ( size_t ) image_info -> orientation ) ; length = fwrite ( "\025\001\003\000\001\000\000\000\001\000\000\000" , 1 , 12 , file ) ; length = fwrite ( "\026\001\004\000\001\000\000\000" , 1 , 8 , file ) ; length = WriteLSBLong ( file , image -> rows ) ; length = fwrite ( "\027\001\004\000\001\000\000\000\000\000\000\000" , 1 , 12 , file ) ; offset = ( ssize_t ) ftell ( file ) - 4 ; length = fwrite ( "\032\001\005\000\001\000\000\000" , 1 , 8 , file ) ; length = WriteLSBLong ( file , ( size_t ) ( strip_offset - 8 ) ) ; length = fwrite ( "\033\001\005\000\001\000\000\000" , 1 , 8 , file ) ; length = WriteLSBLong ( file , ( size_t ) ( strip_offset - 8 ) ) ; length = fwrite ( "\050\001\003\000\001\000\000\000\002\000\000\000" , 1 , 12 , file ) ; length = fwrite ( "\000\000\000\000" , 1 , 4 , file ) ; length = WriteLSBLong ( file , ( long ) image -> resolution . x ) ; length = WriteLSBLong ( file , 1 ) ; for ( length = 0 ; ( c = ReadBlobByte ( image ) ) != EOF ; length ++ ) ( void ) fputc ( c , file ) ; offset = ( ssize_t ) fseek ( file , ( ssize_t ) offset , SEEK_SET ) ; length = WriteLSBLong ( file , ( unsigned int ) length ) ; ( void ) fclose ( file ) ; ( void ) CloseBlob ( image ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( ( ImageInfo * ) NULL ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "%s" , filename ) ; image = ReadTIFFImage ( read_info , exception ) ; read_info = DestroyImageInfo ( read_info ) ; if ( image != ( Image * ) NULL ) { ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , MagickPathExtent ) ;
sp < media :: IAudioRecord > AudioFlinger :: createRecord ( const CreateRecordInput & input , CreateRecordOutput & output , status_t * status ) { sp < RecordThread :: RecordTrack > recordTrack ; sp < RecordHandle > recordHandle ; sp < Client > client ; status_t lStatus ; audio_session_t sessionId = input . sessionId ; audio_port_handle_t portId = AUDIO_PORT_HANDLE_NONE ; output . cblk . clear ( ) ; output . buffers . clear ( ) ; output . inputId = AUDIO_IO_HANDLE_NONE ; bool updatePid = ( input . clientInfo . clientPid == - 1 ) ; const uid_t callingUid = IPCThreadState :: self ( ) -> getCallingUid ( ) ; uid_t clientUid = input . clientInfo . clientUid ; if ( ! isAudioServerOrMediaServerUid ( callingUid ) ) { ALOGW_IF ( clientUid != callingUid , "%s uid %d tried to pass itself off as %d" , __FUNCTION__ , callingUid , clientUid ) ; clientUid = callingUid ; updatePid = true ; } pid_t clientPid = input . clientInfo . clientPid ; const pid_t callingPid = IPCThreadState :: self ( ) -> getCallingPid ( ) ; if ( updatePid ) { ALOGW_IF ( clientPid != - 1 && clientPid != callingPid , "%s uid %d pid %d tried to pass itself off as pid %d" , __func__ , callingUid , callingPid , clientPid ) ; clientPid = callingPid ; } if ( ! audio_is_valid_format ( input . config . format ) || ! audio_is_linear_pcm ( input . config . format ) ) { ALOGE ( "createRecord() invalid format %#x" , input . config . format ) ; lStatus = BAD_VALUE ; goto Exit ; } if ( ! audio_is_input_channel ( input . config . channel_mask ) ) { ALOGE ( "createRecord() invalid channel mask %#x" , input . config . channel_mask ) ; lStatus = BAD_VALUE ; goto Exit ; } if ( sessionId == AUDIO_SESSION_ALLOCATE ) { sessionId = ( audio_session_t ) newAudioUniqueId ( AUDIO_UNIQUE_ID_USE_SESSION ) ; } else if ( audio_unique_id_get_use ( sessionId ) != AUDIO_UNIQUE_ID_USE_SESSION ) { lStatus = BAD_VALUE ; goto Exit ; } output . sessionId = sessionId ; output . selectedDeviceId = input . selectedDeviceId ; output . flags = input . flags ; client = registerPid ( clientPid ) ; for ( ; ; ) { if ( output . inputId != AUDIO_IO_HANDLE_NONE ) { recordTrack . clear ( ) ; AudioSystem :: releaseInput ( portId ) ; output . inputId = AUDIO_IO_HANDLE_NONE ; output . selectedDeviceId = input . selectedDeviceId ; portId = AUDIO_PORT_HANDLE_NONE ; } lStatus = AudioSystem :: getInputForAttr ( & input . attr , & output . inputId , input . riid , sessionId , clientPid , clientUid , input . opPackageName , & input . config , output . flags , & output . selectedDeviceId , & portId ) ; if ( lStatus != NO_ERROR ) { ALOGE ( "createRecord() getInputForAttr return error %d" , lStatus ) ; goto Exit ; } { Mutex :: Autolock _l ( mLock ) ; RecordThread * thread = checkRecordThread_l ( output . inputId ) ; if ( thread == NULL ) { ALOGE ( "createRecord() checkRecordThread_l failed, input handle %d" , output . inputId ) ; lStatus = BAD_VALUE ; goto Exit ; } ALOGV ( "createRecord() lSessionId: %d input %d" , sessionId , output . inputId ) ; output . sampleRate = input . config . sample_rate ; output . frameCount = input . frameCount ; output . notificationFrameCount = input . notificationFrameCount ; recordTrack = thread -> createRecordTrack_l ( client , input . attr , & output . sampleRate , input . config . format , input . config . channel_mask , & output . frameCount , sessionId , & output . notificationFrameCount , callingPid , clientUid , & output . flags , input . clientInfo . clientTid , & lStatus , portId ) ; LOG_ALWAYS_FATAL_IF ( ( lStatus == NO_ERROR ) && ( recordTrack == 0 ) ) ; if ( lStatus == BAD_TYPE ) { continue ; } if ( lStatus != NO_ERROR ) { goto Exit ; } sp < EffectChain > chain = getOrphanEffectChain_l ( sessionId ) ; if ( chain != 0 ) { Mutex :: Autolock _l ( thread -> mLock ) ; thread -> addEffectChain_l ( chain ) ; } break ; } } output . cblk = recordTrack -> getCblk ( ) ; output . buffers = recordTrack -> getBuffers ( ) ; output . portId = portId ; recordHandle = new RecordHandle ( recordTrack ) ; Exit : if ( lStatus != NO_ERROR ) { { Mutex :: Autolock _cl ( mClientLock ) ; client . clear ( ) ; } recordTrack . clear ( ) ; if ( output . inputId != AUDIO_IO_HANDLE_NONE ) { AudioSystem :: releaseInput ( portId ) ; } } * status = lStatus ; return recordHandle ; }
nsComboboxControlFrame :: SetFocus ( bool aOn , bool aRepaint ) { nsWeakFrame weakFrame ( this ) ; if ( aOn ) { nsListControlFrame :: ComboboxFocusSet ( ) ; mFocused = this ; } else { mFocused = nsnull ; if ( mDroppedDown ) { mListControlFrame -> ComboboxFinish ( mDisplayedIndex ) ; if ( ! weakFrame . IsAlive ( ) ) { return ; } } mListControlFrame -> FireOnChange ( ) ; } if ( ! weakFrame . IsAlive ( ) ) { return ; } Invalidate ( nsRect ( 0 , 0 , mRect . width , mRect . height ) ) ; }
Handle < NumberDictionary > DictionaryAddNoUpdateNextEnumerationIndex ( Isolate * isolate , Handle < NumberDictionary > dictionary , uint32_t element , Handle < Object > value , PropertyDetails details , int * entry_out = nullptr ) { return NumberDictionary :: Add ( isolate , dictionary , element , value , details , entry_out ) ; }
Serializer < AllocatorT > :: ~ Serializer ( ) { if ( code_address_map_ != nullptr ) delete code_address_map_ ; #ifdef OBJECT_PRINT for ( int space = 0 ; space < LAST_SPACE ; ++ space ) { if ( instance_type_count_ [ space ] != nullptr ) { DeleteArray ( instance_type_count_ [ space ] ) ; DeleteArray ( instance_type_size_ [ space ] ) ; } } #endif // OBJECT_PRINT }
void ImplementationVisitor :: GenerateFunctionDeclaration ( std :: ostream & o , const std :: string & macro_prefix , const std :: string & name , const Signature & signature , const NameVector & parameter_names ) { if ( global_context_ . verbose ( ) ) { std :: cout < < "generating source for declaration " < < name < < "\n" ; } std :: string return_type_name ( signature . return_type -> GetGeneratedTypeName ( ) ) ; if ( const StructType * struct_type = StructType :: DynamicCast ( signature . return_type ) ) { o < < GetDSLAssemblerName ( struct_type -> module ( ) ) < < "::" ; } else if ( macro_prefix != "" && ( return_type_name . length ( ) > 5 ) && ( return_type_name . substr ( 0 , 5 ) == "TNode" ) ) { o < < "compiler::" ; } o < < return_type_name ; o < < " " < < macro_prefix < < name < < "(" ; DCHECK_EQ ( signature . types ( ) . size ( ) , parameter_names . size ( ) ) ; auto type_iterator = signature . types ( ) . begin ( ) ; bool first = true ; for ( const std :: string & name : parameter_names ) { if ( ! first ) { o < < ", " ; } const Value * parameter = declarations ( ) -> LookupValue ( name ) ; const Type * parameter_type = * type_iterator ; const std :: string & generated_type_name = parameter_type -> GetGeneratedTypeName ( ) ; o < < generated_type_name < < " " < < parameter -> value ( ) ; type_iterator ++ ; first = false ; } for ( const LabelDeclaration & label_info : signature . labels ) { Label * label = declarations ( ) -> LookupLabel ( label_info . name ) ; if ( ! first ) { o < < ", " ; } o < < "Label* " < < label -> generated ( ) ; for ( Variable * var : label -> GetParameters ( ) ) { std :: string generated_type_name ( "TVariable<" ) ; generated_type_name += var -> type ( ) -> GetGeneratedTNodeTypeName ( ) ; generated_type_name += ">*" ; o < < ", " ; o < < generated_type_name < < " " < < var -> value ( ) ; } } o < < ")" ; }
TIFFReadEncodedStrip ( TIFF * tif , uint32 strip , void * buf , tmsize_t size ) { static const char module [ ] = "TIFFReadEncodedStrip" ; TIFFDirectory * td = & tif -> tif_dir ; uint32 rowsperstrip ; uint32 stripsperplane ; uint32 stripinplane ; uint16 plane ; uint32 rows ; tmsize_t stripsize ; if ( ! TIFFCheckRead ( tif , 0 ) ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( strip >= td -> td_nstrips ) { TIFFErrorExt ( tif -> tif_clientdata , module , "%lu: Strip out of range, max %lu" , ( unsigned long ) strip , ( unsigned long ) td -> td_nstrips ) ; return ( ( tmsize_t ) ( - 1 ) ) ; } rowsperstrip = td -> td_rowsperstrip ; if ( rowsperstrip > td -> td_imagelength ) rowsperstrip = td -> td_imagelength ; stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ; stripinplane = ( strip % stripsperplane ) ; plane = ( uint16 ) ( strip / stripsperplane ) ; rows = td -> td_imagelength - stripinplane * rowsperstrip ; if ( rows > rowsperstrip ) rows = rowsperstrip ; stripsize = TIFFVStripSize ( tif , rows ) ; if ( stripsize == 0 ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( td -> td_compression == COMPRESSION_NONE && size != ( tmsize_t ) ( - 1 ) && size >= stripsize && ! isMapped ( tif ) && ( ( tif -> tif_flags & TIFF_NOREADRAW ) == 0 ) ) { if ( TIFFReadRawStrip1 ( tif , strip , buf , stripsize , module ) != stripsize ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( ! isFillOrder ( tif , td -> td_fillorder ) && ( tif -> tif_flags & TIFF_NOBITREV ) == 0 ) TIFFReverseBits ( buf , stripsize ) ; ( * tif -> tif_postdecode ) ( tif , buf , stripsize ) ; return ( stripsize ) ; } if ( ( size != ( tmsize_t ) ( - 1 ) ) && ( size < stripsize ) ) stripsize = size ; if ( ! TIFFFillStrip ( tif , strip ) ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( ( * tif -> tif_decodestrip ) ( tif , buf , stripsize , plane ) <= 0 ) return ( ( tmsize_t ) ( - 1 ) ) ; ( * tif -> tif_postdecode ) ( tif , buf , stripsize ) ; return ( stripsize ) ; }
vpx_codec_err_t vpx_codec_destroy ( vpx_codec_ctx_t * ctx ) { vpx_codec_err_t res ; if ( ! ctx ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { if ( ctx -> priv -> alg_priv ) ctx -> iface -> destroy ( ctx -> priv -> alg_priv ) ; ctx -> iface = NULL ; ctx -> name = NULL ; ctx -> priv = NULL ; res = VPX_CODEC_OK ; } return SAVE_STATUS ( ctx , res ) ; }
status_t AudioPolicyMixCollection :: getOutputForAttr ( audio_attributes_t attributes , uid_t uid , sp < SwAudioOutputDescriptor > & desc ) { ALOGV ( "getOutputForAttr() querying %zu mixes:" , size ( ) ) ; desc = 0 ; for ( size_t i = 0 ; i < size ( ) ; i ++ ) { sp < AudioPolicyMix > policyMix = valueAt ( i ) ; AudioMix * mix = policyMix -> getMix ( ) ; if ( mix -> mMixType == MIX_TYPE_PLAYERS ) { bool hasUsageMatchRules = false ; bool hasUsageExcludeRules = false ; bool usageMatchFound = false ; bool usageExclusionFound = false ; bool hasUidMatchRules = false ; bool hasUidExcludeRules = false ; bool uidMatchFound = false ; bool uidExclusionFound = false ; bool hasAddrMatch = false ; for ( size_t j = 0 ; j < mix -> mCriteria . size ( ) ; j ++ ) { ALOGV ( " getOutputForAttr: mix %zu: inspecting mix criteria %zu of %zu" , i , j , mix -> mCriteria . size ( ) ) ; if ( strncmp ( attributes . tags , "addr=" , strlen ( "addr=" ) ) == 0 && strncmp ( attributes . tags + strlen ( "addr=" ) , mix -> mDeviceAddress . string ( ) , AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - strlen ( "addr=" ) - 1 ) == 0 ) { hasAddrMatch = true ; break ; } switch ( mix -> mCriteria [ j ] . mRule ) { case RULE_MATCH_ATTRIBUTE_USAGE : ALOGV ( "\tmix has RULE_MATCH_ATTRIBUTE_USAGE for usage %d" , mix -> mCriteria [ j ] . mValue . mUsage ) ; hasUsageMatchRules = true ; if ( mix -> mCriteria [ j ] . mValue . mUsage == attributes . usage ) { usageMatchFound = true ; } break ; case RULE_EXCLUDE_ATTRIBUTE_USAGE : ALOGV ( "\tmix has RULE_EXCLUDE_ATTRIBUTE_USAGE for usage %d" , mix -> mCriteria [ j ] . mValue . mUsage ) ; hasUsageExcludeRules = true ; if ( mix -> mCriteria [ j ] . mValue . mUsage == attributes . usage ) { usageExclusionFound = true ; } break ; case RULE_MATCH_UID : ALOGV ( "\tmix has RULE_MATCH_UID for uid %d" , mix -> mCriteria [ j ] . mValue . mUid ) ; hasUidMatchRules = true ; if ( mix -> mCriteria [ j ] . mValue . mUid == uid ) { uidMatchFound = true ; } break ; case RULE_EXCLUDE_UID : ALOGV ( "\tmix has RULE_EXCLUDE_UID for uid %d" , mix -> mCriteria [ j ] . mValue . mUid ) ; hasUidExcludeRules = true ; if ( mix -> mCriteria [ j ] . mValue . mUid == uid ) { uidExclusionFound = true ; } break ; default : break ; } if ( hasUsageMatchRules && hasUsageExcludeRules ) { ALOGE ( "getOutputForAttr: invalid combination of RULE_MATCH_ATTRIBUTE_USAGE" " and RULE_EXCLUDE_ATTRIBUTE_USAGE in mix %zu" , i ) ; return BAD_VALUE ; } if ( hasUidMatchRules && hasUidExcludeRules ) { ALOGE ( "getOutputForAttr: invalid combination of RULE_MATCH_UID" " and RULE_EXCLUDE_UID in mix %zu" , i ) ; return BAD_VALUE ; } if ( ( hasUsageExcludeRules && usageExclusionFound ) || ( hasUidExcludeRules && uidExclusionFound ) ) { break ; } } if ( hasAddrMatch || ! ( ( hasUsageExcludeRules && usageExclusionFound ) || ( hasUsageMatchRules && ! usageMatchFound ) || ( hasUidExcludeRules && uidExclusionFound ) || ( hasUidMatchRules && ! uidMatchFound ) ) ) { ALOGV ( "\tgetOutputForAttr will use mix %zu" , i ) ; desc = policyMix -> getOutput ( ) ; } } else if ( mix -> mMixType == MIX_TYPE_RECORDERS ) { if ( attributes . usage == AUDIO_USAGE_VIRTUAL_SOURCE && strncmp ( attributes . tags , "addr=" , strlen ( "addr=" ) ) == 0 && strncmp ( attributes . tags + strlen ( "addr=" ) , mix -> mDeviceAddress . string ( ) , AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - strlen ( "addr=" ) - 1 ) == 0 ) { desc = policyMix -> getOutput ( ) ; } } if ( desc != 0 ) { desc -> mPolicyMix = mix ; return NO_ERROR ; } } return BAD_VALUE ; }
int vp9_fast_dia_search ( const MACROBLOCK * x , MV * ref_mv , int search_param , int sad_per_bit , int do_init_search , const vp9_variance_fn_ptr_t * vfp , int use_mvcost , const MV * center_mv , MV * best_mv ) { return vp9_bigdia_search ( x , ref_mv , MAX ( MAX_MVSEARCH_STEPS - 2 , search_param ) , sad_per_bit , do_init_search , vfp , use_mvcost , center_mv , best_mv ) ; }
static int af9005_identify_state ( struct usb_device * udev , struct dvb_usb_device_properties * props , struct dvb_usb_device_description * * desc , int * cold ) { int ret ; u8 reply , * buf ; buf = kmalloc ( FW_BULKOUT_SIZE + 2 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; ret = af9005_boot_packet ( udev , FW_CONFIG , & reply , buf , FW_BULKOUT_SIZE + 2 ) ; if ( ret ) goto err ; deb_info ( "result of FW_CONFIG in identify state %d\n" , reply ) ; if ( reply == 0x01 ) * cold = 1 ; else if ( reply == 0x02 ) * cold = 0 ; else return - EIO ; deb_info ( "Identify state cold = %d\n" , * cold ) ; err : kfree ( buf ) ; return ret ; }
Reduction JSCallReducer :: ReduceStringPrototypeToLowerCaseIntl ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSCall , node -> opcode ( ) ) ; CallParameters const & p = CallParametersOf ( node -> op ( ) ) ; if ( p . speculation_mode ( ) == SpeculationMode :: kDisallowSpeculation ) { return NoChange ( ) ; } Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; Node * receiver = effect = graph ( ) -> NewNode ( simplified ( ) -> CheckString ( p . feedback ( ) ) , NodeProperties :: GetValueInput ( node , 1 ) , effect , control ) ; NodeProperties :: ReplaceEffectInput ( node , effect ) ; RelaxEffectsAndControls ( node ) ; node -> ReplaceInput ( 0 , receiver ) ; node -> TrimInputCount ( 1 ) ; NodeProperties :: ChangeOp ( node , simplified ( ) -> StringToLowerCaseIntl ( ) ) ; NodeProperties :: SetType ( node , Type :: String ( ) ) ; return Changed ( node ) ; }
TF_BUILTIN ( SetPrototypeGetSize , CollectionsBuiltinsAssembler ) { Node * const receiver = Parameter ( Descriptor :: kReceiver ) ; Node * const context = Parameter ( Descriptor :: kContext ) ; ThrowIfNotInstanceType ( context , receiver , JS_SET_TYPE , "get Set.prototype.size" ) ; Node * const table = LoadObjectField ( receiver , JSSet :: kTableOffset ) ; Return ( LoadObjectField ( table , OrderedHashSet :: kNumberOfElementsOffset ) ) ; }
status_t MPEG4Extractor :: parseITunesMetaData ( off64_t offset , size_t size ) { if ( size < 4 || size == SIZE_MAX ) { return ERROR_MALFORMED ; } uint8_t * buffer = new ( std :: nothrow ) uint8_t [ size + 1 ] ; if ( buffer == NULL ) { return ERROR_MALFORMED ; } if ( mDataSource -> readAt ( offset , buffer , size ) != ( ssize_t ) size ) { delete [ ] buffer ; buffer = NULL ; return ERROR_IO ; } uint32_t flags = U32_AT ( buffer ) ; uint32_t metadataKey = 0 ; char chunk [ 5 ] ; MakeFourCCString ( mPath [ 4 ] , chunk ) ; ALOGV ( "meta: %s @ %lld" , chunk , ( long long ) offset ) ; switch ( ( int32_t ) mPath [ 4 ] ) { case FOURCC ( 0xa9 , 'a' , 'l' , 'b' ) : { metadataKey = kKeyAlbum ; break ; } case FOURCC ( 0xa9 , 'A' , 'R' , 'T' ) : { metadataKey = kKeyArtist ; break ; } case FOURCC ( 'a' , 'A' , 'R' , 'T' ) : { metadataKey = kKeyAlbumArtist ; break ; } case FOURCC ( 0xa9 , 'd' , 'a' , 'y' ) : { metadataKey = kKeyYear ; break ; } case FOURCC ( 0xa9 , 'n' , 'a' , 'm' ) : { metadataKey = kKeyTitle ; break ; } case FOURCC ( 0xa9 , 'w' , 'r' , 't' ) : { metadataKey = kKeyWriter ; break ; } case FOURCC ( 'c' , 'o' , 'v' , 'r' ) : { metadataKey = kKeyAlbumArt ; break ; } case FOURCC ( 'g' , 'n' , 'r' , 'e' ) : { metadataKey = kKeyGenre ; break ; } case FOURCC ( 0xa9 , 'g' , 'e' , 'n' ) : { metadataKey = kKeyGenre ; break ; } case FOURCC ( 'c' , 'p' , 'i' , 'l' ) : { if ( size == 9 && flags == 21 ) { char tmp [ 16 ] ; sprintf ( tmp , "%d" , ( int ) buffer [ size - 1 ] ) ; mFileMetaData -> setCString ( kKeyCompilation , tmp ) ; } break ; } case FOURCC ( 't' , 'r' , 'k' , 'n' ) : { if ( size == 16 && flags == 0 ) { char tmp [ 16 ] ; uint16_t * pTrack = ( uint16_t * ) & buffer [ 10 ] ; uint16_t * pTotalTracks = ( uint16_t * ) & buffer [ 12 ] ; sprintf ( tmp , "%d/%d" , ntohs ( * pTrack ) , ntohs ( * pTotalTracks ) ) ; mFileMetaData -> setCString ( kKeyCDTrackNumber , tmp ) ; } break ; } case FOURCC ( 'd' , 'i' , 's' , 'k' ) : { if ( ( size == 14 || size == 16 ) && flags == 0 ) { char tmp [ 16 ] ; uint16_t * pDisc = ( uint16_t * ) & buffer [ 10 ] ; uint16_t * pTotalDiscs = ( uint16_t * ) & buffer [ 12 ] ; sprintf ( tmp , "%d/%d" , ntohs ( * pDisc ) , ntohs ( * pTotalDiscs ) ) ; mFileMetaData -> setCString ( kKeyDiscNumber , tmp ) ; } break ; } case FOURCC ( '-' , '-' , '-' , '-' ) : { buffer [ size ] = '\0' ; switch ( mPath [ 5 ] ) { case FOURCC ( 'm' , 'e' , 'a' , 'n' ) : mLastCommentMean . setTo ( ( const char * ) buffer + 4 ) ; break ; case FOURCC ( 'n' , 'a' , 'm' , 'e' ) : mLastCommentName . setTo ( ( const char * ) buffer + 4 ) ; break ; case FOURCC ( 'd' , 'a' , 't' , 'a' ) : if ( size < 8 ) { delete [ ] buffer ; buffer = NULL ; ALOGE ( "b/24346430" ) ; return ERROR_MALFORMED ; } mLastCommentData . setTo ( ( const char * ) buffer + 8 ) ; break ; } if ( ( mLastCommentMean . length ( ) != 0 ) && ( mLastCommentName . length ( ) != 0 ) && ( mLastCommentData . length ( ) != 0 ) ) { if ( mLastCommentMean == "com.apple.iTunes" && mLastCommentName == "iTunSMPB" ) { int32_t delay , padding ; if ( sscanf ( mLastCommentData , " %*x %x %x %*x" , & delay , & padding ) == 2 ) { if ( mLastTrack == NULL ) return ERROR_MALFORMED ; mLastTrack -> meta -> setInt32 ( kKeyEncoderDelay , delay ) ; mLastTrack -> meta -> setInt32 ( kKeyEncoderPadding , padding ) ; } } mLastCommentMean . clear ( ) ; mLastCommentName . clear ( ) ; mLastCommentData . clear ( ) ; } break ; } default : break ; } if ( size >= 8 && metadataKey && ! mFileMetaData -> hasData ( metadataKey ) ) { if ( metadataKey == kKeyAlbumArt ) { mFileMetaData -> setData ( kKeyAlbumArt , MetaData :: TYPE_NONE , buffer + 8 , size - 8 ) ; } else if ( metadataKey == kKeyGenre ) { if ( flags == 0 ) { int genrecode = ( int ) buffer [ size - 1 ] ; genrecode -- ; if ( genrecode < 0 ) { genrecode = 255 ; } char genre [ 10 ] ; sprintf ( genre , "%d" , genrecode ) ; mFileMetaData -> setCString ( metadataKey , genre ) ; } else if ( flags == 1 ) { buffer [ size ] = '\0' ; mFileMetaData -> setCString ( metadataKey , ( const char * ) buffer + 8 ) ; } } else { buffer [ size ] = '\0' ; mFileMetaData -> setCString ( metadataKey , ( const char * ) buffer + 8 ) ; } } delete [ ] buffer ; buffer = NULL ; return OK ; }
EUCJPDistributionAnalysis :: EUCJPDistributionAnalysis ( ) { mCharToFreqOrder = JISCharToFreqOrder ; mTableSize = JIS_TABLE_SIZE ; mTypicalDistributionRatio = JIS_TYPICAL_DISTRIBUTION_RATIO ; }
static struct child_process * git_connect_git ( int fd [ 2 ] , char * hostandport , const char * path , const char * prog , enum protocol_version version , int flags ) { struct child_process * conn ; struct strbuf request = STRBUF_INIT ; char * target_host = getenv ( "GIT_OVERRIDE_VIRTUAL_HOST" ) ; if ( target_host ) target_host = xstrdup ( target_host ) ; else target_host = xstrdup ( hostandport ) ; transport_check_allowed ( "git" ) ; if ( git_use_proxy ( hostandport ) ) conn = git_proxy_connect ( fd , hostandport ) ; else conn = git_tcp_connect ( fd , hostandport , flags ) ; strbuf_addf ( & request , "%s %s%chost=%s%c" , prog , path , 0 , target_host , 0 ) ; if ( version > 0 ) { strbuf_addch ( & request , '\0' ) ; strbuf_addf ( & request , "version=%d%c" , version , '\0' ) ; } packet_write ( fd [ 1 ] , request . buf , request . len ) ; free ( target_host ) ; strbuf_release ( & request ) ; return conn ; }
png_crc_error ( png_structrp png_ptr ) { png_byte crc_bytes [ 4 ] ; png_uint_32 crc ; int need_crc = 1 ; if ( PNG_CHUNK_ANCILLARY ( png_ptr -> chunk_name ) ) { if ( ( png_ptr -> flags & PNG_FLAG_CRC_ANCILLARY_MASK ) == ( PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN ) ) need_crc = 0 ; } else { if ( png_ptr -> flags & PNG_FLAG_CRC_CRITICAL_IGNORE ) need_crc = 0 ; } #ifdef PNG_IO_STATE_SUPPORTED png_ptr -> io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC ; #endif png_read_data ( png_ptr , crc_bytes , 4 ) ; if ( need_crc ) { crc = png_get_uint_32 ( crc_bytes ) ; return ( ( int ) ( crc != png_ptr -> crc ) ) ; } else return ( 0 ) ; }
png_set_sig_bytes ( png_structrp png_ptr , int num_bytes ) { png_debug ( 1 , "in png_set_sig_bytes" ) ; if ( png_ptr == NULL ) return ; if ( num_bytes > 8 ) png_error ( png_ptr , "Too many bytes for PNG signature" ) ; png_ptr -> sig_bytes = ( png_byte ) ( num_bytes < 0 ? 0 : num_bytes ) ; }
% MagickBooleanType DrawDashPolygon ( const DrawInfo * draw_info , % const PrimitiveInfo * primitive_info , Image * image , % ExceptionInfo * exception ) % % A description of each parameter follows : % % o draw_info : the draw info . % % o primitive_info : Specifies a pointer to a PrimitiveInfo structure . % % o image : the image . % % o exception : return any errors or warnings in this structure . % * / static MagickBooleanType DrawDashPolygon ( const DrawInfo * draw_info , const PrimitiveInfo * primitive_info , Image * image , ExceptionInfo * exception ) { DrawInfo * clone_info ; double length , maximum_length , offset , scale , total_length ; MagickStatusType status ; PrimitiveInfo * dash_polygon ; register ssize_t i ; register double dx , dy ; size_t number_vertices ; ssize_t j , n ; assert ( draw_info != ( const DrawInfo * ) NULL ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( DrawEvent , GetMagickModule ( ) , "    begin draw-dash" ) ; for ( i = 0 ; primitive_info [ i ] . primitive != UndefinedPrimitive ; i ++ ) ; number_vertices = ( size_t ) i ; dash_polygon = ( PrimitiveInfo * ) AcquireQuantumMemory ( ( size_t ) ( 2UL * number_vertices + 1UL ) , sizeof ( * dash_polygon ) ) ; if ( dash_polygon == ( PrimitiveInfo * ) NULL ) return ( MagickFalse ) ; clone_info = CloneDrawInfo ( ( ImageInfo * ) NULL , draw_info ) ; clone_info -> miterlimit = 0 ; dash_polygon [ 0 ] = primitive_info [ 0 ] ; scale = ExpandAffine ( & draw_info -> affine ) ; length = scale * ( draw_info -> dash_pattern [ 0 ] - 0.5 ) ; offset = draw_info -> dash_offset != 0.0 ? scale * draw_info -> dash_offset : 0.0 ; j = 1 ; for ( n = 0 ; offset > 0.0 ; j = 0 ) { if ( draw_info -> dash_pattern [ n ] <= 0.0 ) break ; length = scale * ( draw_info -> dash_pattern [ n ] + ( n == 0 ? - 0.5 : 0.5 ) ) ; if ( offset > length ) { offset -= length ; n ++ ; length = scale * ( draw_info -> dash_pattern [ n ] + 0.5 ) ; continue ; } if ( offset < length ) { length -= offset ; offset = 0.0 ; break ; } offset = 0.0 ; n ++ ; } status = MagickTrue ; maximum_length = 0.0 ; total_length = 0.0 ; for ( i = 1 ; ( i < number_vertices ) && ( length >= 0.0 ) ; i ++ ) { dx = primitive_info [ i ] . point . x - primitive_info [ i - 1 ] . point . x ; dy = primitive_info [ i ] . point . y - primitive_info [ i - 1 ] . point . y ; maximum_length = hypot ( ( double ) dx , dy ) ; if ( length == 0.0 ) { n ++ ; if ( draw_info -> dash_pattern [ n ] == 0.0 ) n = 0 ; length = scale * ( draw_info -> dash_pattern [ n ] + ( n == 0 ? - 0.5 : 0.5 ) ) ; } for ( total_length = 0.0 ; ( length >= 0.0 ) && ( maximum_length >= ( total_length + length ) ) ; ) { total_length += length ; if ( ( n & 0x01 ) != 0 ) { dash_polygon [ 0 ] = primitive_info [ 0 ] ; dash_polygon [ 0 ] . point . x = ( double ) ( primitive_info [ i - 1 ] . point . x + dx * total_length / maximum_length ) ; dash_polygon [ 0 ] . point . y = ( double ) ( primitive_info [ i - 1 ] . point . y + dy * total_length / maximum_length ) ; j = 1 ; } else { if ( ( j + 1 ) > ( ssize_t ) ( 2 * number_vertices ) ) break ; dash_polygon [ j ] = primitive_info [ i - 1 ] ; dash_polygon [ j ] . point . x = ( double ) ( primitive_info [ i - 1 ] . point . x + dx * total_length / maximum_length ) ; dash_polygon [ j ] . point . y = ( double ) ( primitive_info [ i - 1 ] . point . y + dy * total_length / maximum_length ) ; dash_polygon [ j ] . coordinates = 1 ; j ++ ; dash_polygon [ 0 ] . coordinates = ( size_t ) j ; dash_polygon [ j ] . primitive = UndefinedPrimitive ; status &= DrawStrokePolygon ( image , clone_info , dash_polygon , exception ) ; } n ++ ; if ( draw_info -> dash_pattern [ n ] == 0.0 ) n = 0 ; length = scale * ( draw_info -> dash_pattern [ n ] + ( n == 0 ? - 0.5 : 0.5 ) ) ; } length -= ( maximum_length - total_length ) ; if ( ( n & 0x01 ) != 0 ) continue ; dash_polygon [ j ] = primitive_info [ i ] ; dash_polygon [ j ] . coordinates = 1 ; j ++ ; } if ( ( total_length <= maximum_length ) && ( ( n & 0x01 ) == 0 ) && ( j > 1 ) ) {
nsPluginInstanceOwner :: Destroy ( ) { SetFrame ( nullptr ) ; #ifdef XP_MACOSX RemoveFromCARefreshTimer ( ) ; if ( mColorProfile ) :: CGColorSpaceRelease ( mColorProfile ) ; #endif if ( mCXMenuListener ) { mCXMenuListener -> Destroy ( mContent ) ; mCXMenuListener = nullptr ; } mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "focus" ) , this , false ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "blur" ) , this , false ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "mouseup" ) , this , false ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "mousedown" ) , this , false ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "mousemove" ) , this , false ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "click" ) , this , false ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "dblclick" ) , this , false ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "mouseover" ) , this , false ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "mouseout" ) , this , false ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "keypress" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "keydown" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "keyup" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "drop" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "dragdrop" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "drag" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "dragenter" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "dragover" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "dragleave" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "dragexit" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "dragstart" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "draggesture" ) , this , true ) ; mContent -> RemoveEventListener ( NS_LITERAL_STRING ( "dragend" ) , this , true ) ; #if MOZ_WIDGET_ANDROID RemovePluginView ( ) ; #endif if ( mWidget ) { if ( mPluginWindow ) { mPluginWindow -> SetPluginWidget ( nullptr ) ; } nsCOMPtr < nsIPluginWidget > pluginWidget = do_QueryInterface ( mWidget ) ; if ( pluginWidget ) { pluginWidget -> SetPluginInstanceOwner ( nullptr ) ; } mWidget -> Destroy ( ) ; } return NS_OK ; }
static BOOL update_recv_secondary_order ( rdpUpdate * update , wStream * s , BYTE flags ) { BOOL rc = FALSE ; size_t start , end , diff ; BYTE orderType ; UINT16 extraFlags ; UINT16 orderLength ; rdpContext * context = update -> context ; rdpSettings * settings = context -> settings ; rdpSecondaryUpdate * secondary = update -> secondary ; const char * name ; if ( Stream_GetRemainingLength ( s ) < 5 ) { WLog_Print ( update -> log , WLOG_ERROR , "Stream_GetRemainingLength(s) < 5" ) ; return FALSE ; } Stream_Read_UINT16 ( s , orderLength ) ; Stream_Read_UINT16 ( s , extraFlags ) ; Stream_Read_UINT8 ( s , orderType ) ; if ( Stream_GetRemainingLength ( s ) < orderLength + 7U ) { WLog_Print ( update -> log , WLOG_ERROR , "Stream_GetRemainingLength(s) %" PRIuz " < %" PRIu16 , Stream_GetRemainingLength ( s ) , orderLength + 7 ) ; return FALSE ; } start = Stream_GetPosition ( s ) ; name = secondary_order_string ( orderType ) ; WLog_Print ( update -> log , WLOG_DEBUG , "Secondary Drawing Order %s" , name ) ; if ( ! check_secondary_order_supported ( update -> log , settings , orderType , name ) ) return FALSE ; switch ( orderType ) { case ORDER_TYPE_BITMAP_UNCOMPRESSED : case ORDER_TYPE_CACHE_BITMAP_COMPRESSED : { const BOOL compressed = ( orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED ) ; CACHE_BITMAP_ORDER * order = update_read_cache_bitmap_order ( update , s , compressed , extraFlags ) ; if ( order ) { rc = IFCALLRESULT ( FALSE , secondary -> CacheBitmap , context , order ) ; free_cache_bitmap_order ( context , order ) ; } } break ; case ORDER_TYPE_BITMAP_UNCOMPRESSED_V2 : case ORDER_TYPE_BITMAP_COMPRESSED_V2 : { const BOOL compressed = ( orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2 ) ; CACHE_BITMAP_V2_ORDER * order = update_read_cache_bitmap_v2_order ( update , s , compressed , extraFlags ) ; if ( order ) { rc = IFCALLRESULT ( FALSE , secondary -> CacheBitmapV2 , context , order ) ; free_cache_bitmap_v2_order ( context , order ) ; } } break ; case ORDER_TYPE_BITMAP_COMPRESSED_V3 : { CACHE_BITMAP_V3_ORDER * order = update_read_cache_bitmap_v3_order ( update , s , extraFlags ) ; if ( order ) { rc = IFCALLRESULT ( FALSE , secondary -> CacheBitmapV3 , context , order ) ; free_cache_bitmap_v3_order ( context , order ) ; } } break ; case ORDER_TYPE_CACHE_COLOR_TABLE : { CACHE_COLOR_TABLE_ORDER * order = update_read_cache_color_table_order ( update , s , extraFlags ) ; if ( order ) { rc = IFCALLRESULT ( FALSE , secondary -> CacheColorTable , context , order ) ; free_cache_color_table_order ( context , order ) ; } } break ; case ORDER_TYPE_CACHE_GLYPH : { switch ( settings -> GlyphSupportLevel ) { case GLYPH_SUPPORT_PARTIAL : case GLYPH_SUPPORT_FULL : { CACHE_GLYPH_ORDER * order = update_read_cache_glyph_order ( update , s , extraFlags ) ; if ( order ) { rc = IFCALLRESULT ( FALSE , secondary -> CacheGlyph , context , order ) ; free_cache_glyph_order ( context , order ) ; } } break ; case GLYPH_SUPPORT_ENCODE : { CACHE_GLYPH_V2_ORDER * order = update_read_cache_glyph_v2_order ( update , s , extraFlags ) ; if ( order ) { rc = IFCALLRESULT ( FALSE , secondary -> CacheGlyphV2 , context , order ) ; free_cache_glyph_v2_order ( context , order ) ; } } break ; case GLYPH_SUPPORT_NONE : default : break ; } } break ; case ORDER_TYPE_CACHE_BRUSH : { CACHE_BRUSH_ORDER * order = update_read_cache_brush_order ( update , s , extraFlags ) ; if ( order ) { rc = IFCALLRESULT ( FALSE , secondary -> CacheBrush , context , order ) ; free_cache_brush_order ( context , order ) ; } } break ; default : WLog_Print ( update -> log , WLOG_WARN , "SECONDARY ORDER %s not supported" , name ) ; break ; } if ( ! rc ) { WLog_Print ( update -> log , WLOG_ERROR , "SECONDARY ORDER %s failed" , name ) ; } start += orderLength + 7 ; end = Stream_GetPosition ( s ) ; if ( start > end ) { WLog_Print ( update -> log , WLOG_WARN , "SECONDARY_ORDER %s: read %" PRIuz "bytes too much" , name , end - start ) ; return FALSE ; } diff = start - end ; if ( diff > 0 ) { WLog_Print ( update -> log , WLOG_DEBUG , "SECONDARY_ORDER %s: read %" PRIuz "bytes short, skipping" , name , diff ) ; Stream_Seek ( s , diff ) ; } return rc ; }
status_t OMXNodeInstance :: enableNativeBuffers_l ( OMX_U32 portIndex , OMX_BOOL graphic , OMX_BOOL enable ) { if ( portIndex >= NELEM ( mSecureBufferType ) ) { ALOGE ( "b/31385713, portIndex(%u)" , portIndex ) ; android_errorWriteLog ( 0x534e4554 , "31385713" ) ; return BAD_VALUE ; } CLOG_CONFIG ( enableNativeBuffers , "%s:%u%s, %d" , portString ( portIndex ) , portIndex , graphic ? ", graphic" : "" , enable ) ; OMX_STRING name = const_cast < OMX_STRING > ( graphic ? "OMX.google.android.index.enableAndroidNativeBuffers" : "OMX.google.android.index.allocateNativeHandle" ) ; OMX_INDEXTYPE index ; OMX_ERRORTYPE err = OMX_GetExtensionIndex ( mHandle , name , & index ) ; if ( err == OMX_ErrorNone ) { EnableAndroidNativeBuffersParams params ; InitOMXParams ( & params ) ; params . nPortIndex = portIndex ; params . enable = enable ; err = OMX_SetParameter ( mHandle , index , & params ) ; CLOG_IF_ERROR ( setParameter , err , "%s(%#x): %s:%u en=%d" , name , index , portString ( portIndex ) , portIndex , enable ) ; if ( ! graphic ) { if ( err == OMX_ErrorNone ) { mSecureBufferType [ portIndex ] = enable ? kSecureBufferTypeNativeHandle : kSecureBufferTypeOpaque ; } else if ( mSecureBufferType [ portIndex ] == kSecureBufferTypeUnknown ) { mSecureBufferType [ portIndex ] = kSecureBufferTypeOpaque ; } } } else { CLOG_ERROR_IF ( enable , getExtensionIndex , err , "%s" , name ) ; if ( ! graphic ) { if ( property_get_bool ( "media.mediadrmservice.enable" , false ) ) { CLOG_CONFIG ( enableNativeBuffers , "system property override: using native-handles" ) ; mSecureBufferType [ portIndex ] = kSecureBufferTypeNativeHandle ; } else if ( mSecureBufferType [ portIndex ] == kSecureBufferTypeUnknown ) { mSecureBufferType [ portIndex ] = kSecureBufferTypeOpaque ; } err = OMX_ErrorNone ; } } return StatusFromOMXError ( err ) ; }
TF_BUILTIN ( GeneratorPrototypeThrow , GeneratorBuiltinsAssembler ) { const int kExceptionArg = 0 ; Node * argc = ChangeInt32ToIntPtr ( Parameter ( Descriptor :: kJSActualArgumentsCount ) ) ; CodeStubArguments args ( this , argc ) ; Node * receiver = args . GetReceiver ( ) ; Node * exception = args . GetOptionalArgumentValue ( kExceptionArg ) ; Node * context = Parameter ( Descriptor :: kContext ) ; GeneratorPrototypeResume ( & args , receiver , exception , context , JSGeneratorObject :: kThrow , "[Generator].prototype.throw" ) ; }
bool Heap :: PerformGarbageCollection ( GarbageCollector collector , const v8 :: GCCallbackFlags gc_callback_flags ) { int freed_global_handles = 0 ; if ( ! IsYoungGenerationCollector ( collector ) ) { PROFILE ( isolate_ , CodeMovingGCEvent ( ) ) ; } #ifdef VERIFY_HEAP if ( FLAG_verify_heap ) { VerifyStringTable ( this -> isolate ( ) ) ; } #endif GCType gc_type = collector == MARK_COMPACTOR ? kGCTypeMarkSweepCompact : kGCTypeScavenge ; { GCCallbacksScope scope ( this ) ; if ( scope . CheckReenter ( ) ) { AllowHeapAllocation allow_allocation ; TRACE_GC ( tracer ( ) , GCTracer :: Scope :: HEAP_EXTERNAL_PROLOGUE ) ; VMState < EXTERNAL > state ( isolate_ ) ; HandleScope handle_scope ( isolate_ ) ; CallGCPrologueCallbacks ( gc_type , kNoGCCallbackFlags ) ; } } EnsureFromSpaceIsCommitted ( ) ; size_t start_new_space_size = Heap :: new_space ( ) -> Size ( ) ; { Heap :: SkipStoreBufferScope skip_store_buffer_scope ( store_buffer_ ) ; switch ( collector ) { case MARK_COMPACTOR : UpdateOldGenerationAllocationCounter ( ) ; MarkCompact ( ) ; old_generation_size_configured_ = true ; old_generation_allocation_counter_at_last_gc_ += static_cast < size_t > ( promoted_objects_size_ ) ; old_generation_size_at_last_gc_ = OldGenerationSizeOfObjects ( ) ; break ; case MINOR_MARK_COMPACTOR : MinorMarkCompact ( ) ; break ; case SCAVENGER : if ( ( fast_promotion_mode_ && CanExpandOldGeneration ( new_space ( ) -> Size ( ) ) ) ) { tracer ( ) -> NotifyYoungGenerationHandling ( YoungGenerationHandling :: kFastPromotionDuringScavenge ) ; EvacuateYoungGeneration ( ) ; } else { tracer ( ) -> NotifyYoungGenerationHandling ( YoungGenerationHandling :: kRegularScavenge ) ; Scavenge ( ) ; } break ; } ProcessPretenuringFeedback ( ) ; } UpdateSurvivalStatistics ( static_cast < int > ( start_new_space_size ) ) ; ConfigureInitialOldGenerationSize ( ) ; if ( collector != MARK_COMPACTOR ) { incremental_marking ( ) -> UpdateMarkedBytesAfterScavenge ( start_new_space_size - SurvivedNewSpaceObjectSize ( ) ) ; } if ( ! fast_promotion_mode_ || collector == MARK_COMPACTOR ) { ComputeFastPromotionMode ( ) ; } isolate_ -> counters ( ) -> objs_since_last_young ( ) -> Set ( 0 ) ; gc_post_processing_depth_ ++ ; { AllowHeapAllocation allow_allocation ; TRACE_GC ( tracer ( ) , GCTracer :: Scope :: HEAP_EXTERNAL_WEAK_GLOBAL_HANDLES ) ; freed_global_handles = isolate_ -> global_handles ( ) -> PostGarbageCollectionProcessing ( collector , gc_callback_flags ) ; } gc_post_processing_depth_ -- ; isolate_ -> eternal_handles ( ) -> PostGarbageCollectionProcessing ( ) ; Relocatable :: PostGarbageCollectionProcessing ( isolate_ ) ; double gc_speed = tracer ( ) -> CombinedMarkCompactSpeedInBytesPerMillisecond ( ) ; double mutator_speed = tracer ( ) -> CurrentOldGenerationAllocationThroughputInBytesPerMillisecond ( ) ; size_t old_gen_size = OldGenerationSizeOfObjects ( ) ; if ( collector == MARK_COMPACTOR ) { external_memory_at_last_mark_compact_ = external_memory_ ; external_memory_limit_ = external_memory_ + kExternalAllocationSoftLimit ; size_t new_limit = heap_controller ( ) -> CalculateAllocationLimit ( old_gen_size , max_old_generation_size_ , gc_speed , mutator_speed , new_space ( ) -> Capacity ( ) , CurrentHeapGrowingMode ( ) ) ; old_generation_allocation_limit_ = new_limit ; CheckIneffectiveMarkCompact ( old_gen_size , tracer ( ) -> AverageMarkCompactMutatorUtilization ( ) ) ; } else if ( HasLowYoungGenerationAllocationRate ( ) && old_generation_size_configured_ ) { size_t new_limit = heap_controller ( ) -> CalculateAllocationLimit ( old_gen_size , max_old_generation_size_ , gc_speed , mutator_speed , new_space ( ) -> Capacity ( ) , CurrentHeapGrowingMode ( ) ) ; if ( new_limit < old_generation_allocation_limit_ ) { old_generation_allocation_limit_ = new_limit ; } } { GCCallbacksScope scope ( this ) ; if ( scope . CheckReenter ( ) ) { AllowHeapAllocation allow_allocation ; TRACE_GC ( tracer ( ) , GCTracer :: Scope :: HEAP_EXTERNAL_EPILOGUE ) ; VMState < EXTERNAL > state ( isolate_ ) ; HandleScope handle_scope ( isolate_ ) ; CallGCEpilogueCallbacks ( gc_type , gc_callback_flags ) ; } } #ifdef VERIFY_HEAP if ( FLAG_verify_heap ) { VerifyStringTable ( this -> isolate ( ) ) ; } #endif return freed_global_handles > 0 ; }
SecurityWrapper < Base > :: nativeCall ( JSContext * cx , IsAcceptableThis test , NativeImpl impl , CallArgs args ) { return Base :: nativeCall ( cx , test , impl , args ) ; }
Reduction JSCallReducer :: ReduceRegExpPrototypeTest ( Node * node ) { if ( FLAG_force_slow_path ) return NoChange ( ) ; if ( node -> op ( ) -> ValueInputCount ( ) < 3 ) return NoChange ( ) ; CallParameters const & p = CallParametersOf ( node -> op ( ) ) ; if ( p . speculation_mode ( ) == SpeculationMode :: kDisallowSpeculation ) { return NoChange ( ) ; } Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; Node * regexp = NodeProperties :: GetValueInput ( node , 1 ) ; ZoneHandleSet < Map > regexp_maps ; NodeProperties :: InferReceiverMapsResult result = NodeProperties :: InferReceiverMaps ( isolate ( ) , regexp , effect , & regexp_maps ) ; bool need_map_check = false ; switch ( result ) { case NodeProperties :: kNoReceiverMaps : return NoChange ( ) ; case NodeProperties :: kUnreliableReceiverMaps : need_map_check = true ; break ; case NodeProperties :: kReliableReceiverMaps : break ; } for ( auto map : regexp_maps ) { if ( map -> instance_type ( ) != JS_REGEXP_TYPE ) return NoChange ( ) ; } PropertyAccessInfo ai_exec ; AccessInfoFactory access_info_factory ( js_heap_broker ( ) , dependencies ( ) , native_context ( ) , graph ( ) -> zone ( ) ) ; if ( ! access_info_factory . ComputePropertyAccessInfo ( MapHandles ( regexp_maps . begin ( ) , regexp_maps . end ( ) ) , factory ( ) -> exec_string ( ) , AccessMode :: kLoad , & ai_exec ) ) { return NoChange ( ) ; } if ( ! ai_exec . IsDataConstant ( ) ) return NoChange ( ) ; Handle < Object > exec_on_proto = ai_exec . constant ( ) ; if ( * exec_on_proto != * isolate ( ) -> regexp_exec_function ( ) ) return NoChange ( ) ; PropertyAccessBuilder access_builder ( jsgraph ( ) , js_heap_broker ( ) , dependencies ( ) ) ; Handle < JSObject > holder ; if ( ai_exec . holder ( ) . ToHandle ( & holder ) ) { dependencies ( ) -> DependOnStablePrototypeChains ( js_heap_broker ( ) , native_context ( ) , ai_exec . receiver_maps ( ) , holder ) ; } if ( need_map_check ) { effect = graph ( ) -> NewNode ( simplified ( ) -> CheckMaps ( CheckMapsFlag :: kNone , regexp_maps , p . feedback ( ) ) , regexp , effect , control ) ; } Node * context = NodeProperties :: GetContextInput ( node ) ; Node * frame_state = NodeProperties :: GetFrameStateInput ( node ) ; Node * search = NodeProperties :: GetValueInput ( node , 2 ) ; Node * search_string = effect = graph ( ) -> NewNode ( simplified ( ) -> CheckString ( p . feedback ( ) ) , search , effect , control ) ; Node * lastIndex = effect = graph ( ) -> NewNode ( simplified ( ) -> LoadField ( AccessBuilder :: ForJSRegExpLastIndex ( ) ) , regexp , effect , control ) ; Node * lastIndexSmi = effect = graph ( ) -> NewNode ( simplified ( ) -> CheckSmi ( p . feedback ( ) ) , lastIndex , effect , control ) ; Node * is_positive = graph ( ) -> NewNode ( simplified ( ) -> NumberLessThanOrEqual ( ) , jsgraph ( ) -> ZeroConstant ( ) , lastIndexSmi ) ; effect = graph ( ) -> NewNode ( simplified ( ) -> CheckIf ( DeoptimizeReason :: kNotASmi , p . feedback ( ) ) , is_positive , effect , control ) ; node -> ReplaceInput ( 0 , regexp ) ; node -> ReplaceInput ( 1 , search_string ) ; node -> ReplaceInput ( 2 , context ) ; node -> ReplaceInput ( 3 , frame_state ) ; node -> ReplaceInput ( 4 , effect ) ; node -> ReplaceInput ( 5 , control ) ; node -> TrimInputCount ( 6 ) ; NodeProperties :: ChangeOp ( node , javascript ( ) -> RegExpTest ( ) ) ; return Changed ( node ) ; }
png_inflate_claim ( png_structrp png_ptr , png_uint_32 owner ) { if ( png_ptr -> zowner != 0 ) { char msg [ 64 ] ; PNG_STRING_FROM_CHUNK ( msg , png_ptr -> zowner ) ; ( void ) png_safecat ( msg , ( sizeof msg ) , 4 , " using zstream" ) ; #     if PNG_LIBPNG_BUILD_BASE_TYPE >= PNG_LIBPNG_BUILD_RC png_chunk_warning ( png_ptr , msg ) ; png_ptr -> zowner = 0 ; #     else png_chunk_error ( png_ptr , msg ) ; #     endif } { int ret ; #     if PNG_ZLIB_VERNUM >= 0x1240 #        if defined(PNG_SET_OPTION_SUPPORTED) && \             defined(PNG_MAXIMUM_INFLATE_WINDOW) int window_bits ; if ( ( ( png_ptr -> options > > PNG_MAXIMUM_INFLATE_WINDOW ) & 3 ) == PNG_OPTION_ON ) window_bits = 15 ; else window_bits = 0 ; #        else #           define window_bits 0 #        endif #     endif png_ptr -> zstream . next_in = NULL ; png_ptr -> zstream . avail_in = 0 ; png_ptr -> zstream . next_out = NULL ; png_ptr -> zstream . avail_out = 0 ; if ( png_ptr -> flags & PNG_FLAG_ZSTREAM_INITIALIZED ) { #        if PNG_ZLIB_VERNUM < 0x1240 ret = inflateReset ( & png_ptr -> zstream ) ; #        else ret = inflateReset2 ( & png_ptr -> zstream , window_bits ) ; #        endif } else { #        if PNG_ZLIB_VERNUM < 0x1240 ret = inflateInit ( & png_ptr -> zstream ) ; #        else ret = inflateInit2 ( & png_ptr -> zstream , window_bits ) ; #        endif if ( ret == Z_OK ) png_ptr -> flags |= PNG_FLAG_ZSTREAM_INITIALIZED ; } if ( ret == Z_OK ) png_ptr -> zowner = owner ; else png_zstream_error ( png_ptr , ret ) ; return ret ; } #  ifdef window_bits #     undef window_bits #  endif }
static PyObject * __pyx_pw_17clickhouse_driver_14bufferedwriter_3__pyx_unpickle_BufferedSocketWriter ( PyObject * __pyx_self , PyObject * __pyx_args , PyObject * __pyx_kwds ) { PyObject * __pyx_v___pyx_type = 0 ; long __pyx_v___pyx_checksum ; PyObject * __pyx_v___pyx_state = 0 ; PyObject * __pyx_r = 0 ; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext ( "__pyx_unpickle_BufferedSocketWriter (wrapper)" , 0 ) ; { static PyObject * * __pyx_pyargnames [ ] = { & __pyx_n_s_pyx_type , & __pyx_n_s_pyx_checksum , & __pyx_n_s_pyx_state , 0 } ; PyObject * values [ 3 ] = { 0 , 0 , 0 } ; if ( unlikely ( __pyx_kwds ) ) { Py_ssize_t kw_args ; const Py_ssize_t pos_args = PyTuple_GET_SIZE ( __pyx_args ) ; switch ( pos_args ) { case 3 : values [ 2 ] = PyTuple_GET_ITEM ( __pyx_args , 2 ) ; CYTHON_FALLTHROUGH ; case 2 : values [ 1 ] = PyTuple_GET_ITEM ( __pyx_args , 1 ) ; CYTHON_FALLTHROUGH ; case 1 : values [ 0 ] = PyTuple_GET_ITEM ( __pyx_args , 0 ) ; CYTHON_FALLTHROUGH ; case 0 : break ; default : goto __pyx_L5_argtuple_error ; } kw_args = PyDict_Size ( __pyx_kwds ) ; switch ( pos_args ) { case 0 : if ( likely ( ( values [ 0 ] = __Pyx_PyDict_GetItemStr ( __pyx_kwds , __pyx_n_s_pyx_type ) ) != 0 ) ) kw_args -- ; else goto __pyx_L5_argtuple_error ; CYTHON_FALLTHROUGH ; case 1 : if ( likely ( ( values [ 1 ] = __Pyx_PyDict_GetItemStr ( __pyx_kwds , __pyx_n_s_pyx_checksum ) ) != 0 ) ) kw_args -- ; else { __Pyx_RaiseArgtupleInvalid ( "__pyx_unpickle_BufferedSocketWriter" , 1 , 3 , 3 , 1 ) ; __PYX_ERR ( 1 , 1 , __pyx_L3_error ) } CYTHON_FALLTHROUGH ; case 2 : if ( likely ( ( values [ 2 ] = __Pyx_PyDict_GetItemStr ( __pyx_kwds , __pyx_n_s_pyx_state ) ) != 0 ) ) kw_args -- ; else { __Pyx_RaiseArgtupleInvalid ( "__pyx_unpickle_BufferedSocketWriter" , 1 , 3 , 3 , 2 ) ; __PYX_ERR ( 1 , 1 , __pyx_L3_error ) } } if ( unlikely ( kw_args > 0 ) ) { if ( unlikely ( __Pyx_ParseOptionalKeywords ( __pyx_kwds , __pyx_pyargnames , 0 , values , pos_args , "__pyx_unpickle_BufferedSocketWriter" ) < 0 ) ) __PYX_ERR ( 1 , 1 , __pyx_L3_error ) } } else if ( PyTuple_GET_SIZE ( __pyx_args ) != 3 ) { goto __pyx_L5_argtuple_error ; } else { values [ 0 ] = PyTuple_GET_ITEM ( __pyx_args , 0 ) ; values [ 1 ] = PyTuple_GET_ITEM ( __pyx_args , 1 ) ; values [ 2 ] = PyTuple_GET_ITEM ( __pyx_args , 2 ) ; } __pyx_v___pyx_type = values [ 0 ] ; __pyx_v___pyx_checksum = __Pyx_PyInt_As_long ( values [ 1 ] ) ; if ( unlikely ( ( __pyx_v___pyx_checksum == ( long ) - 1 ) && PyErr_Occurred ( ) ) ) __PYX_ERR ( 1 , 1 , __pyx_L3_error ) __pyx_v___pyx_state = values [ 2 ] ; } goto __pyx_L4_argument_unpacking_done ; __pyx_L5_argtuple_error : ; __Pyx_RaiseArgtupleInvalid ( "__pyx_unpickle_BufferedSocketWriter" , 1 , 3 , 3 , PyTuple_GET_SIZE ( __pyx_args ) ) ; __PYX_ERR ( 1 , 1 , __pyx_L3_error ) __pyx_L3_error : ; __Pyx_AddTraceback ( "clickhouse_driver.bufferedwriter.__pyx_unpickle_BufferedSocketWriter" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __Pyx_RefNannyFinishContext ( ) ; return NULL ; __pyx_L4_argument_unpacking_done : ; __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedwriter_2__pyx_unpickle_BufferedSocketWriter ( __pyx_self , __pyx_v___pyx_type , __pyx_v___pyx_checksum , __pyx_v___pyx_state ) ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
void Heap :: MarkCompact ( ) { PauseAllocationObserversScope pause_observers ( this ) ; SetGCState ( MARK_COMPACT ) ; LOG ( isolate_ , ResourceEvent ( "markcompact" , "begin" ) ) ; uint64_t size_of_objects_before_gc = SizeOfObjects ( ) ; CodeSpaceMemoryModificationScope code_modifcation ( this ) ; mark_compact_collector ( ) -> Prepare ( ) ; ms_count_ ++ ; MarkCompactPrologue ( ) ; mark_compact_collector ( ) -> CollectGarbage ( ) ; LOG ( isolate_ , ResourceEvent ( "markcompact" , "end" ) ) ; MarkCompactEpilogue ( ) ; if ( FLAG_allocation_site_pretenuring ) { EvaluateOldSpaceLocalPretenuring ( size_of_objects_before_gc ) ; } }
Reduction JSCallReducer :: ReducePromisePrototypeCatch ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSCall , node -> opcode ( ) ) ; CallParameters const & p = CallParametersOf ( node -> op ( ) ) ; if ( p . speculation_mode ( ) == SpeculationMode :: kDisallowSpeculation ) { return NoChange ( ) ; } int arity = static_cast < int > ( p . arity ( ) - 2 ) ; Node * receiver = NodeProperties :: GetValueInput ( node , 1 ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; if ( ! isolate ( ) -> IsPromiseThenLookupChainIntact ( ) ) return NoChange ( ) ; ZoneHandleSet < Map > receiver_maps ; NodeProperties :: InferReceiverMapsResult result = NodeProperties :: InferReceiverMaps ( isolate ( ) , receiver , effect , & receiver_maps ) ; if ( result == NodeProperties :: kNoReceiverMaps ) return NoChange ( ) ; DCHECK_NE ( 0 , receiver_maps . size ( ) ) ; for ( Handle < Map > receiver_map : receiver_maps ) { if ( ! receiver_map -> IsJSPromiseMap ( ) ) return NoChange ( ) ; if ( receiver_map -> prototype ( ) != native_context ( ) -> promise_prototype ( ) ) { return NoChange ( ) ; } } dependencies ( ) -> DependOnProtector ( PropertyCellRef ( js_heap_broker ( ) , factory ( ) -> promise_then_protector ( ) ) ) ; if ( result == NodeProperties :: kUnreliableReceiverMaps ) { effect = graph ( ) -> NewNode ( simplified ( ) -> CheckMaps ( CheckMapsFlag :: kNone , receiver_maps , p . feedback ( ) ) , receiver , effect , control ) ; } Node * target = jsgraph ( ) -> Constant ( handle ( native_context ( ) -> promise_then ( ) , isolate ( ) ) ) ; NodeProperties :: ReplaceValueInput ( node , target , 0 ) ; NodeProperties :: ReplaceEffectInput ( node , effect ) ; for ( ; arity > 1 ; -- arity ) node -> RemoveInput ( 3 ) ; for ( ; arity < 2 ; ++ arity ) { node -> InsertInput ( graph ( ) -> zone ( ) , 2 , jsgraph ( ) -> UndefinedConstant ( ) ) ; } NodeProperties :: ChangeOp ( node , javascript ( ) -> Call ( 2 + arity , p . frequency ( ) , p . feedback ( ) , ConvertReceiverMode :: kNotNullOrUndefined , p . speculation_mode ( ) ) ) ; Reduction const reduction = ReducePromisePrototypeThen ( node ) ; return reduction . Changed ( ) ? reduction : Changed ( node ) ; }
jpc_ms_t * jpc_getms ( jas_stream_t * in , jpc_cstate_t * cstate ) { jpc_ms_t * ms ; jpc_mstabent_t * mstabent ; jas_stream_t * tmpstream ; if ( ! ( ms = jpc_ms_create ( 0 ) ) ) { return 0 ; } if ( jpc_getuint16 ( in , & ms -> id ) || ms -> id < JPC_MS_MIN || ms -> id > JPC_MS_MAX ) { jpc_ms_destroy ( ms ) ; return 0 ; } mstabent = jpc_mstab_lookup ( ms -> id ) ; ms -> ops = & mstabent -> ops ; if ( JPC_MS_HASPARMS ( ms -> id ) ) { if ( jpc_getuint16 ( in , & ms -> len ) || ms -> len < 3 ) { jpc_ms_destroy ( ms ) ; return 0 ; } ms -> len -= 2 ; if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { jpc_ms_destroy ( ms ) ; return 0 ; } if ( jas_stream_copy ( tmpstream , in , ms -> len ) || jas_stream_seek ( tmpstream , 0 , SEEK_SET ) < 0 ) { jas_stream_close ( tmpstream ) ; jpc_ms_destroy ( ms ) ; return 0 ; } if ( ( * ms -> ops -> getparms ) ( ms , cstate , tmpstream ) ) { ms -> ops = 0 ; jpc_ms_destroy ( ms ) ; jas_stream_close ( tmpstream ) ; return 0 ; } if ( jas_getdbglevel ( ) > 0 ) { jpc_ms_dump ( ms , stderr ) ; } if ( JAS_CAST ( ulong , jas_stream_tell ( tmpstream ) ) != ms -> len ) { jas_eprintf ( "warning: trailing garbage in marker segment (%ld bytes)\n" , ms -> len - jas_stream_tell ( tmpstream ) ) ; } jas_stream_close ( tmpstream ) ; } else { ms -> len = 0 ; if ( jas_getdbglevel ( ) > 0 ) { jpc_ms_dump ( ms , stderr ) ; } } if ( ms -> id == JPC_MS_SIZ ) { cstate -> numcomps = ms -> parms . siz . numcomps ; } return ms ; }
double ThreadTicks :: TSCTicksPerSecond ( ) { DCHECK ( IsSupported ( ) ) ; static double tsc_ticks_per_second = 0 ; if ( tsc_ticks_per_second != 0 ) return tsc_ticks_per_second ; int previous_priority = :: GetThreadPriority ( :: GetCurrentThread ( ) ) ; :: SetThreadPriority ( :: GetCurrentThread ( ) , THREAD_PRIORITY_HIGHEST ) ; static const uint64_t tsc_initial = __rdtsc ( ) ; static const uint64_t perf_counter_initial = QPCNowRaw ( ) ; uint64_t tsc_now = __rdtsc ( ) ; uint64_t perf_counter_now = QPCNowRaw ( ) ; :: SetThreadPriority ( :: GetCurrentThread ( ) , previous_priority ) ; LARGE_INTEGER perf_counter_frequency = { } ; :: QueryPerformanceFrequency ( & perf_counter_frequency ) ; DCHECK_GE ( perf_counter_now , perf_counter_initial ) ; uint64_t perf_counter_ticks = perf_counter_now - perf_counter_initial ; double elapsed_time_seconds = perf_counter_ticks / static_cast < double > ( perf_counter_frequency . QuadPart ) ; const double kMinimumEvaluationPeriodSeconds = 0.05 ; if ( elapsed_time_seconds < kMinimumEvaluationPeriodSeconds ) return 0 ; DCHECK_GE ( tsc_now , tsc_initial ) ; uint64_t tsc_ticks = tsc_now - tsc_initial ; tsc_ticks_per_second = tsc_ticks / elapsed_time_seconds ; return tsc_ticks_per_second ; }
struct r_bin_pe_addr_t * PE_ ( check_mingw ) ( RBinPEObj * pe ) { struct r_bin_pe_addr_t * entry ; bool sw = false ; ut8 b [ 1024 ] ; size_t n = 0 ; if ( ! pe || ! pe -> b ) { return 0LL ; } entry = PE_ ( r_bin_pe_get_entrypoint ) ( pe ) ; ZERO_FILL ( b ) ; if ( r_buf_read_at ( pe -> b , entry -> paddr , b , sizeof ( b ) ) < 0 ) { pe_printf ( "Warning: Cannot read entry at 0x%08"PFMT64x "\n" , entry -> paddr ) ; free ( entry ) ; return NULL ; } if ( b [ 0 ] == 0x55 && b [ 1 ] == 0x89 && b [ 3 ] == 0x83 && b [ 6 ] == 0xc7 && b [ 13 ] == 0xff && b [ 19 ] == 0xe8 ) { sw = follow_offset ( entry , pe -> b , b , sizeof ( b ) , pe -> big_endian , 19 ) ; } if ( b [ 0 ] == 0x83 && b [ 3 ] == 0xc7 && b [ 10 ] == 0xff && b [ 16 ] == 0xe8 ) { sw = follow_offset ( entry , pe -> b , b , sizeof ( b ) , pe -> big_endian , 16 ) ; } if ( b [ 0 ] == 0x83 && b [ 3 ] == 0xc7 && b [ 13 ] == 0xe8 && b [ 18 ] == 0x83 && b [ 21 ] == 0xe9 ) { sw = follow_offset ( entry , pe -> b , b , sizeof ( b ) , pe -> big_endian , 21 ) ; } if ( sw ) { for ( n = 0 ; n < sizeof ( b ) - 12 ; n ++ ) { if ( b [ n ] == 0xa1 && b [ n + 5 ] == 0x89 && b [ n + 8 ] == 0xe8 ) { sw = follow_offset ( entry , pe -> b , b , sizeof ( b ) , pe -> big_endian , n + 8 ) ; return entry ; } } } free ( entry ) ; return NULL ; }
void AbortAnimation ( ) { MOZ_ASSERT ( AndroidBridge :: IsJavaUiThread ( ) ) ; MutexAutoLock lock ( mWindowLock ) ; if ( ! mWindow ) { return ; } RefPtr < IAPZCTreeManager > controller = mWindow -> mAPZC ; RefPtr < CompositorBridgeParent > compositor = mWindow -> GetCompositorBridgeParent ( ) ; if ( controller && compositor ) { controller -> CancelAnimation ( ScrollableLayerGuid ( compositor -> RootLayerTreeId ( ) , 0 , 0 ) ) ; } }
long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , "Filesystem call made without initialization" ) ; for ( search = fs_searchpaths ; search ; search = search -> next ) { len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } #ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , "%s\n" , filename ) ; #endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }
static int inv_recenter_nonneg ( int v , int m ) { if ( v > 2 * m ) return v ; return v % 2 ? m - ( v + 1 ) / 2 : m + v / 2 ; }
static int add_push_report_sideband_pkt ( git_push * push , git_pkt_data * data_pkt , git_buf * data_pkt_buf ) { git_pkt * pkt ; const char * line , * line_end ; size_t line_len ; int error ; int reading_from_buf = data_pkt_buf -> size > 0 ; if ( reading_from_buf ) { git_buf_put ( data_pkt_buf , data_pkt -> data , data_pkt -> len ) ; line = data_pkt_buf -> ptr ; line_len = data_pkt_buf -> size ; } else { line = data_pkt -> data ; line_len = data_pkt -> len ; } while ( line_len > 0 ) { error = git_pkt_parse_line ( & pkt , line , & line_end , line_len ) ; if ( error == GIT_EBUFS ) { if ( ! reading_from_buf ) git_buf_put ( data_pkt_buf , line , line_len ) ; error = 0 ; goto done ; } else if ( error < 0 ) goto done ; line_len -= ( line_end - line ) ; line = line_end ; if ( pkt == NULL ) continue ; error = add_push_report_pkt ( push , pkt ) ; git_pkt_free ( pkt ) ; if ( error < 0 && error != GIT_ITEROVER ) goto done ; } error = 0 ; done : if ( reading_from_buf ) git_buf_consume ( data_pkt_buf , line_end ) ; return error ; }
static void ttm_put_pages ( struct page * * pages , unsigned npages , int flags , enum ttm_caching_state cstate ) { struct ttm_page_pool * pool = ttm_get_pool ( flags , false , cstate ) ; #ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool * huge = ttm_get_pool ( flags , true , cstate ) ; #endif unsigned long irq_flags ; unsigned i ; if ( pool == NULL ) { i = 0 ; while ( i < npages ) { #ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ; #endif unsigned order = 0 , j ; if ( ! pages [ i ] ) { ++ i ; continue ; } #ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) ) { for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ; } #endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( "Erroneous page count. Leaking pages.\n" ) ; __free_pages ( pages [ i ] , order ) ; j = 1 < < order ; while ( j ) { pages [ i ++ ] = NULL ; -- j ; } } return ; } i = 0 ; #ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) { unsigned max_size , n2free ; spin_lock_irqsave ( & huge -> lock , irq_flags ) ; while ( i < npages ) { struct page * p = pages [ i ] ; unsigned j ; if ( ! p ) break ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j != HPAGE_PMD_NR ) break ; list_add_tail ( & pages [ i ] -> lru , & huge -> list ) ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) pages [ i ++ ] = NULL ; huge -> npages ++ ; } max_size = _manager -> options . max_size ; max_size /= HPAGE_PMD_NR ; if ( huge -> npages > max_size ) n2free = huge -> npages - max_size ; else n2free = 0 ; spin_unlock_irqrestore ( & huge -> lock , irq_flags ) ; if ( n2free ) ttm_page_pool_free ( huge , n2free , false ) ; } #endif spin_lock_irqsave ( & pool -> lock , irq_flags ) ; while ( i < npages ) { if ( pages [ i ] ) { if ( page_count ( pages [ i ] ) != 1 ) pr_err ( "Erroneous page count. Leaking pages.\n" ) ; list_add_tail ( & pages [ i ] -> lru , & pool -> list ) ; pages [ i ] = NULL ; pool -> npages ++ ; } ++ i ; } npages = 0 ; if ( pool -> npages > _manager -> options . max_size ) { npages = pool -> npages - _manager -> options . max_size ; if ( npages < NUM_PAGES_TO_ALLOC ) npages = NUM_PAGES_TO_ALLOC ; } spin_unlock_irqrestore ( & pool -> lock , irq_flags ) ; if ( npages ) ttm_page_pool_free ( pool , npages , false ) ; }
bool WasmDebugInfo :: RunInterpreter ( Isolate * isolate , Handle < WasmDebugInfo > debug_info , Address frame_pointer , int func_index , Address arg_buffer ) { DCHECK_LE ( 0 , func_index ) ; auto * handle = GetOrCreateInterpreterHandle ( isolate , debug_info ) ; Handle < WasmInstanceObject > instance ( debug_info -> wasm_instance ( ) , isolate ) ; return handle -> Execute ( instance , frame_pointer , static_cast < uint32_t > ( func_index ) , arg_buffer ) ; }
void BytecodeGenerator :: BuildLoadNamedProperty ( Property * property , Register object , const AstRawString * name ) { if ( ShouldOptimizeAsOneShot ( ) ) { RegisterList args = register_allocator ( ) -> NewRegisterList ( 2 ) ; size_t name_index = builder ( ) -> GetConstantPoolEntry ( name ) ; builder ( ) -> MoveRegister ( object , args [ 0 ] ) . LoadConstantPoolEntry ( name_index ) . StoreAccumulatorInRegister ( args [ 1 ] ) . CallRuntime ( Runtime :: kInlineGetProperty , args ) ; } else { FeedbackSlot slot = GetCachedLoadICSlot ( property -> obj ( ) , name ) ; builder ( ) -> LoadNamedProperty ( object , name , feedback_index ( slot ) ) ; } }
R_API int r_socket_block_time ( RSocket * s , int block , int sec , int usec ) { #if __UNIX__ int ret , flags ; #endif if ( ! s ) { return false ; } #if __UNIX__ flags = fcntl ( s -> fd , F_GETFL , 0 ) ; if ( flags < 0 ) { return false ; } ret = fcntl ( s -> fd , F_SETFL , block ? ( flags & ~ O_NONBLOCK ) : ( flags | O_NONBLOCK ) ) ; if ( ret < 0 ) { return false ; } #elif __WINDOWS__ ioctlsocket ( s -> fd , FIONBIO , ( u_long FAR * ) & block ) ; #endif if ( sec > 0 || usec > 0 ) { struct timeval tv = { 0 } ; tv . tv_sec = sec ; tv . tv_usec = usec ; if ( setsockopt ( s -> fd , SOL_SOCKET , SO_RCVTIMEO , ( char * ) & tv , sizeof ( tv ) ) < 0 ) { return false ; } } return true ; }
static int cac_get_serial_nr_from_CUID ( sc_card_t * card , sc_serial_number_t * serial ) { cac_private_data_t * priv = CAC_DATA ( card ) ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_NORMAL ) ; if ( card -> serialnr . len ) { * serial = card -> serialnr ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } if ( priv -> cac_id_len ) { serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ; memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ; }
RUNTIME_FUNCTION ( Runtime_StoreKeyedToSuper_Sloppy ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 4 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( Object , receiver , 0 ) ; CONVERT_ARG_HANDLE_CHECKED ( JSObject , home_object , 1 ) ; CONVERT_ARG_HANDLE_CHECKED ( Object , key , 2 ) ; CONVERT_ARG_HANDLE_CHECKED ( Object , value , 3 ) ; RETURN_RESULT_OR_FAILURE ( isolate , StoreKeyedToSuper ( isolate , home_object , receiver , key , value , LanguageMode :: kSloppy ) ) ; }
static int hashtable_do_del ( hashtable_t * hashtable , const char * key , size_t hash ) { pair_t * pair ; bucket_t * bucket ; size_t index ; index = hash % num_buckets ( hashtable ) ; bucket = & hashtable -> buckets [ index ] ; pair = hashtable_find_pair ( hashtable , bucket , key , hash ) ; if ( ! pair ) return - 1 ; if ( & pair -> list == bucket -> first && & pair -> list == bucket -> last ) bucket -> first = bucket -> last = & hashtable -> list ; else if ( & pair -> list == bucket -> first ) bucket -> first = pair -> list . next ; else if ( & pair -> list == bucket -> last ) bucket -> last = pair -> list . prev ; list_remove ( & pair -> list ) ; json_decref ( pair -> value ) ; jsonp_free ( pair ) ; hashtable -> size -- ; return 0 ; }
GetHelper :: ReleaseMainThreadObjects ( ) { mKeyRange = nullptr ; IDBObjectStore :: ClearStructuredCloneBuffer ( mCloneReadInfo . mCloneBuffer ) ; ObjectStoreHelper :: ReleaseMainThreadObjects ( ) ; }
uint32_t BytecodeDecoder :: DecodeUnsignedOperand ( Address operand_start , OperandType operand_type , OperandScale operand_scale ) { DCHECK ( Bytecodes :: IsUnsignedOperandType ( operand_type ) ) ; switch ( Bytecodes :: SizeOfOperand ( operand_type , operand_scale ) ) { case OperandSize :: kByte : return * reinterpret_cast < const uint8_t * > ( operand_start ) ; case OperandSize :: kShort : return ReadUnalignedUInt16 ( operand_start ) ; case OperandSize :: kQuad : return ReadUnalignedUInt32 ( operand_start ) ; case OperandSize :: kNone : UNREACHABLE ( ) ; } return 0 ; }
void SoftG711 :: onQueueFilled ( OMX_U32 ) { if ( mSignalledError ) { return ; } List < BufferInfo * > & inQueue = getPortQueue ( 0 ) ; List < BufferInfo * > & outQueue = getPortQueue ( 1 ) ; while ( ! inQueue . empty ( ) && ! outQueue . empty ( ) ) { BufferInfo * inInfo = * inQueue . begin ( ) ; OMX_BUFFERHEADERTYPE * inHeader = inInfo -> mHeader ; BufferInfo * outInfo = * outQueue . begin ( ) ; OMX_BUFFERHEADERTYPE * outHeader = outInfo -> mHeader ; if ( inHeader -> nFlags & OMX_BUFFERFLAG_EOS ) { inQueue . erase ( inQueue . begin ( ) ) ; inInfo -> mOwnedByUs = false ; notifyEmptyBufferDone ( inHeader ) ; outHeader -> nFilledLen = 0 ; outHeader -> nFlags = OMX_BUFFERFLAG_EOS ; outQueue . erase ( outQueue . begin ( ) ) ; outInfo -> mOwnedByUs = false ; notifyFillBufferDone ( outHeader ) ; return ; } if ( inHeader -> nFilledLen > kMaxNumSamplesPerFrame ) { ALOGE ( "input buffer too large (%d)." , inHeader -> nFilledLen ) ; notify ( OMX_EventError , OMX_ErrorUndefined , 0 , NULL ) ; mSignalledError = true ; } const uint8_t * inputptr = inHeader -> pBuffer + inHeader -> nOffset ; if ( mIsMLaw ) { DecodeMLaw ( reinterpret_cast < int16_t * > ( outHeader -> pBuffer ) , inputptr , inHeader -> nFilledLen ) ; } else { DecodeALaw ( reinterpret_cast < int16_t * > ( outHeader -> pBuffer ) , inputptr , inHeader -> nFilledLen ) ; } outHeader -> nTimeStamp = inHeader -> nTimeStamp ; outHeader -> nOffset = 0 ; outHeader -> nFilledLen = inHeader -> nFilledLen * sizeof ( int16_t ) ; outHeader -> nFlags = 0 ; inInfo -> mOwnedByUs = false ; inQueue . erase ( inQueue . begin ( ) ) ; inInfo = NULL ; notifyEmptyBufferDone ( inHeader ) ; inHeader = NULL ; outInfo -> mOwnedByUs = false ; outQueue . erase ( outQueue . begin ( ) ) ; outInfo = NULL ; notifyFillBufferDone ( outHeader ) ; outHeader = NULL ; } }
void FetchChunk ( size_t position ) { const uint8_t * data = nullptr ; size_t length ; { RuntimeCallTimerScope scope ( stats_ , RuntimeCallCounterId :: kGetMoreDataCallback ) ; length = source_ -> GetMoreData ( & data ) ; } ProcessChunk ( data , position , length ) ; }
static int pagemap_open ( struct inode * inode , struct file * file ) { pr_warn_once ( "Bits 55-60 of /proc/PID/pagemap entries are about " "to stop being page-shift some time soon. See the " "linux/Documentation/vm/pagemap.txt for details.\n" ) ; return 0 ; }
array_push_slowly ( JSContext * cx , JSObject * obj , uintN argc , jsval * argv , jsval * rval ) { jsuint length , newlength ; if ( ! js_GetLengthProperty ( cx , obj , & length ) ) return JS_FALSE ; newlength = length + argc ; if ( ! InitArrayElements ( cx , obj , length , newlength , argv ) ) return JS_FALSE ; if ( ! IndexToValue ( cx , newlength , rval ) ) return JS_FALSE ; return js_SetLengthProperty ( cx , obj , newlength ) ; }
static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu ) { if ( ! to_vmx ( vcpu ) -> nested . vmxon ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; } return 1 ; }
static int __init init_ext2_fs ( void ) { int err = init_ext2_xattr ( ) ; if ( err ) return err ; err = init_inodecache ( ) ; if ( err ) goto out1 ; err = register_filesystem ( & ext2_fs_type ) ; if ( err ) goto out ; return 0 ; out : destroy_inodecache ( ) ; out1 : exit_ext2_xattr ( ) ; return err ; }
static void MaybeTailCallOptimizedCodeSlot ( MacroAssembler * masm , Register feedback_vector , Register scratch1 , Register scratch2 , Register scratch3 ) { DCHECK ( ! AreAliased ( feedback_vector , a0 , a1 , a3 , scratch1 , scratch2 , scratch3 ) ) ; Label optimized_code_slot_is_weak_ref , fallthrough ; Register closure = a1 ; Register optimized_code_entry = scratch1 ; __ lw ( optimized_code_entry , FieldMemOperand ( feedback_vector , FeedbackVector :: kOptimizedCodeOffset ) ) ; __ JumpIfNotSmi ( optimized_code_entry , & optimized_code_slot_is_weak_ref ) ; { __ Branch ( & fallthrough , eq , optimized_code_entry , Operand ( Smi :: FromEnum ( OptimizationMarker :: kNone ) ) ) ; TailCallRuntimeIfMarkerEquals ( masm , optimized_code_entry , OptimizationMarker :: kLogFirstExecution , Runtime :: kFunctionFirstExecution ) ; TailCallRuntimeIfMarkerEquals ( masm , optimized_code_entry , OptimizationMarker :: kCompileOptimized , Runtime :: kCompileOptimized_NotConcurrent ) ; TailCallRuntimeIfMarkerEquals ( masm , optimized_code_entry , OptimizationMarker :: kCompileOptimizedConcurrent , Runtime :: kCompileOptimized_Concurrent ) ; { if ( FLAG_debug_code ) { __ Assert ( eq , AbortReason :: kExpectedOptimizationSentinel , optimized_code_entry , Operand ( Smi :: FromEnum ( OptimizationMarker :: kInOptimizationQueue ) ) ) ; } __ jmp ( & fallthrough ) ; } } { __ bind ( & optimized_code_slot_is_weak_ref ) ; __ LoadWeakValue ( optimized_code_entry , optimized_code_entry , & fallthrough ) ; Label found_deoptimized_code ; __ lw ( scratch2 , FieldMemOperand ( optimized_code_entry , Code :: kCodeDataContainerOffset ) ) ; __ lw ( scratch2 , FieldMemOperand ( scratch2 , CodeDataContainer :: kKindSpecificFlagsOffset ) ) ; __ And ( scratch2 , scratch2 , Operand ( 1 < < Code :: kMarkedForDeoptimizationBit ) ) ; __ Branch ( & found_deoptimized_code , ne , scratch2 , Operand ( zero_reg ) ) ; ReplaceClosureCodeWithOptimizedCode ( masm , optimized_code_entry , closure , scratch2 , scratch3 , feedback_vector ) ; static_assert ( kJavaScriptCallCodeStartRegister == a2 , "ABI mismatch" ) ; __ Addu ( a2 , optimized_code_entry , Code :: kHeaderSize - kHeapObjectTag ) ; __ Jump ( a2 ) ; __ bind ( & found_deoptimized_code ) ; GenerateTailCallToReturnedCode ( masm , Runtime :: kEvictOptimizedCodeSlot ) ; } __ bind ( & fallthrough ) ; }
UnoptimizedCompilationJob :: Status AsmJsCompilationJob :: ExecuteJobImpl ( ) { size_t compile_zone_start = compilation_info ( ) -> zone ( ) -> allocation_size ( ) ; base :: ElapsedTimer translate_timer ; translate_timer . Start ( ) ; Zone * compile_zone = compilation_info ( ) -> zone ( ) ; Zone translate_zone ( allocator_ , ZONE_NAME ) ; Utf16CharacterStream * stream = parse_info ( ) -> character_stream ( ) ; base :: Optional < AllowHandleDereference > allow_deref ; if ( stream -> can_access_heap ( ) ) { allow_deref . emplace ( ) ; } stream -> Seek ( compilation_info ( ) -> literal ( ) -> start_position ( ) ) ; wasm :: AsmJsParser parser ( & translate_zone , stack_limit ( ) , stream ) ; if ( ! parser . Run ( ) ) { if ( ! FLAG_suppress_asm_messages ) { ReportCompilationFailure ( parse_info ( ) , parser . failure_location ( ) , parser . failure_message ( ) ) ; } return FAILED ; } module_ = new ( compile_zone ) wasm :: ZoneBuffer ( compile_zone ) ; parser . module_builder ( ) -> WriteTo ( * module_ ) ; asm_offsets_ = new ( compile_zone ) wasm :: ZoneBuffer ( compile_zone ) ; parser . module_builder ( ) -> WriteAsmJsOffsetTable ( * asm_offsets_ ) ; stdlib_uses_ = * parser . stdlib_uses ( ) ; size_t compile_zone_size = compilation_info ( ) -> zone ( ) -> allocation_size ( ) - compile_zone_start ; translate_zone_size_ = translate_zone . allocation_size ( ) ; translate_time_ = translate_timer . Elapsed ( ) . InMillisecondsF ( ) ; translate_time_micro_ = translate_timer . Elapsed ( ) . InMicroseconds ( ) ; module_source_size_ = compilation_info ( ) -> literal ( ) -> end_position ( ) - compilation_info ( ) -> literal ( ) -> start_position ( ) ; if ( FLAG_trace_asm_parser ) { PrintF ( "[asm.js translation successful: time=%0.3fms, " "translate_zone=%" PRIuS "KB, compile_zone+=%" PRIuS "KB]\n" , translate_time_ , translate_zone_size_ / KB , compile_zone_size / KB ) ; } return SUCCEEDED ; }
int iwch_cxgb3_ofld_send ( struct t3cdev * tdev , struct sk_buff * skb ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = cxgb3_ofld_send ( tdev , skb ) ; if ( error < 0 ) kfree_skb ( skb ) ; return error ; }
FieldAccess AccessBuilder :: ForMapBitField ( ) { FieldAccess access = { kTaggedBase , Map :: kBitFieldOffset , Handle < Name > ( ) , MaybeHandle < Map > ( ) , TypeCache :: Get ( ) . kUint8 , MachineType :: Uint8 ( ) , kNoWriteBarrier } ; return access ; }
static int bin_entry ( RCore * r , int mode , ut64 laddr , int va , bool inifin ) { char str [ R_FLAG_NAME_SIZE ] ; RList * entries = r_bin_get_entries ( r -> bin ) ; RListIter * iter ; RBinAddr * entry = NULL ; int i = 0 ; ut64 baddr = r_bin_get_baddr ( r -> bin ) ; if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( "fs symbols\n" ) ; } else if ( IS_MODE_JSON ( mode ) ) { r_cons_printf ( "[" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { if ( inifin ) { r_cons_printf ( "[Constructors]\n" ) ; } else { r_cons_printf ( "[Entrypoints]\n" ) ; } } r_list_foreach ( entries , iter , entry ) { ut64 paddr = entry -> paddr ; ut64 haddr = UT64_MAX ; if ( mode != R_CORE_BIN_SET ) { if ( inifin ) { if ( entry -> type == R_BIN_ENTRY_TYPE_PROGRAM ) { continue ; } } else { if ( entry -> type != R_BIN_ENTRY_TYPE_PROGRAM ) { continue ; } } } switch ( entry -> type ) { case R_BIN_ENTRY_TYPE_INIT : case R_BIN_ENTRY_TYPE_FINI : case R_BIN_ENTRY_TYPE_PREINIT : if ( r -> io -> va && entry -> paddr == entry -> vaddr ) { RIOMap * map = r_io_map_get ( r -> io , entry -> vaddr ) ; if ( map ) { paddr = entry -> vaddr - map -> itv . addr + map -> delta ; } } } if ( entry -> haddr ) { haddr = entry -> haddr ; } ut64 at = rva ( r -> bin , paddr , entry -> vaddr , va ) ; const char * type = r_bin_entry_type_string ( entry -> type ) ; if ( ! type ) { type = "unknown" ; } if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags , "symbols" ) ; if ( entry -> type == R_BIN_ENTRY_TYPE_INIT ) { snprintf ( str , R_FLAG_NAME_SIZE , "entry%i.init" , i ) ; } else if ( entry -> type == R_BIN_ENTRY_TYPE_FINI ) { snprintf ( str , R_FLAG_NAME_SIZE , "entry%i.fini" , i ) ; } else if ( entry -> type == R_BIN_ENTRY_TYPE_PREINIT ) { snprintf ( str , R_FLAG_NAME_SIZE , "entry%i.preinit" , i ) ; } else { snprintf ( str , R_FLAG_NAME_SIZE , "entry%i" , i ) ; } r_flag_set ( r -> flags , str , at , 1 ) ; } else if ( IS_MODE_SIMPLE ( mode ) ) { r_cons_printf ( "0x%08"PFMT64x "\n" , at ) ; } else if ( IS_MODE_JSON ( mode ) ) { r_cons_printf ( "%s{\"vaddr\":%" PFMT64d "," "\"paddr\":%" PFMT64d "," "\"baddr\":%" PFMT64d "," "\"laddr\":%" PFMT64d "," "\"haddr\":%" PFMT64d "," "\"type\":\"%s\"}" , iter -> p ? "," : "" , at , paddr , baddr , laddr , haddr , type ) ; } else if ( IS_MODE_RAD ( mode ) ) { char * name = NULL ; if ( entry -> type == R_BIN_ENTRY_TYPE_INIT ) { name = r_str_newf ( "entry%i.init" , i ) ; } else if ( entry -> type == R_BIN_ENTRY_TYPE_FINI ) { name = r_str_newf ( "entry%i.fini" , i ) ; } else if ( entry -> type == R_BIN_ENTRY_TYPE_PREINIT ) { name = r_str_newf ( "entry%i.preinit" , i ) ; } else { name = r_str_newf ( "entry%i" , i ) ; } r_cons_printf ( "f %s 1 @ 0x%08"PFMT64x "\n" , name , at ) ; r_cons_printf ( "f %s_haddr 1 @ 0x%08"PFMT64x "\n" , name , haddr ) ; r_cons_printf ( "s %s\n" , name ) ; free ( name ) ; } else { r_cons_printf ( "vaddr=0x%08"PFMT64x " paddr=0x%08"PFMT64x " baddr=0x%08"PFMT64x " laddr=0x%08"PFMT64x , at , paddr , baddr , laddr ) ; if ( haddr == UT64_MAX ) { r_cons_printf ( " haddr=%"PFMT64d " type=%s\n" , haddr , type ) ; } else { r_cons_printf ( " haddr=0x%08"PFMT64x " type=%s\n" , haddr , type ) ; } } i ++ ; } if ( IS_MODE_SET ( mode ) ) { if ( entry ) { ut64 at = rva ( r -> bin , entry -> paddr , entry -> vaddr , va ) ; r_core_seek ( r , at , 0 ) ; } } else if ( IS_MODE_JSON ( mode ) ) { r_cons_printf ( "]" ) ; r_cons_newline ( ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( "\n%i entrypoints\n" , i ) ; } return true ; }
HRESULT nsDataObj :: GetFileDescriptor_IStreamA ( FORMATETC & aFE , STGMEDIUM & aSTG ) { HGLOBAL fileGroupDescHandle = :: GlobalAlloc ( GMEM_ZEROINIT | GMEM_SHARE , sizeof ( FILEGROUPDESCRIPTORW ) ) ; NS_ENSURE_TRUE ( fileGroupDescHandle , E_OUTOFMEMORY ) ; LPFILEGROUPDESCRIPTORA fileGroupDescA = reinterpret_cast < LPFILEGROUPDESCRIPTORA > ( GlobalLock ( fileGroupDescHandle ) ) ; if ( ! fileGroupDescA ) { :: GlobalFree ( fileGroupDescHandle ) ; return E_OUTOFMEMORY ; } nsAutoString wideFileName ; HRESULT res ; nsCOMPtr < nsIURI > sourceURI ; res = GetDownloadDetails ( getter_AddRefs ( sourceURI ) , wideFileName ) ; if ( FAILED ( res ) ) { :: GlobalFree ( fileGroupDescHandle ) ; return res ; } nsAutoCString nativeFileName ; NS_CopyUnicodeToNative ( wideFileName , nativeFileName ) ; strncpy ( fileGroupDescA -> fgd [ 0 ] . cFileName , nativeFileName . get ( ) , NS_MAX_FILEDESCRIPTOR - 1 ) ; fileGroupDescA -> fgd [ 0 ] . cFileName [ NS_MAX_FILEDESCRIPTOR - 1 ] = '\0' ; fileGroupDescA -> cItems = 1 ; fileGroupDescA -> fgd [ 0 ] . dwFlags = FD_PROGRESSUI ; GlobalUnlock ( fileGroupDescHandle ) ; aSTG . hGlobal = fileGroupDescHandle ; aSTG . tymed = TYMED_HGLOBAL ; return S_OK ; }
static OPJ_BOOL opj_jp2_read_ftyp ( opj_jp2_t * jp2 , OPJ_BYTE * p_header_data , OPJ_UINT32 p_header_size , opj_event_mgr_t * p_manager ) { OPJ_UINT32 i , l_remaining_bytes ; assert ( p_header_data != 00 ) ; assert ( jp2 != 00 ) ; assert ( p_manager != 00 ) ; if ( jp2 -> jp2_state != JP2_STATE_SIGNATURE ) { opj_event_msg ( p_manager , EVT_ERROR , "The ftyp box must be the second box in the file.\n" ) ; return OPJ_FALSE ; } if ( p_header_size < 8 ) { opj_event_msg ( p_manager , EVT_ERROR , "Error with FTYP signature Box size\n" ) ; return OPJ_FALSE ; } opj_read_bytes ( p_header_data , & jp2 -> brand , 4 ) ; p_header_data += 4 ; opj_read_bytes ( p_header_data , & jp2 -> minversion , 4 ) ; p_header_data += 4 ; l_remaining_bytes = p_header_size - 8 ; if ( ( l_remaining_bytes & 0x3 ) != 0 ) { opj_event_msg ( p_manager , EVT_ERROR , "Error with FTYP signature Box size\n" ) ; return OPJ_FALSE ; } jp2 -> numcl = l_remaining_bytes > > 2 ; if ( jp2 -> numcl ) { jp2 -> cl = ( OPJ_UINT32 * ) opj_calloc ( jp2 -> numcl , sizeof ( OPJ_UINT32 ) ) ; if ( jp2 -> cl == 00 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not enough memory with FTYP Box\n" ) ; return OPJ_FALSE ; } } for ( i = 0 ; i < jp2 -> numcl ; ++ i ) { opj_read_bytes ( p_header_data , & jp2 -> cl [ i ] , 4 ) ; p_header_data += 4 ; } jp2 -> jp2_state |= JP2_STATE_FILE_TYPE ; return OPJ_TRUE ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteTensor * data = GetInput ( context , node , kInputDataTensor ) ; const TfLiteTensor * segment_ids = GetInput ( context , node , kInputSegmentIdsTensor ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; if ( IsDynamicTensor ( output ) ) { TF_LITE_ENSURE_OK ( context , ResizeOutputTensor ( context , data , segment_ids , output ) ) ; } #define TF_LITE_SEGMENT_SUM(dtype)                                      \   reference_ops::SegmentSum<dtype>(                                     \       GetTensorShape(data), GetTensorData<dtype>(data),                 \       GetTensorShape(segment_ids), GetTensorData<int32_t>(segment_ids), \       GetTensorShape(output), GetTensorData<dtype>(output)); switch ( data -> type ) { case kTfLiteInt32 : TF_LITE_SEGMENT_SUM ( int32_t ) ; break ; case kTfLiteFloat32 : TF_LITE_SEGMENT_SUM ( float ) ; break ; default : context -> ReportError ( context , "Currently SegmentSum doesn't support type: %s" , TfLiteTypeGetName ( data -> type ) ) ; return kTfLiteError ; } #undef TF_LITE_SEGMENT_SUM return kTfLiteOk ; }
mb_ctor_mbuf ( void * mem , void * arg , int flgs ) { #if USING_MBUF_CONSTRUCTOR struct mbuf * m ; struct mb_args * args ; int flags ; short type ; m = ( struct mbuf * ) mem ; args = ( struct mb_args * ) arg ; flags = args -> flags ; type = args -> type ; if ( type == MT_NOINIT ) return ( 0 ) ; m -> m_next = NULL ; m -> m_nextpkt = NULL ; m -> m_len = 0 ; m -> m_flags = flags ; m -> m_type = type ; if ( flags & M_PKTHDR ) { m -> m_data = m -> m_pktdat ; m -> m_pkthdr . rcvif = NULL ; m -> m_pkthdr . len = 0 ; m -> m_pkthdr . header = NULL ; m -> m_pkthdr . csum_flags = 0 ; m -> m_pkthdr . csum_data = 0 ; m -> m_pkthdr . tso_segsz = 0 ; m -> m_pkthdr . ether_vtag = 0 ; SLIST_INIT ( & m -> m_pkthdr . tags ) ; } else m -> m_data = m -> m_dat ; #endif return ( 0 ) ; }
main ( int argc , char * * argv ) { const char * safepath = "/bin:/sbin:/usr/bin:/usr/sbin:" "/usr/local/bin:/usr/local/sbin" ; const char * confpath = NULL ; char * shargv [ ] = { NULL , NULL } ; char * sh ; const char * cmd ; char cmdline [ LINE_MAX ] ; #ifdef __OpenBSD__ char mypwbuf [ _PW_BUF_LEN ] , targpwbuf [ _PW_BUF_LEN ] ; #else char * mypwbuf = NULL , * targpwbuf = NULL ; #endif struct passwd mypwstore , targpwstore ; struct passwd * mypw , * targpw ; const struct rule * rule ; uid_t uid ; uid_t target = 0 ; gid_t groups [ NGROUPS_MAX + 1 ] ; int ngroups ; int i , ch , rv ; int sflag = 0 ; int nflag = 0 ; char cwdpath [ PATH_MAX ] ; const char * cwd ; char * * envp ; #ifdef USE_BSD_AUTH char * login_style = NULL ; #endif setprogname ( "doas" ) ; closefrom ( STDERR_FILENO + 1 ) ; uid = getuid ( ) ; #ifdef USE_BSD_AUTH # define OPTSTRING "a:C:Lnsu:" #else # define OPTSTRING "+C:Lnsu:" #endif while ( ( ch = getopt ( argc , argv , OPTSTRING ) ) != - 1 ) { switch ( ch ) { #ifdef USE_BSD_AUTH case 'a' : login_style = optarg ; break ; #endif case 'C' : confpath = optarg ; break ; case 'L' : #if defined(USE_BSD_AUTH) i = open ( "/dev/tty" , O_RDWR ) ; if ( i != - 1 ) ioctl ( i , TIOCCLRVERAUTH ) ; exit ( i == - 1 ) ; #elif defined(USE_TIMESTAMP) exit ( timestamp_clear ( ) == - 1 ) ; #else exit ( 0 ) ; #endif case 'u' : if ( parseuid ( optarg , & target ) != 0 ) errx ( 1 , "unknown user" ) ; break ; case 'n' : nflag = 1 ; break ; case 's' : sflag = 1 ; break ; default : usage ( ) ; break ; } } argv += optind ; argc -= optind ; if ( confpath ) { if ( sflag ) usage ( ) ; } else if ( ( ! sflag && ! argc ) || ( sflag && argc ) ) usage ( ) ; #ifdef __OpenBSD__ rv = getpwuid_r ( uid , & mypwstore , mypwbuf , sizeof ( mypwbuf ) , & mypw ) ; if ( rv != 0 ) err ( 1 , "getpwuid_r failed" ) ; #else for ( size_t sz = 1024 ; sz <= 16 * 1024 ; sz *= 2 ) { mypwbuf = reallocarray ( mypwbuf , sz , sizeof ( char ) ) ; if ( mypwbuf == NULL ) errx ( 1 , "can't allocate mypwbuf" ) ; rv = getpwuid_r ( uid , & mypwstore , mypwbuf , sz , & mypw ) ; if ( rv != ERANGE ) break ; } if ( rv != 0 ) err ( 1 , "getpwuid_r failed" ) ; #endif if ( mypw == NULL ) errx ( 1 , "no passwd entry for self" ) ; ngroups = getgroups ( NGROUPS_MAX , groups ) ; if ( ngroups == - 1 ) err ( 1 , "can't get groups" ) ; groups [ ngroups ++ ] = getgid ( ) ; if ( sflag ) { sh = getenv ( "SHELL" ) ; if ( sh == NULL || * sh == '\0' ) { shargv [ 0 ] = mypw -> pw_shell ; } else shargv [ 0 ] = sh ; argv = shargv ; argc = 1 ; } if ( confpath ) { checkconfig ( confpath , argc , argv , uid , groups , ngroups , target ) ; exit ( 1 ) ; } if ( geteuid ( ) ) errx ( 1 , "not installed setuid" ) ; parseconfig ( "/etc/doas.conf" , 1 ) ; ( void ) strlcpy ( cmdline , argv [ 0 ] , sizeof ( cmdline ) ) ; for ( i = 1 ; i < argc ; i ++ ) { if ( strlcat ( cmdline , " " , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; if ( strlcat ( cmdline , argv [ i ] , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; } cmd = argv [ 0 ] ; if ( ! permit ( uid , groups , ngroups , & rule , target , cmd , ( const char * * ) argv + 1 ) ) { syslog ( LOG_AUTHPRIV | LOG_NOTICE , "failed command for %s: %s" , mypw -> pw_name , cmdline ) ; errc ( 1 , EPERM , NULL ) ; } #if defined(__OpenBSD__) || defined(USE_SHADOW) if ( ! ( rule -> options & NOPASS ) ) { if ( nflag ) errx ( 1 , "Authorization required" ) ; # ifdef __OpenBSD__ authuser ( mypw -> pw_name , login_style , rule -> options & PERSIST ) ; # else shadowauth ( mypw -> pw_name , rule -> options & PERSIST ) ; # endif } # ifdef __OpenBSD__ if ( pledge ( "stdio rpath getpw exec id" , NULL ) == - 1 ) err ( 1 , "pledge" ) ; # endif #elif !defined(USE_PAM) ( void ) nflag ; if ( ! ( rule -> options & NOPASS ) ) { errx ( 1 , "Authorization required" ) ; } #endif /* !(__OpenBSD__ || USE_SHADOW) && !USE_PAM */ #ifdef __OpenBSD__ rv = getpwuid_r ( target , & targpwstore , targpwbuf , sizeof ( targpwbuf ) , & targpw ) ; if ( rv != 0 ) errx ( 1 , "no passwd entry for target" ) ; #else for ( size_t sz = 1024 ; sz <= 16 * 1024 ; sz *= 2 ) { targpwbuf = reallocarray ( targpwbuf , sz , sizeof ( char ) ) ; if ( targpwbuf == NULL ) errx ( 1 , "can't allocate targpwbuf" ) ; rv = getpwuid_r ( target , & targpwstore , targpwbuf , sz , & targpw ) ; if ( rv != ERANGE ) break ; } if ( rv != 0 ) err ( 1 , "getpwuid_r failed" ) ; #endif if ( targpw == NULL ) err ( 1 , "getpwuid_r failed" ) ; #if defined(USE_PAM) pamauth ( targpw -> pw_name , mypw -> pw_name , ! nflag , rule -> options & NOPASS , rule -> options & PERSIST ) ; #endif #ifdef HAVE_SETUSERCONTEXT if ( setusercontext ( NULL , targpw , target , LOGIN_SETGROUP | LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK | LOGIN_SETUSER ) != 0 ) errx ( 1 , "failed to set user context for target" ) ; #else if ( setresgid ( targpw -> pw_gid , targpw -> pw_gid , targpw -> pw_gid ) != 0 ) err ( 1 , "setresgid" ) ; if ( initgroups ( targpw -> pw_name , targpw -> pw_gid ) != 0 ) err ( 1 , "initgroups" ) ; if ( setresuid ( target , target , target ) != 0 ) err ( 1 , "setresuid" ) ; #endif #ifdef __OpenBSD__ if ( pledge ( "stdio rpath exec" , NULL ) == - 1 ) err ( 1 , "pledge" ) ; #endif if ( getcwd ( cwdpath , sizeof ( cwdpath ) ) == NULL ) cwd = "(failed)" ; else cwd = cwdpath ; #ifdef __OpenBSD__ if ( pledge ( "stdio exec" , NULL ) == - 1 ) err ( 1 , "pledge" ) ; #endif syslog ( LOG_AUTHPRIV | LOG_INFO , "%s ran command %s as %s from %s" , mypw -> pw_name , cmdline , targpw -> pw_name , cwd ) ; envp = prepenv ( rule ) ; if ( rule -> cmd ) { if ( setenv ( "PATH" , safepath , 1 ) == - 1 ) err ( 1 , "failed to set PATH '%s'" , safepath ) ; } execvpe ( cmd , argv , envp ) ; if ( errno == ENOENT ) errx ( 1 , "%s: command not found" , cmd ) ; err ( 1 , "%s" , cmd ) ; }
static int build_open_gop_key_points ( AVStream * st ) { int k ; int sample_id = 0 ; uint32_t cra_index ; MOVStreamContext * sc = st -> priv_data ; if ( st -> codecpar -> codec_id != AV_CODEC_ID_HEVC || ! sc -> sync_group_count ) return 0 ; sc -> sample_offsets_count = 0 ; for ( uint32_t i = 0 ; i < sc -> ctts_count ; i ++ ) sc -> sample_offsets_count += sc -> ctts_data [ i ] . count ; av_freep ( & sc -> sample_offsets ) ; sc -> sample_offsets = av_calloc ( sc -> sample_offsets_count , sizeof ( * sc -> sample_offsets ) ) ; if ( ! sc -> sample_offsets ) return AVERROR ( ENOMEM ) ; k = 0 ; for ( uint32_t i = 0 ; i < sc -> ctts_count ; i ++ ) for ( int j = 0 ; j < sc -> ctts_data [ i ] . count ; j ++ ) sc -> sample_offsets [ k ++ ] = sc -> ctts_data [ i ] . duration ; cra_index = get_sgpd_sync_index ( sc , HEVC_NAL_CRA_NUT ) ; if ( ! cra_index ) return 0 ; sc -> open_key_samples_count = 0 ; for ( uint32_t i = 0 ; i < sc -> sync_group_count ; i ++ ) if ( sc -> sync_group [ i ] . index == cra_index ) sc -> open_key_samples_count += sc -> sync_group [ i ] . count ; av_freep ( & sc -> open_key_samples ) ; sc -> open_key_samples = av_calloc ( sc -> open_key_samples_count , sizeof ( * sc -> open_key_samples ) ) ; if ( ! sc -> open_key_samples ) return AVERROR ( ENOMEM ) ; k = 0 ; for ( uint32_t i = 0 ; i < sc -> sync_group_count ; i ++ ) { const MOVSbgp * sg = & sc -> sync_group [ i ] ; if ( sg -> index == cra_index ) for ( uint32_t j = 0 ; j < sg -> count ; j ++ ) sc -> open_key_samples [ k ++ ] = sample_id ; sample_id += sg -> count ; } sc -> min_sample_duration = UINT_MAX ; for ( uint32_t i = 0 ; i < sc -> stts_count ; i ++ ) sc -> min_sample_duration = FFMIN ( sc -> min_sample_duration , sc -> stts_data [ i ] . duration ) ; return 0 ; }
SkJpegCodec :: SkJpegCodec ( const SkImageInfo & srcInfo , SkStream * stream , JpegDecoderMgr * decoderMgr ) : INHERITED ( srcInfo , stream ) , fDecoderMgr ( decoderMgr ) , fReadyState ( decoderMgr -> dinfo ( ) -> global_state ) , fSwizzlerSubset ( SkIRect :: MakeEmpty ( ) ) { }
check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) { duprintf ( "Bad offset %p\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking: element %p size %u\n" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 < < h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( "Underflows must be unconditional and " "use the STANDARD target with " "ACCEPT/DROP\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
cib_remote_connection_destroy ( gpointer user_data ) { cib_client_t * client = user_data ; if ( client == NULL ) { return ; } crm_trace ( "Cleaning up after client disconnect: %s/%s" , crm_str ( client -> name ) , client -> id ) ; if ( client -> id != NULL ) { if ( ! g_hash_table_remove ( client_list , client -> id ) ) { crm_err ( "Client %s not found in the hashtable" , client -> name ) ; } } crm_trace ( "Destroying %s (%p)" , client -> name , user_data ) ; num_clients -- ; crm_trace ( "Num unfree'd clients: %d" , num_clients ) ; free ( client -> name ) ; free ( client -> callback_id ) ; free ( client -> id ) ; free ( client -> user ) ; free ( client ) ; crm_trace ( "Freed the cib client" ) ; if ( cib_shutdown_flag ) { cib_shutdown ( 0 ) ; } return ; }
void Heap :: NotifyObjectLayoutChange ( HeapObject * object , int size , const DisallowHeapAllocation & ) { if ( incremental_marking ( ) -> IsMarking ( ) ) { incremental_marking ( ) -> MarkBlackAndPush ( object ) ; if ( incremental_marking ( ) -> IsCompacting ( ) && MayContainRecordedSlots ( object ) ) { MemoryChunk :: FromHeapObject ( object ) -> RegisterObjectWithInvalidatedSlots ( object , size ) ; } } #ifdef VERIFY_HEAP if ( FLAG_verify_heap ) { DCHECK_NULL ( pending_layout_change_object_ ) ; pending_layout_change_object_ = object ; } #endif }
JS :: Value StringToJsval ( nsPIDOMWindow * aWindow , nsAString & aString ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; MOZ_ASSERT ( aWindow ) ; AutoJSAPI jsapi ; if ( NS_WARN_IF ( ! jsapi . Init ( aWindow ) ) ) { return JSVAL_NULL ; } JSContext * cx = jsapi . cx ( ) ; JS :: Rooted < JS :: Value > result ( cx ) ; if ( ! xpc :: StringToJsval ( cx , aString , & result ) ) { return JSVAL_NULL ; } return result ; }
void SMILAnimationController :: NotifyRefreshDriverCreated ( nsRefreshDriver * aRefreshDriver ) { if ( ! mPauseState ) { MaybeStartSampling ( aRefreshDriver ) ; } }
krb5_gss_context_time ( minor_status , context_handle , time_rec ) OM_uint32 * minor_status ; gss_ctx_id_t context_handle ; OM_uint32 * time_rec ; { krb5_error_code code ; krb5_gss_ctx_id_rec * ctx ; krb5_timestamp now ; krb5_deltat lifetime ; ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; if ( ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return ( GSS_S_NO_CONTEXT ) ; } if ( ( code = krb5_timeofday ( ctx -> k5_context , & now ) ) ) { * minor_status = code ; save_error_info ( * minor_status , ctx -> k5_context ) ; return ( GSS_S_FAILURE ) ; } if ( ( lifetime = ctx -> krb_times . endtime - now ) <= 0 ) { * time_rec = 0 ; * minor_status = 0 ; return ( GSS_S_CONTEXT_EXPIRED ) ; } else { * time_rec = lifetime ; * minor_status = 0 ; return ( GSS_S_COMPLETE ) ; } }
void IC :: PatchCache ( Handle < Name > name , const MaybeObjectHandle & handler ) { DCHECK ( IsHandler ( * handler ) ) ; DCHECK ( IsAnyLoad ( ) || IsAnyStore ( ) ) ; switch ( state ( ) ) { case UNINITIALIZED : case PREMONOMORPHIC : UpdateMonomorphicIC ( handler , name ) ; break ; case RECOMPUTE_HANDLER : case MONOMORPHIC : if ( IsGlobalIC ( ) ) { UpdateMonomorphicIC ( handler , name ) ; break ; } V8_FALLTHROUGH ; case POLYMORPHIC : if ( UpdatePolymorphicIC ( name , handler ) ) break ; if ( ! is_keyed ( ) || state ( ) == RECOMPUTE_HANDLER ) { CopyICToMegamorphicCache ( name ) ; } ConfigureVectorState ( MEGAMORPHIC , name ) ; V8_FALLTHROUGH ; case MEGAMORPHIC : UpdateMegamorphicCache ( receiver_map ( ) , name , handler ) ; vector_set_ = true ; break ; case GENERIC : UNREACHABLE ( ) ; break ; } }
nsRefreshDriver :: PVsyncActorCreated ( VsyncChild * aVsyncChild ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; MOZ_ASSERT ( ! XRE_IsParentProcess ( ) ) ; auto * vsyncRefreshDriverTimer = new VsyncRefreshDriverTimer ( aVsyncChild ) ; if ( sRegularRateTimer ) { sRegularRateTimer -> SwapRefreshDrivers ( vsyncRefreshDriverTimer ) ; delete sRegularRateTimer ; } sRegularRateTimer = vsyncRefreshDriverTimer ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { OpData * op_data = reinterpret_cast < OpData * > ( node -> user_data ) ; OpContext op_context ( context , node ) ; if ( IsConstantTensor ( op_context . input ) && op_data -> float_input_initialized ) { return kTfLiteOk ; } TfLiteTensor * dequantized = GetTemporary ( context , node , 0 ) ; auto status = builtin :: dequantize :: DequantizeImpl < kernel_type > ( context , node , op_context . input , dequantized ) ; if ( status != kTfLiteOk ) { return status ; } if ( IsConstantTensor ( op_context . input ) ) { op_data -> float_input_initialized = true ; } if ( op_data -> tolerance < 0.1 ) { std :: vector < double > diffs , temp ; diffs . reserve ( NumElements ( dequantized ) ) ; temp . reserve ( NumElements ( dequantized ) ) ; for ( int i = 0 ; i < NumElements ( op_context . ref ) ; ++ i ) { float dequant = GetTensorData < float > ( dequantized ) [ i ] ; float reference = GetTensorData < float > ( op_context . ref ) [ i ] ; diffs . push_back ( dequant - reference ) ; } double mean = std :: accumulate ( diffs . begin ( ) , diffs . end ( ) , 0.0 ) / diffs . size ( ) ; double max_diff = 0.0 ; std :: transform ( diffs . begin ( ) , diffs . end ( ) , temp . begin ( ) , [ mean , & max_diff ] ( double x ) { max_diff = std :: max ( max_diff , std :: abs ( x ) ) ; return x - mean ; } ) ; double sq_sum = std :: inner_product ( temp . begin ( ) , temp . end ( ) , temp . begin ( ) , 0.0 ) ; double std = std :: sqrt ( sq_sum / diffs . size ( ) ) ; TF_LITE_KERNEL_LOG ( context , "std: %f, mean: %f, max_diff: %f (scale: %f, zero_point: %d).\n" , std , mean , max_diff , op_context . input -> params . scale , op_context . input -> params . zero_point ) ; return kTfLiteOk ; } auto max_diff = op_data -> tolerance * op_context . input -> params . scale ; for ( int i = 0 ; i < NumElements ( op_context . ref ) ; ++ i ) { int32_t value = GetQuantizedValue ( op_context , i ) ; float dequant = GetTensorData < float > ( dequantized ) [ i ] ; float reference = GetTensorData < float > ( op_context . ref ) [ i ] ; float diff = std :: abs ( reference - dequant ) ; if ( diff > max_diff ) { TF_LITE_KERNEL_LOG ( context , "Mismatch: %f is quantized to %d with (%f, %d). " "abs(%f - %f) = %f > %f (tolerance) range percentage %f.\n" , reference , value , op_context . input -> params . scale , op_context . input -> params . zero_point , reference , dequant , diff , max_diff , op_data -> tolerance ) ; return kTfLiteError ; } } return kTfLiteOk ; }
MediaStreamSource :: MediaStreamSource ( MediaResource * aResource , AbstractMediaDecoder * aDecoder ) : mResource ( aResource ) , mDecoder ( aDecoder ) { }
} #endif static MagickBooleanType ReadPSDChannel ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , LayerInfo * layer_info , const size_t channel , const PSDCompressionType compression , ExceptionInfo * exception ) { Image * channel_image , * mask ; MagickOffsetType offset ; MagickBooleanType status ; channel_image = image ; mask = ( Image * ) NULL ; if ( layer_info -> channel_info [ channel ] . type < - 1 ) { const char * option ; option = GetImageOption ( image_info , "psd:preserve-opacity-mask" ) ; if ( ( layer_info -> channel_info [ channel ] . type != - 2 ) || ( layer_info -> mask . flags > 2 ) || ( ( layer_info -> mask . flags & 0x02 ) && ( IsStringTrue ( option ) == MagickFalse ) ) ) { SeekBlob ( image , layer_info -> channel_info [ channel ] . size - 2 , SEEK_CUR ) ; return ( MagickTrue ) ; } mask = CloneImage ( image , layer_info -> mask . page . width , layer_info -> mask . page . height , MagickFalse , exception ) ; mask -> matte = MagickFalse ; channel_image = mask ; } offset = TellBlob ( image ) ; status = MagickTrue ; switch ( compression ) { case Raw : status = ReadPSDChannelRaw ( channel_image , psd_info -> channels , layer_info -> channel_info [ channel ] . type , exception ) ; break ; case RLE : { MagickOffsetType * sizes ; sizes = ReadPSDRLESizes ( channel_image , psd_info , channel_image -> rows ) ; if ( sizes == ( MagickOffsetType * ) NULL ) ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , image -> filename ) ; status = ReadPSDChannelRLE ( channel_image , psd_info , layer_info -> channel_info [ channel ] . type , sizes , exception ) ; sizes = ( MagickOffsetType * ) RelinquishMagickMemory ( sizes ) ; } break ; case ZipWithPrediction : case ZipWithoutPrediction : #ifdef MAGICKCORE_ZLIB_DELEGATE status = ReadPSDChannelZip ( channel_image , layer_info -> channels , layer_info -> channel_info [ channel ] . type , compression , layer_info -> channel_info [ channel ] . size - 2 , exception ) ; #else ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , MissingDelegateWarning , "DelegateLibrarySupportNotBuiltIn" , "'%s' (ZLIB)" , image -> filename ) ; #endif break ; default : ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , TypeWarning , "CompressionNotSupported" , "'%.20g'" , ( double ) compression ) ; break ; } SeekBlob ( image , offset + layer_info -> channel_info [ channel ] . size - 2 , SEEK_SET ) ; if ( status == MagickFalse ) { if ( mask != ( Image * ) NULL ) DestroyImage ( mask ) ; ThrowBinaryException ( CoderError , "UnableToDecompressImage" , image -> filename ) ; }
status_t SampleIterator :: seekTo ( uint32_t sampleIndex ) { ALOGV ( "seekTo(%d)" , sampleIndex ) ; if ( sampleIndex >= mTable -> mNumSampleSizes ) { return ERROR_END_OF_STREAM ; } if ( mTable -> mSampleToChunkOffset < 0 || mTable -> mChunkOffsetOffset < 0 || mTable -> mSampleSizeOffset < 0 || mTable -> mTimeToSampleCount == 0 ) { return ERROR_MALFORMED ; } if ( mInitialized && mCurrentSampleIndex == sampleIndex ) { return OK ; } if ( ! mInitialized || sampleIndex < mFirstChunkSampleIndex ) { reset ( ) ; } if ( sampleIndex >= mStopChunkSampleIndex ) { status_t err ; if ( ( err = findChunkRange ( sampleIndex ) ) != OK ) { ALOGE ( "findChunkRange failed" ) ; return err ; } } CHECK ( sampleIndex < mStopChunkSampleIndex ) ; uint32_t chunk = ( sampleIndex - mFirstChunkSampleIndex ) / mSamplesPerChunk + mFirstChunk ; if ( ! mInitialized || chunk != mCurrentChunkIndex ) { mCurrentChunkIndex = chunk ; status_t err ; if ( ( err = getChunkOffset ( chunk , & mCurrentChunkOffset ) ) != OK ) { ALOGE ( "getChunkOffset return error" ) ; return err ; } mCurrentChunkSampleSizes . clear ( ) ; uint32_t firstChunkSampleIndex = mFirstChunkSampleIndex + mSamplesPerChunk * ( mCurrentChunkIndex - mFirstChunk ) ; for ( uint32_t i = 0 ; i < mSamplesPerChunk ; ++ i ) { size_t sampleSize ; if ( ( err = getSampleSizeDirect ( firstChunkSampleIndex + i , & sampleSize ) ) != OK ) { ALOGE ( "getSampleSizeDirect return error" ) ; return err ; } mCurrentChunkSampleSizes . push ( sampleSize ) ; } } uint32_t chunkRelativeSampleIndex = ( sampleIndex - mFirstChunkSampleIndex ) % mSamplesPerChunk ; mCurrentSampleOffset = mCurrentChunkOffset ; for ( uint32_t i = 0 ; i < chunkRelativeSampleIndex ; ++ i ) { mCurrentSampleOffset += mCurrentChunkSampleSizes [ i ] ; } mCurrentSampleSize = mCurrentChunkSampleSizes [ chunkRelativeSampleIndex ] ; if ( sampleIndex < mTTSSampleIndex ) { mTimeToSampleIndex = 0 ; mTTSSampleIndex = 0 ; mTTSSampleTime = 0 ; mTTSCount = 0 ; mTTSDuration = 0 ; } status_t err ; if ( ( err = findSampleTimeAndDuration ( sampleIndex , & mCurrentSampleTime , & mCurrentSampleDuration ) ) != OK ) { ALOGE ( "findSampleTime return error" ) ; return err ; } mCurrentSampleIndex = sampleIndex ; mInitialized = true ; return OK ; }
get_chainname_rulenum ( const struct ip6t_entry * s , const struct ip6t_entry * e , const char * hookname , const char * * chainname , const char * * comment , unsigned int * rulenum ) { const struct xt_standard_target * t = ( void * ) ip6t_get_target_c ( s ) ; if ( strcmp ( t -> target . u . kernel . target -> name , XT_ERROR_TARGET ) == 0 ) { * chainname = t -> target . data ; ( * rulenum ) = 0 ; } else if ( s == e ) { ( * rulenum ) ++ ; if ( s -> target_offset == sizeof ( struct ip6t_entry ) && strcmp ( t -> target . u . kernel . target -> name , XT_STANDARD_TARGET ) == 0 && t -> verdict < 0 && unconditional ( & s -> ipv6 ) ) { * comment = * chainname == hookname ? comments [ NF_IP6_TRACE_COMMENT_POLICY ] : comments [ NF_IP6_TRACE_COMMENT_RETURN ] ; } return 1 ; } else ( * rulenum ) ++ ; return 0 ; }
int ip6_mroute_getsockopt ( struct sock * sk , int optname , char __user * optval , int __user * optlen ) { int olr ; int val ; struct net * net = sock_net ( sk ) ; struct mr6_table * mrt ; mrt = ip6mr_get_table ( net , raw6_sk ( sk ) -> ip6mr_table ? : RT6_TABLE_DFLT ) ; if ( ! mrt ) return - ENOENT ; switch ( optname ) { case MRT6_VERSION : val = 0x0305 ; break ; #ifdef CONFIG_IPV6_PIMSM_V2 case MRT6_PIM : val = mrt -> mroute_do_pim ; break ; #endif case MRT6_ASSERT : val = mrt -> mroute_do_assert ; break ; default : return - ENOPROTOOPT ; } if ( get_user ( olr , optlen ) ) return - EFAULT ; olr = min_t ( int , olr , sizeof ( int ) ) ; if ( olr < 0 ) return - EINVAL ; if ( put_user ( olr , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & val , olr ) ) return - EFAULT ; return 0 ; }
PresShell :: Destroy ( ) { NS_ASSERTION ( ! nsContentUtils :: IsSafeToRunScript ( ) , "destroy called on presshell while scripts not blocked" ) ; #ifdef MOZ_REFLOW_PERF DumpReflows ( ) ; if ( mReflowCountMgr ) { delete mReflowCountMgr ; mReflowCountMgr = nsnull ; } #endif if ( mHaveShutDown ) return NS_OK ; mContentToScrollTo = nsnull ; if ( mPresContext ) { mPresContext -> EventStateManager ( ) -> NotifyDestroyPresContext ( mPresContext ) ; } { nsCOMPtr < nsIObserverService > os = do_GetService ( "@mozilla.org/observer-service;1" ) ; if ( os ) { os -> RemoveObserver ( this , NS_LINK_VISITED_EVENT_TOPIC ) ; os -> RemoveObserver ( this , "agent-sheet-added" ) ; os -> RemoveObserver ( this , "user-sheet-added" ) ; os -> RemoveObserver ( this , "agent-sheet-removed" ) ; os -> RemoveObserver ( this , "user-sheet-removed" ) ; #ifdef MOZ_XUL os -> RemoveObserver ( this , "chrome-flush-skin-caches" ) ; #endif #ifdef ACCESSIBILITY os -> RemoveObserver ( this , "a11y-init-or-shutdown" ) ; #endif } } if ( mPaintSuppressionTimer ) { mPaintSuppressionTimer -> Cancel ( ) ; mPaintSuppressionTimer = nsnull ; } if ( mReflowContinueTimer ) { mReflowContinueTimer -> Cancel ( ) ; mReflowContinueTimer = nsnull ; } if ( mCaret ) { mCaret -> Terminate ( ) ; mCaret = nsnull ; } if ( mSelection ) { mSelection -> DisconnectFromPresShell ( ) ; } ClearPreferenceStyleRules ( ) ; mIsDestroying = PR_TRUE ; mCurrentEventFrame = nsnull ; PRInt32 i , count = mCurrentEventFrameStack . Length ( ) ; for ( i = 0 ; i < count ; i ++ ) { mCurrentEventFrameStack [ i ] = nsnull ; } if ( mViewManager ) { mViewManager -> SetViewObserver ( nsnull ) ; mViewManager = nsnull ; } mStyleSet -> BeginShutdown ( mPresContext ) ; if ( mDocument ) { mDocument -> DeleteShell ( this ) ; } mReflowEvent . Revoke ( ) ; mResizeEvent . Revoke ( ) ; if ( mAsyncResizeTimerIsActive ) { mAsyncResizeEventTimer -> Cancel ( ) ; mAsyncResizeTimerIsActive = PR_FALSE ; } CancelAllPendingReflows ( ) ; CancelPostedReflowCallbacks ( ) ; mFrameConstructor -> WillDestroyFrameTree ( ) ; FrameManager ( ) -> Destroy ( ) ; if ( mPresContext ) { mPresContext -> PropertyTable ( ) -> DeleteAllProperties ( ) ; } NS_WARN_IF_FALSE ( ! mWeakFrames , "Weak frames alive after destroying FrameManager" ) ; while ( mWeakFrames ) { mWeakFrames -> Clear ( this ) ; } mStyleSet -> Shutdown ( mPresContext ) ; if ( mPresContext ) { mPresContext -> SetShell ( nsnull ) ; mPresContext -> SetLinkHandler ( nsnull ) ; } mHaveShutDown = PR_TRUE ; return NS_OK ; }
void CollectionsBuiltinsAssembler :: TryLookupOrderedHashTableIndex ( Node * const table , Node * const key , Node * const context , Variable * result , Label * if_entry_found , Label * if_not_found ) { Label if_key_smi ( this ) , if_key_string ( this ) , if_key_heap_number ( this ) , if_key_bigint ( this ) ; GotoIf ( TaggedIsSmi ( key ) , & if_key_smi ) ; Node * key_map = LoadMap ( key ) ; Node * key_instance_type = LoadMapInstanceType ( key_map ) ; GotoIf ( IsStringInstanceType ( key_instance_type ) , & if_key_string ) ; GotoIf ( IsHeapNumberMap ( key_map ) , & if_key_heap_number ) ; GotoIf ( IsBigIntInstanceType ( key_instance_type ) , & if_key_bigint ) ; FindOrderedHashTableEntryForOtherKey < CollectionType > ( context , table , key , result , if_entry_found , if_not_found ) ; BIND ( & if_key_smi ) ; { FindOrderedHashTableEntryForSmiKey < CollectionType > ( table , key , result , if_entry_found , if_not_found ) ; } BIND ( & if_key_string ) ; { FindOrderedHashTableEntryForStringKey < CollectionType > ( context , table , key , result , if_entry_found , if_not_found ) ; } BIND ( & if_key_heap_number ) ; { FindOrderedHashTableEntryForHeapNumberKey < CollectionType > ( context , table , key , result , if_entry_found , if_not_found ) ; } BIND ( & if_key_bigint ) ; { FindOrderedHashTableEntryForBigIntKey < CollectionType > ( context , table , key , result , if_entry_found , if_not_found ) ; } }
void test_path_dotgit__dotgit_modules_symlink ( void ) { cl_assert_equal_b ( true , git_path_isvalid ( NULL , ".gitmodules" , 0 , GIT_PATH_REJECT_DOT_GIT_HFS | GIT_PATH_REJECT_DOT_GIT_NTFS ) ) ; cl_assert_equal_b ( false , git_path_isvalid ( NULL , ".gitmodules" , S_IFLNK , GIT_PATH_REJECT_DOT_GIT_HFS ) ) ; cl_assert_equal_b ( false , git_path_isvalid ( NULL , ".gitmodules" , S_IFLNK , GIT_PATH_REJECT_DOT_GIT_NTFS ) ) ; }
void rw_t3t_handle_nci_poll_ntf ( uint8_t nci_status , uint8_t num_responses , uint8_t sensf_res_buf_size , uint8_t * p_sensf_res_buf ) { tRW_DATA evt_data ; tRW_T3T_CB * p_cb = & rw_cb . tcb . t3t ; nfc_stop_quick_timer ( & p_cb -> poll_timer ) ; if ( p_cb -> flags & RW_T3T_FL_W4_PRESENCE_CHECK_POLL_RSP ) { p_cb -> flags &= ~ RW_T3T_FL_W4_PRESENCE_CHECK_POLL_RSP ; evt_data . status = nci_status ; p_cb -> rw_state = RW_T3T_STATE_IDLE ; ( * ( rw_cb . p_cback ) ) ( RW_T3T_PRESENCE_CHECK_EVT , & evt_data ) ; } else if ( p_cb -> flags & RW_T3T_FL_W4_GET_SC_POLL_RSP ) { p_cb -> flags &= ~ RW_T3T_FL_W4_GET_SC_POLL_RSP ; rw_t3t_handle_get_sc_poll_rsp ( p_cb , nci_status , num_responses , sensf_res_buf_size , p_sensf_res_buf ) ; } else if ( p_cb -> flags & RW_T3T_FL_W4_FMT_FELICA_LITE_POLL_RSP ) { p_cb -> flags &= ~ RW_T3T_FL_W4_FMT_FELICA_LITE_POLL_RSP ; rw_t3t_handle_fmt_poll_rsp ( p_cb , nci_status , num_responses ) ; } else if ( p_cb -> flags & RW_T3T_FL_W4_SRO_FELICA_LITE_POLL_RSP ) { p_cb -> flags &= ~ RW_T3T_FL_W4_SRO_FELICA_LITE_POLL_RSP ; rw_t3t_handle_sro_poll_rsp ( p_cb , nci_status , num_responses ) ; } else if ( p_cb -> flags & RW_T3T_FL_W4_NDEF_DETECT_POLL_RSP ) { p_cb -> flags &= ~ RW_T3T_FL_W4_NDEF_DETECT_POLL_RSP ; rw_t3t_handle_ndef_detect_poll_rsp ( p_cb , nci_status , num_responses ) ; } else { evt_data . t3t_poll . status = nci_status ; if ( evt_data . t3t_poll . status == NCI_STATUS_OK ) { evt_data . t3t_poll . rc = p_cb -> cur_poll_rc ; evt_data . t3t_poll . response_num = num_responses ; evt_data . t3t_poll . response_bufsize = sensf_res_buf_size ; evt_data . t3t_poll . response_buf = p_sensf_res_buf ; } p_cb -> rw_state = RW_T3T_STATE_IDLE ; ( * ( rw_cb . p_cback ) ) ( RW_T3T_POLL_EVT , & evt_data ) ; } }
JS :: Compile ( JSContext * cx , HandleObject obj , const ReadOnlyCompileOptions & options , const jschar * chars , size_t length ) { SourceBufferHolder srcBuf ( chars , length , SourceBufferHolder :: NoOwnership ) ; RootedScript script ( cx ) ; if ( ! Compile ( cx , obj , options , srcBuf , & script ) ) return nullptr ; return script ; }
static int add_push_report_sideband_pkt ( git_push * push , git_pkt_data * data_pkt , git_buf * data_pkt_buf ) { git_pkt * pkt ; const char * line , * line_end = NULL ; size_t line_len ; int error ; int reading_from_buf = data_pkt_buf -> size > 0 ; if ( reading_from_buf ) { git_buf_put ( data_pkt_buf , data_pkt -> data , data_pkt -> len ) ; line = data_pkt_buf -> ptr ; line_len = data_pkt_buf -> size ; } else { line = data_pkt -> data ; line_len = data_pkt -> len ; } while ( line_len > 0 ) { error = git_pkt_parse_line ( & pkt , line , & line_end , line_len ) ; if ( error == GIT_EBUFS ) { if ( ! reading_from_buf ) git_buf_put ( data_pkt_buf , line , line_len ) ; error = 0 ; goto done ; } else if ( error < 0 ) goto done ; line_len -= ( line_end - line ) ; line = line_end ; if ( pkt == NULL ) continue ; error = add_push_report_pkt ( push , pkt ) ; git_pkt_free ( pkt ) ; if ( error < 0 && error != GIT_ITEROVER ) goto done ; } error = 0 ; done : if ( reading_from_buf ) git_buf_consume ( data_pkt_buf , line_end ) ; return error ; }
MaybeHandle < Code > CompileJSToWasmWrapper ( Isolate * isolate , const wasm :: NativeModule * native_module , wasm :: FunctionSig * sig , bool is_import , wasm :: UseTrapHandler use_trap_handler ) { TRACE_EVENT0 ( TRACE_DISABLED_BY_DEFAULT ( "v8.wasm" ) , "CompileJSToWasmWrapper" ) ; const wasm :: WasmModule * module = native_module -> module ( ) ; Zone zone ( isolate -> allocator ( ) , ZONE_NAME ) ; Graph graph ( & zone ) ; CommonOperatorBuilder common ( & zone ) ; MachineOperatorBuilder machine ( & zone , MachineType :: PointerRepresentation ( ) , InstructionSelector :: SupportedMachineOperatorFlags ( ) , InstructionSelector :: AlignmentRequirements ( ) ) ; JSGraph jsgraph ( isolate , & graph , & common , nullptr , nullptr , & machine ) ; Node * control = nullptr ; Node * effect = nullptr ; wasm :: ModuleEnv env ( module , use_trap_handler , wasm :: kRuntimeExceptionSupport ) ; WasmWrapperGraphBuilder builder ( & zone , & env , & jsgraph , sig , nullptr , StubCallMode :: kCallOnHeapBuiltin ) ; builder . set_control_ptr ( & control ) ; builder . set_effect_ptr ( & effect ) ; builder . BuildJSToWasmWrapper ( is_import ) ; #ifdef DEBUG EmbeddedVector < char , 32 > func_name ; static unsigned id = 0 ; func_name . Truncate ( SNPrintF ( func_name , "js-to-wasm#%d" , id ++ ) ) ; #else Vector < const char > func_name = CStrVector ( "js-to-wasm" ) ; #endif OptimizedCompilationInfo info ( func_name , & zone , Code :: JS_TO_WASM_FUNCTION ) ; if ( info . trace_turbo_graph_enabled ( ) ) { StdoutStream { } < < "-- Graph after change lowering -- " < < std :: endl < < AsRPO ( graph ) ; } int params = static_cast < int > ( sig -> parameter_count ( ) ) ; CallDescriptor * incoming = Linkage :: GetJSCallDescriptor ( & zone , false , params + 1 , CallDescriptor :: kNoFlags ) ; MaybeHandle < Code > maybe_code = Pipeline :: GenerateCodeForTesting ( & info , isolate , incoming , & graph , WasmAssemblerOptions ( ) ) ; Handle < Code > code ; if ( ! maybe_code . ToHandle ( & code ) ) { return maybe_code ; } #ifdef ENABLE_DISASSEMBLER if ( FLAG_print_opt_code ) { CodeTracer :: Scope tracing_scope ( isolate -> GetCodeTracer ( ) ) ; OFStream os ( tracing_scope . file ( ) ) ; code -> Disassemble ( func_name . start ( ) , os ) ; } #endif if ( must_record_function_compilation ( isolate ) ) { RecordFunctionCompilation ( CodeEventListener :: STUB_TAG , isolate , code , "%.*s" , func_name . length ( ) , func_name . start ( ) ) ; } return code ; }
static char * allocFromUTF32 ( const char32_t * in , size_t len ) { if ( len == 0 ) { return getEmptyString ( ) ; } const ssize_t bytes = utf32_to_utf8_length ( in , len ) ; if ( bytes < 0 ) { return getEmptyString ( ) ; } SharedBuffer * buf = SharedBuffer :: alloc ( bytes + 1 ) ; ALOG_ASSERT ( buf , "Unable to allocate shared buffer" ) ; if ( ! buf ) { return getEmptyString ( ) ; } char * str = ( char * ) buf -> data ( ) ; utf32_to_utf8 ( in , len , str ) ; return str ; }
static void process_service_search_attr_rsp ( tCONN_CB * p_ccb , uint8_t * p_reply ) { uint8_t * p , * p_start , * p_end , * p_param_len ; uint8_t type ; uint32_t seq_len ; uint16_t param_len , lists_byte_count = 0 ; bool cont_request_needed = false ; #if (SDP_DEBUG_RAW == TRUE) SDP_TRACE_WARNING ( "process_service_search_attr_rsp" ) ; #endif if ( p_reply ) { #if (SDP_DEBUG_RAW == TRUE) SDP_TRACE_WARNING ( "ID & len: 0x%02x-%02x-%02x-%02x" , p_reply [ 0 ] , p_reply [ 1 ] , p_reply [ 2 ] , p_reply [ 3 ] ) ; #endif p_reply += 4 ; BE_STREAM_TO_UINT16 ( lists_byte_count , p_reply ) ; #if (SDP_DEBUG_RAW == TRUE) SDP_TRACE_WARNING ( "lists_byte_count:%d" , lists_byte_count ) ; #endif if ( ( p_ccb -> list_len + lists_byte_count ) > SDP_MAX_LIST_BYTE_COUNT ) { sdp_disconnect ( p_ccb , SDP_INVALID_PDU_SIZE ) ; return ; } #if (SDP_DEBUG_RAW == TRUE) SDP_TRACE_WARNING ( "list_len: %d, list_byte_count: %d" , p_ccb -> list_len , lists_byte_count ) ; #endif if ( p_ccb -> rsp_list == NULL ) p_ccb -> rsp_list = ( uint8_t * ) osi_malloc ( SDP_MAX_LIST_BYTE_COUNT ) ; memcpy ( & p_ccb -> rsp_list [ p_ccb -> list_len ] , p_reply , lists_byte_count ) ; p_ccb -> list_len += lists_byte_count ; p_reply += lists_byte_count ; #if (SDP_DEBUG_RAW == TRUE) SDP_TRACE_WARNING ( "list_len: %d(search_attr_rsp)" , p_ccb -> list_len ) ; SDP_TRACE_WARNING ( "*p_reply:%d(%d)" , * p_reply , SDP_MAX_CONTINUATION_LEN ) ; #endif if ( * p_reply ) { if ( * p_reply > SDP_MAX_CONTINUATION_LEN ) { sdp_disconnect ( p_ccb , SDP_INVALID_CONT_STATE ) ; return ; } cont_request_needed = true ; } } #if (SDP_DEBUG_RAW == TRUE) SDP_TRACE_WARNING ( "cont_request_needed:%d" , cont_request_needed ) ; #endif if ( ( cont_request_needed ) || ( ! p_reply ) ) { BT_HDR * p_msg = ( BT_HDR * ) osi_malloc ( SDP_DATA_BUF_SIZE ) ; uint8_t * p ; p_msg -> offset = L2CAP_MIN_OFFSET ; p = p_start = ( uint8_t * ) ( p_msg + 1 ) + L2CAP_MIN_OFFSET ; UINT8_TO_BE_STREAM ( p , SDP_PDU_SERVICE_SEARCH_ATTR_REQ ) ; UINT16_TO_BE_STREAM ( p , p_ccb -> transaction_id ) ; p_ccb -> transaction_id ++ ; p_param_len = p ; p += 2 ; #if (SDP_BROWSE_PLUS == TRUE) p = sdpu_build_uuid_seq ( p , 1 , & p_ccb -> p_db -> uuid_filters [ p_ccb -> cur_uuid_idx ] ) ; #else p = sdpu_build_uuid_seq ( p , p_ccb -> p_db -> num_uuid_filters , p_ccb -> p_db -> uuid_filters ) ; #endif UINT16_TO_BE_STREAM ( p , sdp_cb . max_attr_list_size ) ; if ( p_ccb -> p_db -> num_attr_filters ) p = sdpu_build_attrib_seq ( p , p_ccb -> p_db -> attr_filters , p_ccb -> p_db -> num_attr_filters ) ; else p = sdpu_build_attrib_seq ( p , NULL , 0 ) ; if ( p_reply ) { memcpy ( p , p_reply , * p_reply + 1 ) ; p += * p_reply + 1 ; } else UINT8_TO_BE_STREAM ( p , 0 ) ; param_len = p - p_param_len - 2 ; UINT16_TO_BE_STREAM ( p_param_len , param_len ) ; p_msg -> len = p - p_start ; L2CA_DataWrite ( p_ccb -> connection_id , p_msg ) ; alarm_set_on_mloop ( p_ccb -> sdp_conn_timer , SDP_INACT_TIMEOUT_MS , sdp_conn_timer_timeout , p_ccb ) ; return ; } #if (SDP_RAW_DATA_INCLUDED == TRUE) SDP_TRACE_WARNING ( "process_service_search_attr_rsp" ) ; sdp_copy_raw_data ( p_ccb , true ) ; #endif p = & p_ccb -> rsp_list [ 0 ] ; type = * p ++ ; if ( ( type > > 3 ) != DATA_ELE_SEQ_DESC_TYPE ) { SDP_TRACE_WARNING ( "SDP - Wrong type: 0x%02x in attr_rsp" , type ) ; return ; } p = sdpu_get_len_from_type ( p , type , & seq_len ) ; p_end = & p_ccb -> rsp_list [ p_ccb -> list_len ] ; if ( ( p + seq_len ) != p_end ) { sdp_disconnect ( p_ccb , SDP_INVALID_CONT_STATE ) ; return ; } while ( p < p_end ) { p = save_attr_seq ( p_ccb , p , & p_ccb -> rsp_list [ p_ccb -> list_len ] ) ; if ( ! p ) { sdp_disconnect ( p_ccb , SDP_DB_FULL ) ; return ; } } sdp_disconnect ( p_ccb , SDP_SUCCESS ) ; }
TF_BUILTIN ( AsyncGeneratorYieldResolveClosure , AsyncGeneratorBuiltinsAssembler ) { Node * const context = Parameter ( Descriptor :: kContext ) ; Node * const value = Parameter ( Descriptor :: kValue ) ; Node * const generator = LoadContextElement ( context , AwaitContext :: kGeneratorSlot ) ; SetGeneratorNotAwaiting ( generator ) ; CallBuiltin ( Builtins :: kAsyncGeneratorResolve , context , generator , value , FalseConstant ( ) ) ; TailCallBuiltin ( Builtins :: kAsyncGeneratorResumeNext , context , generator ) ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteUnpackParams * data = reinterpret_cast < TfLiteUnpackParams * > ( node -> builtin_data ) ; TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , data -> num ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; TF_LITE_ENSURE ( context , NumElements ( input ) > 0 ) ; int axis = data -> axis ; if ( axis < 0 ) { axis += NumDimensions ( input ) ; } TF_LITE_ENSURE ( context , 0 <= axis && axis < NumDimensions ( input ) ) ; if ( input -> type != kTfLiteInt32 && input -> type != kTfLiteFloat32 && input -> type != kTfLiteUInt8 && input -> type != kTfLiteInt8 && input -> type != kTfLiteInt16 && input -> type != kTfLiteBool ) { context -> ReportError ( context , "Type '%s' is not supported by unpack." , TfLiteTypeGetName ( input -> type ) ) ; return kTfLiteError ; } const TfLiteIntArray * input_shape = input -> dims ; TfLiteIntArray * output_shape = TfLiteIntArrayCreate ( NumDimensions ( input ) - 1 ) ; int o = 0 ; for ( int index = 0 ; index < NumDimensions ( input ) ; ++ index ) { if ( index != axis ) { output_shape -> data [ o ++ ] = input_shape -> data [ index ] ; } } TF_LITE_ENSURE_EQ ( context , data -> num , input_shape -> data [ axis ] ) ; for ( int i = 0 ; i < data -> num ; ++ i ) { TfLiteIntArray * copied_output_shape = TfLiteIntArrayCopy ( output_shape ) ; TfLiteTensor * output = GetOutput ( context , node , i ) ; TF_LITE_ENSURE_TYPES_EQ ( context , output -> type , input -> type ) ; TF_LITE_ENSURE_EQ ( context , input -> params . zero_point , output -> params . zero_point ) ; TF_LITE_ENSURE_EQ ( context , input -> params . scale , output -> params . scale ) ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , output , copied_output_shape ) ) ; } TfLiteIntArrayFree ( output_shape ) ; return kTfLiteOk ; }
Handle < SmallOrderedHashSet > Factory :: NewSmallOrderedHashSet ( int capacity , PretenureFlag pretenure ) { DCHECK_LE ( 0 , capacity ) ; CHECK_LE ( capacity , SmallOrderedHashSet :: kMaxCapacity ) ; DCHECK_EQ ( 0 , capacity % SmallOrderedHashSet :: kLoadFactor ) ; int size = SmallOrderedHashSet :: SizeFor ( capacity ) ; Map * map = * small_ordered_hash_set_map ( ) ; HeapObject * result = AllocateRawWithImmortalMap ( size , pretenure , map ) ; Handle < SmallOrderedHashSet > table ( SmallOrderedHashSet :: cast ( result ) , isolate ( ) ) ; table -> Initialize ( isolate ( ) , capacity ) ; return table ; }
TfLiteStatus PreluPrepare ( TfLiteContext * context , TfLiteNode * node ) { TFLITE_DCHECK ( node -> user_data != nullptr ) ; PreluParams * params = static_cast < PreluParams * > ( node -> user_data ) ; const TfLiteTensor * input = GetInput ( context , node , 0 ) ; const TfLiteTensor * alpha = GetInput ( context , node , 1 ) ; TfLiteTensor * output = GetOutput ( context , node , 0 ) ; return CalculatePreluParams ( input , alpha , output , params ) ; }
ICInfo :: ICInfo ( ) : function_name ( nullptr ) , script_offset ( 0 ) , script_name ( nullptr ) , line_num ( - 1 ) , is_constructor ( false ) , is_optimized ( false ) , map ( nullptr ) , is_dictionary_map ( 0 ) , number_of_own_descriptors ( 0 ) { }
FileInfo :: Cleanup ( ) { if ( quota :: QuotaManager :: IsShuttingDown ( ) || mFileManager -> Invalidated ( ) ) { return ; } nsRefPtr < IndexedDatabaseManager > mgr = IndexedDatabaseManager :: Get ( ) ; NS_ASSERTION ( mgr , "Shouldn't be null!" ) ; if ( NS_FAILED ( mgr -> AsyncDeleteFile ( mFileManager , Id ( ) ) ) ) { NS_WARNING ( "Failed to delete file asynchronously!" ) ; } }
void Generate_JSBuiltinsConstructStubHelper ( MacroAssembler * masm ) { Label post_instantiation_deopt_entry ; { FrameAndConstantPoolScope scope ( masm , StackFrame :: CONSTRUCT ) ; __ SmiTag ( r2 ) ; __ Push ( cp , r2 ) ; __ SmiUntag ( r2 ) ; __ PushRoot ( Heap :: kTheHoleValueRootIndex ) ; __ la ( r6 , MemOperand ( fp , StandardFrameConstants :: kCallerSPOffset ) ) ; Label loop , no_args ; __ beq ( & no_args ) ; __ ShiftLeftP ( ip , r2 , Operand ( kPointerSizeLog2 ) ) ; __ SubP ( sp , sp , ip ) ; __ LoadRR ( r1 , r2 ) ; __ bind ( & loop ) ; __ lay ( ip , MemOperand ( ip , - kPointerSize ) ) ; __ LoadP ( r0 , MemOperand ( ip , r6 ) ) ; __ StoreP ( r0 , MemOperand ( ip , sp ) ) ; __ BranchOnCount ( r1 , & loop ) ; __ bind ( & no_args ) ; ParameterCount actual ( r2 ) ; __ InvokeFunction ( r3 , r5 , actual , CALL_FUNCTION ) ; __ LoadP ( cp , MemOperand ( fp , ConstructFrameConstants :: kContextOffset ) ) ; __ LoadP ( r3 , MemOperand ( fp , ConstructFrameConstants :: kLengthOffset ) ) ; } STATIC_ASSERT ( kSmiTagSize == 1 && kSmiTag == 0 ) ; __ SmiToPtrArrayOffset ( r3 , r3 ) ; __ AddP ( sp , sp , r3 ) ; __ AddP ( sp , sp , Operand ( kPointerSize ) ) ; __ Ret ( ) ; }
DrawTargetCairo :: CreateSimilarDrawTarget ( const IntSize & aSize , SurfaceFormat aFormat ) const { cairo_surface_t * similar = cairo_surface_create_similar ( mSurface , GfxFormatToCairoContent ( aFormat ) , aSize . width , aSize . height ) ; if ( ! cairo_surface_status ( similar ) ) { RefPtr < DrawTargetCairo > target = new DrawTargetCairo ( ) ; target -> InitAlreadyReferenced ( similar , aSize ) ; return target . forget ( ) ; } gfxCriticalError ( ) < < "Failed to create similar cairo surface! Size: " < < aSize < < " Status: " < < cairo_surface_status ( similar ) ; return nullptr ; }
static CK_RV fill_ec_key_from_pubkey ( EC_KEY * ec_key , const CK_BYTE * data , CK_ULONG data_len , CK_BBOOL allow_raw ) { CK_BYTE * ecpoint = NULL ; CK_ULONG ecpoint_len , privlen ; CK_BBOOL allocated = FALSE ; CK_RV rc ; privlen = ( EC_GROUP_order_bits ( EC_KEY_get0_group ( ec_key ) ) + 7 ) / 8 ; rc = ec_point_from_public_data ( data , data_len , privlen , allow_raw , & allocated , & ecpoint , & ecpoint_len ) ; if ( rc != CKR_OK ) { TRACE_DEVEL ( "ec_point_from_public_data failed\n" ) ; goto out ; } if ( ! EC_KEY_oct2key ( ec_key , ecpoint , ecpoint_len , NULL ) ) { TRACE_ERROR ( "EC_KEY_oct2key failed\n" ) ; rc = CKR_FUNCTION_FAILED ; goto out ; } out : if ( allocated && ecpoint != NULL ) free ( ecpoint ) ; return rc ; }
fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; if ( cc % ( bps * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpAcc" , "%s" , "cc%(bps*stride))!=0" ) ; return 0 ; } if ( ! tmp ) return 0 ; while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { #if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; #else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; #endif } } _TIFFfree ( tmp ) ; return 1 ; }
TfLiteStatus SigmoidPrepare ( TfLiteContext * context , TfLiteNode * node ) { OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * input = GetInput ( context , node , 0 ) ; TfLiteTensor * output = GetOutput ( context , node , 0 ) ; TF_LITE_ENSURE_TYPES_EQ ( context , input -> type , output -> type ) ; if ( kernel_type == kFixedPointOptimized ) { if ( input -> type == kTfLiteUInt8 || input -> type == kTfLiteInt8 ) { if ( input -> type == kTfLiteUInt8 ) { TF_LITE_ENSURE_EQ ( context , output -> params . zero_point , std :: numeric_limits < uint8_t > :: min ( ) ) ; } if ( input -> type == kTfLiteInt8 ) { TF_LITE_ENSURE_EQ ( context , output -> params . zero_point , std :: numeric_limits < int8_t > :: min ( ) ) ; } TF_LITE_ENSURE ( context , output -> params . scale == 1. / 256 ) ; static constexpr int kInputIntegerBits = 4 ; const double input_real_multiplier = input -> params . scale * static_cast < double > ( 1 < < ( 15 - kInputIntegerBits ) ) ; const double q = std :: frexp ( input_real_multiplier , & data -> input_left_shift ) ; auto q_fixed = static_cast < int32_t > ( TfLiteRound ( q * ( 1ll < < 15 ) ) ) ; data -> input_multiplier = static_cast < int16_t > ( q_fixed ) ; int16_t input_range_radius = CalculateInputRadius ( kInputIntegerBits , data -> input_left_shift , 15 ) ; data -> input_range_radius = input_range_radius ; } } if ( kernel_type == kGenericOptimized || kernel_type == kReference ) { if ( input -> type == kTfLiteUInt8 ) { TF_LITE_ENSURE ( context , output -> params . scale == 1. / 256 ) ; PopulateLookupTable < uint8_t > ( data , input , output , [ ] ( float value ) { return 1.0f / ( 1.0f + std :: exp ( - value ) ) ; } ) ; } else if ( input -> type == kTfLiteInt8 ) { TF_LITE_ENSURE ( context , output -> params . scale == 1. / 256 ) ; PopulateLookupTable < int8_t > ( data , input , output , [ ] ( float value ) { return 1.0f / ( 1.0f + std :: exp ( - value ) ) ; } ) ; } else if ( input -> type == kTfLiteInt16 ) { TF_LITE_ENSURE ( context , output -> params . scale == 1. / 32768 ) ; TF_LITE_ENSURE ( context , output -> params . zero_point == 0 ) ; } } if ( input -> type == kTfLiteInt16 ) { static constexpr int kInputIntegerBits = 3 ; static constexpr int kOutputFractionalBits = 15 ; TF_LITE_ENSURE_EQ ( context , input -> params . zero_point , 0 ) ; TF_LITE_ENSURE_EQ ( context , output -> params . zero_point , 0 ) ; int input_scale_log2_rounded ; bool param_scale_pot = CheckedLog2 ( input -> params . scale , & input_scale_log2_rounded ) ; data -> input_left_shift = ( 15 - kInputIntegerBits ) + input_scale_log2_rounded ; param_scale_pot &= ( data -> input_left_shift == 0 ) ; if ( ! param_scale_pot ) { data -> input_multiplier = static_cast < int32_t > ( input -> params . scale * 4096 ) ; } int output_scale_log2_rounded ; TF_LITE_ENSURE ( context , CheckedLog2 ( output -> params . scale , & output_scale_log2_rounded ) ) ; TF_LITE_ENSURE_EQ ( context , output_scale_log2_rounded , - kOutputFractionalBits ) ; } return context -> ResizeTensor ( context , output , TfLiteIntArrayCopy ( input -> dims ) ) ; }
void Finalize ( Isolate * isolate ) { if ( HasDictionaryProperties ( ) ) { properties_dictionary_template_ -> SetNextEnumerationIndex ( next_enumeration_index_ ) ; computed_properties_ = FixedArray :: ShrinkOrEmpty ( isolate , computed_properties_ , current_computed_index_ ) ; } else { DCHECK ( descriptor_array_template_ -> IsSortedNoDuplicates ( ) ) ; } }
Response V8DebuggerAgentImpl :: continueToLocation ( std :: unique_ptr < protocol :: Debugger :: Location > location , Maybe < String16 > targetCallFrames ) { if ( ! enabled ( ) ) return Response :: Error ( kDebuggerNotEnabled ) ; if ( ! isPaused ( ) ) return Response :: Error ( kDebuggerNotPaused ) ; ScriptsMap :: iterator it = m_scripts . find ( location -> getScriptId ( ) ) ; if ( it == m_scripts . end ( ) ) { return Response :: Error ( "Cannot continue to specified location" ) ; } V8DebuggerScript * script = it -> second . get ( ) ; int contextId = script -> executionContextId ( ) ; InspectedContext * inspected = m_inspector -> getContext ( contextId ) ; if ( ! inspected ) return Response :: Error ( "Cannot continue to specified location" ) ; v8 :: Context :: Scope contextScope ( inspected -> context ( ) ) ; return m_debugger -> continueToLocation ( m_session -> contextGroupId ( ) , script , std :: move ( location ) , targetCallFrames . fromMaybe ( protocol :: Debugger :: ContinueToLocation :: TargetCallFramesEnum :: Any ) ) ; }
bool XPCArrayHomogenizer :: GetTypeForArray ( JSContext * cx , HandleObject array , uint32_t length , nsXPTType * resultType , nsID * resultID ) { Type state = tUnk ; Type type ; RootedValue val ( cx ) ; RootedObject jsobj ( cx ) ; for ( uint32_t i = 0 ; i < length ; i ++ ) { if ( ! JS_GetElement ( cx , array , i , & val ) ) { return false ; } if ( val . isInt32 ( ) ) { type = tInt ; } else if ( val . isDouble ( ) ) { type = tDbl ; } else if ( val . isBoolean ( ) ) { type = tBool ; } else if ( val . isUndefined ( ) || val . isSymbol ( ) ) { state = tVar ; break ; } else if ( val . isNull ( ) ) { type = tNull ; } else if ( val . isString ( ) ) { type = tStr ; } else { MOZ_ASSERT ( val . isObject ( ) , "invalid type of jsval!" ) ; jsobj = & val . toObject ( ) ; bool isArray ; if ( ! JS :: IsArrayObject ( cx , jsobj , & isArray ) ) { return false ; } if ( isArray ) { type = tArr ; } else if ( xpc :: JSValue2ID ( cx , val ) ) { type = tID ; } else { type = tISup ; } } MOZ_ASSERT ( state != tErr , "bad state table!" ) ; MOZ_ASSERT ( type != tErr , "bad type!" ) ; MOZ_ASSERT ( type != tVar , "bad type!" ) ; MOZ_ASSERT ( type != tUnk , "bad type!" ) ; state = StateTable [ state ] [ type ] ; MOZ_ASSERT ( state != tErr , "bad state table!" ) ; MOZ_ASSERT ( state != tUnk , "bad state table!" ) ; if ( state == tVar ) { break ; } } switch ( state ) { case tInt : * resultType = nsXPTType :: MkArrayType ( nsXPTType :: Idx :: INT32 ) ; break ; case tDbl : * resultType = nsXPTType :: MkArrayType ( nsXPTType :: Idx :: DOUBLE ) ; break ; case tBool : * resultType = nsXPTType :: MkArrayType ( nsXPTType :: Idx :: BOOL ) ; break ; case tStr : * resultType = nsXPTType :: MkArrayType ( nsXPTType :: Idx :: PWSTRING ) ; break ; case tID : * resultType = nsXPTType :: MkArrayType ( nsXPTType :: Idx :: NSIDPTR ) ; break ; case tISup : * resultType = nsXPTType :: MkArrayType ( nsXPTType :: Idx :: INTERFACE_IS_TYPE ) ; * resultID = NS_GET_IID ( nsISupports ) ; break ; case tNull : case tVar : * resultType = nsXPTType :: MkArrayType ( nsXPTType :: Idx :: INTERFACE_IS_TYPE ) ; * resultID = NS_GET_IID ( nsIVariant ) ; break ; case tArr : case tUnk : case tErr : default : NS_ERROR ( "bad state" ) ; return false ; } return true ; }
uint32_t ProcessParameter ( ValueType type , uint32_t input_idx ) { const int num_lowered_params = 1 + needs_reg_pair ( type ) ; LiftoffRegister reg = LiftoffRegister :: from_code ( kGpReg , 0 ) ; RegClass rc = num_lowered_params == 1 ? reg_class_for ( type ) : kGpReg ; LiftoffRegList pinned ; for ( int pair_idx = 0 ; pair_idx < num_lowered_params ; ++ pair_idx ) { compiler :: LinkageLocation param_loc = descriptor_ -> GetInputLocation ( input_idx + pair_idx ) ; LiftoffRegister in_reg = LiftoffRegister :: from_code ( kGpReg , 0 ) ; if ( param_loc . IsRegister ( ) ) { DCHECK ( ! param_loc . IsAnyRegister ( ) ) ; int reg_code = param_loc . AsRegister ( ) ; RegList cache_regs = rc == kGpReg ? kLiftoffAssemblerGpCacheRegs : kLiftoffAssemblerFpCacheRegs ; if ( cache_regs & ( 1 < < reg_code ) ) { in_reg = LiftoffRegister :: from_code ( rc , reg_code ) ; } else { LiftoffRegister in_reg = __ GetUnusedRegister ( rc , pinned ) ; if ( rc == kGpReg ) { __ Move ( in_reg . gp ( ) , Register :: from_code ( reg_code ) , type ) ; } else { __ Move ( in_reg . fp ( ) , DoubleRegister :: from_code ( reg_code ) , type ) ; } } } else if ( param_loc . IsCallerFrameSlot ( ) ) { in_reg = __ GetUnusedRegister ( rc , pinned ) ; ValueType lowered_type = num_lowered_params == 1 ? type : kWasmI32 ; __ LoadCallerFrameSlot ( in_reg , - param_loc . AsCallerFrameSlot ( ) , lowered_type ) ; } reg = pair_idx == 0 ? in_reg : LiftoffRegister :: ForPair ( reg . gp ( ) , in_reg . gp ( ) ) ; pinned . set ( reg ) ; } __ PushRegister ( type , reg ) ; return num_lowered_params ; }
void CopyVopMB ( Vop * curr , uint8 * prevFrame , int mbnum , int width_Y , int height ) { int width_C = width_Y > > 1 ; int row = MB_SIZE ; uint8 * y1 , * y2 , * u1 , * u2 , * v1 , * v2 ; int xpos , ypos , MB_in_width ; int32 lumstart , chrstart , size ; MB_in_width = ( width_Y + 15 ) > > 4 ; ypos = PV_GET_ROW ( mbnum , MB_in_width ) ; xpos = mbnum - ypos * MB_in_width ; lumstart = ( ypos < < 4 ) * ( int32 ) width_Y + ( xpos < < 4 ) ; chrstart = ( ypos < < 3 ) * ( int32 ) width_C + ( xpos < < 3 ) ; size = ( int32 ) height * width_Y ; y1 = curr -> yChan + lumstart ; u1 = curr -> uChan + chrstart ; v1 = curr -> vChan + chrstart ; y2 = prevFrame + lumstart ; u2 = prevFrame + size + chrstart ; v2 = prevFrame + size + ( size > > 2 ) + chrstart ; while ( row ) { oscl_memcpy ( y1 , y2 , MB_SIZE ) ; y1 += width_Y ; y2 += width_Y ; oscl_memcpy ( y1 , y2 , MB_SIZE ) ; y1 += width_Y ; y2 += width_Y ; oscl_memcpy ( y1 , y2 , MB_SIZE ) ; y1 += width_Y ; y2 += width_Y ; oscl_memcpy ( y1 , y2 , MB_SIZE ) ; y1 += width_Y ; y2 += width_Y ; oscl_memcpy ( u1 , u2 , B_SIZE ) ; u1 += width_C ; u2 += width_C ; oscl_memcpy ( u1 , u2 , B_SIZE ) ; u1 += width_C ; u2 += width_C ; oscl_memcpy ( v1 , v2 , B_SIZE ) ; v1 += width_C ; v2 += width_C ; oscl_memcpy ( v1 , v2 , B_SIZE ) ; v1 += width_C ; v2 += width_C ; row -= 4 ; } return ; }
void CallOnceImpl ( OnceType * once , std :: function < void ( ) > init_func ) { AtomicWord state = Acquire_Load ( once ) ; if ( state == ONCE_STATE_DONE ) { return ; } state = Acquire_CompareAndSwap ( once , ONCE_STATE_UNINITIALIZED , ONCE_STATE_EXECUTING_FUNCTION ) ; if ( state == ONCE_STATE_UNINITIALIZED ) { init_func ( ) ; Release_Store ( once , ONCE_STATE_DONE ) ; } else { while ( state == ONCE_STATE_EXECUTING_FUNCTION ) { #ifdef _WIN32 :: Sleep ( 0 ) ; #else sched_yield ( ) ; #endif state = Acquire_Load ( once ) ; } } }
cib_connect ( gboolean full ) { int rc = pcmk_ok ; static gboolean need_pass = TRUE ; CRM_CHECK ( cib != NULL , return - EINVAL ) ; if ( getenv ( "CIB_passwd" ) != NULL ) { need_pass = FALSE ; } if ( watch_fencing && st == NULL ) { st = stonith_api_new ( ) ; } if ( watch_fencing && st -> state == stonith_disconnected ) { crm_trace ( "Connecting to stonith" ) ; rc = st -> cmds -> connect ( st , crm_system_name , NULL ) ; if ( rc == pcmk_ok ) { crm_trace ( "Setting up stonith callbacks" ) ; st -> cmds -> register_notification ( st , T_STONITH_NOTIFY_FENCE , mon_st_callback ) ; } } if ( cib -> state != cib_connected_query && cib -> state != cib_connected_command ) { crm_trace ( "Connecting to the CIB" ) ; if ( as_console && need_pass && cib -> variant == cib_remote ) { need_pass = FALSE ; print_as ( "Password:" ) ; } rc = cib -> cmds -> signon ( cib , crm_system_name , cib_query ) ; if ( rc != pcmk_ok ) { return rc ; } current_cib = get_cib_copy ( cib ) ; mon_refresh_display ( NULL ) ; if ( full ) { if ( rc == pcmk_ok ) { rc = cib -> cmds -> set_connection_dnotify ( cib , mon_cib_connection_destroy ) ; if ( rc == - EPROTONOSUPPORT ) { print_as ( "Notification setup failed, won't be able to reconnect after failure" ) ; if ( as_console ) { sleep ( 2 ) ; } rc = pcmk_ok ; } } if ( rc == pcmk_ok ) { cib -> cmds -> del_notify_callback ( cib , T_CIB_DIFF_NOTIFY , crm_diff_update ) ; rc = cib -> cmds -> add_notify_callback ( cib , T_CIB_DIFF_NOTIFY , crm_diff_update ) ; } if ( rc != pcmk_ok ) { print_as ( "Notification setup failed, could not monitor CIB actions" ) ; if ( as_console ) { sleep ( 2 ) ; } clean_up ( - rc ) ; } } } return rc ; }
WORD32 ih264d_end_of_pic ( dec_struct_t * ps_dec , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num ) { dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; WORD32 ret ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } } H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ret = ih264d_end_of_pic_processing ( ps_dec ) ; if ( ret != OK ) return ret ; ps_dec -> u2_total_mbs_coded = 0 ; { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ret = ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; if ( ret != OK ) return ret ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } } H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return OK ; }
static int on_header_cb ( nghttp2_session * ngh2 , const nghttp2_frame * frame , const uint8_t * name , size_t namelen , const uint8_t * value , size_t valuelen , uint8_t flags , void * userp ) { h2_session * session = ( h2_session * ) userp ; h2_stream * stream ; apr_status_t status ; ( void ) flags ; stream = get_stream ( session , frame -> hd . stream_id ) ; if ( ! stream ) { ap_log_cerror ( APLOG_MARK , APLOG_ERR , 0 , session -> c , APLOGNO ( 02 920 ) "h2_session:  stream(%ld-%d): on_header unknown stream" , session -> id , ( int ) frame -> hd . stream_id ) ; return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ; } status = h2_stream_add_header ( stream , ( const char * ) name , namelen , ( const char * ) value , valuelen ) ; if ( status != APR_SUCCESS && ! h2_stream_is_ready ( stream ) ) { return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ; } return 0 ; }
void BytecodeGenerator :: VisitNaryOperation ( NaryOperation * expr ) { switch ( expr -> op ( ) ) { case Token :: COMMA : VisitNaryCommaExpression ( expr ) ; break ; case Token :: OR : VisitNaryLogicalOrExpression ( expr ) ; break ; case Token :: AND : VisitNaryLogicalAndExpression ( expr ) ; break ; default : VisitNaryArithmeticExpression ( expr ) ; break ; } }
bool IsRename ( Node * node ) { switch ( node -> opcode ( ) ) { case IrOpcode :: kCheckHeapObject : case IrOpcode :: kFinishRegion : case IrOpcode :: kTypeGuard : return true ; default : return false ; } }
auto SourceListener :: UpdateDevice ( MediaTrack * aTrack , bool aOn ) -> RefPtr < DeviceOperationPromise > { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; RefPtr < SourceListener > self = this ; DeviceState & state = GetDeviceStateFor ( aTrack ) ; return MediaManager :: Dispatch < DeviceOperationPromise > ( __func__ , [ self , device = state . mDevice , aOn ] ( MozPromiseHolder < DeviceOperationPromise > & h ) { LOG ( "Turning %s device (%s)" , aOn ? "on" : "off" , NS_ConvertUTF16toUTF8 ( device -> mName ) . get ( ) ) ; h . Resolve ( aOn ? device -> Start ( ) : device -> Stop ( ) , __func__ ) ; } ) -> Then ( GetMainThreadSerialEventTarget ( ) , __func__ , [ self , this , & state , track = RefPtr < MediaTrack > ( aTrack ) , aOn ] ( nsresult aResult ) { if ( state . mStopped ) { return DeviceOperationPromise :: CreateAndResolve ( aResult , __func__ ) ; } LOG ( "SourceListener %p turning %s %s input device for track %p %s" , this , aOn ? "on" : "off" , & state == mAudioDeviceState . get ( ) ? "audio" : "video" , track . get ( ) , NS_SUCCEEDED ( aResult ) ? "succeeded" : "failed" ) ; if ( NS_FAILED ( aResult ) && aResult != NS_ERROR_ABORT ) { if ( aOn ) { StopTrack ( track ) ; } else { MOZ_ASSERT_UNREACHABLE ( "The device should be stoppable" ) ; } } return DeviceOperationPromise :: CreateAndResolve ( aResult , __func__ ) ; } , [ ] ( ) { MOZ_ASSERT_UNREACHABLE ( "Unexpected and unhandled reject" ) ; return DeviceOperationPromise :: CreateAndReject ( false , __func__ ) ; } ) ; }
Handle < Object > LoadHandler :: LoadFromPrototype ( Isolate * isolate , Handle < Map > receiver_map , Handle < JSReceiver > holder , Handle < Smi > smi_handler , MaybeObjectHandle maybe_data1 , MaybeObjectHandle maybe_data2 ) { MaybeObjectHandle data1 ; if ( maybe_data1 . is_null ( ) ) { data1 = MaybeObjectHandle :: Weak ( holder ) ; } else { data1 = maybe_data1 ; } int checks_count = GetPrototypeCheckCount < LoadHandler > ( isolate , & smi_handler , receiver_map , holder , data1 , maybe_data2 ) ; Handle < Object > validity_cell = Map :: GetOrCreatePrototypeChainValidityCell ( receiver_map , isolate ) ; int data_count = 1 + checks_count ; Handle < LoadHandler > handler = isolate -> factory ( ) -> NewLoadHandler ( data_count ) ; handler -> set_smi_handler ( * smi_handler ) ; handler -> set_validity_cell ( * validity_cell ) ; InitPrototypeChecks ( isolate , handler , receiver_map , holder , data1 , maybe_data2 ) ; return handler ; }
BytecodeGraphBuilder :: TryBuildSimplifiedUnaryOp ( const Operator * op , Node * operand , FeedbackSlot slot ) { Node * effect = environment ( ) -> GetEffectDependency ( ) ; Node * control = environment ( ) -> GetControlDependency ( ) ; JSTypeHintLowering :: LoweringResult result = type_hint_lowering ( ) . ReduceUnaryOperation ( op , operand , effect , control , slot ) ; ApplyEarlyReduction ( result ) ; return result ; }
static char * get_header ( FILE * fp ) { long start ; char * header ; header = calloc ( 1 , 1024 ) ; start = ftell ( fp ) ; fseek ( fp , 0 , SEEK_SET ) ; SAFE_E ( fread ( header , 1 , 1023 , fp ) , 1023 , "Failed to load PDF header.\n" ) ; fseek ( fp , start , SEEK_SET ) ; return header ; }
AttributeData ( nsPresContext * aPresContext , Element * aElement , nsIAtom * aAttribute , int32_t aModType , bool aAttrHasChanged , const nsAttrValue * aOtherValue , TreeMatchContext & aTreeMatchContext ) : AttributeRuleProcessorData ( aPresContext , aElement , aAttribute , aModType , aAttrHasChanged , aOtherValue , aTreeMatchContext ) , mHint ( nsRestyleHint ( 0 ) ) { }
tt_sbit_decoder_load_image ( TT_SBitDecoder decoder , FT_UInt glyph_index , FT_Int x_pos , FT_Int y_pos ) { FT_Byte * p = decoder -> eblc_base + decoder -> strike_index_array ; FT_Byte * p_limit = decoder -> eblc_limit ; FT_ULong num_ranges = decoder -> strike_index_count ; FT_UInt start , end , index_format , image_format ; FT_ULong image_start = 0 , image_end = 0 , image_offset ; for ( ; num_ranges > 0 ; num_ranges -- ) { start = FT_NEXT_USHORT ( p ) ; end = FT_NEXT_USHORT ( p ) ; if ( glyph_index >= start && glyph_index <= end ) goto FoundRange ; p += 4 ; } goto NoBitmap ; FoundRange : image_offset = FT_NEXT_ULONG ( p ) ; p = decoder -> eblc_base + decoder -> strike_index_array ; if ( image_offset > ( FT_ULong ) ( p_limit - p ) ) goto Failure ; p += image_offset ; if ( p + 8 > p_limit ) goto NoBitmap ; index_format = FT_NEXT_USHORT ( p ) ; image_format = FT_NEXT_USHORT ( p ) ; image_offset = FT_NEXT_ULONG ( p ) ; switch ( index_format ) { case 1 : p += 4 * ( glyph_index - start ) ; if ( p + 8 > p_limit ) goto NoBitmap ; image_start = FT_NEXT_ULONG ( p ) ; image_end = FT_NEXT_ULONG ( p ) ; if ( image_start == image_end ) goto NoBitmap ; break ; case 2 : { FT_ULong image_size ; if ( p + 12 > p_limit ) goto NoBitmap ; image_size = FT_NEXT_ULONG ( p ) ; if ( tt_sbit_decoder_load_metrics ( decoder , & p , p_limit , 1 ) ) goto NoBitmap ; image_start = image_size * ( glyph_index - start ) ; image_end = image_start + image_size ; } break ; case 3 : p += 2 * ( glyph_index - start ) ; if ( p + 4 > p_limit ) goto NoBitmap ; image_start = FT_NEXT_USHORT ( p ) ; image_end = FT_NEXT_USHORT ( p ) ; if ( image_start == image_end ) goto NoBitmap ; break ; case 4 : { FT_ULong mm , num_glyphs ; if ( p + 4 > p_limit ) goto NoBitmap ; num_glyphs = FT_NEXT_ULONG ( p ) ; if ( p + 4 > p_limit || num_glyphs > ( FT_ULong ) ( ( ( p_limit - p ) > > 2 ) - 1 ) ) goto NoBitmap ; for ( mm = 0 ; mm < num_glyphs ; mm ++ ) { FT_UInt gindex = FT_NEXT_USHORT ( p ) ; if ( gindex == glyph_index ) { image_start = FT_NEXT_USHORT ( p ) ; p += 2 ; image_end = FT_PEEK_USHORT ( p ) ; break ; } p += 2 ; } if ( mm >= num_glyphs ) goto NoBitmap ; } break ; case 5 : case 19 : { FT_ULong image_size , mm , num_glyphs ; if ( p + 16 > p_limit ) goto NoBitmap ; image_size = FT_NEXT_ULONG ( p ) ; if ( tt_sbit_decoder_load_metrics ( decoder , & p , p_limit , 1 ) ) goto NoBitmap ; num_glyphs = FT_NEXT_ULONG ( p ) ; if ( num_glyphs > ( FT_ULong ) ( ( p_limit - p ) > > 1 ) ) goto NoBitmap ; for ( mm = 0 ; mm < num_glyphs ; mm ++ ) { FT_UInt gindex = FT_NEXT_USHORT ( p ) ; if ( gindex == glyph_index ) break ; } if ( mm >= num_glyphs ) goto NoBitmap ; image_start = image_size * mm ; image_end = image_start + image_size ; } break ; default : goto NoBitmap ; } if ( image_start > image_end ) goto NoBitmap ; image_end -= image_start ; image_start = image_offset + image_start ; FT_TRACE3 ( ( "tt_sbit_decoder_load_image:" " found sbit (format %d) for glyph index %d\n" , image_format , glyph_index ) ) ; return tt_sbit_decoder_load_bitmap ( decoder , image_format , image_start , image_end , x_pos , y_pos ) ; Failure : return FT_THROW ( Invalid_Table ) ; NoBitmap : FT_TRACE4 ( ( "tt_sbit_decoder_load_image:" " no sbit found for glyph index %d\n" , glyph_index ) ) ; return FT_THROW ( Invalid_Argument ) ; }
static int __pyx_pf_17clickhouse_driver_14bufferedreader_20BufferedSocketReader___init__ ( struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedSocketReader * __pyx_v_self , PyObject * __pyx_v_sock , PyObject * __pyx_v_bufsize ) { int __pyx_r ; __Pyx_RefNannyDeclarations PyObject * __pyx_t_1 = NULL ; PyObject * __pyx_t_2 = NULL ; PyObject * __pyx_t_3 = NULL ; __Pyx_RefNannySetupContext ( "__init__" , 0 ) ; __Pyx_INCREF ( __pyx_v_sock ) ; __Pyx_GIVEREF ( __pyx_v_sock ) ; __Pyx_GOTREF ( __pyx_v_self -> sock ) ; __Pyx_DECREF ( __pyx_v_self -> sock ) ; __pyx_v_self -> sock = __pyx_v_sock ; __pyx_t_2 = PyTuple_New ( 2 ) ; if ( unlikely ( ! __pyx_t_2 ) ) __PYX_ERR ( 0 , 185 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_2 ) ; __Pyx_INCREF ( ( ( PyObject * ) __pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedSocketReader ) ) ; __Pyx_GIVEREF ( ( ( PyObject * ) __pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedSocketReader ) ) ; PyTuple_SET_ITEM ( __pyx_t_2 , 0 , ( ( PyObject * ) __pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedSocketReader ) ) ; __Pyx_INCREF ( ( ( PyObject * ) __pyx_v_self ) ) ; __Pyx_GIVEREF ( ( ( PyObject * ) __pyx_v_self ) ) ; PyTuple_SET_ITEM ( __pyx_t_2 , 1 , ( ( PyObject * ) __pyx_v_self ) ) ; __pyx_t_3 = __Pyx_PyObject_Call ( __pyx_builtin_super , __pyx_t_2 , NULL ) ; if ( unlikely ( ! __pyx_t_3 ) ) __PYX_ERR ( 0 , 185 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_3 ) ; __Pyx_DECREF ( __pyx_t_2 ) ; __pyx_t_2 = 0 ; __pyx_t_2 = __Pyx_PyObject_GetAttrStr ( __pyx_t_3 , __pyx_n_s_init ) ; if ( unlikely ( ! __pyx_t_2 ) ) __PYX_ERR ( 0 , 185 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_2 ) ; __Pyx_DECREF ( __pyx_t_3 ) ; __pyx_t_3 = 0 ; __pyx_t_3 = NULL ; if ( CYTHON_UNPACK_METHODS && likely ( PyMethod_Check ( __pyx_t_2 ) ) ) { __pyx_t_3 = PyMethod_GET_SELF ( __pyx_t_2 ) ; if ( likely ( __pyx_t_3 ) ) { PyObject * function = PyMethod_GET_FUNCTION ( __pyx_t_2 ) ; __Pyx_INCREF ( __pyx_t_3 ) ; __Pyx_INCREF ( function ) ; __Pyx_DECREF_SET ( __pyx_t_2 , function ) ; } } __pyx_t_1 = ( __pyx_t_3 ) ? __Pyx_PyObject_Call2Args ( __pyx_t_2 , __pyx_t_3 , __pyx_v_bufsize ) : __Pyx_PyObject_CallOneArg ( __pyx_t_2 , __pyx_v_bufsize ) ; __Pyx_XDECREF ( __pyx_t_3 ) ; __pyx_t_3 = 0 ; if ( unlikely ( ! __pyx_t_1 ) ) __PYX_ERR ( 0 , 185 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_1 ) ; __Pyx_DECREF ( __pyx_t_2 ) ; __pyx_t_2 = 0 ; __Pyx_DECREF ( __pyx_t_1 ) ; __pyx_t_1 = 0 ; __pyx_r = 0 ; goto __pyx_L0 ; __pyx_L1_error : ; __Pyx_XDECREF ( __pyx_t_1 ) ; __Pyx_XDECREF ( __pyx_t_2 ) ; __Pyx_XDECREF ( __pyx_t_3 ) ; __Pyx_AddTraceback ( "clickhouse_driver.bufferedreader.BufferedSocketReader.__init__" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __pyx_r = - 1 ; __pyx_L0 : ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
void CollectionsBuiltinsAssembler :: FindOrderedHashTableEntryForSmiKey ( Node * table , Node * smi_key , Variable * result , Label * entry_found , Label * not_found ) { Node * const key_untagged = SmiUntag ( smi_key ) ; Node * const hash = ChangeInt32ToIntPtr ( ComputeIntegerHash ( key_untagged , Int32Constant ( 0 ) ) ) ; CSA_ASSERT ( this , IntPtrGreaterThanOrEqual ( hash , IntPtrConstant ( 0 ) ) ) ; result -> Bind ( hash ) ; FindOrderedHashTableEntry < CollectionType > ( table , hash , [ & ] ( Node * other_key , Label * if_same , Label * if_not_same ) { SameValueZeroSmi ( smi_key , other_key , if_same , if_not_same ) ; } , result , entry_found , not_found ) ; }
void PipelineImpl :: ComputeScheduledGraph ( ) { PipelineData * data = this -> data_ ; DCHECK_NULL ( data -> schedule ( ) ) ; Run < LateGraphTrimmingPhase > ( ) ; RunPrintAndVerify ( LateGraphTrimmingPhase :: phase_name ( ) , true ) ; Run < ComputeSchedulePhase > ( ) ; TraceSchedule ( data -> info ( ) , data , data -> schedule ( ) , "schedule" ) ; }
void MarkUntypedPointers ( YoungGenerationMarkingTask * task ) { RememberedSet < OLD_TO_NEW > :: Iterate ( chunk_ , [ this , task ] ( Address slot ) { return CheckAndMarkObject ( task , slot ) ; } , SlotSet :: PREFREE_EMPTY_BUCKETS ) ; }
int writepng_init ( mainprog_info * mainprog_ptr ) { png_structp png_ptr ; png_infop info_ptr ; int color_type , interlace_type ; png_ptr = png_create_write_struct ( PNG_LIBPNG_VER_STRING , mainprog_ptr , writepng_error_handler , NULL ) ; if ( ! png_ptr ) return 4 ; info_ptr = png_create_info_struct ( png_ptr ) ; if ( ! info_ptr ) { png_destroy_write_struct ( & png_ptr , NULL ) ; return 4 ; } if ( setjmp ( mainprog_ptr -> jmpbuf ) ) { png_destroy_write_struct ( & png_ptr , & info_ptr ) ; return 2 ; } png_init_io ( png_ptr , mainprog_ptr -> outfile ) ; png_set_compression_level ( png_ptr , Z_BEST_COMPRESSION ) ; if ( mainprog_ptr -> pnmtype == 5 ) color_type = PNG_COLOR_TYPE_GRAY ; else if ( mainprog_ptr -> pnmtype == 6 ) color_type = PNG_COLOR_TYPE_RGB ; else if ( mainprog_ptr -> pnmtype == 8 ) color_type = PNG_COLOR_TYPE_RGB_ALPHA ; else { png_destroy_write_struct ( & png_ptr , & info_ptr ) ; return 11 ; } interlace_type = mainprog_ptr -> interlaced ? PNG_INTERLACE_ADAM7 : PNG_INTERLACE_NONE ; png_set_IHDR ( png_ptr , info_ptr , mainprog_ptr -> width , mainprog_ptr -> height , mainprog_ptr -> sample_depth , color_type , interlace_type , PNG_COMPRESSION_TYPE_DEFAULT , PNG_FILTER_TYPE_DEFAULT ) ; if ( mainprog_ptr -> gamma > 0.0 ) png_set_gAMA ( png_ptr , info_ptr , mainprog_ptr -> gamma ) ; if ( mainprog_ptr -> have_bg ) { png_color_16 background ; background . red = mainprog_ptr -> bg_red ; background . green = mainprog_ptr -> bg_green ; background . blue = mainprog_ptr -> bg_blue ; png_set_bKGD ( png_ptr , info_ptr , & background ) ; } if ( mainprog_ptr -> have_time ) { png_time modtime ; png_convert_from_time_t ( & modtime , mainprog_ptr -> modtime ) ; png_set_tIME ( png_ptr , info_ptr , & modtime ) ; } if ( mainprog_ptr -> have_text ) { png_text text [ 6 ] ; int num_text = 0 ; if ( mainprog_ptr -> have_text & TEXT_TITLE ) { text [ num_text ] . compression = PNG_TEXT_COMPRESSION_NONE ; text [ num_text ] . key = "Title" ; text [ num_text ] . text = mainprog_ptr -> title ; ++ num_text ; } if ( mainprog_ptr -> have_text & TEXT_AUTHOR ) { text [ num_text ] . compression = PNG_TEXT_COMPRESSION_NONE ; text [ num_text ] . key = "Author" ; text [ num_text ] . text = mainprog_ptr -> author ; ++ num_text ; } if ( mainprog_ptr -> have_text & TEXT_DESC ) { text [ num_text ] . compression = PNG_TEXT_COMPRESSION_NONE ; text [ num_text ] . key = "Description" ; text [ num_text ] . text = mainprog_ptr -> desc ; ++ num_text ; } if ( mainprog_ptr -> have_text & TEXT_COPY ) { text [ num_text ] . compression = PNG_TEXT_COMPRESSION_NONE ; text [ num_text ] . key = "Copyright" ; text [ num_text ] . text = mainprog_ptr -> copyright ; ++ num_text ; } if ( mainprog_ptr -> have_text & TEXT_EMAIL ) { text [ num_text ] . compression = PNG_TEXT_COMPRESSION_NONE ; text [ num_text ] . key = "E-mail" ; text [ num_text ] . text = mainprog_ptr -> email ; ++ num_text ; } if ( mainprog_ptr -> have_text & TEXT_URL ) { text [ num_text ] . compression = PNG_TEXT_COMPRESSION_NONE ; text [ num_text ] . key = "URL" ; text [ num_text ] . text = mainprog_ptr -> url ; ++ num_text ; } png_set_text ( png_ptr , info_ptr , text , num_text ) ; } png_write_info ( png_ptr , info_ptr ) ; png_set_packing ( png_ptr ) ; mainprog_ptr -> png_ptr = png_ptr ; mainprog_ptr -> info_ptr = info_ptr ; return 0 ; }
PREFIX ( scanEndTag ) ( const ENCODING * enc , const char * ptr , const char * end , const char * * nextTokPtr ) { if ( ptr == end ) return XML_TOK_PARTIAL ; switch ( BYTE_TYPE ( enc , ptr ) ) { CHECK_NMSTRT_CASES ( enc , ptr , end , nextTokPtr ) default : * nextTokPtr = ptr ; return XML_TOK_INVALID ; } while ( ptr != end ) { switch ( BYTE_TYPE ( enc , ptr ) ) { CHECK_NAME_CASES ( enc , ptr , end , nextTokPtr ) case BT_S : case BT_CR : case BT_LF : for ( ptr += MINBPC ( enc ) ; ptr != end ; ptr += MINBPC ( enc ) ) { switch ( BYTE_TYPE ( enc , ptr ) ) { case BT_S : case BT_CR : case BT_LF : break ; case BT_GT : * nextTokPtr = ptr + MINBPC ( enc ) ; return XML_TOK_END_TAG ; default : * nextTokPtr = ptr ; return XML_TOK_INVALID ; } } return XML_TOK_PARTIAL ; #ifdef XML_NS case BT_COLON : ptr += MINBPC ( enc ) ; break ; #endif case BT_GT : * nextTokPtr = ptr + MINBPC ( enc ) ; return XML_TOK_END_TAG ; default : * nextTokPtr = ptr ; return XML_TOK_INVALID ; } } return XML_TOK_PARTIAL ; }
Expression * Parser :: NewV8Intrinsic ( const AstRawString * name , ZonePtrList < Expression > * args , int pos , bool * ok ) { if ( extension_ != nullptr ) { GetClosureScope ( ) -> ForceEagerCompilation ( ) ; } DCHECK ( name -> is_one_byte ( ) ) ; const Runtime :: Function * function = Runtime :: FunctionForName ( name -> raw_data ( ) , name -> length ( ) ) ; if ( function != nullptr ) { DCHECK_EQ ( Context :: kNotFound , Context :: IntrinsicIndexForName ( name -> raw_data ( ) , name -> length ( ) ) ) ; if ( function -> function_id == Runtime :: kIS_VAR ) { DCHECK_EQ ( Runtime :: RUNTIME , function -> intrinsic_type ) ; if ( args -> length ( ) == 1 && args -> at ( 0 ) -> AsVariableProxy ( ) != nullptr ) { return args -> at ( 0 ) ; } else { ReportMessage ( MessageTemplate :: kNotIsvar ) ; * ok = false ; return nullptr ; } } if ( function -> nargs != - 1 && function -> nargs != args -> length ( ) ) { ReportMessage ( MessageTemplate :: kRuntimeWrongNumArgs ) ; * ok = false ; return nullptr ; } return factory ( ) -> NewCallRuntime ( function , args , pos ) ; } int context_index = Context :: IntrinsicIndexForName ( name -> raw_data ( ) , name -> length ( ) ) ; if ( context_index == Context :: kNotFound ) { ReportMessage ( MessageTemplate :: kNotDefined , name ) ; * ok = false ; return nullptr ; } return factory ( ) -> NewCallRuntime ( context_index , args , pos ) ; }
void Parser :: ValidateCatchBlock ( const CatchInfo & catch_info , bool * ok ) { Scope * inner_block_scope = catch_info . inner_block -> scope ( ) ; if ( inner_block_scope != nullptr ) { Declaration * decl = inner_block_scope -> CheckLexDeclarationsConflictingWith ( catch_info . bound_names ) ; if ( decl != nullptr ) { const AstRawString * name = decl -> proxy ( ) -> raw_name ( ) ; int position = decl -> proxy ( ) -> position ( ) ; Scanner :: Location location = position == kNoSourcePosition ? Scanner :: Location :: invalid ( ) : Scanner :: Location ( position , position + 1 ) ; ReportMessageAt ( location , MessageTemplate :: kVarRedeclaration , name ) ; * ok = false ; } } }
int ConnectionImpl :: onHeadersCompleteBase ( ) { ENVOY_CONN_LOG ( trace , "headers complete" , connection_ ) ; completeLastHeader ( ) ; if ( ! ( parser_ . http_major == 1 && parser_ . http_minor == 1 ) ) { protocol_ = Protocol :: Http10 ; } if ( Utility :: isUpgrade ( * current_header_map_ ) ) { if ( current_header_map_ -> Upgrade ( ) && absl :: EqualsIgnoreCase ( current_header_map_ -> Upgrade ( ) -> value ( ) . getStringView ( ) , Http :: Headers :: get ( ) . UpgradeValues . H2c ) ) { ENVOY_CONN_LOG ( trace , "removing unsupported h2c upgrade headers." , connection_ ) ; current_header_map_ -> removeUpgrade ( ) ; if ( current_header_map_ -> Connection ( ) ) { const auto & tokens_to_remove = caseUnorderdSetContainingUpgradeAndHttp2Settings ( ) ; std :: string new_value = StringUtil :: removeTokens ( current_header_map_ -> Connection ( ) -> value ( ) . getStringView ( ) , "," , tokens_to_remove , "," ) ; if ( new_value . empty ( ) ) { current_header_map_ -> removeConnection ( ) ; } else { current_header_map_ -> Connection ( ) -> value ( new_value ) ; } } current_header_map_ -> remove ( Headers :: get ( ) . Http2Settings ) ; } else { ENVOY_CONN_LOG ( trace , "codec entering upgrade mode." , connection_ ) ; handling_upgrade_ = true ; } } int rc = onHeadersComplete ( std :: move ( current_header_map_ ) ) ; current_header_map_ . reset ( ) ; header_parsing_state_ = HeaderParsingState :: Done ; return handling_upgrade_ ? 2 : rc ; }
WebGLContext :: CompressedTexSubImage2D ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLsizei width , GLsizei height , GLenum format , const ArrayBufferView & view ) { if ( IsContextLost ( ) ) { return ; } switch ( target ) { case LOCAL_GL_TEXTURE_2D : case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X : case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X : case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y : case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y : case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z : case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z : break ; default : return ErrorInvalidEnumInfo ( "texSubImage2D: target" , target ) ; } WebGLTexture * tex = activeBoundTextureForTarget ( target ) ; if ( ! tex ) { ErrorInvalidOperation ( "compressedTexSubImage2D: no texture is bound to this target" ) ; return ; } if ( ! mCompressedTextureFormats . Contains ( format ) ) { ErrorInvalidEnum ( "compressedTexSubImage2D: compressed texture format 0x%x is not supported" , format ) ; return ; } if ( ! ValidateLevelWidthHeightForTarget ( target , level , width , height , "compressedTexSubImage2D" ) ) { return ; } uint32_t byteLength = view . Length ( ) ; if ( ! ValidateCompressedTextureSize ( target , level , format , width , height , byteLength , "compressedTexSubImage2D" ) ) { return ; } if ( ! tex -> HasImageInfoAt ( target , level ) ) { ErrorInvalidOperation ( "compressedTexSubImage2D: no texture image previously defined for this level and face" ) ; return ; } const WebGLTexture :: ImageInfo & imageInfo = tex -> ImageInfoAt ( target , level ) ; if ( ! CanvasUtils :: CheckSaneSubrectSize ( xoffset , yoffset , width , height , imageInfo . Width ( ) , imageInfo . Height ( ) ) ) { ErrorInvalidValue ( "compressedTexSubImage2D: subtexture rectangle out of bounds" ) ; return ; } switch ( format ) { case LOCAL_GL_COMPRESSED_RGB_S3TC_DXT1_EXT : case LOCAL_GL_COMPRESSED_RGBA_S3TC_DXT1_EXT : case LOCAL_GL_COMPRESSED_RGBA_S3TC_DXT3_EXT : case LOCAL_GL_COMPRESSED_RGBA_S3TC_DXT5_EXT : { if ( xoffset < 0 || xoffset % 4 != 0 ) { ErrorInvalidOperation ( "compressedTexSubImage2D: xoffset is not a multiple of 4" ) ; return ; } if ( yoffset < 0 || yoffset % 4 != 0 ) { ErrorInvalidOperation ( "compressedTexSubImage2D: yoffset is not a multiple of 4" ) ; return ; } if ( width % 4 != 0 && width != imageInfo . Width ( ) ) { ErrorInvalidOperation ( "compressedTexSubImage2D: width is not a multiple of 4 or equal to texture width" ) ; return ; } if ( height % 4 != 0 && height != imageInfo . Height ( ) ) { ErrorInvalidOperation ( "compressedTexSubImage2D: height is not a multiple of 4 or equal to texture height" ) ; return ; } break ; } case LOCAL_GL_COMPRESSED_RGB_PVRTC_4BPPV1 : case LOCAL_GL_COMPRESSED_RGB_PVRTC_2BPPV1 : case LOCAL_GL_COMPRESSED_RGBA_PVRTC_4BPPV1 : case LOCAL_GL_COMPRESSED_RGBA_PVRTC_2BPPV1 : { if ( xoffset || yoffset || width != imageInfo . Width ( ) || height != imageInfo . Height ( ) ) { ErrorInvalidValue ( "compressedTexSubImage2D: the update rectangle doesn't match the existing image" ) ; return ; } } } if ( imageInfo . HasUninitializedImageData ( ) ) { tex -> DoDeferredImageInitialization ( target , level ) ; } gl -> fCompressedTexSubImage2D ( target , level , xoffset , yoffset , width , height , format , byteLength , view . Data ( ) ) ; return ; }
void CalculateOutputIndexValueRowID ( OpKernelContext * context , const RowPartitionTensor & value_rowids , const vector < INDEX_TYPE > & parent_output_index , INDEX_TYPE output_index_multiplier , INDEX_TYPE output_size , vector < INDEX_TYPE > * result ) { const INDEX_TYPE index_size = value_rowids . size ( ) ; result -> reserve ( index_size ) ; if ( index_size == 0 ) { return ; } INDEX_TYPE current_output_column = 0 ; INDEX_TYPE current_value_rowid = value_rowids ( 0 ) ; DCHECK_LT ( current_value_rowid , parent_output_index . size ( ) ) ; INDEX_TYPE current_output_index = parent_output_index [ current_value_rowid ] ; result -> push_back ( current_output_index ) ; for ( INDEX_TYPE i = 1 ; i < index_size ; ++ i ) { INDEX_TYPE next_value_rowid = value_rowids ( i ) ; if ( next_value_rowid == current_value_rowid ) { if ( current_output_index >= 0 ) { ++ current_output_column ; if ( current_output_column < output_size ) { current_output_index += output_index_multiplier ; } else { current_output_index = - 1 ; } } } else { current_output_column = 0 ; current_value_rowid = next_value_rowid ; DCHECK_LT ( next_value_rowid , parent_output_index . size ( ) ) ; current_output_index = parent_output_index [ next_value_rowid ] ; } result -> push_back ( current_output_index ) ; } OP_REQUIRES ( context , result -> size ( ) == value_rowids . size ( ) , errors :: InvalidArgument ( "Invalid row ids." ) ) ; }
FLAC__bool seek_to_absolute_sample_ogg_ ( FLAC__StreamDecoder * decoder , FLAC__uint64 stream_length , FLAC__uint64 target_sample ) { FLAC__uint64 left_pos = 0 , right_pos = stream_length ; FLAC__uint64 left_sample = 0 , right_sample = FLAC__stream_decoder_get_total_samples ( decoder ) ; FLAC__uint64 this_frame_sample = ( FLAC__uint64 ) 0 - 1 ; FLAC__uint64 pos = 0 ; FLAC__bool did_a_seek ; unsigned iteration = 0 ; unsigned BINARY_SEARCH_AFTER_ITERATION = 2 ; static const FLAC__uint64 LINEAR_SEARCH_WITHIN_SAMPLES = FLAC__MAX_BLOCK_SIZE * 2 ; if ( right_sample == 0 ) { right_sample = ( FLAC__uint64 ) ( - 1 ) ; BINARY_SEARCH_AFTER_ITERATION = 0 ; } decoder -> private_ -> target_sample = target_sample ; for ( ; ; iteration ++ ) { if ( iteration == 0 || this_frame_sample > target_sample || target_sample - this_frame_sample > LINEAR_SEARCH_WITHIN_SAMPLES ) { if ( iteration >= BINARY_SEARCH_AFTER_ITERATION ) { pos = ( right_pos + left_pos ) / 2 ; } else { #ifndef FLAC__INTEGER_ONLY_LIBRARY #if defined _MSC_VER || defined __MINGW32__ pos = ( FLAC__uint64 ) ( ( FLAC__double ) ( FLAC__int64 ) ( target_sample - left_sample ) / ( FLAC__double ) ( FLAC__int64 ) ( right_sample - left_sample ) * ( FLAC__double ) ( FLAC__int64 ) ( right_pos - left_pos ) ) ; #else pos = ( FLAC__uint64 ) ( ( FLAC__double ) ( target_sample - left_sample ) / ( FLAC__double ) ( right_sample - left_sample ) * ( FLAC__double ) ( right_pos - left_pos ) ) ; #endif #else if ( ( target_sample - left_sample <= 0xffffffff ) && ( right_pos - left_pos <= 0xffffffff ) ) pos = ( FLAC__int64 ) ( ( ( target_sample - left_sample ) * ( right_pos - left_pos ) ) / ( right_sample - left_sample ) ) ; else pos = ( FLAC__int64 ) ( ( ( ( target_sample - left_sample ) > > 8 ) * ( ( right_pos - left_pos ) > > 8 ) ) / ( ( right_sample - left_sample ) > > 16 ) ) ; #endif } if ( decoder -> private_ -> seek_callback ( ( FLAC__StreamDecoder * ) decoder , ( FLAC__uint64 ) pos , decoder -> private_ -> client_data ) != FLAC__STREAM_DECODER_SEEK_STATUS_OK ) { decoder -> protected_ -> state = FLAC__STREAM_DECODER_SEEK_ERROR ; return false ; } if ( ! FLAC__stream_decoder_flush ( decoder ) ) { return false ; } did_a_seek = true ; } else did_a_seek = false ; decoder -> private_ -> got_a_frame = false ; if ( ! FLAC__stream_decoder_process_single ( decoder ) ) { decoder -> protected_ -> state = FLAC__STREAM_DECODER_SEEK_ERROR ; return false ; } if ( ! decoder -> private_ -> got_a_frame ) { if ( did_a_seek ) { right_pos = pos ; BINARY_SEARCH_AFTER_ITERATION = 0 ; } else { decoder -> protected_ -> state = FLAC__STREAM_DECODER_SEEK_ERROR ; return false ; } } else if ( ! decoder -> private_ -> is_seeking ) { break ; } else { this_frame_sample = decoder -> private_ -> last_frame . header . number . sample_number ; FLAC__ASSERT ( decoder -> private_ -> last_frame . header . number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER ) ; if ( did_a_seek ) { if ( this_frame_sample <= target_sample ) { FLAC__ASSERT ( this_frame_sample != target_sample ) ; left_sample = this_frame_sample ; if ( left_pos == pos ) { decoder -> protected_ -> state = FLAC__STREAM_DECODER_SEEK_ERROR ; return false ; } left_pos = pos ; } else if ( this_frame_sample > target_sample ) { right_sample = this_frame_sample ; if ( right_pos == pos ) { decoder -> protected_ -> state = FLAC__STREAM_DECODER_SEEK_ERROR ; return false ; } right_pos = pos ; } } } } return true ; }
SampleTable :: SampleTable ( const sp < DataSource > & source ) : mDataSource ( source ) , mChunkOffsetOffset ( - 1 ) , mChunkOffsetType ( 0 ) , mNumChunkOffsets ( 0 ) , mSampleToChunkOffset ( - 1 ) , mNumSampleToChunkOffsets ( 0 ) , mSampleSizeOffset ( - 1 ) , mSampleSizeFieldSize ( 0 ) , mDefaultSampleSize ( 0 ) , mNumSampleSizes ( 0 ) , mTimeToSampleCount ( 0 ) , mTimeToSample ( NULL ) , mSampleTimeEntries ( NULL ) , mCompositionTimeDeltaEntries ( NULL ) , mNumCompositionTimeDeltaEntries ( 0 ) , mCompositionDeltaLookup ( new CompositionDeltaLookup ) , mSyncSampleOffset ( - 1 ) , mNumSyncSamples ( 0 ) , mSyncSamples ( NULL ) , mLastSyncSampleIndex ( 0 ) , mSampleToChunkEntries ( NULL ) { mSampleIterator = new SampleIterator ( this ) ; }
CanvasClient2D :: Update ( gfx :: IntSize aSize , ClientCanvasLayer * aLayer ) { AutoRemoveTexture autoRemove ( this ) ; if ( mBuffer && ( mBuffer -> IsImmutable ( ) || mBuffer -> GetSize ( ) != aSize ) ) { autoRemove . mTexture = mBuffer ; mBuffer = nullptr ; } bool bufferCreated = false ; if ( ! mBuffer ) { bool isOpaque = ( aLayer -> GetContentFlags ( ) & Layer :: CONTENT_OPAQUE ) ; gfxContentType contentType = isOpaque ? gfxContentType :: COLOR : gfxContentType :: COLOR_ALPHA ; gfxImageFormat format = gfxPlatform :: GetPlatform ( ) -> OptimalFormatForContent ( contentType ) ; TextureFlags flags = TextureFlags :: DEFAULT ; if ( mTextureFlags & TextureFlags :: ORIGIN_BOTTOM_LEFT ) { flags |= TextureFlags :: ORIGIN_BOTTOM_LEFT ; } gfx :: SurfaceFormat surfaceFormat = gfx :: ImageFormatToSurfaceFormat ( format ) ; mBuffer = CreateTextureClientForCanvas ( surfaceFormat , aSize , flags , aLayer ) ; if ( ! mBuffer ) { NS_WARNING ( "Failed to allocate the TextureClient" ) ; return ; } MOZ_ASSERT ( mBuffer -> CanExposeDrawTarget ( ) ) ; bufferCreated = true ; } if ( ! mBuffer -> Lock ( OpenMode :: OPEN_WRITE_ONLY ) ) { mBuffer = nullptr ; return ; } bool updated = false ; { RefPtr < DrawTarget > target = mBuffer -> BorrowDrawTarget ( ) ; if ( target ) { aLayer -> UpdateTarget ( target ) ; updated = true ; } } mBuffer -> Unlock ( ) ; if ( bufferCreated && ! AddTextureClient ( mBuffer ) ) { mBuffer = nullptr ; return ; } if ( updated ) { nsAutoTArray < CompositableForwarder :: TimedTextureClient , 1 > textures ; CompositableForwarder :: TimedTextureClient * t = textures . AppendElement ( ) ; t -> mTextureClient = mBuffer ; t -> mPictureRect = nsIntRect ( nsIntPoint ( 0 , 0 ) , mBuffer -> GetSize ( ) ) ; GetForwarder ( ) -> UseTextures ( this , textures ) ; mBuffer -> SyncWithObject ( GetForwarder ( ) -> GetSyncObject ( ) ) ; } }
int composite_dev_prepare ( struct usb_composite_driver * composite , struct usb_composite_dev * cdev ) { struct usb_gadget * gadget = cdev -> gadget ; int ret = - ENOMEM ; cdev -> req = usb_ep_alloc_request ( gadget -> ep0 , GFP_KERNEL ) ; if ( ! cdev -> req ) return - ENOMEM ; cdev -> req -> buf = kmalloc ( USB_COMP_EP0_BUFSIZ , GFP_KERNEL ) ; if ( ! cdev -> req -> buf ) goto fail ; ret = device_create_file ( & gadget -> dev , & dev_attr_suspended ) ; if ( ret ) goto fail_dev ; cdev -> req -> complete = composite_setup_complete ; cdev -> req -> context = cdev ; gadget -> ep0 -> driver_data = cdev ; cdev -> driver = composite ; if ( CONFIG_USB_GADGET_VBUS_DRAW <= USB_SELF_POWER_VBUS_MAX_DRAW ) usb_gadget_set_selfpowered ( gadget ) ; usb_ep_autoconfig_reset ( gadget ) ; return 0 ; fail_dev : kfree ( cdev -> req -> buf ) ; fail : usb_ep_free_request ( gadget -> ep0 , cdev -> req ) ; cdev -> req = NULL ; return ret ; }
static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put ( loop_trans ) ; conn -> c_loopback = 1 ; if ( is_outgoing && trans -> t_prefer_loopback ) { trans = & rds_loop_transport ; } } if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; } conn -> c_trans = trans ; ret = trans -> conn_alloc ( conn , gfp ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } atomic_set ( & conn -> c_state , RDS_CONN_DOWN ) ; conn -> c_send_gen = 0 ; conn -> c_outgoing = ( is_outgoing ? 1 : 0 ) ; conn -> c_reconnect_jiffies = 0 ; INIT_DELAYED_WORK ( & conn -> c_send_w , rds_send_worker ) ; INIT_DELAYED_WORK ( & conn -> c_recv_w , rds_recv_worker ) ; INIT_DELAYED_WORK ( & conn -> c_conn_w , rds_connect_worker ) ; INIT_WORK ( & conn -> c_down_w , rds_shutdown_worker ) ; mutex_init ( & conn -> c_cm_lock ) ; conn -> c_flags = 0 ; rdsdebug ( "allocated conn %p for %pI4 -> %pI4 over %s %s\n" , conn , & laddr , & faddr , trans -> t_name ? trans -> t_name : "[unknown]" , is_outgoing ? "(outgoing)" : "" ) ; spin_lock_irqsave ( & rds_conn_lock , flags ) ; if ( parent ) { if ( parent -> c_passive ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = parent -> c_passive ; } else { parent -> c_passive = conn ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } else { struct rds_connection * found ; found = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( found ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = found ; } else { hlist_add_head_rcu ( & conn -> c_hash_node , head ) ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } spin_unlock_irqrestore ( & rds_conn_lock , flags ) ; out : return conn ; }
xmlFreeHTTPWriteCtxt ( xmlIOHTTPWriteCtxtPtr ctxt ) { if ( ctxt -> uri != NULL ) xmlFree ( ctxt -> uri ) ; if ( ctxt -> doc_buff != NULL ) { #ifdef HAVE_ZLIB_H if ( ctxt -> compression > 0 ) { xmlFreeZMemBuff ( ctxt -> doc_buff ) ; } else #endif { xmlOutputBufferClose ( ctxt -> doc_buff ) ; } } xmlFree ( ctxt ) ; return ; }
void CoreAuthHandler :: onReadyRead ( ) { if ( socket ( ) -> bytesAvailable ( ) < 4 ) return ; if ( _peer ) return ; if ( ! _magicReceived ) { quint32 magic ; socket ( ) -> peek ( ( char * ) & magic , 4 ) ; magic = qFromBigEndian < quint32 > ( magic ) ; if ( ( magic & 0xffffff00 ) != Protocol :: magic ) { qDebug ( ) < < "Legacy client detected, switching to compatibility mode" ; _legacy = true ; RemotePeer * peer = PeerFactory :: createPeer ( PeerFactory :: ProtoDescriptor ( Protocol :: LegacyProtocol , 0 ) , this , socket ( ) , Compressor :: NoCompression , this ) ; connect ( peer , SIGNAL ( protocolVersionMismatch ( int , int ) ) , SLOT ( onProtocolVersionMismatch ( int , int ) ) ) ; setPeer ( peer ) ; return ; } _magicReceived = true ; quint8 features = magic & 0xff ; if ( Core :: sslSupported ( ) && ( features & Protocol :: Encryption ) ) _connectionFeatures |= Protocol :: Encryption ; if ( features & Protocol :: Compression ) _connectionFeatures |= Protocol :: Compression ; socket ( ) -> read ( ( char * ) & magic , 4 ) ; } while ( socket ( ) -> bytesAvailable ( ) >= 4 ) { quint32 data ; socket ( ) -> read ( ( char * ) & data , 4 ) ; data = qFromBigEndian < quint32 > ( data ) ; Protocol :: Type type = static_cast < Protocol :: Type > ( data & 0xff ) ; quint16 protoFeatures = static_cast < quint16 > ( data > > 8 & 0xffff ) ; _supportedProtos . append ( PeerFactory :: ProtoDescriptor ( type , protoFeatures ) ) ; if ( data >= 0x80000000 ) { Compressor :: CompressionLevel level ; if ( _connectionFeatures & Protocol :: Compression ) level = Compressor :: BestCompression ; else level = Compressor :: NoCompression ; RemotePeer * peer = PeerFactory :: createPeer ( _supportedProtos , this , socket ( ) , level , this ) ; if ( peer -> protocol ( ) == Protocol :: LegacyProtocol ) { _legacy = true ; connect ( peer , SIGNAL ( protocolVersionMismatch ( int , int ) ) , SLOT ( onProtocolVersionMismatch ( int , int ) ) ) ; } setPeer ( peer ) ; quint32 reply = peer -> protocol ( ) | peer -> enabledFeatures ( ) < < 8 | _connectionFeatures < < 24 ; reply = qToBigEndian < quint32 > ( reply ) ; socket ( ) -> write ( ( char * ) & reply , 4 ) ; socket ( ) -> flush ( ) ; if ( ! _legacy && ( _connectionFeatures & Protocol :: Encryption ) ) startSsl ( ) ; return ; } } }
static struct dir * squashfs_opendir ( unsigned int block_start , unsigned int offset , struct inode * * i ) { squashfs_dir_header_2 dirh ; char buffer [ sizeof ( squashfs_dir_entry_2 ) + SQUASHFS_NAME_LEN + 1 ] __attribute__ ( ( aligned ) ) ; squashfs_dir_entry_2 * dire = ( squashfs_dir_entry_2 * ) buffer ; long long start ; int bytes ; int dir_count , size ; struct dir_ent * new_dir ; struct dir * dir ; TRACE ( "squashfs_opendir: inode start block %d, offset %d\n" , block_start , offset ) ; * i = read_inode ( block_start , offset ) ; dir = malloc ( sizeof ( struct dir ) ) ; if ( dir == NULL ) EXIT_UNSQUASH ( "squashfs_opendir: malloc failed!\n" ) ; dir -> dir_count = 0 ; dir -> cur_entry = 0 ; dir -> mode = ( * i ) -> mode ; dir -> uid = ( * i ) -> uid ; dir -> guid = ( * i ) -> gid ; dir -> mtime = ( * i ) -> time ; dir -> xattr = ( * i ) -> xattr ; dir -> dirs = NULL ; if ( ( * i ) -> data == 0 ) return dir ; start = sBlk . s . directory_table_start + ( * i ) -> start ; bytes = lookup_entry ( directory_table_hash , start ) ; if ( bytes == - 1 ) EXIT_UNSQUASH ( "squashfs_opendir: directory block %d not " "found!\n" , block_start ) ; bytes += ( * i ) -> offset ; size = ( * i ) -> data + bytes ; while ( bytes < size ) { if ( swap ) { squashfs_dir_header_2 sdirh ; memcpy ( & sdirh , directory_table + bytes , sizeof ( sdirh ) ) ; SQUASHFS_SWAP_DIR_HEADER_2 ( & dirh , & sdirh ) ; } else memcpy ( & dirh , directory_table + bytes , sizeof ( dirh ) ) ; dir_count = dirh . count + 1 ; TRACE ( "squashfs_opendir: Read directory header @ byte position " "%d, %d directory entries\n" , bytes , dir_count ) ; bytes += sizeof ( dirh ) ; if ( dir_count > SQUASHFS_DIR_COUNT ) { ERROR ( "File system corrupted: too many entries in directory\n" ) ; goto corrupted ; } while ( dir_count -- ) { if ( swap ) { squashfs_dir_entry_2 sdire ; memcpy ( & sdire , directory_table + bytes , sizeof ( sdire ) ) ; SQUASHFS_SWAP_DIR_ENTRY_2 ( dire , & sdire ) ; } else memcpy ( dire , directory_table + bytes , sizeof ( * dire ) ) ; bytes += sizeof ( * dire ) ; if ( dire -> size >= SQUASHFS_NAME_LEN ) { ERROR ( "File system corrupted: filename too long\n" ) ; goto corrupted ; } memcpy ( dire -> name , directory_table + bytes , dire -> size + 1 ) ; dire -> name [ dire -> size + 1 ] = '\0' ; TRACE ( "squashfs_opendir: directory entry %s, inode " "%d:%d, type %d\n" , dire -> name , dirh . start_block , dire -> offset , dire -> type ) ; if ( ( dir -> dir_count % DIR_ENT_SIZE ) == 0 ) { new_dir = realloc ( dir -> dirs , ( dir -> dir_count + DIR_ENT_SIZE ) * sizeof ( struct dir_ent ) ) ; if ( new_dir == NULL ) EXIT_UNSQUASH ( "squashfs_opendir: " "realloc failed!\n" ) ; dir -> dirs = new_dir ; } strcpy ( dir -> dirs [ dir -> dir_count ] . name , dire -> name ) ; dir -> dirs [ dir -> dir_count ] . start_block = dirh . start_block ; dir -> dirs [ dir -> dir_count ] . offset = dire -> offset ; dir -> dirs [ dir -> dir_count ] . type = dire -> type ; dir -> dir_count ++ ; bytes += dire -> size + 1 ; } } return dir ; corrupted : free ( dir -> dirs ) ; free ( dir ) ; return NULL ; }
exif_data_load_data_thumbnail ( ExifData * data , const unsigned char * d , unsigned int ds , ExifLong o , ExifLong s ) { if ( ( o + s < o ) || ( o + s < s ) || ( o + s > ds ) || ( o > ds ) ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , "ExifData" , "Bogus thumbnail offset (%u) or size (%u)." , o , s ) ; return ; } if ( data -> data ) exif_mem_free ( data -> priv -> mem , data -> data ) ; if ( ! ( data -> data = exif_data_alloc ( data , s ) ) ) { EXIF_LOG_NO_MEMORY ( data -> priv -> log , "ExifData" , s ) ; data -> size = 0 ; return ; } data -> size = s ; memcpy ( data -> data , d + o , s ) ; }
static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; cstate = 0 ; if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { return - 1 ; } if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( "all tiles are outside the image area\n" ) ; return - 1 ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid XRsiz value %d\n" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid YRsiz value %d\n" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } siz -> comps [ i ] . sgnd = ( tmp > > 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { jas_free ( siz -> comps ) ; return - 1 ; } return 0 ; }
nsMultiMixedConv :: SendStop ( nsresult aStatus ) { nsresult rv = NS_OK ; if ( mPartChannel ) { rv = mFinalListener -> OnStopRequest ( mPartChannel , mContext , aStatus ) ; nsCOMPtr < nsILoadGroup > loadGroup ; ( void ) mPartChannel -> GetLoadGroup ( getter_AddRefs ( loadGroup ) ) ; if ( loadGroup ) ( void ) loadGroup -> RemoveRequest ( mPartChannel , mContext , aStatus ) ; } mPartChannel = 0 ; return rv ; }
Return < void > DescramblerImpl :: descramble ( ScramblingControl scramblingControl , const hidl_vec < SubSample > & subSamples , const SharedBuffer & srcBuffer , uint64_t srcOffset , const DestinationBuffer & dstBuffer , uint64_t dstOffset , descramble_cb _hidl_cb ) { ALOGV ( "%s" , __FUNCTION__ ) ; sp < IMemory > srcMem = mapMemory ( srcBuffer . heapBase ) ; if ( srcMem == NULL ) { ALOGE ( "Failed to map src buffer." ) ; _hidl_cb ( toStatus ( BAD_VALUE ) , 0 , NULL ) ; return Void ( ) ; } if ( ! validateRangeForSize ( srcBuffer . offset , srcBuffer . size , ( uint64_t ) srcMem -> getSize ( ) ) ) { ALOGE ( "Invalid src buffer range: offset %llu, size %llu, srcMem size %llu" , srcBuffer . offset , srcBuffer . size , ( uint64_t ) srcMem -> getSize ( ) ) ; android_errorWriteLog ( 0x534e4554 , "67962232" ) ; _hidl_cb ( toStatus ( BAD_VALUE ) , 0 , NULL ) ; return Void ( ) ; } uint64_t totalBytesInSubSamples = 0 ; for ( size_t i = 0 ; i < subSamples . size ( ) ; i ++ ) { totalBytesInSubSamples += ( uint64_t ) subSamples [ i ] . numBytesOfClearData + subSamples [ i ] . numBytesOfEncryptedData ; } if ( ! validateRangeForSize ( srcOffset , totalBytesInSubSamples , srcBuffer . size ) ) { ALOGE ( "Invalid srcOffset and subsample size: " "srcOffset %llu, totalBytesInSubSamples %llu, srcBuffer size %llu" , srcOffset , totalBytesInSubSamples , srcBuffer . size ) ; android_errorWriteLog ( 0x534e4554 , "67962232" ) ; _hidl_cb ( toStatus ( BAD_VALUE ) , 0 , NULL ) ; return Void ( ) ; } void * srcPtr = ( uint8_t * ) ( void * ) srcMem -> getPointer ( ) + srcBuffer . offset ; void * dstPtr = NULL ; if ( dstBuffer . type == BufferType :: SHARED_MEMORY ) { dstPtr = srcPtr ; if ( ! validateRangeForSize ( dstOffset , totalBytesInSubSamples , srcBuffer . size ) ) { ALOGE ( "Invalid dstOffset and subsample size: " "dstOffset %llu, totalBytesInSubSamples %llu, srcBuffer size %llu" , dstOffset , totalBytesInSubSamples , srcBuffer . size ) ; android_errorWriteLog ( 0x534e4554 , "67962232" ) ; _hidl_cb ( toStatus ( BAD_VALUE ) , 0 , NULL ) ; return Void ( ) ; } } else { native_handle_t * handle = const_cast < native_handle_t * > ( dstBuffer . secureMemory . getNativeHandle ( ) ) ; dstPtr = static_cast < void * > ( handle ) ; } int32_t result = mPlugin -> descramble ( dstBuffer . type != BufferType :: SHARED_MEMORY , ( DescramblerPlugin :: ScramblingControl ) scramblingControl , subSamples . size ( ) , ( DescramblerPlugin :: SubSample * ) subSamples . data ( ) , srcPtr , srcOffset , dstPtr , dstOffset , NULL ) ; _hidl_cb ( toStatus ( result >= 0 ? OK : result ) , result , NULL ) ; return Void ( ) ; }
InitClass ( JSContext * aCx , JSObject * aObj , JSObject * aParentProto , bool aMainRuntime ) { JSObject * proto = js :: InitClassWithReserved ( aCx , aObj , aParentProto , Class ( ) , Construct , 0 , sProperties , sFunctions , NULL , NULL ) ; if ( ! proto ) { return NULL ; } if ( ! aMainRuntime ) { WorkerPrivate * parent = GetWorkerPrivateFromContext ( aCx ) ; parent -> AssertIsOnWorkerThread ( ) ; JSObject * constructor = JS_GetConstructor ( aCx , proto ) ; if ( ! constructor ) return NULL ; js :: SetFunctionNativeReserved ( constructor , CONSTRUCTOR_SLOT_PARENT , PRIVATE_TO_JSVAL ( parent ) ) ; } return proto ; }
void Heap :: UnprotectAndRegisterMemoryChunk ( MemoryChunk * chunk ) { if ( unprotected_memory_chunks_registry_enabled_ ) { base :: LockGuard < base :: Mutex > guard ( & unprotected_memory_chunks_mutex_ ) ; if ( unprotected_memory_chunks_ . insert ( chunk ) . second ) { chunk -> SetReadAndWritable ( ) ; } } }
JS_CloneFunctionObject ( JSContext * cx , JSObject * funobjArg , JSRawObject parentArg ) { RootedObject funobj ( cx , funobjArg ) ; RootedObject parent ( cx , parentArg ) ; AssertHeapIsIdle ( cx ) ; CHECK_REQUEST ( cx ) ; assertSameCompartment ( cx , parent ) ; if ( ! parent ) parent = cx -> global ( ) ; if ( ! funobj -> isFunction ( ) ) { ReportIsNotFunction ( cx , ObjectValue ( * funobj ) ) ; return NULL ; } RootedFunction fun ( cx , funobj -> toFunction ( ) ) ; if ( fun -> isInterpreted ( ) && ( fun -> nonLazyScript ( ) -> enclosingStaticScope ( ) || ( fun -> nonLazyScript ( ) -> compileAndGo && ! parent -> isGlobal ( ) ) ) ) { JS_ReportErrorNumber ( cx , js_GetErrorMessage , NULL , JSMSG_BAD_CLONE_FUNOBJ_SCOPE ) ; return NULL ; } if ( fun -> isBoundFunction ( ) ) { JS_ReportErrorNumber ( cx , js_GetErrorMessage , NULL , JSMSG_CANT_CLONE_OBJECT ) ; return NULL ; } if ( fun -> isNative ( ) && IsAsmJSModuleNative ( fun -> native ( ) ) ) { JS_ReportErrorNumber ( cx , js_GetErrorMessage , NULL , JSMSG_CANT_CLONE_OBJECT ) ; return NULL ; } return CloneFunctionObject ( cx , fun , parent , fun -> getAllocKind ( ) ) ; }
base :: Optional < ParseResult > MakeConstDeclaration ( ParseResultIterator * child_results ) { auto name = child_results -> NextAs < std :: string > ( ) ; auto type = child_results -> NextAs < TypeExpression * > ( ) ; auto expression = child_results -> NextAs < Expression * > ( ) ; Declaration * result = MakeNode < ConstDeclaration > ( std :: move ( name ) , type , expression ) ; return ParseResult { result } ; }
void ComputeAsync ( OpKernelContext * context , DoneCallback done ) override { const Tensor & grads = context -> input ( 0 ) ; const Tensor & boxes = context -> input ( 1 ) ; const Tensor & box_index = context -> input ( 2 ) ; const Tensor & image_size = context -> input ( 3 ) ; OP_REQUIRES_ASYNC ( context , grads . dims ( ) == 4 , errors :: InvalidArgument ( "grads image must be 4-D" , grads . shape ( ) . DebugString ( ) ) , done ) ; const int crop_height = grads . dim_size ( 1 ) ; const int crop_width = grads . dim_size ( 2 ) ; OP_REQUIRES_ASYNC ( context , crop_height > 0 && crop_width > 0 , errors :: InvalidArgument ( "grads dimensions must be positive" ) , done ) ; int num_boxes = 0 ; OP_REQUIRES_OK_ASYNC ( context , ParseAndCheckBoxSizes ( boxes , box_index , & num_boxes ) , done ) ; OP_REQUIRES_ASYNC ( context , grads . dim_size ( 0 ) == num_boxes , errors :: InvalidArgument ( "boxes and grads have incompatible shape" ) , done ) ; OP_REQUIRES_ASYNC ( context , image_size . dims ( ) == 1 , errors :: InvalidArgument ( "image_size must be 1-D" , image_size . shape ( ) . DebugString ( ) ) , done ) ; OP_REQUIRES_ASYNC ( context , image_size . dim_size ( 0 ) == 4 , errors :: InvalidArgument ( "image_size must have 4 elements" , image_size . shape ( ) . DebugString ( ) ) , done ) ; auto image_size_vec = image_size . vec < int32 > ( ) ; const int batch_size = internal :: SubtleMustCopy ( image_size_vec ( 0 ) ) ; const int image_height = internal :: SubtleMustCopy ( image_size_vec ( 1 ) ) ; const int image_width = internal :: SubtleMustCopy ( image_size_vec ( 2 ) ) ; const int depth = internal :: SubtleMustCopy ( image_size_vec ( 3 ) ) ; OP_REQUIRES_ASYNC ( context , image_height > 0 && image_width > 0 , errors :: InvalidArgument ( "image dimensions must be positive" ) , done ) ; OP_REQUIRES_ASYNC ( context , grads . dim_size ( 3 ) == depth , errors :: InvalidArgument ( "image_size and grads are incompatible" ) , done ) ; if ( std :: is_same < Device , GPUDevice > :: value ) { OP_REQUIRES_ASYNC ( context , ! OpDeterminismRequired ( ) , errors :: Unimplemented ( "Deterministic GPU implementation of CropAndResizeBackpropImage" " not available." ) , done ) ; } Tensor * output = nullptr ; OP_REQUIRES_OK_ASYNC ( context , context -> allocate_output ( 0 , TensorShape ( { batch_size , image_height , image_width , depth } ) , & output ) , done ) ; auto compute_callback = [ this , context , output ] ( ) { const Tensor & grads = context -> input ( 0 ) ; const Tensor & boxes = context -> input ( 1 ) ; const Tensor & box_index = context -> input ( 2 ) ; const bool status = functor :: CropAndResizeBackpropImage < Device , T > ( ) ( context , grads . tensor < float , 4 > ( ) , boxes . tensor < float , 2 > ( ) , box_index . tensor < int32 , 1 > ( ) , output -> tensor < T , 4 > ( ) , method_ ) ; if ( ! status ) { context -> SetStatus ( errors :: Internal ( "Failed to launch CropAndResizeBackpropImage kernel." ) ) ; } } ; RunIfBoxIndexIsValid < Device > ( context , box_index . tensor < int32 , 1 > ( ) , batch_size , std :: move ( compute_callback ) , std :: move ( done ) ) ; }
bool Pass :: resolveCollisions ( Segment * seg , Slot * slotFix , Slot * start , ShiftCollider & coll , GR_MAYBE_UNUSED bool isRev , int dir , bool & moved , bool & hasCol , json * const dbgout ) const { Slot * nbor ; SlotCollision * cFix = seg -> collisionInfo ( slotFix ) ; if ( ! coll . initSlot ( seg , slotFix , cFix -> limit ( ) , cFix -> margin ( ) , cFix -> marginWt ( ) , cFix -> shift ( ) , cFix -> offset ( ) , dir , dbgout ) ) return false ; bool collides = false ; bool ignoreForKern = ! isRev ; bool rtl = dir & 1 ; Slot * base = slotFix ; while ( base -> attachedTo ( ) ) base = base -> attachedTo ( ) ; Position zero ( 0. , 0. ) ; for ( nbor = start ; nbor ; nbor = isRev ? nbor -> prev ( ) : nbor -> next ( ) ) { SlotCollision * cNbor = seg -> collisionInfo ( nbor ) ; bool sameCluster = nbor -> isChildOf ( base ) ; if ( nbor != slotFix && ! ( cNbor -> ignore ( ) ) && ( nbor == base || sameCluster || ! inKernCluster ( seg , nbor ) || ( rtl ^ ignoreForKern ) ) && ( ! isRev || ! ( cNbor -> flags ( ) & SlotCollision :: COLL_FIX ) || ( ( cNbor -> flags ( ) & SlotCollision :: COLL_KERN ) && ! sameCluster ) || ( cNbor -> flags ( ) & SlotCollision :: COLL_ISCOL ) ) && ! coll . mergeSlot ( seg , nbor , cNbor -> shift ( ) , ! ignoreForKern , sameCluster , collides , false , dbgout ) ) return false ; else if ( nbor == slotFix ) ignoreForKern = ! ignoreForKern ; if ( nbor != start && ( cNbor -> flags ( ) & ( isRev ? SlotCollision :: COLL_START : SlotCollision :: COLL_END ) ) ) break ; } bool isCol = false ; if ( collides || cFix -> shift ( ) . x != 0.f || cFix -> shift ( ) . y != 0.f ) { Position shift = coll . resolve ( seg , isCol , dbgout ) ; if ( std :: fabs ( shift . x ) < 1e38f && std :: fabs ( shift . y ) < 1e38f ) { if ( sqr ( shift . x - cFix -> shift ( ) . x ) + sqr ( shift . y - cFix -> shift ( ) . y ) >= m_colThreshold * m_colThreshold ) moved = true ; cFix -> setShift ( shift ) ; if ( slotFix -> firstChild ( ) ) { Rect bbox ; Position here = slotFix -> origin ( ) + shift ; float clusterMin = here . x ; slotFix -> firstChild ( ) -> finalise ( seg , NULL , here , bbox , 0 , clusterMin , rtl , false ) ; } } } else { #if !defined GRAPHITE2_NTRACING if ( dbgout ) { * dbgout < < json :: object < < "missed" < < objectid ( dslot ( seg , slotFix ) ) ; coll . outputJsonDbg ( dbgout , seg , - 1 ) ; * dbgout < < json :: close ; } #endif } if ( isCol ) { cFix -> setFlags ( cFix -> flags ( ) | SlotCollision :: COLL_ISCOL | SlotCollision :: COLL_KNOWN ) ; } else { cFix -> setFlags ( ( cFix -> flags ( ) & ~ SlotCollision :: COLL_ISCOL ) | SlotCollision :: COLL_KNOWN ) ; } hasCol |= isCol ; return true ; }
af_latin2_hints_apply ( AF_GlyphHints hints , FT_Outline * outline , AF_LatinMetrics metrics ) { FT_Error error ; int dim ; error = af_glyph_hints_reload ( hints , outline ) ; if ( error ) goto Exit ; #ifdef AF_CONFIG_OPTION_USE_WARPER if ( ( metrics -> root . scaler . render_mode == FT_RENDER_MODE_LIGHT && AF_HINTS_DO_WARP ( hints ) ) || AF_HINTS_DO_HORIZONTAL ( hints ) ) #else if ( AF_HINTS_DO_HORIZONTAL ( hints ) ) #endif { error = af_latin2_hints_detect_features ( hints , AF_DIMENSION_HORZ ) ; if ( error ) goto Exit ; } if ( AF_HINTS_DO_VERTICAL ( hints ) ) { error = af_latin2_hints_detect_features ( hints , AF_DIMENSION_VERT ) ; if ( error ) goto Exit ; af_latin2_hints_compute_blue_edges ( hints , metrics ) ; } for ( dim = 0 ; dim < AF_DIMENSION_MAX ; dim ++ ) { #ifdef AF_CONFIG_OPTION_USE_WARPER if ( dim == AF_DIMENSION_HORZ && metrics -> root . scaler . render_mode == FT_RENDER_MODE_LIGHT && AF_HINTS_DO_WARP ( hints ) ) { AF_WarperRec warper ; FT_Fixed scale ; FT_Pos delta ; af_warper_compute ( & warper , hints , dim , & scale , & delta ) ; af_glyph_hints_scale_dim ( hints , dim , scale , delta ) ; continue ; } #endif /* AF_CONFIG_OPTION_USE_WARPER */ if ( ( dim == AF_DIMENSION_HORZ && AF_HINTS_DO_HORIZONTAL ( hints ) ) || ( dim == AF_DIMENSION_VERT && AF_HINTS_DO_VERTICAL ( hints ) ) ) { af_latin2_hint_edges ( hints , ( AF_Dimension ) dim ) ; af_glyph_hints_align_edge_points ( hints , ( AF_Dimension ) dim ) ; af_glyph_hints_align_strong_points ( hints , ( AF_Dimension ) dim ) ; af_glyph_hints_align_weak_points ( hints , ( AF_Dimension ) dim ) ; } } af_glyph_hints_save ( hints , outline ) ; Exit : return error ; }
void DoImageProjectiveTransformOp ( OpKernelContext * ctx , const Interpolation & interpolation , const Mode & fill_mode ) { const Tensor & images_t = ctx -> input ( 0 ) ; const Tensor & transform_t = ctx -> input ( 1 ) ; OP_REQUIRES ( ctx , images_t . shape ( ) . dims ( ) == 4 , errors :: InvalidArgument ( "Input images must have rank 4" ) ) ; OP_REQUIRES ( ctx , ( TensorShapeUtils :: IsMatrix ( transform_t . shape ( ) ) && ( transform_t . dim_size ( 0 ) == images_t . dim_size ( 0 ) || transform_t . dim_size ( 0 ) == 1 ) && transform_t . dim_size ( 1 ) == 8 ) , errors :: InvalidArgument ( "Input transform should be num_images x 8 or 1 x 8" ) ) ; int32_t out_height , out_width ; if ( ctx -> num_inputs ( ) >= 3 ) { const Tensor & shape_t = ctx -> input ( 2 ) ; OP_REQUIRES ( ctx , shape_t . dims ( ) == 1 , errors :: InvalidArgument ( "output shape must be 1-dimensional" , shape_t . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , shape_t . NumElements ( ) == 2 , errors :: InvalidArgument ( "output shape must have two elements" , shape_t . shape ( ) . DebugString ( ) ) ) ; auto shape_vec = shape_t . vec < int32 > ( ) ; out_height = shape_vec ( 0 ) ; out_width = shape_vec ( 1 ) ; OP_REQUIRES ( ctx , out_height > 0 && out_width > 0 , errors :: InvalidArgument ( "output dimensions must be positive" ) ) ; } else { out_height = images_t . shape ( ) . dim_size ( 1 ) ; out_width = images_t . shape ( ) . dim_size ( 2 ) ; } T fill_value ( 0 ) ; if ( ctx -> num_inputs ( ) >= 4 ) { const Tensor & fill_value_t = ctx -> input ( 3 ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsScalar ( fill_value_t . shape ( ) ) , errors :: InvalidArgument ( "fill_value must be a scalar" , fill_value_t . shape ( ) . DebugString ( ) ) ) ; fill_value = static_cast < T > ( * ( fill_value_t . scalar < float > ( ) . data ( ) ) ) ; } Tensor * output_t ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { images_t . dim_size ( 0 ) , out_height , out_width , images_t . dim_size ( 3 ) } ) , & output_t ) ) ; auto output = output_t -> tensor < T , 4 > ( ) ; auto images = images_t . tensor < T , 4 > ( ) ; auto transform = transform_t . matrix < float > ( ) ; ( FillProjectiveTransform < Device , T > ( interpolation ) ) ( ctx -> eigen_device < Device > ( ) , & output , images , transform , fill_mode , fill_value ) ; }
static int __blkdev_get ( struct block_device * bdev , fmode_t mode , int for_part ) { struct gendisk * disk ; int ret ; int partno ; int perm = 0 ; bool first_open = false ; if ( mode & FMODE_READ ) perm |= MAY_READ ; if ( mode & FMODE_WRITE ) perm |= MAY_WRITE ; if ( ! for_part ) { ret = devcgroup_inode_permission ( bdev -> bd_inode , perm ) ; if ( ret != 0 ) { bdput ( bdev ) ; return ret ; } } restart : ret = - ENXIO ; disk = bdev_get_gendisk ( bdev , & partno ) ; if ( ! disk ) goto out ; disk_block_events ( disk ) ; mutex_lock_nested ( & bdev -> bd_mutex , for_part ) ; if ( ! bdev -> bd_openers ) { first_open = true ; bdev -> bd_disk = disk ; bdev -> bd_queue = disk -> queue ; bdev -> bd_contains = bdev ; bdev -> bd_partno = partno ; if ( ! partno ) { ret = - ENXIO ; bdev -> bd_part = disk_get_part ( disk , partno ) ; if ( ! bdev -> bd_part ) goto out_clear ; ret = 0 ; if ( disk -> fops -> open ) { ret = disk -> fops -> open ( bdev , mode ) ; if ( ret == - ERESTARTSYS ) { disk_put_part ( bdev -> bd_part ) ; bdev -> bd_part = NULL ; bdev -> bd_disk = NULL ; bdev -> bd_queue = NULL ; mutex_unlock ( & bdev -> bd_mutex ) ; disk_unblock_events ( disk ) ; put_disk_and_module ( disk ) ; goto restart ; } } if ( ! ret ) { bd_set_size ( bdev , ( loff_t ) get_capacity ( disk ) < < 9 ) ; set_init_blocksize ( bdev ) ; } if ( bdev -> bd_invalidated && ( ! ret || ret == - ENOMEDIUM ) ) bdev_disk_changed ( bdev , ret == - ENOMEDIUM ) ; if ( ret ) goto out_clear ; } else { struct block_device * whole ; whole = bdget_disk ( disk , 0 ) ; ret = - ENOMEM ; if ( ! whole ) goto out_clear ; BUG_ON ( for_part ) ; ret = __blkdev_get ( whole , mode , 1 ) ; if ( ret ) goto out_clear ; bdev -> bd_contains = whole ; bdev -> bd_part = disk_get_part ( disk , partno ) ; if ( ! ( disk -> flags & GENHD_FL_UP ) || ! bdev -> bd_part || ! bdev -> bd_part -> nr_sects ) { ret = - ENXIO ; goto out_clear ; } bd_set_size ( bdev , ( loff_t ) bdev -> bd_part -> nr_sects < < 9 ) ; set_init_blocksize ( bdev ) ; } if ( bdev -> bd_bdi == & noop_backing_dev_info ) bdev -> bd_bdi = bdi_get ( disk -> queue -> backing_dev_info ) ; } else { if ( bdev -> bd_contains == bdev ) { ret = 0 ; if ( bdev -> bd_disk -> fops -> open ) ret = bdev -> bd_disk -> fops -> open ( bdev , mode ) ; if ( bdev -> bd_invalidated && ( ! ret || ret == - ENOMEDIUM ) ) bdev_disk_changed ( bdev , ret == - ENOMEDIUM ) ; if ( ret ) goto out_unlock_bdev ; } } bdev -> bd_openers ++ ; if ( for_part ) bdev -> bd_part_count ++ ; mutex_unlock ( & bdev -> bd_mutex ) ; disk_unblock_events ( disk ) ; if ( ! first_open ) put_disk_and_module ( disk ) ; return 0 ; out_clear : disk_put_part ( bdev -> bd_part ) ; bdev -> bd_disk = NULL ; bdev -> bd_part = NULL ; bdev -> bd_queue = NULL ; if ( bdev != bdev -> bd_contains ) __blkdev_put ( bdev -> bd_contains , mode , 1 ) ; bdev -> bd_contains = NULL ; out_unlock_bdev : mutex_unlock ( & bdev -> bd_mutex ) ; disk_unblock_events ( disk ) ; put_disk_and_module ( disk ) ; out : bdput ( bdev ) ; return ret ; }
OPJ_BOOL OPJ_CALLCONV opj_setup_encoder ( opj_codec_t * p_codec , opj_cparameters_t * parameters , opj_image_t * p_image ) { if ( p_codec && parameters && p_image ) { opj_codec_private_t * l_codec = ( opj_codec_private_t * ) p_codec ; if ( ! l_codec -> is_decompressor ) { return l_codec -> m_codec_data . m_compression . opj_setup_encoder ( l_codec -> m_codec , parameters , p_image , & ( l_codec -> m_event_mgr ) ) ; } } return OPJ_FALSE ; }
static void wacom_wireless_work ( struct work_struct * work ) { struct wacom * wacom = container_of ( work , struct wacom , wireless_work ) ; struct usb_device * usbdev = wacom -> usbdev ; struct wacom_wac * wacom_wac = & wacom -> wacom_wac ; struct hid_device * hdev1 , * hdev2 ; struct wacom * wacom1 , * wacom2 ; struct wacom_wac * wacom_wac1 , * wacom_wac2 ; int error ; wacom_destroy_battery ( wacom ) ; hdev1 = usb_get_intfdata ( usbdev -> config -> interface [ 1 ] ) ; wacom1 = hid_get_drvdata ( hdev1 ) ; wacom_wac1 = & ( wacom1 -> wacom_wac ) ; wacom_release_resources ( wacom1 ) ; hdev2 = usb_get_intfdata ( usbdev -> config -> interface [ 2 ] ) ; wacom2 = hid_get_drvdata ( hdev2 ) ; wacom_wac2 = & ( wacom2 -> wacom_wac ) ; wacom_release_resources ( wacom2 ) ; if ( wacom_wac -> pid == 0 ) { hid_info ( wacom -> hdev , "wireless tablet disconnected\n" ) ; } else { const struct hid_device_id * id = wacom_ids ; hid_info ( wacom -> hdev , "wireless tablet connected with PID %x\n" , wacom_wac -> pid ) ; while ( id -> bus ) { if ( id -> vendor == USB_VENDOR_ID_WACOM && id -> product == wacom_wac -> pid ) break ; id ++ ; } if ( ! id -> bus ) { hid_info ( wacom -> hdev , "ignoring unknown PID.\n" ) ; return ; } wacom_wac1 -> features = * ( ( struct wacom_features * ) id -> driver_data ) ; wacom_wac1 -> pid = wacom_wac -> pid ; hid_hw_stop ( hdev1 ) ; error = wacom_parse_and_register ( wacom1 , true ) ; if ( error ) goto fail ; if ( wacom_wac1 -> features . touch_max || ( wacom_wac1 -> features . type >= INTUOSHT && wacom_wac1 -> features . type <= BAMBOO_PT ) ) { wacom_wac2 -> features = * ( ( struct wacom_features * ) id -> driver_data ) ; wacom_wac2 -> pid = wacom_wac -> pid ; hid_hw_stop ( hdev2 ) ; error = wacom_parse_and_register ( wacom2 , true ) ; if ( error ) goto fail ; } strlcpy ( wacom_wac -> name , wacom_wac1 -> name , sizeof ( wacom_wac -> name ) ) ; error = wacom_initialize_battery ( wacom ) ; if ( error ) goto fail ; } return ; fail : wacom_release_resources ( wacom1 ) ; wacom_release_resources ( wacom2 ) ; return ; }
void Compute ( OpKernelContext * context ) override { auto min_input_tensor = context -> input ( 1 ) ; auto max_input_tensor = context -> input ( 2 ) ; OP_REQUIRES ( context , min_input_tensor . NumElements ( ) == 1 , errors :: InvalidArgument ( "min_input must be a scalar float value, got tensor with shape " , min_input_tensor . shape ( ) ) ) ; OP_REQUIRES ( context , max_input_tensor . NumElements ( ) == 1 , errors :: InvalidArgument ( "max_input must be a scalar float value, got tensor with shape " , max_input_tensor . shape ( ) ) ) ; const float min_input = context -> input ( 1 ) . flat < float > ( ) ( 0 ) ; const float max_input = context -> input ( 2 ) . flat < float > ( ) ( 0 ) ; MaxPoolingOp < Device , T > :: Compute ( context ) ; Tensor * output_min = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 1 , { } , & output_min ) ) ; output_min -> flat < float > ( ) ( 0 ) = min_input ; Tensor * output_max = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 2 , { } , & output_max ) ) ; output_max -> flat < float > ( ) ( 0 ) = max_input ; }
static void parse_time ( pj_scanner * scanner , pjmedia_sdp_session * ses , volatile parse_context * ctx ) { pj_str_t str ; ctx -> last_error = PJMEDIA_SDP_EINTIME ; if ( * ( scanner -> curptr + 1 ) != '=' ) { on_scanner_error ( scanner ) ; return ; } pj_scan_advance_n ( scanner , 2 , SKIP_WS ) ; pj_scan_get_until_ch ( scanner , ' ' , & str ) ; ses -> time . start = pj_strtoul ( & str ) ; pj_scan_get_char ( scanner ) ; pj_scan_get_until_chr ( scanner , " \t\r\n" , & str ) ; ses -> time . stop = pj_strtoul ( & str ) ; pj_scan_skip_line ( scanner ) ; }
de_dotdot ( char * file ) { char * cp ; char * cp2 ; int l ; while ( ( cp = strstr ( file , "//" ) ) != ( char * ) 0 ) { for ( cp2 = cp + 2 ; * cp2 == '/' ; ++ cp2 ) continue ; ( void ) strcpy ( cp + 1 , cp2 ) ; } while ( strncmp ( file , "./" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ; while ( ( cp = strstr ( file , "/./" ) ) != ( char * ) 0 ) ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; for ( ; ; ) { while ( strncmp ( file , "../" , 3 ) == 0 ) ( void ) memmove ( file , file + 3 , strlen ( file ) - 2 ) ; cp = strstr ( file , "/../" ) ; if ( cp == ( char * ) 0 ) break ; for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; ( void ) strcpy ( cp2 + 1 , cp + 4 ) ; } while ( ( l = strlen ( file ) ) > 3 && strcmp ( ( cp = file + l - 3 ) , "/.." ) == 0 ) { for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; if ( cp2 < file ) break ; * cp2 = '\0' ; } }
TNode < MaybeObject > AccessorAssembler :: TryMonomorphicCase ( Node * slot , Node * vector , Node * receiver_map , Label * if_handler , TVariable < MaybeObject > * var_handler , Label * if_miss ) { Comment ( "TryMonomorphicCase" ) ; DCHECK_EQ ( MachineRepresentation :: kTagged , var_handler -> rep ( ) ) ; CSA_ASSERT ( this , IsFeedbackVector ( vector ) , vector ) ; int32_t header_size = FeedbackVector :: kFeedbackSlotsOffset - kHeapObjectTag ; Node * offset = ElementOffsetFromIndex ( slot , HOLEY_ELEMENTS , SMI_PARAMETERS ) ; TNode < MaybeObject > feedback = ReinterpretCast < MaybeObject > ( Load ( MachineType :: AnyTagged ( ) , vector , IntPtrAdd ( offset , IntPtrConstant ( header_size ) ) ) ) ; GotoIf ( IsNotWeakReferenceTo ( feedback , CAST ( receiver_map ) ) , if_miss ) ; TNode < MaybeObject > handler = UncheckedCast < MaybeObject > ( Load ( MachineType :: AnyTagged ( ) , vector , IntPtrAdd ( offset , IntPtrConstant ( header_size + kPointerSize ) ) ) ) ; * var_handler = handler ; Goto ( if_handler ) ; return feedback ; }
static int v9fs_xattr_set_acl ( const struct xattr_handler * handler , struct dentry * dentry , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { int retval ; struct posix_acl * acl ; struct v9fs_session_info * v9ses ; v9ses = v9fs_dentry2v9ses ( dentry ) ; if ( ( v9ses -> flags & V9FS_ACCESS_MASK ) != V9FS_ACCESS_CLIENT ) return v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( value ) { acl = posix_acl_from_xattr ( & init_user_ns , value , size ) ; if ( IS_ERR ( acl ) ) return PTR_ERR ( acl ) ; else if ( acl ) { retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ; if ( retval ) goto err_out ; } } else acl = NULL ; switch ( handler -> flags ) { case ACL_TYPE_ACCESS : if ( acl ) { umode_t mode = inode -> i_mode ; retval = posix_acl_equiv_mode ( acl , & mode ) ; if ( retval < 0 ) goto err_out ; else { struct iattr iattr ; if ( retval == 0 ) { acl = NULL ; value = NULL ; size = 0 ; } iattr . ia_mode = ( ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ) ; iattr . ia_valid = ATTR_MODE ; v9fs_vfs_setattr_dotl ( dentry , & iattr ) ; } } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { retval = acl ? - EINVAL : 0 ; goto err_out ; } break ; default : BUG ( ) ; } retval = v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( ! retval ) set_cached_acl ( inode , handler -> flags , acl ) ; err_out : posix_acl_release ( acl ) ; return retval ; }
status_t ScreenshotClient :: capture ( const sp < IBinder > & display , Rect sourceCrop , uint32_t reqWidth , uint32_t reqHeight , int32_t minLayerZ , int32_t maxLayerZ , bool useIdentityTransform , uint32_t rotation , bool captureSecureLayers , sp < GraphicBuffer > * outBuffer ) { sp < ISurfaceComposer > s ( ComposerService :: getComposerService ( ) ) ; if ( s == NULL ) return NO_INIT ; status_t ret = s -> captureScreen ( display , outBuffer , sourceCrop , reqWidth , reqHeight , minLayerZ , maxLayerZ , useIdentityTransform , static_cast < ISurfaceComposer :: Rotation > ( rotation ) , captureSecureLayers ) ; if ( ret != NO_ERROR ) { return ret ; } return ret ; }
static struct hid_field * hid_register_field ( struct hid_report * report , unsigned usages , unsigned values ) { struct hid_field * field ; if ( report -> maxfield == HID_MAX_FIELDS ) { hid_err ( report -> device , "too many fields in report\n" ) ; return NULL ; } field = kzalloc ( ( sizeof ( struct hid_field ) + usages * sizeof ( struct hid_usage ) + values * sizeof ( unsigned ) ) , GFP_KERNEL ) ; if ( ! field ) return NULL ; field -> index = report -> maxfield ++ ; report -> field [ field -> index ] = field ; field -> usage = ( struct hid_usage * ) ( field + 1 ) ; field -> value = ( s32 * ) ( field -> usage + usages ) ; field -> report = report ; return field ; }
static void validate_stream_config ( const struct stream_state * stream , const struct VpxEncoderConfig * global ) { const struct stream_state * streami ; if ( ! stream -> config . cfg . g_w || ! stream -> config . cfg . g_h ) fatal ( "Stream %d: Specify stream dimensions with --width (-w) " " and --height (-h)" , stream -> index ) ; if ( stream -> config . cfg . g_profile != 0 && ! global -> experimental_bitstream ) { fatal ( "Stream %d: profile %d is experimental and requires the --%s flag" , stream -> index , stream -> config . cfg . g_profile , experimental_bitstream . long_name ) ; } for ( streami = stream ; streami ; streami = streami -> next ) { if ( ! streami -> config . out_fn ) fatal ( "Stream %d: Output file is required (specify with -o)" , streami -> index ) ; if ( streami != stream ) { const char * a = stream -> config . out_fn ; const char * b = streami -> config . out_fn ; if ( ! strcmp ( a , b ) && strcmp ( a , "/dev/null" ) && strcmp ( a , ":nul" ) ) fatal ( "Stream %d: duplicate output file (from stream %d)" , streami -> index , stream -> index ) ; } if ( streami != stream ) { const char * a = stream -> config . stats_fn ; const char * b = streami -> config . stats_fn ; if ( a && b && ! strcmp ( a , b ) ) fatal ( "Stream %d: duplicate stats file (from stream %d)" , streami -> index , stream -> index ) ; } } }
TryEnablingIon ( JSContext * cx , AsmJSModule & module , HandleFunction fun , uint32_t exitIndex , int32_t argc , Value * argv ) { if ( ! fun -> hasScript ( ) ) return true ; JSScript * script = fun -> nonLazyScript ( ) ; if ( ! script -> hasIonScript ( ) ) return true ; if ( fun -> nargs ( ) > size_t ( argc ) ) return true ; if ( ! types :: TypeScript :: ThisTypes ( script ) -> hasType ( types :: Type :: UndefinedType ( ) ) ) return true ; for ( uint32_t i = 0 ; i < fun -> nargs ( ) ; i ++ ) { types :: StackTypeSet * typeset = types :: TypeScript :: ArgTypes ( script , i ) ; types :: Type type = types :: Type :: DoubleType ( ) ; if ( ! argv [ i ] . isDouble ( ) ) type = types :: Type :: PrimitiveType ( argv [ i ] . extractNonDoubleType ( ) ) ; if ( ! typeset -> hasType ( type ) ) return true ; } IonScript * ionScript = script -> ionScript ( ) ; if ( ! ionScript -> addDependentAsmJSModule ( cx , DependentAsmJSModuleExit ( & module , exitIndex ) ) ) return false ; module . exitIndexToGlobalDatum ( exitIndex ) . exit = module . ionExitTrampoline ( module . exit ( exitIndex ) ) ; return true ; }
static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; pipe_buf_get ( ipipe , ibuf ) ; obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
void ProcessQueue ( Node * root ) { ZoneQueue < Node * > * queue = & ( scheduler_ -> schedule_queue_ ) ; for ( Node * node : root -> inputs ( ) ) { if ( scheduler_ -> GetPlacement ( node ) == Scheduler :: kCoupled ) { node = NodeProperties :: GetControlInput ( node ) ; } if ( scheduler_ -> GetData ( node ) -> unscheduled_count_ != 0 ) continue ; queue -> push ( node ) ; do { Node * const node = queue -> front ( ) ; queue -> pop ( ) ; VisitNode ( node ) ; } while ( ! queue -> empty ( ) ) ; } }
static int filter_frame ( AVFilterLink * inlink , AVFrame * buf ) { AVFilterContext * ctx = inlink -> dst ; FPSContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int64_t delta ; int i , ret ; s -> frames_in ++ ; if ( s -> pts == AV_NOPTS_VALUE ) { if ( buf -> pts != AV_NOPTS_VALUE ) { ret = write_to_fifo ( s -> fifo , buf ) ; if ( ret < 0 ) return ret ; if ( s -> start_time != DBL_MAX && s -> start_time != AV_NOPTS_VALUE ) { double first_pts = s -> start_time * AV_TIME_BASE ; first_pts = FFMIN ( FFMAX ( first_pts , INT64_MIN ) , INT64_MAX ) ; s -> first_pts = s -> pts = av_rescale_q ( first_pts , AV_TIME_BASE_Q , inlink -> time_base ) ; av_log ( ctx , AV_LOG_VERBOSE , "Set first pts to (in:%"PRId64 " out:%"PRId64 ")\n" , s -> first_pts , av_rescale_q ( first_pts , AV_TIME_BASE_Q , outlink -> time_base ) ) ; } else { s -> first_pts = s -> pts = buf -> pts ; } } else { av_log ( ctx , AV_LOG_WARNING , "Discarding initial frame(s) with no " "timestamp.\n" ) ; av_frame_free ( & buf ) ; s -> drop ++ ; } return 0 ; } if ( buf -> pts == AV_NOPTS_VALUE ) { return write_to_fifo ( s -> fifo , buf ) ; } delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ) ; if ( delta < 1 ) { AVFrame * tmp ; int drop = av_fifo_size ( s -> fifo ) / sizeof ( AVFrame * ) ; av_log ( ctx , AV_LOG_DEBUG , "Dropping %d frame(s).\n" , drop ) ; s -> drop += drop ; av_fifo_generic_read ( s -> fifo , & tmp , sizeof ( tmp ) , NULL ) ; flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , tmp ) ; av_frame_free ( & buf ) ; return ret ; } for ( i = 0 ; i < delta ; i ++ ) { AVFrame * buf_out ; av_fifo_generic_read ( s -> fifo , & buf_out , sizeof ( buf_out ) , NULL ) ; if ( ! av_fifo_size ( s -> fifo ) && i < delta - 1 ) { AVFrame * dup = av_frame_clone ( buf_out ) ; av_log ( ctx , AV_LOG_DEBUG , "Duplicating frame.\n" ) ; if ( dup ) ret = write_to_fifo ( s -> fifo , dup ) ; else ret = AVERROR ( ENOMEM ) ; if ( ret < 0 ) { av_frame_free ( & buf_out ) ; av_frame_free ( & buf ) ; return ret ; } s -> dup ++ ; } buf_out -> pts = av_rescale_q ( s -> first_pts , inlink -> time_base , outlink -> time_base ) + s -> frames_out ; if ( ( ret = ff_filter_frame ( outlink , buf_out ) ) < 0 ) { av_frame_free ( & buf ) ; return ret ; } s -> frames_out ++ ; } flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , buf ) ; s -> pts = s -> first_pts + av_rescale_q ( s -> frames_out , outlink -> time_base , inlink -> time_base ) ; return ret ; }
tt_cmap8_char_index ( TT_CMap cmap , FT_UInt32 char_code ) { FT_Byte * table = cmap -> data ; FT_UInt result = 0 ; FT_Byte * p = table + 8204 ; FT_UInt32 num_groups = TT_NEXT_ULONG ( p ) ; FT_UInt32 start , end , start_id ; for ( ; num_groups > 0 ; num_groups -- ) { start = TT_NEXT_ULONG ( p ) ; end = TT_NEXT_ULONG ( p ) ; start_id = TT_NEXT_ULONG ( p ) ; if ( char_code < start ) break ; if ( char_code <= end ) { result = ( FT_UInt ) ( start_id + char_code - start ) ; break ; } } return result ; }
static OPJ_BOOL opj_j2k_write_mct_record ( opj_j2k_t * p_j2k , opj_mct_data_t * p_mct_record , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { OPJ_UINT32 l_mct_size ; OPJ_BYTE * l_current_data = 00 ; OPJ_UINT32 l_tmp ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; l_mct_size = 10 + p_mct_record -> m_data_size ; if ( l_mct_size > p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size ) { OPJ_BYTE * new_header_tile_data = ( OPJ_BYTE * ) opj_realloc ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mct_size ) ; if ( ! new_header_tile_data ) { opj_free ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data ) ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data = NULL ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = 0 ; opj_event_msg ( p_manager , EVT_ERROR , "Not enough memory to write MCT marker\n" ) ; return OPJ_FALSE ; } p_j2k -> m_specific_param . m_encoder . m_header_tile_data = new_header_tile_data ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = l_mct_size ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; opj_write_bytes ( l_current_data , J2K_MS_MCT , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , l_mct_size - 2 , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , 0 , 2 ) ; l_current_data += 2 ; l_tmp = ( p_mct_record -> m_index & 0xff ) | ( p_mct_record -> m_array_type < < 8 ) | ( p_mct_record -> m_element_type < < 10 ) ; opj_write_bytes ( l_current_data , l_tmp , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , 0 , 2 ) ; l_current_data += 2 ; memcpy ( l_current_data , p_mct_record -> m_data , p_mct_record -> m_data_size ) ; if ( opj_stream_write_data ( p_stream , p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mct_size , p_manager ) != l_mct_size ) { return OPJ_FALSE ; } return OPJ_TRUE ; }
zfs_groupmember ( zfsvfs_t * zfsvfs , uint64_t id , cred_t * cr ) { #ifdef HAVE_KSID ksid_t * ksid = crgetsid ( cr , KSID_GROUP ) ; ksidlist_t * ksidlist = crgetsidlist ( cr ) ; uid_t gid ; if ( ksid && ksidlist ) { int i ; ksid_t * ksid_groups ; uint32_t idx = FUID_INDEX ( id ) ; uint32_t rid = FUID_RID ( id ) ; ksid_groups = ksidlist -> ksl_sids ; for ( i = 0 ; i != ksidlist -> ksl_nsid ; i ++ ) { if ( idx == 0 ) { if ( id != IDMAP_WK_CREATOR_GROUP_GID && id == ksid_groups [ i ] . ks_id ) { return ( B_TRUE ) ; } } else { const char * domain ; domain = zfs_fuid_find_by_idx ( zfsvfs , idx ) ; ASSERT ( domain != NULL ) ; if ( strcmp ( domain , IDMAP_WK_CREATOR_SID_AUTHORITY ) == 0 ) return ( B_FALSE ) ; if ( ( strcmp ( domain , ksid_groups [ i ] . ks_domain -> kd_name ) == 0 ) && rid == ksid_groups [ i ] . ks_rid ) return ( B_TRUE ) ; } } } gid = zfs_fuid_map_id ( zfsvfs , id , cr , ZFS_GROUP ) ; return ( groupmember ( gid , cr ) ) ; #else return ( B_TRUE ) ; #endif }
xmlParsePI ( xmlParserCtxtPtr ctxt ) { xmlChar * buf = NULL ; size_t len = 0 ; size_t size = XML_PARSER_BUFFER_SIZE ; int cur , l ; const xmlChar * target ; xmlParserInputState state ; int count = 0 ; if ( ( RAW == '<' ) && ( NXT ( 1 ) == '?' ) ) { xmlParserInputPtr input = ctxt -> input ; state = ctxt -> instate ; ctxt -> instate = XML_PARSER_PI ; SKIP ( 2 ) ; SHRINK ; target = xmlParsePITarget ( ctxt ) ; if ( target != NULL ) { if ( ( RAW == '?' ) && ( NXT ( 1 ) == '>' ) ) { if ( input != ctxt -> input ) { xmlFatalErrMsg ( ctxt , XML_ERR_ENTITY_BOUNDARY , "PI declaration doesn't start and stop in the same entity\n" ) ; } SKIP ( 2 ) ; if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData , target , NULL ) ; if ( ctxt -> instate != XML_PARSER_EOF ) ctxt -> instate = state ; return ; } buf = ( xmlChar * ) xmlMallocAtomic ( size * sizeof ( xmlChar ) ) ; if ( buf == NULL ) { xmlErrMemory ( ctxt , NULL ) ; ctxt -> instate = state ; return ; } cur = CUR ; if ( ! IS_BLANK ( cur ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_SPACE_REQUIRED , "ParsePI: PI %s space expected\n" , target ) ; } SKIP_BLANKS ; cur = CUR_CHAR ( l ) ; while ( IS_CHAR ( cur ) && ( ( cur != '?' ) || ( NXT ( 1 ) != '>' ) ) ) { if ( len + 5 >= size ) { xmlChar * tmp ; size_t new_size = size * 2 ; tmp = ( xmlChar * ) xmlRealloc ( buf , new_size ) ; if ( tmp == NULL ) { xmlErrMemory ( ctxt , NULL ) ; xmlFree ( buf ) ; ctxt -> instate = state ; return ; } buf = tmp ; size = new_size ; } count ++ ; if ( count > 50 ) { GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) { xmlFree ( buf ) ; return ; } count = 0 ; if ( ( len > XML_MAX_TEXT_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_PI_NOT_FINISHED , "PI %s too big found" , target ) ; xmlFree ( buf ) ; ctxt -> instate = state ; return ; } } COPY_BUF ( l , buf , len , cur ) ; NEXTL ( l ) ; cur = CUR_CHAR ( l ) ; if ( cur == 0 ) { SHRINK ; GROW ; cur = CUR_CHAR ( l ) ; } } if ( ( len > XML_MAX_TEXT_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_PI_NOT_FINISHED , "PI %s too big found" , target ) ; xmlFree ( buf ) ; ctxt -> instate = state ; return ; } buf [ len ] = 0 ; if ( cur != '?' ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_PI_NOT_FINISHED , "ParsePI: PI %s never end ...\n" , target ) ; } else { if ( input != ctxt -> input ) { xmlFatalErrMsg ( ctxt , XML_ERR_SPACE_REQUIRED , "PI declaration doesn't start and stop in the same entity\n" ) ; } SKIP ( 2 ) ; #ifdef LIBXML_CATALOG_ENABLED if ( ( ( state == XML_PARSER_MISC ) || ( state == XML_PARSER_START ) ) && ( xmlStrEqual ( target , XML_CATALOG_PI ) ) ) { xmlCatalogAllow allow = xmlCatalogGetDefaults ( ) ; if ( ( allow == XML_CATA_ALLOW_DOCUMENT ) || ( allow == XML_CATA_ALLOW_ALL ) ) xmlParseCatalogPI ( ctxt , buf ) ; } #endif if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData , target , buf ) ; } xmlFree ( buf ) ; } else { xmlFatalErr ( ctxt , XML_ERR_PI_NOT_STARTED , NULL ) ; } if ( ctxt -> instate != XML_PARSER_EOF ) ctxt -> instate = state ; } }
js :: CompileAsmJS ( JSContext * cx , AsmJSParser & parser , ParseNode * stmtList , bool * validated ) { * validated = false ; if ( ! JSC :: MacroAssembler :: supportsFloatingPoint ( ) ) return Warn ( cx , JSMSG_USE_ASM_TYPE_FAIL , "Disabled by lack of floating point support" ) ; if ( cx -> runtime ( ) -> gcSystemPageSize != AsmJSPageSize ) return Warn ( cx , JSMSG_USE_ASM_TYPE_FAIL , "Disabled by non 4KiB system page size" ) ; if ( ! cx -> hasOption ( JSOPTION_ASMJS ) ) return Warn ( cx , JSMSG_USE_ASM_TYPE_FAIL , "Disabled by javascript.options.asmjs in about:config" ) ; if ( cx -> compartment ( ) -> debugMode ( ) ) return Warn ( cx , JSMSG_USE_ASM_TYPE_FAIL , "Disabled by debugger" ) ; if ( ! EnsureAsmJSSignalHandlersInstalled ( cx -> runtime ( ) ) ) return Warn ( cx , JSMSG_USE_ASM_TYPE_FAIL , "Platform missing signal handler support" ) ; # ifdef JS_WORKER_THREADS if ( OffThreadCompilationEnabled ( cx ) ) { if ( ! EnsureWorkerThreadsInitialized ( cx -> runtime ( ) ) ) return Warn ( cx , JSMSG_USE_ASM_TYPE_FAIL , "Failed compilation thread initialization" ) ; } # endif ScopedJSFreePtr < char > compilationTimeReport ; ScopedJSDeletePtr < AsmJSModule > module ; if ( ! CheckModule ( cx , parser , stmtList , & module , & compilationTimeReport ) ) return ! cx -> isExceptionPending ( ) ; RootedObject moduleObj ( cx , NewAsmJSModuleObject ( cx , & module ) ) ; if ( ! moduleObj ) return false ; FunctionBox * funbox = parser . pc -> maybeFunction -> pn_funbox ; RootedFunction moduleFun ( cx , NewAsmJSModuleFunction ( cx , funbox -> function ( ) , moduleObj ) ) ; if ( ! moduleFun ) return false ; JS_ASSERT ( funbox -> function ( ) -> isInterpreted ( ) ) ; funbox -> object = moduleFun ; * validated = true ; return Warn ( cx , JSMSG_USE_ASM_TYPE_OK , compilationTimeReport ) ; }
static int run_schema_dump_query ( struct callback_data * p , const char * zQuery ) { int rc ; char * zErr = 0 ; rc = sqlite3_exec ( p -> db , zQuery , dump_callback , p , & zErr ) ; if ( rc == SQLITE_CORRUPT ) { char * zQ2 ; int len = strlen30 ( zQuery ) ; fprintf ( p -> out , "/****** CORRUPTION ERROR *******/\n" ) ; if ( zErr ) { fprintf ( p -> out , "/****** %s ******/\n" , zErr ) ; sqlite3_free ( zErr ) ; zErr = 0 ; } zQ2 = malloc ( len + 100 ) ; if ( zQ2 == 0 ) return rc ; sqlite3_snprintf ( len + 100 , zQ2 , "%s ORDER BY rowid DESC" , zQuery ) ; rc = sqlite3_exec ( p -> db , zQ2 , dump_callback , p , & zErr ) ; if ( rc ) { fprintf ( p -> out , "/****** ERROR: %s ******/\n" , zErr ) ; } else { rc = SQLITE_CORRUPT ; } sqlite3_free ( zErr ) ; free ( zQ2 ) ; } return rc ; }
V8StackTraceId V8Debugger :: storeCurrentStackTrace ( const StringView & description ) { if ( ! m_maxAsyncCallStackDepth ) return V8StackTraceId ( ) ; v8 :: HandleScope scope ( m_isolate ) ; int contextGroupId = currentContextGroupId ( ) ; if ( ! contextGroupId ) return V8StackTraceId ( ) ; std :: shared_ptr < AsyncStackTrace > asyncStack = AsyncStackTrace :: capture ( this , contextGroupId , toString16 ( description ) , V8StackTraceImpl :: maxCallStackSizeToCapture ) ; if ( ! asyncStack ) return V8StackTraceId ( ) ; uintptr_t id = AsyncStackTrace :: store ( this , asyncStack ) ; m_allAsyncStacks . push_back ( std :: move ( asyncStack ) ) ; ++ m_asyncStacksCount ; collectOldAsyncStacksIfNeeded ( ) ; asyncTaskCandidateForStepping ( reinterpret_cast < void * > ( id ) , false ) ; return V8StackTraceId ( id , debuggerIdFor ( contextGroupId ) ) ; }
static int ext4_split_unwritten_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags ) { struct ext4_extent * ex , newex , orig_ex ; struct ext4_extent * ex1 = NULL ; struct ext4_extent * ex2 = NULL ; struct ext4_extent * ex3 = NULL ; ext4_lblk_t ee_block , eof_block ; unsigned int allocated , ee_len , depth ; ext4_fsblk_t newblock ; int err = 0 ; int may_zeroout ; ext_debug ( "ext4_split_unwritten_extents: inode %lu, logical" "block %llu, max_blocks %u\n" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len ) ; eof_block = ( inode -> i_size + inode -> i_sb -> s_blocksize - 1 ) > > inode -> i_sb -> s_blocksize_bits ; if ( eof_block < map -> m_lblk + map -> m_len ) eof_block = map -> m_lblk + map -> m_len ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; allocated = ee_len - ( map -> m_lblk - ee_block ) ; newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ; ex2 = ex ; orig_ex . ee_block = ex -> ee_block ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_store_pblock ( & orig_ex , ext4_ext_pblock ( ex ) ) ; may_zeroout = ee_block + ee_len <= eof_block ; if ( ( map -> m_lblk == ee_block ) && ( allocated <= map -> m_len ) ) return allocated ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; if ( map -> m_lblk > ee_block ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } if ( ! ex1 && allocated > map -> m_len ) ex2 -> ee_len = cpu_to_le16 ( map -> m_len ) ; if ( allocated > map -> m_len ) { unsigned int newdepth ; ex3 = & newex ; ex3 -> ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; ext4_ext_store_pblock ( ex3 , newblock + map -> m_len ) ; ex3 -> ee_len = cpu_to_le16 ( allocated - map -> m_len ) ; ext4_ext_mark_uninitialized ( ex3 ) ; err = ext4_ext_insert_extent ( handle , inode , path , ex3 , flags ) ; if ( err == - ENOSPC && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; newdepth = ext_depth ( inode ) ; ee_len -= ext4_ext_get_actual_len ( ex3 ) ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; may_zeroout = ee_block + ee_len <= eof_block ; depth = newdepth ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } ex = path [ depth ] . p_ext ; if ( ex2 != & newex ) ex2 = ex ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; allocated = map -> m_len ; } if ( ex1 && ex1 != ex ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } ex2 -> ee_block = cpu_to_le32 ( map -> m_lblk ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; ex2 -> ee_len = cpu_to_le16 ( allocated ) ; ext4_ext_mark_uninitialized ( ex2 ) ; if ( ex2 != ex ) goto insert ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; ext_debug ( "out here\n" ) ; goto out ; insert : err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err == - ENOSPC && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ? err : allocated ; fix_extent_len : ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }
static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { int min_log2_tile_cols , max_log2_tile_cols , ones ; vp9_get_tile_n_bits ( cm -> mi_cols , & min_log2_tile_cols , & max_log2_tile_cols ) ; ones = cm -> log2_tile_cols - min_log2_tile_cols ; while ( ones -- ) vp9_wb_write_bit ( wb , 1 ) ; if ( cm -> log2_tile_cols < max_log2_tile_cols ) vp9_wb_write_bit ( wb , 0 ) ; vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ; if ( cm -> log2_tile_rows != 0 ) vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ; }
CallDescriptor const * CallDescriptorOf ( const Operator * const op ) { DCHECK ( op -> opcode ( ) == IrOpcode :: kCall || op -> opcode ( ) == IrOpcode :: kCallWithCallerSavedRegisters || op -> opcode ( ) == IrOpcode :: kTailCall ) ; return OpParameter < CallDescriptor const * > ( op ) ; }
Blob ( const uint8_t * value , int32_t valueLength , const uint8_t * info , uint8_t infoLength , BlobType type ) { mBlob . length = valueLength ; memcpy ( mBlob . value , value , valueLength ) ; mBlob . info = infoLength ; memcpy ( mBlob . value + valueLength , info , infoLength ) ; mBlob . version = CURRENT_BLOB_VERSION ; mBlob . type = uint8_t ( type ) ; if ( type == TYPE_MASTER_KEY ) { mBlob . flags = KEYSTORE_FLAG_ENCRYPTED ; } else { mBlob . flags = KEYSTORE_FLAG_NONE ; } }
VisitResult ImplementationVisitor :: Visit ( AssumeTypeImpossibleExpression * expr ) { VisitResult result = Visit ( expr -> expression ) ; const Type * result_type = SubtractType ( result . type ( ) , declarations ( ) -> GetType ( expr -> excluded_type ) ) ; if ( result_type -> IsNever ( ) ) { ReportError ( "unreachable code" ) ; } return VisitResult { result_type , "UncheckedCast<" + result_type -> GetGeneratedTNodeTypeName ( ) + ">(" + result . RValue ( ) + ")" } ; }
SnapshotIterator :: SnapshotIterator ( const JitFrameIterator & iter ) : snapshot_ ( iter . ionScript ( ) -> snapshots ( ) , iter . osiIndex ( ) -> snapshotOffset ( ) , iter . ionScript ( ) -> snapshotsRVATableSize ( ) , iter . ionScript ( ) -> snapshotsListSize ( ) ) , recover_ ( snapshot_ , iter . ionScript ( ) -> recovers ( ) , iter . ionScript ( ) -> recoversSize ( ) ) , fp_ ( iter . jsFrame ( ) ) , machine_ ( iter . machineState ( ) ) , ionScript_ ( iter . ionScript ( ) ) , instructionResults_ ( nullptr ) { }
MPEG4Source :: MPEG4Source ( const sp < MPEG4Extractor > & owner , const sp < MetaData > & format , const sp < DataSource > & dataSource , int32_t timeScale , const sp < SampleTable > & sampleTable , Vector < SidxEntry > & sidx , const Trex * trex , off64_t firstMoofOffset ) : mOwner ( owner ) , mFormat ( format ) , mDataSource ( dataSource ) , mTimescale ( timeScale ) , mSampleTable ( sampleTable ) , mCurrentSampleIndex ( 0 ) , mCurrentFragmentIndex ( 0 ) , mSegments ( sidx ) , mTrex ( trex ) , mFirstMoofOffset ( firstMoofOffset ) , mCurrentMoofOffset ( firstMoofOffset ) , mCurrentTime ( 0 ) , mCurrentSampleInfoAllocSize ( 0 ) , mCurrentSampleInfoSizes ( NULL ) , mCurrentSampleInfoOffsetsAllocSize ( 0 ) , mCurrentSampleInfoOffsets ( NULL ) , mIsAVC ( false ) , mIsHEVC ( false ) , mNALLengthSize ( 0 ) , mStarted ( false ) , mGroup ( NULL ) , mBuffer ( NULL ) , mWantsNALFragments ( false ) , mSrcBuffer ( NULL ) { memset ( & mTrackFragmentHeaderInfo , 0 , sizeof ( mTrackFragmentHeaderInfo ) ) ; mFormat -> findInt32 ( kKeyCryptoMode , & mCryptoMode ) ; mDefaultIVSize = 0 ; mFormat -> findInt32 ( kKeyCryptoDefaultIVSize , & mDefaultIVSize ) ; uint32_t keytype ; const void * key ; size_t keysize ; if ( mFormat -> findData ( kKeyCryptoKey , & keytype , & key , & keysize ) ) { CHECK ( keysize <= 16 ) ; memset ( mCryptoKey , 0 , 16 ) ; memcpy ( mCryptoKey , key , keysize ) ; } const char * mime ; bool success = mFormat -> findCString ( kKeyMIMEType , & mime ) ; CHECK ( success ) ; mIsAVC = ! strcasecmp ( mime , MEDIA_MIMETYPE_VIDEO_AVC ) ; mIsHEVC = ! strcasecmp ( mime , MEDIA_MIMETYPE_VIDEO_HEVC ) ; if ( mIsAVC ) { uint32_t type ; const void * data ; size_t size ; CHECK ( format -> findData ( kKeyAVCC , & type , & data , & size ) ) ; const uint8_t * ptr = ( const uint8_t * ) data ; CHECK ( size >= 7 ) ; CHECK_EQ ( ( unsigned ) ptr [ 0 ] , 1u ) ; mNALLengthSize = 1 + ( ptr [ 4 ] & 3 ) ; } else if ( mIsHEVC ) { uint32_t type ; const void * data ; size_t size ; CHECK ( format -> findData ( kKeyHVCC , & type , & data , & size ) ) ; const uint8_t * ptr = ( const uint8_t * ) data ; CHECK ( size >= 22 ) ; CHECK_EQ ( ( unsigned ) ptr [ 0 ] , 1u ) ; mNALLengthSize = 1 + ( ptr [ 14 + 7 ] & 3 ) ; } CHECK ( format -> findInt32 ( kKeyTrackID , & mTrackId ) ) ; if ( mFirstMoofOffset != 0 ) { off64_t offset = mFirstMoofOffset ; parseChunk ( & offset ) ; } }
static void jsiLNGetMatches ( const char * str , linenoiseCompletions * lc ) { char buf [ 1000 ] , pre [ 1000 ] , hpre [ 6 ] = { } ; const char * cp , * fnam = "Info.completions" ; int i = 0 , len ; int rc , isfile = 0 , start = 0 , end = Jsi_Strlen ( str ) ; Jsi_Interp * interp = jsi_interactiveInterp ; if ( ! Jsi_Strncmp ( str , "help " , 5 ) ) { Jsi_Strcpy ( hpre , "help " ) ; str += 5 ; end -= 5 ; } if ( end <= 0 ) return ; Jsi_Strncpy ( buf , str , sizeof ( buf ) - 1 ) ; buf [ sizeof ( buf ) - 1 ] = 0 ; pre [ 0 ] = 0 ; if ( end <= 3 && ! Jsi_Strncmp ( str , "help" , end ) ) { linenoiseAddCompletion ( lc , "help" ) ; return ; } if ( ! completeValues ) completeValues = Jsi_ValueNew1 ( interp ) ; Jsi_Value * func = interp -> onComplete ; if ( func == NULL || ! Jsi_ValueIsFunction ( interp , func ) ) { for ( i = 0 ; jsiFilePreCmds [ i ] ; i ++ ) if ( ! Jsi_Strncmp ( buf , jsiFilePreCmds [ i ] , Jsi_Strlen ( jsiFilePreCmds [ i ] ) ) ) break ; if ( jsiFilePreCmds [ i ] && ( ( cp = Jsi_Strrchr ( buf , '(' ) ) && ( cp [ 1 ] == '\"' || cp [ 1 ] == '\'' ) ) ) { Jsi_Strcpy ( pre , buf ) ; pre [ cp - buf + 2 ] = 0 ; snprintf ( buf , sizeof ( buf ) , "%s*%s" , cp + 2 , ( buf [ 0 ] == 's' ? ".js*" : "" ) ) ; isfile = 1 ; fnam = "File.glob" ; } } func = Jsi_NameLookup ( interp , fnam ) ; if ( func && Jsi_ValueIsFunction ( interp , func ) ) { Jsi_Value * items [ 3 ] = { } ; ; i = 0 ; items [ i ++ ] = Jsi_ValueNewStringDup ( interp , buf ) ; if ( ! isfile ) { items [ i ++ ] = Jsi_ValueNewNumber ( interp , ( Jsi_Number ) start ) ; items [ i ++ ] = Jsi_ValueNewNumber ( interp , ( Jsi_Number ) end ) ; } Jsi_Value * args = Jsi_ValueMakeObject ( interp , NULL , Jsi_ObjNewArray ( interp , items , i , 0 ) ) ; Jsi_IncrRefCount ( interp , args ) ; rc = Jsi_FunctionInvoke ( interp , func , args , & completeValues , interp -> csc ) ; Jsi_DecrRefCount ( interp , args ) ; if ( rc != JSI_OK ) { fprintf ( stderr , "bad completion: %s %d %d\n" , str ? str : "" , start , end ) ; return ; } const char * name ; Jsi_Interp * interp = jsi_interactiveInterp ; if ( completeValues == NULL || ! Jsi_ValueIsArray ( interp , completeValues ) ) return ; Jsi_Value * * arr = completeValues -> d . obj -> arr ; int aLen = completeValues -> d . obj -> arrCnt ; i = 0 ; while ( i < aLen ) { name = Jsi_ValueString ( interp , arr [ i ] , & len ) ; if ( name ) { if ( ! pre [ 0 ] && ! hpre [ 0 ] ) linenoiseAddCompletion ( lc , name ) ; else { snprintf ( buf , sizeof ( buf ) , "%s%s%s" , hpre , pre , name ) ; linenoiseAddCompletion ( lc , buf ) ; } } i ++ ; } } }
void Builtins :: Generate_WasmCompileLazy ( MacroAssembler * masm ) { __ SmiTag ( r15 , r15 ) ; { HardAbortScope hard_abort ( masm ) ; FrameAndConstantPoolScope scope ( masm , StackFrame :: WASM_COMPILE_LAZY ) ; constexpr RegList gp_regs = Register :: ListOf < r3 , r4 , r5 , r6 , r7 , r8 , r9 , r10 > ( ) ; constexpr RegList fp_regs = DoubleRegister :: ListOf < d1 , d2 , d3 , d4 , d5 , d6 , d7 , d8 > ( ) ; __ MultiPush ( gp_regs ) ; __ MultiPushDoubles ( fp_regs ) ; __ Push ( kWasmInstanceRegister , r15 ) ; __ LoadP ( r5 , FieldMemOperand ( kWasmInstanceRegister , WasmInstanceObject :: kCEntryStubOffset ) ) ; __ LoadSmiLiteral ( cp , Smi :: kZero ) ; __ CallRuntimeWithCEntry ( Runtime :: kWasmCompileLazy , r5 ) ; __ mr ( r11 , kReturnRegister0 ) ; __ MultiPopDoubles ( fp_regs ) ; __ MultiPop ( gp_regs ) ; } __ Jump ( r11 ) ; }
void Http2Stream :: TopBrowsingContextIdChangedInternal ( uint64_t id ) { MOZ_ASSERT ( gHttpHandler -> ActiveTabPriority ( ) ) ; LOG3 ( ( "Http2Stream::TopBrowsingContextIdChangedInternal " "%p bcId=%" PRIx64 "\n" , this , id ) ) ; mCurrentTopBrowsingContextId = id ; if ( ! mSession -> UseH2Deps ( ) ) { return ; } if ( mPriorityDependency == Http2Session :: kUrgentStartGroupID ) { return ; } if ( mTransactionTabId != mCurrentTopBrowsingContextId ) { mPriorityDependency = Http2Session :: kBackgroundGroupID ; LOG3 ( ( "Http2Stream::TopBrowsingContextIdChangedInternal %p " "move into background group.\n" , this ) ) ; nsHttp :: NotifyActiveTabLoadOptimization ( ) ; } else { nsHttpTransaction * trans = mTransaction -> QueryHttpTransaction ( ) ; if ( ! trans ) { return ; } mPriorityDependency = GetPriorityDependencyFromTransaction ( trans ) ; LOG3 ( ( "Http2Stream::TopBrowsingContextIdChangedInternal %p " "depends on stream 0x%X\n" , this , mPriorityDependency ) ) ; } uint32_t modifyStreamID = mStreamID ; if ( ! modifyStreamID && mPushSource ) { modifyStreamID = mPushSource -> StreamID ( ) ; } if ( modifyStreamID ) { mSession -> SendPriorityFrame ( modifyStreamID , mPriorityDependency , mPriorityWeight ) ; } }
store_message ( png_store * ps , png_const_structp pp , char * buffer , size_t bufsize , size_t pos , PNG_CONST char * msg ) { if ( pp != NULL && pp == ps -> pread ) { pos = safecat ( buffer , bufsize , pos , "read: " ) ; if ( ps -> current != NULL ) { pos = safecat ( buffer , bufsize , pos , ps -> current -> name ) ; pos = safecat ( buffer , bufsize , pos , sep ) ; } } else if ( pp != NULL && pp == ps -> pwrite ) { pos = safecat ( buffer , bufsize , pos , "write: " ) ; pos = safecat ( buffer , bufsize , pos , ps -> wname ) ; pos = safecat ( buffer , bufsize , pos , sep ) ; } else { pos = safecat ( buffer , bufsize , pos , "pngvalid: " ) ; } if ( ps -> test [ 0 ] != 0 ) { pos = safecat ( buffer , bufsize , pos , ps -> test ) ; pos = safecat ( buffer , bufsize , pos , sep ) ; } pos = safecat ( buffer , bufsize , pos , msg ) ; return pos ; }
bool Bytecodes :: IsStarLookahead ( Bytecode bytecode , OperandScale operand_scale ) { if ( operand_scale == OperandScale :: kSingle ) { switch ( bytecode ) { case Bytecode :: kLdaZero : case Bytecode :: kLdaSmi : case Bytecode :: kLdaNull : case Bytecode :: kLdaTheHole : case Bytecode :: kLdaConstant : case Bytecode :: kLdaUndefined : case Bytecode :: kLdaGlobal : case Bytecode :: kLdaNamedProperty : case Bytecode :: kLdaKeyedProperty : case Bytecode :: kLdaContextSlot : case Bytecode :: kLdaCurrentContextSlot : case Bytecode :: kAdd : case Bytecode :: kSub : case Bytecode :: kMul : case Bytecode :: kAddSmi : case Bytecode :: kSubSmi : case Bytecode :: kInc : case Bytecode :: kDec : case Bytecode :: kTypeOf : case Bytecode :: kCallAnyReceiver : case Bytecode :: kCallProperty : case Bytecode :: kCallProperty0 : case Bytecode :: kCallProperty1 : case Bytecode :: kCallProperty2 : case Bytecode :: kCallUndefinedReceiver : case Bytecode :: kCallUndefinedReceiver0 : case Bytecode :: kCallUndefinedReceiver1 : case Bytecode :: kCallUndefinedReceiver2 : case Bytecode :: kConstruct : case Bytecode :: kConstructWithSpread : return true ; default : return false ; } } return false ; }
Status check_index_uninitialized ( const Tensor & key , std :: size_t index , const OptionalTuple & tuple ) TF_EXCLUSIVE_LOCKS_REQUIRED ( mu_ ) { if ( tuple [ index ] . has_value ( ) ) { return Status ( errors :: InvalidArgument ( "The tensor for index '" , index , "' for key '" , key . scalar < int64 > ( ) ( ) , "' was already initialized '" , dtypes_ . size ( ) , "'." ) ) ; } return Status :: OK ( ) ; }
RUNTIME_FUNCTION ( Runtime_DebugTrackRetainingPath ) { HandleScope scope ( isolate ) ; DCHECK_LE ( 1 , args . length ( ) ) ; DCHECK_GE ( 2 , args . length ( ) ) ; if ( ! FLAG_track_retaining_path ) { PrintF ( "DebugTrackRetainingPath requires --track-retaining-path flag.\n" ) ; } else { CONVERT_ARG_HANDLE_CHECKED ( HeapObject , object , 0 ) ; RetainingPathOption option = RetainingPathOption :: kDefault ; if ( args . length ( ) == 2 ) { CONVERT_ARG_HANDLE_CHECKED ( String , str , 1 ) ; const char track_ephemeron_path [ ] = "track-ephemeron-path" ; if ( str -> IsOneByteEqualTo ( STATIC_CHAR_VECTOR ( track_ephemeron_path ) ) ) { option = RetainingPathOption :: kTrackEphemeronPath ; } else if ( str -> length ( ) != 0 ) { PrintF ( "Unexpected second argument of DebugTrackRetainingPath.\n" ) ; PrintF ( "Expected an empty string or '%s', got '%s'.\n" , track_ephemeron_path , str -> ToCString ( ) . get ( ) ) ; } } isolate -> heap ( ) -> AddRetainingPathTarget ( object , option ) ; } return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
png_image_format ( png_structrp png_ptr ) { png_uint_32 format = 0 ; if ( png_ptr -> color_type & PNG_COLOR_MASK_COLOR ) format |= PNG_FORMAT_FLAG_COLOR ; if ( png_ptr -> color_type & PNG_COLOR_MASK_ALPHA ) format |= PNG_FORMAT_FLAG_ALPHA ; else if ( png_ptr -> num_trans > 0 ) format |= PNG_FORMAT_FLAG_ALPHA ; if ( png_ptr -> bit_depth == 16 ) format |= PNG_FORMAT_FLAG_LINEAR ; if ( png_ptr -> color_type & PNG_COLOR_MASK_PALETTE ) format |= PNG_FORMAT_FLAG_COLORMAP ; return format ; }
void CheckSADs ( ) { unsigned int reference_sad , exp_sad [ 4 ] ; SADs ( exp_sad ) ; for ( int block = 0 ; block < 4 ; block ++ ) { reference_sad = ReferenceSAD ( UINT_MAX , block ) ; EXPECT_EQ ( exp_sad [ block ] , reference_sad ) < < "block " < < block ; } }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { const OpData * op_data = reinterpret_cast < OpData * > ( node -> user_data ) ; TF_LITE_ENSURE ( context , node -> inputs -> size > 0 ) ; const TfLiteTensor * cond = GetInput ( context , node , 0 ) ; TF_LITE_ENSURE_EQ ( context , cond -> type , kTfLiteBool ) ; TF_LITE_ENSURE_EQ ( context , NumElements ( cond ) , 1 ) ; int num_inputs = node -> inputs -> size - 1 ; int num_outputs = node -> outputs -> size ; Subgraph * this_subgraph = reinterpret_cast < Subgraph * > ( context -> impl_ ) ; auto * subgraphs = this_subgraph -> GetSubgraphs ( ) ; TF_LITE_ENSURE ( context , op_data -> then_subgraph_index < subgraphs -> size ( ) ) ; TF_LITE_ENSURE ( context , op_data -> else_subgraph_index < subgraphs -> size ( ) ) ; Subgraph * then_subgraph = ( * subgraphs ) [ op_data -> then_subgraph_index ] . get ( ) ; Subgraph * else_subgraph = ( * subgraphs ) [ op_data -> else_subgraph_index ] . get ( ) ; for ( auto * subgraph : { then_subgraph , else_subgraph } ) { TF_LITE_ENSURE_EQ ( context , num_inputs , subgraph -> inputs ( ) . size ( ) ) ; TF_LITE_ENSURE_EQ ( context , num_outputs , subgraph -> outputs ( ) . size ( ) ) ; } bool has_dynamic_output_tensors = false ; for ( auto * subgraph : { then_subgraph , else_subgraph } ) { for ( int i = 0 ; i < num_inputs ; ++ i ) { const TfLiteTensor * input = GetInput ( context , node , i + 1 ) ; std :: vector < int > dims ( input -> dims -> data , input -> dims -> data + input -> dims -> size ) ; subgraph -> ResizeInputTensor ( i , dims ) ; TfLiteTensor * subgraph_input = subgraph -> tensor ( subgraph -> inputs ( ) [ i ] ) ; TF_LITE_ENSURE_TYPES_EQ ( context , input -> type , subgraph_input -> type ) ; } TF_LITE_ENSURE_OK ( context , subgraph -> AllocateTensors ( ) ) ; has_dynamic_output_tensors |= subgraph -> HasDynamicTensors ( ) ; } if ( ! has_dynamic_output_tensors ) { for ( int i = 0 ; i < num_outputs ; ++ i ) { TfLiteTensor * then_output = then_subgraph -> tensor ( then_subgraph -> outputs ( ) [ i ] ) ; TfLiteTensor * else_output = else_subgraph -> tensor ( else_subgraph -> outputs ( ) [ i ] ) ; if ( ! TfLiteIntArrayEqual ( then_output -> dims , else_output -> dims ) ) { has_dynamic_output_tensors = true ; break ; } } } for ( int i = 0 ; i < num_outputs ; ++ i ) { TfLiteTensor * output = GetOutput ( context , node , i ) ; if ( has_dynamic_output_tensors ) { SetTensorToDynamic ( output ) ; } else { TfLiteTensor * then_output = then_subgraph -> tensor ( then_subgraph -> outputs ( ) [ i ] ) ; TfLiteIntArray * output_size = TfLiteIntArrayCopy ( then_output -> dims ) ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , output , output_size ) ) ; } } return kTfLiteOk ; }
static apr_byte_t oidc_validate_post_logout_url ( request_rec * r , const char * url , char * * err_str , char * * err_desc ) { apr_uri_t uri ; const char * c_host = NULL ; if ( apr_uri_parse ( r -> pool , url , & uri ) != APR_SUCCESS ) { * err_str = apr_pstrdup ( r -> pool , "Malformed URL" ) ; * err_desc = apr_psprintf ( r -> pool , "Logout URL malformed: %s" , url ) ; oidc_error ( r , "%s: %s" , * err_str , * err_desc ) ; return FALSE ; } c_host = oidc_get_current_url_host ( r ) ; if ( ( uri . hostname != NULL ) && ( ( strstr ( c_host , uri . hostname ) == NULL ) || ( strstr ( uri . hostname , c_host ) == NULL ) ) ) { * err_str = apr_pstrdup ( r -> pool , "Invalid Request" ) ; * err_desc = apr_psprintf ( r -> pool , "logout value \"%s\" does not match the hostname of the current request \"%s\"" , apr_uri_unparse ( r -> pool , & uri , 0 ) , c_host ) ; oidc_error ( r , "%s: %s" , * err_str , * err_desc ) ; return FALSE ; } else if ( strstr ( url , "/" ) != url ) { * err_str = apr_pstrdup ( r -> pool , "Malformed URL" ) ; * err_desc = apr_psprintf ( r -> pool , "No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s" , url ) ; oidc_error ( r , "%s: %s" , * err_str , * err_desc ) ; return FALSE ; } if ( ( ( strstr ( url , "\n" ) != NULL ) || strstr ( url , "\r" ) != NULL ) ) { * err_str = apr_pstrdup ( r -> pool , "Invalid Request" ) ; * err_desc = apr_psprintf ( r -> pool , "logout value \"%s\" contains illegal \"\n\" or \"\r\" character(s)" , url ) ; oidc_error ( r , "%s: %s" , * err_str , * err_desc ) ; return FALSE ; } return TRUE ; }
void CallOrConstructBuiltinsAssembler :: CallOrConstructWithSpread ( TNode < Object > target , TNode < Object > new_target , TNode < Object > spread , TNode < Int32T > args_count , TNode < Context > context ) { Label if_smiorobject ( this ) , if_double ( this ) , if_generic ( this , Label :: kDeferred ) ; TVARIABLE ( Int32T , var_length ) ; TVARIABLE ( FixedArrayBase , var_elements ) ; TVARIABLE ( Int32T , var_elements_kind ) ; GotoIf ( TaggedIsSmi ( spread ) , & if_generic ) ; TNode < Map > spread_map = LoadMap ( CAST ( spread ) ) ; GotoIfNot ( IsJSArrayMap ( spread_map ) , & if_generic ) ; TNode < JSArray > spread_array = CAST ( spread ) ; GotoIfNot ( IsPrototypeInitialArrayPrototype ( context , spread_map ) , & if_generic ) ; GotoIf ( IsNoElementsProtectorCellInvalid ( ) , & if_generic ) ; TNode < PropertyCell > protector_cell = CAST ( LoadRoot ( Heap :: kArrayIteratorProtectorRootIndex ) ) ; GotoIf ( WordEqual ( LoadObjectField ( protector_cell , PropertyCell :: kValueOffset ) , SmiConstant ( Isolate :: kProtectorInvalid ) ) , & if_generic ) ; { TNode < Int32T > spread_kind = LoadMapElementsKind ( spread_map ) ; var_elements_kind = spread_kind ; var_length = LoadAndUntagToWord32ObjectField ( spread_array , JSArray :: kLengthOffset ) ; var_elements = LoadElements ( spread_array ) ; GotoIf ( Int32LessThan ( spread_kind , Int32Constant ( PACKED_DOUBLE_ELEMENTS ) ) , & if_smiorobject ) ; Branch ( Int32GreaterThan ( spread_kind , Int32Constant ( LAST_FAST_ELEMENTS_KIND ) ) , & if_generic , & if_double ) ; } BIND ( & if_generic ) ; { Label if_iterator_fn_not_callable ( this , Label :: kDeferred ) ; TNode < Object > iterator_fn = GetProperty ( context , spread , IteratorSymbolConstant ( ) ) ; GotoIfNot ( TaggedIsCallable ( iterator_fn ) , & if_iterator_fn_not_callable ) ; TNode < JSArray > list = CAST ( CallBuiltin ( Builtins :: kIterableToList , context , spread , iterator_fn ) ) ; var_length = LoadAndUntagToWord32ObjectField ( list , JSArray :: kLengthOffset ) ; var_elements = LoadElements ( list ) ; var_elements_kind = LoadElementsKind ( list ) ; Branch ( Int32LessThan ( var_elements_kind . value ( ) , Int32Constant ( PACKED_DOUBLE_ELEMENTS ) ) , & if_smiorobject , & if_double ) ; BIND ( & if_iterator_fn_not_callable ) ; ThrowTypeError ( context , MessageTemplate :: kIteratorSymbolNonCallable ) ; } BIND ( & if_smiorobject ) ; { TNode < FixedArrayBase > elements = var_elements . value ( ) ; TNode < Int32T > length = var_length . value ( ) ; if ( new_target == nullptr ) { Callable callable = CodeFactory :: CallVarargs ( isolate ( ) ) ; TailCallStub ( callable , context , target , args_count , elements , length ) ; } else { Callable callable = CodeFactory :: ConstructVarargs ( isolate ( ) ) ; TailCallStub ( callable , context , target , new_target , args_count , elements , length ) ; } } BIND ( & if_double ) ; { GotoIf ( Word32Equal ( var_length . value ( ) , Int32Constant ( 0 ) ) , & if_smiorobject ) ; CallOrConstructDoubleVarargs ( target , new_target , CAST ( var_elements . value ( ) ) , var_length . value ( ) , args_count , context , var_elements_kind . value ( ) ) ; } }
void vp8_sixtap_predict16x16_mmx ( unsigned char * src_ptr , int src_pixels_per_line , int xoffset , int yoffset , unsigned char * dst_ptr , int dst_pitch ) { DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , FData2 , 24 * 24 ) ; const short * HFilter , * VFilter ; HFilter = vp8_six_tap_mmx [ xoffset ] ; vp8_filter_block1d_h6_mmx ( src_ptr - ( 2 * src_pixels_per_line ) , FData2 , src_pixels_per_line , 1 , 21 , 32 , HFilter ) ; vp8_filter_block1d_h6_mmx ( src_ptr - ( 2 * src_pixels_per_line ) + 4 , FData2 + 4 , src_pixels_per_line , 1 , 21 , 32 , HFilter ) ; vp8_filter_block1d_h6_mmx ( src_ptr - ( 2 * src_pixels_per_line ) + 8 , FData2 + 8 , src_pixels_per_line , 1 , 21 , 32 , HFilter ) ; vp8_filter_block1d_h6_mmx ( src_ptr - ( 2 * src_pixels_per_line ) + 12 , FData2 + 12 , src_pixels_per_line , 1 , 21 , 32 , HFilter ) ; VFilter = vp8_six_tap_mmx [ yoffset ] ; vp8_filter_block1dc_v6_mmx ( FData2 + 32 , dst_ptr , dst_pitch , 32 , 16 , 16 , 16 , VFilter ) ; vp8_filter_block1dc_v6_mmx ( FData2 + 36 , dst_ptr + 4 , dst_pitch , 32 , 16 , 16 , 16 , VFilter ) ; vp8_filter_block1dc_v6_mmx ( FData2 + 40 , dst_ptr + 8 , dst_pitch , 32 , 16 , 16 , 16 , VFilter ) ; vp8_filter_block1dc_v6_mmx ( FData2 + 44 , dst_ptr + 12 , dst_pitch , 32 , 16 , 16 , 16 , VFilter ) ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; output -> type = input -> type ; return context -> ResizeTensor ( context , output , TfLiteIntArrayCopy ( input -> dims ) ) ; }
static vpx_codec_err_t image2yuvconfig ( const vpx_image_t * img , YV12_BUFFER_CONFIG * yv12 ) { vpx_codec_err_t res = VPX_CODEC_OK ; yv12 -> y_buffer = img -> planes [ VPX_PLANE_Y ] ; yv12 -> u_buffer = img -> planes [ VPX_PLANE_U ] ; yv12 -> v_buffer = img -> planes [ VPX_PLANE_V ] ; yv12 -> y_crop_width = img -> d_w ; yv12 -> y_crop_height = img -> d_h ; yv12 -> y_width = img -> d_w ; yv12 -> y_height = img -> d_h ; yv12 -> uv_width = yv12 -> y_width / 2 ; yv12 -> uv_height = yv12 -> y_height / 2 ; yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ; yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ; yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - img -> d_w ) / 2 ; return res ; }
static int __br_mdb_del ( struct net_bridge * br , struct br_mdb_entry * entry ) { struct net_bridge_mdb_htable * mdb ; struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; struct br_ip ip ; int err = - EINVAL ; if ( ! netif_running ( br -> dev ) || br -> multicast_disabled ) return - EINVAL ; if ( timer_pending ( & br -> multicast_querier_timer ) ) return - EBUSY ; ip . proto = entry -> addr . proto ; if ( ip . proto == htons ( ETH_P_IP ) ) ip . u . ip4 = entry -> addr . u . ip4 ; #if IS_ENABLED(CONFIG_IPV6) else ip . u . ip6 = entry -> addr . u . ip6 ; #endif spin_lock_bh ( & br -> multicast_lock ) ; mdb = mlock_dereference ( br -> mdb , br ) ; mp = br_mdb_ip_get ( mdb , & ip ) ; if ( ! mp ) goto unlock ; for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( ! p -> port || p -> port -> dev -> ifindex != entry -> ifindex ) continue ; if ( p -> port -> state == BR_STATE_DISABLED ) goto unlock ; rcu_assign_pointer ( * pp , p -> next ) ; hlist_del_init ( & p -> mglist ) ; del_timer ( & p -> timer ) ; call_rcu_bh ( & p -> rcu , br_multicast_free_pg ) ; err = 0 ; if ( ! mp -> ports && ! mp -> mglist && netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ; break ; } unlock : spin_unlock_bh ( & br -> multicast_lock ) ; return err ; }
spnego_gss_unwrap_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int * conf_state , gss_qop_t * qop_state , gss_iov_buffer_desc * iov , int iov_count ) { OM_uint32 ret ; ret = gss_unwrap_iov ( minor_status , context_handle , conf_state , qop_state , iov , iov_count ) ; return ( ret ) ; }
void Node :: OutOfLineInputs :: ExtractFrom ( Use * old_use_ptr , Node * * old_input_ptr , int count ) { Use * new_use_ptr = reinterpret_cast < Use * > ( this ) - 1 ; Node * * new_input_ptr = inputs_ ; for ( int current = 0 ; current < count ; current ++ ) { new_use_ptr -> bit_field_ = Use :: InputIndexField :: encode ( current ) | Use :: InlineField :: encode ( false ) ; DCHECK_EQ ( old_input_ptr , old_use_ptr -> input_ptr ( ) ) ; DCHECK_EQ ( new_input_ptr , new_use_ptr -> input_ptr ( ) ) ; Node * old_to = * old_input_ptr ; if ( old_to ) { * old_input_ptr = nullptr ; old_to -> RemoveUse ( old_use_ptr ) ; * new_input_ptr = old_to ; old_to -> AppendUse ( new_use_ptr ) ; } else { * new_input_ptr = nullptr ; } old_input_ptr ++ ; new_input_ptr ++ ; old_use_ptr -- ; new_use_ptr -- ; } this -> count_ = count ; }
static struct dentry * aio_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data ) { static const struct dentry_operations ops = { . d_dname = simple_dname , } ; return mount_pseudo ( fs_type , "aio:" , NULL , & ops , AIO_RING_MAGIC ) ; }
static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; list_del ( & key -> graveyard_link ) ; kdebug ( "- %u" , key -> serial ) ; key_check ( key ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; kfree ( key -> description ) ; memzero_explicit ( key , sizeof ( * key ) ) ; kmem_cache_free ( key_jar , key ) ; } }
void StackCheck ( WasmCodePosition position ) { if ( FLAG_wasm_no_stack_checks || ! env_ -> runtime_exception_support ) return ; out_of_line_code_ . push_back ( OutOfLineCode :: StackCheck ( position , __ cache_state ( ) -> used_registers ) ) ; OutOfLineCode & ool = out_of_line_code_ . back ( ) ; LiftoffRegister limit_address = __ GetUnusedRegister ( kGpReg ) ; LOAD_INSTANCE_FIELD ( limit_address , StackLimitAddress , kPointerLoadType ) ; __ StackCheck ( ool . label . get ( ) , limit_address . gp ( ) ) ; __ bind ( ool . continuation . get ( ) ) ; }
DSA_PrivateKey :: create_signature_op ( RandomNumberGenerator & , const std :: string & params , const std :: string & provider ) const { if ( provider == "base" || provider . empty ( ) ) return std :: unique_ptr < PK_Ops :: Signature > ( new DSA_Signature_Operation ( * this , params ) ) ; throw Provider_Not_Found ( algo_name ( ) , provider ) ; }
CookieServiceChild :: SetCookieInternal ( nsCookieAttributes & aCookieAttributes , const mozilla :: OriginAttributes & aAttrs , nsIChannel * aChannel , bool aFromHttp , nsICookiePermission * aPermissionService ) { if ( aCookieAttributes . isHttpOnly ) { return ; } int64_t currentTimeInUsec = PR_Now ( ) ; RefPtr < nsCookie > cookie = nsCookie :: Create ( aCookieAttributes . name , aCookieAttributes . value , aCookieAttributes . host , aCookieAttributes . path , aCookieAttributes . expiryTime , currentTimeInUsec , nsCookie :: GenerateUniqueCreationTime ( currentTimeInUsec ) , aCookieAttributes . isSession , aCookieAttributes . isSecure , aCookieAttributes . isHttpOnly , aAttrs , aCookieAttributes . sameSite ) ; RecordDocumentCookie ( cookie , aAttrs ) ; }
static void launch ( OpKernelContext * context , const TensorShape & tensor_in_shape , const Tensor & out_backprop , const std :: array < int64 , 3 > & window , const std :: array < int64 , 3 > & stride , const std :: array < int64 , 3 > & output_shape , const std :: array < int64 , 3 > & padding , TensorFormat data_format , Tensor * output ) { output -> flat < T > ( ) . setZero ( ) ; std :: array < int64 , 3 > input_size = { { tensor_in_shape . dim_size ( 3 ) , tensor_in_shape . dim_size ( 2 ) , tensor_in_shape . dim_size ( 1 ) } } ; for ( int64 p = 0 ; p < out_backprop . dim_size ( 3 ) ; ++ p ) { int pindex , psize ; OP_REQUIRES_OK ( context , GetBroadcastSize ( p , input_size [ 0 ] , window [ 0 ] , stride [ 0 ] , padding [ 0 ] , & pindex , & psize ) ) ; for ( int64 r = 0 ; r < out_backprop . dim_size ( 2 ) ; ++ r ) { int rindex , rsize ; OP_REQUIRES_OK ( context , GetBroadcastSize ( r , input_size [ 1 ] , window [ 1 ] , stride [ 1 ] , padding [ 1 ] , & rindex , & rsize ) ) ; for ( int64 c = 0 ; c < out_backprop . dim_size ( 1 ) ; ++ c ) { int cindex , csize ; OP_REQUIRES_OK ( context , GetBroadcastSize ( c , input_size [ 2 ] , window [ 2 ] , stride [ 2 ] , padding [ 2 ] , & cindex , & csize ) ) ; TensorSlice src { { 0 , - 1 } , { c , 1 } , { r , 1 } , { p , 1 } , { 0 , - 1 } } ; TensorSlice dst { { 0 , - 1 } , { cindex , csize } , { rindex , rsize } , { pindex , psize } , { 0 , - 1 } } ; Eigen :: DSizes < Eigen :: DenseIndex , 5 > src_indices ; Eigen :: DSizes < Eigen :: DenseIndex , 5 > src_sizes ; Eigen :: DSizes < Eigen :: DenseIndex , 5 > dst_indices ; Eigen :: DSizes < Eigen :: DenseIndex , 5 > dst_sizes ; src . FillIndicesAndSizes < 5 > ( out_backprop . shape ( ) , & src_indices , & src_sizes ) ; dst . FillIndicesAndSizes < 5 > ( tensor_in_shape , & dst_indices , & dst_sizes ) ; #if !defined(EIGEN_HAS_INDEX_LIST) Eigen :: array < int , 5 > bcast = { 1 , csize , rsize , psize , 1 } ; #else Eigen :: IndexList < Eigen :: type2index < 1 > , int , int , int , Eigen :: type2index < 1 > > bcast ; bcast . set ( 1 , csize ) ; bcast . set ( 2 , rsize ) ; bcast . set ( 3 , psize ) ; #endif Eigen :: Tensor < T , 5 , Eigen :: RowMajor > slices ( src_sizes ) ; slices . device ( context -> eigen_cpu_device ( ) ) = out_backprop . tensor < T , 5 > ( ) . slice ( src_indices , src_sizes ) ; float divide_size = rsize * csize * psize * 1.0f ; slices *= slices . constant ( 1.0f / divide_size ) ; output -> tensor < T , 5 > ( ) . slice ( dst_indices , dst_sizes ) . device ( context -> eigen_cpu_device ( ) ) += slices . broadcast ( bcast ) ; } } } }
GC_INNER void * GC_generic_malloc_ignore_off_page ( size_t lb , int k ) { void * result ; size_t lg ; size_t lb_rounded ; word n_blocks ; GC_bool init ; DCL_LOCK_STATE ; if ( SMALL_OBJ ( lb ) ) return ( GC_generic_malloc ( ( word ) lb , k ) ) ; lg = ROUNDED_UP_GRANULES ( lb ) ; lb_rounded = GRANULES_TO_BYTES ( lg ) ; n_blocks = OBJ_SZ_TO_BLOCKS ( lb_rounded ) ; init = GC_obj_kinds [ k ] . ok_init ; if ( EXPECT ( GC_have_errors , FALSE ) ) GC_print_all_errors ( ) ; GC_INVOKE_FINALIZERS ( ) ; LOCK ( ) ; result = ( ptr_t ) GC_alloc_large ( ADD_SLOP ( lb ) , k , IGNORE_OFF_PAGE ) ; if ( 0 != result ) { if ( GC_debugging_started ) { BZERO ( result , n_blocks * HBLKSIZE ) ; } else { #           ifdef THREADS ( ( word * ) result ) [ 0 ] = 0 ; ( ( word * ) result ) [ 1 ] = 0 ; ( ( word * ) result ) [ GRANULES_TO_WORDS ( lg ) - 1 ] = 0 ; ( ( word * ) result ) [ GRANULES_TO_WORDS ( lg ) - 2 ] = 0 ; #           endif } } GC_bytes_allocd += lb_rounded ; if ( 0 == result ) { GC_oom_func oom_fn = GC_oom_fn ; UNLOCK ( ) ; return ( ( * oom_fn ) ( lb ) ) ; } else { UNLOCK ( ) ; if ( init && ! GC_debugging_started ) { BZERO ( result , n_blocks * HBLKSIZE ) ; } return ( result ) ; } }
struct vfsmount * collect_mounts ( struct path * path ) { struct mount * tree ; namespace_lock ( ) ; tree = copy_tree ( real_mount ( path -> mnt ) , path -> dentry , CL_COPY_ALL | CL_PRIVATE ) ; namespace_unlock ( ) ; if ( IS_ERR ( tree ) ) return ERR_CAST ( tree ) ; return & tree -> mnt ; }
folly :: Optional < Param > ReadRecordLayer :: readEvent ( folly :: IOBufQueue & socketBuf ) { if ( ! unparsedHandshakeData_ . empty ( ) ) { auto param = decodeHandshakeMessage ( unparsedHandshakeData_ ) ; if ( param ) { VLOG ( 8 ) < < "Received handshake message " < < toString ( boost :: apply_visitor ( EventVisitor ( ) , * param ) ) ; return param ; } } while ( true ) { auto message = read ( socketBuf ) ; if ( ! message ) { return folly :: none ; } if ( ! unparsedHandshakeData_ . empty ( ) && message -> type != ContentType :: handshake ) { throw std :: runtime_error ( "spliced handshake data" ) ; } switch ( message -> type ) { case ContentType :: alert : { auto alert = decode < Alert > ( std :: move ( message -> fragment ) ) ; if ( alert . description == AlertDescription :: close_notify ) { return Param ( CloseNotify ( socketBuf . move ( ) ) ) ; } else { return Param ( std :: move ( alert ) ) ; } } case ContentType :: handshake : { unparsedHandshakeData_ . append ( std :: move ( message -> fragment ) ) ; auto param = decodeHandshakeMessage ( unparsedHandshakeData_ ) ; if ( param ) { VLOG ( 8 ) < < "Received handshake message " < < toString ( boost :: apply_visitor ( EventVisitor ( ) , * param ) ) ; return param ; } else { continue ; } } case ContentType :: application_data : return Param ( AppData ( std :: move ( message -> fragment ) ) ) ; default : throw std :: runtime_error ( "unknown content type" ) ; } } }
static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; cstate = 0 ; if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { return - 1 ; } if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || ! siz -> tileheight || ! siz -> numcomps ) { return - 1 ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { jas_free ( siz -> comps ) ; return - 1 ; } siz -> comps [ i ] . sgnd = ( tmp > > 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { jas_free ( siz -> comps ) ; return - 1 ; } return 0 ; }
static void update_mbgraph_frame_stats ( VP9_COMP * cpi , MBGRAPH_FRAME_STATS * stats , YV12_BUFFER_CONFIG * buf , YV12_BUFFER_CONFIG * golden_ref , YV12_BUFFER_CONFIG * alt_ref ) { MACROBLOCK * const x = & cpi -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; VP9_COMMON * const cm = & cpi -> common ; int mb_col , mb_row , offset = 0 ; int mb_y_offset = 0 , arf_y_offset = 0 , gld_y_offset = 0 ; int_mv arf_top_mv , gld_top_mv ; MODE_INFO mi_local = { { 0 } } ; arf_top_mv . as_int = 0 ; gld_top_mv . as_int = 0 ; x -> mv_row_min = - BORDER_MV_PIXELS_B16 ; x -> mv_row_max = ( cm -> mb_rows - 1 ) * 8 + BORDER_MV_PIXELS_B16 ; xd -> up_available = 0 ; xd -> plane [ 0 ] . dst . stride = buf -> y_stride ; xd -> plane [ 0 ] . pre [ 0 ] . stride = buf -> y_stride ; xd -> plane [ 1 ] . dst . stride = buf -> uv_stride ; xd -> mi [ 0 ] = & mi_local ; mi_local . mbmi . sb_type = BLOCK_16X16 ; mi_local . mbmi . ref_frame [ 0 ] = LAST_FRAME ; mi_local . mbmi . ref_frame [ 1 ] = NONE ; for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { int_mv arf_left_mv , gld_left_mv ; int mb_y_in_offset = mb_y_offset ; int arf_y_in_offset = arf_y_offset ; int gld_y_in_offset = gld_y_offset ; arf_left_mv . as_int = arf_top_mv . as_int ; gld_left_mv . as_int = gld_top_mv . as_int ; x -> mv_col_min = - BORDER_MV_PIXELS_B16 ; x -> mv_col_max = ( cm -> mb_cols - 1 ) * 8 + BORDER_MV_PIXELS_B16 ; xd -> left_available = 0 ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { MBGRAPH_MB_STATS * mb_stats = & stats -> mb_stats [ offset + mb_col ] ; update_mbgraph_mb_stats ( cpi , mb_stats , buf , mb_y_in_offset , golden_ref , & gld_left_mv , alt_ref , mb_row , mb_col ) ; arf_left_mv . as_int = mb_stats -> ref [ ALTREF_FRAME ] . m . mv . as_int ; gld_left_mv . as_int = mb_stats -> ref [ GOLDEN_FRAME ] . m . mv . as_int ; if ( mb_col == 0 ) { arf_top_mv . as_int = arf_left_mv . as_int ; gld_top_mv . as_int = gld_left_mv . as_int ; } xd -> left_available = 1 ; mb_y_in_offset += 16 ; gld_y_in_offset += 16 ; arf_y_in_offset += 16 ; x -> mv_col_min -= 16 ; x -> mv_col_max -= 16 ; } xd -> up_available = 1 ; mb_y_offset += buf -> y_stride * 16 ; gld_y_offset += golden_ref -> y_stride * 16 ; if ( alt_ref ) arf_y_offset += alt_ref -> y_stride * 16 ; x -> mv_row_min -= 16 ; x -> mv_row_max -= 16 ; offset += cm -> mb_cols ; } }
status_t SurfaceFlinger :: captureScreen ( const sp < IBinder > & display , sp < GraphicBuffer > * outBuffer , Rect sourceCrop , uint32_t reqWidth , uint32_t reqHeight , int32_t minLayerZ , int32_t maxLayerZ , bool useIdentityTransform , ISurfaceComposer :: Rotation rotation ) { ATRACE_CALL ( ) ; if ( CC_UNLIKELY ( display == 0 ) ) return BAD_VALUE ; const sp < const DisplayDevice > device ( getDisplayDeviceLocked ( display ) ) ; if ( CC_UNLIKELY ( device == 0 ) ) return BAD_VALUE ; const Rect & dispScissor = device -> getScissor ( ) ; if ( ! dispScissor . isEmpty ( ) ) { sourceCrop . set ( dispScissor ) ; if ( reqWidth == 0 || reqHeight == 0 ) { reqWidth = uint32_t ( device -> getViewport ( ) . width ( ) ) ; reqHeight = uint32_t ( device -> getViewport ( ) . height ( ) ) ; } } DisplayRenderArea renderArea ( device , sourceCrop , reqHeight , reqWidth , rotation ) ; auto traverseLayers = std :: bind ( std :: mem_fn ( & SurfaceFlinger :: traverseLayersInDisplay ) , this , device , minLayerZ , maxLayerZ , std :: placeholders :: _1 ) ; return captureScreenCommon ( renderArea , traverseLayers , outBuffer , useIdentityTransform ) ; }
ProxyResolverV8 :: ProxyResolverV8 ( ProxyResolverJSBindings * custom_js_bindings , ProxyErrorListener * error_listener ) : context_ ( NULL ) , js_bindings_ ( custom_js_bindings ) , error_listener_ ( error_listener ) { if ( ! initialized_for_this_process_ ) { v8 :: Platform * platform = v8 :: platform :: CreateDefaultPlatform ( ) ; v8 :: V8 :: InitializePlatform ( platform ) ; v8 :: V8 :: Initialize ( ) ; initialized_for_this_process_ = true ; } }
nsSMILAnimationController :: StopSampling ( nsRefreshDriver * aRefreshDriver ) { if ( aRefreshDriver ) { NS_ABORT_IF_FALSE ( ! GetRefreshDriver ( ) || aRefreshDriver == GetRefreshDriver ( ) , "Stopping sampling with wrong refresh driver" ) ; aRefreshDriver -> RemoveRefreshObserver ( this , Flush_Style ) ; } }
sp < ABuffer > AMPEG4AudioAssembler :: removeLATMFraming ( const sp < ABuffer > & buffer ) { CHECK ( ! mMuxConfigPresent ) ; sp < ABuffer > out = new ABuffer ( buffer -> size ( ) ) ; out -> setRange ( 0 , 0 ) ; size_t offset = 0 ; uint8_t * ptr = buffer -> data ( ) ; for ( size_t i = 0 ; i <= mNumSubFrames ; ++ i ) { unsigned payloadLength = 0 ; switch ( mFrameLengthType ) { case 0 : { unsigned muxSlotLengthBytes = 0 ; unsigned tmp ; do { CHECK_LT ( offset , buffer -> size ( ) ) ; tmp = ptr [ offset ++ ] ; muxSlotLengthBytes += tmp ; } while ( tmp == 0xff ) ; payloadLength = muxSlotLengthBytes ; break ; } case 2 : { TRESPASS ( ) ; break ; } default : { CHECK_GE ( mFixedFrameLength , 0 ) ; payloadLength = mFixedFrameLength ; break ; } } CHECK_LE ( offset + payloadLength , buffer -> size ( ) ) ; memcpy ( out -> data ( ) + out -> size ( ) , & ptr [ offset ] , payloadLength ) ; out -> setRange ( 0 , out -> size ( ) + payloadLength ) ; offset += payloadLength ; if ( mOtherDataPresent ) { CHECK ( ( mOtherDataLenBits % 8 ) == 0 ) ; CHECK_LE ( offset + ( mOtherDataLenBits / 8 ) , buffer -> size ( ) ) ; offset += mOtherDataLenBits / 8 ; } } if ( offset < buffer -> size ( ) ) { ALOGI ( "ignoring %d bytes of trailing data" , buffer -> size ( ) - offset ) ; } CHECK_LE ( offset , buffer -> size ( ) ) ; return out ; }
int main ( ) { { typedef std :: poisson_distribution < > D ; typedef std :: minstd_rand G ; G g ; D d ( 2 ) ; const int N = 100000 ; std :: vector < double > u ; for ( int i = 0 ; i < N ; ++ i ) { D :: result_type v = d ( g ) ; assert ( d . min ( ) <= v && v <= d . max ( ) ) ; u . push_back ( v ) ; } double mean = std :: accumulate ( u . begin ( ) , u . end ( ) , 0.0 ) / u . size ( ) ; double var = 0 ; double skew = 0 ; double kurtosis = 0 ; for ( unsigned i = 0 ; i < u . size ( ) ; ++ i ) { double dbl = ( u [ i ] - mean ) ; double d2 = sqr ( dbl ) ; var += d2 ; skew += dbl * d2 ; kurtosis += d2 * d2 ; } var /= u . size ( ) ; double dev = std :: sqrt ( var ) ; skew /= u . size ( ) * dev * var ; kurtosis /= u . size ( ) * var * var ; kurtosis -= 3 ; double x_mean = d . mean ( ) ; double x_var = d . mean ( ) ; double x_skew = 1 / std :: sqrt ( x_var ) ; double x_kurtosis = 1 / x_var ; assert ( std :: abs ( ( mean - x_mean ) / x_mean ) < 0.01 ) ; assert ( std :: abs ( ( var - x_var ) / x_var ) < 0.01 ) ; assert ( std :: abs ( ( skew - x_skew ) / x_skew ) < 0.01 ) ; assert ( std :: abs ( ( kurtosis - x_kurtosis ) / x_kurtosis ) < 0.03 ) ; } { typedef std :: poisson_distribution < > D ; typedef std :: minstd_rand G ; G g ; D d ( 0.75 ) ; const int N = 100000 ; std :: vector < double > u ; for ( int i = 0 ; i < N ; ++ i ) { D :: result_type v = d ( g ) ; assert ( d . min ( ) <= v && v <= d . max ( ) ) ; u . push_back ( v ) ; } double mean = std :: accumulate ( u . begin ( ) , u . end ( ) , 0.0 ) / u . size ( ) ; double var = 0 ; double skew = 0 ; double kurtosis = 0 ; for ( unsigned i = 0 ; i < u . size ( ) ; ++ i ) { double dbl = ( u [ i ] - mean ) ; double d2 = sqr ( dbl ) ; var += d2 ; skew += dbl * d2 ; kurtosis += d2 * d2 ; } var /= u . size ( ) ; double dev = std :: sqrt ( var ) ; skew /= u . size ( ) * dev * var ; kurtosis /= u . size ( ) * var * var ; kurtosis -= 3 ; double x_mean = d . mean ( ) ; double x_var = d . mean ( ) ; double x_skew = 1 / std :: sqrt ( x_var ) ; double x_kurtosis = 1 / x_var ; assert ( std :: abs ( ( mean - x_mean ) / x_mean ) < 0.01 ) ; assert ( std :: abs ( ( var - x_var ) / x_var ) < 0.01 ) ; assert ( std :: abs ( ( skew - x_skew ) / x_skew ) < 0.01 ) ; assert ( std :: abs ( ( kurtosis - x_kurtosis ) / x_kurtosis ) < 0.04 ) ; } { typedef std :: poisson_distribution < > D ; typedef std :: mt19937 G ; G g ; D d ( 20 ) ; const int N = 1000000 ; std :: vector < double > u ; for ( int i = 0 ; i < N ; ++ i ) { D :: result_type v = d ( g ) ; assert ( d . min ( ) <= v && v <= d . max ( ) ) ; u . push_back ( v ) ; } double mean = std :: accumulate ( u . begin ( ) , u . end ( ) , 0.0 ) / u . size ( ) ; double var = 0 ; double skew = 0 ; double kurtosis = 0 ; for ( unsigned i = 0 ; i < u . size ( ) ; ++ i ) { double dbl = ( u [ i ] - mean ) ; double d2 = sqr ( dbl ) ; var += d2 ; skew += dbl * d2 ; kurtosis += d2 * d2 ; } var /= u . size ( ) ; double dev = std :: sqrt ( var ) ; skew /= u . size ( ) * dev * var ; kurtosis /= u . size ( ) * var * var ; kurtosis -= 3 ; double x_mean = d . mean ( ) ; double x_var = d . mean ( ) ; double x_skew = 1 / std :: sqrt ( x_var ) ; double x_kurtosis = 1 / x_var ; assert ( std :: abs ( ( mean - x_mean ) / x_mean ) < 0.01 ) ; assert ( std :: abs ( ( var - x_var ) / x_var ) < 0.01 ) ; assert ( std :: abs ( ( skew - x_skew ) / x_skew ) < 0.01 ) ; assert ( std :: abs ( ( kurtosis - x_kurtosis ) / x_kurtosis ) < 0.01 ) ; } }
static void sas_init_port ( struct asd_sas_port * port , struct sas_ha_struct * sas_ha , int i ) { memset ( port , 0 , sizeof ( * port ) ) ; port -> id = i ; INIT_LIST_HEAD ( & port -> dev_list ) ; INIT_LIST_HEAD ( & port -> disco_list ) ; INIT_LIST_HEAD ( & port -> destroy_list ) ; spin_lock_init ( & port -> phy_list_lock ) ; INIT_LIST_HEAD ( & port -> phy_list ) ; port -> ha = sas_ha ; spin_lock_init ( & port -> dev_list_lock ) ; }
intptr_t IncrementalMarking :: ProcessMarkingWorklist ( intptr_t bytes_to_process , ForceCompletionAction completion ) { intptr_t bytes_processed = 0 ; while ( bytes_processed < bytes_to_process || completion == FORCE_COMPLETION ) { HeapObject * obj ; if ( worklist_to_process == WorklistToProcess :: kBailout ) { obj = marking_worklist ( ) -> PopBailout ( ) ; } else { obj = marking_worklist ( ) -> Pop ( ) ; } if ( obj == nullptr ) break ; if ( obj -> IsFiller ( ) ) { DCHECK ( ! marking_state ( ) -> IsImpossible ( obj ) ) ; continue ; } unscanned_bytes_of_large_object_ = 0 ; int size = VisitObject ( obj -> map ( ) , obj ) ; bytes_processed += size - unscanned_bytes_of_large_object_ ; } heap_ -> local_embedder_heap_tracer ( ) -> RegisterWrappersWithRemoteTracer ( ) ; return bytes_processed ; }
nsFormFillController :: StopControllingInput ( ) { RemoveKeyListener ( ) ; if ( mListNode ) { mListNode -> RemoveMutationObserver ( this ) ; mListNode = nullptr ; } nsCOMPtr < nsIAutoCompleteInput > input ; mController -> GetInput ( getter_AddRefs ( input ) ) ; if ( input == this ) mController -> SetInput ( nullptr ) ; if ( mFocusedInputNode ) { MaybeRemoveMutationObserver ( mFocusedInputNode ) ; mFocusedInputNode = nullptr ; mFocusedInput = nullptr ; } mFocusedPopup = nullptr ; }
Decoder :: Write ( const char * aBuffer , uint32_t aCount ) { PROFILER_LABEL ( "ImageDecoder" , "Write" ) ; NS_ABORT_IF_FALSE ( ! HasDecoderError ( ) , "Not allowed to make more decoder calls after error!" ) ; if ( HasDataError ( ) ) return ; if ( IsSizeDecode ( ) && HasSize ( ) ) { return ; } WriteInternal ( aBuffer , aCount ) ; while ( mSynchronous && NeedsNewFrame ( ) && ! HasDataError ( ) ) { nsresult rv = AllocateFrame ( ) ; if ( NS_SUCCEEDED ( rv ) ) { WriteInternal ( nullptr , 0 ) ; } } }
static MaybeHandle < Object > KeyedGetObjectProperty ( Isolate * isolate , Handle < Object > receiver_obj , Handle < Object > key_obj ) { uint32_t index ; if ( key_obj -> IsString ( ) && String :: cast ( * key_obj ) -> AsArrayIndex ( & index ) ) { key_obj = isolate -> factory ( ) -> NewNumberFromUint ( index ) ; } if ( receiver_obj -> IsJSObject ( ) ) { if ( ! receiver_obj -> IsJSGlobalProxy ( ) && ! receiver_obj -> IsAccessCheckNeeded ( ) && key_obj -> IsName ( ) ) { Handle < JSObject > receiver = Handle < JSObject > :: cast ( receiver_obj ) ; Handle < Name > key = Handle < Name > :: cast ( key_obj ) ; key_obj = key = isolate -> factory ( ) -> InternalizeName ( key ) ; DisallowHeapAllocation no_allocation ; if ( receiver -> IsJSGlobalObject ( ) ) { GlobalDictionary * dictionary = JSGlobalObject :: cast ( * receiver ) -> global_dictionary ( ) ; int entry = dictionary -> FindEntry ( isolate , key ) ; if ( entry != GlobalDictionary :: kNotFound ) { PropertyCell * cell = dictionary -> CellAt ( entry ) ; if ( cell -> property_details ( ) . kind ( ) == kData ) { Object * value = cell -> value ( ) ; if ( ! value -> IsTheHole ( isolate ) ) { return Handle < Object > ( value , isolate ) ; } } } } else if ( ! receiver -> HasFastProperties ( ) ) { NameDictionary * dictionary = receiver -> property_dictionary ( ) ; int entry = dictionary -> FindEntry ( isolate , key ) ; if ( ( entry != NameDictionary :: kNotFound ) && ( dictionary -> DetailsAt ( entry ) . kind ( ) == kData ) ) { Object * value = dictionary -> ValueAt ( entry ) ; return Handle < Object > ( value , isolate ) ; } } } else if ( key_obj -> IsSmi ( ) ) { Handle < JSObject > js_object = Handle < JSObject > :: cast ( receiver_obj ) ; ElementsKind elements_kind = js_object -> GetElementsKind ( ) ; if ( IsDoubleElementsKind ( elements_kind ) ) { if ( Smi :: ToInt ( * key_obj ) >= js_object -> elements ( ) -> length ( ) ) { elements_kind = IsHoleyElementsKind ( elements_kind ) ? HOLEY_ELEMENTS : PACKED_ELEMENTS ; JSObject :: TransitionElementsKind ( js_object , elements_kind ) ; } } else { DCHECK ( IsSmiOrObjectElementsKind ( elements_kind ) || ! IsFastElementsKind ( elements_kind ) ) ; } } } else if ( receiver_obj -> IsString ( ) && key_obj -> IsSmi ( ) ) { Handle < String > str = Handle < String > :: cast ( receiver_obj ) ; int index = Handle < Smi > :: cast ( key_obj ) -> value ( ) ; if ( index >= 0 && index < str -> length ( ) ) { Factory * factory = isolate -> factory ( ) ; return factory -> LookupSingleCharacterStringFromCode ( String :: Flatten ( isolate , str ) -> Get ( index ) ) ; } } return Runtime :: GetObjectProperty ( isolate , receiver_obj , key_obj ) ; }
aaudio_result_t AAudioServiceStreamMMAP :: startClient ( const android :: AudioClient & client , audio_port_handle_t * clientHandle ) { aaudio_result_t result = mServiceEndpoint -> startClient ( client , clientHandle ) ; return result ; }
static int mp_get_count ( struct sb_uart_state * state , struct serial_icounter_struct * icnt ) { struct serial_icounter_struct icount ; struct sb_uart_icount cnow ; struct sb_uart_port * port = state -> port ; spin_lock_irq ( & port -> lock ) ; memcpy ( & cnow , & port -> icount , sizeof ( struct sb_uart_icount ) ) ; spin_unlock_irq ( & port -> lock ) ; icount . cts = cnow . cts ; icount . dsr = cnow . dsr ; icount . rng = cnow . rng ; icount . dcd = cnow . dcd ; icount . rx = cnow . rx ; icount . tx = cnow . tx ; icount . frame = cnow . frame ; icount . overrun = cnow . overrun ; icount . parity = cnow . parity ; icount . brk = cnow . brk ; icount . buf_overrun = cnow . buf_overrun ; return copy_to_user ( icnt , & icount , sizeof ( icount ) ) ? - EFAULT : 0 ; }
PrimitiveStatus TrustedPrimitives :: UntrustedCall ( uint64_t untrusted_selector , MessageWriter * input , MessageReader * output ) { int ret ; UntrustedCacheMalloc * untrusted_cache = UntrustedCacheMalloc :: Instance ( ) ; SgxParams * const sgx_params = reinterpret_cast < SgxParams * > ( untrusted_cache -> Malloc ( sizeof ( SgxParams ) ) ) ; Cleanup clean_up ( [ sgx_params , untrusted_cache ] { untrusted_cache -> Free ( sgx_params ) ; } ) ; sgx_params -> input_size = 0 ; sgx_params -> input = nullptr ; if ( input ) { sgx_params -> input_size = input -> MessageSize ( ) ; if ( sgx_params -> input_size > 0 ) { sgx_params -> input = untrusted_cache -> Malloc ( sgx_params -> input_size ) ; input -> Serialize ( const_cast < void * > ( sgx_params -> input ) ) ; } } sgx_params -> output_size = 0 ; sgx_params -> output = nullptr ; CHECK_OCALL ( ocall_dispatch_untrusted_call ( & ret , untrusted_selector , sgx_params ) ) ; if ( sgx_params -> input ) { untrusted_cache -> Free ( const_cast < void * > ( sgx_params -> input ) ) ; } if ( sgx_params -> output ) { output -> Deserialize ( sgx_params -> output , sgx_params -> output_size ) ; TrustedPrimitives :: UntrustedLocalFree ( sgx_params -> output ) ; } return PrimitiveStatus :: OkStatus ( ) ; }
Type OperationTyper :: NumberToString ( Type type ) { DCHECK ( type . Is ( Type :: Number ( ) ) ) ; if ( type . IsNone ( ) ) return type ; if ( type . Is ( Type :: NaN ( ) ) ) return singleton_NaN_string_ ; if ( type . Is ( cache_ . kZeroOrMinusZero ) ) return singleton_zero_string_ ; return Type :: String ( ) ; }
mcs_recv_connect_response ( STREAM mcs_data ) { UNUSED ( mcs_data ) ; uint8 result ; int length ; STREAM s ; RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( Protocol , Debug , "%s()" , __func__ ) ; s = iso_recv ( & is_fastpath , & fastpath_hdr ) ; if ( s == NULL ) return False ; ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; ber_parse_header ( s , BER_TAG_RESULT , & length ) ; in_uint8 ( s , result ) ; if ( result != 0 ) { logger ( Protocol , Error , "mcs_recv_connect_response(), result=%d" , result ) ; return False ; } ber_parse_header ( s , BER_TAG_INTEGER , & length ) ; in_uint8s ( s , length ) ; mcs_parse_domain_params ( s ) ; ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ; sec_process_mcs_data ( s ) ; return s_check_end ( s ) ; }
TF_BUILTIN ( StringPrototypeSplit , StringBuiltinsAssembler ) { const int kSeparatorArg = 0 ; const int kLimitArg = 1 ; Node * const argc = ChangeInt32ToIntPtr ( Parameter ( Descriptor :: kJSActualArgumentsCount ) ) ; CodeStubArguments args ( this , argc ) ; Node * const receiver = args . GetReceiver ( ) ; Node * const separator = args . GetOptionalArgumentValue ( kSeparatorArg ) ; Node * const limit = args . GetOptionalArgumentValue ( kLimitArg ) ; TNode < Context > context = CAST ( Parameter ( Descriptor :: kContext ) ) ; TNode < Smi > smi_zero = SmiConstant ( 0 ) ; RequireObjectCoercible ( context , receiver , "String.prototype.split" ) ; MaybeCallFunctionAtSymbol ( context , separator , receiver , isolate ( ) -> factory ( ) -> split_symbol ( ) , [ & ] ( ) { args . PopAndReturn ( CallBuiltin ( Builtins :: kRegExpSplit , context , separator , receiver , limit ) ) ; } , [ & ] ( Node * fn ) { Callable call_callable = CodeFactory :: Call ( isolate ( ) ) ; args . PopAndReturn ( CallJS ( call_callable , context , fn , separator , receiver , limit ) ) ; } ) ; TNode < String > subject_string = ToString_Inline ( context , receiver ) ; TNode < Number > limit_number = Select < Number > ( IsUndefined ( limit ) , [ = ] { return NumberConstant ( kMaxUInt32 ) ; } , [ = ] { return ToUint32 ( context , limit ) ; } ) ; Node * const separator_string = ToString_Inline ( context , separator ) ; Label return_empty_array ( this ) ; GotoIf ( WordEqual < Object , Object > ( limit_number , smi_zero ) , & return_empty_array ) ; { Label next ( this ) ; GotoIfNot ( IsUndefined ( separator ) , & next ) ; const ElementsKind kind = PACKED_ELEMENTS ; Node * const native_context = LoadNativeContext ( context ) ; Node * const array_map = LoadJSArrayElementsMap ( kind , native_context ) ; Node * const length = SmiConstant ( 1 ) ; Node * const capacity = IntPtrConstant ( 1 ) ; Node * const result = AllocateJSArray ( kind , array_map , capacity , length ) ; TNode < FixedArray > const fixed_array = CAST ( LoadElements ( result ) ) ; StoreFixedArrayElement ( fixed_array , 0 , subject_string ) ; args . PopAndReturn ( result ) ; BIND ( & next ) ; } { Label next ( this ) ; GotoIfNot ( SmiEqual ( LoadStringLengthAsSmi ( separator_string ) , smi_zero ) , & next ) ; TNode < Smi > subject_length = LoadStringLengthAsSmi ( subject_string ) ; GotoIf ( SmiEqual ( subject_length , smi_zero ) , & return_empty_array ) ; args . PopAndReturn ( StringToArray ( context , subject_string , subject_length , limit_number ) ) ; BIND ( & next ) ; } Node * const result = CallRuntime ( Runtime :: kStringSplit , context , subject_string , separator_string , limit_number ) ; args . PopAndReturn ( result ) ; BIND ( & return_empty_array ) ; { const ElementsKind kind = PACKED_ELEMENTS ; Node * const native_context = LoadNativeContext ( context ) ; Node * const array_map = LoadJSArrayElementsMap ( kind , native_context ) ; Node * const length = smi_zero ; Node * const capacity = IntPtrConstant ( 0 ) ; Node * const result = AllocateJSArray ( kind , array_map , capacity , length ) ; args . PopAndReturn ( result ) ; } }
bool PipelineImpl :: SelectInstructions ( Linkage * linkage ) { auto call_descriptor = linkage -> GetIncomingDescriptor ( ) ; PipelineData * data = this -> data_ ; DCHECK_NOT_NULL ( data -> graph ( ) ) ; DCHECK_NOT_NULL ( data -> schedule ( ) ) ; if ( FLAG_turbo_profiling ) { data -> set_profiler_data ( BasicBlockInstrumentor :: Instrument ( info ( ) , data -> graph ( ) , data -> schedule ( ) , data -> isolate ( ) ) ) ; } bool verify_stub_graph = data -> verify_graph ( ) ; auto jump_opt = data -> jump_optimization_info ( ) ; if ( jump_opt && jump_opt -> is_optimizing ( ) ) { verify_stub_graph = false ; } if ( verify_stub_graph || ( FLAG_turbo_verify_machine_graph != nullptr && ( ! strcmp ( FLAG_turbo_verify_machine_graph , "*" ) || ! strcmp ( FLAG_turbo_verify_machine_graph , data -> debug_name ( ) ) ) ) ) { if ( FLAG_trace_verify_csa ) { AllowHandleDereference allow_deref ; CodeTracer :: Scope tracing_scope ( data -> GetCodeTracer ( ) ) ; OFStream os ( tracing_scope . file ( ) ) ; os < < "--------------------------------------------------\n" < < "--- Verifying " < < data -> debug_name ( ) < < " generated by TurboFan\n" < < "--------------------------------------------------\n" < < * data -> schedule ( ) < < "--------------------------------------------------\n" < < "--- End of " < < data -> debug_name ( ) < < " generated by TurboFan\n" < < "--------------------------------------------------\n" ; } Zone temp_zone ( data -> allocator ( ) , ZONE_NAME ) ; MachineGraphVerifier :: Run ( data -> graph ( ) , data -> schedule ( ) , linkage , data -> info ( ) -> IsStub ( ) , data -> debug_name ( ) , & temp_zone ) ; } data -> InitializeInstructionSequence ( call_descriptor ) ; data -> InitializeFrameData ( call_descriptor ) ; Run < InstructionSelectionPhase > ( linkage ) ; if ( data -> compilation_failed ( ) ) { info ( ) -> AbortOptimization ( BailoutReason :: kCodeGenerationFailed ) ; data -> EndPhaseKind ( ) ; return false ; } if ( info ( ) -> trace_turbo_json_enabled ( ) && ! data -> MayHaveUnverifiableGraph ( ) ) { AllowHandleDereference allow_deref ; TurboCfgFile tcf ( isolate ( ) ) ; tcf < < AsC1V ( "CodeGen" , data -> schedule ( ) , data -> source_positions ( ) , data -> sequence ( ) ) ; } if ( info ( ) -> trace_turbo_json_enabled ( ) ) { std :: ostringstream source_position_output ; data_ -> source_positions ( ) -> PrintJson ( source_position_output ) ; source_position_output < < ",\n\"NodeOrigins\" : " ; data_ -> node_origins ( ) -> PrintJson ( source_position_output ) ; data_ -> set_source_position_output ( source_position_output . str ( ) ) ; } data -> DeleteGraphZone ( ) ; data -> BeginPhaseKind ( "register allocation" ) ; bool run_verifier = FLAG_turbo_verify_allocation ; if ( call_descriptor -> HasRestrictedAllocatableRegisters ( ) ) { RegList registers = call_descriptor -> AllocatableRegisters ( ) ; DCHECK_LT ( 0 , NumRegs ( registers ) ) ; std :: unique_ptr < const RegisterConfiguration > config ; config . reset ( RegisterConfiguration :: RestrictGeneralRegisters ( registers ) ) ; AllocateRegisters ( config . get ( ) , call_descriptor , run_verifier ) ; } else if ( data -> info ( ) -> GetPoisoningMitigationLevel ( ) != PoisoningMitigationLevel :: kDontPoison ) { AllocateRegisters ( RegisterConfiguration :: Poisoning ( ) , call_descriptor , run_verifier ) ; #if defined(V8_TARGET_ARCH_IA32) && defined(V8_EMBEDDED_BUILTINS) } else if ( data_ -> assembler_options ( ) . isolate_independent_code ) { static_assert ( kRootRegister == kSpeculationPoisonRegister , "The following checks assume root equals poison register" ) ; CHECK_IMPLIES ( FLAG_embedded_builtins , ! FLAG_branch_load_poisoning ) ; CHECK_IMPLIES ( FLAG_embedded_builtins , ! FLAG_untrusted_code_mitigations ) ; AllocateRegisters ( RegisterConfiguration :: PreserveRootIA32 ( ) , call_descriptor , run_verifier ) ; #endif // V8_TARGET_ARCH_IA32 } else { AllocateRegisters ( RegisterConfiguration :: Default ( ) , call_descriptor , run_verifier ) ; } VerifyGeneratedCodeIsIdempotent ( ) ; Run < FrameElisionPhase > ( ) ; if ( data -> compilation_failed ( ) ) { info ( ) -> AbortOptimization ( BailoutReason :: kNotEnoughVirtualRegistersRegalloc ) ; data -> EndPhaseKind ( ) ; return false ; } bool generate_frame_at_start = data_ -> sequence ( ) -> instruction_blocks ( ) . front ( ) -> must_construct_frame ( ) ; if ( FLAG_turbo_jt ) { Run < JumpThreadingPhase > ( generate_frame_at_start ) ; } data -> EndPhaseKind ( ) ; return true ; }
static bool check_underflow ( const struct ip6t_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; if ( ! unconditional ( & e -> ipv6 ) ) return false ; t = ip6t_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }
void Builtins :: Generate_CEntry ( MacroAssembler * masm , int result_size , SaveFPRegsMode save_doubles , ArgvMode argv_mode , bool builtin_exit_frame ) { ProfileEntryHookStub :: MaybeCallEntryHook ( masm ) ; __ mov ( r5 , Operand ( r1 ) ) ; if ( argv_mode == kArgvInRegister ) { __ mov ( r1 , Operand ( r2 ) ) ; } else { __ add ( r1 , sp , Operand ( r0 , LSL , kPointerSizeLog2 ) ) ; __ sub ( r1 , r1 , Operand ( kPointerSize ) ) ; } FrameScope scope ( masm , StackFrame :: MANUAL ) ; __ EnterExitFrame ( save_doubles == kSaveFPRegs , 0 , builtin_exit_frame ? StackFrame :: BUILTIN_EXIT : StackFrame :: EXIT ) ; __ mov ( r4 , Operand ( r0 ) ) ; #if V8_HOST_ARCH_ARM int frame_alignment = MacroAssembler :: ActivationFrameAlignment ( ) ; int frame_alignment_mask = frame_alignment - 1 ; if ( FLAG_debug_code ) { if ( frame_alignment > kPointerSize ) { Label alignment_as_expected ; DCHECK ( base :: bits :: IsPowerOfTwo ( frame_alignment ) ) ; __ tst ( sp , Operand ( frame_alignment_mask ) ) ; __ b ( eq , & alignment_as_expected ) ; __ stop ( "Unexpected alignment" ) ; __ bind ( & alignment_as_expected ) ; } } #endif __ Move ( r2 , ExternalReference :: isolate_address ( masm -> isolate ( ) ) ) ; { Assembler :: BlockConstPoolScope block_const_pool ( masm ) ; __ add ( lr , pc , Operand ( 4 ) ) ; __ str ( lr , MemOperand ( sp ) ) ; __ Call ( r5 ) ; } Label exception_returned ; __ CompareRoot ( r0 , Heap :: kExceptionRootIndex ) ; __ b ( eq , & exception_returned ) ; if ( FLAG_debug_code ) { Label okay ; ExternalReference pending_exception_address = ExternalReference :: Create ( IsolateAddressId :: kPendingExceptionAddress , masm -> isolate ( ) ) ; __ Move ( r3 , pending_exception_address ) ; __ ldr ( r3 , MemOperand ( r3 ) ) ; __ CompareRoot ( r3 , Heap :: kTheHoleValueRootIndex ) ; __ b ( eq , & okay ) ; __ stop ( "Unexpected pending exception" ) ; __ bind ( & okay ) ; } Register argc = argv_mode == kArgvInRegister ? no_reg : r4 ; __ LeaveExitFrame ( save_doubles == kSaveFPRegs , argc ) ; __ mov ( pc , lr ) ; __ bind ( & exception_returned ) ; ExternalReference pending_handler_context_address = ExternalReference :: Create ( IsolateAddressId :: kPendingHandlerContextAddress , masm -> isolate ( ) ) ; ExternalReference pending_handler_entrypoint_address = ExternalReference :: Create ( IsolateAddressId :: kPendingHandlerEntrypointAddress , masm -> isolate ( ) ) ; ExternalReference pending_handler_fp_address = ExternalReference :: Create ( IsolateAddressId :: kPendingHandlerFPAddress , masm -> isolate ( ) ) ; ExternalReference pending_handler_sp_address = ExternalReference :: Create ( IsolateAddressId :: kPendingHandlerSPAddress , masm -> isolate ( ) ) ; ExternalReference find_handler = ExternalReference :: Create ( Runtime :: kUnwindAndFindExceptionHandler ) ; { FrameScope scope ( masm , StackFrame :: MANUAL ) ; __ PrepareCallCFunction ( 3 , 0 ) ; __ mov ( r0 , Operand ( 0 ) ) ; __ mov ( r1 , Operand ( 0 ) ) ; __ Move ( r2 , ExternalReference :: isolate_address ( masm -> isolate ( ) ) ) ; __ CallCFunction ( find_handler , 3 ) ; } __ Move ( cp , pending_handler_context_address ) ; __ ldr ( cp , MemOperand ( cp ) ) ; __ Move ( sp , pending_handler_sp_address ) ; __ ldr ( sp , MemOperand ( sp ) ) ; __ Move ( fp , pending_handler_fp_address ) ; __ ldr ( fp , MemOperand ( fp ) ) ; __ cmp ( cp , Operand ( 0 ) ) ; __ str ( cp , MemOperand ( fp , StandardFrameConstants :: kContextOffset ) , ne ) ; __ ResetSpeculationPoisonRegister ( ) ; ConstantPoolUnavailableScope constant_pool_unavailable ( masm ) ; __ Move ( r1 , pending_handler_entrypoint_address ) ; __ ldr ( r1 , MemOperand ( r1 ) ) ; __ Jump ( r1 ) ; }
static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { struct flowi6 fl6 ; dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; if ( ! dst ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( np -> opt != NULL ) newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; dccp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req && ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
int jas_stream_write ( jas_stream_t * stream , const void * buf , int cnt ) { int n ; const char * bufptr ; bufptr = buf ; n = 0 ; while ( n < cnt ) { if ( jas_stream_putc ( stream , * bufptr ) == EOF ) { return n ; } ++ bufptr ; ++ n ; } return n ; }
OMX_ERRORTYPE SimpleSoftOMXComponent :: internalSetParameter ( OMX_INDEXTYPE index , const OMX_PTR params ) { switch ( index ) { case OMX_IndexParamPortDefinition : { OMX_PARAM_PORTDEFINITIONTYPE * defParams = ( OMX_PARAM_PORTDEFINITIONTYPE * ) params ; if ( defParams -> nPortIndex >= mPorts . size ( ) ) { return OMX_ErrorBadPortIndex ; } if ( defParams -> nSize != sizeof ( OMX_PARAM_PORTDEFINITIONTYPE ) ) { return OMX_ErrorUnsupportedSetting ; } PortInfo * port = & mPorts . editItemAt ( defParams -> nPortIndex ) ; if ( defParams -> nBufferSize > port -> mDef . nBufferSize ) { port -> mDef . nBufferSize = defParams -> nBufferSize ; } if ( defParams -> nBufferCountActual < port -> mDef . nBufferCountMin ) { ALOGW ( "component requires at least %u buffers (%u requested)" , port -> mDef . nBufferCountMin , defParams -> nBufferCountActual ) ; return OMX_ErrorUnsupportedSetting ; } port -> mDef . nBufferCountActual = defParams -> nBufferCountActual ; return OMX_ErrorNone ; } default : return OMX_ErrorUnsupportedIndex ; } }
void Sweeper :: AbortAndWaitForTasks ( ) { if ( ! FLAG_concurrent_sweeping ) return ; for ( int i = 0 ; i < num_tasks_ ; i ++ ) { if ( heap_ -> isolate ( ) -> cancelable_task_manager ( ) -> TryAbort ( task_ids_ [ i ] ) != CancelableTaskManager :: kTaskAborted ) { pending_sweeper_tasks_semaphore_ . Wait ( ) ; } else { num_sweeping_tasks_ -- ; } } num_tasks_ = 0 ; DCHECK_EQ ( 0 , num_sweeping_tasks_ ) ; }
static struct sctp_association * __sctp_rcv_init_lookup ( struct net * net , struct sk_buff * skb , const union sctp_addr * laddr , struct sctp_transport * * transportp ) { struct sctp_association * asoc ; union sctp_addr addr ; union sctp_addr * paddr = & addr ; struct sctphdr * sh = sctp_hdr ( skb ) ; union sctp_params params ; struct sctp_init_chunk * init ; struct sctp_af * af ; init = ( struct sctp_init_chunk * ) skb -> data ; sctp_walk_params ( params , init , init_hdr . params ) { af = sctp_get_af_specific ( param_type2af ( params . p -> type ) ) ; if ( ! af ) continue ; af -> from_addr_param ( paddr , params . addr , sh -> source , 0 ) ; asoc = __sctp_lookup_association ( net , laddr , paddr , transportp ) ; if ( asoc ) return asoc ; } return NULL ; }
png_set_tIME ( png_const_structrp png_ptr , png_inforp info_ptr , png_const_timep mod_time ) { png_debug1 ( 1 , "in %s storage function" , "tIME" ) ; if ( png_ptr == NULL || info_ptr == NULL || mod_time == NULL || ( png_ptr -> mode & PNG_WROTE_tIME ) ) return ; if ( mod_time -> month == 0 || mod_time -> month > 12 || mod_time -> day == 0 || mod_time -> day > 31 || mod_time -> hour > 23 || mod_time -> minute > 59 || mod_time -> second > 60 ) { png_warning ( png_ptr , "Ignoring invalid time value" ) ; return ; } info_ptr -> mod_time = * mod_time ; info_ptr -> valid |= PNG_INFO_tIME ; }
static PyObject * __pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter_8flush ( struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter * __pyx_v_self ) { PyObject * __pyx_r = NULL ; __Pyx_RefNannyDeclarations PyObject * __pyx_t_1 = NULL ; __Pyx_RefNannySetupContext ( "flush" , 0 ) ; __pyx_t_1 = ( ( struct __pyx_vtabstruct_17clickhouse_driver_14bufferedwriter_BufferedWriter * ) __pyx_v_self -> __pyx_vtab ) -> write_into_stream ( __pyx_v_self , 0 ) ; if ( unlikely ( ! __pyx_t_1 ) ) __PYX_ERR ( 0 , 47 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_1 ) ; __Pyx_DECREF ( __pyx_t_1 ) ; __pyx_t_1 = 0 ; __pyx_r = Py_None ; __Pyx_INCREF ( Py_None ) ; goto __pyx_L0 ; __pyx_L1_error : ; __Pyx_XDECREF ( __pyx_t_1 ) ; __Pyx_AddTraceback ( "clickhouse_driver.bufferedwriter.BufferedWriter.flush" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __pyx_r = NULL ; __pyx_L0 : ; __Pyx_XGIVEREF ( __pyx_r ) ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
mjit :: Compiler :: inlineNativeFunction ( uint32_t argc , bool callingNew ) { if ( ! cx -> typeInferenceEnabled ( ) ) return Compile_InlineAbort ; FrameEntry * origCallee = frame . peek ( - ( ( int ) argc + 2 ) ) ; FrameEntry * thisValue = frame . peek ( - ( ( int ) argc + 1 ) ) ; types :: StackTypeSet * thisTypes = analysis -> poppedTypes ( PC , argc ) ; if ( ! origCallee -> isConstant ( ) || ! origCallee -> isType ( JSVAL_TYPE_OBJECT ) ) return Compile_InlineAbort ; JSObject * callee = & origCallee -> getValue ( ) . toObject ( ) ; if ( ! callee -> isFunction ( ) ) return Compile_InlineAbort ; if ( ! globalObj || globalObj != & callee -> global ( ) ) return Compile_InlineAbort ; Native native = callee -> toFunction ( ) -> maybeNative ( ) ; if ( ! native ) return Compile_InlineAbort ; JSValueType type = knownPushedType ( 0 ) ; JSValueType thisType = thisValue -> isTypeKnown ( ) ? thisValue -> getKnownType ( ) : JSVAL_TYPE_UNKNOWN ; if ( native == js_Array && type == JSVAL_TYPE_OBJECT && globalObj ) { if ( argc == 0 || argc == 1 ) return compileArrayWithLength ( argc ) ; return compileArrayWithArgs ( argc ) ; } if ( callingNew ) return Compile_InlineAbort ; if ( native == js :: num_parseInt && argc >= 1 ) { FrameEntry * arg = frame . peek ( - ( int32_t ) argc ) ; JSValueType argType = arg -> isTypeKnown ( ) ? arg -> getKnownType ( ) : JSVAL_TYPE_UNKNOWN ; if ( ( argType == JSVAL_TYPE_DOUBLE || argType == JSVAL_TYPE_INT32 ) && type == JSVAL_TYPE_INT32 ) { return compileParseInt ( argType , argc ) ; } } if ( argc == 0 ) { } else if ( argc == 1 ) { FrameEntry * arg = frame . peek ( - 1 ) ; types :: StackTypeSet * argTypes = frame . extra ( arg ) . types ; if ( ! argTypes ) return Compile_InlineAbort ; JSValueType argType = arg -> isTypeKnown ( ) ? arg -> getKnownType ( ) : JSVAL_TYPE_UNKNOWN ; if ( native == js_math_abs ) { if ( argType == JSVAL_TYPE_INT32 && type == JSVAL_TYPE_INT32 ) return compileMathAbsInt ( arg ) ; if ( argType == JSVAL_TYPE_DOUBLE && type == JSVAL_TYPE_DOUBLE ) return compileMathAbsDouble ( arg ) ; } if ( native == js_math_floor && argType == JSVAL_TYPE_DOUBLE && type == JSVAL_TYPE_INT32 ) { return compileRound ( arg , Floor ) ; } if ( native == js_math_round && argType == JSVAL_TYPE_DOUBLE && type == JSVAL_TYPE_INT32 ) { return compileRound ( arg , Round ) ; } if ( native == js_math_sqrt && type == JSVAL_TYPE_DOUBLE && masm . supportsFloatingPointSqrt ( ) && ( argType == JSVAL_TYPE_INT32 || argType == JSVAL_TYPE_DOUBLE ) ) { return compileMathSqrt ( arg ) ; } if ( native == js_str_charCodeAt && argType == JSVAL_TYPE_INT32 && thisType == JSVAL_TYPE_STRING && type == JSVAL_TYPE_INT32 ) { return compileGetChar ( thisValue , arg , GetCharCode ) ; } if ( native == js_str_charAt && argType == JSVAL_TYPE_INT32 && thisType == JSVAL_TYPE_STRING && type == JSVAL_TYPE_STRING ) { return compileGetChar ( thisValue , arg , GetChar ) ; } if ( native == js :: str_fromCharCode && argType == JSVAL_TYPE_INT32 && type == JSVAL_TYPE_STRING ) { return compileStringFromCode ( arg ) ; } if ( native == js :: array_push && thisType == JSVAL_TYPE_OBJECT && type == JSVAL_TYPE_INT32 ) { if ( thisTypes -> getKnownClass ( ) == & ArrayClass && ! thisTypes -> hasObjectFlags ( cx , types :: OBJECT_FLAG_SPARSE_INDEXES | types :: OBJECT_FLAG_LENGTH_OVERFLOW ) && ! types :: ArrayPrototypeHasIndexedProperty ( cx , outerScript ) ) { types :: StackTypeSet :: DoubleConversion conversion = thisTypes -> convertDoubleElements ( cx ) ; if ( conversion != types :: StackTypeSet :: AmbiguousDoubleConversion ) return compileArrayPush ( thisValue , arg , conversion ) ; } } if ( native == js :: array_concat && argType == JSVAL_TYPE_OBJECT && thisType == JSVAL_TYPE_OBJECT && type == JSVAL_TYPE_OBJECT && thisTypes -> getKnownClass ( ) == & ArrayClass && ! thisTypes -> hasObjectFlags ( cx , types :: OBJECT_FLAG_SPARSE_INDEXES | types :: OBJECT_FLAG_LENGTH_OVERFLOW ) && argTypes -> getKnownClass ( ) == & ArrayClass && ! argTypes -> hasObjectFlags ( cx , types :: OBJECT_FLAG_SPARSE_INDEXES | types :: OBJECT_FLAG_LENGTH_OVERFLOW ) && ! types :: ArrayPrototypeHasIndexedProperty ( cx , outerScript ) ) { return compileArrayConcat ( thisTypes , argTypes , thisValue , arg ) ; } } else if ( argc == 2 ) { FrameEntry * arg1 = frame . peek ( - 2 ) ; FrameEntry * arg2 = frame . peek ( - 1 ) ; JSValueType arg1Type = arg1 -> isTypeKnown ( ) ? arg1 -> getKnownType ( ) : JSVAL_TYPE_UNKNOWN ; JSValueType arg2Type = arg2 -> isTypeKnown ( ) ? arg2 -> getKnownType ( ) : JSVAL_TYPE_UNKNOWN ; if ( native == js_math_pow && type == JSVAL_TYPE_DOUBLE && masm . supportsFloatingPointSqrt ( ) && ( arg1Type == JSVAL_TYPE_DOUBLE || arg1Type == JSVAL_TYPE_INT32 ) && arg2Type == JSVAL_TYPE_DOUBLE && arg2 -> isConstant ( ) ) { Value arg2Value = arg2 -> getValue ( ) ; if ( arg2Value . toDouble ( ) == - 0.5 || arg2Value . toDouble ( ) == 0.5 ) return compileMathPowSimple ( arg1 , arg2 ) ; } if ( ( native == js_math_min || native == js_math_max ) ) { if ( arg1Type == JSVAL_TYPE_INT32 && arg2Type == JSVAL_TYPE_INT32 && type == JSVAL_TYPE_INT32 ) { return compileMathMinMaxInt ( arg1 , arg2 , native == js_math_min ? Assembler :: LessThan : Assembler :: GreaterThan ) ; } if ( ( arg1Type == JSVAL_TYPE_INT32 || arg1Type == JSVAL_TYPE_DOUBLE ) && ( arg2Type == JSVAL_TYPE_INT32 || arg2Type == JSVAL_TYPE_DOUBLE ) && type == JSVAL_TYPE_DOUBLE ) { return compileMathMinMaxDouble ( arg1 , arg2 , ( native == js_math_min ) ? Assembler :: DoubleLessThan : Assembler :: DoubleGreaterThan ) ; } } } return Compile_InlineAbort ; }
void MarkCompactCollector :: CollectEvacuationCandidates ( PagedSpace * space ) { DCHECK ( space -> identity ( ) == OLD_SPACE || space -> identity ( ) == CODE_SPACE ) ; int number_of_pages = space -> CountTotalPages ( ) ; size_t area_size = space -> AreaSize ( ) ; typedef std :: pair < size_t , Page * > LiveBytesPagePair ; std :: vector < LiveBytesPagePair > pages ; pages . reserve ( number_of_pages ) ; DCHECK ( ! sweeping_in_progress ( ) ) ; Page * owner_of_linear_allocation_area = space -> top ( ) == space -> limit ( ) ? nullptr : Page :: FromAllocationAreaAddress ( space -> top ( ) ) ; for ( Page * p : * space ) { if ( p -> NeverEvacuate ( ) || ( p == owner_of_linear_allocation_area ) || ! p -> CanAllocate ( ) ) continue ; CHECK ( ! p -> IsEvacuationCandidate ( ) ) ; CHECK_NULL ( p -> slot_set < OLD_TO_OLD > ( ) ) ; CHECK_NULL ( p -> typed_slot_set < OLD_TO_OLD > ( ) ) ; CHECK ( p -> SweepingDone ( ) ) ; DCHECK ( p -> area_size ( ) == area_size ) ; pages . push_back ( std :: make_pair ( p -> allocated_bytes ( ) , p ) ) ; } int candidate_count = 0 ; size_t total_live_bytes = 0 ; const bool reduce_memory = heap ( ) -> ShouldReduceMemory ( ) ; if ( FLAG_manual_evacuation_candidates_selection ) { for ( size_t i = 0 ; i < pages . size ( ) ; i ++ ) { Page * p = pages [ i ] . second ; if ( p -> IsFlagSet ( MemoryChunk :: FORCE_EVACUATION_CANDIDATE_FOR_TESTING ) ) { candidate_count ++ ; total_live_bytes += pages [ i ] . first ; p -> ClearFlag ( MemoryChunk :: FORCE_EVACUATION_CANDIDATE_FOR_TESTING ) ; AddEvacuationCandidate ( p ) ; } } } else if ( FLAG_stress_compaction_random ) { double fraction = isolate ( ) -> fuzzer_rng ( ) -> NextDouble ( ) ; size_t pages_to_mark_count = static_cast < size_t > ( fraction * ( pages . size ( ) + 1 ) ) ; for ( uint64_t i : isolate ( ) -> fuzzer_rng ( ) -> NextSample ( pages . size ( ) , pages_to_mark_count ) ) { candidate_count ++ ; total_live_bytes += pages [ i ] . first ; AddEvacuationCandidate ( pages [ i ] . second ) ; } } else if ( FLAG_stress_compaction ) { for ( size_t i = 0 ; i < pages . size ( ) ; i ++ ) { Page * p = pages [ i ] . second ; if ( i % 2 == 0 ) { candidate_count ++ ; total_live_bytes += pages [ i ] . first ; AddEvacuationCandidate ( p ) ; } } } else { size_t max_evacuated_bytes ; int target_fragmentation_percent ; ComputeEvacuationHeuristics ( area_size , & target_fragmentation_percent , & max_evacuated_bytes ) ; const size_t free_bytes_threshold = target_fragmentation_percent * ( area_size / 100 ) ; std :: sort ( pages . begin ( ) , pages . end ( ) , [ ] ( const LiveBytesPagePair & a , const LiveBytesPagePair & b ) { return a . first < b . first ; } ) ; for ( size_t i = 0 ; i < pages . size ( ) ; i ++ ) { size_t live_bytes = pages [ i ] . first ; DCHECK_GE ( area_size , live_bytes ) ; size_t free_bytes = area_size - live_bytes ; if ( FLAG_always_compact || ( ( free_bytes >= free_bytes_threshold ) && ( ( total_live_bytes + live_bytes ) <= max_evacuated_bytes ) ) ) { candidate_count ++ ; total_live_bytes += live_bytes ; } if ( FLAG_trace_fragmentation_verbose ) { PrintIsolate ( isolate ( ) , "compaction-selection-page: space=%s free_bytes_page=%zu " "fragmentation_limit_kb=%" PRIuS " fragmentation_limit_percent=%d sum_compaction_kb=%zu " "compaction_limit_kb=%zu\n" , space -> name ( ) , free_bytes / KB , free_bytes_threshold / KB , target_fragmentation_percent , total_live_bytes / KB , max_evacuated_bytes / KB ) ; } } int estimated_new_pages = static_cast < int > ( ( total_live_bytes + area_size - 1 ) / area_size ) ; DCHECK_LE ( estimated_new_pages , candidate_count ) ; int estimated_released_pages = candidate_count - estimated_new_pages ; if ( ( estimated_released_pages == 0 ) && ! FLAG_always_compact ) { candidate_count = 0 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { AddEvacuationCandidate ( pages [ i ] . second ) ; } } if ( FLAG_trace_fragmentation ) { PrintIsolate ( isolate ( ) , "compaction-selection: space=%s reduce_memory=%d pages=%d " "total_live_bytes=%zu\n" , space -> name ( ) , reduce_memory , candidate_count , total_live_bytes / KB ) ; } }
ascii_toUtf8 ( const ENCODING * enc , const char * * fromP , const char * fromLim , char * * toP , const char * toLim ) { while ( * fromP != fromLim && * toP != toLim ) * ( * toP ) ++ = * ( * fromP ) ++ ; }
static int ptrace_check_attach ( struct task_struct * child , bool ignore_state ) { int ret = - ESRCH ; read_lock ( & tasklist_lock ) ; if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) { spin_lock_irq ( & child -> sighand -> siglock ) ; WARN_ON_ONCE ( task_is_stopped ( child ) ) ; if ( ignore_state || ( task_is_traced ( child ) && ! ( child -> jobctl & JOBCTL_LISTENING ) ) ) ret = 0 ; spin_unlock_irq ( & child -> sighand -> siglock ) ; } read_unlock ( & tasklist_lock ) ; if ( ! ret && ! ignore_state ) ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ; return ret ; }
static void Generate_InterpreterPushArgs ( MacroAssembler * masm , Register num_args , Register index , Register count , Register scratch ) { Label loop , skip ; __ CmpP ( count , Operand :: Zero ( ) ) ; __ beq ( & skip ) ; __ AddP ( index , index , Operand ( kPointerSize ) ) ; __ LoadRR ( r0 , count ) ; __ bind ( & loop ) ; __ LoadP ( scratch , MemOperand ( index , - kPointerSize ) ) ; __ lay ( index , MemOperand ( index , - kPointerSize ) ) ; __ push ( scratch ) ; __ SubP ( r0 , Operand ( 1 ) ) ; __ bne ( & loop ) ; __ bind ( & skip ) ; }
void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = "`\"\\" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = '"' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { dlen -= 2 ; if ( dlen == 0 ) break ; * pt ++ = '\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = '"' ; * pt = '\0' ; }
GF_Err tenc_box_read ( GF_Box * s , GF_BitStream * bs ) { u8 iv_size ; GF_TrackEncryptionBox * ptr = ( GF_TrackEncryptionBox * ) s ; ISOM_DECREASE_SIZE ( ptr , 3 ) ; gf_bs_read_u8 ( bs ) ; if ( ! ptr -> version ) { gf_bs_read_u8 ( bs ) ; } else { ptr -> crypt_byte_block = gf_bs_read_int ( bs , 4 ) ; ptr -> skip_byte_block = gf_bs_read_int ( bs , 4 ) ; } ptr -> isProtected = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , 17 ) ; ptr -> key_info [ 0 ] = 0 ; ptr -> key_info [ 1 ] = 0 ; ptr -> key_info [ 2 ] = 0 ; ptr -> key_info [ 3 ] = iv_size = gf_bs_read_u8 ( bs ) ; gf_bs_read_data ( bs , ptr -> key_info + 4 , 16 ) ; if ( ! iv_size && ptr -> isProtected ) { ISOM_DECREASE_SIZE ( ptr , 1 ) ; iv_size = ptr -> key_info [ 20 ] = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , ptr -> key_info [ 20 ] ) ; gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ; } return GF_OK ; }
void Heap :: VerifyObjectLayoutChange ( HeapObject * object , Map * new_map ) { if ( ! FLAG_verify_heap ) return ; if ( pending_layout_change_object_ == nullptr ) { if ( object -> IsJSObject ( ) ) { DCHECK ( ! object -> map ( ) -> TransitionRequiresSynchronizationWithGC ( new_map ) ) ; } else { SlotCollectingVisitor old_visitor ; object -> IterateFast ( & old_visitor ) ; MapWord old_map_word = object -> map_word ( ) ; object -> set_map_word ( MapWord :: FromMap ( new_map ) ) ; SlotCollectingVisitor new_visitor ; object -> IterateFast ( & new_visitor ) ; object -> set_map_word ( old_map_word ) ; DCHECK_EQ ( new_visitor . number_of_slots ( ) , old_visitor . number_of_slots ( ) ) ; for ( int i = 0 ; i < new_visitor . number_of_slots ( ) ; i ++ ) { DCHECK_EQ ( new_visitor . slot ( i ) , old_visitor . slot ( i ) ) ; } } } else { DCHECK_EQ ( pending_layout_change_object_ , object ) ; pending_layout_change_object_ = nullptr ; } }
void Builtins :: Generate_CallOrConstructForwardVarargs ( MacroAssembler * masm , CallOrConstructMode mode , Handle < Code > code ) { Register scratch = r8 ; if ( mode == CallOrConstructMode :: kConstruct ) { Label new_target_constructor , new_target_not_constructor ; __ JumpIfSmi ( r5 , & new_target_not_constructor ) ; __ LoadP ( scratch , FieldMemOperand ( r5 , HeapObject :: kMapOffset ) ) ; __ LoadlB ( scratch , FieldMemOperand ( scratch , Map :: kBitFieldOffset ) ) ; __ tmll ( scratch , Operand ( Map :: IsConstructorBit :: kShift ) ) ; __ bne ( & new_target_constructor ) ; __ bind ( & new_target_not_constructor ) ; { FrameScope scope ( masm , StackFrame :: MANUAL ) ; __ EnterFrame ( StackFrame :: INTERNAL ) ; __ Push ( r5 ) ; __ CallRuntime ( Runtime :: kThrowNotConstructor ) ; } __ bind ( & new_target_constructor ) ; } Label arguments_adaptor , arguments_done ; __ LoadP ( r6 , MemOperand ( fp , StandardFrameConstants :: kCallerFPOffset ) ) ; __ LoadP ( ip , MemOperand ( r6 , CommonFrameConstants :: kContextOrFrameTypeOffset ) ) ; __ CmpP ( ip , Operand ( StackFrame :: TypeToMarker ( StackFrame :: ARGUMENTS_ADAPTOR ) ) ) ; __ beq ( & arguments_adaptor ) ; { __ LoadP ( r7 , MemOperand ( fp , JavaScriptFrameConstants :: kFunctionOffset ) ) ; __ LoadP ( r7 , FieldMemOperand ( r7 , JSFunction :: kSharedFunctionInfoOffset ) ) ; __ LoadLogicalHalfWordP ( r7 , FieldMemOperand ( r7 , SharedFunctionInfo :: kFormalParameterCountOffset ) ) ; __ LoadRR ( r6 , fp ) ; } __ b ( & arguments_done ) ; __ bind ( & arguments_adaptor ) ; { __ LoadP ( r7 , MemOperand ( r6 , ArgumentsAdaptorFrameConstants :: kLengthOffset ) ) ; __ SmiUntag ( r7 ) ; } __ bind ( & arguments_done ) ; Label stack_done , stack_overflow ; __ SubP ( r7 , r7 , r4 ) ; __ CmpP ( r7 , Operand :: Zero ( ) ) ; __ ble ( & stack_done ) ; { Generate_StackOverflowCheck ( masm , r7 , r4 , & stack_overflow ) ; { Label loop ; __ AddP ( r6 , r6 , Operand ( kPointerSize ) ) ; __ AddP ( r2 , r2 , r7 ) ; __ bind ( & loop ) ; { __ ShiftLeftP ( ip , r7 , Operand ( kPointerSizeLog2 ) ) ; __ LoadP ( ip , MemOperand ( r6 , ip ) ) ; __ push ( ip ) ; __ SubP ( r7 , r7 , Operand ( 1 ) ) ; __ CmpP ( r7 , Operand :: Zero ( ) ) ; __ bne ( & loop ) ; } } } __ b ( & stack_done ) ; __ bind ( & stack_overflow ) ; __ TailCallRuntime ( Runtime :: kThrowStackOverflow ) ; __ bind ( & stack_done ) ; __ Jump ( code , RelocInfo :: CODE_TARGET ) ; }
void usb_serial_console_disconnect ( struct usb_serial * serial ) { if ( serial -> port [ 0 ] == usbcons_info . port ) { usb_serial_console_exit ( ) ; usb_serial_put ( serial ) ; } }
static BOOL gdi_Bitmap_Decompress ( rdpContext * context , rdpBitmap * bitmap , const BYTE * pSrcData , UINT32 DstWidth , UINT32 DstHeight , UINT32 bpp , UINT32 length , BOOL compressed , UINT32 codecId ) { UINT32 SrcSize = length ; rdpGdi * gdi = context -> gdi ; bitmap -> compressed = FALSE ; bitmap -> format = gdi -> dstFormat ; bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ; if ( ! bitmap -> data ) return FALSE ; if ( compressed ) { if ( bpp < 32 ) { if ( ! interleaved_decompress ( context -> codecs -> interleaved , pSrcData , SrcSize , DstWidth , DstHeight , bpp , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , & gdi -> palette ) ) return FALSE ; } else { if ( ! planar_decompress ( context -> codecs -> planar , pSrcData , SrcSize , DstWidth , DstHeight , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , TRUE ) ) return FALSE ; } } else { const UINT32 SrcFormat = gdi_get_pixel_format ( bpp ) ; const size_t sbpp = GetBytesPerPixel ( SrcFormat ) ; const size_t dbpp = GetBytesPerPixel ( bitmap -> format ) ; if ( ( sbpp == 0 ) || ( dbpp == 0 ) ) return FALSE ; else { const size_t dstSize = SrcSize * dbpp / sbpp ; if ( dstSize < bitmap -> length ) return FALSE ; } if ( ! freerdp_image_copy ( bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , pSrcData , SrcFormat , 0 , 0 , 0 , & gdi -> palette , FREERDP_FLIP_VERTICAL ) ) return FALSE ; } return TRUE ; }
Status ImportNodes ( ValueMapManager value_manager , const RepeatedPtrField < NodeDef > & nodes , OpBuilder & builder ) { Location unknown_loc = builder . getUnknownLoc ( ) ; MLIRContext * context = builder . getContext ( ) ; Type placeholder_ty = OpaqueTensorType :: get ( context ) ; Type control_ty = ControlType :: get ( context ) ; TFGraphDialect * tfgDialect = cast < TFGraphDialect > ( context -> getLoadedDialect ( "tfg" ) ) ; StringAttr device_attr = tfgDialect -> getDeviceAttrIdentifier ( ) ; StringAttr name_attr = tfgDialect -> getNameAttrIdentifier ( ) ; StringAttr fulltype_attr = tfgDialect -> getFullTypeAttrIdentifier ( ) ; for ( const NodeDef & node : nodes ) { DVLOG ( 1 ) < < "Processing node " < < node . name ( ) < < "\n" ; if ( node . op ( ) . empty ( ) ) return InvalidArgument ( "empty op type" ) ; OperationState state ( unknown_loc , absl :: StrCat ( "tfg." , node . op ( ) ) ) ; for ( const std :: string & input : node . input ( ) ) state . operands . push_back ( value_manager . GetValueOrCreatePlaceholder ( input ) ) ; state . types . push_back ( placeholder_ty ) ; state . types . push_back ( control_ty ) ; for ( const auto & namedAttr : node . attr ( ) ) { const std :: string & name = namedAttr . first ; const AttrValue & tf_attr = namedAttr . second ; TF_ASSIGN_OR_RETURN ( Attribute attr , ConvertAttributeValue ( tf_attr , builder , tfgDialect ) ) ; state . addAttribute ( name , attr ) ; } if ( ! node . device ( ) . empty ( ) ) state . addAttribute ( device_attr , StringAttr :: get ( context , node . device ( ) ) ) ; if ( ! node . name ( ) . empty ( ) ) state . addAttribute ( name_attr , StringAttr :: get ( context , node . name ( ) ) ) ; if ( node . has_experimental_type ( ) ) { TF_ASSIGN_OR_RETURN ( tf_type :: FullTypeAttr type , ConvertAttribute ( node . experimental_type ( ) , builder , tfgDialect ) ) ; state . addAttribute ( fulltype_attr , type ) ; } Operation * op = builder . create ( state ) ; StringRef node_name = node . name ( ) ; { size_t colon_sep = node_name . find_first_of ( ':' ) ; if ( colon_sep != StringRef :: npos ) node_name = node_name . take_front ( colon_sep ) ; } TF_RETURN_IF_ERROR ( value_manager . DefineOperation ( op , node_name ) ) ; } for ( Operation & op : * builder . getInsertionBlock ( ) ) { if ( op . getName ( ) . getStringRef ( ) == "tfg.__mlir_placeholder" ) { return InvalidArgument ( absl :: StrCat ( "Couldn't import graph: placeholder left " , op . getAttrOfType < StringAttr > ( name_attr ) . getValue ( ) . str ( ) ) ) ; } } return Status :: OK ( ) ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; const int num_elements = NumElements ( input ) ; TF_LITE_ENSURE_EQ ( context , num_elements , NumElements ( output ) ) ; switch ( input -> type ) { case kTfLiteInt64 : return copyToTensor ( context , input -> data . i64 , output , num_elements ) ; case kTfLiteInt32 : return copyToTensor ( context , input -> data . i32 , output , num_elements ) ; case kTfLiteUInt8 : return copyToTensor ( context , input -> data . uint8 , output , num_elements ) ; case kTfLiteFloat32 : return copyToTensor ( context , GetTensorData < float > ( input ) , output , num_elements ) ; case kTfLiteBool : return copyToTensor ( context , input -> data . b , output , num_elements ) ; case kTfLiteComplex64 : return copyToTensor ( context , reinterpret_cast < std :: complex < float > * > ( input -> data . c64 ) , output , num_elements ) ; default : TF_LITE_UNSUPPORTED_TYPE ( context , input -> type , "Cast" ) ; } return kTfLiteOk ; }
static int __dwc3_gadget_kick_transfer ( struct dwc3_ep * dep ) { struct dwc3_gadget_ep_cmd_params params ; struct dwc3_request * req ; int starting ; int ret ; u32 cmd ; if ( ! dwc3_calc_trbs_left ( dep ) ) return 0 ; starting = ! ( dep -> flags & DWC3_EP_BUSY ) ; dwc3_prepare_trbs ( dep ) ; req = next_request ( & dep -> started_list ) ; if ( ! req ) { dep -> flags |= DWC3_EP_PENDING_REQUEST ; return 0 ; } memset ( & params , 0 , sizeof ( params ) ) ; if ( starting ) { params . param0 = upper_32_bits ( req -> trb_dma ) ; params . param1 = lower_32_bits ( req -> trb_dma ) ; cmd = DWC3_DEPCMD_STARTTRANSFER ; if ( usb_endpoint_xfer_isoc ( dep -> endpoint . desc ) ) cmd |= DWC3_DEPCMD_PARAM ( dep -> frame_number ) ; } else { cmd = DWC3_DEPCMD_UPDATETRANSFER | DWC3_DEPCMD_PARAM ( dep -> resource_index ) ; } ret = dwc3_send_gadget_ep_cmd ( dep , cmd , & params ) ; if ( ret < 0 ) { if ( req -> trb ) memset ( req -> trb , 0 , sizeof ( struct dwc3_trb ) ) ; dep -> queued_requests -- ; dwc3_gadget_giveback ( dep , req , ret ) ; return ret ; } dep -> flags |= DWC3_EP_BUSY ; if ( starting ) { dep -> resource_index = dwc3_gadget_ep_get_transfer_index ( dep ) ; WARN_ON_ONCE ( ! dep -> resource_index ) ; } return 0 ; }
static int jas_iccputsint ( jas_stream_t * out , int n , longlong val ) { ulonglong tmp ; tmp = ( val < 0 ) ? ( abort ( ) , 0 ) : val ; return jas_iccputuint ( out , n , tmp ) ; }
TNode < Object > TypedArrayBuiltinsAssembler :: GetDefaultConstructor ( TNode < Context > context , TNode < JSTypedArray > exemplar ) { TVARIABLE ( IntPtrT , context_slot ) ; TNode < Word32T > elements_kind = LoadElementsKind ( exemplar ) ; DispatchTypedArrayByElementsKind ( elements_kind , [ & ] ( ElementsKind el_kind , int size , int typed_array_function_index ) { context_slot = IntPtrConstant ( typed_array_function_index ) ; } ) ; return LoadContextElement ( LoadNativeContext ( context ) , context_slot . value ( ) ) ; }
NEVER_INLINE void FX_OutOfMemoryTerminate ( ) { abort ( ) ; reinterpret_cast < void ( * ) ( ) > ( 0xbd ) ( ) ; }
int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ; ( * re_ast ) -> root_node = NULL ; return ERROR_SUCCESS ; }
IDBRequest :: NotifyHelperSentResultsToChildProcess ( nsresult aRv ) { NS_ASSERTION ( NS_IsMainThread ( ) , "Wrong thread!" ) ; NS_ASSERTION ( ! mHaveResultOrErrorCode , "Already called!" ) ; NS_ASSERTION ( ! PreservingWrapper ( ) , "Already rooted?!" ) ; NS_ASSERTION ( JSVAL_IS_VOID ( mResultVal ) , "Should be undefined!" ) ; if ( NS_FAILED ( CheckInnerWindowCorrectness ( ) ) ) { return ; } mHaveResultOrErrorCode = true ; if ( NS_FAILED ( aRv ) ) { SetError ( aRv ) ; } }
TPM2B_PRIVATE_KEY_RSA_Marshal ( TPM2B_PRIVATE_KEY_RSA * source , BYTE * * buffer , INT32 * size ) { UINT16 written = 0 ; written += TPM2B_Marshal ( & source -> b , buffer , size ) ; return written ; }
static void mt_decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; #if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ; #endif if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; #if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ; vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ; vpx_memset ( xd -> eobs , 0 , 25 ) ; } } #endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) vpx_memset ( xd -> eobs , 0 , 25 ) ; intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above ; unsigned char * yleft ; int left_stride ; unsigned char top_left ; if ( i < 4 && pbi -> common . filter_level ) Above = xd -> recon_above [ 0 ] + b -> offset ; else Above = dst - dst_stride ; if ( i % 4 == 0 && pbi -> common . filter_level ) { yleft = xd -> recon_left [ 0 ] + i ; left_stride = 1 ; } else { yleft = dst - 1 ; left_stride = dst_stride ; } if ( ( i == 4 || i == 8 || i == 12 ) && pbi -> common . filter_level ) top_left = * ( xd -> recon_left [ 0 ] + i - 1 ) ; else top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ; vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } #if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } #endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ; } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }
void sealHexSEK ( int * errStatus , char * errString , uint8_t * encrypted_sek , uint32_t * enc_len , char * sek_hex ) { CALL_ONCE LOG_INFO ( __FUNCTION__ ) ; INIT_ERROR_STATE CHECK_STATE ( encrypted_sek ) ; CHECK_STATE ( sek_hex ) ; CHECK_STATE ( strnlen ( sek_hex , 33 ) == 32 ) uint64_t plaintextLen = strlen ( sek_hex ) + 1 ; uint64_t sealedLen = sgx_calc_sealed_data_size ( 0 , plaintextLen ) ; sgx_attributes_t attribute_mask ; attribute_mask . flags = 0xfffffffffffffff3 ; attribute_mask . xfrm = 0x0 ; sgx_misc_select_t misc = 0xF0000000 ; sgx_status_t status = sgx_seal_data_ex ( SGX_KEYPOLICY_MRENCLAVE , attribute_mask , misc , 0 , NULL , plaintextLen , ( uint8_t * ) sek_hex , sealedLen , ( sgx_sealed_data_t * ) encrypted_sek ) ; CHECK_STATUS ( "seal SEK failed after SEK generation" ) ; uint32_t encrypt_text_length = sgx_get_encrypt_txt_len ( ( const sgx_sealed_data_t * ) encrypted_sek ) ; CHECK_STATE ( encrypt_text_length = plaintextLen ) ; SAFE_CHAR_BUF ( unsealedKey , BUF_LEN ) ; uint32_t decLen = BUF_LEN ; uint32_t add_text_length = sgx_get_add_mac_txt_len ( ( const sgx_sealed_data_t * ) encrypted_sek ) ; CHECK_STATE ( add_text_length == 0 ) ; CHECK_STATE ( sgx_is_within_enclave ( encrypted_sek , sizeof ( sgx_sealed_data_t ) ) ) ; status = sgx_unseal_data ( ( const sgx_sealed_data_t * ) encrypted_sek , NULL , NULL , ( uint8_t * ) unsealedKey , & decLen ) ; CHECK_STATUS ( "seal/unseal SEK failed after SEK generation in unseal" ) ; * enc_len = sealedLen ; SET_SUCCESS clean : LOG_INFO ( __FUNCTION__ ) ; LOG_INFO ( "SGX call completed" ) ; }
WebGLTexture :: IsComplete ( const char * funcName , uint32_t texUnit , const char * * const out_reason , bool * const out_initFailed ) { * out_initFailed = false ; if ( ! EnsureLevelInitialized ( funcName , mBaseMipmapLevel ) ) { * out_initFailed = true ; return false ; } const ImageInfo & baseImageInfo = BaseImageInfo ( ) ; if ( ! baseImageInfo . IsDefined ( ) ) { * out_reason = nullptr ; return false ; } if ( ! baseImageInfo . mWidth || ! baseImageInfo . mHeight || ! baseImageInfo . mDepth ) { * out_reason = "The dimensions of `level_base` are not all positive." ; return false ; } if ( IsCubeMap ( ) && ! IsCubeComplete ( ) ) { * out_reason = "Cubemaps must be \"cube complete\"." ; return false ; } WebGLSampler * sampler = mContext -> mBoundSamplers [ texUnit ] ; TexMinFilter minFilter = sampler ? sampler -> mMinFilter : mMinFilter ; TexMagFilter magFilter = sampler ? sampler -> mMagFilter : mMagFilter ; const bool requiresMipmap = ( minFilter != LOCAL_GL_NEAREST && minFilter != LOCAL_GL_LINEAR ) ; if ( requiresMipmap && ! IsMipmapComplete ( funcName , texUnit , out_initFailed ) ) { if ( * out_initFailed ) return false ; * out_reason = "Because the minification filter requires mipmapping, the texture" " must be \"mipmap complete\"." ; return false ; } const bool isMinFilteringNearest = ( minFilter == LOCAL_GL_NEAREST || minFilter == LOCAL_GL_NEAREST_MIPMAP_NEAREST ) ; const bool isMagFilteringNearest = ( magFilter == LOCAL_GL_NEAREST ) ; const bool isFilteringNearestOnly = ( isMinFilteringNearest && isMagFilteringNearest ) ; if ( ! isFilteringNearestOnly ) { auto formatUsage = baseImageInfo . mFormat ; auto format = formatUsage -> format ; bool isFilterable = formatUsage -> isFilterable ; if ( format -> d && mTexCompareMode != LOCAL_GL_NONE ) { isFilterable = true ; } if ( ! isFilterable ) { * out_reason = "Because minification or magnification filtering is not NEAREST" " or NEAREST_MIPMAP_NEAREST, and the texture's format must be" " \"texture-filterable\"." ; return false ; } } if ( ! mContext -> IsWebGL2 ( ) ) { if ( ! baseImageInfo . IsPowerOfTwo ( ) ) { TexWrap wrapS = sampler ? sampler -> mWrapS : mWrapS ; TexWrap wrapT = sampler ? sampler -> mWrapT : mWrapT ; if ( wrapS != LOCAL_GL_CLAMP_TO_EDGE || wrapT != LOCAL_GL_CLAMP_TO_EDGE ) { * out_reason = "Non-power-of-two textures must have a wrap mode of" " CLAMP_TO_EDGE." ; return false ; } if ( requiresMipmap ) { * out_reason = "Mipmapping requires power-of-two textures." ; return false ; } } } return true ; }
MacroAssemblerARMCompat :: store32 ( Register src , const BaseIndex & dest ) { Register base = dest . base ; uint32_t scale = Imm32 :: ShiftOf ( dest . scale ) . value ; ScratchRegisterScope scratch ( asMasm ( ) ) ; if ( dest . offset != 0 ) { ma_add ( base , Imm32 ( dest . offset ) , scratch ) ; base = scratch ; } ma_str ( src , DTRAddr ( base , DtrRegImmShift ( dest . index , LSL , scale ) ) ) ; }
nsJARChannel :: OnDownloadComplete ( MemoryDownloader * aDownloader , nsIRequest * request , nsISupports * context , nsresult status , MemoryDownloader :: Data aData ) { nsresult rv ; nsCOMPtr < nsIChannel > channel ( do_QueryInterface ( request ) ) ; if ( channel ) { uint32_t loadFlags ; channel -> GetLoadFlags ( & loadFlags ) ; if ( loadFlags & LOAD_REPLACE ) { mLoadFlags |= LOAD_REPLACE ; if ( ! mOriginalURI ) { SetOriginalURI ( mJarURI ) ; } nsCOMPtr < nsIURI > innerURI ; rv = channel -> GetURI ( getter_AddRefs ( innerURI ) ) ; if ( NS_SUCCEEDED ( rv ) ) { nsCOMPtr < nsIJARURI > newURI ; rv = mJarURI -> CloneWithJARFile ( innerURI , getter_AddRefs ( newURI ) ) ; if ( NS_SUCCEEDED ( rv ) ) { mJarURI = newURI ; } } if ( NS_SUCCEEDED ( status ) ) { status = rv ; } } } if ( NS_SUCCEEDED ( status ) && channel ) { channel -> GetSecurityInfo ( getter_AddRefs ( mSecurityInfo ) ) ; nsCOMPtr < nsIHttpChannel > httpChannel ( do_QueryInterface ( channel ) ) ; if ( httpChannel ) { nsAutoCString header ; httpChannel -> GetResponseHeader ( NS_LITERAL_CSTRING ( "Content-Type" ) , header ) ; nsAutoCString contentType ; nsAutoCString charset ; NS_ParseContentType ( header , contentType , charset ) ; nsAutoCString channelContentType ; channel -> GetContentType ( channelContentType ) ; mIsUnsafe = ! ( contentType . Equals ( channelContentType ) && ( contentType . EqualsLiteral ( "application/java-archive" ) || contentType . EqualsLiteral ( "application/x-jar" ) ) ) ; } else { nsCOMPtr < nsIJARChannel > innerJARChannel ( do_QueryInterface ( channel ) ) ; if ( innerJARChannel ) { bool unsafe ; innerJARChannel -> GetIsUnsafe ( & unsafe ) ; mIsUnsafe = unsafe ; } } channel -> GetContentDispositionHeader ( mContentDispositionHeader ) ; mContentDisposition = NS_GetContentDispositionFromHeader ( mContentDispositionHeader , this ) ; } MOZ_RELEASE_ASSERT ( ! mBlockRemoteFiles ) ; if ( NS_SUCCEEDED ( status ) && mIsUnsafe && ! Preferences :: GetBool ( "network.jar.open-unsafe-types" , false ) ) { status = NS_ERROR_UNSAFE_CONTENT_TYPE ; } if ( NS_SUCCEEDED ( status ) ) { nsCOMPtr < nsIViewSourceChannel > viewSource = do_QueryInterface ( channel ) ; if ( viewSource ) { status = NS_ERROR_UNSAFE_CONTENT_TYPE ; } } if ( NS_SUCCEEDED ( status ) ) { mTempMem = Move ( aData ) ; nsRefPtr < nsJARInputThunk > input ; rv = CreateJarInput ( nullptr , getter_AddRefs ( input ) ) ; if ( NS_SUCCEEDED ( rv ) ) { rv = NS_NewInputStreamPump ( getter_AddRefs ( mPump ) , input ) ; if ( NS_SUCCEEDED ( rv ) ) rv = mPump -> AsyncRead ( this , nullptr ) ; } status = rv ; } if ( NS_FAILED ( status ) ) { NotifyError ( status ) ; } }
int Archive :: Read ( void * Data , size_t Size ) { size_t Result ; if ( QOpen . Read ( Data , Size , Result ) ) return ( int ) Result ; return File :: Read ( Data , Size ) ; }
bool Module :: FinishInstantiate ( Isolate * isolate , Handle < Module > module , ZoneForwardList < Handle < Module > > * stack , unsigned * dfs_index , Zone * zone ) { DCHECK_NE ( module -> status ( ) , kEvaluating ) ; if ( module -> status ( ) >= kInstantiating ) return true ; DCHECK_EQ ( module -> status ( ) , kPreInstantiating ) ; STACK_CHECK ( isolate , false ) ; Handle < SharedFunctionInfo > shared ( SharedFunctionInfo :: cast ( module -> code ( ) ) , isolate ) ; Handle < JSFunction > function = isolate -> factory ( ) -> NewFunctionFromSharedFunctionInfo ( shared , isolate -> native_context ( ) ) ; module -> set_code ( * function ) ; module -> SetStatus ( kInstantiating ) ; module -> set_dfs_index ( * dfs_index ) ; module -> set_dfs_ancestor_index ( * dfs_index ) ; stack -> push_front ( module ) ; ( * dfs_index ) ++ ; Handle < FixedArray > requested_modules ( module -> requested_modules ( ) , isolate ) ; for ( int i = 0 , length = requested_modules -> length ( ) ; i < length ; ++ i ) { Handle < Module > requested_module ( Module :: cast ( requested_modules -> get ( i ) ) , isolate ) ; if ( ! FinishInstantiate ( isolate , requested_module , stack , dfs_index , zone ) ) { return false ; } DCHECK_NE ( requested_module -> status ( ) , kEvaluating ) ; DCHECK_GE ( requested_module -> status ( ) , kInstantiating ) ; SLOW_DCHECK ( ( requested_module -> status ( ) == kInstantiating ) == std :: count_if ( stack -> begin ( ) , stack -> end ( ) , [ & ] ( Handle < Module > m ) { return * m == * requested_module ; } ) ) ; if ( requested_module -> status ( ) == kInstantiating ) { module -> set_dfs_ancestor_index ( std :: min ( module -> dfs_ancestor_index ( ) , requested_module -> dfs_ancestor_index ( ) ) ) ; } } Handle < Script > script ( module -> script ( ) , isolate ) ; Handle < ModuleInfo > module_info ( module -> info ( ) , isolate ) ; Handle < FixedArray > regular_imports ( module_info -> regular_imports ( ) , isolate ) ; for ( int i = 0 , n = regular_imports -> length ( ) ; i < n ; ++ i ) { Handle < ModuleInfoEntry > entry ( ModuleInfoEntry :: cast ( regular_imports -> get ( i ) ) , isolate ) ; Handle < String > name ( String :: cast ( entry -> import_name ( ) ) , isolate ) ; MessageLocation loc ( script , entry -> beg_pos ( ) , entry -> end_pos ( ) ) ; ResolveSet resolve_set ( zone ) ; Handle < Cell > cell ; if ( ! ResolveImport ( isolate , module , name , entry -> module_request ( ) , loc , true , & resolve_set ) . ToHandle ( & cell ) ) { return false ; } module -> regular_imports ( ) -> set ( ImportIndex ( entry -> cell_index ( ) ) , * cell ) ; } Handle < FixedArray > special_exports ( module_info -> special_exports ( ) , isolate ) ; for ( int i = 0 , n = special_exports -> length ( ) ; i < n ; ++ i ) { Handle < ModuleInfoEntry > entry ( ModuleInfoEntry :: cast ( special_exports -> get ( i ) ) , isolate ) ; Handle < Object > name ( entry -> export_name ( ) , isolate ) ; if ( name -> IsUndefined ( isolate ) ) continue ; MessageLocation loc ( script , entry -> beg_pos ( ) , entry -> end_pos ( ) ) ; ResolveSet resolve_set ( zone ) ; if ( ResolveExport ( isolate , module , Handle < String > ( ) , Handle < String > :: cast ( name ) , loc , true , & resolve_set ) . is_null ( ) ) { return false ; } } return MaybeTransitionComponent ( isolate , module , stack , kInstantiated ) ; }
void FDK_InitBitBuffer ( HANDLE_FDK_BITBUF hBitBuf , UCHAR * pBuffer , UINT bufSize , UINT validBits ) { hBitBuf -> ValidBits = validBits ; hBitBuf -> ReadOffset = 0 ; hBitBuf -> WriteOffset = 0 ; hBitBuf -> BitCnt = 0 ; hBitBuf -> BitNdx = 0 ; hBitBuf -> Buffer = pBuffer ; hBitBuf -> bufSize = bufSize ; hBitBuf -> bufBits = ( bufSize < < 3 ) ; FDK_ASSERT ( hBitBuf -> ValidBits <= hBitBuf -> bufBits ) ; FDK_ASSERT ( ( bufSize > 0 ) && ( bufSize <= MAX_BUFSIZE_BYTES ) ) ; { UINT x = 0 , n = bufSize ; for ( x = 0 ; n > 0 ; x ++ , n >>= 1 ) { } if ( bufSize != ( ( UINT ) 1 < < ( x - 1 ) ) ) { FDK_ASSERT ( 0 ) ; } } }
static long snd_timer_user_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct snd_timer_user * tu ; void __user * argp = ( void __user * ) arg ; int __user * p = argp ; tu = file -> private_data ; switch ( cmd ) { case SNDRV_TIMER_IOCTL_PVERSION : return put_user ( SNDRV_TIMER_VERSION , p ) ? - EFAULT : 0 ; case SNDRV_TIMER_IOCTL_NEXT_DEVICE : return snd_timer_user_next_device ( argp ) ; case SNDRV_TIMER_IOCTL_TREAD : { int xarg ; mutex_lock ( & tu -> tread_sem ) ; if ( tu -> timeri ) { mutex_unlock ( & tu -> tread_sem ) ; return - EBUSY ; } if ( get_user ( xarg , p ) ) { mutex_unlock ( & tu -> tread_sem ) ; return - EFAULT ; } tu -> tread = xarg ? 1 : 0 ; mutex_unlock ( & tu -> tread_sem ) ; return 0 ; } case SNDRV_TIMER_IOCTL_GINFO : return snd_timer_user_ginfo ( file , argp ) ; case SNDRV_TIMER_IOCTL_GPARAMS : return snd_timer_user_gparams ( file , argp ) ; case SNDRV_TIMER_IOCTL_GSTATUS : return snd_timer_user_gstatus ( file , argp ) ; case SNDRV_TIMER_IOCTL_SELECT : return snd_timer_user_tselect ( file , argp ) ; case SNDRV_TIMER_IOCTL_INFO : return snd_timer_user_info ( file , argp ) ; case SNDRV_TIMER_IOCTL_PARAMS : return snd_timer_user_params ( file , argp ) ; case SNDRV_TIMER_IOCTL_STATUS : return snd_timer_user_status ( file , argp ) ; case SNDRV_TIMER_IOCTL_START : case SNDRV_TIMER_IOCTL_START_OLD : return snd_timer_user_start ( file ) ; case SNDRV_TIMER_IOCTL_STOP : case SNDRV_TIMER_IOCTL_STOP_OLD : return snd_timer_user_stop ( file ) ; case SNDRV_TIMER_IOCTL_CONTINUE : case SNDRV_TIMER_IOCTL_CONTINUE_OLD : return snd_timer_user_continue ( file ) ; case SNDRV_TIMER_IOCTL_PAUSE : case SNDRV_TIMER_IOCTL_PAUSE_OLD : return snd_timer_user_pause ( file ) ; } return - ENOTTY ; }
int vp9_twopass_worst_quality ( VP9_COMP * cpi , FIRSTPASS_STATS * fpstats , int section_target_bandwitdh ) { int q ; const int num_mbs = cpi -> common . MBs ; int target_norm_bits_per_mb ; const RATE_CONTROL * const rc = & cpi -> rc ; const double section_err = fpstats -> coded_error / fpstats -> count ; const double err_per_mb = section_err / num_mbs ; const double speed_term = 1.0 + ( ( double ) cpi -> speed * 0.04 ) ; if ( section_target_bandwitdh <= 0 ) return rc -> worst_quality ; target_norm_bits_per_mb = ( ( uint64_t ) section_target_bandwitdh < < BPER_MB_NORMBITS ) / num_mbs ; for ( q = rc -> best_quality ; q < rc -> worst_quality ; ++ q ) { const double err_correction_factor = calc_correction_factor ( err_per_mb , ERR_DIVISOR , 0.5 , 0.90 , q ) ; const int bits_per_mb_at_this_q = vp9_rc_bits_per_mb ( INTER_FRAME , q , ( err_correction_factor * speed_term ) ) ; if ( bits_per_mb_at_this_q <= target_norm_bits_per_mb ) break ; } if ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) q = MAX ( q , cpi -> cq_target_quality ) ; return q ; }
Type Typer :: Visitor :: Decrement ( Type type , Typer * t ) { type = ToNumeric ( type , t ) ; if ( type . Is ( Type :: Number ( ) ) ) { return NumberSubtract ( type , t -> cache_ . kSingletonOne , t ) ; } return Type :: Numeric ( ) ; }
static tAVRC_STS avrc_ctrl_pars_vendor_cmd ( tAVRC_MSG_VENDOR * p_msg , tAVRC_COMMAND * p_result ) { tAVRC_STS status = AVRC_STS_NO_ERROR ; uint8_t * p = p_msg -> p_vendor_data ; p_result -> pdu = * p ++ ; AVRC_TRACE_DEBUG ( "%s pdu:0x%x" , __func__ , p_result -> pdu ) ; if ( ! AVRC_IsValidAvcType ( p_result -> pdu , p_msg -> hdr . ctype ) ) { AVRC_TRACE_DEBUG ( "%s detects wrong AV/C type!" , __func__ ) ; status = AVRC_STS_BAD_CMD ; } p ++ ; uint16_t len ; BE_STREAM_TO_UINT16 ( len , p ) ; if ( ( len + 4 ) != ( p_msg -> vendor_len ) ) { status = AVRC_STS_INTERNAL_ERR ; } if ( status != AVRC_STS_NO_ERROR ) return status ; switch ( p_result -> pdu ) { case AVRC_PDU_SET_ABSOLUTE_VOLUME : { if ( len != 1 ) status = AVRC_STS_INTERNAL_ERR ; else { BE_STREAM_TO_UINT8 ( p_result -> volume . volume , p ) ; p_result -> volume . volume = AVRC_MAX_VOLUME & p_result -> volume . volume ; } break ; } case AVRC_PDU_REGISTER_NOTIFICATION : if ( len < 5 ) return AVRC_STS_INTERNAL_ERR ; BE_STREAM_TO_UINT8 ( p_result -> reg_notif . event_id , p ) ; BE_STREAM_TO_UINT32 ( p_result -> reg_notif . param , p ) ; break ; default : status = AVRC_STS_BAD_CMD ; break ; } return status ; }
SourcePositionTable * TurbofanWasmCompilationUnit :: BuildGraphForWasmFunction ( wasm :: WasmFeatures * detected , double * decode_ms , MachineGraph * mcgraph , NodeOriginTable * node_origins ) { base :: ElapsedTimer decode_timer ; if ( FLAG_trace_wasm_decode_time ) { decode_timer . Start ( ) ; } SourcePositionTable * source_position_table = new ( mcgraph -> zone ( ) ) SourcePositionTable ( mcgraph -> graph ( ) ) ; WasmGraphBuilder builder ( wasm_unit_ -> env_ , mcgraph -> zone ( ) , mcgraph , wasm_unit_ -> func_body_ . sig , source_position_table ) ; graph_construction_result_ = wasm :: BuildTFGraph ( wasm_unit_ -> wasm_engine_ -> allocator ( ) , wasm_unit_ -> native_module_ -> enabled_features ( ) , wasm_unit_ -> env_ -> module , & builder , detected , wasm_unit_ -> func_body_ , node_origins ) ; if ( graph_construction_result_ . failed ( ) ) { if ( FLAG_trace_wasm_compiler ) { StdoutStream { } < < "Compilation failed: " < < graph_construction_result_ . error_msg ( ) < < std :: endl ; } return nullptr ; } builder . LowerInt64 ( ) ; if ( builder . has_simd ( ) && ( ! CpuFeatures :: SupportsWasmSimd128 ( ) || wasm_unit_ -> env_ -> lower_simd ) ) { SimdScalarLowering ( mcgraph , CreateMachineSignature ( mcgraph -> zone ( ) , wasm_unit_ -> func_body_ . sig ) ) . LowerGraph ( ) ; } if ( wasm_unit_ -> func_index_ >= FLAG_trace_wasm_ast_start && wasm_unit_ -> func_index_ < FLAG_trace_wasm_ast_end ) { PrintRawWasmCode ( wasm_unit_ -> wasm_engine_ -> allocator ( ) , wasm_unit_ -> func_body_ , wasm_unit_ -> env_ -> module , wasm :: kPrintLocals ) ; } if ( FLAG_trace_wasm_decode_time ) { * decode_ms = decode_timer . Elapsed ( ) . InMillisecondsF ( ) ; } return source_position_table ; }
bool Chapters :: Edition :: ExpandAtomsArray ( ) { if ( m_atoms_size > m_atoms_count ) return true ; const int size = ( m_atoms_size == 0 ) ? 1 : 2 * m_atoms_size ; Atom * const atoms = new ( std :: nothrow ) Atom [ size ] ; if ( atoms == NULL ) return false ; for ( int idx = 0 ; idx < m_atoms_count ; ++ idx ) { m_atoms [ idx ] . ShallowCopy ( atoms [ idx ] ) ; } delete [ ] m_atoms ; m_atoms = atoms ; m_atoms_size = size ; return true ; }
int main ( int argc , char * * argv ) { test_cmp_parameters inParam ; FILE * fbase = NULL , * ftest = NULL ; int same = 0 ; char lbase [ 256 ] ; char strbase [ 256 ] ; char ltest [ 256 ] ; char strtest [ 256 ] ; if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) { compare_dump_files_help_display ( ) ; goto cleanup ; } printf ( "******Parameters********* \n" ) ; printf ( " base_filename = %s\n" " test_filename = %s\n" , inParam . base_filename , inParam . test_filename ) ; printf ( "************************* \n" ) ; printf ( "Try to open: %s for reading ... " , inParam . base_filename ) ; if ( ( fbase = fopen ( inParam . base_filename , "rb" ) ) == NULL ) { goto cleanup ; } printf ( "Ok.\n" ) ; printf ( "Try to open: %s for reading ... " , inParam . test_filename ) ; if ( ( ftest = fopen ( inParam . test_filename , "rb" ) ) == NULL ) { goto cleanup ; } printf ( "Ok.\n" ) ; while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) { int nbase = sscanf ( lbase , "%255[^\r\n]" , strbase ) ; int ntest = sscanf ( ltest , "%255[^\r\n]" , strtest ) ; assert ( nbase != 255 && ntest != 255 ) ; if ( nbase != 1 || ntest != 1 ) { fprintf ( stderr , "could not parse line from files\n" ) ; goto cleanup ; } if ( strcmp ( strbase , strtest ) != 0 ) { fprintf ( stderr , "<%s> vs. <%s>\n" , strbase , strtest ) ; goto cleanup ; } } same = 1 ; printf ( "\n***** TEST SUCCEED: Files are the same. *****\n" ) ; cleanup : if ( fbase ) fclose ( fbase ) ; if ( ftest ) fclose ( ftest ) ; free ( inParam . base_filename ) ; free ( inParam . test_filename ) ; return same ? EXIT_SUCCESS : EXIT_FAILURE ; }
NS_IMETHODIMP nsUTF8ToUnicode :: GetMaxLength ( const char * aSrc , int32_t aSrcLength , int32_t * aDestLength ) { * aDestLength = aSrcLength + 1 ; return NS_OK ; }
void operator ( ) ( OpKernelContext * context , const Tensor & x_input , const Tensor & scale_input , const Tensor & offset_input , const Tensor & estimated_mean_input , const Tensor & estimated_variance_input , const Tensor * side_input , U epsilon , U exponential_avg_factor , FusedBatchNormActivationMode activation_mode , Tensor * y_output , Tensor * batch_mean_output , Tensor * batch_var_output , Tensor * saved_mean_output , Tensor * saved_var_output , TensorFormat tensor_format , bool use_reserved_space ) { OP_REQUIRES ( context , side_input == nullptr , errors :: Internal ( "The CPU implementation of FusedBatchNorm does not support " "side input." ) ) ; OP_REQUIRES ( context , activation_mode == FusedBatchNormActivationMode :: kIdentity , errors :: Internal ( "The CPU implementation of FusedBatchNorm " "does not support activations." ) ) ; if ( use_reserved_space ) { Tensor * dummy_reserve_space = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 5 , { } , & dummy_reserve_space ) ) ; dummy_reserve_space -> flat < U > ( ) ( 0 ) = U ( ) ; } Tensor transformed_x ; Tensor transformed_y ; if ( tensor_format == FORMAT_NCHW ) { const int64 in_batch = GetTensorDim ( x_input , tensor_format , 'N' ) ; const int64 in_rows = GetTensorDim ( x_input , tensor_format , 'H' ) ; const int64 in_cols = GetTensorDim ( x_input , tensor_format , 'W' ) ; const int64 in_depths = GetTensorDim ( x_input , tensor_format , 'C' ) ; OP_REQUIRES_OK ( context , context -> allocate_temp ( DataTypeToEnum < T > :: value , ShapeFromFormat ( FORMAT_NHWC , in_batch , in_rows , in_cols , in_depths ) , & transformed_x ) ) ; OP_REQUIRES_OK ( context , context -> allocate_temp ( DataTypeToEnum < T > :: value , ShapeFromFormat ( FORMAT_NHWC , in_batch , in_rows , in_cols , in_depths ) , & transformed_y ) ) ; std :: vector < int32 > perm = { 0 , 2 , 3 , 1 } ; OP_REQUIRES_OK ( context , :: tensorflow :: DoTranspose ( context -> eigen_device < CPUDevice > ( ) , x_input , perm , & transformed_x ) ) ; } else { transformed_x = x_input ; transformed_y = * y_output ; } typename TTypes < T , 4 > :: Tensor x ( transformed_x . tensor < T , 4 > ( ) ) ; typename TTypes < U > :: ConstVec scale ( scale_input . vec < U > ( ) ) ; typename TTypes < U > :: ConstVec offset ( offset_input . vec < U > ( ) ) ; typename TTypes < U > :: ConstVec estimated_mean ( estimated_mean_input . vec < U > ( ) ) ; typename TTypes < U > :: ConstVec estimated_variance ( estimated_variance_input . vec < U > ( ) ) ; typename TTypes < T , 4 > :: Tensor y ( transformed_y . tensor < T , 4 > ( ) ) ; typename TTypes < U > :: Vec batch_mean ( batch_mean_output -> vec < U > ( ) ) ; typename TTypes < U > :: Vec batch_variance ( batch_var_output -> vec < U > ( ) ) ; const CPUDevice & d = context -> eigen_device < CPUDevice > ( ) ; const int depth = x . dimension ( 3 ) ; const int size = x . size ( ) ; const int rest_size = size / depth ; Eigen :: DSizes < Eigen :: Index , 2 > rest_by_depth ( rest_size , depth ) ; #if !defined(EIGEN_HAS_INDEX_LIST) Eigen :: DSizes < Eigen :: Index , 2 > one_by_depth ( 1 , depth ) ; Eigen :: array < int , 1 > reduce_dims ( { 0 } ) ; Eigen :: array < int , 2 > bcast_spec ( { rest_size , 1 } ) ; #else Eigen :: IndexList < Eigen :: type2index < 1 > , Eigen :: Index > one_by_depth ; one_by_depth . set ( 1 , depth ) ; Eigen :: IndexList < Eigen :: Index , Eigen :: type2index < 1 > > bcast_spec ; bcast_spec . set ( 0 , rest_size ) ; #endif auto x_rest_by_depth = x . reshape ( rest_by_depth ) . template cast < U > ( ) ; auto x_centered = x_rest_by_depth - estimated_mean . reshape ( one_by_depth ) . broadcast ( bcast_spec ) ; auto scaling_factor = ( ( estimated_variance + epsilon ) . rsqrt ( ) * scale ) . eval ( ) . reshape ( one_by_depth ) . broadcast ( bcast_spec ) ; auto x_scaled = x_centered * scaling_factor ; auto x_shifted = ( x_scaled + offset . reshape ( one_by_depth ) . broadcast ( bcast_spec ) ) . template cast < T > ( ) ; y . reshape ( rest_by_depth ) . device ( d ) = x_shifted ; batch_mean . device ( d ) = estimated_mean ; batch_variance . device ( d ) = estimated_variance ; if ( tensor_format == FORMAT_NCHW ) { const std :: vector < int32 > perm = { 0 , 3 , 1 , 2 } ; const Status s = :: tensorflow :: DoTranspose ( context -> eigen_device < CPUDevice > ( ) , transformed_y , perm , y_output ) ; if ( ! s . ok ( ) ) { context -> SetStatus ( errors :: InvalidArgument ( "Transpose failed: " , s ) ) ; } } }
void ObjectStatsCollectorImpl :: RecordVirtualArrayBoilerplateDescription ( ArrayBoilerplateDescription * description ) { RecordVirtualObjectsForConstantPoolOrEmbeddedObjects ( description , description -> constant_elements ( ) , ObjectStats :: ARRAY_BOILERPLATE_DESCRIPTION_ELEMENTS_TYPE ) ; }
Node * WasmGraphBuilder :: SetGlobal ( uint32_t index , Node * val ) { MachineType mem_type = wasm :: ValueTypes :: MachineTypeFor ( env_ -> module -> globals [ index ] . type ) ; Node * base = nullptr ; Node * offset = nullptr ; GetGlobalBaseAndOffset ( mem_type , env_ -> module -> globals [ index ] , & base , & offset ) ; const Operator * op = mcgraph ( ) -> machine ( ) -> Store ( StoreRepresentation ( mem_type . representation ( ) , kNoWriteBarrier ) ) ; #if defined(V8_TARGET_BIG_ENDIAN) val = BuildChangeEndiannessStore ( val , mem_type . representation ( ) , env_ -> module -> globals [ index ] . type ) ; #endif return SetEffect ( graph ( ) -> NewNode ( op , base , offset , val , Effect ( ) , Control ( ) ) ) ; }
static uint8_t avdt_msg_prs_cfg ( tAVDT_CFG * p_cfg , uint8_t * p , uint16_t len , uint8_t * p_elem , uint8_t sig_id ) { uint8_t * p_end ; uint8_t elem = 0 ; uint8_t elem_len ; uint8_t tmp ; uint8_t err = 0 ; uint8_t protect_offset = 0 ; if ( ! p_cfg ) { AVDT_TRACE_ERROR ( "not expecting this cfg" ) ; return AVDT_ERR_BAD_STATE ; } p_cfg -> psc_mask = 0 ; p_cfg -> num_codec = 0 ; p_cfg -> num_protect = 0 ; p_end = p + len ; while ( ( p < p_end ) && ( err == 0 ) ) { if ( ( p_end - p ) < AVDT_LEN_CFG_MIN ) { err = AVDT_ERR_PAYLOAD ; break ; } elem = * p ++ ; elem_len = * p ++ ; if ( ( elem == 0 ) || ( elem > AVDT_CAT_MAX_CUR ) ) { if ( ( sig_id == AVDT_SIG_SETCONFIG ) || ( sig_id == AVDT_SIG_RECONFIG ) ) { err = AVDT_ERR_CATEGORY ; break ; } else { p += elem_len ; AVDT_TRACE_DEBUG ( "skipping unknown service category=%d len: %d" , elem , elem_len ) ; continue ; } } if ( ( elem_len > avdt_msg_ie_len_max [ elem ] ) || ( elem_len < avdt_msg_ie_len_min [ elem ] ) ) { err = avdt_msg_ie_err [ elem ] ; break ; } p_cfg -> psc_mask |= ( 1 < < elem ) ; AVDT_TRACE_DEBUG ( "elem=%d elem_len: %d psc_mask=0x%x" , elem , elem_len , p_cfg -> psc_mask ) ; switch ( elem ) { case AVDT_CAT_RECOV : p_cfg -> recov_type = * p ++ ; p_cfg -> recov_mrws = * p ++ ; p_cfg -> recov_mnmp = * p ++ ; if ( p_cfg -> recov_type != AVDT_RECOV_RFC2733 ) { err = AVDT_ERR_RECOV_TYPE ; } else if ( ( p_cfg -> recov_mrws < AVDT_RECOV_MRWS_MIN ) || ( p_cfg -> recov_mrws > AVDT_RECOV_MRWS_MAX ) || ( p_cfg -> recov_mnmp < AVDT_RECOV_MNMP_MIN ) || ( p_cfg -> recov_mnmp > AVDT_RECOV_MNMP_MAX ) ) { err = AVDT_ERR_RECOV_FMT ; } break ; case AVDT_CAT_PROTECT : p_cfg -> psc_mask &= ~ AVDT_PSC_PROTECT ; if ( ( elem_len + protect_offset ) < AVDT_PROTECT_SIZE ) { p_cfg -> num_protect ++ ; p_cfg -> protect_info [ protect_offset ] = elem_len ; protect_offset ++ ; memcpy ( & p_cfg -> protect_info [ protect_offset ] , p , elem_len ) ; protect_offset += elem_len ; } p += elem_len ; break ; case AVDT_CAT_HDRCMP : p_cfg -> hdrcmp_mask = * p ++ ; break ; case AVDT_CAT_CODEC : p_cfg -> psc_mask &= ~ AVDT_PSC_CODEC ; tmp = elem_len ; if ( elem_len >= AVDT_CODEC_SIZE ) { tmp = AVDT_CODEC_SIZE - 1 ; } p_cfg -> num_codec ++ ; p_cfg -> codec_info [ 0 ] = elem_len ; memcpy ( & p_cfg -> codec_info [ 1 ] , p , tmp ) ; p += elem_len ; break ; case AVDT_CAT_DELAY_RPT : break ; default : p += elem_len ; break ; } } * p_elem = elem ; AVDT_TRACE_DEBUG ( "err=0x%x, elem:0x%x psc_mask=0x%x" , err , elem , p_cfg -> psc_mask ) ; return err ; }
static int save_context ( Context * context , const struct iovec_wrapper * iovw ) { const char * unit ; int r ; assert ( context ) ; assert ( iovw ) ; assert ( iovw -> count >= _META_ARGV_MAX ) ; for ( size_t n = 0 ; n < iovw -> count ; n ++ ) { struct iovec * iovec = iovw -> iovec + n ; for ( size_t i = 0 ; i < ELEMENTSOF ( meta_field_names ) ; i ++ ) { char * p ; assert ( ( ( char * ) iovec -> iov_base ) [ iovec -> iov_len ] == 0 ) ; p = startswith ( iovec -> iov_base , meta_field_names [ i ] ) ; if ( p ) { context -> meta [ i ] = p ; break ; } } } if ( ! context -> meta [ META_ARGV_PID ] ) return log_error_errno ( SYNTHETIC_ERRNO ( EINVAL ) , "Failed to find the PID of crashing process" ) ; r = parse_pid ( context -> meta [ META_ARGV_PID ] , & context -> pid ) ; if ( r < 0 ) return log_error_errno ( r , "Failed to parse PID \"%s\": %m" , context -> meta [ META_ARGV_PID ] ) ; unit = context -> meta [ META_UNIT ] ; context -> is_pid1 = streq ( context -> meta [ META_ARGV_PID ] , "1" ) || streq_ptr ( unit , SPECIAL_INIT_SCOPE ) ; context -> is_journald = streq_ptr ( unit , SPECIAL_JOURNALD_SERVICE ) ; return 0 ; }
bool FramingChecker :: CheckOneFrameOptionsPolicy ( nsIHttpChannel * aHttpChannel , const nsAString & aPolicy ) { nsCOMPtr < nsIURI > uri ; aHttpChannel -> GetURI ( getter_AddRefs ( uri ) ) ; if ( ! aPolicy . LowerCaseEqualsLiteral ( "deny" ) && ! aPolicy . LowerCaseEqualsLiteral ( "sameorigin" ) ) { ReportError ( "XFrameOptionsInvalid" , aHttpChannel , uri , aPolicy ) ; return true ; } bool checkSameOrigin = aPolicy . LowerCaseEqualsLiteral ( "sameorigin" ) ; nsCOMPtr < nsILoadInfo > loadInfo = aHttpChannel -> LoadInfo ( ) ; RefPtr < mozilla :: dom :: BrowsingContext > ctx ; loadInfo -> GetBrowsingContext ( getter_AddRefs ( ctx ) ) ; while ( ctx ) { nsCOMPtr < nsIPrincipal > principal ; WindowGlobalParent * window = ctx -> Canonical ( ) -> GetCurrentWindowGlobal ( ) ; if ( window ) { principal = window -> DocumentPrincipal ( ) ; } if ( principal && principal -> IsSystemPrincipal ( ) ) { return true ; } if ( checkSameOrigin ) { bool isPrivateWin = false ; bool isSameOrigin = false ; if ( principal ) { isPrivateWin = principal -> OriginAttributesRef ( ) . mPrivateBrowsingId > 0 ; principal -> IsSameOrigin ( uri , isPrivateWin , & isSameOrigin ) ; } if ( ! isSameOrigin ) { ReportError ( "XFrameOptionsDeny" , aHttpChannel , uri , aPolicy ) ; return false ; } } ctx = ctx -> GetParent ( ) ; } if ( aPolicy . LowerCaseEqualsLiteral ( "deny" ) ) { ReportError ( "XFrameOptionsDeny" , aHttpChannel , uri , aPolicy ) ; return false ; } return true ; }
int blk_rq_map_user_iov ( struct request_queue * q , struct request * rq , struct rq_map_data * map_data , const struct iov_iter * iter , gfp_t gfp_mask ) { bool copy = false ; unsigned long align = q -> dma_pad_mask | queue_dma_alignment ( q ) ; struct bio * bio = NULL ; struct iov_iter i ; int ret ; if ( map_data ) copy = true ; else if ( iov_iter_alignment ( iter ) & align ) copy = true ; else if ( queue_virt_boundary ( q ) ) copy = queue_virt_boundary ( q ) & iov_iter_gap_alignment ( iter ) ; i = * iter ; do { ret = __blk_rq_map_user_iov ( rq , map_data , & i , gfp_mask , copy ) ; if ( ret ) goto unmap_rq ; if ( ! bio ) bio = rq -> bio ; } while ( iov_iter_count ( & i ) ) ; if ( ! bio_flagged ( bio , BIO_USER_MAPPED ) ) rq -> cmd_flags |= REQ_COPY_USER ; return 0 ; unmap_rq : __blk_rq_unmap_user ( bio ) ; rq -> bio = NULL ; return - EINVAL ; }
static int load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg ) { u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; return __load_segment_descriptor ( ctxt , selector , seg , cpl , X86_TRANSFER_NONE , NULL ) ; }
void Version ( const v8 :: FunctionCallbackInfo < v8 :: Value > & args ) { args . GetReturnValue ( ) . Set ( v8 :: String :: NewFromUtf8 ( args . GetIsolate ( ) , v8 :: V8 :: GetVersion ( ) , v8 :: NewStringType :: kNormal ) . ToLocalChecked ( ) ) ; }
std :: unique_ptr < protocol :: Array < int > > buildInspectorObjectForSamples ( v8 :: CpuProfile * v8profile ) { auto array = protocol :: Array < int > :: create ( ) ; int count = v8profile -> GetSamplesCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) array -> addItem ( v8profile -> GetSample ( i ) -> GetNodeId ( ) ) ; return array ; }
CollectionsBuiltinsAssembler :: Transition ( TNode < TableType > const table , TNode < IntPtrT > const index , UpdateInTransition const & update_in_transition ) { TVARIABLE ( IntPtrT , var_index , index ) ; TVARIABLE ( TableType , var_table , table ) ; Label if_done ( this ) , if_transition ( this , Label :: kDeferred ) ; Branch ( TaggedIsSmi ( LoadObjectField ( var_table . value ( ) , TableType :: kNextTableOffset ) ) , & if_done , & if_transition ) ; BIND ( & if_transition ) ; { Label loop ( this , { & var_table , & var_index } ) , done_loop ( this ) ; Goto ( & loop ) ; BIND ( & loop ) ; { TNode < TableType > table = var_table . value ( ) ; TNode < IntPtrT > index = var_index . value ( ) ; TNode < Object > next_table = LoadObjectField ( table , TableType :: kNextTableOffset ) ; GotoIf ( TaggedIsSmi ( next_table ) , & done_loop ) ; var_table = CAST ( next_table ) ; var_index = SmiUntag ( CAST ( CallBuiltin ( Builtins :: kOrderedHashTableHealIndex , NoContextConstant ( ) , table , SmiTag ( index ) ) ) ) ; Goto ( & loop ) ; } BIND ( & done_loop ) ; update_in_transition ( var_table . value ( ) , var_index . value ( ) ) ; Goto ( & if_done ) ; } BIND ( & if_done ) ; return { var_table . value ( ) , var_index . value ( ) } ; }
static int mount_entry_on_absolute_rootfs ( struct mntent * mntent , const struct lxc_rootfs * rootfs , const char * lxc_name ) { char * aux ; char path [ MAXPATHLEN ] ; int r , ret = 0 , offset ; const char * lxcpath ; lxcpath = lxc_global_config_value ( "lxc.lxcpath" ) ; if ( ! lxcpath ) { ERROR ( "Out of memory" ) ; return - 1 ; } r = snprintf ( path , MAXPATHLEN , "%s/%s/rootfs" , lxcpath , lxc_name ) ; if ( r < 0 || r >= MAXPATHLEN ) goto skipvarlib ; aux = strstr ( mntent -> mnt_dir , path ) ; if ( aux ) { offset = strlen ( path ) ; goto skipabs ; } skipvarlib : aux = strstr ( mntent -> mnt_dir , rootfs -> path ) ; if ( ! aux ) { WARN ( "ignoring mount point '%s'" , mntent -> mnt_dir ) ; return ret ; } offset = strlen ( rootfs -> path ) ; skipabs : r = snprintf ( path , MAXPATHLEN , "%s/%s" , rootfs -> mount , aux + offset ) ; if ( r < 0 || r >= MAXPATHLEN ) { WARN ( "pathnme too long for '%s'" , mntent -> mnt_dir ) ; return - 1 ; } return mount_entry_on_generic ( mntent , path ) ; }
TEST ( VP9Idct8x8Test , AccuracyCheck ) { ACMRandom rnd ( ACMRandom :: DeterministicSeed ( ) ) ; const int count_test_block = 10000 ; for ( int i = 0 ; i < count_test_block ; ++ i ) { int16_t input [ 64 ] , coeff [ 64 ] ; double output_r [ 64 ] ; uint8_t dst [ 64 ] , src [ 64 ] ; for ( int j = 0 ; j < 64 ; ++ j ) { src [ j ] = rnd . Rand8 ( ) ; dst [ j ] = rnd . Rand8 ( ) ; } for ( int j = 0 ; j < 64 ; ++ j ) input [ j ] = src [ j ] - dst [ j ] ; reference_dct_2d ( input , output_r ) ; for ( int j = 0 ; j < 64 ; ++ j ) coeff [ j ] = round ( output_r [ j ] ) ; vp9_idct8x8_64_add_c ( coeff , dst , 8 ) ; for ( int j = 0 ; j < 64 ; ++ j ) { const int diff = dst [ j ] - src [ j ] ; const int error = diff * diff ; EXPECT_GE ( 1 , error ) < < "Error: 8x8 FDCT/IDCT has error " < < error < < " at index " < < j ; } } }
Node * RawMachineAssembler :: RelocatableIntPtrConstant ( intptr_t value , RelocInfo :: Mode rmode ) { return kPointerSize == 8 ? RelocatableInt64Constant ( value , rmode ) : RelocatableInt32Constant ( static_cast < int > ( value ) , rmode ) ; }
cib_recv_tls ( gnutls_session * session ) { char * buf = NULL ; int rc = 0 ; int len = 0 ; int chunk_size = 1024 ; if ( session == NULL ) { return NULL ; } buf = calloc ( 1 , chunk_size ) ; while ( TRUE ) { errno = 0 ; rc = gnutls_record_recv ( * session , buf + len , chunk_size ) ; crm_trace ( "Got %d more bytes. errno=%d" , rc , errno ) ; if ( rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN ) { crm_trace ( "Retry" ) ; } else if ( rc == GNUTLS_E_UNEXPECTED_PACKET_LENGTH ) { crm_trace ( "Session disconnected" ) ; goto bail ; } else if ( rc < 0 ) { crm_err ( "Error receiving message: %s (%d)" , gnutls_strerror ( rc ) , rc ) ; goto bail ; } else if ( rc == chunk_size ) { len += rc ; chunk_size *= 2 ; buf = realloc ( buf , len + chunk_size ) ; crm_trace ( "Retry with %d more bytes" , ( int ) chunk_size ) ; CRM_ASSERT ( buf != NULL ) ; } else if ( buf [ len + rc - 1 ] != 0 ) { crm_trace ( "Last char is %d '%c'" , buf [ len + rc - 1 ] , buf [ len + rc - 1 ] ) ; crm_trace ( "Retry with %d more bytes" , ( int ) chunk_size ) ; len += rc ; buf = realloc ( buf , len + chunk_size ) ; CRM_ASSERT ( buf != NULL ) ; } else { crm_trace ( "Got %d more bytes" , ( int ) rc ) ; return buf ; } } bail : free ( buf ) ; return NULL ; }
static void TailCallRuntimeIfMarkerEquals ( MacroAssembler * masm , Register smi_entry , OptimizationMarker marker , Runtime :: FunctionId function_id ) { Label no_match ; __ Branch ( & no_match , ne , smi_entry , Operand ( Smi :: FromEnum ( marker ) ) ) ; GenerateTailCallToReturnedCode ( masm , function_id ) ; __ bind ( & no_match ) ; }
get_function_args ( char_u * * argp , char_u endchar , garray_T * newargs , garray_T * argtypes , int types_optional , evalarg_T * evalarg , int * varargs , garray_T * default_args , int skip , exarg_T * eap , char_u * * line_to_free ) { int mustend = FALSE ; char_u * arg ; char_u * p ; int c ; int any_default = FALSE ; char_u * expr ; char_u * whitep = * argp ; if ( newargs != NULL ) ga_init2 ( newargs , ( int ) sizeof ( char_u * ) , 3 ) ; if ( argtypes != NULL ) ga_init2 ( argtypes , ( int ) sizeof ( char_u * ) , 3 ) ; if ( ! skip && default_args != NULL ) ga_init2 ( default_args , ( int ) sizeof ( char_u * ) , 3 ) ; if ( varargs != NULL ) * varargs = FALSE ; arg = skipwhite ( * argp ) ; p = arg ; while ( * p != endchar ) { while ( eap != NULL && eap -> getline != NULL && ( * p == NUL || ( VIM_ISWHITE ( * whitep ) && * p == '#' ) ) ) { char_u * theline ; theline = eap -> getline ( ':' , eap -> cookie , 0 , TRUE ) ; if ( theline == NULL ) break ; vim_free ( * line_to_free ) ; * line_to_free = theline ; whitep = ( char_u * ) " " ; p = skipwhite ( theline ) ; } if ( mustend && * p != endchar ) { if ( ! skip ) semsg ( _ ( e_invarg2 ) , * argp ) ; goto err_ret ; } if ( * p == endchar ) break ; if ( p [ 0 ] == '.' && p [ 1 ] == '.' && p [ 2 ] == '.' ) { if ( varargs != NULL ) * varargs = TRUE ; p += 3 ; mustend = TRUE ; if ( argtypes != NULL ) { if ( ! eval_isnamec1 ( * p ) ) { if ( ! skip ) emsg ( _ ( e_missing_name_after_dots ) ) ; goto err_ret ; } arg = p ; p = one_function_arg ( p , newargs , argtypes , types_optional , evalarg , TRUE , skip ) ; if ( p == arg ) break ; if ( * skipwhite ( p ) == '=' ) { emsg ( _ ( e_cannot_use_default_for_variable_arguments ) ) ; break ; } } } else { char_u * np ; arg = p ; p = one_function_arg ( p , newargs , argtypes , types_optional , evalarg , FALSE , skip ) ; if ( p == arg ) break ; np = skipwhite ( p ) ; if ( * np == '=' && np [ 1 ] != '=' && np [ 1 ] != '~' && default_args != NULL ) { typval_T rettv ; any_default = TRUE ; p = skipwhite ( p ) + 1 ; whitep = p ; p = skipwhite ( p ) ; expr = p ; if ( eval1 ( & p , & rettv , NULL ) != FAIL ) { if ( ! skip ) { if ( ga_grow ( default_args , 1 ) == FAIL ) goto err_ret ; while ( p > expr && VIM_ISWHITE ( p [ - 1 ] ) ) p -- ; c = * p ; * p = NUL ; expr = vim_strsave ( expr ) ; if ( expr == NULL ) { * p = c ; goto err_ret ; } ( ( char_u * * ) ( default_args -> ga_data ) ) [ default_args -> ga_len ] = expr ; default_args -> ga_len ++ ; * p = c ; } } else mustend = TRUE ; } else if ( any_default ) { emsg ( _ ( "E989: Non-default argument follows default argument" ) ) ; goto err_ret ; } if ( VIM_ISWHITE ( * p ) && * skipwhite ( p ) == ',' ) { if ( ! skip ) { semsg ( _ ( e_no_white_space_allowed_before_str_str ) , "," , p ) ; goto err_ret ; } p = skipwhite ( p ) ; } if ( * p == ',' ) { ++ p ; if ( ! skip && argtypes != NULL && ! IS_WHITE_OR_NUL ( * p ) && * p != endchar ) { semsg ( _ ( e_white_space_required_after_str_str ) , "," , p - 1 ) ; goto err_ret ; } } else mustend = TRUE ; } whitep = p ; p = skipwhite ( p ) ; } if ( * p != endchar ) goto err_ret ; ++ p ; * argp = p ; return OK ; err_ret : if ( newargs != NULL ) ga_clear_strings ( newargs ) ; if ( ! skip && default_args != NULL ) ga_clear_strings ( default_args ) ; return FAIL ; }
static enum sctp_disposition sctp_sf_shut_8_4_5 ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const union sctp_subtype type , void * arg , struct sctp_cmd_seq * commands ) { struct sctp_packet * packet = NULL ; struct sctp_chunk * chunk = arg ; struct sctp_chunk * shut ; packet = sctp_ootb_pkt_new ( net , asoc , chunk ) ; if ( ! packet ) return SCTP_DISPOSITION_NOMEM ; shut = sctp_make_shutdown_complete ( asoc , chunk ) ; if ( ! shut ) { sctp_ootb_pkt_free ( packet ) ; return SCTP_DISPOSITION_NOMEM ; } if ( sctp_test_T_bit ( shut ) ) packet -> vtag = ntohl ( chunk -> sctp_hdr -> vtag ) ; shut -> skb -> sk = ep -> base . sk ; sctp_packet_append_chunk ( packet , shut ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SEND_PKT , SCTP_PACKET ( packet ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_OUTCTRLCHUNKS ) ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( struct sctp_chunkhdr ) ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; }
png_handle_iTXt ( png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) { png_const_charp errmsg = NULL ; png_bytep buffer ; png_uint_32 prefix_length ; png_debug ( 1 , "in png_handle_iTXt" ) ; #ifdef PNG_USER_LIMITS_SUPPORTED if ( png_ptr -> user_chunk_cache_max != 0 ) { if ( png_ptr -> user_chunk_cache_max == 1 ) { png_crc_finish ( png_ptr , length ) ; return ; } if ( -- png_ptr -> user_chunk_cache_max == 1 ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "no space in chunk cache" ) ; return ; } } #endif if ( ! ( png_ptr -> mode & PNG_HAVE_IHDR ) ) png_chunk_error ( png_ptr , "missing IHDR" ) ; if ( png_ptr -> mode & PNG_HAVE_IDAT ) png_ptr -> mode |= PNG_AFTER_IDAT ; buffer = png_read_buffer ( png_ptr , length + 1 , 1 ) ; if ( buffer == NULL ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "out of memory" ) ; return ; } png_crc_read ( png_ptr , buffer , length ) ; if ( png_crc_finish ( png_ptr , 0 ) ) return ; for ( prefix_length = 0 ; prefix_length < length && buffer [ prefix_length ] != 0 ; ++ prefix_length ) ; if ( prefix_length > 79 || prefix_length < 1 ) errmsg = "bad keyword" ; else if ( prefix_length + 5 > length ) errmsg = "truncated" ; else if ( buffer [ prefix_length + 1 ] == 0 || ( buffer [ prefix_length + 1 ] == 1 && buffer [ prefix_length + 2 ] == PNG_COMPRESSION_TYPE_BASE ) ) { int compressed = buffer [ prefix_length + 1 ] != 0 ; png_uint_32 language_offset , translated_keyword_offset ; png_alloc_size_t uncompressed_length = 0 ; prefix_length += 3 ; language_offset = prefix_length ; for ( ; prefix_length < length && buffer [ prefix_length ] != 0 ; ++ prefix_length ) ; translated_keyword_offset = ++ prefix_length ; for ( ; prefix_length < length && buffer [ prefix_length ] != 0 ; ++ prefix_length ) ; ++ prefix_length ; if ( ! compressed && prefix_length <= length ) uncompressed_length = length - prefix_length ; else if ( compressed && prefix_length < length ) { uncompressed_length = PNG_SIZE_MAX ; if ( png_decompress_chunk ( png_ptr , length , prefix_length , & uncompressed_length , 1 ) == Z_STREAM_END ) buffer = png_ptr -> read_buffer ; else errmsg = png_ptr -> zstream . msg ; } else errmsg = "truncated" ; if ( errmsg == NULL ) { png_text text ; buffer [ uncompressed_length + prefix_length ] = 0 ; if ( compressed ) text . compression = PNG_ITXT_COMPRESSION_NONE ; else text . compression = PNG_ITXT_COMPRESSION_zTXt ; text . key = ( png_charp ) buffer ; text . lang = ( png_charp ) buffer + language_offset ; text . lang_key = ( png_charp ) buffer + translated_keyword_offset ; text . text = ( png_charp ) buffer + prefix_length ; text . text_length = 0 ; text . itxt_length = uncompressed_length ; if ( png_set_text_2 ( png_ptr , info_ptr , & text , 1 ) ) errmsg = "insufficient memory" ; } } else errmsg = "bad compression info" ; if ( errmsg != NULL ) png_chunk_benign_error ( png_ptr , errmsg ) ; }
static OPJ_BOOL opj_jp2_write_ftyp ( opj_jp2_t * jp2 , opj_stream_private_t * cio , opj_event_mgr_t * p_manager ) { OPJ_UINT32 i ; OPJ_UINT32 l_ftyp_size = 16 + 4 * jp2 -> numcl ; OPJ_BYTE * l_ftyp_data , * l_current_data_ptr ; OPJ_BOOL l_result ; assert ( cio != 00 ) ; assert ( jp2 != 00 ) ; assert ( p_manager != 00 ) ; l_ftyp_data = ( OPJ_BYTE * ) opj_calloc ( 1 , l_ftyp_size ) ; if ( l_ftyp_data == 00 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not enough memory to handle ftyp data\n" ) ; return OPJ_FALSE ; } l_current_data_ptr = l_ftyp_data ; opj_write_bytes ( l_current_data_ptr , l_ftyp_size , 4 ) ; l_current_data_ptr += 4 ; opj_write_bytes ( l_current_data_ptr , JP2_FTYP , 4 ) ; l_current_data_ptr += 4 ; opj_write_bytes ( l_current_data_ptr , jp2 -> brand , 4 ) ; l_current_data_ptr += 4 ; opj_write_bytes ( l_current_data_ptr , jp2 -> minversion , 4 ) ; l_current_data_ptr += 4 ; for ( i = 0 ; i < jp2 -> numcl ; i ++ ) { opj_write_bytes ( l_current_data_ptr , jp2 -> cl [ i ] , 4 ) ; } l_result = ( opj_stream_write_data ( cio , l_ftyp_data , l_ftyp_size , p_manager ) == l_ftyp_size ) ; if ( ! l_result ) { opj_event_msg ( p_manager , EVT_ERROR , "Error while writing ftyp data to stream\n" ) ; } opj_free ( l_ftyp_data ) ; return l_result ; }
TEST_F ( DeviceClassTest , limited_discoverable_mode ) { uint8_t dc_stream [ ] = { 0x00 , 0x00 , 0x00 } ; bt_device_class_t dc ; device_class_from_stream ( & dc , dc_stream ) ; uint32_t * test = ( uint32_t * ) & dc ; EXPECT_FALSE ( device_class_get_limited ( & dc ) ) ; EXPECT_EQ ( ( unsigned ) 0x00000000 , * test & DC_MASK ) ; device_class_set_limited ( & dc , true ) ; EXPECT_TRUE ( device_class_get_limited ( & dc ) ) ; EXPECT_EQ ( ( unsigned ) 0x00002000 , * test & DC_MASK ) ; device_class_set_limited ( & dc , false ) ; EXPECT_FALSE ( device_class_get_limited ( & dc ) ) ; EXPECT_EQ ( ( unsigned ) 0x00000000 , * test & DC_MASK ) ; device_class_set_limited ( & dc , true ) ; EXPECT_PRED_FORMAT2 ( check_bitfield , 0x00002000 , * test & DC_MASK ) ; device_class_set_limited ( & dc , false ) ; EXPECT_PRED_FORMAT2 ( check_bitfield , 0x00000000 , * test & DC_MASK ) ; }
Compute ( OpKernelContext * context , bool sorted , int k , const typename TTypes < T , 2 > :: ConstTensor & input , const int64 num_rows , const int64 num_cols , typename TTypes < T , 2 > :: Tensor values , typename TTypes < int , 2 > :: Tensor indices ) { const CPUDevice & d = context -> eigen_device < CPUDevice > ( ) ; if ( k == 1 ) { #ifdef EIGEN_HAS_INDEX_LIST typename Eigen :: IndexList < Eigen :: type2index < 1 > > reduce_on_cols ; typename Eigen :: IndexList < int , Eigen :: type2index < 1 > > rows_by_one ; rows_by_one . set ( 0 , num_rows ) ; #else Eigen :: array < int , 1 > reduce_on_cols = { 1 } ; Eigen :: array < int , 2 > rows_by_one = { static_cast < int > ( num_rows ) , 1 } ; #endif values . device ( d ) = input . maximum ( reduce_on_cols ) . eval ( ) . reshape ( rows_by_one ) ; for ( int r = 0 ; r < num_rows ; ++ r ) { indices ( r , 0 ) = 0 ; for ( int c = 0 ; c < num_cols ; ++ c ) { if ( values ( r , 0 ) == input ( r , c ) ) { indices ( r , 0 ) = c ; break ; } } values ( r , 0 ) = input ( r , indices ( r , 0 ) ) ; } return Status :: OK ( ) ; } auto SortIndices = [ & ] ( int start_batch , int limit_batch ) { for ( int32 b = start_batch ; b < limit_batch ; ++ b ) { const T * input_data = & input ( b , 0 ) ; const auto stable_comp = [ input_data ] ( const int32 a , const int32 b ) { if ( input_data [ b ] < input_data [ a ] ) { return true ; } else if ( input_data [ b ] > input_data [ a ] ) { return false ; } else { return a < b ; } } ; const auto comp = [ input_data ] ( const int32 a , const int32 b ) { return input_data [ b ] < input_data [ a ] ; } ; if ( k == num_cols ) { auto * begin = & indices ( b , 0 ) ; auto * end = & indices ( b , k ) ; std :: iota ( begin , end , 0 ) ; std :: sort ( begin , end , comp ) ; for ( auto * run_begin = begin ; run_begin != end ; ) { auto * run_end = run_begin + 1 ; if ( run_end == end ) break ; if ( input_data [ * run_begin ] == input_data [ * run_end ] ) { while ( ++ run_end != end ) { if ( input_data [ * run_begin ] != input_data [ * run_end ] ) break ; } std :: sort ( run_begin , run_end ) ; } run_begin = run_end ; } } else { gtl :: TopN < int32 , decltype ( stable_comp ) > filter ( k , stable_comp ) ; filter . reserve ( num_cols ) ; for ( int32 c = 0 ; c < num_cols ; ++ c ) { filter . push ( c ) ; } int32 i = 0 ; if ( sorted ) { std :: unique_ptr < std :: vector < int32 > > top_k ( filter . Extract ( ) ) ; for ( auto top_k_it = top_k -> begin ( ) ; top_k_it != top_k -> end ( ) ; ++ top_k_it , ++ i ) { indices ( b , i ) = * top_k_it ; } } else { for ( auto top_k_it = filter . unsorted_begin ( ) ; top_k_it != filter . unsorted_end ( ) ; ++ top_k_it , ++ i ) { indices ( b , i ) = * top_k_it ; } } } std :: transform ( & indices ( b , 0 ) , & indices ( b , k ) , & values ( b , 0 ) , [ b , & input ] ( const int32 loc ) { return input ( b , loc ) ; } ) ; } } ; const double cmp_cost = 3 * Eigen :: TensorOpCost :: AddCost < int32 > ( ) + Eigen :: TensorOpCost :: AddCost < T > ( ) ; const double base_cost = cmp_cost * static_cast < double > ( num_cols * Eigen :: numext :: log2 ( static_cast < float > ( k + 1 ) ) ) ; const double sort_cost = ( k == num_cols ) ? base_cost : 4 * base_cost ; const double copy_cost = 2 * k * Eigen :: TensorOpCost :: AddCost < T > ( ) ; const double total_cost = sort_cost + copy_cost ; const int64 final_cost = ( total_cost >= static_cast < double > ( kint64max ) ) ? kint64max : static_cast < int64 > ( total_cost ) ; auto worker_threads = * ( context -> device ( ) -> tensorflow_cpu_worker_threads ( ) ) ; Shard ( worker_threads . num_threads , worker_threads . workers , num_rows , final_cost , SortIndices ) ; return Status :: OK ( ) ; }
void read ( Protocol_ * iprot , const StructInfo & structInfo , void * object ) { DCHECK ( object ) ; ProtocolReaderStructReadState < Protocol_ > readState ; readState . readStructBegin ( iprot ) ; if ( UNLIKELY ( structInfo . unionExt != nullptr ) ) { readState . fieldId = 0 ; readState . readFieldBegin ( iprot ) ; if ( readState . atStop ( ) ) { structInfo . unionExt -> clear ( object ) ; readState . readStructEnd ( iprot ) ; return ; } const auto * fieldInfo = findFieldInfo ( iprot , readState , structInfo ) ; if ( fieldInfo ) { void * unionVal = getMember ( * fieldInfo , object ) ; structInfo . unionExt -> initMember [ fieldInfo - structInfo . fieldInfos ] ( unionVal ) ; read ( iprot , * fieldInfo -> typeInfo , readState , unionVal ) ; const_cast < FieldID & > ( activeUnionMemberId ( object , structInfo . unionExt -> unionTypeOffset ) ) = fieldInfo -> id ; } else { skip ( iprot , readState ) ; } readState . readFieldEnd ( iprot ) ; readState . readFieldBegin ( iprot ) ; if ( UNLIKELY ( ! readState . atStop ( ) ) ) { TProtocolException :: throwUnionMissingStop ( ) ; } readState . readStructEnd ( iprot ) ; return ; } FieldID prevFieldId = 0 ; std :: int16_t index = 0 ; for ( ; ; ++ index ) { auto * fieldInfo = index < structInfo . numFields ? & structInfo . fieldInfos [ index ] : & kStopMarker ; if ( UNLIKELY ( ! readState . advanceToNextField ( iprot , prevFieldId , fieldInfo -> id , fieldInfo -> typeInfo -> type ) ) ) { for ( ; ; ) { readState . afterAdvanceFailure ( iprot ) ; if ( readState . atStop ( ) ) { readState . readStructEnd ( iprot ) ; return ; } fieldInfo = findFieldInfo ( iprot , readState , structInfo ) ; if ( fieldInfo ) { index = fieldInfo - structInfo . fieldInfos ; break ; } skip ( iprot , readState ) ; } } else if ( UNLIKELY ( index >= structInfo . numFields ) ) { readState . readStructEnd ( iprot ) ; return ; } prevFieldId = fieldInfo -> id ; read ( iprot , * fieldInfo -> typeInfo , readState , getMember ( * fieldInfo , object ) ) ; if ( fieldInfo -> issetOffset > 0 ) { const_cast < bool & > ( fieldIsSet ( object , fieldInfo -> issetOffset ) ) = true ; } } }
virtual sp < IBinder > getService ( const String16 & name ) const { sp < IBinder > svc = checkService ( name ) ; if ( svc != nullptr ) return svc ; const bool isVendorService = strcmp ( ProcessState :: self ( ) -> getDriverName ( ) . c_str ( ) , "/dev/vndbinder" ) == 0 ; const long timeout = uptimeMillis ( ) + 5000 ; if ( ! gSystemBootCompleted && ! isVendorService ) { char bootCompleted [ PROPERTY_VALUE_MAX ] ; property_get ( "sys.boot_completed" , bootCompleted , "0" ) ; gSystemBootCompleted = strcmp ( bootCompleted , "1" ) == 0 ? true : false ; } const long sleepTime = gSystemBootCompleted ? 1000 : 100 ; int n = 0 ; while ( uptimeMillis ( ) < timeout ) { n ++ ; ALOGI ( "Waiting for service '%s' on '%s'..." , String8 ( name ) . string ( ) , ProcessState :: self ( ) -> getDriverName ( ) . c_str ( ) ) ; usleep ( 1000 * sleepTime ) ; sp < IBinder > svc = checkService ( name ) ; if ( svc != nullptr ) return svc ; } ALOGW ( "Service %s didn't start. Returning NULL" , String8 ( name ) . string ( ) ) ; return nullptr ; }
static void estimate_missing_mvs ( MB_OVERLAP * overlaps , MODE_INFO * mi , MODE_INFO * prev_mi , int mb_rows , int mb_cols , unsigned int first_corrupt ) { int mb_row , mb_col ; vpx_memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ; for ( mb_row = 0 ; mb_row < mb_rows ; ++ mb_row ) { for ( mb_col = 0 ; mb_col < mb_cols ; ++ mb_col ) { if ( prev_mi -> mbmi . ref_frame == LAST_FRAME ) { calc_prev_mb_overlaps ( overlaps , prev_mi , mb_row , mb_col , mb_rows , mb_cols ) ; } ++ prev_mi ; } ++ prev_mi ; } mb_row = first_corrupt / mb_cols ; mb_col = first_corrupt - mb_row * mb_cols ; mi += mb_row * ( mb_cols + 1 ) + mb_col ; for ( ; mb_row < mb_rows ; ++ mb_row ) { int mb_to_top_edge = - ( ( mb_row * 16 ) ) < < 3 ; int mb_to_bottom_edge = ( ( mb_rows - 1 - mb_row ) * 16 ) < < 3 ; for ( ; mb_col < mb_cols ; ++ mb_col ) { int mb_to_left_edge = - ( ( mb_col * 16 ) < < 3 ) ; int mb_to_right_edge = ( ( mb_cols - 1 - mb_col ) * 16 ) < < 3 ; const B_OVERLAP * block_overlaps = overlaps [ mb_row * mb_cols + mb_col ] . overlaps ; mi -> mbmi . ref_frame = LAST_FRAME ; mi -> mbmi . mode = SPLITMV ; mi -> mbmi . uv_mode = DC_PRED ; mi -> mbmi . partitioning = 3 ; mi -> mbmi . segment_id = 0 ; estimate_mb_mvs ( block_overlaps , mi , mb_to_left_edge , mb_to_right_edge , mb_to_top_edge , mb_to_bottom_edge ) ; ++ mi ; } mb_col = 0 ; ++ mi ; } }
MaybeHandle < WasmModuleObject > CompileToModuleObject ( Isolate * isolate , const WasmFeatures & enabled , ErrorThrower * thrower , std :: shared_ptr < const WasmModule > module , const ModuleWireBytes & wire_bytes , Handle < Script > asm_js_script , Vector < const byte > asm_js_offset_table_bytes ) { const WasmModule * wasm_module = module . get ( ) ; TimedHistogramScope wasm_compile_module_time_scope ( SELECT_WASM_COUNTER ( isolate -> counters ( ) , wasm_module -> origin , wasm_compile , module_time ) ) ; if ( wasm_module -> has_shared_memory ) { isolate -> CountUsage ( v8 :: Isolate :: UseCounterFeature :: kWasmSharedMemory ) ; } base :: Optional < CodeSpaceMemoryModificationScope > modification_scope ( base :: in_place_t ( ) , isolate -> heap ( ) ) ; Handle < Script > script ; Handle < ByteArray > asm_js_offset_table ; if ( asm_js_script . is_null ( ) ) { script = CreateWasmScript ( isolate , wire_bytes ) ; } else { script = asm_js_script ; asm_js_offset_table = isolate -> factory ( ) -> NewByteArray ( asm_js_offset_table_bytes . length ( ) ) ; asm_js_offset_table -> copy_in ( 0 , asm_js_offset_table_bytes . start ( ) , asm_js_offset_table_bytes . length ( ) ) ; } OwnedVector < uint8_t > wire_bytes_copy = OwnedVector < uint8_t > :: Of ( wire_bytes . module_bytes ( ) ) ; ModuleEnv env = CreateDefaultModuleEnv ( wasm_module ) ; Handle < WasmModuleObject > module_object = WasmModuleObject :: New ( isolate , enabled , std :: move ( module ) , env , std :: move ( wire_bytes_copy ) , script , asm_js_offset_table ) ; CompileNativeModule ( isolate , thrower , module_object , wasm_module , & env ) ; if ( thrower -> error ( ) ) return { } ; CompileJsToWasmWrappers ( isolate , module_object ) ; if ( asm_js_script . is_null ( ) ) { modification_scope . reset ( ) ; isolate -> debug ( ) -> OnAfterCompile ( script ) ; } module_object -> native_module ( ) -> LogWasmCodes ( isolate ) ; return module_object ; }
nsXBLProtoImpl :: Read ( nsIScriptContext * aContext , nsIObjectInputStream * aStream , nsXBLPrototypeBinding * aBinding , nsIScriptGlobalObject * aGlobal ) { JSContext * cx = aContext -> GetNativeContext ( ) ; JSObject * global = aGlobal -> GetGlobalJSObject ( ) ; JSObject * classObject ; nsresult rv = aBinding -> InitClass ( mClassName , cx , global , global , & classObject ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; NS_ENSURE_TRUE ( classObject , NS_ERROR_FAILURE ) ; mClassObject = classObject ; nsXBLProtoImplField * previousField = nullptr ; nsXBLProtoImplMember * previousMember = nullptr ; do { XBLBindingSerializeDetails type ; rv = aStream -> Read8 ( & type ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( type == XBLBinding_Serialize_NoMoreItems ) break ; switch ( type & XBLBinding_Serialize_Mask ) { case XBLBinding_Serialize_Field : { nsXBLProtoImplField * field = new nsXBLProtoImplField ( type & XBLBinding_Serialize_ReadOnly ) ; rv = field -> Read ( aContext , aStream ) ; if ( NS_FAILED ( rv ) ) { delete field ; return rv ; } if ( previousField ) { previousField -> SetNext ( field ) ; } else { mFields = field ; } previousField = field ; break ; } case XBLBinding_Serialize_GetterProperty : case XBLBinding_Serialize_SetterProperty : case XBLBinding_Serialize_GetterSetterProperty : { nsAutoString name ; nsresult rv = aStream -> ReadString ( name ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsXBLProtoImplProperty * prop = new nsXBLProtoImplProperty ( name . get ( ) , type & XBLBinding_Serialize_ReadOnly ) ; rv = prop -> Read ( aContext , aStream , type & XBLBinding_Serialize_Mask ) ; if ( NS_FAILED ( rv ) ) { delete prop ; return rv ; } previousMember = AddMember ( prop , previousMember ) ; break ; } case XBLBinding_Serialize_Method : { nsAutoString name ; rv = aStream -> ReadString ( name ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsXBLProtoImplMethod * method = new nsXBLProtoImplMethod ( name . get ( ) ) ; rv = method -> Read ( aContext , aStream ) ; if ( NS_FAILED ( rv ) ) { delete method ; return rv ; } previousMember = AddMember ( method , previousMember ) ; break ; } case XBLBinding_Serialize_Constructor : { mConstructor = new nsXBLProtoImplAnonymousMethod ( ) ; rv = mConstructor -> Read ( aContext , aStream ) ; if ( NS_FAILED ( rv ) ) { delete mConstructor ; mConstructor = nullptr ; return rv ; } previousMember = AddMember ( mConstructor , previousMember ) ; break ; } case XBLBinding_Serialize_Destructor : { mDestructor = new nsXBLProtoImplAnonymousMethod ( ) ; rv = mDestructor -> Read ( aContext , aStream ) ; if ( NS_FAILED ( rv ) ) { delete mDestructor ; mDestructor = nullptr ; return rv ; } previousMember = AddMember ( mDestructor , previousMember ) ; break ; } default : NS_ERROR ( "Unexpected binding member type" ) ; break ; } } while ( 1 ) ; return NS_OK ; }
startParsing ( XML_Parser parser ) { if ( hash_secret_salt == 0 ) hash_secret_salt = generate_hash_secret_salt ( ) ; if ( ns ) { return setContext ( parser , implicitContext ) ; } return XML_TRUE ; }
SYSCALL_DEFINE6 ( sendto , int , fd , void __user * , buff , size_t , len , unsigned int , flags , struct sockaddr __user * , addr , int , addr_len ) { struct socket * sock ; struct sockaddr_storage address ; int err ; struct msghdr msg ; struct iovec iov ; int fput_needed ; if ( len > INT_MAX ) len = INT_MAX ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; iov . iov_base = buff ; iov . iov_len = len ; msg . msg_name = NULL ; iov_iter_init ( & msg . msg_iter , WRITE , & iov , 1 , len ) ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_namelen = 0 ; if ( addr ) { err = move_addr_to_kernel ( addr , addr_len , & address ) ; if ( err < 0 ) goto out_put ; msg . msg_name = ( struct sockaddr * ) & address ; msg . msg_namelen = addr_len ; } if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; msg . msg_flags = flags ; err = sock_sendmsg ( sock , & msg , len ) ; out_put : fput_light ( sock -> file , fput_needed ) ; out : return err ; }
- Label * next_holder , Label * if_bailout ) { - VARIABLE ( var_value , MachineRepresentation :: kTagged ) ; + CodeStubAssembler :: LookupPropertyInHolder lookup_property_in_holder = + [ = ] ( TNode < HeapObject > receiver , TNode < HeapObject > holder , + TNode < Map > holder_map , TNode < Int32T > holder_instance_type , + TNode < Name > unique_name , Label * next_holder , Label * if_bailout ) { + TVARIABLE ( Object , var_value ) ; Label if_found ( this ) ; - TryGetOwnProperty ( context , receiver , holder , holder_map , + TryGetOwnProperty ( context , receiver , CAST ( holder ) , holder_map , holder_instance_type , unique_name , & if_found , & var_value , next_holder , if_bailout ) ; BIND ( & if_found ) ; - { - var_result . Bind ( var_value . value ( ) ) ; - Goto ( & end ) ; - } + Return ( var_value . value ( ) ) ; } ;
static inline void add_sdb_addrline ( Sdb * s , ut64 addr , const char * file , ut64 line , int mode , PrintfCallback print ) { const char * p ; char * fileline ; char offset [ SDB_NUM_BUFSZ ] ; char * offset_ptr ; if ( ! s || ! file ) { return ; } p = r_str_rchr ( file , NULL , '/' ) ; if ( p ) { p ++ ; } else { p = file ; } switch ( mode ) { case 1 : case 'r' : case '*' : print ( "CL %s:%d 0x%08"PFMT64x "\n" , p , ( int ) line , addr ) ; break ; } #if 0 if ( r_file_exists ( file ) ) { p = file ; } #else p = file ; #endif fileline = r_str_newf ( "%s|%"PFMT64d , p , line ) ; offset_ptr = sdb_itoa ( addr , 16 , offset , sizeof ( offset ) ) ; sdb_add ( s , offset_ptr , fileline , 0 ) ; sdb_add ( s , fileline , offset_ptr , 0 ) ; free ( fileline ) ; }
void GCTracer :: Output ( const char * format , ... ) const { if ( FLAG_trace_gc ) { va_list arguments ; va_start ( arguments , format ) ; base :: OS :: VPrint ( format , arguments ) ; va_end ( arguments ) ; } const int kBufferSize = 256 ; char raw_buffer [ kBufferSize ] ; Vector < char > buffer ( raw_buffer , kBufferSize ) ; va_list arguments2 ; va_start ( arguments2 , format ) ; VSNPrintF ( buffer , format , arguments2 ) ; va_end ( arguments2 ) ; heap_ -> AddToRingBuffer ( buffer . start ( ) ) ; }
BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ; PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) nsc_rle_decompress_data ( context ) ; PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) context -> decode ( context ) ; PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }
ScriptSource :: substring ( JSContext * cx , uint32_t start , uint32_t stop ) { JS_ASSERT ( start <= stop ) ; SourceDataCache :: AutoSuppressPurge asp ( cx ) ; const jschar * chars = this -> chars ( cx , asp ) ; if ( ! chars ) return nullptr ; return js_NewStringCopyN < CanGC > ( cx , chars + start , stop - start ) ; }
Expression * Parser :: SpreadCall ( Expression * function , ZonePtrList < Expression > * args_list , int pos , Call :: PossiblyEval is_possibly_eval ) { if ( OnlyLastArgIsSpread ( args_list ) || function -> IsSuperCallReference ( ) ) { return factory ( ) -> NewCall ( function , args_list , pos ) ; } ZonePtrList < Expression > * args = new ( zone ( ) ) ZonePtrList < Expression > ( 3 , zone ( ) ) ; if ( function -> IsProperty ( ) ) { if ( function -> AsProperty ( ) -> IsSuperAccess ( ) ) { Expression * home = ThisExpression ( kNoSourcePosition ) ; args -> Add ( function , zone ( ) ) ; args -> Add ( home , zone ( ) ) ; } else { Variable * temp = NewTemporary ( ast_value_factory ( ) -> empty_string ( ) ) ; VariableProxy * obj = factory ( ) -> NewVariableProxy ( temp ) ; Assignment * assign_obj = factory ( ) -> NewAssignment ( Token :: ASSIGN , obj , function -> AsProperty ( ) -> obj ( ) , kNoSourcePosition ) ; function = factory ( ) -> NewProperty ( assign_obj , function -> AsProperty ( ) -> key ( ) , kNoSourcePosition ) ; args -> Add ( function , zone ( ) ) ; obj = factory ( ) -> NewVariableProxy ( temp ) ; args -> Add ( obj , zone ( ) ) ; } } else { args -> Add ( function , zone ( ) ) ; args -> Add ( factory ( ) -> NewUndefinedLiteral ( kNoSourcePosition ) , zone ( ) ) ; } args -> Add ( ArrayLiteralFromListWithSpread ( args_list ) , zone ( ) ) ; return factory ( ) -> NewCallRuntime ( Context :: REFLECT_APPLY_INDEX , args , pos ) ; }
static void EnterArgumentsAdaptorFrame ( MacroAssembler * masm ) { __ sll ( a0 , a0 , kSmiTagSize ) ; __ li ( t0 , Operand ( StackFrame :: TypeToMarker ( StackFrame :: ARGUMENTS_ADAPTOR ) ) ) ; __ MultiPush ( a0 . bit ( ) | a1 . bit ( ) | t0 . bit ( ) | fp . bit ( ) | ra . bit ( ) ) ; __ Push ( Smi :: kZero ) ; __ Addu ( fp , sp , Operand ( ArgumentsAdaptorFrameConstants :: kFixedFrameSizeFromFp ) ) ; }
base :: Optional < ParseResult > MakeNumberLiteralExpression ( ParseResultIterator * child_results ) { auto number = child_results -> NextAs < std :: string > ( ) ; Expression * result = MakeNode < NumberLiteralExpression > ( std :: move ( number ) ) ; return ParseResult { result } ; }
MaybeHandle < String > GetNamedCapture ( Handle < String > name , CaptureState * state ) override { DCHECK ( has_named_captures_ ) ; const int capture_index = LookupNamedCapture ( [ = ] ( String * capture_name ) { return capture_name -> Equals ( * name ) ; } , * capture_name_map_ ) ; if ( capture_index == - 1 ) { * state = INVALID ; return name ; } DCHECK ( 1 <= capture_index && capture_index <= CaptureCount ( ) ) ; bool capture_exists ; Handle < String > capture_value ; ASSIGN_RETURN_ON_EXCEPTION ( isolate_ , capture_value , GetCapture ( capture_index , & capture_exists ) , String ) ; if ( ! capture_exists ) { * state = UNMATCHED ; return isolate_ -> factory ( ) -> empty_string ( ) ; } else { * state = MATCHED ; return capture_value ; } }
static BOOL zgfx_decompress_segment ( ZGFX_CONTEXT * zgfx , wStream * stream , size_t segmentSize ) { BYTE c ; BYTE flags ; UINT32 extra = 0 ; int opIndex ; int haveBits ; int inPrefix ; UINT32 count ; UINT32 distance ; BYTE * pbSegment ; size_t cbSegment = segmentSize - 1 ; if ( ( Stream_GetRemainingLength ( stream ) < segmentSize ) || ( segmentSize < 1 ) ) return FALSE ; Stream_Read_UINT8 ( stream , flags ) ; zgfx -> OutputCount = 0 ; pbSegment = Stream_Pointer ( stream ) ; Stream_Seek ( stream , cbSegment ) ; if ( ! ( flags & PACKET_COMPRESSED ) ) { zgfx_history_buffer_ring_write ( zgfx , pbSegment , cbSegment ) ; CopyMemory ( zgfx -> OutputBuffer , pbSegment , cbSegment ) ; zgfx -> OutputCount = cbSegment ; return TRUE ; } zgfx -> pbInputCurrent = pbSegment ; zgfx -> pbInputEnd = & pbSegment [ cbSegment - 1 ] ; zgfx -> cBitsRemaining = 8 * ( cbSegment - 1 ) - * zgfx -> pbInputEnd ; zgfx -> cBitsCurrent = 0 ; zgfx -> BitsCurrent = 0 ; while ( zgfx -> cBitsRemaining ) { haveBits = 0 ; inPrefix = 0 ; for ( opIndex = 0 ; ZGFX_TOKEN_TABLE [ opIndex ] . prefixLength != 0 ; opIndex ++ ) { while ( haveBits < ZGFX_TOKEN_TABLE [ opIndex ] . prefixLength ) { zgfx_GetBits ( zgfx , 1 ) ; inPrefix = ( inPrefix < < 1 ) + zgfx -> bits ; haveBits ++ ; } if ( inPrefix == ZGFX_TOKEN_TABLE [ opIndex ] . prefixCode ) { if ( ZGFX_TOKEN_TABLE [ opIndex ] . tokenType == 0 ) { zgfx_GetBits ( zgfx , ZGFX_TOKEN_TABLE [ opIndex ] . valueBits ) ; c = ( BYTE ) ( ZGFX_TOKEN_TABLE [ opIndex ] . valueBase + zgfx -> bits ) ; zgfx -> HistoryBuffer [ zgfx -> HistoryIndex ] = c ; if ( ++ zgfx -> HistoryIndex == zgfx -> HistoryBufferSize ) zgfx -> HistoryIndex = 0 ; zgfx -> OutputBuffer [ zgfx -> OutputCount ++ ] = c ; } else { zgfx_GetBits ( zgfx , ZGFX_TOKEN_TABLE [ opIndex ] . valueBits ) ; distance = ZGFX_TOKEN_TABLE [ opIndex ] . valueBase + zgfx -> bits ; if ( distance != 0 ) { zgfx_GetBits ( zgfx , 1 ) ; if ( zgfx -> bits == 0 ) { count = 3 ; } else { count = 4 ; extra = 2 ; zgfx_GetBits ( zgfx , 1 ) ; while ( zgfx -> bits == 1 ) { count *= 2 ; extra ++ ; zgfx_GetBits ( zgfx , 1 ) ; } zgfx_GetBits ( zgfx , extra ) ; count += zgfx -> bits ; } zgfx_history_buffer_ring_read ( zgfx , distance , & ( zgfx -> OutputBuffer [ zgfx -> OutputCount ] ) , count ) ; zgfx_history_buffer_ring_write ( zgfx , & ( zgfx -> OutputBuffer [ zgfx -> OutputCount ] ) , count ) ; zgfx -> OutputCount += count ; } else { zgfx_GetBits ( zgfx , 15 ) ; count = zgfx -> bits ; zgfx -> cBitsRemaining -= zgfx -> cBitsCurrent ; zgfx -> cBitsCurrent = 0 ; zgfx -> BitsCurrent = 0 ; CopyMemory ( & ( zgfx -> OutputBuffer [ zgfx -> OutputCount ] ) , zgfx -> pbInputCurrent , count ) ; zgfx_history_buffer_ring_write ( zgfx , zgfx -> pbInputCurrent , count ) ; zgfx -> pbInputCurrent += count ; zgfx -> cBitsRemaining -= ( 8 * count ) ; zgfx -> OutputCount += count ; } } break ; } } } return TRUE ; }
LookupGetterOrSetter ( JSContext * cx , JSBool wantGetter , jsval * vp ) { uintN attrs ; JSBool found ; JSPropertyOp getter , setter ; JSObject * obj2 ; jsid interned_id ; jsval v ; XPC_QS_ASSERT_CONTEXT_OK ( cx ) ; JSObject * obj = JS_THIS_OBJECT ( cx , vp ) ; if ( ! obj ) return JS_FALSE ; jsval idval = JS_ARGV ( cx , vp ) [ 0 ] ; const char * name = JSVAL_IS_STRING ( idval ) ? JS_GetStringBytes ( JSVAL_TO_STRING ( idval ) ) : nsnull ; if ( ! JS_ValueToId ( cx , idval , & interned_id ) || ! JS_LookupPropertyWithFlagsById ( cx , obj , interned_id , JSRESOLVE_QUALIFIED , & obj2 , & v ) || ( obj2 && ! JS_GetPropertyAttrsGetterAndSetterById ( cx , obj2 , interned_id , & attrs , & found , & getter , & setter ) ) ) return JS_FALSE ; if ( ! obj2 || ! found ) { JS_SET_RVAL ( cx , vp , JSVAL_VOID ) ; return JS_TRUE ; } if ( wantGetter ) { if ( attrs & JSPROP_GETTER ) { JS_SET_RVAL ( cx , vp , OBJECT_TO_JSVAL ( JS_FUNC_TO_DATA_PTR ( JSObject * , getter ) ) ) ; return JS_TRUE ; } } else { if ( attrs & JSPROP_SETTER ) { JS_SET_RVAL ( cx , vp , OBJECT_TO_JSVAL ( JS_FUNC_TO_DATA_PTR ( JSObject * , setter ) ) ) ; return JS_TRUE ; } } if ( ! name || ! IS_PROTO_CLASS ( STOBJ_GET_CLASS ( obj2 ) ) || ( attrs & ( JSPROP_GETTER | JSPROP_SETTER ) ) || ! ( getter || setter ) ) { JS_SET_RVAL ( cx , vp , JSVAL_VOID ) ; return JS_TRUE ; } JSObject * getterobj , * setterobj ; if ( ! ReifyPropertyOps ( cx , obj , idval , interned_id , name , getter , setter , & getterobj , & setterobj ) ) return JS_FALSE ; JSObject * wantedobj = wantGetter ? getterobj : setterobj ; v = wantedobj ? OBJECT_TO_JSVAL ( wantedobj ) : JSVAL_VOID ; JS_SET_RVAL ( cx , vp , v ) ; return JS_TRUE ; }
const Operator * CommonOperatorBuilder :: NumberConstant ( volatile double value ) { return new ( zone ( ) ) Operator1 < double > ( IrOpcode :: kNumberConstant , Operator :: kPure , "NumberConstant" , 0 , 0 , 0 , 1 , 0 , 0 , value ) ; }
Type Typer :: Visitor :: BinaryNumberOpTyper ( Type lhs , Type rhs , Typer * t , BinaryTyperFun f ) { lhs = ToNumeric ( lhs , t ) ; rhs = ToNumeric ( rhs , t ) ; bool lhs_is_number = lhs . Is ( Type :: Number ( ) ) ; bool rhs_is_number = rhs . Is ( Type :: Number ( ) ) ; if ( lhs_is_number && rhs_is_number ) { return f ( lhs , rhs , t ) ; } if ( lhs_is_number || rhs_is_number ) { return Type :: Number ( ) ; } if ( lhs . Is ( Type :: BigInt ( ) ) || rhs . Is ( Type :: BigInt ( ) ) ) { return Type :: BigInt ( ) ; } return Type :: Numeric ( ) ; }
void WeakCollectionsBuiltinsAssembler :: AddEntry ( TNode < EphemeronHashTable > table , TNode < IntPtrT > key_index , TNode < Object > key , TNode < Object > value , TNode < IntPtrT > number_of_elements ) { TNode < IntPtrT > value_index = ValueIndexFromKeyIndex ( key_index ) ; StoreFixedArrayElement ( table , key_index , key ) ; StoreFixedArrayElement ( table , value_index , value ) ; StoreFixedArrayElement ( table , EphemeronHashTable :: kNumberOfElementsIndex , SmiFromIntPtr ( number_of_elements ) , SKIP_WRITE_BARRIER ) ; }
TypedArrayObject :: getElement ( uint32_t index ) { JS_ASSERT ( index < length ( ) ) ; switch ( type ( ) ) { case ScalarTypeDescr :: TYPE_INT8 : return TypedArrayObjectTemplate < int8_t > :: getIndexValue ( this , index ) ; break ; case ScalarTypeDescr :: TYPE_UINT8 : return TypedArrayObjectTemplate < uint8_t > :: getIndexValue ( this , index ) ; break ; case ScalarTypeDescr :: TYPE_UINT8_CLAMPED : return TypedArrayObjectTemplate < uint8_clamped > :: getIndexValue ( this , index ) ; break ; case ScalarTypeDescr :: TYPE_INT16 : return TypedArrayObjectTemplate < int16_t > :: getIndexValue ( this , index ) ; break ; case ScalarTypeDescr :: TYPE_UINT16 : return TypedArrayObjectTemplate < uint16_t > :: getIndexValue ( this , index ) ; break ; case ScalarTypeDescr :: TYPE_INT32 : return TypedArrayObjectTemplate < int32_t > :: getIndexValue ( this , index ) ; break ; case ScalarTypeDescr :: TYPE_UINT32 : return TypedArrayObjectTemplate < uint32_t > :: getIndexValue ( this , index ) ; break ; case ScalarTypeDescr :: TYPE_FLOAT32 : return TypedArrayObjectTemplate < float > :: getIndexValue ( this , index ) ; break ; case ScalarTypeDescr :: TYPE_FLOAT64 : return TypedArrayObjectTemplate < double > :: getIndexValue ( this , index ) ; break ; default : MOZ_ASSUME_UNREACHABLE ( "Unknown TypedArray type" ) ; break ; } }
void ItemParallelJob :: Task :: RunInternal ( ) { if ( gc_parallel_task_latency_histogram_ ) { gc_parallel_task_latency_histogram_ -> RecordDone ( ) ; gc_parallel_task_latency_histogram_ . reset ( ) ; } RunInParallel ( ) ; on_finish_ -> Signal ( ) ; }
Block * Parser :: BuildParameterInitializationBlock ( const ParserFormalParameters & parameters , bool * ok ) { DCHECK ( ! parameters . is_simple ) ; DCHECK ( scope ( ) -> is_function_scope ( ) ) ; DCHECK_EQ ( scope ( ) , parameters . scope ) ; Block * init_block = factory ( ) -> NewBlock ( 1 , true ) ; int index = 0 ; for ( auto parameter : parameters . params ) { DeclarationDescriptor descriptor ; descriptor . declaration_kind = DeclarationDescriptor :: PARAMETER ; descriptor . scope = scope ( ) ; descriptor . mode = VariableMode :: kLet ; descriptor . declaration_pos = parameter -> pattern -> position ( ) ; descriptor . initialization_pos = parameter -> pattern -> position ( ) ; Expression * initial_value = factory ( ) -> NewVariableProxy ( parameters . scope -> parameter ( index ) ) ; if ( parameter -> initializer != nullptr ) { RewriteParameterInitializer ( parameter -> initializer ) ; auto condition = factory ( ) -> NewCompareOperation ( Token :: EQ_STRICT , factory ( ) -> NewVariableProxy ( parameters . scope -> parameter ( index ) ) , factory ( ) -> NewUndefinedLiteral ( kNoSourcePosition ) , kNoSourcePosition ) ; initial_value = factory ( ) -> NewConditional ( condition , parameter -> initializer , initial_value , kNoSourcePosition ) ; descriptor . initialization_pos = parameter -> initializer -> position ( ) ; } Scope * param_scope = scope ( ) ; Block * param_block = init_block ; if ( ! parameter -> is_simple ( ) && scope ( ) -> AsDeclarationScope ( ) -> calls_sloppy_eval ( ) ) { param_scope = NewVarblockScope ( ) ; param_scope -> set_start_position ( descriptor . initialization_pos ) ; param_scope -> set_end_position ( parameter -> initializer_end_position ) ; param_scope -> RecordEvalCall ( ) ; param_block = factory ( ) -> NewBlock ( 8 , true ) ; param_block -> set_scope ( param_scope ) ; descriptor . scope = param_scope ; ReparentExpressionScope ( stack_limit ( ) , initial_value , param_scope ) ; } BlockState block_state ( & scope_ , param_scope ) ; DeclarationParsingResult :: Declaration decl ( parameter -> pattern , parameter -> initializer_end_position , initial_value ) ; DeclareAndInitializeVariables ( param_block , & descriptor , & decl , nullptr , CHECK_OK ) ; if ( param_block != init_block ) { param_scope = param_scope -> FinalizeBlockScope ( ) ; if ( param_scope != nullptr ) { CheckConflictingVarDeclarations ( param_scope , CHECK_OK ) ; } init_block -> statements ( ) -> Add ( param_block , zone ( ) ) ; } ++ index ; } return init_block ; }
LoadElimination :: AbstractState const * LoadElimination :: AbstractState :: AddField ( Node * object , size_t index , Node * value , MaybeHandle < Name > name , Zone * zone ) const { AbstractState * that = new ( zone ) AbstractState ( * this ) ; if ( that -> fields_ [ index ] ) { that -> fields_ [ index ] = that -> fields_ [ index ] -> Extend ( object , value , name , zone ) ; } else { that -> fields_ [ index ] = new ( zone ) AbstractField ( object , value , name , zone ) ; } return that ; }
PresShell :: Freeze ( ) { MaybeReleaseCapturingContent ( ) ; mDocument -> EnumerateFreezableElements ( FreezeElement , nullptr ) ; if ( mCaret ) { mCaret -> SetCaretVisible ( false ) ; } mPaintingSuppressed = true ; if ( mDocument ) { mDocument -> EnumerateSubDocuments ( FreezeSubDocument , nullptr ) ; } nsPresContext * presContext = GetPresContext ( ) ; if ( presContext && presContext -> RefreshDriver ( ) -> PresContext ( ) == presContext ) { presContext -> RefreshDriver ( ) -> Freeze ( ) ; } if ( presContext ) { nsRootPresContext * rootPresContext = presContext -> GetRootPresContext ( ) ; if ( rootPresContext ) { rootPresContext -> RootForgetUpdatePluginGeometryFrameForPresContext ( mPresContext ) ; } } mFrozen = true ; if ( mDocument ) { UpdateImageLockingState ( ) ; } }
int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr > > PAGE_SHIFT ; npages = mem -> memory_size > > PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( npages && ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } if ( ! npages ) { struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow_memslot ( kvm , slot ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr > > PAGE_SHIFT ) kvm_arch_flush_shadow_all ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }
TPMI_ALG_KEYEDHASH_SCHEME_Unmarshal ( TPMI_ALG_KEYEDHASH_SCHEME * target , BYTE * * buffer , INT32 * size , BOOL allowNull ) { TPM_RC rc = TPM_RC_SUCCESS ; if ( rc == TPM_RC_SUCCESS ) { rc = TPM_ALG_ID_Unmarshal ( target , buffer , size ) ; } if ( rc == TPM_RC_SUCCESS ) { switch ( * target ) { #if ALG_HMAC case TPM_ALG_HMAC : #endif #if ALG_XOR case TPM_ALG_XOR : #endif break ; case TPM_ALG_NULL : if ( allowNull ) { break ; } default : rc = TPM_RC_VALUE ; } } return rc ; }
png_get_compression_buffer_size ( png_const_structrp png_ptr ) { if ( png_ptr == NULL ) return 0 ; #  ifdef PNG_WRITE_SUPPORTED if ( png_ptr -> mode & PNG_IS_READ_STRUCT ) #  endif { #     ifdef PNG_SEQUENTIAL_READ_SUPPORTED return png_ptr -> IDAT_read_size ; #     else return PNG_IDAT_READ_SIZE ; #     endif } #  ifdef PNG_WRITE_SUPPORTED else return png_ptr -> zbuffer_size ; #  endif }
inline AllocationResult AllocateInOldSpace ( int size_in_bytes , AllocationAlignment alignment ) { AllocationResult allocation = local_allocator_ -> Allocate ( OLD_SPACE , size_in_bytes , alignment ) ; if ( allocation . IsRetry ( ) ) { heap_ -> FatalProcessOutOfMemory ( "MarkCompactCollector: semi-space copy, fallback in old gen" ) ; } return allocation ; }
void AsyncCompileJob :: ExecuteForegroundTaskImmediately ( ) { DCHECK_NULL ( pending_foreground_task_ ) ; auto new_task = base :: make_unique < CompileTask > ( this , true ) ; pending_foreground_task_ = new_task . get ( ) ; new_task -> Run ( ) ; }
void RegExpMacroAssemblerX64 :: CheckCharacterAfterAnd ( uint32_t c , uint32_t mask , Label * on_equal ) { if ( c == 0 ) { __ testl ( current_character ( ) , Immediate ( mask ) ) ; } else { __ movl ( rax , Immediate ( mask ) ) ; __ andp ( rax , current_character ( ) ) ; __ cmpl ( rax , Immediate ( c ) ) ; } BranchOrBacktrack ( equal , on_equal ) ; }
int vp9_alloc_context_buffers ( VP9_COMMON * cm , int width , int height ) { int new_mi_size ; vp9_set_mb_mi ( cm , width , height ) ; new_mi_size = cm -> mi_stride * calc_mi_size ( cm -> mi_rows ) ; if ( cm -> mi_alloc_size < new_mi_size ) { cm -> free_mi ( cm ) ; if ( cm -> alloc_mi ( cm , new_mi_size ) ) goto fail ; } if ( cm -> seg_map_alloc_size < cm -> mi_rows * cm -> mi_cols ) { free_seg_map ( cm ) ; if ( alloc_seg_map ( cm , cm -> mi_rows * cm -> mi_cols ) ) goto fail ; } if ( cm -> above_context_alloc_cols < cm -> mi_cols ) { vpx_free ( cm -> above_context ) ; cm -> above_context = ( ENTROPY_CONTEXT * ) vpx_calloc ( 2 * mi_cols_aligned_to_sb ( cm -> mi_cols ) * MAX_MB_PLANE , sizeof ( * cm -> above_context ) ) ; if ( ! cm -> above_context ) goto fail ; vpx_free ( cm -> above_seg_context ) ; cm -> above_seg_context = ( PARTITION_CONTEXT * ) vpx_calloc ( mi_cols_aligned_to_sb ( cm -> mi_cols ) , sizeof ( * cm -> above_seg_context ) ) ; if ( ! cm -> above_seg_context ) goto fail ; cm -> above_context_alloc_cols = cm -> mi_cols ; } return 0 ; fail : vp9_free_context_buffers ( cm ) ; return 1 ; }
int dccp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { const struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; __be16 orig_sport , orig_dport ; __be32 daddr , nexthop ; struct flowi4 fl4 ; struct rtable * rt ; int err ; dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) return - EAFNOSUPPORT ; nexthop = daddr = usin -> sin_addr . s_addr ; if ( inet -> opt != NULL && inet -> opt -> srr ) { if ( daddr == 0 ) return - EINVAL ; nexthop = inet -> opt -> faddr ; } orig_sport = inet -> inet_sport ; orig_dport = usin -> sin_port ; rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , IPPROTO_DCCP , orig_sport , orig_dport , sk , true ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; if ( rt -> rt_flags & ( RTCF_MULTICAST | RTCF_BROADCAST ) ) { ip_rt_put ( rt ) ; return - ENETUNREACH ; } if ( inet -> opt == NULL || ! inet -> opt -> srr ) daddr = rt -> rt_dst ; if ( inet -> inet_saddr == 0 ) inet -> inet_saddr = rt -> rt_src ; inet -> inet_rcv_saddr = inet -> inet_saddr ; inet -> inet_dport = usin -> sin_port ; inet -> inet_daddr = daddr ; inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ; if ( inet -> opt != NULL ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; dccp_set_state ( sk , DCCP_REQUESTING ) ; err = inet_hash_connect ( & dccp_death_row , sk ) ; if ( err != 0 ) goto failure ; rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , inet -> inet_sport , inet -> inet_dport , sk ) ; if ( IS_ERR ( rt ) ) { rt = NULL ; goto failure ; } sk_setup_caps ( sk , & rt -> dst ) ; dp -> dccps_iss = secure_dccp_sequence_number ( inet -> inet_saddr , inet -> inet_daddr , inet -> inet_sport , inet -> inet_dport ) ; inet -> inet_id = dp -> dccps_iss ^ jiffies ; err = dccp_connect ( sk ) ; rt = NULL ; if ( err != 0 ) goto failure ; out : return err ; failure : dccp_set_state ( sk , DCCP_CLOSED ) ; ip_rt_put ( rt ) ; sk -> sk_route_caps = 0 ; inet -> inet_dport = 0 ; goto out ; }
static void Generate_InterpreterPushArgs ( MacroAssembler * masm , Register num_args , Register first_arg_index , Register spread_arg_out , ConvertReceiverMode receiver_mode , InterpreterPushArgsMode mode ) { Register last_arg_addr = x10 ; Register stack_addr = x11 ; Register slots_to_claim = x12 ; Register slots_to_copy = x13 ; DCHECK ( ! AreAliased ( num_args , first_arg_index , last_arg_addr , stack_addr , slots_to_claim , slots_to_copy ) ) ; DCHECK ( ! AreAliased ( spread_arg_out , last_arg_addr , stack_addr , slots_to_claim , slots_to_copy ) ) ; __ Add ( slots_to_claim , num_args , 1 ) ; if ( mode == InterpreterPushArgsMode :: kWithFinalSpread ) { __ Sub ( slots_to_claim , slots_to_claim , 1 ) ; __ Sub ( num_args , num_args , 1 ) ; } Label stack_overflow , done ; Generate_StackOverflowCheck ( masm , slots_to_claim , & stack_overflow ) ; __ B ( & done ) ; __ Bind ( & stack_overflow ) ; __ TailCallRuntime ( Runtime :: kThrowStackOverflow ) ; __ Unreachable ( ) ; __ Bind ( & done ) ; __ Add ( slots_to_claim , slots_to_claim , 1 ) ; __ Bic ( slots_to_claim , slots_to_claim , 1 ) ; __ Claim ( slots_to_claim ) ; { UseScratchRegisterScope temps ( masm ) ; Register scratch = temps . AcquireX ( ) ; __ Sub ( scratch , slots_to_claim , 1 ) ; __ Poke ( padreg , Operand ( scratch , LSL , kPointerSizeLog2 ) ) ; } if ( receiver_mode == ConvertReceiverMode :: kNullOrUndefined ) { Register receiver = x14 ; __ LoadRoot ( receiver , Heap :: kUndefinedValueRootIndex ) ; __ SlotAddress ( stack_addr , num_args ) ; __ Str ( receiver , MemOperand ( stack_addr ) ) ; __ Mov ( slots_to_copy , num_args ) ; } else { __ Add ( slots_to_copy , num_args , 1 ) ; } __ Sub ( last_arg_addr , first_arg_index , Operand ( slots_to_copy , LSL , kPointerSizeLog2 ) ) ; __ Add ( last_arg_addr , last_arg_addr , kPointerSize ) ; if ( mode == InterpreterPushArgsMode :: kWithFinalSpread ) { __ Ldr ( spread_arg_out , MemOperand ( last_arg_addr , - kPointerSize ) ) ; } __ SlotAddress ( stack_addr , 0 ) ; __ CopyDoubleWords ( stack_addr , last_arg_addr , slots_to_copy ) ; }
static void setPowerBoostWithHandle ( sp < IPowerAidl > handle , Boost boost , int32_t durationMs ) { static std :: array < std :: atomic < HalSupport > , static_cast < int32_t > ( Boost :: DISPLAY_UPDATE_IMMINENT ) + 1 > boostSupportedArray = { HalSupport :: UNKNOWN } ; if ( boost > Boost :: DISPLAY_UPDATE_IMMINENT || boostSupportedArray [ static_cast < int32_t > ( boost ) ] == HalSupport :: OFF ) { ALOGV ( "Skipped setPowerBoost %s because HAL doesn't support it" , toString ( boost ) . c_str ( ) ) ; return ; } if ( boostSupportedArray [ static_cast < int32_t > ( boost ) ] == HalSupport :: UNKNOWN ) { bool isSupported = false ; handle -> isBoostSupported ( boost , & isSupported ) ; boostSupportedArray [ static_cast < int32_t > ( boost ) ] = isSupported ? HalSupport :: ON : HalSupport :: OFF ; if ( ! isSupported ) { ALOGV ( "Skipped setPowerBoost %s because HAL doesn't support it" , toString ( boost ) . c_str ( ) ) ; return ; } } auto ret = handle -> setBoost ( boost , durationMs ) ; processPowerHalReturn ( ret . isOk ( ) , "setPowerBoost" ) ; }
IonBailoutIterator :: IonBailoutIterator ( const JitActivationIterator & activations , const JitFrameIterator & frame ) : JitFrameIterator ( activations ) , machine_ ( frame . machineState ( ) ) { kind_ = Kind_BailoutIterator ; returnAddressToFp_ = frame . returnAddressToFp ( ) ; topIonScript_ = frame . ionScript ( ) ; const OsiIndex * osiIndex = frame . osiIndex ( ) ; current_ = ( uint8_t * ) frame . fp ( ) ; type_ = JitFrame_IonJS ; topFrameSize_ = frame . frameSize ( ) ; snapshotOffset_ = osiIndex -> snapshotOffset ( ) ; }
CanEffectlesslyCallLookupGenericOnObject ( JSObject * obj ) { while ( obj ) { if ( ! obj -> isNative ( ) ) return false ; if ( obj -> getClass ( ) -> ops . lookupProperty ) return false ; if ( obj -> getClass ( ) -> resolve != JS_ResolveStub ) return false ; obj = obj -> getProto ( ) ; } return true ; }
static void nfs4_open_release ( void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state * state = NULL ; if ( data -> cancelled == 0 ) goto out_free ; if ( data -> rpc_status != 0 || ! data -> rpc_done ) goto out_free ; if ( data -> o_res . rflags & NFS4_OPEN_RESULT_CONFIRM ) goto out_free ; state = nfs4_opendata_to_nfs4_state ( data ) ; if ( ! IS_ERR ( state ) ) nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ; out_free : nfs4_opendata_put ( data ) ; }
size_t SkBmpRLECodec :: checkForMoreData ( ) { const size_t remainingBytes = fRLEBytes - fCurrRLEByte ; uint8_t * buffer = fStreamBuffer . get ( ) ; memmove ( buffer , SkTAddOffset < uint8_t > ( buffer , fCurrRLEByte ) , remainingBytes ) ; buffer += remainingBytes ; size_t additionalBytes = this -> stream ( ) -> read ( buffer , fCurrRLEByte ) ; fCurrRLEByte = 0 ; fRLEBytes = remainingBytes + additionalBytes ; return fRLEBytes ; }
int uinput_create ( char * name ) { struct uinput_dev dev ; int fd , x = 0 ; for ( x = 0 ; x < MAX_UINPUT_PATHS ; x ++ ) { fd = open ( uinput_dev_path [ x ] , O_RDWR ) ; if ( fd < 0 ) continue ; break ; } if ( x == MAX_UINPUT_PATHS ) { BTIF_TRACE_ERROR ( "%s ERROR: uinput device open failed" , __FUNCTION__ ) ; return - 1 ; } memset ( & dev , 0 , sizeof ( dev ) ) ; if ( name ) strncpy ( dev . name , name , UINPUT_MAX_NAME_SIZE - 1 ) ; dev . id . bustype = BUS_BLUETOOTH ; dev . id . vendor = 0x0000 ; dev . id . product = 0x0000 ; dev . id . version = 0x0000 ; if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) { BTIF_TRACE_ERROR ( "%s Unable to write device information" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ; ioctl ( fd , UI_SET_EVBIT , EV_REL ) ; ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ; for ( x = 0 ; key_map [ x ] . name != NULL ; x ++ ) ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ; if ( ioctl ( fd , UI_DEV_CREATE , NULL ) < 0 ) { BTIF_TRACE_ERROR ( "%s Unable to create uinput device" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } return fd ; }
static int DecodeBasicOcspResponse ( byte * source , word32 * ioIndex , OcspResponse * resp , word32 size , void * cm , void * heap , int noVerify ) { int length ; word32 idx = * ioIndex ; word32 end_index ; int ret ; int sigLength ; WOLFSSL_ENTER ( "DecodeBasicOcspResponse" ) ; ( void ) heap ; if ( GetSequence ( source , & idx , & length , size ) < 0 ) return ASN_PARSE_E ; if ( idx + length > size ) return ASN_INPUT_E ; end_index = idx + length ; if ( ( ret = DecodeResponseData ( source , & idx , resp , size ) ) < 0 ) return ret ; if ( GetAlgoId ( source , & idx , & resp -> sigOID , oidSigType , size ) < 0 ) return ASN_PARSE_E ; ret = CheckBitString ( source , & idx , & sigLength , size , 1 , NULL ) ; if ( ret != 0 ) return ret ; resp -> sigSz = sigLength ; resp -> sig = source + idx ; idx += sigLength ; #ifndef WOLFSSL_NO_OCSP_OPTIONAL_CERTS if ( idx < end_index ) { DecodedCert cert ; if ( DecodeCerts ( source , & idx , resp , size ) < 0 ) return ASN_PARSE_E ; InitDecodedCert ( & cert , resp -> cert , resp -> certSz , heap ) ; ret = ParseCertRelative ( & cert , CERT_TYPE , noVerify ? NO_VERIFY : VERIFY_OCSP , cm ) ; if ( ret < 0 ) { WOLFSSL_MSG ( "\tOCSP Responder certificate parsing failed" ) ; FreeDecodedCert ( & cert ) ; return ret ; } #ifndef WOLFSSL_NO_OCSP_ISSUER_CHECK if ( ( cert . extExtKeyUsage & EXTKEYUSE_OCSP_SIGN ) == 0 ) { if ( XMEMCMP ( cert . subjectHash , resp -> single -> issuerHash , OCSP_DIGEST_SIZE ) == 0 ) { WOLFSSL_MSG ( "\tOCSP Response signed by issuer" ) ; } else { WOLFSSL_MSG ( "\tOCSP Responder key usage check failed" ) ; #ifdef OPENSSL_EXTRA resp -> verifyError = OCSP_BAD_ISSUER ; #else FreeDecodedCert ( & cert ) ; return BAD_OCSP_RESPONDER ; #endif } } #endif ret = ConfirmSignature ( & cert . sigCtx , resp -> response , resp -> responseSz , cert . publicKey , cert . pubKeySize , cert . keyOID , resp -> sig , resp -> sigSz , resp -> sigOID , NULL ) ; FreeDecodedCert ( & cert ) ; if ( ret != 0 ) { WOLFSSL_MSG ( "\tOCSP Confirm signature failed" ) ; return ASN_OCSP_CONFIRM_E ; } } else #endif /* WOLFSSL_NO_OCSP_OPTIONAL_CERTS */ { Signer * ca ; int sigValid = - 1 ; #ifndef NO_SKID ca = GetCA ( cm , resp -> single -> issuerKeyHash ) ; #else ca = GetCA ( cm , resp -> single -> issuerHash ) ; #endif if ( ca ) { SignatureCtx sigCtx ; InitSignatureCtx ( & sigCtx , heap , INVALID_DEVID ) ; sigValid = ConfirmSignature ( & sigCtx , resp -> response , resp -> responseSz , ca -> publicKey , ca -> pubKeySize , ca -> keyOID , resp -> sig , resp -> sigSz , resp -> sigOID , NULL ) ; } if ( ca == NULL || sigValid != 0 ) { WOLFSSL_MSG ( "\tOCSP Confirm signature failed" ) ; return ASN_OCSP_CONFIRM_E ; } ( void ) noVerify ; } * ioIndex = idx ; return 0 ; }
nsResizerFrame :: GetContentToResize ( nsIPresShell * aPresShell , nsIBaseWindow * * aWindow ) { * aWindow = nullptr ; nsAutoString elementid ; mContent -> GetAttr ( kNameSpaceID_None , nsGkAtoms :: element , elementid ) ; if ( elementid . IsEmpty ( ) ) { nsIFrame * popup = GetParent ( ) ; while ( popup ) { nsMenuPopupFrame * popupFrame = do_QueryFrame ( popup ) ; if ( popupFrame ) { return popupFrame -> GetContent ( ) ; } popup = popup -> GetParent ( ) ; } bool isChromeShell = false ; nsCOMPtr < nsISupports > cont = aPresShell -> GetPresContext ( ) -> GetContainer ( ) ; nsCOMPtr < nsIDocShellTreeItem > dsti = do_QueryInterface ( cont ) ; if ( dsti ) { int32_t type = - 1 ; isChromeShell = ( NS_SUCCEEDED ( dsti -> GetItemType ( & type ) ) && type == nsIDocShellTreeItem :: typeChrome ) ; } if ( ! isChromeShell ) { nsIContent * nonNativeAnon = mContent -> FindFirstNonNativeAnonymous ( ) ; if ( ! nonNativeAnon || nonNativeAnon -> GetParent ( ) ) { return nullptr ; } } nsPIDOMWindow * domWindow = aPresShell -> GetDocument ( ) -> GetWindow ( ) ; if ( domWindow ) { nsCOMPtr < nsIDocShellTreeItem > docShellAsItem = do_QueryInterface ( domWindow -> GetDocShell ( ) ) ; if ( docShellAsItem ) { nsCOMPtr < nsIDocShellTreeOwner > treeOwner ; docShellAsItem -> GetTreeOwner ( getter_AddRefs ( treeOwner ) ) ; if ( treeOwner ) { CallQueryInterface ( treeOwner , aWindow ) ; } } } return nullptr ; } if ( elementid . EqualsLiteral ( "_parent" ) ) { nsIContent * parent = mContent -> GetParent ( ) ; return parent ? parent -> FindFirstNonNativeAnonymous ( ) : nullptr ; } return aPresShell -> GetDocument ( ) -> GetElementById ( elementid ) ; }
xmlDumpAttributeTable ( xmlBufferPtr buf , xmlAttributeTablePtr table ) { if ( ( buf == NULL ) || ( table == NULL ) ) return ; xmlHashScan ( table , ( xmlHashScanner ) xmlDumpAttributeDeclScan , buf ) ; }
static int konepure_probe ( struct hid_device * hdev , const struct hid_device_id * id ) { int retval ; retval = hid_parse ( hdev ) ; if ( retval ) { hid_err ( hdev , "parse failed\n" ) ; goto exit ; } retval = hid_hw_start ( hdev , HID_CONNECT_DEFAULT ) ; if ( retval ) { hid_err ( hdev , "hw start failed\n" ) ; goto exit ; } retval = konepure_init_specials ( hdev ) ; if ( retval ) { hid_err ( hdev , "couldn't install mouse\n" ) ; goto exit_stop ; } return 0 ; exit_stop : hid_hw_stop ( hdev ) ; exit : return retval ; }
void Scavenger :: ScavengePage ( MemoryChunk * page ) { TRACE_EVENT0 ( TRACE_DISABLED_BY_DEFAULT ( "v8.gc" ) , "Scavenger::ScavengePage" ) ; CodePageMemoryModificationScope memory_modification_scope ( page ) ; RememberedSet < OLD_TO_NEW > :: Iterate ( page , [ this ] ( Address addr ) { return CheckAndScavengeObject ( heap_ , addr ) ; } , SlotSet :: KEEP_EMPTY_BUCKETS ) ; RememberedSet < OLD_TO_NEW > :: IterateTyped ( page , [ this ] ( SlotType type , Address host_addr , Address addr ) { return UpdateTypedSlotHelper :: UpdateTypedSlot ( heap_ , type , addr , [ this ] ( MaybeObject * * addr ) { return CheckAndScavengeObject ( heap ( ) , reinterpret_cast < Address > ( addr ) ) ; } ) ; } ) ; AddPageToSweeperIfNecessary ( page ) ; }
void CharCodeToUnicode :: addMapping ( CharCode code , char * uStr , int n , int offset ) { CharCode oldLen , i ; Unicode u ; char uHex [ 5 ] ; int j ; if ( code >= mapLen ) { oldLen = mapLen ; mapLen = ( code + 256 ) & ~ 255 ; map = ( Unicode * ) greallocn ( map , mapLen , sizeof ( Unicode ) ) ; for ( i = oldLen ; i < mapLen ; ++ i ) { map [ i ] = 0 ; } } if ( n <= 4 ) { if ( sscanf ( uStr , "%x" , & u ) != 1 ) { error ( - 1 , "Illegal entry in ToUnicode CMap" ) ; return ; } map [ code ] = u + offset ; } else { if ( sMapLen >= sMapSize ) { sMapSize = sMapSize + 16 ; sMap = ( CharCodeToUnicodeString * ) greallocn ( sMap , sMapSize , sizeof ( CharCodeToUnicodeString ) ) ; } map [ code ] = 0 ; sMap [ sMapLen ] . c = code ; sMap [ sMapLen ] . len = n / 4 ; for ( j = 0 ; j < sMap [ sMapLen ] . len && j < maxUnicodeString ; ++ j ) { strncpy ( uHex , uStr + j * 4 , 4 ) ; uHex [ 4 ] = '\0' ; if ( sscanf ( uHex , "%x" , & sMap [ sMapLen ] . u [ j ] ) != 1 ) { error ( - 1 , "Illegal entry in ToUnicode CMap" ) ; } } sMap [ sMapLen ] . u [ sMap [ sMapLen ] . len - 1 ] += offset ; ++ sMapLen ; } }
SVGFEDisplacementMapElement :: GetPrimitiveDescription ( nsSVGFilterInstance * aInstance , const IntRect & aFilterSubregion , nsTArray < RefPtr < SourceSurface > > & aInputImages ) { float scale = aInstance -> GetPrimitiveNumber ( SVGContentUtils :: XY , & mNumberAttributes [ SCALE ] ) ; uint32_t xChannel = mEnumAttributes [ CHANNEL_X ] . GetAnimValue ( ) ; uint32_t yChannel = mEnumAttributes [ CHANNEL_Y ] . GetAnimValue ( ) ; FilterPrimitiveDescription descr ( FilterPrimitiveDescription :: eDisplacementMap ) ; descr . Attributes ( ) . Set ( eDisplacementMapScale , scale ) ; descr . Attributes ( ) . Set ( eDisplacementMapXChannel , xChannel ) ; descr . Attributes ( ) . Set ( eDisplacementMapYChannel , yChannel ) ; return descr ; }
nsMultiplexInputStream :: Tell ( int64_t * aResult ) { if ( NS_FAILED ( mStatus ) ) { return mStatus ; } nsresult rv ; int64_t ret64 = 0 ; uint32_t i , last ; last = mStartedReadingCurrent ? mCurrentStream + 1 : mCurrentStream ; for ( i = 0 ; i < last ; ++ i ) { nsCOMPtr < nsISeekableStream > stream = do_QueryInterface ( mStreams [ i ] ) ; if ( NS_WARN_IF ( ! stream ) ) { return NS_ERROR_NO_INTERFACE ; } int64_t pos ; rv = TellMaybeSeek ( stream , & pos ) ; if ( NS_WARN_IF ( NS_FAILED ( rv ) ) ) { return rv ; } ret64 += pos ; } * aResult = ret64 ; return NS_OK ; }
Response V8DebuggerAgentImpl :: restartFrame ( const String16 & callFrameId , std :: unique_ptr < Array < CallFrame > > * newCallFrames , Maybe < protocol :: Runtime :: StackTrace > * asyncStackTrace , Maybe < protocol :: Runtime :: StackTraceId > * asyncStackTraceId ) { if ( ! isPaused ( ) ) return Response :: Error ( kDebuggerNotPaused ) ; InjectedScript :: CallFrameScope scope ( m_session , callFrameId ) ; Response response = scope . initialize ( ) ; if ( ! response . isSuccess ( ) ) return response ; int frameOrdinal = static_cast < int > ( scope . frameOrdinal ( ) ) ; auto it = v8 :: debug :: StackTraceIterator :: Create ( m_isolate , frameOrdinal ) ; if ( it -> Done ( ) ) { return Response :: Error ( "Could not find call frame with given id" ) ; } if ( ! it -> Restart ( ) ) { return Response :: InternalError ( ) ; } response = currentCallFrames ( newCallFrames ) ; if ( ! response . isSuccess ( ) ) return response ; * asyncStackTrace = currentAsyncStackTrace ( ) ; * asyncStackTraceId = currentExternalStackTrace ( ) ; return Response :: OK ( ) ; }
AudioBuffer :: CopyFromChannel ( const Float32Array & aDestination , uint32_t aChannelNumber , uint32_t aStartInChannel , ErrorResult & aRv ) { uint32_t length = aDestination . Length ( ) ; CheckedInt < uint32_t > end = aStartInChannel ; end += length ; if ( aChannelNumber >= NumberOfChannels ( ) || ! end . isValid ( ) || end . value ( ) > mLength ) { aRv . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; return ; } if ( ! mSharedChannels && JS_GetTypedArrayLength ( mJSChannels [ aChannelNumber ] ) != mLength ) { aRv . Throw ( NS_ERROR_DOM_INDEX_SIZE_ERR ) ; return ; } const float * sourceData = mSharedChannels ? mSharedChannels -> GetData ( aChannelNumber ) : JS_GetFloat32ArrayData ( mJSChannels [ aChannelNumber ] ) ; PodMove ( aDestination . Data ( ) , sourceData + aStartInChannel , length ) ; }
static void setup_format_params ( int track ) { int n ; int il ; int count ; int head_shift ; int track_shift ; struct fparm { unsigned char track , head , sect , size ; } * here = ( struct fparm * ) floppy_track_buffer ; raw_cmd = & default_raw_cmd ; raw_cmd -> track = track ; raw_cmd -> flags = ( FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK ) ; raw_cmd -> rate = _floppy -> rate & 0x43 ; raw_cmd -> cmd_count = NR_F ; COMMAND = FM_MODE ( _floppy , FD_FORMAT ) ; DR_SELECT = UNIT ( current_drive ) + PH_HEAD ( _floppy , format_req . head ) ; F_SIZECODE = FD_SIZECODE ( _floppy ) ; F_SECT_PER_TRACK = _floppy -> sect < < 2 > > F_SIZECODE ; F_GAP = _floppy -> fmt_gap ; F_FILL = FD_FILL_BYTE ; raw_cmd -> kernel_data = floppy_track_buffer ; raw_cmd -> length = 4 * F_SECT_PER_TRACK ; head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; track_shift = 2 * head_shift + 3 ; n = ( track_shift * format_req . track + head_shift * format_req . head ) % F_SECT_PER_TRACK ; il = 1 ; if ( _floppy -> fmt_gap < 0x22 ) il ++ ; for ( count = 0 ; count < F_SECT_PER_TRACK ; ++ count ) { here [ count ] . track = format_req . track ; here [ count ] . head = format_req . head ; here [ count ] . sect = 0 ; here [ count ] . size = F_SIZECODE ; } for ( count = 1 ; count <= F_SECT_PER_TRACK ; ++ count ) { here [ n ] . sect = count ; n = ( n + il ) % F_SECT_PER_TRACK ; if ( here [ n ] . sect ) { ++ n ; if ( n >= F_SECT_PER_TRACK ) { n -= F_SECT_PER_TRACK ; while ( here [ n ] . sect ) ++ n ; } } } if ( _floppy -> stretch & FD_SECTBASEMASK ) { for ( count = 0 ; count < F_SECT_PER_TRACK ; count ++ ) here [ count ] . sect += FD_SECTBASE ( _floppy ) - 1 ; } }
FT_Render_Glyph_Internal ( FT_Library library , FT_GlyphSlot slot , FT_Render_Mode render_mode ) { FT_Error error = FT_Err_Ok ; FT_Renderer renderer ; switch ( slot -> format ) { case FT_GLYPH_FORMAT_BITMAP : break ; default : { FT_ListNode node = NULL ; if ( slot -> format == FT_GLYPH_FORMAT_OUTLINE ) { renderer = library -> cur_renderer ; node = library -> renderers . head ; } else renderer = FT_Lookup_Renderer ( library , slot -> format , & node ) ; error = FT_ERR ( Unimplemented_Feature ) ; while ( renderer ) { error = renderer -> render ( renderer , slot , render_mode , NULL ) ; if ( ! error || FT_ERR_NEQ ( error , Cannot_Render_Glyph ) ) break ; renderer = FT_Lookup_Renderer ( library , slot -> format , & node ) ; } } } #ifdef FT_DEBUG_LEVEL_TRACE #undef  FT_COMPONENT #define FT_COMPONENT  trace_bitmap if ( ! error ) { FT_Bitmap bitmap ; FT_Error err ; FT_Bitmap_Init ( & bitmap ) ; err = FT_Bitmap_Convert ( library , & slot -> bitmap , & bitmap , 1 ) ; if ( ! err ) { MD5_CTX ctx ; unsigned char md5 [ 16 ] ; int i ; unsigned int rows = bitmap . rows ; unsigned int pitch = ( unsigned int ) bitmap . pitch ; MD5_Init ( & ctx ) ; MD5_Update ( & ctx , bitmap . buffer , rows * pitch ) ; MD5_Final ( md5 , & ctx ) ; FT_TRACE3 ( ( "MD5 checksum for %dx%d bitmap:\n" "  " , rows , pitch ) ) ; for ( i = 0 ; i < 16 ; i ++ ) FT_TRACE3 ( ( "%02X" , md5 [ i ] ) ) ; FT_TRACE3 ( ( "\n" ) ) ; } FT_Bitmap_Done ( library , & bitmap ) ; } #undef  FT_COMPONENT #define FT_COMPONENT  trace_objs #endif /* FT_DEBUG_LEVEL_TRACE */ return error ; }
RegExpMacroAssemblerPPC :: RegExpMacroAssemblerPPC ( Isolate * isolate , Zone * zone , Mode mode , int registers_to_save ) : NativeRegExpMacroAssembler ( isolate , zone ) , masm_ ( new MacroAssembler ( isolate , nullptr , kRegExpCodeSize , CodeObjectRequired :: kYes ) ) , mode_ ( mode ) , num_registers_ ( registers_to_save ) , num_saved_registers_ ( registers_to_save ) , entry_label_ ( ) , start_label_ ( ) , success_label_ ( ) , backtrack_label_ ( ) , exit_label_ ( ) , internal_failure_label_ ( ) { DCHECK_EQ ( 0 , registers_to_save % 2 ) ; __ function_descriptor ( ) ; __ b ( & entry_label_ ) ; __ bind ( & internal_failure_label_ ) ; __ li ( r3 , Operand ( FAILURE ) ) ; __ Ret ( ) ; __ bind ( & start_label_ ) ; }
long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , "Filesystem call made without initialization" ) ; for ( search = fs_searchpaths ; search ; search = search -> next ) { len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } #ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , "%s\n" , filename ) ; #endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }
static Jsi_Value * jsi_hashFmtKey ( Jsi_MapEntry * h , struct Jsi_MapOpts * opts , int flags ) { Jsi_HashEntry * hPtr = ( Jsi_HashEntry * ) h ; void * key = Jsi_HashKeyGet ( hPtr ) ; if ( opts -> keyType == JSI_KEYS_ONEWORD ) return Jsi_ValueNewNumber ( opts -> interp , ( Jsi_Number ) ( intptr_t ) key ) ; char nbuf [ 100 ] ; snprintf ( nbuf , sizeof ( nbuf ) , "%p" , key ) ; return Jsi_ValueNewStringDup ( opts -> interp , nbuf ) ; }
Object * ObjectLookupAccessor ( Isolate * isolate , Handle < Object > object , Handle < Object > key , AccessorComponent component ) { ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , object , Object :: ToObject ( isolate , object ) ) ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , key , Object :: ToPropertyKey ( isolate , key ) ) ; bool success = false ; LookupIterator it = LookupIterator :: PropertyOrElement ( isolate , object , key , & success , LookupIterator :: PROTOTYPE_CHAIN_SKIP_INTERCEPTOR ) ; DCHECK ( success ) ; for ( ; it . IsFound ( ) ; it . Next ( ) ) { switch ( it . state ( ) ) { case LookupIterator :: INTERCEPTOR : case LookupIterator :: NOT_FOUND : case LookupIterator :: TRANSITION : UNREACHABLE ( ) ; case LookupIterator :: ACCESS_CHECK : if ( it . HasAccess ( ) ) continue ; isolate -> ReportFailedAccessCheck ( it . GetHolder < JSObject > ( ) ) ; RETURN_FAILURE_IF_SCHEDULED_EXCEPTION ( isolate ) ; return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; case LookupIterator :: JSPROXY : { PropertyDescriptor desc ; Maybe < bool > found = JSProxy :: GetOwnPropertyDescriptor ( isolate , it . GetHolder < JSProxy > ( ) , it . GetName ( ) , & desc ) ; MAYBE_RETURN ( found , ReadOnlyRoots ( isolate ) . exception ( ) ) ; if ( found . FromJust ( ) ) { if ( component == ACCESSOR_GETTER && desc . has_get ( ) ) { return * desc . get ( ) ; } if ( component == ACCESSOR_SETTER && desc . has_set ( ) ) { return * desc . set ( ) ; } return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; } Handle < Object > prototype ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , prototype , JSProxy :: GetPrototype ( it . GetHolder < JSProxy > ( ) ) ) ; if ( prototype -> IsNull ( isolate ) ) { return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; } return ObjectLookupAccessor ( isolate , prototype , key , component ) ; } case LookupIterator :: INTEGER_INDEXED_EXOTIC : case LookupIterator :: DATA : return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; case LookupIterator :: ACCESSOR : { Handle < Object > maybe_pair = it . GetAccessors ( ) ; if ( maybe_pair -> IsAccessorPair ( ) ) { return * AccessorPair :: GetComponent ( isolate , Handle < AccessorPair > :: cast ( maybe_pair ) , component ) ; } } } } return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
void RegExpMacroAssemblerS390 :: CheckStackLimit ( ) { ExternalReference stack_limit = ExternalReference :: address_of_regexp_stack_limit ( isolate ( ) ) ; __ mov ( r2 , Operand ( stack_limit ) ) ; __ CmpLogicalP ( backtrack_stackpointer ( ) , MemOperand ( r2 ) ) ; SafeCall ( & stack_overflow_label_ , le ) ; }
const vpx_image_t * vpx_codec_get_preview_frame ( vpx_codec_ctx_t * ctx ) { vpx_image_t * img = NULL ; if ( ctx ) { if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else if ( ! ctx -> iface -> enc . get_preview ) ctx -> err = VPX_CODEC_INCAPABLE ; else img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ; } return img ; }
int ff_mms_asf_header_parser ( MMSContext * mms ) { uint8_t * p = mms -> asf_header ; uint8_t * end ; int flags , stream_id ; mms -> stream_num = 0 ; if ( mms -> asf_header_size < sizeof ( ff_asf_guid ) * 2 + 22 || memcmp ( p , ff_asf_header , sizeof ( ff_asf_guid ) ) ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt stream (invalid ASF header, size=%d)\n" , mms -> asf_header_size ) ; return AVERROR_INVALIDDATA ; } end = mms -> asf_header + mms -> asf_header_size ; p += sizeof ( ff_asf_guid ) + 14 ; while ( end - p >= sizeof ( ff_asf_guid ) + 8 ) { uint64_t chunksize ; if ( ! memcmp ( p , ff_asf_data_header , sizeof ( ff_asf_guid ) ) ) { chunksize = 50 ; } else { chunksize = AV_RL64 ( p + sizeof ( ff_asf_guid ) ) ; } if ( ! chunksize || chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt stream (header chunksize %"PRId64 " is invalid)\n" , chunksize ) ; return AVERROR_INVALIDDATA ; } if ( ! memcmp ( p , ff_asf_file_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p > sizeof ( ff_asf_guid ) * 2 + 68 ) { mms -> asf_packet_len = AV_RL32 ( p + sizeof ( ff_asf_guid ) * 2 + 64 ) ; if ( mms -> asf_packet_len <= 0 || mms -> asf_packet_len > sizeof ( mms -> in_buffer ) ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt stream (too large pkt_len %d)\n" , mms -> asf_packet_len ) ; return AVERROR_INVALIDDATA ; } } } else if ( ! memcmp ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; stream_id = flags & 0x7F ; if ( mms -> stream_num < MMS_MAX_STREAMS && 46 + mms -> stream_num * 6 < sizeof ( mms -> out_buffer ) ) { mms -> streams = av_fast_realloc ( mms -> streams , & mms -> nb_streams_allocated , ( mms -> stream_num + 1 ) * sizeof ( MMSStream ) ) ; if ( ! mms -> streams ) return AVERROR ( ENOMEM ) ; mms -> streams [ mms -> stream_num ] . id = stream_id ; mms -> stream_num ++ ; } else { av_log ( NULL , AV_LOG_ERROR , "Corrupt stream (too many A/V streams)\n" ) ; return AVERROR_INVALIDDATA ; } } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p >= 88 ) { int stream_count = AV_RL16 ( p + 84 ) , ext_len_count = AV_RL16 ( p + 86 ) ; uint64_t skip_bytes = 88 ; while ( stream_count -- ) { if ( end - p < skip_bytes + 4 ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt stream (next stream name length is not in the buffer)\n" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 4 + AV_RL16 ( p + skip_bytes + 2 ) ; } while ( ext_len_count -- ) { if ( end - p < skip_bytes + 22 ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt stream (next extension system info length is not in the buffer)\n" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 22 + AV_RL32 ( p + skip_bytes + 18 ) ; } if ( end - p < skip_bytes ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt stream (the last extension system info length is invalid)\n" ) ; return AVERROR_INVALIDDATA ; } if ( chunksize - skip_bytes > 24 ) chunksize = skip_bytes ; } } else if ( ! memcmp ( p , ff_asf_head1_guid , sizeof ( ff_asf_guid ) ) ) { chunksize = 46 ; } p += chunksize ; } return 0 ; }
int dns_packet_is_reply_for ( DnsPacket * p , const DnsResourceKey * key ) { int r ; assert ( p ) ; assert ( key ) ; if ( DNS_PACKET_QR ( p ) != 1 ) return 0 ; r = dns_packet_extract ( p ) ; if ( r < 0 ) return r ; if ( p -> question -> n_keys != 1 ) return 0 ; return dns_resource_key_equal ( p -> question -> keys [ 0 ] , key ) ; }
void FDK_ResetBitBuffer ( HANDLE_FDK_BITBUF hBitBuf ) { hBitBuf -> ValidBits = 0 ; hBitBuf -> ReadOffset = 0 ; hBitBuf -> WriteOffset = 0 ; hBitBuf -> BitCnt = 0 ; hBitBuf -> BitNdx = 0 ; }
void Compute ( OpKernelContext * ctx ) override { const Tensor & input = ctx -> input ( 0 ) ; OP_REQUIRES ( ctx , ( axis_ == - 1 || axis_ < input . shape ( ) . dims ( ) ) , errors :: InvalidArgument ( "Shape must be at least rank " , axis_ + 1 , " but is rank " , input . shape ( ) . dims ( ) ) ) ; const int depth = ( axis_ == - 1 ) ? 1 : input . dim_size ( axis_ ) ; Tensor input_min_tensor ; Tensor input_max_tensor ; Tensor * output = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , input . shape ( ) , & output ) ) ; if ( range_given_ ) { input_min_tensor = ctx -> input ( 1 ) ; input_max_tensor = ctx -> input ( 2 ) ; if ( axis_ == - 1 ) { auto min_val = input_min_tensor . scalar < T > ( ) ( ) ; auto max_val = input_max_tensor . scalar < T > ( ) ( ) ; OP_REQUIRES ( ctx , min_val <= max_val , errors :: InvalidArgument ( "Invalid range: input_min " , min_val , " > input_max " , max_val ) ) ; } else { OP_REQUIRES ( ctx , input_min_tensor . dim_size ( 0 ) == depth , errors :: InvalidArgument ( "input_min_tensor has incorrect size, was " , input_min_tensor . dim_size ( 0 ) , " expected " , depth , " to match dim " , axis_ , " of the input " , input_min_tensor . shape ( ) ) ) ; OP_REQUIRES ( ctx , input_max_tensor . dim_size ( 0 ) == depth , errors :: InvalidArgument ( "input_max_tensor has incorrect size, was " , input_max_tensor . dim_size ( 0 ) , " expected " , depth , " to match dim " , axis_ , " of the input " , input_max_tensor . shape ( ) ) ) ; } } else { auto range_shape = ( axis_ == - 1 ) ? TensorShape ( { } ) : TensorShape ( { depth } ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < T > :: value , range_shape , & input_min_tensor ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < T > :: value , range_shape , & input_max_tensor ) ) ; } if ( axis_ == - 1 ) { functor :: QuantizeAndDequantizeOneScaleFunctor < Device , T > f ; f ( ctx -> eigen_device < Device > ( ) , input . flat < T > ( ) , signed_input_ , num_bits_ , range_given_ , & input_min_tensor , & input_max_tensor , round_mode_ , narrow_range_ , output -> flat < T > ( ) ) ; } else { functor :: QuantizeAndDequantizePerChannelFunctor < Device , T > f ; f ( ctx -> eigen_device < Device > ( ) , input . template flat_inner_outer_dims < T , 3 > ( axis_ - 1 ) , signed_input_ , num_bits_ , range_given_ , & input_min_tensor , & input_max_tensor , round_mode_ , narrow_range_ , output -> template flat_inner_outer_dims < T , 3 > ( axis_ - 1 ) ) ; } }
void V8InspectorImpl :: resetContextGroup ( int contextGroupId ) { m_consoleStorageMap . erase ( contextGroupId ) ; m_muteExceptionsMap . erase ( contextGroupId ) ; forEachSession ( contextGroupId , [ ] ( V8InspectorSessionImpl * session ) { session -> reset ( ) ; } ) ; m_contexts . erase ( contextGroupId ) ; m_debugger -> wasmTranslation ( ) -> Clear ( ) ; }
struct tcp_conn_t * tcp_conn_accept ( struct tcp_sock_t * sock ) { struct tcp_conn_t * conn = calloc ( 1 , sizeof * conn ) ; if ( conn == NULL ) { ERR ( "Calloc for connection struct failed" ) ; goto error ; } conn -> sd = accept ( sock -> sd , NULL , NULL ) ; if ( conn -> sd < 0 ) { ERR ( "accept failed" ) ; goto error ; } return conn ; error : if ( conn != NULL ) free ( conn ) ; return NULL ; }
PreParser :: LazyParsingResult PreParser :: ParseStatementListAndLogFunction ( PreParserFormalParameters * formals , bool may_abort , bool * ok ) { PreParserStatementList body ; LazyParsingResult result = ParseStatementList ( body , Token :: RBRACE , may_abort , CHECK_OK_VALUE ( kLazyParsingComplete ) ) ; if ( result == kLazyParsingAborted ) return result ; DCHECK_EQ ( Token :: RBRACE , scanner ( ) -> peek ( ) ) ; int body_end = scanner ( ) -> peek_location ( ) . end_pos ; DCHECK_EQ ( this -> scope ( ) -> is_function_scope ( ) , formals -> is_simple ) ; log_ . LogFunction ( body_end , formals -> num_parameters ( ) , GetLastFunctionLiteralId ( ) ) ; return kLazyParsingComplete ; }
TimerThread :: ReleaseTimerInternal ( nsTimerImpl * aTimer ) { aTimer -> mArmed = false ; NS_RELEASE ( aTimer ) ; }
static RList * r_bin_wasm_get_data_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmDataEntry * ptr = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; ut32 len = sec -> payload_len ; ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; size_t n = 0 ; while ( i < len && r < count ) { if ( ! ( ptr = R_NEW0 ( RBinWasmDataEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { free ( ptr ) ; return ret ; } if ( ! ( n = consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { free ( ptr ) ; return ret ; } ptr -> offset . len = n ; if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> size , & i ) ) ) { free ( ptr ) ; return ret ; } ptr -> data = sec -> payload_data + i ; r_list_append ( ret , ptr ) ; r += 1 ; } return ret ; }
TIFFNumberOfStrips ( TIFF * tif ) { TIFFDirectory * td = & tif -> tif_dir ; uint32 nstrips ; if ( td -> td_nstrips ) return td -> td_nstrips ; nstrips = ( td -> td_rowsperstrip == ( uint32 ) - 1 ? 1 : TIFFhowmany_32 ( td -> td_imagelength , td -> td_rowsperstrip ) ) ; if ( td -> td_planarconfig == PLANARCONFIG_SEPARATE ) nstrips = _TIFFMultiply32 ( tif , nstrips , ( uint32 ) td -> td_samplesperpixel , "TIFFNumberOfStrips" ) ; return ( nstrips ) ; }
char * redisProtocolToLuaType_Aggregate ( lua_State * lua , char * reply , int atype ) { char * p = strchr ( reply + 1 , '\r' ) ; long long mbulklen ; int j = 0 ; string2ll ( reply + 1 , p - reply - 1 , & mbulklen ) ; if ( server . lua_client -> resp == 2 || atype == '*' ) { p += 2 ; if ( mbulklen == - 1 ) { lua_pushboolean ( lua , 0 ) ; return p ; } lua_newtable ( lua ) ; for ( j = 0 ; j < mbulklen ; j ++ ) { lua_pushnumber ( lua , j + 1 ) ; p = redisProtocolToLuaType ( lua , p ) ; lua_settable ( lua , - 3 ) ; } } else if ( server . lua_client -> resp == 3 ) { p += 2 ; lua_newtable ( lua ) ; lua_pushstring ( lua , atype == '%' ? "map" : "set" ) ; lua_newtable ( lua ) ; for ( j = 0 ; j < mbulklen ; j ++ ) { p = redisProtocolToLuaType ( lua , p ) ; if ( atype == '%' ) { p = redisProtocolToLuaType ( lua , p ) ; } else { lua_pushboolean ( lua , 1 ) ; } lua_settable ( lua , - 3 ) ; } lua_settable ( lua , - 3 ) ; } return p ; }
int perf_event_refresh ( struct perf_event * event , int refresh ) { if ( event -> attr . inherit || ! is_sampling_event ( event ) ) return - EINVAL ; atomic_add ( refresh , & event -> event_limit ) ; perf_event_enable ( event ) ; return 0 ; }
Reduction JSCallReducer :: ReduceObjectPrototypeGetProto ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSCall , node -> opcode ( ) ) ; Node * receiver = NodeProperties :: GetValueInput ( node , 1 ) ; return ReduceObjectGetPrototype ( node , receiver ) ; }
imgFrame :: InitForDecoder ( const nsIntSize & aImageSize , const nsIntRect & aRect , SurfaceFormat aFormat , uint8_t aPaletteDepth , bool aNonPremult ) { if ( ! AllowedImageAndFrameDimensions ( aImageSize , aRect ) ) { NS_WARNING ( "Should have legal image size" ) ; mAborted = true ; return NS_ERROR_FAILURE ; } mImageSize = aImageSize ; mFrameRect = aRect ; mFormat = aFormat ; mPaletteDepth = aPaletteDepth ; mNonPremult = aNonPremult ; if ( aPaletteDepth != 0 ) { if ( aPaletteDepth > 8 ) { NS_WARNING ( "Should have legal palette depth" ) ; NS_ERROR ( "This Depth is not supported" ) ; mAborted = true ; return NS_ERROR_FAILURE ; } mPalettedImageData = static_cast < uint8_t * > ( malloc ( PaletteDataLength ( ) + mFrameRect . Area ( ) ) ) ; if ( ! mPalettedImageData ) { NS_WARNING ( "malloc for paletted image data should succeed" ) ; } NS_ENSURE_TRUE ( mPalettedImageData , NS_ERROR_OUT_OF_MEMORY ) ; } else { MOZ_ASSERT ( ! mImageSurface , "Called imgFrame::InitForDecoder() twice?" ) ; mVBuf = AllocateBufferForImage ( mFrameRect . Size ( ) , mFormat ) ; if ( ! mVBuf ) { mAborted = true ; return NS_ERROR_OUT_OF_MEMORY ; } if ( mVBuf -> OnHeap ( ) ) { int32_t stride = VolatileSurfaceStride ( mFrameRect . Size ( ) , mFormat ) ; VolatileBufferPtr < uint8_t > ptr ( mVBuf ) ; memset ( ptr , 0 , stride * mFrameRect . height ) ; } mImageSurface = CreateLockedSurface ( mVBuf , mFrameRect . Size ( ) , mFormat ) ; if ( ! mImageSurface ) { NS_WARNING ( "Failed to create VolatileDataSourceSurface" ) ; mAborted = true ; return NS_ERROR_OUT_OF_MEMORY ; } } return NS_OK ; }
void CopyFromOMX ( const OMX_BUFFERHEADERTYPE * header ) { if ( ! mIsBackup ) { return ; } sp < ABuffer > codec = getBuffer ( header , false , true ) ; memcpy ( ( OMX_U8 * ) mMem -> pointer ( ) + header -> nOffset , codec -> data ( ) , codec -> size ( ) ) ; }
Jsi_RC Jsi_RegExpMatch ( Jsi_Interp * interp , Jsi_Value * pattern , const char * v , int * rc , Jsi_DString * dStr ) { Jsi_Regex * re ; int regexec_flags = 0 ; if ( rc ) * rc = 0 ; if ( pattern == NULL || pattern -> vt != JSI_VT_OBJECT || pattern -> d . obj -> ot != JSI_OT_REGEXP ) return Jsi_LogError ( "expected pattern" ) ; re = pattern -> d . obj -> d . robj ; regex_t * reg = & re -> reg ; regmatch_t pos = { } ; if ( dStr ) Jsi_DSInit ( dStr ) ; int r = regexec ( reg , v , 1 , & pos , regexec_flags ) ; if ( r >= REG_BADPAT ) { char buf [ 100 ] ; regerror ( r , reg , buf , sizeof ( buf ) ) ; return Jsi_LogError ( "error while matching pattern: %s" , buf ) ; } if ( r != REG_NOMATCH ) { if ( rc ) * rc = 1 ; if ( dStr && pos . rm_so >= 0 && pos . rm_eo >= 0 && pos . rm_eo >= pos . rm_so ) Jsi_DSAppendLen ( dStr , v + pos . rm_so , pos . rm_eo - pos . rm_so ) ; } return JSI_OK ; }
createSubarray ( JSContext * cx , HandleObject tarrayArg , uint32_t begin , uint32_t end ) { Rooted < TypedArrayObject * > tarray ( cx , & tarrayArg -> as < TypedArrayObject > ( ) ) ; JS_ASSERT ( begin <= tarray -> length ( ) ) ; JS_ASSERT ( end <= tarray -> length ( ) ) ; if ( ! ensureHasBuffer ( cx , tarray ) ) return nullptr ; Rooted < ArrayBufferObject * > bufobj ( cx , tarray -> buffer ( ) ) ; JS_ASSERT ( bufobj ) ; JS_ASSERT ( begin <= end ) ; uint32_t length = end - begin ; JS_ASSERT ( begin < UINT32_MAX / sizeof ( NativeType ) ) ; uint32_t arrayByteOffset = tarray -> byteOffset ( ) ; JS_ASSERT ( UINT32_MAX - begin * sizeof ( NativeType ) >= arrayByteOffset ) ; uint32_t byteOffset = arrayByteOffset + begin * sizeof ( NativeType ) ; return makeInstance ( cx , bufobj , byteOffset , length ) ; }
NS_IMETHODIMP nsPlaintextEditor :: Paste ( PRInt32 aSelectionType ) { if ( ! FireClipboardEvent ( NS_PASTE ) ) return NS_OK ; nsresult rv ; nsCOMPtr < nsIClipboard > clipboard ( do_GetService ( "@mozilla.org/widget/clipboard;1" , & rv ) ) ; if ( NS_FAILED ( rv ) ) return rv ; nsCOMPtr < nsITransferable > trans ; rv = PrepareTransferable ( getter_AddRefs ( trans ) ) ; if ( NS_SUCCEEDED ( rv ) && trans ) { if ( NS_SUCCEEDED ( clipboard -> GetData ( trans , aSelectionType ) ) && IsModifiable ( ) ) { nsCOMPtr < nsIDOMDocument > domdoc ; GetDocument ( getter_AddRefs ( domdoc ) ) ; if ( ! nsEditorHookUtils :: DoInsertionHook ( domdoc , nsnull , trans ) ) return NS_OK ; rv = InsertTextFromTransferable ( trans , nsnull , nsnull , PR_TRUE ) ; } } return rv ; }
void DecodeMemorySection ( ) { uint32_t memory_count = consume_count ( "memory count" , kV8MaxWasmMemories ) ; for ( uint32_t i = 0 ; ok ( ) && i < memory_count ; i ++ ) { if ( ! AddMemory ( module_ . get ( ) ) ) break ; uint8_t flags = validate_memory_flags ( & module_ -> has_shared_memory ) ; consume_resizable_limits ( "memory" , "pages" , FLAG_wasm_max_mem_pages , & module_ -> initial_pages , & module_ -> has_maximum_pages , kSpecMaxWasmMemoryPages , & module_ -> maximum_pages , flags ) ; } }
static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb_out ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_type = SADB_X_SPDFLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; return 0 ; }
GarbageCollector Heap :: SelectGarbageCollector ( AllocationSpace space , const char * * reason ) { if ( space != NEW_SPACE ) { isolate_ -> counters ( ) -> gc_compactor_caused_by_request ( ) -> Increment ( ) ; * reason = "GC in old space requested" ; return MARK_COMPACTOR ; } if ( FLAG_gc_global || ( FLAG_stress_compaction && ( gc_count_ & 1 ) != 0 ) ) { * reason = "GC in old space forced by flags" ; return MARK_COMPACTOR ; } if ( incremental_marking ( ) -> NeedsFinalization ( ) && AllocationLimitOvershotByLargeMargin ( ) ) { * reason = "Incremental marking needs finalization" ; return MARK_COMPACTOR ; } if ( ! CanExpandOldGeneration ( new_space_ -> TotalCapacity ( ) ) ) { isolate_ -> counters ( ) -> gc_compactor_caused_by_oldspace_exhaustion ( ) -> Increment ( ) ; * reason = "scavenge might not succeed" ; return MARK_COMPACTOR ; } * reason = nullptr ; return YoungGenerationCollector ( ) ; }
static int __kprobes perf_event_nmi_handler ( struct notifier_block * self , unsigned long cmd , void * __args ) { struct die_args * args = __args ; struct perf_sample_data data ; struct cpu_hw_events * cpuc ; struct pt_regs * regs ; int i ; if ( ! atomic_read ( & active_events ) ) return NOTIFY_DONE ; switch ( cmd ) { case DIE_NMI : break ; default : return NOTIFY_DONE ; } regs = args -> regs ; perf_sample_data_init ( & data , 0 ) ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; if ( sparc_pmu -> irq_bit ) pcr_ops -> write ( cpuc -> pcr ) ; for ( i = 0 ; i < cpuc -> n_events ; i ++ ) { struct perf_event * event = cpuc -> event [ i ] ; int idx = cpuc -> current_idx [ i ] ; struct hw_perf_event * hwc ; u64 val ; hwc = & event -> hw ; val = sparc_perf_event_update ( event , hwc , idx ) ; if ( val & ( 1ULL < < 31 ) ) continue ; data . period = event -> hw . last_period ; if ( ! sparc_perf_event_set_period ( event , hwc , idx ) ) continue ; if ( perf_event_overflow ( event , 1 , & data , regs ) ) sparc_pmu_stop ( event , 0 ) ; } return NOTIFY_STOP ; }
static void ipv6_select_ident ( struct frag_hdr * fhdr , struct rt6_info * rt ) { static u32 ip6_idents_hashrnd __read_mostly ; u32 hash , id ; net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ; hash = __ipv6_addr_jhash ( & rt -> rt6i_src . addr , hash ) ; id = ip_idents_reserve ( hash , 1 ) ; fhdr -> identification = htonl ( id ) ; }
static Jsi_RC jsi_ArrayPushCmd ( Jsi_Interp * interp , Jsi_Value * args , Jsi_Value * _this , Jsi_Value * * ret , Jsi_Func * funcPtr ) { Jsi_Obj * obj ; if ( _this -> vt != JSI_VT_OBJECT || ! Jsi_ObjIsArray ( interp , _this -> d . obj ) ) { Jsi_ValueMakeNumber ( interp , ret , 0 ) ; return JSI_OK ; } obj = _this -> d . obj ; int argc = Jsi_ValueGetLength ( interp , args ) ; int curlen = Jsi_ObjGetLength ( interp , obj ) ; if ( curlen < 0 ) { Jsi_ObjSetLength ( interp , obj , 0 ) ; } int i ; for ( i = 0 ; i < argc ; ++ i ) { Jsi_Value * ov = Jsi_ValueArrayIndex ( interp , args , i ) ; if ( ! ov ) { Jsi_LogBug ( "Arguments Error" ) ; ov = Jsi_ValueNew ( interp ) ; } Jsi_ValueInsertArray ( interp , _this , curlen + i , ov , 0 ) ; } Jsi_ValueMakeNumber ( interp , ret , Jsi_ObjGetLength ( interp , obj ) ) ; return JSI_OK ; }
static enum gro_result dev_gro_receive ( struct napi_struct * napi , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct packet_offload * ptype ; __be16 type = skb -> protocol ; struct list_head * head = & offload_base ; int same_flow ; enum gro_result ret ; int grow ; if ( ! ( skb -> dev -> features & NETIF_F_GRO ) ) goto normal ; if ( skb_is_gso ( skb ) || skb_has_frag_list ( skb ) || skb -> csum_bad ) goto normal ; gro_list_prepare ( napi , skb ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( ptype , head , list ) { if ( ptype -> type != type || ! ptype -> callbacks . gro_receive ) continue ; skb_set_network_header ( skb , skb_gro_offset ( skb ) ) ; skb_reset_mac_len ( skb ) ; NAPI_GRO_CB ( skb ) -> same_flow = 0 ; NAPI_GRO_CB ( skb ) -> flush = 0 ; NAPI_GRO_CB ( skb ) -> free = 0 ; NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ; switch ( skb -> ip_summed ) { case CHECKSUM_COMPLETE : NAPI_GRO_CB ( skb ) -> csum = skb -> csum ; NAPI_GRO_CB ( skb ) -> csum_valid = 1 ; NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; break ; case CHECKSUM_UNNECESSARY : NAPI_GRO_CB ( skb ) -> csum_cnt = skb -> csum_level + 1 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; break ; default : NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; } pp = ptype -> callbacks . gro_receive ( & napi -> gro_list , skb ) ; break ; } rcu_read_unlock ( ) ; if ( & ptype -> list == head ) goto normal ; same_flow = NAPI_GRO_CB ( skb ) -> same_flow ; ret = NAPI_GRO_CB ( skb ) -> free ? GRO_MERGED_FREE : GRO_MERGED ; if ( pp ) { struct sk_buff * nskb = * pp ; * pp = nskb -> next ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; napi -> gro_count -- ; } if ( same_flow ) goto ok ; if ( NAPI_GRO_CB ( skb ) -> flush ) goto normal ; if ( unlikely ( napi -> gro_count >= MAX_GRO_SKBS ) ) { struct sk_buff * nskb = napi -> gro_list ; while ( nskb -> next ) { pp = & nskb -> next ; nskb = * pp ; } * pp = NULL ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; } else { napi -> gro_count ++ ; } NAPI_GRO_CB ( skb ) -> count = 1 ; NAPI_GRO_CB ( skb ) -> age = jiffies ; NAPI_GRO_CB ( skb ) -> last = skb ; skb_shinfo ( skb ) -> gso_size = skb_gro_len ( skb ) ; skb -> next = napi -> gro_list ; napi -> gro_list = skb ; ret = GRO_HELD ; pull : grow = skb_gro_offset ( skb ) - skb_headlen ( skb ) ; if ( grow > 0 ) gro_pull_from_frag0 ( skb , grow ) ; ok : return ret ; normal : ret = GRO_NORMAL ; goto pull ; }
nsresult Http2Stream :: ConvertResponseHeaders ( Http2Decompressor * decompressor , nsACString & aHeadersIn , nsACString & aHeadersOut , int32_t & httpResponseCode ) { nsresult rv = decompressor -> DecodeHeaderBlock ( reinterpret_cast < const uint8_t * > ( aHeadersIn . BeginReading ( ) ) , aHeadersIn . Length ( ) , aHeadersOut , false ) ; if ( NS_FAILED ( rv ) ) { LOG3 ( ( "Http2Stream::ConvertResponseHeaders %p decode Error\n" , this ) ) ; return rv ; } nsAutoCString statusString ; decompressor -> GetStatus ( statusString ) ; if ( statusString . IsEmpty ( ) ) { LOG3 ( ( "Http2Stream::ConvertResponseHeaders %p Error - no status\n" , this ) ) ; return NS_ERROR_ILLEGAL_VALUE ; } nsresult errcode ; httpResponseCode = statusString . ToInteger ( & errcode ) ; nsAutoCString parsedStatusString ; parsedStatusString . AppendInt ( httpResponseCode ) ; if ( ! parsedStatusString . Equals ( statusString ) ) { LOG3 ( ( "Http2Stream::ConvertResposeHeaders %p status %s is not just a code" , this , statusString . BeginReading ( ) ) ) ; return NS_ERROR_ILLEGAL_VALUE ; } LOG3 ( ( "Http2Stream::ConvertResponseHeaders %p response code %d\n" , this , httpResponseCode ) ) ; if ( mIsTunnel ) { LOG3 ( ( "Http2Stream %p Tunnel Response code %d" , this , httpResponseCode ) ) ; if ( ( httpResponseCode / 100 ) > 2 ) { MapStreamToPlainText ( ) ; } if ( MapStreamToHttpConnection ( aHeadersOut , httpResponseCode ) ) { ClearTransactionsBlockedOnTunnel ( ) ; } } else if ( mIsWebsocket ) { LOG3 ( ( "Http2Stream %p websocket response code %d" , this , httpResponseCode ) ) ; if ( httpResponseCode == 200 ) { MapStreamToHttpConnection ( aHeadersOut ) ; } } if ( httpResponseCode == 421 ) { mSession -> Received421 ( mTransaction -> ConnectionInfo ( ) ) ; } if ( aHeadersIn . Length ( ) && aHeadersOut . Length ( ) ) { Telemetry :: Accumulate ( Telemetry :: SPDY_SYN_REPLY_SIZE , aHeadersIn . Length ( ) ) ; uint32_t ratio = aHeadersIn . Length ( ) * 100 / aHeadersOut . Length ( ) ; Telemetry :: Accumulate ( Telemetry :: SPDY_SYN_REPLY_RATIO , ratio ) ; } aHeadersIn . Truncate ( ) ; aHeadersOut . AppendLiteral ( "X-Firefox-Spdy: h2" ) ; aHeadersOut . AppendLiteral ( "\r\n\r\n" ) ; LOG ( ( "decoded response headers are:\n%s" , aHeadersOut . BeginReading ( ) ) ) ; if ( mIsTunnel && ! mPlainTextTunnel ) { aHeadersOut . Truncate ( ) ; LOG ( ( "Http2Stream::ConvertHeaders %p 0x%X headers removed for tunnel\n" , this , mStreamID ) ) ; } return NS_OK ; }
static INLINE void sync_write ( VP9LfSync * const lf_sync , int r , int c , const int sb_cols ) { #if CONFIG_MULTITHREAD const int nsync = lf_sync -> sync_range ; int cur ; int sig = 1 ; if ( c < sb_cols - 1 ) { cur = c ; if ( c % nsync ) sig = 0 ; } else { cur = sb_cols + nsync ; } if ( sig ) { mutex_lock ( & lf_sync -> mutex_ [ r ] ) ; lf_sync -> cur_sb_col [ r ] = cur ; pthread_cond_signal ( & lf_sync -> cond_ [ r ] ) ; pthread_mutex_unlock ( & lf_sync -> mutex_ [ r ] ) ; } #else ( void ) lf_sync ; ( void ) r ; ( void ) c ; ( void ) sb_cols ; #endif // CONFIG_MULTITHREAD }
static void GenerateTailCallToReturnedCode ( MacroAssembler * masm , Runtime :: FunctionId function_id ) { { FrameAndConstantPoolScope scope ( masm , StackFrame :: INTERNAL ) ; __ SmiTag ( r2 ) ; __ Push ( r2 , r3 , r5 , r3 ) ; __ CallRuntime ( function_id , 1 ) ; __ LoadRR ( r4 , r2 ) ; __ Pop ( r2 , r3 , r5 ) ; __ SmiUntag ( r2 ) ; } static_assert ( kJavaScriptCallCodeStartRegister == r4 , "ABI mismatch" ) ; __ AddP ( r4 , r4 , Operand ( Code :: kHeaderSize - kHeapObjectTag ) ) ; __ JumpToJSEntry ( r4 ) ; }
void BytecodeGraphBuilder :: VisitThrowReferenceErrorIfHole ( ) { Node * accumulator = environment ( ) -> LookupAccumulator ( ) ; Node * check_for_hole = NewNode ( simplified ( ) -> ReferenceEqual ( ) , accumulator , jsgraph ( ) -> TheHoleConstant ( ) ) ; Node * name = jsgraph ( ) -> Constant ( handle ( bytecode_iterator ( ) . GetConstantForIndexOperand ( 0 ) , isolate ( ) ) ) ; BuildHoleCheckAndThrow ( check_for_hole , Runtime :: kThrowReferenceError , name ) ; }
nsresult HTMLFormSubmission :: GetFromForm ( HTMLFormElement * aForm , nsGenericHTMLElement * aSubmitter , NotNull < const Encoding * > & aEncoding , HTMLFormSubmission * * aFormSubmission ) { NS_ASSERTION ( aForm -> GetComposedDoc ( ) , "Should have doc if we're building submission!" ) ; nsresult rv ; nsCOMPtr < nsIURI > actionURL ; rv = aForm -> GetActionURL ( getter_AddRefs ( actionURL ) , aSubmitter ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIContentSecurityPolicy > csp = aForm -> GetCsp ( ) ; if ( csp ) { bool permitsFormAction = true ; rv = csp -> Permits ( aForm , nullptr , actionURL , nsIContentSecurityPolicy :: FORM_ACTION_DIRECTIVE , true , & permitsFormAction ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! permitsFormAction ) { return NS_ERROR_CSP_FORM_ACTION_VIOLATION ; } } nsAutoString target ; if ( ! ( aSubmitter && aSubmitter -> GetAttr ( kNameSpaceID_None , nsGkAtoms :: formtarget , target ) ) && ! aForm -> GetAttr ( kNameSpaceID_None , nsGkAtoms :: target , target ) ) { aForm -> GetBaseTarget ( target ) ; } int32_t enctype = NS_FORM_ENCTYPE_URLENCODED ; if ( aSubmitter && aSubmitter -> HasAttr ( kNameSpaceID_None , nsGkAtoms :: formenctype ) ) { GetEnumAttr ( aSubmitter , nsGkAtoms :: formenctype , & enctype ) ; } else { GetEnumAttr ( aForm , nsGkAtoms :: enctype , & enctype ) ; } int32_t method = NS_FORM_METHOD_GET ; if ( aSubmitter && aSubmitter -> HasAttr ( kNameSpaceID_None , nsGkAtoms :: formmethod ) ) { GetEnumAttr ( aSubmitter , nsGkAtoms :: formmethod , & method ) ; } else { GetEnumAttr ( aForm , nsGkAtoms :: method , & method ) ; } if ( method == NS_FORM_METHOD_DIALOG ) { HTMLDialogElement * dialog = aForm -> FirstAncestorOfType < HTMLDialogElement > ( ) ; if ( ! dialog || ! dialog -> Open ( ) ) { return NS_ERROR_FAILURE ; } nsAutoString result ; if ( aSubmitter ) { aSubmitter -> ResultForDialogSubmit ( result ) ; } * aFormSubmission = new DialogFormSubmission ( result , actionURL , target , aEncoding , dialog ) ; return NS_OK ; } MOZ_ASSERT ( method != NS_FORM_METHOD_DIALOG ) ; if ( method == NS_FORM_METHOD_POST && enctype == NS_FORM_ENCTYPE_MULTIPART ) { * aFormSubmission = new FSMultipartFormData ( actionURL , target , aEncoding , aSubmitter ) ; } else if ( method == NS_FORM_METHOD_POST && enctype == NS_FORM_ENCTYPE_TEXTPLAIN ) { * aFormSubmission = new FSTextPlain ( actionURL , target , aEncoding , aSubmitter ) ; } else { Document * doc = aForm -> OwnerDoc ( ) ; if ( enctype == NS_FORM_ENCTYPE_MULTIPART || enctype == NS_FORM_ENCTYPE_TEXTPLAIN ) { AutoTArray < nsString , 1 > args ; nsString & enctypeStr = * args . AppendElement ( ) ; if ( aSubmitter && aSubmitter -> HasAttr ( kNameSpaceID_None , nsGkAtoms :: formenctype ) ) { aSubmitter -> GetAttr ( kNameSpaceID_None , nsGkAtoms :: formenctype , enctypeStr ) ; } else { aForm -> GetAttr ( kNameSpaceID_None , nsGkAtoms :: enctype , enctypeStr ) ; } SendJSWarning ( doc , "ForgotPostWarning" , args ) ; } * aFormSubmission = new FSURLEncoded ( actionURL , target , aEncoding , method , doc , aSubmitter ) ; } return NS_OK ; }
void BytecodeGraphBuilder :: VisitReThrow ( ) { BuildLoopExitsForFunctionExit ( bytecode_analysis ( ) -> GetInLivenessFor ( bytecode_iterator ( ) . current_offset ( ) ) ) ; Node * value = environment ( ) -> LookupAccumulator ( ) ; NewNode ( javascript ( ) -> CallRuntime ( Runtime :: kReThrow ) , value ) ; Node * control = NewNode ( common ( ) -> Throw ( ) ) ; MergeControlToLeaveFunction ( control ) ; }
static int mif_process_cmpt ( mif_hdr_t * hdr , char * buf ) { jas_tvparser_t * tvp ; mif_cmpt_t * cmpt ; int id ; cmpt = 0 ; tvp = 0 ; if ( ! ( cmpt = mif_cmpt_create ( ) ) ) { goto error ; } cmpt -> tlx = 0 ; cmpt -> tly = 0 ; cmpt -> sampperx = 0 ; cmpt -> samppery = 0 ; cmpt -> width = 0 ; cmpt -> height = 0 ; cmpt -> prec = 0 ; cmpt -> sgnd = - 1 ; cmpt -> data = 0 ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { goto error ; } while ( ! ( id = jas_tvparser_next ( tvp ) ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case MIF_TLX : cmpt -> tlx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_TLY : cmpt -> tly = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_WIDTH : cmpt -> width = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HEIGHT : cmpt -> height = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HSAMP : cmpt -> sampperx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_VSAMP : cmpt -> samppery = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_PREC : cmpt -> prec = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_SGND : cmpt -> sgnd = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_DATA : if ( ! ( cmpt -> data = jas_strdup ( jas_tvparser_getval ( tvp ) ) ) ) { return - 1 ; } break ; } } jas_tvparser_destroy ( tvp ) ; if ( ! cmpt -> sampperx || ! cmpt -> samppery ) { goto error ; } if ( mif_hdr_addcmpt ( hdr , hdr -> numcmpts , cmpt ) ) { goto error ; } return 0 ; error : if ( cmpt ) { mif_cmpt_destroy ( cmpt ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } return - 1 ; }
archive_wstring_append_from_mbs ( struct archive_wstring * dest , const char * p , size_t len ) { size_t r ; int ret_val = 0 ; size_t wcs_length = len ; size_t mbs_length = len ; const char * mbs = p ; wchar_t * wcs ; #if HAVE_MBRTOWC mbstate_t shift_state ; memset ( & shift_state , 0 , sizeof ( shift_state ) ) ; #endif if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) ) return ( - 1 ) ; wcs = dest -> s + dest -> length ; while ( * mbs && mbs_length > 0 ) { if ( wcs_length == 0 ) { dest -> length = wcs - dest -> s ; dest -> s [ dest -> length ] = L'\0' ; wcs_length = mbs_length ; if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) ) return ( - 1 ) ; wcs = dest -> s + dest -> length ; } #if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , wcs_length , & shift_state ) ; #else r = mbtowc ( wcs , mbs , wcs_length ) ; #endif if ( r == ( size_t ) - 1 || r == ( size_t ) - 2 ) { ret_val = - 1 ; if ( errno == EILSEQ ) { ++ mbs ; -- mbs_length ; continue ; } else break ; } if ( r == 0 || r > mbs_length ) break ; wcs ++ ; wcs_length -- ; mbs += r ; mbs_length -= r ; } dest -> length = wcs - dest -> s ; dest -> s [ dest -> length ] = L'\0' ; return ( ret_val ) ; }
xmlXPtrEndPointFunction ( xmlXPathParserContextPtr ctxt , int nargs ) { xmlXPathObjectPtr tmp , obj , point ; xmlLocationSetPtr newset = NULL ; xmlLocationSetPtr oldset = NULL ; CHECK_ARITY ( 1 ) ; if ( ( ctxt -> value == NULL ) || ( ( ctxt -> value -> type != XPATH_LOCATIONSET ) && ( ctxt -> value -> type != XPATH_NODESET ) ) ) XP_ERROR ( XPATH_INVALID_TYPE ) obj = valuePop ( ctxt ) ; if ( obj -> type == XPATH_NODESET ) { tmp = xmlXPtrNewLocationSetNodeSet ( obj -> nodesetval ) ; xmlXPathFreeObject ( obj ) ; if ( tmp == NULL ) XP_ERROR ( XPATH_MEMORY_ERROR ) obj = tmp ; } newset = xmlXPtrLocationSetCreate ( NULL ) ; if ( newset == NULL ) { xmlXPathFreeObject ( obj ) ; XP_ERROR ( XPATH_MEMORY_ERROR ) ; } oldset = ( xmlLocationSetPtr ) obj -> user ; if ( oldset != NULL ) { int i ; for ( i = 0 ; i < oldset -> locNr ; i ++ ) { tmp = oldset -> locTab [ i ] ; if ( tmp == NULL ) continue ; point = NULL ; switch ( tmp -> type ) { case XPATH_POINT : point = xmlXPtrNewPoint ( tmp -> user , tmp -> index ) ; break ; case XPATH_RANGE : { xmlNodePtr node = tmp -> user2 ; if ( node != NULL ) { if ( node -> type == XML_ATTRIBUTE_NODE ) { xmlXPathFreeObject ( obj ) ; xmlXPtrFreeLocationSet ( newset ) ; XP_ERROR ( XPTR_SYNTAX_ERROR ) ; } point = xmlXPtrNewPoint ( node , tmp -> index2 ) ; } else if ( tmp -> user == NULL ) { point = xmlXPtrNewPoint ( node , xmlXPtrNbLocChildren ( node ) ) ; } break ; } default : break ; } if ( point != NULL ) xmlXPtrLocationSetAdd ( newset , point ) ; } } xmlXPathFreeObject ( obj ) ; valuePush ( ctxt , xmlXPtrWrapLocationSet ( newset ) ) ; }
static int __driver_rfc4106_decrypt ( struct aead_request * req ) { u8 one_entry_in_sg = 0 ; u8 * src , * dst , * assoc ; unsigned long tempCipherLen = 0 ; __be32 counter = cpu_to_be32 ( 1 ) ; int retval = 0 ; struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; struct aesni_rfc4106_gcm_ctx * ctx = aesni_rfc4106_gcm_ctx_get ( tfm ) ; u32 key_len = ctx -> aes_key_expanded . key_length ; void * aes_ctx = & ( ctx -> aes_key_expanded ) ; unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; u8 iv_and_authTag [ 32 + AESNI_ALIGN ] ; u8 * iv = ( u8 * ) PTR_ALIGN ( ( u8 * ) iv_and_authTag , AESNI_ALIGN ) ; u8 * authTag = iv + 16 ; struct scatter_walk src_sg_walk ; struct scatter_walk assoc_sg_walk ; struct scatter_walk dst_sg_walk ; unsigned int i ; if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) ) return - EINVAL ; if ( unlikely ( auth_tag_len != 8 && auth_tag_len != 12 && auth_tag_len != 16 ) ) return - EINVAL ; if ( unlikely ( key_len != AES_KEYSIZE_128 && key_len != AES_KEYSIZE_192 && key_len != AES_KEYSIZE_256 ) ) return - EINVAL ; tempCipherLen = ( unsigned long ) ( req -> cryptlen - auth_tag_len ) ; for ( i = 0 ; i < 4 ; i ++ ) * ( iv + i ) = ctx -> nonce [ i ] ; for ( i = 0 ; i < 8 ; i ++ ) * ( iv + 4 + i ) = req -> iv [ i ] ; * ( ( __be32 * ) ( iv + 12 ) ) = counter ; if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) ) { one_entry_in_sg = 1 ; scatterwalk_start ( & src_sg_walk , req -> src ) ; scatterwalk_start ( & assoc_sg_walk , req -> assoc ) ; src = scatterwalk_map ( & src_sg_walk ) ; assoc = scatterwalk_map ( & assoc_sg_walk ) ; dst = src ; if ( unlikely ( req -> src != req -> dst ) ) { scatterwalk_start ( & dst_sg_walk , req -> dst ) ; dst = scatterwalk_map ( & dst_sg_walk ) ; } } else { src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ) ; if ( ! src ) return - ENOMEM ; assoc = ( src + req -> cryptlen + auth_tag_len ) ; scatterwalk_map_and_copy ( src , req -> src , 0 , req -> cryptlen , 0 ) ; scatterwalk_map_and_copy ( assoc , req -> assoc , 0 , req -> assoclen , 0 ) ; dst = src ; } aesni_gcm_dec_tfm ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ) ; retval = crypto_memneq ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0 ; if ( one_entry_in_sg ) { if ( unlikely ( req -> src != req -> dst ) ) { scatterwalk_unmap ( dst ) ; scatterwalk_done ( & dst_sg_walk , 0 , 0 ) ; } scatterwalk_unmap ( src ) ; scatterwalk_unmap ( assoc ) ; scatterwalk_done ( & src_sg_walk , 0 , 0 ) ; scatterwalk_done ( & assoc_sg_walk , 0 , 0 ) ; } else { scatterwalk_map_and_copy ( dst , req -> dst , 0 , req -> cryptlen , 1 ) ; kfree ( src ) ; } return retval ; }
static void update_state_rt ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , int mi_row , int mi_col , int bsize ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCK * const x = & cpi -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const struct segmentation * const seg = & cm -> seg ; * ( xd -> mi [ 0 ] ) = ctx -> mic ; if ( ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) && seg -> enabled ) { vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi , mi_row , mi_col , bsize , 1 ) ; vp9_init_plane_quantizers ( cpi , x ) ; } if ( is_inter_block ( mbmi ) ) { vp9_update_mv_count ( cm , xd ) ; if ( cm -> interp_filter == SWITCHABLE ) { const int pred_ctx = vp9_get_pred_context_switchable_interp ( xd ) ; ++ cm -> counts . switchable_interp [ pred_ctx ] [ mbmi -> interp_filter ] ; } } x -> skip = ctx -> skip ; }
PJ_DEF ( pj_status_t ) pjmedia_rtcp_fb_parse_rpsi ( const void * buf , pj_size_t length , pjmedia_rtcp_fb_rpsi * rpsi ) { pjmedia_rtcp_common * hdr = ( pjmedia_rtcp_common * ) buf ; pj_uint8_t * p ; pj_uint8_t padlen ; pj_size_t rpsi_len ; PJ_ASSERT_RETURN ( buf && rpsi , PJ_EINVAL ) ; PJ_ASSERT_RETURN ( length >= sizeof ( pjmedia_rtcp_common ) , PJ_ETOOSMALL ) ; if ( hdr -> pt != RTCP_PSFB || hdr -> count != 3 ) return PJ_ENOTFOUND ; rpsi_len = ( pj_ntohs ( ( pj_uint16_t ) hdr -> length ) - 2 ) * 4 ; if ( length < rpsi_len + 12 ) return PJ_ETOOSMALL ; p = ( pj_uint8_t * ) hdr + sizeof ( * hdr ) ; padlen = * p ++ ; rpsi -> pt = ( * p ++ & 0x7F ) ; rpsi -> rpsi_bit_len = rpsi_len * 8 - 16 - padlen ; pj_strset ( & rpsi -> rpsi , ( char * ) p , ( rpsi -> rpsi_bit_len + 7 ) / 8 ) ; return PJ_SUCCESS ; }
void smp_proc_id_info ( tSMP_CB * p_cb , tSMP_INT_DATA * p_data ) { uint8_t * p = p_data -> p_data ; SMP_TRACE_DEBUG ( "%s" , __func__ ) ; STREAM_TO_ARRAY ( p_cb -> tk , p , BT_OCTET16_LEN ) ; smp_key_distribution_by_transport ( p_cb , NULL ) ; }
TF_BUILTIN ( StringGreaterThan , StringBuiltinsAssembler ) { Node * context = Parameter ( Descriptor :: kContext ) ; Node * left = Parameter ( Descriptor :: kLeft ) ; Node * right = Parameter ( Descriptor :: kRight ) ; GenerateStringRelationalComparison ( context , left , right , Operation :: kGreaterThan ) ; }
static int __pyx_pf_17clickhouse_driver_14bufferedwriter_24CompressedBufferedWriter___init__ ( struct __pyx_obj_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter * __pyx_v_self , PyObject * __pyx_v_compressor , PyObject * __pyx_v_bufsize ) { int __pyx_r ; __Pyx_RefNannyDeclarations PyObject * __pyx_t_1 = NULL ; PyObject * __pyx_t_2 = NULL ; PyObject * __pyx_t_3 = NULL ; __Pyx_RefNannySetupContext ( "__init__" , 0 ) ; __Pyx_INCREF ( __pyx_v_compressor ) ; __Pyx_GIVEREF ( __pyx_v_compressor ) ; __Pyx_GOTREF ( __pyx_v_self -> compressor ) ; __Pyx_DECREF ( __pyx_v_self -> compressor ) ; __pyx_v_self -> compressor = __pyx_v_compressor ; __pyx_t_2 = PyTuple_New ( 2 ) ; if ( unlikely ( ! __pyx_t_2 ) ) __PYX_ERR ( 0 , 82 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_2 ) ; __Pyx_INCREF ( ( ( PyObject * ) __pyx_ptype_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter ) ) ; __Pyx_GIVEREF ( ( ( PyObject * ) __pyx_ptype_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter ) ) ; PyTuple_SET_ITEM ( __pyx_t_2 , 0 , ( ( PyObject * ) __pyx_ptype_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter ) ) ; __Pyx_INCREF ( ( ( PyObject * ) __pyx_v_self ) ) ; __Pyx_GIVEREF ( ( ( PyObject * ) __pyx_v_self ) ) ; PyTuple_SET_ITEM ( __pyx_t_2 , 1 , ( ( PyObject * ) __pyx_v_self ) ) ; __pyx_t_3 = __Pyx_PyObject_Call ( __pyx_builtin_super , __pyx_t_2 , NULL ) ; if ( unlikely ( ! __pyx_t_3 ) ) __PYX_ERR ( 0 , 82 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_3 ) ; __Pyx_DECREF ( __pyx_t_2 ) ; __pyx_t_2 = 0 ; __pyx_t_2 = __Pyx_PyObject_GetAttrStr ( __pyx_t_3 , __pyx_n_s_init ) ; if ( unlikely ( ! __pyx_t_2 ) ) __PYX_ERR ( 0 , 82 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_2 ) ; __Pyx_DECREF ( __pyx_t_3 ) ; __pyx_t_3 = 0 ; __pyx_t_3 = NULL ; if ( CYTHON_UNPACK_METHODS && likely ( PyMethod_Check ( __pyx_t_2 ) ) ) { __pyx_t_3 = PyMethod_GET_SELF ( __pyx_t_2 ) ; if ( likely ( __pyx_t_3 ) ) { PyObject * function = PyMethod_GET_FUNCTION ( __pyx_t_2 ) ; __Pyx_INCREF ( __pyx_t_3 ) ; __Pyx_INCREF ( function ) ; __Pyx_DECREF_SET ( __pyx_t_2 , function ) ; } } __pyx_t_1 = ( __pyx_t_3 ) ? __Pyx_PyObject_Call2Args ( __pyx_t_2 , __pyx_t_3 , __pyx_v_bufsize ) : __Pyx_PyObject_CallOneArg ( __pyx_t_2 , __pyx_v_bufsize ) ; __Pyx_XDECREF ( __pyx_t_3 ) ; __pyx_t_3 = 0 ; if ( unlikely ( ! __pyx_t_1 ) ) __PYX_ERR ( 0 , 82 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_1 ) ; __Pyx_DECREF ( __pyx_t_2 ) ; __pyx_t_2 = 0 ; __Pyx_DECREF ( __pyx_t_1 ) ; __pyx_t_1 = 0 ; __pyx_r = 0 ; goto __pyx_L0 ; __pyx_L1_error : ; __Pyx_XDECREF ( __pyx_t_1 ) ; __Pyx_XDECREF ( __pyx_t_2 ) ; __Pyx_XDECREF ( __pyx_t_3 ) ; __Pyx_AddTraceback ( "clickhouse_driver.bufferedwriter.CompressedBufferedWriter.__init__" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __pyx_r = - 1 ; __pyx_L0 : ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; const VpxInterface * decoder = NULL ; exec_name = argv [ 0 ] ; if ( argc != 3 ) die ( "Invalid number of arguments." ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( "Failed to open %s for reading." , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , "wb" ) ) ) die ( "Failed to open %s for writing." , argv [ 2 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( "Unknown input codec." ) ; printf ( "Using %s\n" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) die_codec ( & codec , "Failed to initialize decoder" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , "Failed to decode frame" ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) { unsigned char digest [ 16 ] ; get_image_md5 ( img , digest ) ; print_md5 ( outfile , digest ) ; fprintf ( outfile , "  img-%dx%d-%04d.i420\n" , img -> d_w , img -> d_h , ++ frame_cnt ) ; } } printf ( "Processed %d frames.\n" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , "Failed to destroy codec." ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }
GCRuntime :: findZoneEdgesForWeakMaps ( ) { for ( GCZonesIter zone ( rt ) ; ! zone . done ( ) ; zone . next ( ) ) { if ( ! WeakMapBase :: findInterZoneEdges ( zone ) ) return false ; } return true ; }
void Sweeper :: ScheduleIncrementalSweepingTask ( ) { if ( ! incremental_sweeper_pending_ ) { incremental_sweeper_pending_ = true ; IncrementalSweeperTask * task = new IncrementalSweeperTask ( heap_ -> isolate ( ) , this ) ; v8 :: Isolate * isolate = reinterpret_cast < v8 :: Isolate * > ( heap_ -> isolate ( ) ) ; V8 :: GetCurrentPlatform ( ) -> CallOnForegroundThread ( isolate , task ) ; } }
bool ID3 :: removeUnsynchronizationV2_4 ( bool iTunesHack ) { size_t oldSize = mSize ; size_t offset = 0 ; while ( mSize >= 10 && offset <= mSize - 10 ) { if ( ! memcmp ( & mData [ offset ] , "\0\0\0\0" , 4 ) ) { break ; } size_t dataSize ; if ( iTunesHack ) { dataSize = U32_AT ( & mData [ offset + 4 ] ) ; } else if ( ! ParseSyncsafeInteger ( & mData [ offset + 4 ] , & dataSize ) ) { return false ; } if ( dataSize > mSize - 10 - offset ) { return false ; } uint16_t flags = U16_AT ( & mData [ offset + 8 ] ) ; uint16_t prevFlags = flags ; if ( flags & 1 ) { if ( mSize < 14 || mSize - 14 < offset ) { return false ; } memmove ( & mData [ offset + 10 ] , & mData [ offset + 14 ] , mSize - offset - 14 ) ; mSize -= 4 ; dataSize -= 4 ; flags &= ~ 1 ; } if ( flags & 2 ) { size_t readOffset = offset + 11 ; size_t writeOffset = offset + 11 ; for ( size_t i = 0 ; i + 1 < dataSize ; ++ i ) { if ( mData [ readOffset - 1 ] == 0xff && mData [ readOffset ] == 0x00 ) { ++ readOffset ; -- mSize ; -- dataSize ; } mData [ writeOffset ++ ] = mData [ readOffset ++ ] ; } memmove ( & mData [ writeOffset ] , & mData [ readOffset ] , oldSize - readOffset ) ; flags &= ~ 2 ; } if ( flags != prevFlags || iTunesHack ) { WriteSyncsafeInteger ( & mData [ offset + 4 ] , dataSize ) ; mData [ offset + 8 ] = flags > > 8 ; mData [ offset + 9 ] = flags & 0xff ; } offset += 10 + dataSize ; } memset ( & mData [ mSize ] , 0 , oldSize - mSize ) ; return true ; }
WebGLContext :: BufferData_array ( WebGLenum target , js :: TypedArray * wa , WebGLenum usage ) { WebGLBuffer * boundBuffer = NULL ; if ( target == LOCAL_GL_ARRAY_BUFFER ) { boundBuffer = mBoundArrayBuffer ; } else if ( target == LOCAL_GL_ELEMENT_ARRAY_BUFFER ) { boundBuffer = mBoundElementArrayBuffer ; } else { return ErrorInvalidEnumInfo ( "bufferData: target" , target ) ; } if ( ! ValidateBufferUsageEnum ( usage , "bufferData: usage" ) ) return NS_OK ; if ( ! boundBuffer ) return ErrorInvalidOperation ( "BufferData: no buffer bound!" ) ; MakeContextCurrent ( ) ; boundBuffer -> SetByteLength ( wa -> byteLength ) ; if ( ! boundBuffer -> CopyDataIfElementArray ( wa -> data ) ) return ErrorOutOfMemory ( "bufferData: out of memory" ) ; boundBuffer -> InvalidateCachedMaxElements ( ) ; gl -> fBufferData ( target , wa -> byteLength , wa -> data , usage ) ; return NS_OK ; }
count_comp_fors ( struct compiling * c , const node * n ) { int n_fors = 0 ; int is_async ; count_comp_for : is_async = 0 ; n_fors ++ ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( NCH ( n ) == ( 5 + is_async ) ) { n = CHILD ( n , 4 + is_async ) ; } else { return n_fors ; } count_comp_iter : REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; if ( TYPE ( n ) == comp_for ) goto count_comp_for ; else if ( TYPE ( n ) == comp_if ) { if ( NCH ( n ) == 3 ) { n = CHILD ( n , 2 ) ; goto count_comp_iter ; } else return n_fors ; } PyErr_SetString ( PyExc_SystemError , "logic error in count_comp_fors" ) ; return - 1 ; }
PURE_ASSEMBLER_MACH_UNOP_LIST ( PURE_UNOP_DEF ) #undef PURE_UNOP_DEF #define PURE_BINOP_DEF(Name)                                 \  Node* GraphAssembler::Name(Node* left, Node* right) {      \  return graph()->NewNode(machine()->Name(), left, right); \  } PURE_ASSEMBLER_MACH_BINOP_LIST ( PURE_BINOP_DEF ) #undef PURE_BINOP_DEF #define CHECKED_BINOP_DEF(Name)                                                \  Node* GraphAssembler::Name(Node* left, Node* right) {                        \  return graph()->NewNode(machine()->Name(), left, right, current_control_); \  } CHECKED_ASSEMBLER_MACH_BINOP_LIST ( CHECKED_BINOP_DEF ) #undef CHECKED_BINOP_DEF Node * GraphAssembler :: Float64RoundDown ( Node * value ) { CHECK ( machine ( ) -> Float64RoundDown ( ) . IsSupported ( ) ) ; return graph ( ) -> NewNode ( machine ( ) -> Float64RoundDown ( ) . op ( ) , value ) ; }
Utf8ExternalStreamingStream ( ScriptCompiler :: ExternalSourceStream * source_stream , RuntimeCallStats * stats ) : current_ ( { 0 , { 0 , 0 , 0 , unibrow :: Utf8 :: State :: kAccept } } ) , source_stream_ ( source_stream ) , stats_ ( stats ) { }
MaybeHandle < BigInt > MutableBigInt :: AbsoluteAdd ( Isolate * isolate , Handle < BigInt > x , Handle < BigInt > y , bool result_sign ) { if ( x -> length ( ) < y -> length ( ) ) return AbsoluteAdd ( isolate , y , x , result_sign ) ; if ( x -> is_zero ( ) ) { DCHECK ( y -> is_zero ( ) ) ; return x ; } if ( y -> is_zero ( ) ) { return result_sign == x -> sign ( ) ? x : BigInt :: UnaryMinus ( isolate , x ) ; } Handle < MutableBigInt > result ; if ( ! New ( isolate , x -> length ( ) + 1 ) . ToHandle ( & result ) ) { return MaybeHandle < BigInt > ( ) ; } digit_t carry = 0 ; int i = 0 ; for ( ; i < y -> length ( ) ; i ++ ) { digit_t new_carry = 0 ; digit_t sum = digit_add ( x -> digit ( i ) , y -> digit ( i ) , & new_carry ) ; sum = digit_add ( sum , carry , & new_carry ) ; result -> set_digit ( i , sum ) ; carry = new_carry ; } for ( ; i < x -> length ( ) ; i ++ ) { digit_t new_carry = 0 ; digit_t sum = digit_add ( x -> digit ( i ) , carry , & new_carry ) ; result -> set_digit ( i , sum ) ; carry = new_carry ; } result -> set_digit ( i , carry ) ; result -> set_sign ( result_sign ) ; return MakeImmutable ( result ) ; }
std :: unique_ptr < IdleTask > DefaultForegroundTaskRunner :: PopTaskFromIdleQueue ( ) { base :: LockGuard < base :: Mutex > guard ( & lock_ ) ; if ( idle_task_queue_ . empty ( ) ) return { } ; std :: unique_ptr < IdleTask > task = std :: move ( idle_task_queue_ . front ( ) ) ; idle_task_queue_ . pop ( ) ; return task ; }
void VisitRootPointers ( Root root , const char * description , Object * * start , Object * * end ) override { MarkCompactCollector :: NonAtomicMarkingState * marking_state = heap_ -> mark_compact_collector ( ) -> non_atomic_marking_state ( ) ; Object * the_hole = ReadOnlyRoots ( heap_ ) . the_hole_value ( ) ; for ( Object * * p = start ; p < end ; p ++ ) { Object * o = * p ; if ( o -> IsHeapObject ( ) ) { HeapObject * heap_object = HeapObject :: cast ( o ) ; if ( marking_state -> IsWhite ( heap_object ) ) { if ( o -> IsExternalString ( ) ) { heap_ -> FinalizeExternalString ( String :: cast ( * p ) ) ; } else { DCHECK ( o -> IsThinString ( ) ) ; } * p = the_hole ; } } } }
int equalizer_set_parameter ( effect_context_t * context , effect_param_t * p , uint32_t size __unused ) { equalizer_context_t * eq_ctxt = ( equalizer_context_t * ) context ; int voffset = ( ( p -> psize - 1 ) / sizeof ( int32_t ) + 1 ) * sizeof ( int32_t ) ; void * value = p -> data + voffset ; int32_t * param_tmp = ( int32_t * ) p -> data ; int32_t param = * param_tmp ++ ; int32_t preset ; int32_t band ; int32_t level ; int i ; ALOGV ( "%s" , __func__ ) ; p -> status = 0 ; switch ( param ) { case EQ_PARAM_CUR_PRESET : ALOGV ( "EQ_PARAM_CUR_PRESET" ) ; preset = ( int32_t ) ( * ( uint16_t * ) value ) ; if ( ( preset >= equalizer_get_num_presets ( eq_ctxt ) ) || ( preset < 0 ) ) { p -> status = - EINVAL ; break ; } equalizer_set_preset ( eq_ctxt , preset ) ; break ; case EQ_PARAM_BAND_LEVEL : ALOGV ( "EQ_PARAM_BAND_LEVEL" ) ; band = * param_tmp ; level = ( int32_t ) ( * ( int16_t * ) value ) ; if ( band >= NUM_EQ_BANDS ) { p -> status = - EINVAL ; break ; } equalizer_set_band_level ( eq_ctxt , band , level ) ; break ; case EQ_PARAM_PROPERTIES : { ALOGV ( "EQ_PARAM_PROPERTIES" ) ; int16_t * prop = ( int16_t * ) value ; if ( ( int ) prop [ 0 ] >= equalizer_get_num_presets ( eq_ctxt ) ) { p -> status = - EINVAL ; break ; } if ( prop [ 0 ] >= 0 ) { equalizer_set_preset ( eq_ctxt , ( int ) prop [ 0 ] ) ; } else { if ( ( int ) prop [ 1 ] != NUM_EQ_BANDS ) { p -> status = - EINVAL ; break ; } for ( i = 0 ; i < NUM_EQ_BANDS ; i ++ ) { equalizer_set_band_level ( eq_ctxt , i , ( int ) prop [ 2 + i ] ) ; } } } break ; default : p -> status = - EINVAL ; break ; } return 0 ; }
parsetok ( struct tok_state * tok , grammar * g , int start , perrdetail * err_ret , int * flags ) { parser_state * ps ; node * n ; int started = 0 ; growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; Ta3Tokenizer_Free ( tok ) ; return NULL ; } if ( ( ps = Ta3Parser_New ( g , start ) ) == NULL ) { err_ret -> error = E_NOMEM ; Ta3Tokenizer_Free ( tok ) ; return NULL ; } #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; #endif for ( ; ; ) { char * a , * b ; int type ; size_t len ; char * str ; int col_offset ; type = Ta3Tokenizer_Get ( tok , & a , & b ) ; if ( type == ERRORTOKEN ) { err_ret -> error = tok -> done ; break ; } if ( type == ENDMARKER && started ) { type = NEWLINE ; started = 0 ; if ( tok -> indent && ! ( * flags & PyPARSE_DONT_IMPLY_DEDENT ) ) { tok -> pendin = - tok -> indent ; tok -> indent = 0 ; } } else started = 1 ; len = b - a ; str = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( str == NULL ) { err_ret -> error = E_NOMEM ; break ; } if ( len > 0 ) strncpy ( str , a , len ) ; str [ len ] = '\0' ; #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( type == NOTEQUAL ) { if ( ! ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , "!=" ) ) { PyObject_FREE ( str ) ; err_ret -> error = E_SYNTAX ; break ; } else if ( ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , "<>" ) ) { PyObject_FREE ( str ) ; err_ret -> text = "with Barry as BDFL, use '<>' " "instead of '!='" ; err_ret -> error = E_SYNTAX ; break ; } } #endif if ( a >= tok -> line_start ) col_offset = Py_SAFE_DOWNCAST ( a - tok -> line_start , intptr_t , int ) ; else col_offset = - 1 ; if ( type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( ( err_ret -> error = Ta3Parser_AddToken ( ps , ( int ) type , str , tok -> lineno , col_offset , & ( err_ret -> expected ) ) ) != E_OK ) { if ( err_ret -> error != E_DONE ) { PyObject_FREE ( str ) ; err_ret -> token = type ; } break ; } } if ( err_ret -> error == E_DONE ) { n = ps -> p_tree ; ps -> p_tree = NULL ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { Ta3Node_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores ) ; #ifndef PGEN if ( start == single_input ) { char * cur = tok -> cur ; char c = * tok -> cur ; for ( ; ; ) { while ( c == ' ' || c == '\t' || c == '\n' || c == '\014' ) c = * ++ cur ; if ( ! c ) break ; if ( c != '#' ) { err_ret -> error = E_BADSINGLE ; Ta3Node_Free ( n ) ; n = NULL ; break ; } while ( c && c != '\n' ) c = * ++ cur ; } } #endif } else n = NULL ; #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD * flags = ps -> p_flags ; #endif Ta3Parser_Delete ( ps ) ; if ( n == NULL ) { if ( tok -> done == E_EOF ) err_ret -> error = E_EOF ; err_ret -> lineno = tok -> lineno ; if ( tok -> buf != NULL ) { size_t len ; assert ( tok -> cur - tok -> buf < INT_MAX ) ; err_ret -> offset = ( int ) ( tok -> cur - tok -> buf ) ; len = tok -> inp - tok -> buf ; err_ret -> text = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( err_ret -> text != NULL ) { if ( len > 0 ) strncpy ( err_ret -> text , tok -> buf , len ) ; err_ret -> text [ len ] = '\0' ; } } } else if ( tok -> encoding != NULL ) { node * r = Ta3Node_New ( encoding_decl ) ; if ( r ) r -> n_str = PyObject_MALLOC ( strlen ( tok -> encoding ) + 1 ) ; if ( ! r || ! r -> n_str ) { err_ret -> error = E_NOMEM ; if ( r ) PyObject_FREE ( r ) ; n = NULL ; goto done ; } strcpy ( r -> n_str , tok -> encoding ) ; PyMem_FREE ( tok -> encoding ) ; tok -> encoding = NULL ; r -> n_nchildren = 1 ; r -> n_child = n ; n = r ; } done : Ta3Tokenizer_Free ( tok ) ; return n ; }
uint32_t * GetPayload ( size_t handle , uint32_t * lastpayload , uint32_t index ) { mp4object * mp4 = ( mp4object * ) handle ; if ( mp4 == NULL ) return NULL ; uint32_t * MP4buffer = NULL ; if ( index < mp4 -> indexcount && mp4 -> mediafp ) { MP4buffer = ( uint32_t * ) realloc ( ( void * ) lastpayload , mp4 -> metasizes [ index ] ) ; if ( MP4buffer ) { LONGSEEK ( mp4 -> mediafp , mp4 -> metaoffsets [ index ] , SEEK_SET ) ; fread ( MP4buffer , 1 , mp4 -> metasizes [ index ] , mp4 -> mediafp ) ; return MP4buffer ; } } return NULL ; }
long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) { if ( shmflg & SHM_RND ) addr &= ~ ( shmlba - 1 ) ; else #ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) #endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock ; } err = - EACCES ; if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) goto out_unlock ; err = security_shm_shmat ( shp , shmaddr , shmflg ) ; if ( err ) goto out_unlock ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ipc_valid_object ( & shp -> shm_perm ) ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; } path = shp -> shm_file -> f_path ; path_get ( & path ) ; shp -> shm_nattch ++ ; size = i_size_read ( d_inode ( path . dentry ) ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; err = - ENOMEM ; sfd = kzalloc ( sizeof ( * sfd ) , GFP_KERNEL ) ; if ( ! sfd ) { path_put ( & path ) ; goto out_nattch ; } file = alloc_file ( & path , f_mode , is_file_hugepages ( shp -> shm_file ) ? & shm_file_operations_huge : & shm_file_operations ) ; err = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) { kfree ( sfd ) ; path_put ( & path ) ; goto out_nattch ; } file -> private_data = sfd ; file -> f_mapping = shp -> shm_file -> f_mapping ; sfd -> id = shp -> shm_perm . id ; sfd -> ns = get_ipc_ns ( ns ) ; sfd -> file = shp -> shm_file ; sfd -> vm_ops = NULL ; err = security_mmap_file ( file , prot , flags ) ; if ( err ) goto out_fput ; if ( down_write_killable ( & current -> mm -> mmap_sem ) ) { err = - EINTR ; goto out_fput ; } if ( addr && ! ( shmflg & SHM_REMAP ) ) { err = - EINVAL ; if ( addr + size < addr ) goto invalid ; if ( find_vma_intersection ( current -> mm , addr , addr + size ) ) goto invalid ; } addr = do_mmap_pgoff ( file , addr , size , prot , flags , 0 , & populate , NULL ) ; * raddr = addr ; err = 0 ; if ( IS_ERR_VALUE ( addr ) ) err = ( long ) addr ; invalid : up_write ( & current -> mm -> mmap_sem ) ; if ( populate ) mm_populate ( addr , populate ) ; out_fput : fput ( file ) ; out_nattch : down_write ( & shm_ids ( ns ) . rwsem ) ; shp = shm_lock ( ns , shmid ) ; shp -> shm_nattch -- ; if ( shm_may_destroy ( ns , shp ) ) shm_destroy ( ns , shp ) ; else shm_unlock ( shp ) ; up_write ( & shm_ids ( ns ) . rwsem ) ; return err ; out_unlock : rcu_read_unlock ( ) ; out : return err ; }
Reduction MachineOperatorReducer :: ReduceWord64Sar ( Node * node ) { Int64BinopMatcher m ( node ) ; if ( m . right ( ) . Is ( 0 ) ) return Replace ( m . left ( ) . node ( ) ) ; if ( m . IsFoldable ( ) ) { return ReplaceInt64 ( m . left ( ) . Value ( ) > > m . right ( ) . Value ( ) ) ; } return NoChange ( ) ; }
QPDF :: read_xref ( qpdf_offset_t xref_offset ) { std :: map < int , int > free_table ; while ( xref_offset ) { char buf [ 7 ] ; memset ( buf , 0 , sizeof ( buf ) ) ; this -> m -> file -> seek ( xref_offset , SEEK_SET ) ; this -> m -> file -> read ( buf , sizeof ( buf ) - 1 ) ; if ( ( strncmp ( buf , "xref" , 4 ) == 0 ) && QUtil :: is_space ( buf [ 4 ] ) ) { QTC :: TC ( "qpdf" , "QPDF xref space" , ( ( buf [ 4 ] == '\n' ) ? 0 : ( buf [ 4 ] == '\r' ) ? 1 : ( buf [ 4 ] == ' ' ) ? 2 : 9999 ) ) ; int skip = 4 ; while ( QUtil :: is_space ( buf [ skip ] ) ) { ++ skip ; } xref_offset = read_xrefTable ( xref_offset + skip ) ; } else { xref_offset = read_xrefStream ( xref_offset ) ; } } if ( ! this -> m -> trailer . isInitialized ( ) ) { throw QPDFExc ( qpdf_e_damaged_pdf , this -> m -> file -> getName ( ) , "" , 0 , "unable to find trailer while reading xref" ) ; } int size = this -> m -> trailer . getKey ( "/Size" ) . getIntValue ( ) ; int max_obj = 0 ; if ( ! this -> m -> xref_table . empty ( ) ) { max_obj = ( * ( this -> m -> xref_table . rbegin ( ) ) ) . first . getObj ( ) ; } if ( ! this -> m -> deleted_objects . empty ( ) ) { max_obj = std :: max ( max_obj , * ( this -> m -> deleted_objects . rbegin ( ) ) ) ; } if ( size != max_obj + 1 ) { QTC :: TC ( "qpdf" , "QPDF xref size mismatch" ) ; warn ( QPDFExc ( qpdf_e_damaged_pdf , this -> m -> file -> getName ( ) , "" , 0 , std :: string ( "reported number of objects (" ) + QUtil :: int_to_string ( size ) + ") inconsistent with actual number of objects (" + QUtil :: int_to_string ( max_obj + 1 ) + ")" ) ) ; } this -> m -> deleted_objects . clear ( ) ; }
static Object * SliceHelper ( BuiltinArguments args , Isolate * isolate , const char * kMethodName , bool is_shared ) { HandleScope scope ( isolate ) ; Handle < Object > start = args . at ( 1 ) ; Handle < Object > end = args . atOrUndefined ( isolate , 2 ) ; CHECK_RECEIVER ( JSArrayBuffer , array_buffer , kMethodName ) ; CHECK_SHARED ( is_shared , array_buffer , kMethodName ) ; if ( ! is_shared && array_buffer -> was_neutered ( ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( MessageTemplate :: kDetachedOperation , isolate -> factory ( ) -> NewStringFromAsciiChecked ( kMethodName ) ) ) ; } double const len = array_buffer -> byte_length ( ) -> Number ( ) ; Handle < Object > relative_start ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , relative_start , Object :: ToInteger ( isolate , start ) ) ; double const first = ( relative_start -> Number ( ) < 0 ) ? Max ( len + relative_start -> Number ( ) , 0.0 ) : Min ( relative_start -> Number ( ) , len ) ; Handle < Object > first_obj = isolate -> factory ( ) -> NewNumber ( first ) ; double relative_end ; if ( end -> IsUndefined ( isolate ) ) { relative_end = len ; } else { Handle < Object > relative_end_obj ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , relative_end_obj , Object :: ToInteger ( isolate , end ) ) ; relative_end = relative_end_obj -> Number ( ) ; } double const final_ = ( relative_end < 0 ) ? Max ( len + relative_end , 0.0 ) : Min ( relative_end , len ) ; double const new_len = Max ( final_ - first , 0.0 ) ; Handle < Object > new_len_obj = isolate -> factory ( ) -> NewNumber ( new_len ) ; Handle < JSFunction > constructor_fun = is_shared ? isolate -> shared_array_buffer_fun ( ) : isolate -> array_buffer_fun ( ) ; Handle < Object > ctor ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , ctor , Object :: SpeciesConstructor ( isolate , Handle < JSReceiver > :: cast ( args . receiver ( ) ) , constructor_fun ) ) ; Handle < JSReceiver > new_ ; { const int argc = 1 ; ScopedVector < Handle < Object > > argv ( argc ) ; argv [ 0 ] = new_len_obj ; Handle < Object > new_obj ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , new_obj , Execution :: New ( isolate , ctor , argc , argv . start ( ) ) ) ; new_ = Handle < JSReceiver > :: cast ( new_obj ) ; } if ( ! new_ -> IsJSArrayBuffer ( ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( MessageTemplate :: kIncompatibleMethodReceiver , isolate -> factory ( ) -> NewStringFromAsciiChecked ( kMethodName ) , new_ ) ) ; } Handle < JSArrayBuffer > new_array_buffer = Handle < JSArrayBuffer > :: cast ( new_ ) ; CHECK_SHARED ( is_shared , new_array_buffer , kMethodName ) ; if ( ! is_shared && new_array_buffer -> was_neutered ( ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( MessageTemplate :: kDetachedOperation , isolate -> factory ( ) -> NewStringFromAsciiChecked ( kMethodName ) ) ) ; } if ( ! is_shared && new_ -> SameValue ( * args . receiver ( ) ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( MessageTemplate :: kArrayBufferSpeciesThis ) ) ; } if ( is_shared && new_array_buffer -> backing_store ( ) == array_buffer -> backing_store ( ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( MessageTemplate :: kSharedArrayBufferSpeciesThis ) ) ; } if ( new_array_buffer -> byte_length ( ) -> Number ( ) < new_len ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( is_shared ? MessageTemplate :: kSharedArrayBufferTooShort : MessageTemplate :: kArrayBufferTooShort ) ) ; } if ( ! is_shared && array_buffer -> was_neutered ( ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( MessageTemplate :: kDetachedOperation , isolate -> factory ( ) -> NewStringFromAsciiChecked ( kMethodName ) ) ) ; } size_t first_size = 0 , new_len_size = 0 ; CHECK ( TryNumberToSize ( * first_obj , & first_size ) ) ; CHECK ( TryNumberToSize ( * new_len_obj , & new_len_size ) ) ; DCHECK ( NumberToSize ( new_array_buffer -> byte_length ( ) ) >= new_len_size ) ; if ( new_len_size != 0 ) { size_t from_byte_length = NumberToSize ( array_buffer -> byte_length ( ) ) ; USE ( from_byte_length ) ; DCHECK ( first_size <= from_byte_length ) ; DCHECK ( from_byte_length - first_size >= new_len_size ) ; uint8_t * from_data = reinterpret_cast < uint8_t * > ( array_buffer -> backing_store ( ) ) ; uint8_t * to_data = reinterpret_cast < uint8_t * > ( new_array_buffer -> backing_store ( ) ) ; CopyBytes ( to_data , from_data + first_size , new_len_size ) ; } return * new_ ; }
GF_Err SetupWriters ( MovieWriter * mw , GF_List * writers , u8 interleaving ) { u32 i , trackCount ; TrackWriter * writer ; GF_TrackBox * trak ; GF_ISOFile * movie = mw -> movie ; mw -> total_samples = mw -> nb_done = 0 ; if ( ! movie -> moov ) return GF_OK ; trackCount = gf_list_count ( movie -> moov -> trackList ) ; for ( i = 0 ; i < trackCount ; i ++ ) { trak = gf_isom_get_track ( movie -> moov , i + 1 ) ; GF_SAFEALLOC ( writer , TrackWriter ) ; if ( ! writer ) goto exit ; writer -> sampleNumber = 1 ; writer -> mdia = trak -> Media ; writer -> stbl = trak -> Media -> information -> sampleTable ; writer -> timeScale = trak -> Media -> mediaHeader -> timeScale ; writer -> all_dref_mode = Media_SelfContainedType ( writer -> mdia ) ; if ( trak -> sample_encryption ) writer -> prevent_dispatch = GF_TRUE ; writer -> isDone = 0 ; writer -> DTSprev = 0 ; writer -> chunkDur = 0 ; writer -> chunkSize = 0 ; writer -> constant_size = writer -> constant_dur = 0 ; if ( writer -> stbl -> SampleSize -> sampleSize ) writer -> constant_size = writer -> stbl -> SampleSize -> sampleSize ; if ( writer -> stbl -> TimeToSample -> nb_entries == 1 ) { writer -> constant_dur = writer -> stbl -> TimeToSample -> entries [ 0 ] . sampleDelta ; if ( writer -> constant_dur > 1 ) writer -> constant_dur = 0 ; } if ( ! writer -> constant_dur || ! writer -> constant_size || ( writer -> constant_size >= 10 ) ) writer -> constant_size = writer -> constant_dur = 0 ; writer -> stsc = ( GF_SampleToChunkBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_STSC ) ; if ( ! writer -> stsc ) return GF_OUT_OF_MEM ; if ( writer -> stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { writer -> stco = gf_isom_box_new ( GF_ISOM_BOX_TYPE_STCO ) ; } else { writer -> stco = gf_isom_box_new ( GF_ISOM_BOX_TYPE_CO64 ) ; } if ( ! writer -> stco ) return GF_OUT_OF_MEM ; if ( interleaving ) writer -> stbl -> MaxSamplePerChunk = 0 ; if ( Media_IsSelfContained ( writer -> mdia , 1 ) ) mw -> total_samples += writer -> stbl -> SampleSize -> sampleCount ; if ( movie -> storageMode != GF_ISOM_STORE_INTERLEAVED ) { gf_list_add ( writers , writer ) ; } else { if ( writer -> mdia -> information -> InfoHeader && writer -> mdia -> information -> InfoHeader -> type == GF_ISOM_BOX_TYPE_SMHD ) { gf_list_add ( writers , writer ) ; } else { gf_list_insert ( writers , writer , 0 ) ; } } if ( movie -> sample_groups_in_traf && trak -> Media -> information -> sampleTable ) { gf_isom_box_array_del_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) ; trak -> Media -> information -> sampleTable -> sampleGroupsDescription = NULL ; } } return GF_OK ; exit : CleanWriters ( writers ) ; return GF_OUT_OF_MEM ; }
lsquic_qeh_settings ( struct qpack_enc_hdl * qeh , unsigned max_table_size , unsigned dyn_table_size , unsigned max_risked_streams , int server ) { enum lsqpack_enc_opts enc_opts ; assert ( qeh -> qeh_flags & QEH_INITIALIZED ) ; if ( qeh -> qeh_flags & QEH_HAVE_SETTINGS ) { LSQ_WARN ( "settings already set" ) ; return - 1 ; } enc_opts = LSQPACK_ENC_OPT_STAGE_2 | ( server ? LSQPACK_ENC_OPT_SERVER : 0 ) ; qeh -> qeh_tsu_sz = sizeof ( qeh -> qeh_tsu_buf ) ; if ( 0 != lsqpack_enc_init ( & qeh -> qeh_encoder , ( void * ) qeh -> qeh_conn , max_table_size , dyn_table_size , max_risked_streams , enc_opts , qeh -> qeh_tsu_buf , & qeh -> qeh_tsu_sz ) ) { LSQ_INFO ( "could not initialize QPACK encoder" ) ; return - 1 ; } LSQ_DEBUG ( "%zu-byte post-init TSU" , qeh -> qeh_tsu_sz ) ; qeh -> qeh_flags |= QEH_HAVE_SETTINGS ; qeh -> qeh_max_prefix_size = lsqpack_enc_header_block_prefix_size ( & qeh -> qeh_encoder ) ; LSQ_DEBUG ( "have settings: max table size=%u; dyn table size=%u; max risked " "streams=%u" , max_table_size , dyn_table_size , max_risked_streams ) ; if ( qeh -> qeh_enc_sm_out ) qeh_begin_out ( qeh ) ; return 0 ; }
static void prefetch_table ( const volatile byte * tab , size_t len ) { size_t i ; for ( i = 0 ; i < len ; i += 8 * 32 ) { ( void ) tab [ i + 0 * 32 ] ; ( void ) tab [ i + 1 * 32 ] ; ( void ) tab [ i + 2 * 32 ] ; ( void ) tab [ i + 3 * 32 ] ; ( void ) tab [ i + 4 * 32 ] ; ( void ) tab [ i + 5 * 32 ] ; ( void ) tab [ i + 6 * 32 ] ; ( void ) tab [ i + 7 * 32 ] ; }
bool handleUnaliasedAccess ( JSContext * cx , Handle < DebugScopeObject * > debugScope , Handle < ScopeObject * > scope , jsid id , Action action , MutableHandleValue vp , AccessResult * accessResult ) const { MOZ_ASSERT ( & debugScope -> scope ( ) == scope ) ; MOZ_ASSERT_IF ( action == SET , ! debugScope -> isOptimizedOut ( ) ) ; * accessResult = ACCESS_GENERIC ; LiveScopeVal * maybeLiveScope = DebugScopes :: hasLiveScope ( * scope ) ; if ( scope -> is < CallObject > ( ) && ! scope -> as < CallObject > ( ) . isForEval ( ) ) { CallObject & callobj = scope -> as < CallObject > ( ) ; RootedScript script ( cx , callobj . callee ( ) . nonLazyScript ( ) ) ; if ( ! script -> ensureHasTypes ( cx ) || ! script -> ensureHasAnalyzedArgsUsage ( cx ) ) return false ; Bindings & bindings = script -> bindings ; BindingIter bi ( script ) ; while ( bi && NameToId ( bi -> name ( ) ) != id ) bi ++ ; if ( ! bi ) return true ; if ( bi -> kind ( ) == Binding :: VARIABLE || bi -> kind ( ) == Binding :: CONSTANT ) { if ( script -> bindingIsAliased ( bi ) ) return true ; uint32_t i = bi . frameIndex ( ) ; if ( maybeLiveScope ) { AbstractFramePtr frame = maybeLiveScope -> frame ( ) ; if ( action == GET ) vp . set ( frame . unaliasedLocal ( i ) ) ; else frame . unaliasedLocal ( i ) = vp ; } else if ( NativeObject * snapshot = debugScope -> maybeSnapshot ( ) ) { if ( action == GET ) vp . set ( snapshot -> getDenseElement ( bindings . numArgs ( ) + i ) ) ; else snapshot -> setDenseElement ( bindings . numArgs ( ) + i , vp ) ; } else { if ( action == GET ) { * accessResult = ACCESS_LOST ; return true ; } } } else { MOZ_ASSERT ( bi -> kind ( ) == Binding :: ARGUMENT ) ; unsigned i = bi . argIndex ( ) ; if ( script -> formalIsAliased ( i ) ) return true ; if ( maybeLiveScope ) { AbstractFramePtr frame = maybeLiveScope -> frame ( ) ; if ( script -> argsObjAliasesFormals ( ) && frame . hasArgsObj ( ) ) { if ( action == GET ) vp . set ( frame . argsObj ( ) . arg ( i ) ) ; else frame . argsObj ( ) . setArg ( i , vp ) ; } else { if ( action == GET ) vp . set ( frame . unaliasedFormal ( i , DONT_CHECK_ALIASING ) ) ; else frame . unaliasedFormal ( i , DONT_CHECK_ALIASING ) = vp ; } } else if ( NativeObject * snapshot = debugScope -> maybeSnapshot ( ) ) { if ( action == GET ) vp . set ( snapshot -> getDenseElement ( i ) ) ; else snapshot -> setDenseElement ( i , vp ) ; } else { if ( action == GET ) { * accessResult = ACCESS_LOST ; return true ; } } if ( action == SET ) TypeScript :: SetArgument ( cx , script , i , vp ) ; } * accessResult = ACCESS_UNALIASED ; return true ; } if ( scope -> is < ClonedBlockObject > ( ) ) { Rooted < ClonedBlockObject * > block ( cx , & scope -> as < ClonedBlockObject > ( ) ) ; Shape * shape = block -> lastProperty ( ) -> search ( cx , id ) ; if ( ! shape ) return true ; unsigned i = block -> staticBlock ( ) . shapeToIndex ( * shape ) ; if ( block -> staticBlock ( ) . isAliased ( i ) ) return true ; if ( maybeLiveScope ) { AbstractFramePtr frame = maybeLiveScope -> frame ( ) ; uint32_t local = block -> staticBlock ( ) . blockIndexToLocalIndex ( i ) ; MOZ_ASSERT ( local < frame . script ( ) -> nfixed ( ) ) ; if ( action == GET ) vp . set ( frame . unaliasedLocal ( local ) ) ; else frame . unaliasedLocal ( local ) = vp ; } else { if ( action == GET ) vp . set ( block -> var ( i , DONT_CHECK_ALIASING ) ) ; else block -> setVar ( i , vp , DONT_CHECK_ALIASING ) ; } * accessResult = ACCESS_UNALIASED ; return true ; } MOZ_ASSERT ( scope -> is < DeclEnvObject > ( ) || scope -> is < DynamicWithObject > ( ) || scope -> as < CallObject > ( ) . isForEval ( ) ) ; return true ; }
void SoftAVC :: drainAllOutputBuffers ( bool eos ) { List < BufferInfo * > & outQueue = getPortQueue ( kOutputPortIndex ) ; H264SwDecPicture decodedPicture ; if ( mHeadersDecoded ) { while ( ! outQueue . empty ( ) && H264SWDEC_PIC_RDY == H264SwDecNextPicture ( mHandle , & decodedPicture , eos ) ) { int32_t picId = decodedPicture . picId ; uint8_t * data = ( uint8_t * ) decodedPicture . pOutputPicture ; drainOneOutputBuffer ( picId , data ) ; } } if ( ! eos ) { return ; } while ( ! outQueue . empty ( ) ) { BufferInfo * outInfo = * outQueue . begin ( ) ; outQueue . erase ( outQueue . begin ( ) ) ; OMX_BUFFERHEADERTYPE * outHeader = outInfo -> mHeader ; outHeader -> nTimeStamp = 0 ; outHeader -> nFilledLen = 0 ; outHeader -> nFlags = OMX_BUFFERFLAG_EOS ; outInfo -> mOwnedByUs = false ; notifyFillBufferDone ( outHeader ) ; mEOSStatus = OUTPUT_FRAMES_FLUSHED ; } }
IGNITION_HANDLER ( ThrowSuperNotCalledIfHole , InterpreterAssembler ) { Node * value = GetAccumulator ( ) ; Label throw_error ( this , Label :: kDeferred ) ; GotoIf ( WordEqual ( value , TheHoleConstant ( ) ) , & throw_error ) ; Dispatch ( ) ; BIND ( & throw_error ) ; { CallRuntime ( Runtime :: kThrowSuperNotCalled , GetContext ( ) ) ; Abort ( AbortReason :: kUnexpectedReturnFromThrow ) ; } }
write_vpAg_chunk ( png_structp write_ptr ) { png_byte vpAg [ 5 ] = { 118 , 112 , 65 , 103 , '\0' } ; png_byte vpag_chunk_data [ 9 ] ; if ( verbose ) fprintf ( STDERR , " vpAg = %lu x %lu, units = %d\n" , ( unsigned long ) user_chunk_data . vpAg_width , ( unsigned long ) user_chunk_data . vpAg_height , user_chunk_data . vpAg_units ) ; png_save_uint_32 ( vpag_chunk_data , user_chunk_data . vpAg_width ) ; png_save_uint_32 ( vpag_chunk_data + 4 , user_chunk_data . vpAg_height ) ; vpag_chunk_data [ 8 ] = user_chunk_data . vpAg_units ; png_write_chunk ( write_ptr , vpAg , vpag_chunk_data , 9 ) ; }
ProcessReplaceRequest ( ) { #ifdef XP_MACOSX NS_tchar destDir [ MAXPATHLEN ] ; NS_tsnprintf ( destDir , sizeof ( destDir ) / sizeof ( destDir [ 0 ] ) , NS_T ( "%s/Contents" ) , gInstallDirPath ) ; #elif XP_WIN NS_tchar destDir [ MAXPATHLEN ] ; if ( ! GetLongPathNameW ( gInstallDirPath , destDir , sizeof ( destDir ) / sizeof ( destDir [ 0 ] ) ) ) { return NO_INSTALLDIR_ERROR ; } #else NS_tchar * destDir = gInstallDirPath ; #endif NS_tchar tmpDir [ MAXPATHLEN ] ; NS_tsnprintf ( tmpDir , sizeof ( tmpDir ) / sizeof ( tmpDir [ 0 ] ) , NS_T ( "%s.bak" ) , destDir ) ; NS_tchar newDir [ MAXPATHLEN ] ; NS_tsnprintf ( newDir , sizeof ( newDir ) / sizeof ( newDir [ 0 ] ) , #ifdef XP_MACOSX NS_T ( "%s/Contents" ) , gWorkingDirPath ) ; #else NS_T ( "%s.bak/updated" ) , gInstallDirPath ) ; #endif ensure_remove_recursive ( tmpDir ) ; LOG ( ( "Begin moving destDir (" LOG_S ") to tmpDir (" LOG_S ")" , destDir , tmpDir ) ) ; int rv = rename_file ( destDir , tmpDir , true ) ; #ifdef XP_WIN const int max_retries = 10 ; int retries = 0 ; while ( rv == WRITE_ERROR && ( retries ++ < max_retries ) ) { LOG ( ( "PerformReplaceRequest: destDir rename attempt %d failed. " "File: " LOG_S ". Last error: %d, err: %d" , retries , destDir , GetLastError ( ) , rv ) ) ; Sleep ( 100 ) ; rv = rename_file ( destDir , tmpDir , true ) ; } #endif if ( rv ) { LOG ( ( "Moving destDir to tmpDir failed, err: %d" , rv ) ) ; return rv ; } LOG ( ( "Begin moving newDir (" LOG_S ") to destDir (" LOG_S ")" , newDir , destDir ) ) ; rv = rename_file ( newDir , destDir , true ) ; #ifdef XP_MACOSX if ( rv ) { LOG ( ( "Moving failed. Begin copying newDir (" LOG_S ") to destDir (" LOG_S ")" , newDir , destDir ) ) ; copy_recursive_skiplist < 0 > skiplist ; rv = ensure_copy_recursive ( newDir , destDir , skiplist ) ; } #endif if ( rv ) { LOG ( ( "Moving newDir to destDir failed, err: %d" , rv ) ) ; LOG ( ( "Now, try to move tmpDir back to destDir" ) ) ; ensure_remove_recursive ( destDir ) ; int rv2 = rename_file ( tmpDir , destDir , true ) ; if ( rv2 ) { LOG ( ( "Moving tmpDir back to destDir failed, err: %d" , rv2 ) ) ; } return rv ; } LOG ( ( "Now, remove the tmpDir" ) ) ; rv = ensure_remove_recursive ( tmpDir ) ; if ( rv ) { LOG ( ( "Removing tmpDir failed, err: %d" , rv ) ) ; #ifdef XP_WIN if ( MoveFileExW ( tmpDir , nullptr , MOVEFILE_DELAY_UNTIL_REBOOT ) ) { LOG ( ( "tmpDir will be removed on OS reboot: " LOG_S , tmpDir ) ) ; } else { LOG ( ( "Failed to schedule OS reboot removal of directory: " LOG_S , tmpDir ) ) ; } #endif } #ifdef XP_MACOSX NS_tchar updatedAppDir [ MAXPATHLEN ] ; NS_tsnprintf ( updatedAppDir , sizeof ( updatedAppDir ) / sizeof ( updatedAppDir [ 0 ] ) , NS_T ( "%s/Updated.app" ) , gPatchDirPath ) ; ensure_remove_recursive ( updatedAppDir ) ; #endif gSucceeded = true ; return 0 ; }
void Compute ( OpKernelContext * const context ) override { const Tensor * node_id_range_t ; OP_REQUIRES_OK ( context , context -> input ( "node_id_range" , & node_id_range_t ) ) ; const auto node_id_range = node_id_range_t -> vec < int32 > ( ) ; const int32_t node_id_first = node_id_range ( 0 ) ; const int32_t node_id_last = node_id_range ( 1 ) ; const Tensor * stats_summary_indices_t ; OP_REQUIRES_OK ( context , context -> input ( "stats_summary_indices" , & stats_summary_indices_t ) ) ; const auto stats_summary_indices = stats_summary_indices_t -> matrix < int32 > ( ) ; const int32_t num_sparse_entries = stats_summary_indices_t -> dim_size ( 0 ) ; const Tensor * stats_summary_values_t ; OP_REQUIRES_OK ( context , context -> input ( "stats_summary_values" , & stats_summary_values_t ) ) ; const auto stats_summary_values = stats_summary_values_t -> vec < float > ( ) ; const Tensor * stats_summary_shape_t ; OP_REQUIRES_OK ( context , context -> input ( "stats_summary_shape" , & stats_summary_shape_t ) ) ; const auto stats_summary_shape = stats_summary_shape_t -> vec < int32 > ( ) ; const int32_t num_buckets = stats_summary_shape ( 2 ) - 1 ; const int32_t stats_dims = stats_summary_shape ( 3 ) ; const Tensor * l1_t ; OP_REQUIRES_OK ( context , context -> input ( "l1" , & l1_t ) ) ; const auto l1 = l1_t -> scalar < float > ( ) ( ) ; const Tensor * l2_t ; OP_REQUIRES_OK ( context , context -> input ( "l2" , & l2_t ) ) ; const auto l2 = l2_t -> scalar < float > ( ) ( ) ; const Tensor * tree_complexity_t ; OP_REQUIRES_OK ( context , context -> input ( "tree_complexity" , & tree_complexity_t ) ) ; const auto tree_complexity = tree_complexity_t -> scalar < float > ( ) ( ) ; const Tensor * min_node_weight_t ; OP_REQUIRES_OK ( context , context -> input ( "min_node_weight" , & min_node_weight_t ) ) ; const auto min_node_weight = min_node_weight_t -> scalar < float > ( ) ( ) ; std :: vector < int32 > output_node_ids ; std :: vector < float > output_gains ; std :: vector < int32 > output_feature_dimensions ; std :: vector < int32 > output_thresholds ; std :: vector < float > output_left_node_contribs ; std :: vector < float > output_right_node_contribs ; std :: vector < string > output_split_types ; FeatureMap f_map ; int32_t previous_node_id = - 1 ; for ( int idx = 0 ; idx < num_sparse_entries ; ++ idx ) { int32_t node_id = stats_summary_indices ( idx , 0 ) ; if ( node_id != previous_node_id ) { process_node ( f_map , & output_node_ids , & output_gains , & output_feature_dimensions , & output_thresholds , & output_left_node_contribs , & output_right_node_contribs , & output_split_types , previous_node_id , min_node_weight , l1 , l2 , num_buckets ) ; f_map . clear ( ) ; } previous_node_id = node_id ; DCHECK_LE ( node_id_first , node_id ) ; DCHECK_LT ( node_id , node_id_last ) ; const int32_t feature_dim = stats_summary_indices ( idx , 1 ) ; const int32_t bucket_id = stats_summary_indices ( idx , 2 ) ; const int32_t stat_dim = stats_summary_indices ( idx , 3 ) ; OP_REQUIRES ( context , stat_dim < stats_dims , errors :: InvalidArgument ( "Stat dim, the sum of logits dim and hessian dim in " "stats_summary_indices, cannot be greater than stats " "dims, the last value in stats_summary_shape, which was " , stats_dims , ". At index (" , idx , ", 4), stats_summary_indices contains value " , stat_dim ) ) ; std :: pair < FeatureMapIterator , bool > const & f_insert_result = f_map . insert ( FeatureMapIterator :: value_type ( feature_dim , BucketMap ( ) ) ) ; auto & b_map = f_insert_result . first -> second ; std :: pair < BucketMapIterator , bool > const & b_insert_result = b_map . insert ( BucketMapIterator :: value_type ( bucket_id , std :: vector < float > ( stats_dims ) ) ) ; auto & stats = b_insert_result . first -> second ; stats [ stat_dim ] = stats_summary_values ( idx ) ; } process_node ( f_map , & output_node_ids , & output_gains , & output_feature_dimensions , & output_thresholds , & output_left_node_contribs , & output_right_node_contribs , & output_split_types , previous_node_id , min_node_weight , l1 , l2 , num_buckets ) ; const int num_nodes = output_node_ids . size ( ) ; Tensor * output_node_ids_t = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( "node_ids" , { num_nodes } , & output_node_ids_t ) ) ; auto output_node_ids_vec = output_node_ids_t -> vec < int32 > ( ) ; Tensor * output_gains_t ; OP_REQUIRES_OK ( context , context -> allocate_output ( "gains" , { num_nodes } , & output_gains_t ) ) ; auto output_gains_vec = output_gains_t -> vec < float > ( ) ; Tensor * output_feature_dimension_t ; OP_REQUIRES_OK ( context , context -> allocate_output ( "feature_dimensions" , { num_nodes } , & output_feature_dimension_t ) ) ; auto output_feature_dimensions_vec = output_feature_dimension_t -> vec < int32 > ( ) ; Tensor * output_thresholds_t ; OP_REQUIRES_OK ( context , context -> allocate_output ( "thresholds" , { num_nodes } , & output_thresholds_t ) ) ; auto output_thresholds_vec = output_thresholds_t -> vec < int32 > ( ) ; Tensor * output_left_node_contribs_t ; OP_REQUIRES_OK ( context , context -> allocate_output ( "left_node_contribs" , { num_nodes , 1 } , & output_left_node_contribs_t ) ) ; auto output_left_node_contribs_matrix = output_left_node_contribs_t -> matrix < float > ( ) ; Tensor * output_right_node_contribs_t ; OP_REQUIRES_OK ( context , context -> allocate_output ( "right_node_contribs" , { num_nodes , 1 } , & output_right_node_contribs_t ) ) ; auto output_right_node_contribs_matrix = output_right_node_contribs_t -> matrix < float > ( ) ; Tensor * output_split_types_t ; OP_REQUIRES_OK ( context , context -> allocate_output ( "split_with_default_directions" , { num_nodes } , & output_split_types_t ) ) ; auto output_split_types_vec = output_split_types_t -> vec < tstring > ( ) ; for ( int i = 0 ; i < num_nodes ; ++ i ) { output_node_ids_vec ( i ) = output_node_ids [ i ] ; output_gains_vec ( i ) = output_gains [ i ] - tree_complexity ; output_feature_dimensions_vec ( i ) = output_feature_dimensions [ i ] ; output_thresholds_vec ( i ) = output_thresholds [ i ] ; output_left_node_contribs_matrix ( i , 0 ) = output_left_node_contribs [ i ] ; output_right_node_contribs_matrix ( i , 0 ) = output_right_node_contribs [ i ] ; output_split_types_vec ( i ) = output_split_types [ i ] ; } }
std :: string FunctionPointerType :: MangledName ( ) const { std :: stringstream result ; result < < "FT" ; for ( const Type * t : parameter_types_ ) { std :: string arg_type_string = t -> MangledName ( ) ; result < < arg_type_string . size ( ) < < arg_type_string ; } std :: string return_type_string = return_type_ -> MangledName ( ) ; result < < return_type_string . size ( ) < < return_type_string ; return result . str ( ) ; }
MaybeHandle < MutableBigInt > MutableBigInt :: New ( Isolate * isolate , int length , PretenureFlag pretenure ) { if ( length > BigInt :: kMaxLength ) { THROW_NEW_ERROR ( isolate , NewRangeError ( MessageTemplate :: kBigIntTooBig ) , MutableBigInt ) ; } Handle < MutableBigInt > result = Cast ( isolate -> factory ( ) -> NewBigInt ( length , pretenure ) ) ; result -> initialize_bitfield ( false , length ) ; #if DEBUG result -> InitializeDigits ( length , 0xBF ) ; #endif return result ; }
PresShell :: PrepareToUseCaretPosition ( nsIWidget * aEventWidget , nsIntPoint & aTargetPt ) { nsresult rv ; nsRefPtr < nsCaret > caret = GetCaret ( ) ; NS_ENSURE_TRUE ( caret , false ) ; bool caretVisible = false ; rv = caret -> GetCaretVisible ( & caretVisible ) ; if ( NS_FAILED ( rv ) || ! caretVisible ) return false ; nsISelection * domSelection = caret -> GetCaretDOMSelection ( ) ; NS_ENSURE_TRUE ( domSelection , false ) ; nsIFrame * frame = nullptr ; nsCOMPtr < nsIDOMNode > node ; rv = domSelection -> GetFocusNode ( getter_AddRefs ( node ) ) ; NS_ENSURE_SUCCESS ( rv , false ) ; NS_ENSURE_TRUE ( node , false ) ; nsCOMPtr < nsIContent > content ( do_QueryInterface ( node ) ) ; if ( content ) { nsIContent * nonNative = content -> FindFirstNonNativeAnonymous ( ) ; content = nonNative ; } if ( content ) { rv = ScrollContentIntoView ( content , nsIPresShell :: ScrollAxis ( nsIPresShell :: SCROLL_MINIMUM , nsIPresShell :: SCROLL_IF_NOT_VISIBLE ) , nsIPresShell :: ScrollAxis ( nsIPresShell :: SCROLL_MINIMUM , nsIPresShell :: SCROLL_IF_NOT_VISIBLE ) , nsIPresShell :: SCROLL_OVERFLOW_HIDDEN ) ; NS_ENSURE_SUCCESS ( rv , false ) ; frame = content -> GetPrimaryFrame ( ) ; NS_WARN_IF_FALSE ( frame , "No frame for focused content?" ) ; } nsCOMPtr < nsISelectionController > selCon ; if ( frame ) frame -> GetSelectionController ( GetPresContext ( ) , getter_AddRefs ( selCon ) ) ; else selCon = static_cast < nsISelectionController * > ( this ) ; if ( selCon ) { rv = selCon -> ScrollSelectionIntoView ( nsISelectionController :: SELECTION_NORMAL , nsISelectionController :: SELECTION_FOCUS_REGION , nsISelectionController :: SCROLL_SYNCHRONOUS ) ; NS_ENSURE_SUCCESS ( rv , false ) ; } nsPresContext * presContext = GetPresContext ( ) ; nsRect caretCoords ; nsIFrame * caretFrame = caret -> GetGeometry ( domSelection , & caretCoords ) ; if ( ! caretFrame ) return false ; nsPoint viewOffset ; nsIView * view = caretFrame -> GetClosestView ( & viewOffset ) ; if ( ! view ) return false ; if ( aEventWidget ) { viewOffset += view -> GetOffsetToWidget ( aEventWidget ) ; } caretCoords . MoveBy ( viewOffset ) ; aTargetPt . x = presContext -> AppUnitsToDevPixels ( caretCoords . x + caretCoords . width ) ; aTargetPt . y = presContext -> AppUnitsToDevPixels ( caretCoords . y + caretCoords . height ) ; aTargetPt . y -= 1 ; return true ; }
parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ; guint pkt_len ; int pktnum , hr , min , sec , csec ; char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , "%9d] %2d:%2d:%2d.%9d %9s %9s" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "toshiba: record header isn't valid" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\0' ; } while ( strcmp ( line , "OFFSET 0001-0203" ) != 0 ) ; num_items_scanned = sscanf ( line + 64 , "LEN=%9u" , & pkt_len ) ; if ( num_items_scanned != 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "toshiba: OFFSET line doesn't have valid LEN item" ) ; return FALSE ; } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "toshiba: File has %u-byte packet, bigger than maximum of %u" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; phdr -> ts . secs = hr * 3600 + min * 60 + sec ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> caplen = pkt_len ; phdr -> len = pkt_len ; switch ( channel [ 0 ] ) { case 'B' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = ( guint8 ) strtol ( & channel [ 1 ] , NULL , 10 ) ; break ; case 'D' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = 0 ; break ; default : phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; pseudo_header -> eth . fcs_len = - 1 ; break ; } ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( ! parse_single_hex_dump_line ( line , pd , i * 16 ) ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "toshiba: hex dump not valid" ) ; return FALSE ; } } return TRUE ; }
SampleTable :: getSampleCencInfo ( uint32_t sample_index , Vector < uint16_t > & clear_sizes , Vector < uint32_t > & cipher_sizes , uint8_t iv [ ] ) { CHECK ( clear_sizes . isEmpty ( ) && cipher_sizes . isEmpty ( ) ) ; if ( sample_index >= mCencInfoCount ) { ALOGE ( "cenc info requested for out of range sample index" ) ; return ERROR_MALFORMED ; } auto & info = mCencInfo [ sample_index ] ; clear_sizes . setCapacity ( info . mSubsampleCount ) ; cipher_sizes . setCapacity ( info . mSubsampleCount ) ; for ( uint32_t i = 0 ; i < info . mSubsampleCount ; i ++ ) { clear_sizes . push ( info . mSubsamples [ i ] . mClearBytes ) ; cipher_sizes . push ( info . mSubsamples [ i ] . mCipherBytes ) ; } memcpy ( iv , info . mIV , IV_BYTES ) ; return OK ; }
gplotRead ( const char * filename ) { char buf [ L_BUF_SIZE ] ; char * rootname , * title , * xlabel , * ylabel , * ignores ; l_int32 outformat , ret , version , ignore ; FILE * fp ; GPLOT * gplot ; PROCNAME ( "gplotRead" ) ; if ( ! filename ) return ( GPLOT * ) ERROR_PTR ( "filename not defined" , procName , NULL ) ; if ( ( fp = fopenReadStream ( filename ) ) == NULL ) return ( GPLOT * ) ERROR_PTR ( "stream not opened" , procName , NULL ) ; ret = fscanf ( fp , "Gplot Version %d\n" , & version ) ; if ( ret != 1 ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( "not a gplot file" , procName , NULL ) ; } if ( version != GPLOT_VERSION_NUMBER ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( "invalid gplot version" , procName , NULL ) ; } ignore = fscanf ( fp , "Rootname: %s\n" , buf ) ; rootname = stringNew ( buf ) ; ignore = fscanf ( fp , "Output format: %d\n" , & outformat ) ; ignores = fgets ( buf , L_BUF_SIZE , fp ) ; title = stringNew ( buf + 7 ) ; title [ strlen ( title ) - 1 ] = '\0' ; ignores = fgets ( buf , L_BUF_SIZE , fp ) ; xlabel = stringNew ( buf + 14 ) ; xlabel [ strlen ( xlabel ) - 1 ] = '\0' ; ignores = fgets ( buf , L_BUF_SIZE , fp ) ; ylabel = stringNew ( buf + 14 ) ; ylabel [ strlen ( ylabel ) - 1 ] = '\0' ; gplot = gplotCreate ( rootname , outformat , title , xlabel , ylabel ) ; LEPT_FREE ( rootname ) ; LEPT_FREE ( title ) ; LEPT_FREE ( xlabel ) ; LEPT_FREE ( ylabel ) ; if ( ! gplot ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( "gplot not made" , procName , NULL ) ; } sarrayDestroy ( & gplot -> cmddata ) ; sarrayDestroy ( & gplot -> datanames ) ; sarrayDestroy ( & gplot -> plotdata ) ; sarrayDestroy ( & gplot -> plottitles ) ; numaDestroy ( & gplot -> plotstyles ) ; ignore = fscanf ( fp , "Commandfile name: %s\n" , buf ) ; stringReplace ( & gplot -> cmdname , buf ) ; ignore = fscanf ( fp , "\nCommandfile data:" ) ; gplot -> cmddata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\nDatafile names:" ) ; gplot -> datanames = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\nPlot data:" ) ; gplot -> plotdata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\nPlot titles:" ) ; gplot -> plottitles = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\nPlot styles:" ) ; gplot -> plotstyles = numaReadStream ( fp ) ; ignore = fscanf ( fp , "Number of plots: %d\n" , & gplot -> nplots ) ; ignore = fscanf ( fp , "Output file name: %s\n" , buf ) ; stringReplace ( & gplot -> outname , buf ) ; ignore = fscanf ( fp , "Axis scaling: %d\n" , & gplot -> scaling ) ; fclose ( fp ) ; return gplot ; }
void options_defaults ( ) { SERVICE_OPTIONS * service ; memset ( & new_global_options , 0 , sizeof ( GLOBAL_OPTIONS ) ) ; memset ( & new_service_options , 0 , sizeof ( SERVICE_OPTIONS ) ) ; new_service_options . next = NULL ; parse_global_option ( CMD_SET_DEFAULTS , NULL , NULL ) ; service = & new_service_options ; parse_service_option ( CMD_SET_DEFAULTS , & service , NULL , NULL ) ; }
njs_function_frame_invoke ( njs_vm_t * vm , njs_value_t * retval ) { njs_native_frame_t * frame ; frame = vm -> top_frame ; frame -> retval = retval ; if ( njs_function_object_type ( vm , frame -> function ) == NJS_OBJ_TYPE_ASYNC_FUNCTION ) { return njs_async_function_frame_invoke ( vm , retval ) ; } if ( frame -> native ) { return njs_function_native_call ( vm ) ; } else { return njs_function_lambda_call ( vm ) ; } }
void Compute ( OpKernelContext * ctx ) override { const Tensor * indices_t , * values_t , * shape_t , * dense_t ; OP_REQUIRES_OK ( ctx , ctx -> input ( "sp_indices" , & indices_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( "sp_values" , & values_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( "sp_shape" , & shape_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( "dense" , & dense_t ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsMatrix ( indices_t -> shape ( ) ) , errors :: InvalidArgument ( "Input sp_indices should be a matrix but received shape: " , indices_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsVector ( values_t -> shape ( ) ) && TensorShapeUtils :: IsVector ( shape_t -> shape ( ) ) , errors :: InvalidArgument ( "Inputs sp_values and sp_shape should be vectors " "but received shapes: " , values_t -> shape ( ) . DebugString ( ) , " and " , shape_t -> shape ( ) . DebugString ( ) ) ) ; const auto indices_mat = indices_t -> matrix < int64 > ( ) ; const auto shape_vec = shape_t -> vec < int64 > ( ) ; const auto lhs_dims = BCast :: FromShape ( TensorShape ( shape_vec ) ) ; const auto rhs_dims = BCast :: FromShape ( dense_t -> shape ( ) ) ; BCast b ( lhs_dims , rhs_dims , false ) ; auto VecGreaterEq = [ ] ( ArraySlice < int64 > lhs , ArraySlice < int64 > rhs ) { if ( lhs . size ( ) < rhs . size ( ) ) return false ; for ( size_t i = 0 ; i < rhs . size ( ) ; ++ i ) { if ( lhs [ lhs . size ( ) - 1 - i ] < rhs [ rhs . size ( ) - 1 - i ] ) return false ; } return true ; } ; OP_REQUIRES ( ctx , VecGreaterEq ( lhs_dims , rhs_dims ) && b . IsValid ( ) , errors :: InvalidArgument ( "SparseDenseBinaryOpShared broadcasts dense to sparse " "only; got incompatible shapes: [" , absl :: StrJoin ( lhs_dims , "," ) , "] vs. [" , absl :: StrJoin ( rhs_dims , "," ) , "]" ) ) ; Tensor * output_values = nullptr ; Tensor dense_gathered ; const int64 nnz = indices_t -> dim_size ( 0 ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { nnz } ) , & output_values ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < T > :: value , TensorShape ( { nnz } ) , & dense_gathered ) ) ; auto dense_gathered_flat = dense_gathered . flat < T > ( ) ; const int ndims = lhs_dims . size ( ) ; switch ( ndims ) { #define CASE(NDIM)                                                             \   case NDIM: {                                                                 \     TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \         dense_t->shaped<T, NDIM>(b.y_reshape())                                \             .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \     Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \     bool indices_valid = true;                                                 \     for (int i = 0; i < nnz; ++i) {                                            \       for (int d = 0; d < NDIM; ++d) {                                         \         idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \         if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \           indices_valid = false;                                               \         }                                                                      \       }                                                                        \       OP_REQUIRES(                                                             \           ctx, indices_valid,                                                  \           errors::InvalidArgument("Provided indices are out-of-bounds w.r.t. " \                                   "dense side with broadcasted shape"));       \       dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \     }                                                                          \     break;                                                                     \   } CASE ( 1 ) ; CASE ( 2 ) ; CASE ( 3 ) ; CASE ( 4 ) ; CASE ( 5 ) ; default : OP_REQUIRES ( ctx , false , errors :: InvalidArgument ( "Only tensors with ranks between 1 and 5 " "are currently supported.  Tensor rank: " , ndims ) ) ; #undef CASE } output_values -> flat < T > ( ) . device ( ctx -> eigen_device < Device > ( ) ) = values_t -> flat < T > ( ) . binaryExpr ( dense_gathered_flat , typename Functor :: func ( ) ) ; }
tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket ( PVOID buffer , ULONG size , LPCSTR caller ) { tTcpIpPacketParsingResult res = QualifyIpPacket ( ( IPHeader * ) buffer , size ) ; PrintOutParsingResult ( res , 1 , caller ) ; return res ; }
static inline int ReadProfileByte ( unsigned char * * p , size_t * length ) { int c ; if ( * length < 1 ) return ( EOF ) ; c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; return ( c ) ; } static inline signed short ReadProfileShort ( const EndianType endian , unsigned char * buffer ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; unsigned short
const SlotSnapshot & MakeSlotSnapshot ( Map * map , T * object , int size ) { SlotSnapshottingVisitor visitor ( & slot_snapshot_ ) ; visitor . VisitPointer ( object , reinterpret_cast < Object * * > ( object -> map_slot ( ) ) ) ; T :: BodyDescriptor :: IterateBody ( map , object , size , & visitor ) ; return slot_snapshot_ ; }
NS_IMETHODIMP nsFocusManager :: SetFocusedWindow ( mozIDOMWindowProxy * aWindowToFocus ) { LOGFOCUS ( ( "<<SetFocusedWindow begin>>" ) ) ; nsCOMPtr < nsPIDOMWindowOuter > windowToFocus = nsPIDOMWindowOuter :: From ( aWindowToFocus ) ; NS_ENSURE_TRUE ( windowToFocus , NS_ERROR_FAILURE ) ; nsCOMPtr < Element > frameElement = windowToFocus -> GetFrameElementInternal ( ) ; if ( frameElement ) { SetFocusInner ( frameElement , 0 , false , true ) ; } else { nsIContent * content = windowToFocus -> GetFocusedElement ( ) ; if ( content ) { if ( nsCOMPtr < nsPIDOMWindowOuter > childWindow = GetContentWindow ( content ) ) ClearFocus ( windowToFocus ) ; } } nsCOMPtr < nsPIDOMWindowOuter > rootWindow = windowToFocus -> GetPrivateRoot ( ) ; if ( rootWindow ) RaiseWindow ( rootWindow ) ; LOGFOCUS ( ( "<<SetFocusedWindow end>>" ) ) ; return NS_OK ; }
const Operator * CommonOperatorBuilder :: Return ( int value_input_count ) { switch ( value_input_count ) { #define CACHED_RETURN(input_count) \  case input_count:                \  return &cache_.kReturn##input_count##Operator; CACHED_RETURN_LIST ( CACHED_RETURN ) #undef CACHED_RETURN default : break ; } return new ( zone ( ) ) Operator ( IrOpcode :: kReturn , Operator :: kNoThrow , "Return" , value_input_count + 1 , 1 , 1 , 0 , 0 , 1 ) ; }
check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( "Bad offset %p\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking: element %p size %u\n" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! ip_checkentry ( & e -> ip ) ) return - EINVAL ; err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 < < h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( "Underflows must be unconditional and " "use the STANDARD target with " "ACCEPT/DROP\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
BUILTIN ( DatePrototypeToISOString ) { HandleScope scope ( isolate ) ; CHECK_RECEIVER ( JSDate , date , "Date.prototype.toISOString" ) ; double const time_val = date -> value ( ) -> Number ( ) ; if ( std :: isnan ( time_val ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewRangeError ( MessageTemplate :: kInvalidTimeValue ) ) ; } int64_t const time_ms = static_cast < int64_t > ( time_val ) ; int year , month , day , weekday , hour , min , sec , ms ; isolate -> date_cache ( ) -> BreakDownTime ( time_ms , & year , & month , & day , & weekday , & hour , & min , & sec , & ms ) ; char buffer [ 128 ] ; if ( year >= 0 && year <= 9999 ) { SNPrintF ( ArrayVector ( buffer ) , "%04d-%02d-%02dT%02d:%02d:%02d.%03dZ" , year , month + 1 , day , hour , min , sec , ms ) ; } else if ( year < 0 ) { SNPrintF ( ArrayVector ( buffer ) , "-%06d-%02d-%02dT%02d:%02d:%02d.%03dZ" , - year , month + 1 , day , hour , min , sec , ms ) ; } else { SNPrintF ( ArrayVector ( buffer ) , "+%06d-%02d-%02dT%02d:%02d:%02d.%03dZ" , year , month + 1 , day , hour , min , sec , ms ) ; } return * isolate -> factory ( ) -> NewStringFromAsciiChecked ( buffer ) ; }
MaybeHandle < JSObject > JSObjectWalkVisitor < ContextObject > :: StructureWalk ( Handle < JSObject > object ) { Isolate * isolate = this -> isolate ( ) ; bool copying = ContextObject :: kCopying ; bool shallow = hints_ == kObjectIsShallow ; if ( ! shallow ) { StackLimitCheck check ( isolate ) ; if ( check . HasOverflowed ( ) ) { isolate -> StackOverflow ( ) ; return MaybeHandle < JSObject > ( ) ; } } if ( object -> map ( ) -> is_deprecated ( ) ) { JSObject :: MigrateInstance ( object ) ; } Handle < JSObject > copy ; if ( copying ) { DCHECK ( ! object -> IsJSFunction ( ) ) ; Handle < AllocationSite > site_to_pass ; if ( site_context ( ) -> ShouldCreateMemento ( object ) ) { site_to_pass = site_context ( ) -> current ( ) ; } copy = isolate -> factory ( ) -> CopyJSObjectWithAllocationSite ( object , site_to_pass ) ; } else { copy = object ; } DCHECK ( copying || copy . is_identical_to ( object ) ) ; if ( shallow ) return copy ; HandleScope scope ( isolate ) ; if ( ! copy -> IsJSArray ( ) ) { if ( copy -> HasFastProperties ( ) ) { Handle < DescriptorArray > descriptors ( copy -> map ( ) -> instance_descriptors ( ) , isolate ) ; int limit = copy -> map ( ) -> NumberOfOwnDescriptors ( ) ; for ( int i = 0 ; i < limit ; i ++ ) { DCHECK_EQ ( kField , descriptors -> GetDetails ( i ) . location ( ) ) ; DCHECK_EQ ( kData , descriptors -> GetDetails ( i ) . kind ( ) ) ; FieldIndex index = FieldIndex :: ForDescriptor ( copy -> map ( ) , i ) ; if ( copy -> IsUnboxedDoubleField ( index ) ) continue ; Object * raw = copy -> RawFastPropertyAt ( index ) ; if ( raw -> IsJSObject ( ) ) { Handle < JSObject > value ( JSObject :: cast ( raw ) , isolate ) ; ASSIGN_RETURN_ON_EXCEPTION ( isolate , value , VisitElementOrProperty ( copy , value ) , JSObject ) ; if ( copying ) copy -> FastPropertyAtPut ( index , * value ) ; } else if ( copying && raw -> IsMutableHeapNumber ( ) ) { DCHECK ( descriptors -> GetDetails ( i ) . representation ( ) . IsDouble ( ) ) ; uint64_t double_value = MutableHeapNumber :: cast ( raw ) -> value_as_bits ( ) ; auto value = isolate -> factory ( ) -> NewMutableHeapNumberFromBits ( double_value ) ; copy -> FastPropertyAtPut ( index , * value ) ; } } } else { Handle < NameDictionary > dict ( copy -> property_dictionary ( ) , isolate ) ; for ( int i = 0 ; i < dict -> Capacity ( ) ; i ++ ) { Object * raw = dict -> ValueAt ( i ) ; if ( ! raw -> IsJSObject ( ) ) continue ; DCHECK ( dict -> KeyAt ( i ) -> IsName ( ) ) ; Handle < JSObject > value ( JSObject :: cast ( raw ) , isolate ) ; ASSIGN_RETURN_ON_EXCEPTION ( isolate , value , VisitElementOrProperty ( copy , value ) , JSObject ) ; if ( copying ) dict -> ValueAtPut ( i , * value ) ; } } if ( copy -> elements ( ) -> length ( ) == 0 ) return copy ; } switch ( copy -> GetElementsKind ( ) ) { case PACKED_ELEMENTS : case HOLEY_ELEMENTS : { Handle < FixedArray > elements ( FixedArray :: cast ( copy -> elements ( ) ) , isolate ) ; if ( elements -> map ( ) == ReadOnlyRoots ( isolate ) . fixed_cow_array_map ( ) ) { #ifdef DEBUG for ( int i = 0 ; i < elements -> length ( ) ; i ++ ) { DCHECK ( ! elements -> get ( i ) -> IsJSObject ( ) ) ; } #endif } else { for ( int i = 0 ; i < elements -> length ( ) ; i ++ ) { Object * raw = elements -> get ( i ) ; if ( ! raw -> IsJSObject ( ) ) continue ; Handle < JSObject > value ( JSObject :: cast ( raw ) , isolate ) ; ASSIGN_RETURN_ON_EXCEPTION ( isolate , value , VisitElementOrProperty ( copy , value ) , JSObject ) ; if ( copying ) elements -> set ( i , * value ) ; } } break ; } case DICTIONARY_ELEMENTS : { Handle < NumberDictionary > element_dictionary ( copy -> element_dictionary ( ) , isolate ) ; int capacity = element_dictionary -> Capacity ( ) ; for ( int i = 0 ; i < capacity ; i ++ ) { Object * raw = element_dictionary -> ValueAt ( i ) ; if ( ! raw -> IsJSObject ( ) ) continue ; Handle < JSObject > value ( JSObject :: cast ( raw ) , isolate ) ; ASSIGN_RETURN_ON_EXCEPTION ( isolate , value , VisitElementOrProperty ( copy , value ) , JSObject ) ; if ( copying ) element_dictionary -> ValueAtPut ( i , * value ) ; } break ; } case FAST_SLOPPY_ARGUMENTS_ELEMENTS : case SLOW_SLOPPY_ARGUMENTS_ELEMENTS : UNIMPLEMENTED ( ) ; break ; case FAST_STRING_WRAPPER_ELEMENTS : case SLOW_STRING_WRAPPER_ELEMENTS : UNREACHABLE ( ) ; break ; #define TYPED_ARRAY_CASE(Type, type, TYPE, ctype) case TYPE##_ELEMENTS: TYPED_ARRAYS ( TYPED_ARRAY_CASE ) #undef TYPED_ARRAY_CASE UNREACHABLE ( ) ; break ; case PACKED_SMI_ELEMENTS : case HOLEY_SMI_ELEMENTS : case PACKED_DOUBLE_ELEMENTS : case HOLEY_DOUBLE_ELEMENTS : case NO_ELEMENTS : break ; } return copy ; }
Parser :: ~ Parser ( ) { JSContext * cx = context ; if ( principals ) JSPRINCIPALS_DROP ( cx , principals ) ; cx -> tempLifoAlloc ( ) . release ( tempPoolMark ) ; cx -> activeCompilations -- ; }
int oidc_handle_redirect_uri_request ( request_rec * r , oidc_cfg * c , oidc_session_t * session ) { if ( oidc_proto_is_redirect_authorization_response ( r , c ) ) { return oidc_handle_redirect_authorization_response ( r , c , session ) ; } else if ( oidc_proto_is_post_authorization_response ( r , c ) ) { return oidc_handle_post_authorization_response ( r , c , session ) ; } else if ( oidc_is_discovery_response ( r , c ) ) { return oidc_handle_discovery_response ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , "logout" ) ) { return oidc_handle_logout ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , "jwks" ) ) { return oidc_handle_jwks ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , "session" ) ) { return oidc_handle_session_management ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , "refresh" ) ) { return oidc_handle_refresh_token_request ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , "request_uri" ) ) { return oidc_handle_request_uri ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , "remove_at_cache" ) ) { return oidc_handle_remove_at_cache ( r , c ) ; } else if ( ( r -> args == NULL ) || ( apr_strnatcmp ( r -> args , "" ) == 0 ) ) { return oidc_proto_javascript_implicit ( r , c ) ; } if ( oidc_util_request_has_parameter ( r , "error" ) ) { oidc_handle_redirect_authorization_response ( r , c , session ) ; } return oidc_util_html_send_error ( r , c -> error_template , "Invalid Request" , apr_psprintf ( r -> pool , "The OpenID Connect callback URL received an invalid request: %s" , r -> args ) , HTTP_INTERNAL_SERVER_ERROR ) ; }
static void nodeConstruct ( struct SaveNode * node , tr_variant const * v , bool sort_dicts ) { node -> isVisited = false ; node -> childIndex = 0 ; if ( sort_dicts && tr_variantIsDict ( v ) ) { size_t const n = v -> val . l . count ; struct KeyIndex * tmp = tr_new ( struct KeyIndex , n ) ; for ( size_t i = 0 ; i < n ; i ++ ) { tmp [ i ] . val = v -> val . l . vals + i ; tmp [ i ] . keystr = tr_quark_get_string ( tmp [ i ] . val -> key , NULL ) ; } qsort ( tmp , n , sizeof ( struct KeyIndex ) , compareKeyIndex ) ; tr_variantInitDict ( & node -> sorted , n ) ; for ( size_t i = 0 ; i < n ; ++ i ) { node -> sorted . val . l . vals [ i ] = * tmp [ i ] . val ; } node -> sorted . val . l . count = n ; tr_free ( tmp ) ; node -> v = & node -> sorted ; } else { node -> v = v ; } }
FieldAccess AccessBuilder :: ForMapDescriptors ( ) { FieldAccess access = { kTaggedBase , Map :: kDescriptorsOffset , Handle < Name > ( ) , MaybeHandle < Map > ( ) , Type :: OtherInternal ( ) , MachineType :: TaggedPointer ( ) , kPointerWriteBarrier } ; return access ; }
int ff_htmlmarkup_to_ass ( void * log_ctx , AVBPrint * dst , const char * in ) { char * param , buffer [ 128 ] , tmp [ 128 ] ; int len , tag_close , sptr = 1 , line_start = 1 , an = 0 , end = 0 ; SrtStack stack [ 16 ] ; int closing_brace_missing = 0 ; stack [ 0 ] . tag [ 0 ] = 0 ; strcpy ( stack [ 0 ] . param [ PARAM_SIZE ] , "{\\fs}" ) ; strcpy ( stack [ 0 ] . param [ PARAM_COLOR ] , "{\\c}" ) ; strcpy ( stack [ 0 ] . param [ PARAM_FACE ] , "{\\fn}" ) ; for ( ; ! end && * in ; in ++ ) { switch ( * in ) { case '\r' : break ; case '\n' : if ( line_start ) { end = 1 ; break ; } rstrip_spaces_buf ( dst ) ; av_bprintf ( dst , "\\N" ) ; line_start = 1 ; break ; case ' ' : if ( ! line_start ) av_bprint_chars ( dst , * in , 1 ) ; break ; case '{' : len = 0 ; an += sscanf ( in , "{\\an%*1u}%n" , & len ) >= 0 && len > 0 ; if ( ! closing_brace_missing ) { if ( ( an != 1 && in [ 1 ] == '\\' ) || ( in [ 1 ] && strchr ( "CcFfoPSsYy" , in [ 1 ] ) && in [ 2 ] == ':' ) ) { char * bracep = strchr ( in + 2 , '}' ) ; if ( bracep ) { in = bracep ; break ; } else closing_brace_missing = 1 ; } } av_bprint_chars ( dst , * in , 1 ) ; break ; case '<' : tag_close = in [ 1 ] == '/' ; len = 0 ; if ( scantag ( in + tag_close + 1 , buffer , & len ) && len > 0 ) { const char * tagname = buffer ; while ( * tagname == ' ' ) tagname ++ ; if ( ( param = strchr ( tagname , ' ' ) ) ) * param ++ = 0 ; if ( ( ! tag_close && sptr < FF_ARRAY_ELEMS ( stack ) && * tagname ) || ( tag_close && sptr > 0 && ! strcmp ( stack [ sptr - 1 ] . tag , tagname ) ) ) { int i , j , unknown = 0 ; in += len + tag_close ; if ( ! tag_close ) memset ( stack + sptr , 0 , sizeof ( * stack ) ) ; if ( ! strcmp ( tagname , "font" ) ) { if ( tag_close ) { for ( i = PARAM_NUMBER - 1 ; i >= 0 ; i -- ) if ( stack [ sptr - 1 ] . param [ i ] [ 0 ] ) for ( j = sptr - 2 ; j >= 0 ; j -- ) if ( stack [ j ] . param [ i ] [ 0 ] ) { av_bprintf ( dst , "%s" , stack [ j ] . param [ i ] ) ; break ; } } else { while ( param ) { if ( ! strncmp ( param , "size=" , 5 ) ) { unsigned font_size ; param += 5 + ( param [ 5 ] == '"' ) ; if ( sscanf ( param , "%u" , & font_size ) == 1 ) { snprintf ( stack [ sptr ] . param [ PARAM_SIZE ] , sizeof ( stack [ 0 ] . param [ PARAM_SIZE ] ) , "{\\fs%u}" , font_size ) ; } } else if ( ! strncmp ( param , "color=" , 6 ) ) { param += 6 + ( param [ 6 ] == '"' ) ; snprintf ( stack [ sptr ] . param [ PARAM_COLOR ] , sizeof ( stack [ 0 ] . param [ PARAM_COLOR ] ) , "{\\c&H%X&}" , html_color_parse ( log_ctx , param ) ) ; } else if ( ! strncmp ( param , "face=" , 5 ) ) { param += 5 + ( param [ 5 ] == '"' ) ; len = strcspn ( param , param [ - 1 ] == '"' ? "\"" : " " ) ; av_strlcpy ( tmp , param , FFMIN ( sizeof ( tmp ) , len + 1 ) ) ; param += len ; snprintf ( stack [ sptr ] . param [ PARAM_FACE ] , sizeof ( stack [ 0 ] . param [ PARAM_FACE ] ) , "{\\fn%s}" , tmp ) ; } if ( ( param = strchr ( param , ' ' ) ) ) param ++ ; } for ( i = 0 ; i < PARAM_NUMBER ; i ++ ) if ( stack [ sptr ] . param [ i ] [ 0 ] ) av_bprintf ( dst , "%s" , stack [ sptr ] . param [ i ] ) ; } } else if ( tagname [ 0 ] && ! tagname [ 1 ] && strspn ( tagname , "bisu" ) == 1 ) { av_bprintf ( dst , "{\\%c%d}" , tagname [ 0 ] , ! tag_close ) ; } else { unknown = 1 ; snprintf ( tmp , sizeof ( tmp ) , "</%s>" , tagname ) ; } if ( tag_close ) { sptr -- ; } else if ( unknown && ! strstr ( in , tmp ) ) { in -= len + tag_close ; av_bprint_chars ( dst , * in , 1 ) ; } else av_strlcpy ( stack [ sptr ++ ] . tag , tagname , sizeof ( stack [ 0 ] . tag ) ) ; break ; } } default : av_bprint_chars ( dst , * in , 1 ) ; break ; } if ( * in != ' ' && * in != '\r' && * in != '\n' ) line_start = 0 ; } if ( ! av_bprint_is_complete ( dst ) ) return AVERROR ( ENOMEM ) ; while ( dst -> len >= 2 && ! strncmp ( & dst -> str [ dst -> len - 2 ] , "\\N" , 2 ) ) dst -> len -= 2 ; dst -> str [ dst -> len ] = 0 ; rstrip_spaces_buf ( dst ) ; return 0 ; }
static void SpatialMaxPoolWithArgMaxHelper ( OpKernelContext * context , Tensor * output , Tensor * output_arg_max , Tensor * input_backprop , const Tensor & tensor_in , const Tensor & out_backprop , const PoolParameters & params , const bool include_batch_in_index ) { if ( input_backprop != nullptr ) { OP_REQUIRES ( context , include_batch_in_index , errors :: Internal ( "SpatialMaxPoolWithArgMaxHelper requires include_batch_in_index " "to be True when input_backprop != nullptr" ) ) ; OP_REQUIRES ( context , ( std :: is_same < Targmax , int64 > :: value ) , errors :: Internal ( "SpatialMaxPoolWithArgMaxHelper requires Targmax " "to be int64 when input_backprop != nullptr" ) ) ; } typedef Eigen :: Map < const Eigen :: Matrix < T , Eigen :: Dynamic , Eigen :: Dynamic > > ConstEigenMatrixMap ; typedef Eigen :: Map < Eigen :: Matrix < T , Eigen :: Dynamic , Eigen :: Dynamic > > EigenMatrixMap ; typedef Eigen :: Map < Eigen :: Matrix < Targmax , Eigen :: Dynamic , Eigen :: Dynamic > > EigenIndexMatrixMap ; ConstEigenMatrixMap in_mat ( tensor_in . flat < T > ( ) . data ( ) , params . depth , params . tensor_in_cols * params . tensor_in_rows * params . tensor_in_batch ) ; EigenMatrixMap out_mat ( output -> flat < T > ( ) . data ( ) , params . depth , params . out_width * params . out_height * params . tensor_in_batch ) ; EigenIndexMatrixMap out_arg_max_mat ( output_arg_max -> flat < Targmax > ( ) . data ( ) , params . depth , params . out_width * params . out_height * params . tensor_in_batch ) ; const DeviceBase :: CpuWorkerThreads & worker_threads = * ( context -> device ( ) -> tensorflow_cpu_worker_threads ( ) ) ; auto shard = [ & params , & in_mat , & out_mat , & out_arg_max_mat , & input_backprop , & output_arg_max , & out_backprop , include_batch_in_index ] ( int64_t start , int64_t limit ) { const int32_t depth = params . depth ; const int32_t in_rows = params . tensor_in_rows ; const int32_t in_cols = params . tensor_in_cols ; const int32_t pad_top = params . pad_top ; const int32_t pad_left = params . pad_left ; const int32_t window_rows = params . window_rows ; const int32_t window_cols = params . window_cols ; const int32_t row_stride = params . row_stride ; const int32_t col_stride = params . col_stride ; const int32_t out_height = params . out_height ; const int32_t out_width = params . out_width ; { const int32_t output_image_size = out_height * out_width * depth ; EigenMatrixMap out_shard ( out_mat . data ( ) + start * output_image_size , 1 , ( limit - start ) * output_image_size ) ; out_shard . setConstant ( Eigen :: NumTraits < T > :: lowest ( ) ) ; EigenIndexMatrixMap out_arg_max_shard ( out_arg_max_mat . data ( ) + start * output_image_size , 1 , ( limit - start ) * output_image_size ) ; out_arg_max_shard . setConstant ( kInvalidMaxPoolingIndex ) ; } for ( int64_t b = start ; b < limit ; ++ b ) { for ( int h = 0 ; h < in_rows ; ++ h ) { for ( int w = 0 ; w < in_cols ; ++ w ) { const int hpad = h + pad_top ; const int wpad = w + pad_left ; const int h_start = ( hpad < window_rows ) ? 0 : ( hpad - window_rows ) / row_stride + 1 ; const int h_end = std :: min ( hpad / row_stride + 1 , out_height ) ; const int w_start = ( wpad < window_cols ) ? 0 : ( wpad - window_cols ) / col_stride + 1 ; const int w_end = std :: min ( wpad / col_stride + 1 , out_width ) ; const int64_t in_index = ( b * in_rows + h ) * in_cols + w ; for ( int ph = h_start ; ph < h_end ; ++ ph ) { const int64_t out_index_base = ( b * out_height + ph ) * out_width ; for ( int pw = w_start ; pw < w_end ; ++ pw ) { const int64_t out_index = out_index_base + pw ; for ( int d = 0 ; d < depth ; ++ d ) { const T & input_ref = in_mat . coeffRef ( d , in_index ) ; T & output_ref = out_mat . coeffRef ( d , out_index ) ; Targmax & out_arg_max_ref = out_arg_max_mat . coeffRef ( d , out_index ) ; if ( output_ref < input_ref || out_arg_max_ref == kInvalidMaxPoolingIndex ) { output_ref = input_ref ; if ( include_batch_in_index ) { out_arg_max_ref = in_index * depth + d ; } else { out_arg_max_ref = ( h * in_cols + w ) * depth + d ; } } } } } } } } if ( input_backprop != nullptr ) { auto input_backprop_flat = input_backprop -> flat < T > ( ) ; auto out_arg_max_flat = output_arg_max -> flat < int64 > ( ) ; auto out_backprop_flat = out_backprop . flat < T > ( ) ; const int64_t in_size = in_rows * in_cols * depth ; const int64_t in_start = start * in_size ; const int64_t in_end = limit * in_size ; EigenMatrixMap in_shard ( input_backprop_flat . data ( ) + in_start , 1 , in_end - in_start ) ; in_shard . setConstant ( T ( 0 ) ) ; const int out_size = out_height * out_width * depth ; const int out_start = start * out_size ; const int out_end = limit * out_size ; for ( int index = out_start ; index < out_end ; ++ index ) { int input_backprop_index = out_arg_max_flat ( index ) ; FastBoundsCheck ( input_backprop_index - in_start , in_end - in_start ) ; if ( index < out_backprop . NumElements ( ) ) { input_backprop_flat ( input_backprop_index ) += out_backprop_flat ( index ) ; } } } } ; const int64_t shard_cost = params . tensor_in_rows * params . tensor_in_cols * params . depth * params . window_rows * params . window_cols ; Shard ( worker_threads . num_threads , worker_threads . workers , params . tensor_in_batch , shard_cost , shard ) ; }
void Compute ( OpKernelContext * ctx ) override { const Tensor & shape_t = ctx -> input ( 0 ) ; const Tensor & alpha_t = ctx -> input ( 1 ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsVector ( shape_t . shape ( ) ) && ( shape_t . dtype ( ) == DataType :: DT_INT32 || shape_t . dtype ( ) == DataType :: DT_INT64 ) , errors :: InvalidArgument ( "shape must be a vector of {int32,int64}, got shape: " , shape_t . DebugString ( ) ) ) ; TensorShape samples_shape ; if ( shape_t . dtype ( ) == DataType :: DT_INT32 ) { auto vec = shape_t . flat < int32 > ( ) ; OP_REQUIRES_OK ( ctx , TensorShapeUtils :: MakeShape ( vec . data ( ) , vec . size ( ) , & samples_shape ) ) ; } else if ( shape_t . dtype ( ) == DataType :: DT_INT64 ) { auto vec = shape_t . flat < int64_t > ( ) ; OP_REQUIRES_OK ( ctx , TensorShapeUtils :: MakeShape ( vec . data ( ) , vec . size ( ) , & samples_shape ) ) ; } const int64_t samples_per_alpha = samples_shape . num_elements ( ) ; samples_shape . AppendShape ( alpha_t . shape ( ) ) ; Tensor * samples_t = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , samples_shape , & samples_t ) ) ; if ( samples_shape . num_elements ( ) == 0 ) return ; using random :: PhiloxRandom ; typedef random :: NormalDistribution < PhiloxRandom , double > Normal ; typedef random :: UniformDistribution < PhiloxRandom , double > Uniform ; #define UNIFORM(X)                                    \   if (uniform_remaining == 0) {                       \     uniform_remaining = Uniform::kResultElementCount; \     uniform_result = uniform(&gen);                   \   }                                                   \   uniform_remaining--;                                \   double X = uniform_result[uniform_remaining] static constexpr int kReservedSamplesPerOutput = 256 ; const auto alpha_flat = alpha_t . flat < T > ( ) . data ( ) ; const int64_t num_alphas = alpha_t . NumElements ( ) ; OP_REQUIRES ( ctx , num_alphas > 0 , errors :: InvalidArgument ( "Input alpha should have non-zero element count, got: " , num_alphas ) ) ; auto samples_flat = samples_t -> flat < T > ( ) . data ( ) ; PhiloxRandom rng = generator_ . ReserveRandomOutputs ( samples_per_alpha * num_alphas , kReservedSamplesPerOutput ) ; auto DoWork = [ samples_per_alpha , num_alphas , & rng , samples_flat , alpha_flat ] ( int64_t start_output , int64_t limit_output ) { using Eigen :: numext :: exp ; using Eigen :: numext :: log ; using Eigen :: numext :: log1p ; using Eigen :: numext :: pow ; Normal normal ; Uniform uniform ; typename Normal :: ResultType norm_result ; typename Uniform :: ResultType uniform_result ; for ( int64_t output_idx = start_output ; output_idx < limit_output ; ) { int64_t alpha_idx = output_idx / samples_per_alpha ; T * const samples_alpha_offset = samples_flat + alpha_idx ; const double alpha = static_cast < double > ( alpha_flat [ alpha_idx ] ) ; DISABLE_FLOAT_EQUALITY_WARNING if ( alpha == static_cast < double > ( 1.0 ) ) { ENABLE_FLOAT_EQUALITY_WARNING for ( int64_t sample_idx = output_idx % samples_per_alpha ; sample_idx < samples_per_alpha && output_idx < limit_output ; sample_idx ++ , output_idx ++ ) { PhiloxRandom gen = rng ; gen . Skip ( kReservedSamplesPerOutput * output_idx ) ; int16_t uniform_remaining = 0 ; UNIFORM ( u ) ; const double res = - log1p ( - u ) ; samples_alpha_offset [ sample_idx * num_alphas ] = static_cast < T > ( res ) ; } } else { const bool alpha_less_than_one = alpha < 1 ; const double d = alpha + ( alpha_less_than_one ? 2.0 / 3 : - 1.0 / 3 ) ; const double c = 1.0 / 3 / sqrt ( d ) ; for ( int64_t sample_idx = output_idx % samples_per_alpha ; sample_idx < samples_per_alpha && output_idx < limit_output ; sample_idx ++ , output_idx ++ ) { PhiloxRandom gen = rng ; gen . Skip ( kReservedSamplesPerOutput * output_idx ) ; int16_t norm_remaining = 0 ; int16_t uniform_remaining = 0 ; while ( true ) { if ( norm_remaining == 0 ) { norm_remaining = Normal :: kResultElementCount ; norm_result = normal ( & gen ) ; } norm_remaining -- ; const double x = norm_result [ norm_remaining ] ; double v = 1 + c * x ; if ( v <= 0 ) { continue ; } v = v * v * v ; UNIFORM ( u ) ; if ( ( u < 1 - 0.0331 * ( x * x ) * ( x * x ) ) || ( log ( u ) < 0.5 * x * x + d * ( 1 - v + log ( v ) ) ) ) { double res = d * v ; if ( alpha_less_than_one ) { UNIFORM ( b ) ; res *= pow ( b , 1 / alpha ) ; } samples_alpha_offset [ sample_idx * num_alphas ] = static_cast < T > ( res ) ; break ; } } } } } } ; #undef UNIFORM static const int kElementCost = 85 + 2 * Normal :: kElementCost + Uniform :: kElementCost + 3 * PhiloxRandom :: kElementCost ; auto worker_threads = * ( ctx -> device ( ) -> tensorflow_cpu_worker_threads ( ) ) ; Shard ( worker_threads . num_threads , worker_threads . workers , num_alphas * samples_per_alpha , kElementCost , DoWork ) ; }
intrinsic_UnsafeCallWrappedFunction ( JSContext * cx , unsigned argc , Value * vp ) { CallArgs args = CallArgsFromVp ( argc , vp ) ; MOZ_ASSERT ( args . length ( ) >= 2 ) ; MOZ_ASSERT ( IsCallable ( args [ 0 ] ) ) ; MOZ_ASSERT ( IsWrapper ( & args [ 0 ] . toObject ( ) ) ) ; MOZ_ASSERT ( args [ 1 ] . isObject ( ) || args [ 1 ] . isUndefined ( ) ) ; MOZ_RELEASE_ASSERT ( args [ 0 ] . isObject ( ) ) ; RootedObject wrappedFun ( cx , & args [ 0 ] . toObject ( ) ) ; RootedObject fun ( cx , UncheckedUnwrap ( wrappedFun ) ) ; MOZ_RELEASE_ASSERT ( fun -> is < JSFunction > ( ) ) ; MOZ_RELEASE_ASSERT ( fun -> as < JSFunction > ( ) . isSelfHostedOrIntrinsic ( ) ) ; InvokeArgs args2 ( cx ) ; if ( ! args2 . init ( args . length ( ) - 2 ) ) return false ; args2 . setThis ( args [ 1 ] ) ; for ( size_t i = 0 ; i < args2 . length ( ) ; i ++ ) args2 [ i ] . set ( args [ i + 2 ] ) ; AutoWaivePolicy waivePolicy ( cx , wrappedFun , JSID_VOIDHANDLE , BaseProxyHandler :: CALL ) ; if ( ! CrossCompartmentWrapper :: singleton . call ( cx , wrappedFun , args2 ) ) return false ; args . rval ( ) . set ( args2 . rval ( ) ) ; return true ; }
static noinline int hiddev_ioctl_usage ( struct hiddev * hiddev , unsigned int cmd , void __user * user_arg ) { struct hid_device * hid = hiddev -> hid ; struct hiddev_report_info rinfo ; struct hiddev_usage_ref_multi * uref_multi = NULL ; struct hiddev_usage_ref * uref ; struct hid_report * report ; struct hid_field * field ; int i ; uref_multi = kmalloc ( sizeof ( struct hiddev_usage_ref_multi ) , GFP_KERNEL ) ; if ( ! uref_multi ) return - ENOMEM ; uref = & uref_multi -> uref ; if ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) { if ( copy_from_user ( uref_multi , user_arg , sizeof ( * uref_multi ) ) ) goto fault ; } else { if ( copy_from_user ( uref , user_arg , sizeof ( * uref ) ) ) goto fault ; } switch ( cmd ) { case HIDIOCGUCODE : rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( uref -> usage_index >= field -> maxusage ) goto inval ; uref -> usage_code = field -> usage [ uref -> usage_index ] . hid ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; default : if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT ) goto inval ; if ( uref -> report_id == HID_REPORT_ID_UNKNOWN ) { field = hiddev_lookup_usage ( hid , uref ) ; if ( field == NULL ) goto inval ; } else { rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( cmd == HIDIOCGCOLLECTIONINDEX ) { if ( uref -> usage_index >= field -> maxusage ) goto inval ; } else if ( uref -> usage_index >= field -> report_count ) goto inval ; else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ; } switch ( cmd ) { case HIDIOCGUSAGE : uref -> value = field -> value [ uref -> usage_index ] ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGE : field -> value [ uref -> usage_index ] = uref -> value ; goto goodreturn ; case HIDIOCGCOLLECTIONINDEX : i = field -> usage [ uref -> usage_index ] . collection_index ; kfree ( uref_multi ) ; return i ; case HIDIOCGUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) uref_multi -> values [ i ] = field -> value [ uref -> usage_index + i ] ; if ( copy_to_user ( user_arg , uref_multi , sizeof ( * uref_multi ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) field -> value [ uref -> usage_index + i ] = uref_multi -> values [ i ] ; goto goodreturn ; } goodreturn : kfree ( uref_multi ) ; return 0 ; fault : kfree ( uref_multi ) ; return - EFAULT ; inval : kfree ( uref_multi ) ; return - EINVAL ; } }
Status DoCompute ( OpKernelContext * ctx ) { tensorflow :: ResourceTagger tag ( kTFDataResourceTag , ctx -> op_kernel ( ) . type_string ( ) ) ; tstring filename ; TF_RETURN_IF_ERROR ( ParseScalarArgument < tstring > ( ctx , "filename" , & filename ) ) ; tstring compression_type ; TF_RETURN_IF_ERROR ( ParseScalarArgument < tstring > ( ctx , "compression_type" , & compression_type ) ) ; std :: unique_ptr < WritableFile > file ; TF_RETURN_IF_ERROR ( ctx -> env ( ) -> NewWritableFile ( filename , & file ) ) ; auto writer = absl :: make_unique < io :: RecordWriter > ( file . get ( ) , io :: RecordWriterOptions :: CreateRecordWriterOptions ( compression_type ) ) ; DatasetBase * dataset ; TF_RETURN_IF_ERROR ( GetDatasetFromVariantTensor ( ctx -> input ( 0 ) , & dataset ) ) ; IteratorContext :: Params params ( ctx ) ; FunctionHandleCache function_handle_cache ( params . flr ) ; params . function_handle_cache = & function_handle_cache ; ResourceMgr resource_mgr ; params . resource_mgr = & resource_mgr ; CancellationManager cancellation_manager ( ctx -> cancellation_manager ( ) ) ; params . cancellation_manager = & cancellation_manager ; IteratorContext iter_ctx ( std :: move ( params ) ) ; DatasetBase * finalized_dataset ; TF_RETURN_IF_ERROR ( FinalizeDataset ( ctx , dataset , & finalized_dataset ) ) ; std :: unique_ptr < IteratorBase > iterator ; TF_RETURN_IF_ERROR ( finalized_dataset -> MakeIterator ( & iter_ctx , nullptr , "ToTFRecordOpIterator" , & iterator ) ) ; std :: vector < Tensor > components ; components . reserve ( finalized_dataset -> output_dtypes ( ) . size ( ) ) ; bool end_of_sequence ; do { TF_RETURN_IF_ERROR ( iterator -> GetNext ( & iter_ctx , & components , & end_of_sequence ) ) ; if ( ! end_of_sequence ) { TF_RETURN_IF_ERROR ( writer -> WriteRecord ( components [ 0 ] . scalar < tstring > ( ) ( ) ) ) ; } components . clear ( ) ; } while ( ! end_of_sequence ) ; return Status :: OK ( ) ; }
nsPlaceholderFrame :: Destroy ( ) { nsIPresShell * shell = PresContext ( ) -> GetPresShell ( ) ; if ( shell && mOutOfFlowFrame ) { NS_ASSERTION ( ! shell -> FrameManager ( ) -> GetPlaceholderFrameFor ( mOutOfFlowFrame ) , "Placeholder relationship should have been torn down; see " "comments in nsPlaceholderFrame.h" ) ; } nsSplittableFrame :: Destroy ( ) ; }
LazyScriptHashPolicy :: match ( JSScript * script , const Lookup & lookup ) { JSContext * cx = lookup . cx ; LazyScript * lazy = lookup . lazy ; if ( script -> lineno != lazy -> lineno ( ) || script -> column != lazy -> column ( ) || script -> getVersion ( ) != lazy -> version ( ) || script -> sourceStart != lazy -> begin ( ) || script -> sourceEnd != lazy -> end ( ) ) { return false ; } AutoSuppressGC suppress ( cx ) ; const jschar * scriptChars = script -> scriptSource ( ) -> chars ( cx ) ; if ( ! scriptChars ) return false ; const jschar * lazyChars = lazy -> source ( ) -> chars ( cx ) ; if ( ! lazyChars ) return false ; size_t begin = script -> sourceStart ; size_t length = script -> sourceEnd - begin ; return ! memcmp ( scriptChars + begin , lazyChars + begin , length ) ; }
static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled , int mi_row , int mi_col , BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCK * const x = & cpi -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; MODE_INFO * * mi_8x8 = xd -> mi ; MODE_INFO * mi = mi_8x8 [ 0 ] ; MB_MODE_INFO * mbmi = & mi -> mbmi ; PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; unsigned int segment_id = mbmi -> segment_id ; const int mis = cm -> mi_stride ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; x -> skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 && cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ; x -> skip_optimize = ctx -> is_coded ; ctx -> is_coded = 1 ; x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ; x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ) ; if ( x -> skip_encode ) return ; if ( cm -> frame_type == KEY_FRAME ) { if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; vp9_update_zbin_extra ( cpi , x ) ; } } else { set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ; if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; } cpi -> zbin_mode_boost = get_zbin_mode_boost ( mbmi , cpi -> zbin_mode_boost_enabled ) ; vp9_update_zbin_extra ( cpi , x ) ; } if ( ! is_inter_block ( mbmi ) ) { int plane ; mbmi -> skip = 1 ; for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; if ( output_enabled ) sum_intra_stats ( & cm -> counts , mi ) ; vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; } else { int ref ; const int is_compound = has_second_ref ( mbmi ) ; for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) { YV12_BUFFER_CONFIG * cfg = get_ref_frame_buffer ( cpi , mbmi -> ref_frame [ ref ] ) ; vp9_setup_pre_planes ( xd , ref , cfg , mi_row , mi_col , & xd -> block_refs [ ref ] -> sf ) ; } vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ; if ( ! x -> skip ) { mbmi -> skip = 1 ; vp9_encode_sb ( x , MAX ( bsize , BLOCK_8X8 ) ) ; vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; } else { mbmi -> skip = 1 ; if ( output_enabled ) cm -> counts . skip [ vp9_get_skip_context ( xd ) ] [ 1 ] ++ ; reset_skip_context ( xd , MAX ( bsize , BLOCK_8X8 ) ) ; } } if ( output_enabled ) { if ( cm -> tx_mode == TX_MODE_SELECT && mbmi -> sb_type >= BLOCK_8X8 && ! ( is_inter_block ( mbmi ) && ( mbmi -> skip || vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) ) ) { ++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) , & cm -> counts . tx ) [ mbmi -> tx_size ] ; } else { int x , y ; TX_SIZE tx_size ; if ( is_inter_block ( & mi -> mbmi ) ) { tx_size = MIN ( tx_mode_to_biggest_tx_size [ cm -> tx_mode ] , max_txsize_lookup [ bsize ] ) ; } else { tx_size = ( bsize >= BLOCK_8X8 ) ? mbmi -> tx_size : TX_4X4 ; } for ( y = 0 ; y < mi_height ; y ++ ) for ( x = 0 ; x < mi_width ; x ++ ) if ( mi_col + x < cm -> mi_cols && mi_row + y < cm -> mi_rows ) mi_8x8 [ mis * y + x ] -> mbmi . tx_size = tx_size ; } } }
void DecodeTypeSection ( ) { uint32_t signatures_count = consume_count ( "types count" , kV8MaxWasmTypes ) ; module_ -> signatures . reserve ( signatures_count ) ; for ( uint32_t i = 0 ; ok ( ) && i < signatures_count ; ++ i ) { TRACE ( "DecodeSignature[%d] module+%d\n" , i , static_cast < int > ( pc_ - start_ ) ) ; FunctionSig * s = consume_sig ( module_ -> signature_zone . get ( ) ) ; module_ -> signatures . push_back ( s ) ; uint32_t id = s ? module_ -> signature_map . FindOrInsert ( * s ) : 0 ; module_ -> signature_ids . push_back ( id ) ; } module_ -> signature_map . Freeze ( ) ; }
double AIXTimezoneCache :: LocalTimeOffset ( double time_ms , bool is_utc ) { time_t utc = time ( nullptr ) ; DCHECK_NE ( utc , - 1 ) ; struct tm tm ; struct tm * loc = localtime_r ( & utc , & tm ) ; DCHECK_NOT_NULL ( loc ) ; return static_cast < double > ( ( mktime ( loc ) - utc ) * msPerSecond ) ; }
nsDisplayTableBackgroundSet :: nsDisplayTableBackgroundSet ( nsDisplayListBuilder * aBuilder , nsIFrame * aTable ) : mBuilder ( aBuilder ) { mPrevTableBackgroundSet = mBuilder -> SetTableBackgroundSet ( this ) ; mozilla :: DebugOnly < const nsIFrame * > reference = mBuilder -> FindReferenceFrameFor ( aTable , & mToReferenceFrame ) ; MOZ_ASSERT ( nsLayoutUtils :: FindNearestCommonAncestorFrame ( reference , aTable ) ) ; mDirtyRect = mBuilder -> GetDirtyRect ( ) ; }
Handle < JSModuleNamespace > Module :: GetModuleNamespace ( Isolate * isolate , Handle < Module > module ) { Handle < HeapObject > object ( module -> module_namespace ( ) , isolate ) ; ReadOnlyRoots roots ( isolate ) ; if ( ! object -> IsUndefined ( roots ) ) { return Handle < JSModuleNamespace > :: cast ( object ) ; } Zone zone ( isolate -> allocator ( ) , ZONE_NAME ) ; UnorderedModuleSet visited ( & zone ) ; FetchStarExports ( isolate , module , & zone , & visited ) ; Handle < ObjectHashTable > exports ( module -> exports ( ) , isolate ) ; ZoneVector < Handle < String > > names ( & zone ) ; names . reserve ( exports -> NumberOfElements ( ) ) ; for ( int i = 0 , n = exports -> Capacity ( ) ; i < n ; ++ i ) { Object * key ; if ( ! exports -> ToKey ( roots , i , & key ) ) continue ; names . push_back ( handle ( String :: cast ( key ) , isolate ) ) ; } DCHECK_EQ ( static_cast < int > ( names . size ( ) ) , exports -> NumberOfElements ( ) ) ; std :: sort ( names . begin ( ) , names . end ( ) , [ & isolate ] ( Handle < String > a , Handle < String > b ) { return String :: Compare ( isolate , a , b ) == ComparisonResult :: kLessThan ; } ) ; Handle < JSModuleNamespace > ns = isolate -> factory ( ) -> NewJSModuleNamespace ( ) ; ns -> set_module ( * module ) ; module -> set_module_namespace ( * ns ) ; PropertyAttributes attr = DONT_DELETE ; JSObject :: NormalizeProperties ( ns , CLEAR_INOBJECT_PROPERTIES , static_cast < int > ( names . size ( ) ) , "JSModuleNamespace" ) ; for ( const auto & name : names ) { JSObject :: SetNormalizedProperty ( ns , name , Accessors :: MakeModuleNamespaceEntryInfo ( isolate , name ) , PropertyDetails ( kAccessor , attr , PropertyCellType :: kMutable ) ) ; } JSObject :: PreventExtensions ( ns , kThrowOnError ) . ToChecked ( ) ; JSObject :: OptimizeAsPrototype ( ns ) ; Handle < PrototypeInfo > proto_info = Map :: GetOrCreatePrototypeInfo ( Handle < JSObject > :: cast ( ns ) , isolate ) ; proto_info -> set_module_namespace ( * ns ) ; return ns ; }
void ConcurrentMarking :: RescheduleTasksIfNeeded ( ) { if ( ! FLAG_concurrent_marking || heap_ -> IsTearingDown ( ) ) return ; { base :: LockGuard < base :: Mutex > guard ( & pending_lock_ ) ; if ( pending_task_count_ > 0 ) return ; } if ( ! shared_ -> IsGlobalPoolEmpty ( ) || ! weak_objects_ -> current_ephemerons . IsEmpty ( ) || ! weak_objects_ -> discovered_ephemerons . IsEmpty ( ) ) { ScheduleTasks ( ) ; } }
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
static void push_bracket ( subject * subj , bool image , cmark_node * inl_text ) { bracket * b = ( bracket * ) subj -> mem -> calloc ( 1 , sizeof ( bracket ) ) ; if ( subj -> last_bracket != NULL ) { subj -> last_bracket -> bracket_after = true ; } b -> image = image ; b -> active = true ; b -> inl_text = inl_text ; b -> previous = subj -> last_bracket ; b -> previous_delimiter = subj -> last_delim ; b -> position = subj -> pos ; b -> bracket_after = false ; subj -> last_bracket = b ; }
TrackBuffer :: InitializeDecoder ( SourceBufferDecoder * aDecoder ) { if ( ! mParentDecoder ) { MSE_DEBUG ( "decoder was shutdown. Aborting initialization." ) ; return ; } mParentDecoder -> GetReentrantMonitor ( ) . AssertNotCurrentThreadIn ( ) ; ReentrantMonitorAutoEnter mon ( mParentDecoder -> GetReentrantMonitor ( ) ) ; if ( mCurrentDecoder != aDecoder ) { MSE_DEBUG ( "append was cancelled. Aborting initialization." ) ; return ; } if ( mShutdown ) { MSE_DEBUG ( "was shut down. Aborting initialization." ) ; RemoveDecoder ( aDecoder ) ; return ; } MOZ_ASSERT ( mTaskQueue -> IsCurrentThreadIn ( ) ) ; MediaDecoderReader * reader = aDecoder -> GetReader ( ) ; MSE_DEBUG ( "Initializing subdecoder %p reader %p" , aDecoder , reader ) ; MediaInfo mi ; nsAutoPtr < MetadataTags > tags ; nsresult rv ; bool wasEnded = aDecoder -> GetResource ( ) -> IsEnded ( ) ; if ( ! wasEnded ) { aDecoder -> GetResource ( ) -> Ended ( ) ; } { ReentrantMonitorAutoExit mon ( mParentDecoder -> GetReentrantMonitor ( ) ) ; rv = reader -> ReadMetadata ( & mi , getter_Transfers ( tags ) ) ; } if ( ! wasEnded ) { nsRefPtr < LargeDataBuffer > emptyBuffer = new LargeDataBuffer ; aDecoder -> GetResource ( ) -> AppendData ( emptyBuffer ) ; } reader -> SetIdle ( ) ; if ( mShutdown ) { MSE_DEBUG ( "was shut down while reading metadata. Aborting initialization." ) ; return ; } if ( NS_SUCCEEDED ( rv ) && reader -> IsWaitingOnCDMResource ( ) ) { mWaitingDecoders . AppendElement ( aDecoder ) ; return ; } aDecoder -> SetTaskQueue ( nullptr ) ; if ( NS_FAILED ( rv ) || ( ! mi . HasVideo ( ) && ! mi . HasAudio ( ) ) ) { MSE_DEBUG ( "Reader %p failed to initialize rv=%x audio=%d video=%d" , reader , rv , mi . HasAudio ( ) , mi . HasVideo ( ) ) ; RemoveDecoder ( aDecoder ) ; mInitializationPromise . RejectIfExists ( NS_ERROR_FAILURE , __func__ ) ; return ; } if ( mi . HasVideo ( ) ) { MSE_DEBUG ( "Reader %p video resolution=%dx%d" , reader , mi . mVideo . mDisplay . width , mi . mVideo . mDisplay . height ) ; } if ( mi . HasAudio ( ) ) { MSE_DEBUG ( "Reader %p audio sampleRate=%d channels=%d" , reader , mi . mAudio . mRate , mi . mAudio . mChannels ) ; } RefPtr < nsIRunnable > task = NS_NewRunnableMethodWithArg < SourceBufferDecoder * > ( this , & TrackBuffer :: CompleteInitializeDecoder , aDecoder ) ; if ( NS_FAILED ( NS_DispatchToMainThread ( task ) ) ) { MSE_DEBUG ( "Failed to enqueue decoder initialization task" ) ; RemoveDecoder ( aDecoder ) ; mInitializationPromise . RejectIfExists ( NS_ERROR_FAILURE , __func__ ) ; return ; } }
png_set_rgb_to_gray_fixed ( png_structrp png_ptr , int error_action , png_fixed_point red , png_fixed_point green ) { png_debug ( 1 , "in png_set_rgb_to_gray" ) ; if ( ! png_rtran_ok ( png_ptr , 1 ) ) return ; switch ( error_action ) { case PNG_ERROR_ACTION_NONE : png_ptr -> transformations |= PNG_RGB_TO_GRAY ; break ; case PNG_ERROR_ACTION_WARN : png_ptr -> transformations |= PNG_RGB_TO_GRAY_WARN ; break ; case PNG_ERROR_ACTION_ERROR : png_ptr -> transformations |= PNG_RGB_TO_GRAY_ERR ; break ; default : png_error ( png_ptr , "invalid error action to rgb_to_gray" ) ; break ; } if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE ) #ifdef PNG_READ_EXPAND_SUPPORTED png_ptr -> transformations |= PNG_EXPAND ; #else { png_error ( png_ptr , "Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED" ) ; } #endif { if ( red >= 0 && green >= 0 && red + green <= PNG_FP_1 ) { png_uint_16 red_int , green_int ; red_int = ( png_uint_16 ) ( ( ( png_uint_32 ) red * 32768 ) / 100000 ) ; green_int = ( png_uint_16 ) ( ( ( png_uint_32 ) green * 32768 ) / 100000 ) ; png_ptr -> rgb_to_gray_red_coeff = red_int ; png_ptr -> rgb_to_gray_green_coeff = green_int ; png_ptr -> rgb_to_gray_coefficients_set = 1 ; } else { if ( red >= 0 && green >= 0 ) png_app_warning ( png_ptr , "ignoring out of range rgb_to_gray coefficients" ) ; if ( png_ptr -> rgb_to_gray_red_coeff == 0 && png_ptr -> rgb_to_gray_green_coeff == 0 ) { png_ptr -> rgb_to_gray_red_coeff = 6968 ; png_ptr -> rgb_to_gray_green_coeff = 23434 ; } } } }
static pj_status_t alloc_codec ( pjmedia_codec_factory * factory , const pjmedia_codec_info * id , pjmedia_codec * * p_codec ) { codec_private_t * codec_data ; pjmedia_codec * codec ; int idx ; pj_pool_t * pool ; unsigned i ; PJ_ASSERT_RETURN ( factory && id && p_codec , PJ_EINVAL ) ; PJ_ASSERT_RETURN ( factory == & codec_factory . base , PJ_EINVAL ) ; pj_mutex_lock ( codec_factory . mutex ) ; idx = - 1 ; for ( i = 0 ; i < PJ_ARRAY_SIZE ( codec_desc ) ; ++ i ) { pj_str_t name = pj_str ( ( char * ) codec_desc [ i ] . name ) ; if ( ( pj_stricmp ( & id -> encoding_name , & name ) == 0 ) && ( id -> clock_rate == ( unsigned ) codec_desc [ i ] . clock_rate ) && ( id -> channel_cnt == ( unsigned ) codec_desc [ i ] . channel_count ) && ( codec_desc [ i ] . enabled ) ) { idx = i ; break ; } } if ( idx == - 1 ) { * p_codec = NULL ; return PJMEDIA_CODEC_EUNSUP ; } pool = pjmedia_endpt_create_pool ( codec_factory . endpt , "passthroughcodec" , 512 , 512 ) ; codec = PJ_POOL_ZALLOC_T ( pool , pjmedia_codec ) ; codec -> op = & codec_op ; codec -> factory = factory ; codec -> codec_data = PJ_POOL_ZALLOC_T ( pool , codec_private_t ) ; codec_data = ( codec_private_t * ) codec -> codec_data ; codec_data -> pool = pool ; codec_data -> codec_idx = idx ; pj_mutex_unlock ( codec_factory . mutex ) ; * p_codec = codec ; return PJ_SUCCESS ; }
static int ocfs2_dio_get_block ( struct inode * inode , sector_t iblock , struct buffer_head * bh_result , int create ) { struct ocfs2_super * osb = OCFS2_SB ( inode -> i_sb ) ; struct ocfs2_inode_info * oi = OCFS2_I ( inode ) ; struct ocfs2_write_ctxt * wc ; struct ocfs2_write_cluster_desc * desc = NULL ; struct ocfs2_dio_write_ctxt * dwc = NULL ; struct buffer_head * di_bh = NULL ; u64 p_blkno ; loff_t pos = iblock < < inode -> i_sb -> s_blocksize_bits ; unsigned len , total_len = bh_result -> b_size ; int ret = 0 , first_get_block = 0 ; len = osb -> s_clustersize - ( pos & ( osb -> s_clustersize - 1 ) ) ; len = min ( total_len , len ) ; mlog ( 0 , "get block of %lu at %llu:%u req %u\n" , inode -> i_ino , pos , len , total_len ) ; if ( pos + total_len <= i_size_read ( inode ) ) { down_read ( & oi -> ip_alloc_sem ) ; ret = ocfs2_get_block ( inode , iblock , bh_result , create ) ; up_read ( & oi -> ip_alloc_sem ) ; if ( buffer_mapped ( bh_result ) && ! buffer_new ( bh_result ) && ret == 0 ) goto out ; bh_result -> b_state = 0 ; } dwc = ocfs2_dio_alloc_write_ctx ( bh_result , & first_get_block ) ; if ( unlikely ( dwc == NULL ) ) { ret = - ENOMEM ; mlog_errno ( ret ) ; goto out ; } if ( ocfs2_clusters_for_bytes ( inode -> i_sb , pos + total_len ) > ocfs2_clusters_for_bytes ( inode -> i_sb , i_size_read ( inode ) ) && ! dwc -> dw_orphaned ) { ret = ocfs2_add_inode_to_orphan ( osb , inode ) ; if ( ret < 0 ) { mlog_errno ( ret ) ; goto out ; } dwc -> dw_orphaned = 1 ; } ret = ocfs2_inode_lock ( inode , & di_bh , 1 ) ; if ( ret ) { mlog_errno ( ret ) ; goto out ; } down_write ( & oi -> ip_alloc_sem ) ; if ( first_get_block ) { if ( ocfs2_sparse_alloc ( OCFS2_SB ( inode -> i_sb ) ) ) ret = ocfs2_zero_tail ( inode , di_bh , pos ) ; else ret = ocfs2_expand_nonsparse_inode ( inode , di_bh , pos , total_len , NULL ) ; if ( ret < 0 ) { mlog_errno ( ret ) ; goto unlock ; } } ret = ocfs2_write_begin_nolock ( inode -> i_mapping , pos , len , OCFS2_WRITE_DIRECT , NULL , ( void * * ) & wc , di_bh , NULL ) ; if ( ret ) { mlog_errno ( ret ) ; goto unlock ; } desc = & wc -> w_desc [ 0 ] ; p_blkno = ocfs2_clusters_to_blocks ( inode -> i_sb , desc -> c_phys ) ; BUG_ON ( p_blkno == 0 ) ; p_blkno += iblock & ( u64 ) ( ocfs2_clusters_to_blocks ( inode -> i_sb , 1 ) - 1 ) ; map_bh ( bh_result , inode -> i_sb , p_blkno ) ; bh_result -> b_size = len ; if ( desc -> c_needs_zero ) set_buffer_new ( bh_result ) ; set_buffer_defer_completion ( bh_result ) ; if ( ! list_empty ( & wc -> w_unwritten_list ) ) { struct ocfs2_unwritten_extent * ue = NULL ; ue = list_first_entry ( & wc -> w_unwritten_list , struct ocfs2_unwritten_extent , ue_node ) ; BUG_ON ( ue -> ue_cpos != desc -> c_cpos ) ; ue -> ue_phys = desc -> c_phys ; list_splice_tail_init ( & wc -> w_unwritten_list , & dwc -> dw_zero_list ) ; dwc -> dw_zero_count ++ ; } ret = ocfs2_write_end_nolock ( inode -> i_mapping , pos , len , len , wc ) ; BUG_ON ( ret != len ) ; ret = 0 ; unlock : up_write ( & oi -> ip_alloc_sem ) ; ocfs2_inode_unlock ( inode , 1 ) ; brelse ( di_bh ) ; out : if ( ret < 0 ) ret = - EIO ; return ret ; }
static ssize_t _hostfs_readv ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; if ( ! file || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( oe_syscall_readv_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret > 0 ) { if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) ; } done : if ( buf ) oe_free ( buf ) ; return ret ; }
CrossProcessCompositorParent :: DidComposite ( uint64_t aId ) { LayerTransactionParent * layerTree = sIndirectLayerTrees [ aId ] . mLayerTree ; if ( layerTree && layerTree -> GetPendingTransactionId ( ) ) { unused < < SendDidComposite ( aId , layerTree -> GetPendingTransactionId ( ) ) ; layerTree -> SetPendingTransactionId ( 0 ) ; } }
WriteBarrierKind WriteBarrierKindFor ( BaseTaggedness base_taggedness , MachineRepresentation field_representation , Type field_type , MachineRepresentation value_representation , Node * value ) { if ( base_taggedness == kTaggedBase && CanBeTaggedPointer ( field_representation ) ) { Type value_type = NodeProperties :: GetType ( value ) ; if ( field_representation == MachineRepresentation :: kTaggedSigned || value_representation == MachineRepresentation :: kTaggedSigned ) { return kNoWriteBarrier ; } if ( field_type . Is ( Type :: BooleanOrNullOrUndefined ( ) ) || value_type . Is ( Type :: BooleanOrNullOrUndefined ( ) ) ) { return kNoWriteBarrier ; } if ( value_type . IsHeapConstant ( ) ) { Heap :: RootListIndex root_index ; Heap * heap = jsgraph_ -> isolate ( ) -> heap ( ) ; if ( heap -> IsRootHandle ( value_type . AsHeapConstant ( ) -> Value ( ) , & root_index ) ) { if ( heap -> RootIsImmortalImmovable ( root_index ) ) { return kNoWriteBarrier ; } } } if ( field_representation == MachineRepresentation :: kTaggedPointer || value_representation == MachineRepresentation :: kTaggedPointer ) { return kPointerWriteBarrier ; } NumberMatcher m ( value ) ; if ( m . HasValue ( ) ) { if ( IsSmiDouble ( m . Value ( ) ) ) { return kNoWriteBarrier ; } return kPointerWriteBarrier ; } return kFullWriteBarrier ; } return kNoWriteBarrier ; }
void CuePoint :: Load ( IMkvReader * pReader ) { if ( m_timecode >= 0 ) return ; assert ( m_track_positions == NULL ) ; assert ( m_track_positions_count == 0 ) ; long long pos_ = - m_timecode ; const long long element_start = pos_ ; long long stop ; { long len ; const long long id = ReadUInt ( pReader , pos_ , len ) ; assert ( id == 0x3B ) ; if ( id != 0x3B ) return ; pos_ += len ; const long long size = ReadUInt ( pReader , pos_ , len ) ; assert ( size >= 0 ) ; pos_ += len ; stop = pos_ + size ; } const long long element_size = stop - element_start ; long long pos = pos_ ; while ( pos < stop ) { long len ; const long long id = ReadUInt ( pReader , pos , len ) ; assert ( id >= 0 ) ; assert ( ( pos + len ) <= stop ) ; pos += len ; const long long size = ReadUInt ( pReader , pos , len ) ; assert ( size >= 0 ) ; assert ( ( pos + len ) <= stop ) ; pos += len ; assert ( ( pos + size ) <= stop ) ; if ( id == 0x33 ) m_timecode = UnserializeUInt ( pReader , pos , size ) ; else if ( id == 0x37 ) ++ m_track_positions_count ; pos += size ; assert ( pos <= stop ) ; } assert ( m_timecode >= 0 ) ; assert ( m_track_positions_count > 0 ) ; m_track_positions = new TrackPosition [ m_track_positions_count ] ; TrackPosition * p = m_track_positions ; pos = pos_ ; while ( pos < stop ) { long len ; const long long id = ReadUInt ( pReader , pos , len ) ; assert ( id >= 0 ) ; assert ( ( pos + len ) <= stop ) ; pos += len ; const long long size = ReadUInt ( pReader , pos , len ) ; assert ( size >= 0 ) ; assert ( ( pos + len ) <= stop ) ; pos += len ; assert ( ( pos + size ) <= stop ) ; if ( id == 0x37 ) { TrackPosition & tp = * p ++ ; tp . Parse ( pReader , pos , size ) ; } pos += size ; assert ( pos <= stop ) ; } assert ( size_t ( p - m_track_positions ) == m_track_positions_count ) ; m_element_start = element_start ; m_element_size = element_size ; }
nsXBLProtoImplAnonymousMethod :: Execute ( nsIContent * aBoundElement ) { NS_PRECONDITION ( IsCompiled ( ) , "Can't execute uncompiled method" ) ; if ( ! mJSMethodObject ) { return NS_OK ; } nsIDocument * document = aBoundElement -> OwnerDoc ( ) ; nsIScriptGlobalObject * global = document -> GetScriptGlobalObject ( ) ; if ( ! global ) { return NS_OK ; } nsCOMPtr < nsIScriptContext > context = global -> GetContext ( ) ; if ( ! context ) { return NS_OK ; } nsAutoMicroTask mt ; JSContext * cx = context -> GetNativeContext ( ) ; JSObject * globalObject = global -> GetGlobalJSObject ( ) ; nsCOMPtr < nsIXPConnectJSObjectHolder > wrapper ; jsval v ; nsresult rv = nsContentUtils :: WrapNative ( cx , globalObject , aBoundElement , & v , getter_AddRefs ( wrapper ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; JSObject * thisObject = JSVAL_TO_OBJECT ( v ) ; JSAutoRequest ar ( cx ) ; JSAutoCompartment ac ( cx , thisObject ) ; JSObject * method = :: JS_CloneFunctionObject ( cx , mJSMethodObject , thisObject ) ; if ( ! method ) return NS_ERROR_OUT_OF_MEMORY ; nsCxPusher pusher ; NS_ENSURE_STATE ( pusher . Push ( aBoundElement ) ) ; rv = nsContentUtils :: GetSecurityManager ( ) -> CheckFunctionAccess ( cx , method , thisObject ) ; JSBool ok = JS_TRUE ; if ( NS_SUCCEEDED ( rv ) ) { jsval retval ; ok = :: JS_CallFunctionValue ( cx , thisObject , OBJECT_TO_JSVAL ( method ) , 0 , nullptr , & retval ) ; } if ( ! ok ) { JSBool saved = JS_SaveFrameChain ( cx ) ; JS_ReportPendingException ( cx ) ; if ( saved ) JS_RestoreFrameChain ( cx ) ; return NS_ERROR_FAILURE ; } return NS_OK ; }
png_set_cHRM_XYZ_fixed ( png_const_structrp png_ptr , png_inforp info_ptr , png_fixed_point int_red_X , png_fixed_point int_red_Y , png_fixed_point int_red_Z , png_fixed_point int_green_X , png_fixed_point int_green_Y , png_fixed_point int_green_Z , png_fixed_point int_blue_X , png_fixed_point int_blue_Y , png_fixed_point int_blue_Z ) { png_XYZ XYZ ; png_debug1 ( 1 , "in %s storage function" , "cHRM XYZ fixed" ) ; if ( png_ptr == NULL || info_ptr == NULL ) return ; XYZ . red_X = int_red_X ; XYZ . red_Y = int_red_Y ; XYZ . red_Z = int_red_Z ; XYZ . green_X = int_green_X ; XYZ . green_Y = int_green_Y ; XYZ . green_Z = int_green_Z ; XYZ . blue_X = int_blue_X ; XYZ . blue_Y = int_blue_Y ; XYZ . blue_Z = int_blue_Z ; if ( png_colorspace_set_endpoints ( png_ptr , & info_ptr -> colorspace , & XYZ , 2 ) ) info_ptr -> colorspace . flags |= PNG_COLORSPACE_FROM_cHRM ; png_colorspace_sync_info ( png_ptr , info_ptr ) ; }
static void iwjpeg_scan_exif ( struct iwjpegrcontext * rctx , const iw_byte * d , size_t d_len ) { struct iw_exif_state e ; iw_uint32 ifd ; if ( d_len < 8 ) return ; iw_zeromem ( & e , sizeof ( struct iw_exif_state ) ) ; e . d = d ; e . d_len = d_len ; e . endian = d [ 0 ] == 'I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG ; ifd = iw_get_ui32_e ( & d [ 4 ] , e . endian ) ; iwjpeg_scan_exif_ifd ( rctx , & e , ifd ) ; }
nsJARChannel :: SetContentType ( const nsACString & aContentType ) { NS_ParseContentType ( aContentType , mContentType , mContentCharset ) ; return NS_OK ; }
xmlParserGetDirectory ( const char * filename ) { char * ret = NULL ; char dir [ 1024 ] ; char * cur ; #ifdef _WIN32_WCE  /* easy way by now ... wince does not have dirs! */ return NULL ; #endif if ( xmlInputCallbackInitialized == 0 ) xmlRegisterDefaultInputCallbacks ( ) ; if ( filename == NULL ) return ( NULL ) ; #if defined(WIN32) && !defined(__CYGWIN__) #   define IS_XMLPGD_SEP(ch) ((ch=='/')||(ch=='\\')) #else #   define IS_XMLPGD_SEP(ch) (ch=='/') #endif strncpy ( dir , filename , 1023 ) ; dir [ 1023 ] = 0 ; cur = & dir [ strlen ( dir ) ] ; while ( cur > dir ) { if ( IS_XMLPGD_SEP ( * cur ) ) break ; cur -- ; } if ( IS_XMLPGD_SEP ( * cur ) ) { if ( cur == dir ) dir [ 1 ] = 0 ; else * cur = 0 ; ret = xmlMemStrdup ( dir ) ; } else { if ( getcwd ( dir , 1024 ) != NULL ) { dir [ 1023 ] = 0 ; ret = xmlMemStrdup ( dir ) ; } } return ( ret ) ; #undef IS_XMLPGD_SEP }
standard_info_part2 ( standard_display * dp , png_const_structp pp , png_const_infop pi , int nImages ) { dp -> pixel_size = bit_size ( pp , png_get_color_type ( pp , pi ) , png_get_bit_depth ( pp , pi ) ) ; dp -> bit_width = png_get_image_width ( pp , pi ) * dp -> pixel_size ; dp -> cbRow = png_get_rowbytes ( pp , pi ) ; if ( dp -> cbRow != ( dp -> bit_width + 7 ) / 8 ) png_error ( pp , "bad png_get_rowbytes calculation" ) ; store_ensure_image ( dp -> ps , pp , nImages , dp -> cbRow , dp -> h ) ; }
static MagickBooleanType SkipDXTMipmaps ( Image * image , DDSInfo * dds_info , int texel_size , ExceptionInfo * exception ) { MagickOffsetType offset ; register ssize_t i ; size_t h , w ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; return ( MagickFalse ) ; } if ( dds_info -> ddscaps1 & DDSCAPS_MIPMAP && ( dds_info -> ddscaps1 & DDSCAPS_TEXTURE || dds_info -> ddscaps2 & DDSCAPS2_CUBEMAP ) ) { w = DIV2 ( dds_info -> width ) ; h = DIV2 ( dds_info -> height ) ; for ( i = 1 ; ( i < ( ssize_t ) dds_info -> mipmapcount ) && w && h ; i ++ ) { offset = ( MagickOffsetType ) ( ( w + 3 ) / 4 ) * ( ( h + 3 ) / 4 ) * texel_size ; ( void ) SeekBlob ( image , offset , SEEK_CUR ) ; w = DIV2 ( w ) ; h = DIV2 ( h ) ; }
FLAC__bool FLAC__memory_alloc_aligned_real_array ( unsigned elements , FLAC__real * * unaligned_pointer , FLAC__real * * aligned_pointer ) { FLAC__real * pu ; union { FLAC__real * pa ; void * pv ; } u ; FLAC__ASSERT ( elements > 0 ) ; FLAC__ASSERT ( 0 != unaligned_pointer ) ; FLAC__ASSERT ( 0 != aligned_pointer ) ; FLAC__ASSERT ( unaligned_pointer != aligned_pointer ) ; if ( ( size_t ) elements > SIZE_MAX / sizeof ( * pu ) ) return false ; pu = ( FLAC__real * ) FLAC__memory_alloc_aligned ( sizeof ( * pu ) * elements , & u . pv ) ; if ( 0 == pu ) { return false ; } else { if ( * unaligned_pointer != 0 ) free ( * unaligned_pointer ) ; * unaligned_pointer = pu ; * aligned_pointer = u . pa ; return true ; } }
Node * WasmGraphBuilder :: GrowMemory ( Node * input ) { SetNeedsStackCheck ( ) ; WasmGrowMemoryDescriptor interface_descriptor ; auto call_descriptor = Linkage :: GetStubCallDescriptor ( mcgraph ( ) -> zone ( ) , interface_descriptor , interface_descriptor . GetStackParameterCount ( ) , CallDescriptor :: kNoFlags , Operator :: kNoProperties , StubCallMode :: kCallWasmRuntimeStub ) ; Node * call_target = mcgraph ( ) -> RelocatableIntPtrConstant ( wasm :: WasmCode :: kWasmGrowMemory , RelocInfo :: WASM_STUB_CALL ) ; return SetEffect ( SetControl ( graph ( ) -> NewNode ( mcgraph ( ) -> common ( ) -> Call ( call_descriptor ) , call_target , input , Effect ( ) , Control ( ) ) ) ) ; }
ObjectRef JSObjectRef :: RawFastPropertyAt ( FieldIndex index ) const { AllowHandleAllocation handle_allocation ; AllowHandleDereference handle_dereference ; return ObjectRef ( broker ( ) , handle ( object < JSObject > ( ) -> RawFastPropertyAt ( index ) , broker ( ) -> isolate ( ) ) ) ; }
static char * r_socket_http_answer ( RSocket * s , int * code , int * rlen ) { r_return_val_if_fail ( s , NULL ) ; const char * p ; int ret , len = 0 , bufsz = 32768 , delta = 0 ; char * dn , * buf = calloc ( 1 , bufsz + 32 ) ; if ( ! buf ) { return NULL ; } char * res = NULL ; int olen = __socket_slurp ( s , ( ut8 * ) buf , bufsz ) ; if ( ( dn = ( char * ) r_str_casestr ( buf , "\n\n" ) ) ) { delta += 2 ; } else if ( ( dn = ( char * ) r_str_casestr ( buf , "\r\n\r\n" ) ) ) { delta += 4 ; } else { goto fail ; } olen -= delta ; * dn = 0 ; p = r_str_casestr ( buf , "Content-Length: " ) ; if ( p ) { len = atoi ( p + 16 ) ; } else { len = olen - ( dn - buf ) ; } if ( len > 0 ) { if ( len > olen ) { res = malloc ( len + 2 ) ; memcpy ( res , dn + delta , olen ) ; do { ret = r_socket_read_block ( s , ( ut8 * ) res + olen , len - olen ) ; if ( ret < 1 ) { break ; } olen += ret ; } while ( olen < len ) ; res [ len ] = 0 ; } else { res = malloc ( len + 1 ) ; if ( res ) { memcpy ( res , dn + delta , len ) ; res [ len ] = 0 ; } } } else { res = NULL ; } fail : free ( buf ) ; r_socket_close ( s ) ; if ( rlen ) { * rlen = len ; } return res ; }
static int vidioc_querycap ( struct file * file , void * priv , struct v4l2_capability * cap ) { struct v4l2_loopback_device * dev = v4l2loopback_getdevice ( file ) ; int labellen = ( sizeof ( cap -> card ) < sizeof ( dev -> card_label ) ) ? sizeof ( cap -> card ) : sizeof ( dev -> card_label ) ; int device_nr = ( ( struct v4l2loopback_private * ) video_get_drvdata ( dev -> vdev ) ) -> device_nr ; __u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE ; strlcpy ( cap -> driver , "v4l2 loopback" , sizeof ( cap -> driver ) ) ; snprintf ( cap -> card , labellen , dev -> card_label ) ; snprintf ( cap -> bus_info , sizeof ( cap -> bus_info ) , "platform:v4l2loopback-%03d" , device_nr ) ; #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0) cap -> version = V4L2LOOPBACK_VERSION_CODE ; #endif #ifdef V4L2_CAP_VIDEO_M2M capabilities |= V4L2_CAP_VIDEO_M2M ; #endif /* V4L2_CAP_VIDEO_M2M */ if ( dev -> announce_all_caps ) { capabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT ; } else { if ( dev -> ready_for_capture ) { capabilities |= V4L2_CAP_VIDEO_CAPTURE ; } if ( dev -> ready_for_output ) { capabilities |= V4L2_CAP_VIDEO_OUTPUT ; } } #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0) dev -> vdev -> device_caps = #endif /* >=linux-4.7.0 */ cap -> device_caps = cap -> capabilities = capabilities ; #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0) cap -> capabilities |= V4L2_CAP_DEVICE_CAPS ; #endif memset ( cap -> reserved , 0 , sizeof ( cap -> reserved ) ) ; return 0 ; }
void AsmJsParser :: ValidateModuleVar ( bool mutable_variable ) { if ( ! scanner_ . IsGlobal ( ) ) { FAIL ( "Expected identifier" ) ; } VarInfo * info = GetVarInfo ( Consume ( ) ) ; if ( info -> kind != VarKind :: kUnused ) { FAIL ( "Redefinition of variable" ) ; } EXPECT_TOKEN ( '=' ) ; double dvalue = 0.0 ; uint32_t uvalue = 0 ; if ( CheckForDouble ( & dvalue ) ) { DeclareGlobal ( info , mutable_variable , AsmType :: Double ( ) , kWasmF64 , WasmInitExpr ( dvalue ) ) ; } else if ( CheckForUnsigned ( & uvalue ) ) { if ( uvalue > 0x7FFFFFFF ) { FAIL ( "Numeric literal out of range" ) ; } DeclareGlobal ( info , mutable_variable , mutable_variable ? AsmType :: Int ( ) : AsmType :: Signed ( ) , kWasmI32 , WasmInitExpr ( static_cast < int32_t > ( uvalue ) ) ) ; } else if ( Check ( '-' ) ) { if ( CheckForDouble ( & dvalue ) ) { DeclareGlobal ( info , mutable_variable , AsmType :: Double ( ) , kWasmF64 , WasmInitExpr ( - dvalue ) ) ; } else if ( CheckForUnsigned ( & uvalue ) ) { if ( uvalue > 0x7FFFFFFF ) { FAIL ( "Numeric literal out of range" ) ; } DeclareGlobal ( info , mutable_variable , mutable_variable ? AsmType :: Int ( ) : AsmType :: Signed ( ) , kWasmI32 , WasmInitExpr ( - static_cast < int32_t > ( uvalue ) ) ) ; } else { FAIL ( "Expected numeric literal" ) ; } } else if ( Check ( TOK ( new ) ) ) { RECURSE ( ValidateModuleVarNewStdlib ( info ) ) ; } else if ( Check ( stdlib_name_ ) ) { EXPECT_TOKEN ( '.' ) ; RECURSE ( ValidateModuleVarStdlib ( info ) ) ; } else if ( Peek ( foreign_name_ ) || Peek ( '+' ) ) { RECURSE ( ValidateModuleVarImport ( info , mutable_variable ) ) ; } else if ( scanner_ . IsGlobal ( ) ) { RECURSE ( ValidateModuleVarFromGlobal ( info , mutable_variable ) ) ; } else { FAIL ( "Bad variable declaration" ) ; } }
static void SetUpTestCase ( ) { source_data_ = reinterpret_cast < uint8_t * > ( vpx_memalign ( kDataAlignment , kDataBlockSize ) ) ; reference_data_ = reinterpret_cast < uint8_t * > ( vpx_memalign ( kDataAlignment , kDataBufferSize ) ) ; }
DECLARATION_NODE_LIST ( DEF_VISIT ) #undef DEF_VISIT bool Rewriter :: Rewrite ( ParseInfo * info ) { DisallowHeapAllocation no_allocation ; DisallowHandleAllocation no_handles ; DisallowHandleDereference no_deref ; RuntimeCallTimerScope runtimeTimer ( info -> runtime_call_stats ( ) , info -> on_background_thread ( ) ? RuntimeCallCounterId :: kCompileBackgroundRewriteReturnResult : RuntimeCallCounterId :: kCompileRewriteReturnResult ) ; FunctionLiteral * function = info -> literal ( ) ; DCHECK_NOT_NULL ( function ) ; Scope * scope = function -> scope ( ) ; DCHECK_NOT_NULL ( scope ) ; DCHECK_EQ ( scope , scope -> GetClosureScope ( ) ) ; if ( ! ( scope -> is_script_scope ( ) || scope -> is_eval_scope ( ) || scope -> is_module_scope ( ) ) ) { return true ; } ZonePtrList < Statement > * body = function -> body ( ) ; DCHECK_IMPLIES ( scope -> is_module_scope ( ) , ! body -> is_empty ( ) ) ; if ( ! body -> is_empty ( ) ) { Variable * result = scope -> AsDeclarationScope ( ) -> NewTemporary ( info -> ast_value_factory ( ) -> dot_result_string ( ) ) ; Processor processor ( info -> stack_limit ( ) , scope -> AsDeclarationScope ( ) , result , info -> ast_value_factory ( ) ) ; processor . Process ( body ) ; DCHECK_IMPLIES ( scope -> is_module_scope ( ) , processor . result_assigned ( ) ) ; if ( processor . result_assigned ( ) ) { int pos = kNoSourcePosition ; Expression * result_value = processor . factory ( ) -> NewVariableProxy ( result , pos ) ; Statement * result_statement = processor . factory ( ) -> NewReturnStatement ( result_value , pos ) ; body -> Add ( result_statement , info -> zone ( ) ) ; } if ( processor . HasStackOverflow ( ) ) return false ; } return true ; }
MacroAssemblerARM :: ma_alu ( Register src1 , Imm32 imm , Register dest , ALUOp op , SBit s , Condition c ) { if ( dest == InvalidReg ) MOZ_ASSERT ( s == SetCC ) ; Imm8 imm8 = Imm8 ( imm . value ) ; if ( ! imm8 . invalid ) { as_alu ( dest , src1 , imm8 , op , s , c ) ; return ; } Imm32 negImm = imm ; Register negDest ; ALUOp negOp = ALUNeg ( op , dest , & negImm , & negDest ) ; Imm8 negImm8 = Imm8 ( negImm . value ) ; if ( negOp != OpInvalid && ! negImm8 . invalid ) { as_alu ( negDest , src1 , negImm8 , negOp , s , c ) ; return ; } if ( HasMOVWT ( ) ) { if ( s == LeaveCC && ( op == OpMov || op == OpMvn ) ) { if ( op == OpMov && ( ( imm . value & ~ 0xffff ) == 0 ) ) { MOZ_ASSERT ( src1 == InvalidReg ) ; as_movw ( dest , Imm16 ( ( uint16_t ) imm . value ) , c ) ; return ; } if ( op == OpMvn && ( ( ( ~ imm . value ) & ~ 0xffff ) == 0 ) ) { MOZ_ASSERT ( src1 == InvalidReg ) ; as_movw ( dest , Imm16 ( ( uint16_t ) ~ imm . value ) , c ) ; return ; } if ( op == OpMvn ) imm . value = ~ imm . value ; as_movw ( dest , Imm16 ( imm . value & 0xffff ) , c ) ; as_movt ( dest , Imm16 ( ( imm . value > > 16 ) & 0xffff ) , c ) ; return ; } } if ( alu_dbl ( src1 , imm , dest , op , s , c ) ) return ; if ( negOp != OpInvalid && alu_dbl ( src1 , negImm , negDest , negOp , s , c ) ) return ; ScratchRegisterScope scratch ( asMasm ( ) ) ; if ( HasMOVWT ( ) ) { as_movw ( scratch , Imm16 ( imm . value & 0xffff ) , c ) ; if ( ( imm . value > > 16 ) != 0 ) as_movt ( scratch , Imm16 ( ( imm . value > > 16 ) & 0xffff ) , c ) ; } else { if ( op == OpMov ) { as_Imm32Pool ( dest , imm . value , c ) ; return ; } else { as_Imm32Pool ( scratch , imm . value , c ) ; } } as_alu ( dest , src1 , O2Reg ( scratch ) , op , s , c ) ; }
long ContentEncoding :: ParseCompressionEntry ( long long start , long long size , IMkvReader * pReader , ContentCompression * compression ) { assert ( pReader ) ; assert ( compression ) ; long long pos = start ; const long long stop = start + size ; bool valid = false ; while ( pos < stop ) { long long id , size ; const long status = ParseElementHeader ( pReader , pos , stop , id , size ) ; if ( status < 0 ) return status ; if ( id == 0x254 ) { long long algo = UnserializeUInt ( pReader , pos , size ) ; if ( algo < 0 ) return E_FILE_FORMAT_INVALID ; compression -> algo = algo ; valid = true ; } else if ( id == 0x255 ) { if ( size <= 0 ) return E_FILE_FORMAT_INVALID ; const size_t buflen = static_cast < size_t > ( size ) ; typedef unsigned char * buf_t ; const buf_t buf = new ( std :: nothrow ) unsigned char [ buflen ] ; if ( buf == NULL ) return - 1 ; const int read_status = pReader -> Read ( pos , static_cast < long > ( buflen ) , buf ) ; if ( read_status ) { delete [ ] buf ; return status ; } compression -> settings = buf ; compression -> settings_len = buflen ; } pos += size ; assert ( pos <= stop ) ; } if ( ! valid ) return E_FILE_FORMAT_INVALID ; return 0 ; }
pacparser_find_proxy ( const char * url , const char * host ) { char * error_prefix = "pacparser.c: pacparser_find_proxy:" ; if ( _debug ( ) ) print_error ( "DEBUG: Finding proxy for URL: %s and Host:" " %s\n" , url , host ) ; jsval rval ; char * script ; if ( url == NULL || ( strcmp ( url , "" ) == 0 ) ) { print_error ( "%s %s\n" , error_prefix , "URL not defined" ) ; return NULL ; } if ( host == NULL || ( strcmp ( host , "" ) == 0 ) ) { print_error ( "%s %s\n" , error_prefix , "Host not defined" ) ; return NULL ; } if ( cx == NULL || global == NULL ) { print_error ( "%s %s\n" , error_prefix , "Pac parser is not initialized." ) ; return NULL ; } script = "typeof(findProxyForURL);" ; if ( _debug ( ) ) print_error ( "DEBUG: Executing JavaScript: %s\n" , script ) ; JS_EvaluateScript ( cx , global , script , strlen ( script ) , NULL , 1 , & rval ) ; if ( strcmp ( "function" , JS_GetStringBytes ( JS_ValueToString ( cx , rval ) ) ) != 0 ) { print_error ( "%s %s\n" , error_prefix , "Javascript function findProxyForURL not defined." ) ; return NULL ; } char * sanitized_url = str_replace ( url , "'" , "%27" ) ; if ( strchr ( host , '\'' ) ) { print_error ( "%s %s\n" , error_prefix , "Invalid hostname: hostname can't have single quotes." ) ; return NULL ; } script = ( char * ) malloc ( 32 + strlen ( url ) + strlen ( host ) ) ; script [ 0 ] = '\0' ; strcat ( script , "findProxyForURL('" ) ; strcat ( script , sanitized_url ) ; strcat ( script , "', '" ) ; strcat ( script , host ) ; strcat ( script , "')" ) ; if ( _debug ( ) ) print_error ( "DEBUG: Executing JavaScript: %s\n" , script ) ; if ( ! JS_EvaluateScript ( cx , global , script , strlen ( script ) , NULL , 1 , & rval ) ) { print_error ( "%s %s\n" , error_prefix , "Problem in executing findProxyForURL." ) ; free ( sanitized_url ) ; free ( script ) ; return NULL ; } free ( sanitized_url ) ; free ( script ) ; return JS_GetStringBytes ( JS_ValueToString ( cx , rval ) ) ; }
RegExpObject :: trace ( JSTracer * trc , JSObject * obj ) { RegExpShared * shared = obj -> as < RegExpObject > ( ) . maybeShared ( ) ; if ( ! shared ) return ; if ( trc -> runtime ( ) -> isHeapBusy ( ) && trc -> isMarkingTracer ( ) && ! obj -> asTenured ( ) . zone ( ) -> isPreservingCode ( ) ) { obj -> as < RegExpObject > ( ) . NativeObject :: setPrivate ( nullptr ) ; } else { shared -> trace ( trc ) ; } }
void HBCISel :: generateHBCResolveEnvironment ( HBCResolveEnvironment * Inst , BasicBlock * next ) { VariableScope * instScope = Inst -> getScope ( ) ; Optional < int32_t > instScopeDepth = scopeAnalysis_ . getScopeDepth ( instScope ) ; Optional < int32_t > curScopeDepth = scopeAnalysis_ . getScopeDepth ( F_ -> getFunctionScope ( ) ) ; if ( ! instScopeDepth || ! curScopeDepth ) { emitUnreachableIfDebug ( ) ; return ; } assert ( curScopeDepth && curScopeDepth . getValue ( ) >= instScopeDepth . getValue ( ) && "Cannot access variables in inner scopes" ) ; int32_t delta = curScopeDepth . getValue ( ) - instScopeDepth . getValue ( ) ; assert ( delta > 0 && "HBCResolveEnvironment for current scope" ) ; BCFGen_ -> emitGetEnvironment ( encodeValue ( Inst ) , delta - 1 ) ; }
Status KeyStoreService :: onKeyguardVisibilityChanged ( bool isShowing , int32_t userId , int32_t * aidl_return ) { enforcement_policy . set_device_locked ( isShowing , userId ) ; if ( ! isShowing ) { mActiveUserId = userId ; } * aidl_return = static_cast < int32_t > ( ResponseCode :: NO_ERROR ) ; return Status :: ok ( ) ; }
long ZEXPORT inflateMark ( strm ) z_streamp strm ; { struct inflate_state FAR * state ; if ( strm == Z_NULL || strm -> state == Z_NULL ) return - 1L < < 16 ; state = ( struct inflate_state FAR * ) strm -> state ; return ( ( long ) ( state -> back ) < < 16 ) + ( state -> mode == COPY ? state -> length : ( state -> mode == MATCH ? state -> was - state -> length : 0 ) ) ; }
nsFieldSetFrame :: BuildDisplayList ( nsDisplayListBuilder * aBuilder , const nsRect & aDirtyRect , const nsDisplayListSet & aLists ) { if ( ! ( GetStateBits ( ) & NS_FRAME_IS_OVERFLOW_CONTAINER ) && IsVisibleForPainting ( aBuilder ) ) { if ( StyleBorder ( ) -> mBoxShadow ) { aLists . BorderBackground ( ) -> AppendNewToTop ( new ( aBuilder ) nsDisplayBoxShadowOuter ( aBuilder , this ) ) ; } aLists . BorderBackground ( ) -> AppendNewToTop ( new ( aBuilder ) nsDisplayFieldSetBorderBackground ( aBuilder , this ) ) ; DisplayOutlineUnconditional ( aBuilder , aLists ) ; DO_GLOBAL_REFLOW_COUNT_DSP ( "nsFieldSetFrame" ) ; } if ( GetPrevInFlow ( ) ) { DisplayOverflowContainers ( aBuilder , aDirtyRect , aLists ) ; } nsDisplayListCollection contentDisplayItems ; if ( mContentFrame ) { BuildDisplayListForChild ( aBuilder , mContentFrame , aDirtyRect , contentDisplayItems ) ; } if ( mLegendFrame ) { nsDisplayListSet set ( aLists , aLists . BlockBorderBackgrounds ( ) ) ; BuildDisplayListForChild ( aBuilder , mLegendFrame , aDirtyRect , set ) ; } contentDisplayItems . MoveTo ( aLists ) ; }
int RegExpMacroAssemblerPPC :: CheckStackGuardState ( Address * return_address , Code * re_code , Address re_frame ) { return NativeRegExpMacroAssembler :: CheckStackGuardState ( frame_entry < Isolate * > ( re_frame , kIsolate ) , frame_entry < intptr_t > ( re_frame , kStartIndex ) , frame_entry < intptr_t > ( re_frame , kDirectCall ) == 1 , return_address , re_code , frame_entry_address < String * > ( re_frame , kInputString ) , frame_entry_address < const byte * > ( re_frame , kInputStart ) , frame_entry_address < const byte * > ( re_frame , kInputEnd ) ) ; }
archive_write_disk_set_acls ( struct archive * a , int fd , const char * name , struct archive_acl * abstract_acl , __LA_MODE_T mode ) { int ret = ARCHIVE_OK ; #if !ARCHIVE_ACL_LIBRICHACL ( void ) mode ; #endif #if ARCHIVE_ACL_LIBRICHACL if ( ( archive_acl_types ( abstract_acl ) & ARCHIVE_ENTRY_ACL_TYPE_NFS4 ) != 0 ) { ret = set_richacl ( a , fd , name , abstract_acl , mode , ARCHIVE_ENTRY_ACL_TYPE_NFS4 , "nfs4" ) ; } #if ARCHIVE_ACL_LIBACL else #endif #endif /* ARCHIVE_ACL_LIBRICHACL */ #if ARCHIVE_ACL_LIBACL if ( ( archive_acl_types ( abstract_acl ) & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E ) != 0 ) { if ( ( archive_acl_types ( abstract_acl ) & ARCHIVE_ENTRY_ACL_TYPE_ACCESS ) != 0 ) { ret = set_acl ( a , fd , name , abstract_acl , ARCHIVE_ENTRY_ACL_TYPE_ACCESS , "access" ) ; if ( ret != ARCHIVE_OK ) return ( ret ) ; } if ( ( archive_acl_types ( abstract_acl ) & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT ) != 0 ) ret = set_acl ( a , fd , name , abstract_acl , ARCHIVE_ENTRY_ACL_TYPE_DEFAULT , "default" ) ; } #endif /* ARCHIVE_ACL_LIBACL */ return ( ret ) ; }
static int key_notify_sa_flush ( const struct km_event * c ) { struct sk_buff * skb ; struct sadb_msg * hdr ; skb = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_satype = pfkey_proto2satype ( c -> data . proto ) ; hdr -> sadb_msg_type = SADB_FLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; return 0 ; }
xmlXPathEvalExpression ( const xmlChar * str , xmlXPathContextPtr ctxt ) { xmlXPathParserContextPtr pctxt ; xmlXPathObjectPtr res , tmp ; int stack = 0 ; CHECK_CTXT ( ctxt ) xmlXPathInit ( ) ; pctxt = xmlXPathNewParserContext ( str , ctxt ) ; if ( pctxt == NULL ) return NULL ; xmlXPathEvalExpr ( pctxt ) ; if ( ( * pctxt -> cur != 0 ) || ( pctxt -> error != XPATH_EXPRESSION_OK ) ) { xmlXPatherror ( pctxt , __FILE__ , __LINE__ , XPATH_EXPR_ERROR ) ; res = NULL ; } else { res = valuePop ( pctxt ) ; } do { tmp = valuePop ( pctxt ) ; if ( tmp != NULL ) { xmlXPathReleaseObject ( ctxt , tmp ) ; stack ++ ; } } while ( tmp != NULL ) ; if ( ( stack != 0 ) && ( res != NULL ) ) { xmlGenericError ( xmlGenericErrorContext , "xmlXPathEvalExpression: %d object left on the stack\n" , stack ) ; } xmlXPathFreeParserContext ( pctxt ) ; return ( res ) ; }
static void on_read ( h2o_socket_t * sock , int status ) { h2o_http2_conn_t * conn = sock -> data ; if ( status != 0 ) { h2o_socket_read_stop ( conn -> sock ) ; close_connection ( conn ) ; return ; } update_idle_timeout ( conn ) ; parse_input ( conn ) ; if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) { h2o_timeout_unlink ( & conn -> _write . timeout_entry ) ; do_emit_writereq ( conn ) ; } }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; ruy :: profiler :: ScopeLabel label ( "SquaredDifference" ) ; const TfLiteTensor * input1 = GetInput ( context , node , kInputTensor1 ) ; const TfLiteTensor * input2 = GetInput ( context , node , kInputTensor2 ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; if ( output -> type == kTfLiteFloat32 ) { EvalSquaredDifference < float > ( context , node , data , input1 , input2 , output ) ; } else if ( output -> type == kTfLiteInt32 ) { EvalSquaredDifference < int32_t > ( context , node , data , input1 , input2 , output ) ; } else { context -> ReportError ( context , "SquaredDifference only supports FLOAT32 and INT32 now, got %d." , output -> type ) ; return kTfLiteError ; } return kTfLiteOk ; }
static int yam_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { struct yam_port * yp = netdev_priv ( dev ) ; struct yamdrv_ioctl_cfg yi ; struct yamdrv_ioctl_mcs * ym ; int ioctl_cmd ; if ( copy_from_user ( & ioctl_cmd , ifr -> ifr_data , sizeof ( int ) ) ) return - EFAULT ; if ( yp -> magic != YAM_MAGIC ) return - EINVAL ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd != SIOCDEVPRIVATE ) return - EINVAL ; switch ( ioctl_cmd ) { case SIOCYAMRESERVED : return - EINVAL ; case SIOCYAMSMCS : if ( netif_running ( dev ) ) return - EINVAL ; if ( ( ym = kmalloc ( sizeof ( struct yamdrv_ioctl_mcs ) , GFP_KERNEL ) ) == NULL ) return - ENOBUFS ; if ( copy_from_user ( ym , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_mcs ) ) ) { kfree ( ym ) ; return - EFAULT ; } if ( ym -> bitrate > YAM_MAXBITRATE ) { kfree ( ym ) ; return - EINVAL ; } add_mcs ( ym -> bits , ym -> bitrate , 0 ) ; kfree ( ym ) ; break ; case SIOCYAMSCFG : if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM ; if ( copy_from_user ( & yi , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; if ( ( yi . cfg . mask & YAM_IOBASE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_IRQ ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BITRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BAUDRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( yi . cfg . mask & YAM_IOBASE ) { yp -> iobase = yi . cfg . iobase ; dev -> base_addr = yi . cfg . iobase ; } if ( yi . cfg . mask & YAM_IRQ ) { if ( yi . cfg . irq > 15 ) return - EINVAL ; yp -> irq = yi . cfg . irq ; dev -> irq = yi . cfg . irq ; } if ( yi . cfg . mask & YAM_BITRATE ) { if ( yi . cfg . bitrate > YAM_MAXBITRATE ) return - EINVAL ; yp -> bitrate = yi . cfg . bitrate ; } if ( yi . cfg . mask & YAM_BAUDRATE ) { if ( yi . cfg . baudrate > YAM_MAXBAUDRATE ) return - EINVAL ; yp -> baudrate = yi . cfg . baudrate ; } if ( yi . cfg . mask & YAM_MODE ) { if ( yi . cfg . mode > YAM_MAXMODE ) return - EINVAL ; yp -> dupmode = yi . cfg . mode ; } if ( yi . cfg . mask & YAM_HOLDDLY ) { if ( yi . cfg . holddly > YAM_MAXHOLDDLY ) return - EINVAL ; yp -> holdd = yi . cfg . holddly ; } if ( yi . cfg . mask & YAM_TXDELAY ) { if ( yi . cfg . txdelay > YAM_MAXTXDELAY ) return - EINVAL ; yp -> txd = yi . cfg . txdelay ; } if ( yi . cfg . mask & YAM_TXTAIL ) { if ( yi . cfg . txtail > YAM_MAXTXTAIL ) return - EINVAL ; yp -> txtail = yi . cfg . txtail ; } if ( yi . cfg . mask & YAM_PERSIST ) { if ( yi . cfg . persist > YAM_MAXPERSIST ) return - EINVAL ; yp -> pers = yi . cfg . persist ; } if ( yi . cfg . mask & YAM_SLOTTIME ) { if ( yi . cfg . slottime > YAM_MAXSLOTTIME ) return - EINVAL ; yp -> slot = yi . cfg . slottime ; yp -> slotcnt = yp -> slot / 10 ; } break ; case SIOCYAMGCFG : yi . cfg . mask = 0xffffffff ; yi . cfg . iobase = yp -> iobase ; yi . cfg . irq = yp -> irq ; yi . cfg . bitrate = yp -> bitrate ; yi . cfg . baudrate = yp -> baudrate ; yi . cfg . mode = yp -> dupmode ; yi . cfg . txdelay = yp -> txd ; yi . cfg . holddly = yp -> holdd ; yi . cfg . txtail = yp -> txtail ; yi . cfg . persist = yp -> pers ; yi . cfg . slottime = yp -> slot ; if ( copy_to_user ( ifr -> ifr_data , & yi , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; break ; default : return - EINVAL ; } return 0 ; }
Builtin * Declarations :: FindSomeInternalBuiltinWithType ( const FunctionPointerType * type ) { for ( auto & declarable : declarables_ ) { if ( Builtin * builtin = Builtin :: DynamicCast ( declarable . get ( ) ) ) { if ( ! builtin -> IsExternal ( ) && builtin -> kind ( ) == Builtin :: kStub && builtin -> signature ( ) . return_type == type -> return_type ( ) && builtin -> signature ( ) . parameter_types . types == type -> parameter_types ( ) ) { return builtin ; } } } return nullptr ; }
TNode < Int32T > StringBuiltinsAssembler :: LoadSurrogatePairAt ( SloppyTNode < String > string , SloppyTNode < IntPtrT > length , SloppyTNode < IntPtrT > index , UnicodeEncoding encoding ) { Label handle_surrogate_pair ( this ) , return_result ( this ) ; TVARIABLE ( Int32T , var_result ) ; TVARIABLE ( Int32T , var_trail ) ; var_result = StringCharCodeAt ( string , index ) ; var_trail = Int32Constant ( 0 ) ; GotoIf ( Word32NotEqual ( Word32And ( var_result . value ( ) , Int32Constant ( 0xFC00 ) ) , Int32Constant ( 0xD800 ) ) , & return_result ) ; TNode < IntPtrT > next_index = IntPtrAdd ( index , IntPtrConstant ( 1 ) ) ; GotoIfNot ( IntPtrLessThan ( next_index , length ) , & return_result ) ; var_trail = StringCharCodeAt ( string , next_index ) ; Branch ( Word32Equal ( Word32And ( var_trail . value ( ) , Int32Constant ( 0xFC00 ) ) , Int32Constant ( 0xDC00 ) ) , & handle_surrogate_pair , & return_result ) ; BIND ( & handle_surrogate_pair ) ; { TNode < Int32T > lead = var_result . value ( ) ; TNode < Int32T > trail = var_trail . value ( ) ; CSA_SLOW_ASSERT ( this , Uint32GreaterThanOrEqual ( lead , Int32Constant ( 0xD800 ) ) ) ; CSA_SLOW_ASSERT ( this , Uint32LessThan ( lead , Int32Constant ( 0xDC00 ) ) ) ; CSA_SLOW_ASSERT ( this , Uint32GreaterThanOrEqual ( trail , Int32Constant ( 0xDC00 ) ) ) ; CSA_SLOW_ASSERT ( this , Uint32LessThan ( trail , Int32Constant ( 0xE000 ) ) ) ; switch ( encoding ) { case UnicodeEncoding :: UTF16 : var_result = Signed ( Word32Or ( #if V8_TARGET_BIG_ENDIAN Word32Shl ( lead , Int32Constant ( 16 ) ) , trail ) ) ; #else Word32Shl ( trail , Int32Constant ( 16 ) ) , lead ) ) ; #endif break ; case UnicodeEncoding :: UTF32 : { TNode < Int32T > surrogate_offset = Int32Constant ( 0x10000 - ( 0xD800 < < 10 ) - 0xDC00 ) ; var_result = Signed ( Int32Add ( Word32Shl ( lead , Int32Constant ( 10 ) ) , Int32Add ( trail , surrogate_offset ) ) ) ; break ; } } Goto ( & return_result ) ; } BIND ( & return_result ) ; return var_result . value ( ) ; }
void InterpreterAssembler :: CallPrologue ( ) { if ( ! Bytecodes :: MakesCallAlongCriticalPath ( bytecode_ ) ) { SaveBytecodeOffset ( ) ; } if ( FLAG_debug_code && ! disable_stack_check_across_call_ ) { DCHECK_NULL ( stack_pointer_before_call_ ) ; stack_pointer_before_call_ = LoadStackPointer ( ) ; } bytecode_array_valid_ = false ; made_call_ = true ; }
int main ( int argc , char * argv [ ] ) { gr_face * face = 0 ; try { if ( argc != 2 ) throw std :: length_error ( "not enough arguments: need a backing font" ) ; dummyFace = face_handle ( argv [ 1 ] ) ; testFeatTable < FeatTableTestA > ( testDataA , "A\n" ) ; testFeatTable < FeatTableTestB > ( testDataB , "B\n" ) ; testFeatTable < FeatTableTestB > ( testDataBunsorted , "Bu\n" ) ; testFeatTable < FeatTableTestC > ( testDataCunsorted , "C\n" ) ; testFeatTable < FeatTableTestD > ( testDataDunsorted , "D\n" ) ; testFeatTable < FeatTableTestE > ( testDataE , "E\n" ) ; FeatureMap testFeatureMap ; dummyFace . replace_table ( TtfUtil :: Tag :: Feat , & testBadOffset , sizeof testBadOffset ) ; face = gr_make_face_with_ops ( & dummyFace , & face_handle :: ops , gr_face_dumbRendering ) ; bool readStatus = testFeatureMap . readFeats ( * face ) ; testAssert ( "fail gracefully on bad table" , ! readStatus ) ; } catch ( std :: exception & e ) { fprintf ( stderr , "%s: %s\n" , argv [ 0 ] , e . what ( ) ) ; gr_face_destroy ( face ) ; return 1 ; } gr_face_destroy ( face ) ; return 0 ; }
yank_copy_line ( struct block_def * bd , long y_idx , int exclude_trailing_space ) { char_u * pnew ; if ( exclude_trailing_space ) bd -> endspaces = 0 ; if ( ( pnew = alloc ( bd -> startspaces + bd -> endspaces + bd -> textlen + 1 ) ) == NULL ) return FAIL ; y_current -> y_array [ y_idx ] = pnew ; vim_memset ( pnew , ' ' , ( size_t ) bd -> startspaces ) ; pnew += bd -> startspaces ; mch_memmove ( pnew , bd -> textstart , ( size_t ) bd -> textlen ) ; pnew += bd -> textlen ; vim_memset ( pnew , ' ' , ( size_t ) bd -> endspaces ) ; pnew += bd -> endspaces ; if ( exclude_trailing_space ) { int s = bd -> textlen + bd -> endspaces ; while ( VIM_ISWHITE ( * ( bd -> textstart + s - 1 ) ) && s > 0 ) { s = s - ( * mb_head_off ) ( bd -> textstart , bd -> textstart + s - 1 ) - 1 ; pnew -- ; } } * pnew = NUL ; return OK ; }
void V8HeapExplorer :: ExtractAccessorInfoReferences ( int entry , AccessorInfo * accessor_info ) { SetInternalReference ( accessor_info , entry , "name" , accessor_info -> name ( ) , AccessorInfo :: kNameOffset ) ; SetInternalReference ( accessor_info , entry , "expected_receiver_type" , accessor_info -> expected_receiver_type ( ) , AccessorInfo :: kExpectedReceiverTypeOffset ) ; SetInternalReference ( accessor_info , entry , "getter" , accessor_info -> getter ( ) , AccessorInfo :: kGetterOffset ) ; SetInternalReference ( accessor_info , entry , "setter" , accessor_info -> setter ( ) , AccessorInfo :: kSetterOffset ) ; SetInternalReference ( accessor_info , entry , "data" , accessor_info -> data ( ) , AccessorInfo :: kDataOffset ) ; }
static int packet_do_bind ( struct sock * sk , const char * name , int ifindex , __be16 proto ) { struct packet_sock * po = pkt_sk ( sk ) ; struct net_device * dev_curr ; __be16 proto_curr ; bool need_rehook ; struct net_device * dev = NULL ; int ret = 0 ; bool unlisted = false ; if ( po -> fanout ) return - EINVAL ; lock_sock ( sk ) ; spin_lock ( & po -> bind_lock ) ; rcu_read_lock ( ) ; if ( name ) { dev = dev_get_by_name_rcu ( sock_net ( sk ) , name ) ; if ( ! dev ) { ret = - ENODEV ; goto out_unlock ; } } else if ( ifindex ) { dev = dev_get_by_index_rcu ( sock_net ( sk ) , ifindex ) ; if ( ! dev ) { ret = - ENODEV ; goto out_unlock ; } } if ( dev ) dev_hold ( dev ) ; proto_curr = po -> prot_hook . type ; dev_curr = po -> prot_hook . dev ; need_rehook = proto_curr != proto || dev_curr != dev ; if ( need_rehook ) { if ( po -> running ) { rcu_read_unlock ( ) ; __unregister_prot_hook ( sk , true ) ; rcu_read_lock ( ) ; dev_curr = po -> prot_hook . dev ; if ( dev ) unlisted = ! dev_get_by_index_rcu ( sock_net ( sk ) , dev -> ifindex ) ; } po -> num = proto ; po -> prot_hook . type = proto ; if ( unlikely ( unlisted ) ) { dev_put ( dev ) ; po -> prot_hook . dev = NULL ; po -> ifindex = - 1 ; packet_cached_dev_reset ( po ) ; } else { po -> prot_hook . dev = dev ; po -> ifindex = dev ? dev -> ifindex : 0 ; packet_cached_dev_assign ( po , dev ) ; } } if ( dev_curr ) dev_put ( dev_curr ) ; if ( proto == 0 || ! need_rehook ) goto out_unlock ; if ( ! unlisted && ( ! dev || ( dev -> flags & IFF_UP ) ) ) { register_prot_hook ( sk ) ; } else { sk -> sk_err = ENETDOWN ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_error_report ( sk ) ; } out_unlock : rcu_read_unlock ( ) ; spin_unlock ( & po -> bind_lock ) ; release_sock ( sk ) ; return ret ; }
static void kvm_steal_time_set_preempted ( struct kvm_vcpu * vcpu ) { struct gfn_to_hva_cache * ghc = & vcpu -> arch . st . cache ; struct kvm_steal_time __user * st ; struct kvm_memslots * slots ; static const u8 preempted = KVM_VCPU_PREEMPTED ; if ( ! ( vcpu -> arch . st . msr_val & KVM_MSR_ENABLED ) ) return ; if ( vcpu -> arch . st . preempted ) return ; if ( unlikely ( current -> mm != vcpu -> kvm -> mm ) ) return ; slots = kvm_memslots ( vcpu -> kvm ) ; if ( unlikely ( slots -> generation != ghc -> generation || kvm_is_error_hva ( ghc -> hva ) || ! ghc -> memslot ) ) return ; st = ( struct kvm_steal_time __user * ) ghc -> hva ; BUILD_BUG_ON ( sizeof ( st -> preempted ) != sizeof ( preempted ) ) ; if ( ! copy_to_user_nofault ( & st -> preempted , & preempted , sizeof ( preempted ) ) ) vcpu -> arch . st . preempted = KVM_VCPU_PREEMPTED ; mark_page_dirty_in_slot ( vcpu -> kvm , ghc -> memslot , gpa_to_gfn ( ghc -> gpa ) ) ; }
void BytecodeGraphBuilder :: VisitCreateObjectLiteral ( ) { Handle < ObjectBoilerplateDescription > constant_properties ( ObjectBoilerplateDescription :: cast ( bytecode_iterator ( ) . GetConstantForIndexOperand ( 0 ) ) , isolate ( ) ) ; int const slot_id = bytecode_iterator ( ) . GetIndexOperand ( 1 ) ; VectorSlotPair pair = CreateVectorSlotPair ( slot_id ) ; int bytecode_flags = bytecode_iterator ( ) . GetFlagOperand ( 2 ) ; int literal_flags = interpreter :: CreateObjectLiteralFlags :: FlagsBits :: decode ( bytecode_flags ) ; int number_of_properties = constant_properties -> size ( ) ; Node * literal = NewNode ( javascript ( ) -> CreateLiteralObject ( constant_properties , pair , literal_flags , number_of_properties ) ) ; environment ( ) -> BindRegister ( bytecode_iterator ( ) . GetRegisterOperand ( 3 ) , literal , Environment :: kAttachFrameState ) ; }
TEST_F ( QuantizedConv2DTest , OddPaddingBatch ) { const int stride = 2 ; TF_ASSERT_OK ( NodeDefBuilder ( "quantized_conv_op" , "QuantizedConv2D" ) . Input ( FakeInput ( DT_QUINT8 ) ) . Input ( FakeInput ( DT_QUINT8 ) ) . Input ( FakeInput ( DT_FLOAT ) ) . Input ( FakeInput ( DT_FLOAT ) ) . Input ( FakeInput ( DT_FLOAT ) ) . Input ( FakeInput ( DT_FLOAT ) ) . Attr ( "out_type" , DataTypeToEnum < qint32 > :: v ( ) ) . Attr ( "strides" , { 1 , stride , stride , 1 } ) . Attr ( "padding" , "SAME" ) . Finalize ( node_def ( ) ) ) ; TF_ASSERT_OK ( InitOp ( ) ) ; const int depth = 1 ; const int image_width = 4 ; const int image_height = 4 ; const int image_batch_count = 3 ; AddInputFromArray < quint8 > ( TensorShape ( { image_batch_count , image_height , image_width , depth } ) , { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 } ) ; const int filter_size = 3 ; const int filter_count = 1 ; AddInputFromArray < quint8 > ( TensorShape ( { filter_size , filter_size , depth , filter_count } ) , { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ) ; AddInputFromArray < float > ( TensorShape ( { 1 } ) , { 0 } ) ; AddInputFromArray < float > ( TensorShape ( { 1 } ) , { 255.0f } ) ; AddInputFromArray < float > ( TensorShape ( { 1 } ) , { 0 } ) ; AddInputFromArray < float > ( TensorShape ( { 1 } ) , { 255.0f } ) ; TF_ASSERT_OK ( RunOpKernel ( ) ) ; const int expected_width = image_width / stride ; const int expected_height = ( image_height * filter_count ) / stride ; Tensor expected ( DT_QINT32 , TensorShape ( { image_batch_count , expected_height , expected_width , filter_count } ) ) ; test :: FillValues < qint32 > ( & expected , { 348 , 252 , 274 , 175 , 348 , 252 , 274 , 175 , 348 , 252 , 274 , 175 } ) ; test :: ExpectTensorEqual < qint32 > ( expected , * GetOutput ( 0 ) ) ; }
HTMLMediaElement :: HTMLMediaElement ( already_AddRefed < nsINodeInfo > & aNodeInfo ) : nsGenericHTMLElement ( aNodeInfo ) , mSrcStreamListener ( nullptr ) , mCurrentLoadID ( 0 ) , mNetworkState ( nsIDOMHTMLMediaElement :: NETWORK_EMPTY ) , mReadyState ( nsIDOMHTMLMediaElement :: HAVE_NOTHING ) , mLoadWaitStatus ( NOT_WAITING ) , mVolume ( 1.0 ) , mPreloadAction ( PRELOAD_UNDEFINED ) , mMediaSize ( - 1 , - 1 ) , mLastCurrentTime ( 0.0 ) , mFragmentStart ( - 1.0 ) , mFragmentEnd ( - 1.0 ) , mDefaultPlaybackRate ( 1.0 ) , mPlaybackRate ( 1.0 ) , mPreservesPitch ( true ) , mPlayed ( new TimeRanges ) , mCurrentPlayRangeStart ( - 1.0 ) , mBegun ( false ) , mLoadedFirstFrame ( false ) , mAutoplaying ( true ) , mAutoplayEnabled ( true ) , mStatsShowing ( false ) , mPaused ( true ) , mMuted ( 0 ) , mAudioCaptured ( false ) , mPlayingBeforeSeek ( false ) , mPausedForInactiveDocumentOrChannel ( false ) , mEventDeliveryPaused ( false ) , mWaitingFired ( false ) , mIsRunningLoadMethod ( false ) , mIsLoadingFromSourceChildren ( false ) , mDelayingLoadEvent ( false ) , mIsRunningSelectResource ( false ) , mHaveQueuedSelectResource ( false ) , mSuspendedAfterFirstFrame ( false ) , mAllowSuspendAfterFirstFrame ( true ) , mHasPlayedOrSeeked ( false ) , mHasSelfReference ( false ) , mShuttingDown ( false ) , mSuspendedForPreloadNone ( false ) , mMediaSecurityVerified ( false ) , mCORSMode ( CORS_NONE ) , mHasAudio ( false ) , mDownloadSuspendedByCache ( false ) , mAudioChannelFaded ( false ) , mPlayingThroughTheAudioChannel ( false ) , mWaitingFor ( MediaWaitingFor :: None ) { #ifdef PR_LOGGING if ( ! gMediaElementLog ) { gMediaElementLog = PR_NewLogModule ( "nsMediaElement" ) ; } if ( ! gMediaElementEventsLog ) { gMediaElementEventsLog = PR_NewLogModule ( "nsMediaElementEvents" ) ; } #endif mAudioChannel = AudioChannelService :: GetDefaultAudioChannel ( ) ; mPaused . SetOuter ( this ) ; RegisterFreezableElement ( ) ; NotifyOwnerDocumentActivityChanged ( ) ; }
void Schedule :: EnsureCFGWellFormedness ( ) { BasicBlockVector all_blocks_copy ( all_blocks_ ) ; for ( auto block : all_blocks_copy ) { if ( block -> PredecessorCount ( ) > 1 ) { if ( block != end_ ) { EnsureSplitEdgeForm ( block ) ; } if ( block -> deferred ( ) ) { EnsureDeferredCodeSingleEntryPoint ( block ) ; } } else { EliminateNoopPhiNodes ( block ) ; } } }
LBlock :: init ( TempAllocator & alloc ) { size_t numLPhis = 0 ; for ( MPhiIterator i ( block_ -> phisBegin ( ) ) , e ( block_ -> phisEnd ( ) ) ; i != e ; ++ i ) { MPhi * phi = * i ; numLPhis += ( phi -> type ( ) == MIRType_Value ) ? BOX_PIECES : 1 ; } if ( ! phis_ . init ( alloc , numLPhis ) ) return false ; size_t phiIndex = 0 ; size_t numPreds = block_ -> numPredecessors ( ) ; for ( MPhiIterator i ( block_ -> phisBegin ( ) ) , e ( block_ -> phisEnd ( ) ) ; i != e ; ++ i ) { MPhi * phi = * i ; MOZ_ASSERT ( phi -> numOperands ( ) == numPreds ) ; int numPhis = ( phi -> type ( ) == MIRType_Value ) ? BOX_PIECES : 1 ; for ( int i = 0 ; i < numPhis ; i ++ ) { void * array = alloc . allocateArray < sizeof ( LAllocation ) > ( numPreds ) ; LAllocation * inputs = static_cast < LAllocation * > ( array ) ; if ( ! inputs ) return false ; void * addr = & phis_ [ phiIndex ++ ] ; LPhi * lphi = new ( addr ) LPhi ( phi , inputs ) ; lphi -> setBlock ( this ) ; } } return true ; }
static unsigned long change_pte_range ( struct vm_area_struct * vma , pmd_t * pmd , unsigned long addr , unsigned long end , pgprot_t newprot , unsigned long cp_flags ) { pte_t * pte , oldpte ; spinlock_t * ptl ; unsigned long pages = 0 ; int target_node = NUMA_NO_NODE ; bool dirty_accountable = cp_flags & MM_CP_DIRTY_ACCT ; bool prot_numa = cp_flags & MM_CP_PROT_NUMA ; bool uffd_wp = cp_flags & MM_CP_UFFD_WP ; bool uffd_wp_resolve = cp_flags & MM_CP_UFFD_WP_RESOLVE ; if ( pmd_trans_unstable ( pmd ) ) return 0 ; pte = pte_offset_map_lock ( vma -> vm_mm , pmd , addr , & ptl ) ; if ( prot_numa && ! ( vma -> vm_flags & VM_SHARED ) && atomic_read ( & vma -> vm_mm -> mm_users ) == 1 ) target_node = numa_node_id ( ) ; flush_tlb_batched_pending ( vma -> vm_mm ) ; arch_enter_lazy_mmu_mode ( ) ; do { oldpte = * pte ; if ( pte_present ( oldpte ) ) { pte_t ptent ; bool preserve_write = prot_numa && pte_write ( oldpte ) ; if ( prot_numa ) { struct page * page ; if ( pte_protnone ( oldpte ) ) continue ; page = vm_normal_page ( vma , addr , oldpte ) ; if ( ! page || PageKsm ( page ) ) continue ; if ( is_cow_mapping ( vma -> vm_flags ) && page_mapcount ( page ) != 1 ) continue ; if ( page_is_file_lru ( page ) && PageDirty ( page ) ) continue ; if ( target_node == page_to_nid ( page ) ) continue ; } oldpte = ptep_modify_prot_start ( vma , addr , pte ) ; ptent = pte_modify ( oldpte , newprot ) ; if ( preserve_write ) ptent = pte_mk_savedwrite ( ptent ) ; if ( uffd_wp ) { ptent = pte_wrprotect ( ptent ) ; ptent = pte_mkuffd_wp ( ptent ) ; } else if ( uffd_wp_resolve ) { ptent = pte_clear_uffd_wp ( ptent ) ; } if ( dirty_accountable && pte_dirty ( ptent ) && ( pte_soft_dirty ( ptent ) || ! ( vma -> vm_flags & VM_SOFTDIRTY ) ) ) { ptent = pte_mkwrite ( ptent ) ; } ptep_modify_prot_commit ( vma , addr , pte , oldpte , ptent ) ; pages ++ ; } else if ( is_swap_pte ( oldpte ) ) { swp_entry_t entry = pte_to_swp_entry ( oldpte ) ; pte_t newpte ; if ( is_write_migration_entry ( entry ) ) { make_migration_entry_read ( & entry ) ; newpte = swp_entry_to_pte ( entry ) ; if ( pte_swp_soft_dirty ( oldpte ) ) newpte = pte_swp_mksoft_dirty ( newpte ) ; if ( pte_swp_uffd_wp ( oldpte ) ) newpte = pte_swp_mkuffd_wp ( newpte ) ; } else if ( is_write_device_private_entry ( entry ) ) { make_device_private_entry_read ( & entry ) ; newpte = swp_entry_to_pte ( entry ) ; if ( pte_swp_uffd_wp ( oldpte ) ) newpte = pte_swp_mkuffd_wp ( newpte ) ; } else { newpte = oldpte ; } if ( uffd_wp ) newpte = pte_swp_mkuffd_wp ( newpte ) ; else if ( uffd_wp_resolve ) newpte = pte_swp_clear_uffd_wp ( newpte ) ; if ( ! pte_same ( oldpte , newpte ) ) { set_pte_at ( vma -> vm_mm , addr , pte , newpte ) ; pages ++ ; } } } while ( pte ++ , addr += PAGE_SIZE , addr != end ) ; arch_leave_lazy_mmu_mode ( ) ; pte_unmap_unlock ( pte - 1 , ptl ) ; return pages ; }
static PyObject * __pyx_pw_17clickhouse_driver_7columns_12stringcolumn_11FixedString_5write_items ( PyObject * __pyx_self , PyObject * __pyx_args , PyObject * __pyx_kwds ) { PyObject * __pyx_v_self = 0 ; PyObject * __pyx_v_items = 0 ; PyObject * __pyx_v_buf = 0 ; PyObject * __pyx_r = 0 ; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext ( "write_items (wrapper)" , 0 ) ; { static PyObject * * __pyx_pyargnames [ ] = { & __pyx_n_s_self , & __pyx_n_s_items , & __pyx_n_s_buf , 0 } ; PyObject * values [ 3 ] = { 0 , 0 , 0 } ; if ( unlikely ( __pyx_kwds ) ) { Py_ssize_t kw_args ; const Py_ssize_t pos_args = PyTuple_GET_SIZE ( __pyx_args ) ; switch ( pos_args ) { case 3 : values [ 2 ] = PyTuple_GET_ITEM ( __pyx_args , 2 ) ; CYTHON_FALLTHROUGH ; case 2 : values [ 1 ] = PyTuple_GET_ITEM ( __pyx_args , 1 ) ; CYTHON_FALLTHROUGH ; case 1 : values [ 0 ] = PyTuple_GET_ITEM ( __pyx_args , 0 ) ; CYTHON_FALLTHROUGH ; case 0 : break ; default : goto __pyx_L5_argtuple_error ; } kw_args = PyDict_Size ( __pyx_kwds ) ; switch ( pos_args ) { case 0 : if ( likely ( ( values [ 0 ] = __Pyx_PyDict_GetItemStr ( __pyx_kwds , __pyx_n_s_self ) ) != 0 ) ) kw_args -- ; else goto __pyx_L5_argtuple_error ; CYTHON_FALLTHROUGH ; case 1 : if ( likely ( ( values [ 1 ] = __Pyx_PyDict_GetItemStr ( __pyx_kwds , __pyx_n_s_items ) ) != 0 ) ) kw_args -- ; else { __Pyx_RaiseArgtupleInvalid ( "write_items" , 1 , 3 , 3 , 1 ) ; __PYX_ERR ( 0 , 83 , __pyx_L3_error ) } CYTHON_FALLTHROUGH ; case 2 : if ( likely ( ( values [ 2 ] = __Pyx_PyDict_GetItemStr ( __pyx_kwds , __pyx_n_s_buf ) ) != 0 ) ) kw_args -- ; else { __Pyx_RaiseArgtupleInvalid ( "write_items" , 1 , 3 , 3 , 2 ) ; __PYX_ERR ( 0 , 83 , __pyx_L3_error ) } } if ( unlikely ( kw_args > 0 ) ) { if ( unlikely ( __Pyx_ParseOptionalKeywords ( __pyx_kwds , __pyx_pyargnames , 0 , values , pos_args , "write_items" ) < 0 ) ) __PYX_ERR ( 0 , 83 , __pyx_L3_error ) } } else if ( PyTuple_GET_SIZE ( __pyx_args ) != 3 ) { goto __pyx_L5_argtuple_error ; } else { values [ 0 ] = PyTuple_GET_ITEM ( __pyx_args , 0 ) ; values [ 1 ] = PyTuple_GET_ITEM ( __pyx_args , 1 ) ; values [ 2 ] = PyTuple_GET_ITEM ( __pyx_args , 2 ) ; } __pyx_v_self = values [ 0 ] ; __pyx_v_items = values [ 1 ] ; __pyx_v_buf = values [ 2 ] ; } goto __pyx_L4_argument_unpacking_done ; __pyx_L5_argtuple_error : ; __Pyx_RaiseArgtupleInvalid ( "write_items" , 1 , 3 , 3 , PyTuple_GET_SIZE ( __pyx_args ) ) ; __PYX_ERR ( 0 , 83 , __pyx_L3_error ) __pyx_L3_error : ; __Pyx_AddTraceback ( "clickhouse_driver.columns.stringcolumn.FixedString.write_items" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __Pyx_RefNannyFinishContext ( ) ; return NULL ; __pyx_L4_argument_unpacking_done : ; __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_11FixedString_4write_items ( __pyx_self , __pyx_v_self , __pyx_v_items , __pyx_v_buf ) ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
AsmType * AsmJsParser :: UnaryExpression ( ) { AsmType * ret ; if ( Check ( '-' ) ) { uint32_t uvalue ; if ( CheckForUnsigned ( & uvalue ) ) { if ( uvalue <= 0x80000000 ) { current_function_builder_ -> EmitI32Const ( - static_cast < int32_t > ( uvalue ) ) ; } else { FAILn ( "Integer numeric literal out of range." ) ; } ret = AsmType :: Signed ( ) ; } else { RECURSEn ( ret = UnaryExpression ( ) ) ; if ( ret -> IsA ( AsmType :: Int ( ) ) ) { TemporaryVariableScope tmp ( this ) ; current_function_builder_ -> EmitSetLocal ( tmp . get ( ) ) ; current_function_builder_ -> EmitI32Const ( 0 ) ; current_function_builder_ -> EmitGetLocal ( tmp . get ( ) ) ; current_function_builder_ -> Emit ( kExprI32Sub ) ; ret = AsmType :: Intish ( ) ; } else if ( ret -> IsA ( AsmType :: DoubleQ ( ) ) ) { current_function_builder_ -> Emit ( kExprF64Neg ) ; ret = AsmType :: Double ( ) ; } else if ( ret -> IsA ( AsmType :: FloatQ ( ) ) ) { current_function_builder_ -> Emit ( kExprF32Neg ) ; ret = AsmType :: Floatish ( ) ; } else { FAILn ( "expected int/double?/float?" ) ; } } } else if ( Peek ( '+' ) ) { call_coercion_ = AsmType :: Double ( ) ; call_coercion_position_ = scanner_ . Position ( ) ; scanner_ . Next ( ) ; RECURSEn ( ret = UnaryExpression ( ) ) ; if ( ret -> IsA ( AsmType :: Signed ( ) ) ) { current_function_builder_ -> Emit ( kExprF64SConvertI32 ) ; ret = AsmType :: Double ( ) ; } else if ( ret -> IsA ( AsmType :: Unsigned ( ) ) ) { current_function_builder_ -> Emit ( kExprF64UConvertI32 ) ; ret = AsmType :: Double ( ) ; } else if ( ret -> IsA ( AsmType :: DoubleQ ( ) ) ) { ret = AsmType :: Double ( ) ; } else if ( ret -> IsA ( AsmType :: FloatQ ( ) ) ) { current_function_builder_ -> Emit ( kExprF64ConvertF32 ) ; ret = AsmType :: Double ( ) ; } else { FAILn ( "expected signed/unsigned/double?/float?" ) ; } } else if ( Check ( '!' ) ) { RECURSEn ( ret = UnaryExpression ( ) ) ; if ( ! ret -> IsA ( AsmType :: Int ( ) ) ) { FAILn ( "expected int" ) ; } current_function_builder_ -> Emit ( kExprI32Eqz ) ; } else if ( Check ( '~' ) ) { if ( Check ( '~' ) ) { RECURSEn ( ret = UnaryExpression ( ) ) ; if ( ret -> IsA ( AsmType :: Double ( ) ) ) { current_function_builder_ -> Emit ( kExprI32AsmjsSConvertF64 ) ; } else if ( ret -> IsA ( AsmType :: FloatQ ( ) ) ) { current_function_builder_ -> Emit ( kExprI32AsmjsSConvertF32 ) ; } else { FAILn ( "expected double or float?" ) ; } ret = AsmType :: Signed ( ) ; } else { RECURSEn ( ret = UnaryExpression ( ) ) ; if ( ! ret -> IsA ( AsmType :: Intish ( ) ) ) { FAILn ( "operator ~ expects intish" ) ; } current_function_builder_ -> EmitI32Const ( 0xFFFFFFFF ) ; current_function_builder_ -> Emit ( kExprI32Xor ) ; ret = AsmType :: Signed ( ) ; } } else { RECURSEn ( ret = CallExpression ( ) ) ; } return ret ; }
status_t MPEG4Extractor :: readMetaData ( ) { if ( mInitCheck != NO_INIT ) { return mInitCheck ; } off64_t offset = 0 ; status_t err ; bool sawMoovOrSidx = false ; while ( ! ( sawMoovOrSidx && ( mMdatFound || mMoofFound ) ) ) { off64_t orig_offset = offset ; err = parseChunk ( & offset , 0 ) ; if ( err != OK && err != UNKNOWN_ERROR ) { break ; } else if ( offset <= orig_offset ) { ALOGE ( "did not advance: %lld->%lld" , ( long long ) orig_offset , ( long long ) offset ) ; err = ERROR_MALFORMED ; break ; } else if ( err == UNKNOWN_ERROR ) { sawMoovOrSidx = true ; } } if ( mInitCheck == OK ) { if ( mHasVideo ) { mFileMetaData -> setCString ( kKeyMIMEType , MEDIA_MIMETYPE_CONTAINER_MPEG4 ) ; } else { mFileMetaData -> setCString ( kKeyMIMEType , "audio/mp4" ) ; } } else { mInitCheck = err ; } CHECK_NE ( err , ( status_t ) NO_INIT ) ; uint64_t psshsize = 0 ; for ( size_t i = 0 ; i < mPssh . size ( ) ; i ++ ) { psshsize += 20 + mPssh [ i ] . datalen ; } if ( psshsize > 0 && psshsize <= UINT32_MAX ) { char * buf = ( char * ) malloc ( psshsize ) ; char * ptr = buf ; for ( size_t i = 0 ; i < mPssh . size ( ) ; i ++ ) { memcpy ( ptr , mPssh [ i ] . uuid , 20 ) ; memcpy ( ptr + 20 , mPssh [ i ] . data , mPssh [ i ] . datalen ) ; ptr += ( 20 + mPssh [ i ] . datalen ) ; } mFileMetaData -> setData ( kKeyPssh , 'pssh' , buf , psshsize ) ; free ( buf ) ; } return mInitCheck ; }
libraw_processed_image_t * LibRaw :: dcraw_make_mem_thumb ( int * errcode ) { if ( ! T . thumb ) { if ( ! ID . toffset && ! ( imgdata . thumbnail . tlength > 0 && load_raw == & LibRaw :: broadcom_load_raw ) ) { if ( errcode ) * errcode = LIBRAW_NO_THUMBNAIL ; } else { if ( errcode ) * errcode = LIBRAW_OUT_OF_ORDER_CALL ; } return NULL ; } if ( T . tformat == LIBRAW_THUMBNAIL_BITMAP ) { libraw_processed_image_t * ret = ( libraw_processed_image_t * ) :: malloc ( sizeof ( libraw_processed_image_t ) + T . tlength ) ; if ( ! ret ) { if ( errcode ) * errcode = ENOMEM ; return NULL ; } memset ( ret , 0 , sizeof ( libraw_processed_image_t ) ) ; ret -> type = LIBRAW_IMAGE_BITMAP ; ret -> height = T . theight ; ret -> width = T . twidth ; ret -> colors = 3 ; ret -> bits = 8 ; ret -> data_size = T . tlength ; memmove ( ret -> data , T . thumb , T . tlength ) ; if ( errcode ) * errcode = 0 ; return ret ; } else if ( T . tformat == LIBRAW_THUMBNAIL_JPEG ) { ushort exif [ 5 ] ; int mk_exif = 0 ; if ( strcmp ( T . thumb + 6 , "Exif" ) ) mk_exif = 1 ; int dsize = T . tlength + mk_exif * ( sizeof ( exif ) + sizeof ( tiff_hdr ) ) ; libraw_processed_image_t * ret = ( libraw_processed_image_t * ) :: malloc ( sizeof ( libraw_processed_image_t ) + dsize ) ; if ( ! ret ) { if ( errcode ) * errcode = ENOMEM ; return NULL ; } memset ( ret , 0 , sizeof ( libraw_processed_image_t ) ) ; ret -> type = LIBRAW_IMAGE_JPEG ; ret -> data_size = dsize ; ret -> data [ 0 ] = 0xff ; ret -> data [ 1 ] = 0xd8 ; if ( mk_exif ) { struct tiff_hdr th ; memcpy ( exif , "\xff\xe1  Exif\0\0" , 10 ) ; exif [ 1 ] = htons ( 8 + sizeof th ) ; memmove ( ret -> data + 2 , exif , sizeof ( exif ) ) ; tiff_head ( & th , 0 ) ; memmove ( ret -> data + ( 2 + sizeof ( exif ) ) , & th , sizeof ( th ) ) ; memmove ( ret -> data + ( 2 + sizeof ( exif ) + sizeof ( th ) ) , T . thumb + 2 , T . tlength - 2 ) ; } else { memmove ( ret -> data + 2 , T . thumb + 2 , T . tlength - 2 ) ; } if ( errcode ) * errcode = 0 ; return ret ; } else { if ( errcode ) * errcode = LIBRAW_UNSUPPORTED_THUMBNAIL ; return NULL ; } }
void Deserializer < AllocatorT > :: DeserializeDeferredObjects ( ) { for ( int code = source_ . Get ( ) ; code != kSynchronize ; code = source_ . Get ( ) ) { switch ( code ) { case kAlignmentPrefix : case kAlignmentPrefix + 1 : case kAlignmentPrefix + 2 : { int alignment = code - ( SerializerDeserializer :: kAlignmentPrefix - 1 ) ; allocator ( ) -> SetAlignment ( static_cast < AllocationAlignment > ( alignment ) ) ; break ; } default : { int space = code & kSpaceMask ; DCHECK_LE ( space , kNumberOfSpaces ) ; DCHECK_EQ ( code - space , kNewObject ) ; HeapObject * object = GetBackReferencedObject ( space ) ; int size = source_ . GetInt ( ) < < kPointerSizeLog2 ; Address obj_address = object -> address ( ) ; MaybeObject * * start = reinterpret_cast < MaybeObject * * > ( obj_address + kPointerSize ) ; MaybeObject * * end = reinterpret_cast < MaybeObject * * > ( obj_address + size ) ; bool filled = ReadData ( start , end , space , obj_address ) ; CHECK ( filled ) ; DCHECK ( CanBeDeferred ( object ) ) ; PostProcessNewObject ( object , space ) ; } } } }
void SoftHEVC :: onQueueFilled ( OMX_U32 portIndex ) { UNUSED ( portIndex ) ; if ( mSignalledError ) { return ; } if ( mOutputPortSettingsChange != NONE ) { return ; } if ( NULL == mCodecCtx ) { if ( OK != initDecoder ( ) ) { return ; } } if ( outputBufferWidth ( ) != mStride ) { mStride = outputBufferWidth ( ) ; setParams ( mStride ) ; } List < BufferInfo * > & inQueue = getPortQueue ( kInputPortIndex ) ; List < BufferInfo * > & outQueue = getPortQueue ( kOutputPortIndex ) ; if ( mReceivedEOS && ! mIsInFlush ) { setFlushMode ( ) ; } while ( ! outQueue . empty ( ) ) { BufferInfo * inInfo ; OMX_BUFFERHEADERTYPE * inHeader ; BufferInfo * outInfo ; OMX_BUFFERHEADERTYPE * outHeader ; size_t timeStampIx ; inInfo = NULL ; inHeader = NULL ; if ( ! mIsInFlush ) { if ( ! inQueue . empty ( ) ) { inInfo = * inQueue . begin ( ) ; inHeader = inInfo -> mHeader ; } else { break ; } } outInfo = * outQueue . begin ( ) ; outHeader = outInfo -> mHeader ; outHeader -> nFlags = 0 ; outHeader -> nTimeStamp = 0 ; outHeader -> nOffset = 0 ; if ( inHeader != NULL && ( inHeader -> nFlags & OMX_BUFFERFLAG_EOS ) ) { mReceivedEOS = true ; if ( inHeader -> nFilledLen == 0 ) { inQueue . erase ( inQueue . begin ( ) ) ; inInfo -> mOwnedByUs = false ; notifyEmptyBufferDone ( inHeader ) ; inHeader = NULL ; setFlushMode ( ) ; } } { size_t i ; timeStampIx = 0 ; for ( i = 0 ; i < MAX_TIME_STAMPS ; i ++ ) { if ( ! mTimeStampsValid [ i ] ) { timeStampIx = i ; break ; } } if ( inHeader != NULL ) { mTimeStampsValid [ timeStampIx ] = true ; mTimeStamps [ timeStampIx ] = inHeader -> nTimeStamp ; } } { ivd_video_decode_ip_t s_dec_ip ; ivd_video_decode_op_t s_dec_op ; WORD32 timeDelay , timeTaken ; size_t sizeY , sizeUV ; setDecodeArgs ( & s_dec_ip , & s_dec_op , inHeader , outHeader , timeStampIx ) ; GETTIME ( & mTimeStart , NULL ) ; TIME_DIFF ( mTimeEnd , mTimeStart , timeDelay ) ; IV_API_CALL_STATUS_T status ; status = ivdec_api_function ( mCodecCtx , ( void * ) & s_dec_ip , ( void * ) & s_dec_op ) ; bool resChanged = ( IVD_RES_CHANGED == ( s_dec_op . u4_error_code & 0xFF ) ) ; GETTIME ( & mTimeEnd , NULL ) ; TIME_DIFF ( mTimeStart , mTimeEnd , timeTaken ) ; ALOGV ( "timeTaken=%6d delay=%6d numBytes=%6d" , timeTaken , timeDelay , s_dec_op . u4_num_bytes_consumed ) ; if ( s_dec_op . u4_frame_decoded_flag && ! mFlushNeeded ) { mFlushNeeded = true ; } if ( ( inHeader != NULL ) && ( 1 != s_dec_op . u4_frame_decoded_flag ) ) { mTimeStampsValid [ timeStampIx ] = false ; } if ( mChangingResolution && ! s_dec_op . u4_output_present ) { mChangingResolution = false ; resetDecoder ( ) ; resetPlugin ( ) ; continue ; } if ( resChanged ) { mChangingResolution = true ; if ( mFlushNeeded ) { setFlushMode ( ) ; } continue ; } if ( ( 0 < s_dec_op . u4_pic_wd ) && ( 0 < s_dec_op . u4_pic_ht ) ) { uint32_t width = s_dec_op . u4_pic_wd ; uint32_t height = s_dec_op . u4_pic_ht ; bool portWillReset = false ; handlePortSettingsChange ( & portWillReset , width , height ) ; if ( portWillReset ) { resetDecoder ( ) ; return ; } } if ( s_dec_op . u4_output_present ) { outHeader -> nFilledLen = ( outputBufferWidth ( ) * outputBufferHeight ( ) * 3 ) / 2 ; outHeader -> nTimeStamp = mTimeStamps [ s_dec_op . u4_ts ] ; mTimeStampsValid [ s_dec_op . u4_ts ] = false ; outInfo -> mOwnedByUs = false ; outQueue . erase ( outQueue . begin ( ) ) ; outInfo = NULL ; notifyFillBufferDone ( outHeader ) ; outHeader = NULL ; } else { mIsInFlush = false ; if ( mReceivedEOS ) { outHeader -> nFilledLen = 0 ; outHeader -> nFlags |= OMX_BUFFERFLAG_EOS ; outInfo -> mOwnedByUs = false ; outQueue . erase ( outQueue . begin ( ) ) ; outInfo = NULL ; notifyFillBufferDone ( outHeader ) ; outHeader = NULL ; resetPlugin ( ) ; } } } if ( inHeader != NULL ) { inInfo -> mOwnedByUs = false ; inQueue . erase ( inQueue . begin ( ) ) ; inInfo = NULL ; notifyEmptyBufferDone ( inHeader ) ; inHeader = NULL ; } } }
PreprocessValue ( JSContext * cx , HandleObject holder , KeyType key , MutableHandleValue vp , StringifyContext * scx ) { RootedString keyStr ( cx ) ; if ( vp . isObject ( ) ) { RootedValue toJSON ( cx ) ; RootedObject obj ( cx , & vp . toObject ( ) ) ; if ( ! GetProperty ( cx , obj , obj , cx -> names ( ) . toJSON , & toJSON ) ) return false ; if ( IsCallable ( toJSON ) ) { keyStr = KeyStringifier < KeyType > :: toString ( cx , key ) ; if ( ! keyStr ) return false ; InvokeArgs args ( cx ) ; if ( ! args . init ( 1 ) ) return false ; args . setCallee ( toJSON ) ; args . setThis ( vp ) ; args [ 0 ] . setString ( keyStr ) ; if ( ! Invoke ( cx , args ) ) return false ; vp . set ( args . rval ( ) ) ; } } if ( scx -> replacer && scx -> replacer -> isCallable ( ) ) { if ( ! keyStr ) { keyStr = KeyStringifier < KeyType > :: toString ( cx , key ) ; if ( ! keyStr ) return false ; } InvokeArgs args ( cx ) ; if ( ! args . init ( 2 ) ) return false ; args . setCallee ( ObjectValue ( * scx -> replacer ) ) ; args . setThis ( ObjectValue ( * holder ) ) ; args [ 0 ] . setString ( keyStr ) ; args [ 1 ] . set ( vp ) ; if ( ! Invoke ( cx , args ) ) return false ; vp . set ( args . rval ( ) ) ; } if ( vp . get ( ) . isObject ( ) ) { RootedObject obj ( cx , & vp . get ( ) . toObject ( ) ) ; if ( ObjectClassIs ( obj , ESClass_Number , cx ) ) { double d ; if ( ! ToNumber ( cx , vp , & d ) ) return false ; vp . set ( NumberValue ( d ) ) ; } else if ( ObjectClassIs ( obj , ESClass_String , cx ) ) { JSString * str = ToStringSlow < CanGC > ( cx , vp ) ; if ( ! str ) return false ; vp . set ( StringValue ( str ) ) ; } else if ( ObjectClassIs ( obj , ESClass_Boolean , cx ) ) { vp . setBoolean ( BooleanGetPrimitiveValue ( obj ) ) ; } } return true ; }
void GeneratorBuiltinsAssembler :: GeneratorPrototypeResume ( CodeStubArguments * args , Node * receiver , Node * value , Node * context , JSGeneratorObject :: ResumeMode resume_mode , char const * const method_name ) { ThrowIfNotInstanceType ( context , receiver , JS_GENERATOR_OBJECT_TYPE , method_name ) ; TNode < Smi > receiver_continuation = CAST ( LoadObjectField ( receiver , JSGeneratorObject :: kContinuationOffset ) ) ; Label if_receiverisclosed ( this , Label :: kDeferred ) , if_receiverisrunning ( this , Label :: kDeferred ) ; TNode < Smi > closed = SmiConstant ( JSGeneratorObject :: kGeneratorClosed ) ; GotoIf ( SmiEqual ( receiver_continuation , closed ) , & if_receiverisclosed ) ; DCHECK_LT ( JSGeneratorObject :: kGeneratorExecuting , JSGeneratorObject :: kGeneratorClosed ) ; GotoIf ( SmiLessThan ( receiver_continuation , closed ) , & if_receiverisrunning ) ; StoreObjectFieldNoWriteBarrier ( receiver , JSGeneratorObject :: kResumeModeOffset , SmiConstant ( resume_mode ) ) ; VARIABLE ( var_exception , MachineRepresentation :: kTagged , UndefinedConstant ( ) ) ; Label if_exception ( this , Label :: kDeferred ) , if_final_return ( this ) ; Node * result = CallStub ( CodeFactory :: ResumeGenerator ( isolate ( ) ) , context , value , receiver ) ; GotoIfException ( result , & if_exception , & var_exception ) ; TNode < Smi > result_continuation = CAST ( LoadObjectField ( receiver , JSGeneratorObject :: kContinuationOffset ) ) ; CSA_ASSERT ( this , SmiNotEqual ( result_continuation , closed ) ) ; TNode < Smi > executing = SmiConstant ( JSGeneratorObject :: kGeneratorExecuting ) ; GotoIf ( SmiEqual ( result_continuation , executing ) , & if_final_return ) ; args -> PopAndReturn ( result ) ; BIND ( & if_final_return ) ; { StoreObjectFieldNoWriteBarrier ( receiver , JSGeneratorObject :: kContinuationOffset , closed ) ; args -> PopAndReturn ( CallBuiltin ( Builtins :: kCreateIterResultObject , context , result , TrueConstant ( ) ) ) ; } BIND ( & if_receiverisclosed ) ; { Node * result = nullptr ; switch ( resume_mode ) { case JSGeneratorObject :: kNext : result = CallBuiltin ( Builtins :: kCreateIterResultObject , context , UndefinedConstant ( ) , TrueConstant ( ) ) ; break ; case JSGeneratorObject :: kReturn : result = CallBuiltin ( Builtins :: kCreateIterResultObject , context , value , TrueConstant ( ) ) ; break ; case JSGeneratorObject :: kThrow : result = CallRuntime ( Runtime :: kThrow , context , value ) ; break ; } args -> PopAndReturn ( result ) ; } BIND ( & if_receiverisrunning ) ; { ThrowTypeError ( context , MessageTemplate :: kGeneratorRunning ) ; } BIND ( & if_exception ) ; { StoreObjectFieldNoWriteBarrier ( receiver , JSGeneratorObject :: kContinuationOffset , closed ) ; CallRuntime ( Runtime :: kReThrow , context , var_exception . value ( ) ) ; Unreachable ( ) ; } }
std :: ostream & operator < < ( std :: ostream & os , AccessMode access_mode ) { switch ( access_mode ) { case AccessMode :: kLoad : return os < < "Load" ; case AccessMode :: kStore : return os < < "Store" ; case AccessMode :: kStoreInLiteral : return os < < "StoreInLiteral" ; } UNREACHABLE ( ) ; }
void Huff_transmit ( huff_t * huff , int ch , byte * fout ) { int i ; if ( huff -> loc [ ch ] == NULL ) { Huff_transmit ( huff , NYT , fout ) ; for ( i = 7 ; i >= 0 ; i -- ) { add_bit ( ( char ) ( ( ch > > i ) & 0x1 ) , fout ) ; } } else { send ( huff -> loc [ ch ] , NULL , fout ) ; } }
static void binder_free_proc ( struct binder_proc * proc ) { struct binder_device * device ; BUG_ON ( ! list_empty ( & proc -> todo ) ) ; BUG_ON ( ! list_empty ( & proc -> delivered_death ) ) ; if ( proc -> outstanding_txns ) pr_warn ( "%s: Unexpected outstanding_txns %d\n" , __func__ , proc -> outstanding_txns ) ; device = container_of ( proc -> context , struct binder_device , context ) ; if ( refcount_dec_and_test ( & device -> ref ) ) { kfree ( proc -> context -> name ) ; kfree ( device ) ; } binder_alloc_deferred_release ( & proc -> alloc ) ; put_task_struct ( proc -> tsk ) ; binder_stats_deleted ( BINDER_STAT_PROC ) ; kfree ( proc ) ; }
static void alarm_ready_generic ( alarm_t * alarm , std :: unique_lock < std :: mutex > & lock ) { if ( alarm == NULL ) { return ; } alarm_callback_t callback = alarm -> callback ; void * data = alarm -> data ; period_ms_t deadline = alarm -> deadline ; if ( alarm -> is_periodic ) { deadline = alarm -> prev_deadline ; } else { alarm -> deadline = 0 ; alarm -> callback = NULL ; alarm -> data = NULL ; alarm -> queue = NULL ; } std :: lock_guard < std :: recursive_mutex > cb_lock ( * alarm -> callback_mutex ) ; lock . unlock ( ) ; period_ms_t t0 = now ( ) ; callback ( data ) ; period_ms_t t1 = now ( ) ; CHECK ( t1 >= t0 ) ; period_ms_t delta = t1 - t0 ; update_scheduling_stats ( & alarm -> stats , t0 , deadline , delta ) ; }
static double calc_correction_factor ( double err_per_mb , double err_divisor , double pt_low , double pt_high , int q ) { const double error_term = err_per_mb / err_divisor ; const double power_term = MIN ( vp9_convert_qindex_to_q ( q ) * 0.0125 + pt_low , pt_high ) ; if ( power_term < 1.0 ) assert ( error_term >= 0.0 ) ; return fclamp ( pow ( error_term , power_term ) , 0.05 , 5.0 ) ; }
const Operator * SimplifiedOperatorBuilder :: CompareMaps ( ZoneHandleSet < Map > maps ) { return new ( zone ( ) ) Operator1 < MapsParameterInfo > ( IrOpcode :: kCompareMaps , Operator :: kEliminatable , "CompareMaps" , 1 , 1 , 1 , 1 , 1 , 0 , MapsParameterInfo ( maps ) ) ; }
void Debug :: OnException ( Handle < Object > exception , Handle < Object > promise ) { if ( ! AllowJavascriptExecution :: IsAllowed ( isolate_ ) ) return ; Isolate :: CatchType catch_type = isolate_ -> PredictExceptionCatcher ( ) ; if ( catch_type == Isolate :: CAUGHT_BY_DESUGARING ) return ; bool uncaught = catch_type == Isolate :: NOT_CAUGHT ; if ( promise -> IsJSObject ( ) ) { Handle < JSObject > jspromise = Handle < JSObject > :: cast ( promise ) ; Handle < Symbol > key = isolate_ -> factory ( ) -> promise_debug_marker_symbol ( ) ; JSObject :: SetProperty ( isolate_ , jspromise , key , key , LanguageMode :: kStrict ) . Assert ( ) ; uncaught = ! isolate_ -> PromiseHasUserDefinedRejectHandler ( jspromise ) ; } if ( ! debug_delegate_ ) return ; if ( uncaught ) { if ( ! ( break_on_uncaught_exception_ || break_on_exception_ ) ) return ; } else { if ( ! break_on_exception_ ) return ; } { JavaScriptFrameIterator it ( isolate_ ) ; if ( ! it . done ( ) && ( IsMutedAtCurrentLocation ( it . frame ( ) ) || IsExceptionBlackboxed ( uncaught ) ) ) { return ; } if ( it . done ( ) ) return ; } DebugScope debug_scope ( this ) ; HandleScope scope ( isolate_ ) ; DisableBreak no_recursive_break ( this ) ; Handle < Context > native_context ( isolate_ -> native_context ( ) ) ; debug_delegate_ -> ExceptionThrown ( v8 :: Utils :: ToLocal ( native_context ) , v8 :: Utils :: ToLocal ( exception ) , v8 :: Utils :: ToLocal ( promise ) , uncaught ) ; }
static Jsi_RC jsi_ArrayPopCmd ( Jsi_Interp * interp , Jsi_Value * args , Jsi_Value * _this , Jsi_Value * * ret , Jsi_Func * funcPtr ) { if ( _this -> vt != JSI_VT_OBJECT || ! Jsi_ObjIsArray ( interp , _this -> d . obj ) ) { Jsi_ValueMakeNumber ( interp , ret , 0 ) ; return JSI_OK ; } Jsi_Value * v ; Jsi_Obj * obj ; obj = _this -> d . obj ; int i = Jsi_ObjGetLength ( interp , obj ) - 1 ; if ( i < 0 ) { Jsi_ValueMakeUndef ( interp , ret ) ; return JSI_OK ; } if ( obj -> arr ) { if ( ( v = obj -> arr [ i ] ) ) { obj -> arr [ i ] = NULL ; obj -> arrCnt -- ; } } else { v = Jsi_ValueArrayIndex ( interp , _this , i ) ; } if ( v ) { Jsi_DecrRefCount ( interp , * ret ) ; * ret = v ; } Jsi_ObjSetLength ( interp , obj , i ) ; return JSI_OK ; }
TimerThread :: RemoveTimerInternal ( nsTimerImpl * aTimer ) { if ( ! mTimers . RemoveElement ( aTimer ) ) { return false ; } ReleaseTimerInternal ( aTimer ) ; return true ; }
TfLiteStatus HardSwishPrepare ( TfLiteContext * context , TfLiteNode * node ) { TFLITE_DCHECK ( node -> user_data != nullptr ) ; TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; if ( input -> type == kTfLiteUInt8 || input -> type == kTfLiteInt8 ) { HardSwishParams * params = static_cast < HardSwishParams * > ( node -> user_data ) ; params -> input_zero_point = input -> params . zero_point ; params -> output_zero_point = output -> params . zero_point ; const float input_scale = input -> params . scale ; const float hires_input_scale = ( 1.0f / 128.0f ) * input_scale ; const float reluish_scale = 3.0f / 32768.0f ; const float output_scale = output -> params . scale ; const double output_multiplier = static_cast < double > ( hires_input_scale / output_scale ) ; int32_t output_multiplier_fixedpoint_int32 ; QuantizeMultiplier ( output_multiplier , & output_multiplier_fixedpoint_int32 , & params -> output_multiplier_exponent ) ; DownScaleInt32ToInt16Multiplier ( output_multiplier_fixedpoint_int32 , & params -> output_multiplier_fixedpoint_int16 ) ; TF_LITE_ENSURE ( context , params -> output_multiplier_exponent <= 0 ) ; const double reluish_multiplier = static_cast < double > ( hires_input_scale / reluish_scale ) ; int32_t reluish_multiplier_fixedpoint_int32 ; QuantizeMultiplier ( reluish_multiplier , & reluish_multiplier_fixedpoint_int32 , & params -> reluish_multiplier_exponent ) ; DownScaleInt32ToInt16Multiplier ( reluish_multiplier_fixedpoint_int32 , & params -> reluish_multiplier_fixedpoint_int16 ) ; } return kTfLiteOk ; }
static int ovl_copy_up_locked ( struct dentry * workdir , struct dentry * upperdir , struct dentry * dentry , struct path * lowerpath , struct kstat * stat , struct iattr * attr , const char * link ) { struct inode * wdir = workdir -> d_inode ; struct inode * udir = upperdir -> d_inode ; struct dentry * newdentry = NULL ; struct dentry * upper = NULL ; umode_t mode = stat -> mode ; int err ; newdentry = ovl_lookup_temp ( workdir , dentry ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out1 ; stat -> mode &= S_IFMT ; err = ovl_create_real ( wdir , newdentry , stat , link , NULL , true ) ; stat -> mode = mode ; if ( err ) goto out2 ; if ( S_ISREG ( stat -> mode ) ) { struct path upperpath ; ovl_path_upper ( dentry , & upperpath ) ; BUG_ON ( upperpath . dentry != NULL ) ; upperpath . dentry = newdentry ; err = ovl_copy_up_data ( lowerpath , & upperpath , stat -> size ) ; if ( err ) goto out_cleanup ; } err = ovl_copy_xattr ( lowerpath -> dentry , newdentry ) ; if ( err ) goto out_cleanup ; mutex_lock ( & newdentry -> d_inode -> i_mutex ) ; err = ovl_set_attr ( newdentry , stat ) ; if ( ! err && attr ) err = notify_change ( newdentry , attr , NULL ) ; mutex_unlock ( & newdentry -> d_inode -> i_mutex ) ; if ( err ) goto out_cleanup ; err = ovl_do_rename ( wdir , newdentry , udir , upper , 0 ) ; if ( err ) goto out_cleanup ; ovl_dentry_update ( dentry , newdentry ) ; newdentry = NULL ; if ( ! S_ISDIR ( stat -> mode ) ) ovl_dentry_set_opaque ( dentry , true ) ; out2 : dput ( upper ) ; out1 : dput ( newdentry ) ; out : return err ; out_cleanup : ovl_cleanup ( wdir , newdentry ) ; goto out ; }
VisitResult ImplementationVisitor :: Visit ( ConditionalExpression * expr ) { std :: string f1 = NewTempVariable ( ) ; std :: string f2 = NewTempVariable ( ) ; VisitResult left , right ; GenerateIndent ( ) ; source_out ( ) < < "auto " < < f1 < < " = [=]() " ; { ScopedIndent indent ( this , false ) ; source_out ( ) < < "\n" ; left = Visit ( expr -> if_true ) ; GenerateIndent ( ) ; source_out ( ) < < "return " < < RValueFlattenStructs ( left ) < < ";\n" ; } source_out ( ) < < ";\n" ; GenerateIndent ( ) ; source_out ( ) < < "auto " < < f2 < < " = [=]() " ; { ScopedIndent indent ( this , false ) ; source_out ( ) < < "\n" ; right = Visit ( expr -> if_false ) ; GenerateIndent ( ) ; source_out ( ) < < "return " < < RValueFlattenStructs ( right ) < < ";\n" ; } source_out ( ) < < ";\n" ; const Type * common_type = GetCommonType ( left . type ( ) , right . type ( ) ) ; std :: string result_var = NewTempVariable ( ) ; Variable * result = GenerateVariableDeclaration ( expr , result_var , false , common_type ) ; { ScopedIndent indent ( this ) ; Declarations :: NodeScopeActivator scope ( declarations ( ) , expr -> condition ) ; Label * true_label = declarations ( ) -> LookupLabel ( kTrueLabelName ) ; GenerateLabelDefinition ( true_label ) ; Label * false_label = declarations ( ) -> LookupLabel ( kFalseLabelName ) ; GenerateLabelDefinition ( false_label ) ; Label * done_label = declarations ( ) -> DeclarePrivateLabel ( kDoneLabelName ) ; GenerateLabelDefinition ( done_label , expr ) ; VisitResult condition_result = Visit ( expr -> condition ) ; if ( ! condition_result . type ( ) -> IsNever ( ) ) { condition_result = GenerateImplicitConvert ( TypeOracle :: GetBoolType ( ) , condition_result ) ; GenerateBranch ( condition_result , true_label , false_label ) ; } GenerateLabelBind ( true_label ) ; GenerateIndent ( ) ; VisitResult left_result = { right . type ( ) , f1 + "()" } ; GenerateAssignToVariable ( result , left_result ) ; GenerateLabelGoto ( done_label ) ; GenerateLabelBind ( false_label ) ; GenerateIndent ( ) ; VisitResult right_result = { right . type ( ) , f2 + "()" } ; GenerateAssignToVariable ( result , right_result ) ; GenerateLabelGoto ( done_label ) ; GenerateLabelBind ( done_label ) ; } return VisitResult ( common_type , result ) ; }
static int __videobuf_mmap_mapper ( struct videobuf_queue * q , struct vm_area_struct * vma ) { struct videbuf_vmalloc_memory * mem ; struct videobuf_mapping * map ; unsigned int first ; int retval ; unsigned long offset = vma -> vm_pgoff < < PAGE_SHIFT ; if ( ! ( vma -> vm_flags & VM_WRITE ) || ! ( vma -> vm_flags & VM_SHARED ) ) return - EINVAL ; for ( first = 0 ; first < VIDEO_MAX_FRAME ; first ++ ) { if ( NULL == q -> bufs [ first ] ) continue ; if ( V4L2_MEMORY_MMAP != q -> bufs [ first ] -> memory ) continue ; if ( q -> bufs [ first ] -> boff == offset ) break ; } if ( VIDEO_MAX_FRAME == first ) { dprintk ( 1 , "mmap app bug: offset invalid [offset=0x%lx]\n" , ( vma -> vm_pgoff < < PAGE_SHIFT ) ) ; return - EINVAL ; } map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ; if ( NULL == map ) return - ENOMEM ; map -> start = vma -> vm_start ; map -> end = vma -> vm_end ; map -> q = q ; q -> bufs [ first ] -> baddr = vma -> vm_start ; vma -> vm_ops = & videobuf_vm_ops ; vma -> vm_flags |= VM_DONTEXPAND | VM_RESERVED ; vma -> vm_private_data = map ; mem = q -> bufs [ first ] -> priv ; BUG_ON ( ! mem ) ; MAGIC_CHECK ( mem -> magic , MAGIC_VMAL_MEM ) ; retval = remap_vmalloc_range ( vma , mem -> vmalloc , 0 ) ; if ( retval < 0 ) { dprintk ( 1 , "mmap: postponing remap_vmalloc_range\n" ) ; mem -> vma = kmalloc ( sizeof ( * vma ) , GFP_KERNEL ) ; if ( ! mem -> vma ) { kfree ( map ) ; q -> bufs [ first ] -> map = NULL ; return - ENOMEM ; } memcpy ( mem -> vma , vma , sizeof ( * vma ) ) ; } dprintk ( 1 , "mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\n" , map , q , vma -> vm_start , vma -> vm_end , ( long int ) q -> bufs [ first ] -> bsize , vma -> vm_pgoff , first ) ; videobuf_vm_open ( vma ) ; return ( 0 ) ; }
static QSvgNode * createPathNode ( QSvgNode * parent , const QXmlStreamAttributes & attributes , QSvgHandler * ) { QStringRef data = attributes . value ( QLatin1String ( "d" ) ) ; QPainterPath qpath ; qpath . setFillRule ( Qt :: WindingFill ) ; parsePathDataFast ( data , qpath ) ; QSvgNode * path = new QSvgPath ( parent , qpath ) ; return path ; }
block_insert ( oparg_T * oap , char_u * s , int b_insert , struct block_def * bdp ) { int ts_val ; int count = 0 ; int spaces = 0 ; colnr_T offset ; colnr_T startcol ; unsigned s_len ; char_u * newp , * oldp ; linenr_T lnum ; int oldstate = State ; State = INSERT ; s_len = ( unsigned ) STRLEN ( s ) ; for ( lnum = oap -> start . lnum + 1 ; lnum <= oap -> end . lnum ; lnum ++ ) { block_prep ( oap , bdp , lnum , TRUE ) ; if ( bdp -> is_short && b_insert ) continue ; oldp = ml_get ( lnum ) ; if ( b_insert ) { ts_val = bdp -> start_char_vcols ; spaces = bdp -> startspaces ; if ( spaces != 0 ) count = ts_val - 1 ; offset = bdp -> textcol ; } else { ts_val = bdp -> end_char_vcols ; if ( ! bdp -> is_short ) { spaces = ( bdp -> endspaces ? ts_val - bdp -> endspaces : 0 ) ; if ( spaces != 0 ) count = ts_val - 1 ; offset = bdp -> textcol + bdp -> textlen - ( spaces != 0 ) ; } else { if ( ! bdp -> is_MAX ) spaces = ( oap -> end_vcol - bdp -> end_vcol ) + 1 ; count = spaces ; offset = bdp -> textcol + bdp -> textlen ; } } if ( has_mbyte && spaces > 0 ) { int off ; if ( b_insert ) { off = ( * mb_head_off ) ( oldp , oldp + offset + spaces ) ; spaces -= off ; count -= off ; } else { off = ( * mb_head_off ) ( oldp , oldp + offset ) ; offset -= off ; } } if ( spaces < 0 ) spaces = 0 ; newp = alloc ( STRLEN ( oldp ) + spaces + s_len + ( spaces > 0 && ! bdp -> is_short ? ts_val - spaces : 0 ) + count + 1 ) ; if ( newp == NULL ) continue ; mch_memmove ( newp , oldp , ( size_t ) offset ) ; oldp += offset ; vim_memset ( newp + offset , ' ' , ( size_t ) spaces ) ; startcol = offset + spaces ; mch_memmove ( newp + startcol , s , ( size_t ) s_len ) ; offset += s_len ; if ( spaces > 0 && ! bdp -> is_short ) { if ( * oldp == TAB ) { vim_memset ( newp + offset + spaces , ' ' , ( size_t ) ( ts_val - spaces ) ) ; oldp ++ ; count ++ ; } else count = spaces ; } if ( spaces > 0 ) offset += count ; STRMOVE ( newp + offset , oldp ) ; ml_replace ( lnum , newp , FALSE ) ; if ( b_insert ) inserted_bytes ( lnum , startcol , s_len ) ; if ( lnum == oap -> end . lnum ) { curbuf -> b_op_end . lnum = oap -> end . lnum ; curbuf -> b_op_end . col = offset ; } } changed_lines ( oap -> start . lnum + 1 , 0 , oap -> end . lnum + 1 , 0L ) ; State = oldstate ; }
IDBRequest :: IDBRequest ( ) : mResultVal ( JSVAL_VOID ) , mActorParent ( nsnull ) , mErrorCode ( NS_OK ) , mHaveResultOrErrorCode ( false ) , mRooted ( false ) , mLineNo ( 0 ) { NS_ASSERTION ( NS_IsMainThread ( ) , "Wrong thread!" ) ; }
static int ghash_update ( struct shash_desc * desc , const u8 * src , unsigned int srclen ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * dst = dctx -> buffer ; if ( dctx -> bytes ) { int n = min ( srclen , dctx -> bytes ) ; u8 * pos = dst + ( GHASH_BLOCK_SIZE - dctx -> bytes ) ; dctx -> bytes -= n ; srclen -= n ; while ( n -- ) * pos ++ ^= * src ++ ; if ( ! dctx -> bytes ) gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; } while ( srclen >= GHASH_BLOCK_SIZE ) { crypto_xor ( dst , src , GHASH_BLOCK_SIZE ) ; gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; src += GHASH_BLOCK_SIZE ; srclen -= GHASH_BLOCK_SIZE ; } if ( srclen ) { dctx -> bytes = GHASH_BLOCK_SIZE - srclen ; while ( srclen -- ) * dst ++ ^= * src ++ ; } return 0 ; }
void AsyncFunctionBuiltinsAssembler :: AsyncFunctionAwait ( Node * const context , Node * const generator , Node * const awaited , Node * const outer_promise , const bool is_predicted_as_caught ) { CSA_SLOW_ASSERT ( this , HasInstanceType ( generator , JS_GENERATOR_OBJECT_TYPE ) ) ; CSA_SLOW_ASSERT ( this , HasInstanceType ( outer_promise , JS_PROMISE_TYPE ) ) ; ContextInitializer init_closure_context = [ & ] ( Node * context ) { StoreContextElementNoWriteBarrier ( context , AwaitContext :: kGeneratorSlot , generator ) ; } ; Label after_debug_hook ( this ) , call_debug_hook ( this , Label :: kDeferred ) ; GotoIf ( HasAsyncEventDelegate ( ) , & call_debug_hook ) ; Goto ( & after_debug_hook ) ; BIND ( & after_debug_hook ) ; Await ( context , generator , awaited , outer_promise , AwaitContext :: kLength , init_closure_context , Context :: ASYNC_FUNCTION_AWAIT_RESOLVE_SHARED_FUN , Context :: ASYNC_FUNCTION_AWAIT_REJECT_SHARED_FUN , is_predicted_as_caught ) ; Return ( outer_promise ) ; BIND ( & call_debug_hook ) ; CallRuntime ( Runtime :: kDebugAsyncFunctionSuspended , context , outer_promise ) ; Goto ( & after_debug_hook ) ; }
bool BytecodeAnalysis :: LivenessIsValid ( ) { interpreter :: BytecodeArrayRandomIterator iterator ( bytecode_array ( ) , zone ( ) ) ; BytecodeLivenessState previous_liveness ( bytecode_array ( ) -> register_count ( ) , zone ( ) ) ; int invalid_offset = - 1 ; int which_invalid = - 1 ; BytecodeLivenessState * next_bytecode_in_liveness = nullptr ; for ( iterator . GoToEnd ( ) ; iterator . IsValid ( ) ; -- iterator ) { Bytecode bytecode = iterator . current_bytecode ( ) ; int current_offset = iterator . current_offset ( ) ; BytecodeLiveness & liveness = liveness_map_ . GetLiveness ( current_offset ) ; previous_liveness . CopyFrom ( * liveness . out ) ; UpdateOutLiveness ( bytecode , * liveness . out , next_bytecode_in_liveness , iterator , liveness_map_ ) ; if ( bytecode == Bytecode :: kJumpLoop ) { int target_offset = iterator . GetJumpTargetOffset ( ) ; liveness . out -> Union ( * liveness_map_ . GetInLiveness ( target_offset ) ) ; } if ( ! liveness . out -> Equals ( previous_liveness ) ) { liveness . out -> CopyFrom ( previous_liveness ) ; invalid_offset = current_offset ; which_invalid = 1 ; break ; } previous_liveness . CopyFrom ( * liveness . in ) ; liveness . in -> CopyFrom ( * liveness . out ) ; UpdateInLiveness ( bytecode , * liveness . in , iterator ) ; if ( ! liveness . in -> Equals ( previous_liveness ) ) { liveness . in -> CopyFrom ( previous_liveness ) ; invalid_offset = current_offset ; which_invalid = 0 ; break ; } next_bytecode_in_liveness = liveness . in ; } for ( iterator . GoToStart ( ) ; iterator . IsValid ( ) && invalid_offset == - 1 ; ++ iterator ) { Bytecode bytecode = iterator . current_bytecode ( ) ; int current_offset = iterator . current_offset ( ) ; int loop_header = GetLoopOffsetFor ( current_offset ) ; if ( loop_header == - 1 ) continue ; if ( ! Bytecodes :: IsJump ( bytecode ) ) continue ; int jump_target = iterator . GetJumpTargetOffset ( ) ; if ( Bytecodes :: IsForwardJump ( bytecode ) && GetLoopOffsetFor ( jump_target ) == loop_header ) { continue ; } if ( liveness_map_ . GetLiveness ( jump_target ) . in -> AccumulatorIsLive ( ) ) { invalid_offset = jump_target ; which_invalid = 0 ; break ; } } if ( invalid_offset != - 1 ) { OFStream of ( stderr ) ; of < < "Invalid liveness:" < < std :: endl ; int loop_indent = 0 ; interpreter :: BytecodeArrayIterator forward_iterator ( bytecode_array ( ) ) ; for ( ; ! forward_iterator . done ( ) ; forward_iterator . Advance ( ) ) { int current_offset = forward_iterator . current_offset ( ) ; const BitVector & in_liveness = GetInLivenessFor ( current_offset ) -> bit_vector ( ) ; const BitVector & out_liveness = GetOutLivenessFor ( current_offset ) -> bit_vector ( ) ; for ( int i = 0 ; i < in_liveness . length ( ) ; ++ i ) { of < < ( in_liveness . Contains ( i ) ? 'L' : '.' ) ; } of < < " | " ; for ( int i = 0 ; i < out_liveness . length ( ) ; ++ i ) { of < < ( out_liveness . Contains ( i ) ? 'L' : '.' ) ; } of < < " : " < < current_offset < < " : " ; if ( forward_iterator . current_bytecode ( ) == Bytecode :: kJumpLoop ) { loop_indent -- ; } for ( int i = 0 ; i < loop_indent ; ++ i ) { of < < "| " ; } if ( forward_iterator . current_bytecode ( ) == Bytecode :: kJumpLoop ) { of < < "`-" ; } else if ( IsLoopHeader ( current_offset ) ) { of < < ".>" ; loop_indent ++ ; } forward_iterator . PrintTo ( of ) ; if ( Bytecodes :: IsJump ( forward_iterator . current_bytecode ( ) ) ) { of < < " (@" < < forward_iterator . GetJumpTargetOffset ( ) < < ")" ; } of < < std :: endl ; if ( current_offset == invalid_offset ) { if ( which_invalid == 0 ) { for ( int i = 0 ; i < in_liveness . length ( ) ; ++ i ) { of < < '^' ; } for ( int i = 0 ; i < out_liveness . length ( ) + 3 ; ++ i ) { of < < ' ' ; } } else { for ( int i = 0 ; i < in_liveness . length ( ) + 3 ; ++ i ) { of < < ' ' ; } for ( int i = 0 ; i < out_liveness . length ( ) ; ++ i ) { of < < '^' ; } } of < < " : " < < current_offset < < " : " ; for ( int i = 0 ; i < loop_indent ; ++ i ) { of < < "| " ; } of < < std :: endl ; } } } return invalid_offset == - 1 ; }
Callable Builtins :: CallableFor ( Isolate * isolate , Name name ) { Handle < Code > code = isolate -> builtins ( ) -> builtin_handle ( name ) ; CallDescriptors :: Key key ; switch ( name ) { #define CASE_OTHER(Name, ...)                          \  case k##Name: {                                      \     key = Builtin_##Name##_InterfaceDescriptor::key(); \  break;                                             \  } BUILTIN_LIST ( IGNORE_BUILTIN , IGNORE_BUILTIN , IGNORE_BUILTIN , CASE_OTHER , CASE_OTHER , CASE_OTHER , IGNORE_BUILTIN , IGNORE_BUILTIN ) #undef CASE_OTHER default : Builtins :: Kind kind = Builtins :: KindOf ( name ) ; DCHECK_NE ( kind , BCH ) ; if ( kind == TFJ || kind == CPP ) { return Callable ( code , JSTrampolineDescriptor { } ) ; } UNREACHABLE ( ) ; } CallInterfaceDescriptor descriptor ( key ) ; return Callable ( code , descriptor ) ; }
HeapSnapshot * HeapProfiler :: TakeSnapshot ( v8 :: ActivityControl * control , v8 :: HeapProfiler :: ObjectNameResolver * resolver ) { HeapSnapshot * result = new HeapSnapshot ( this ) ; { HeapSnapshotGenerator generator ( result , control , resolver , heap ( ) ) ; if ( ! generator . GenerateSnapshot ( ) ) { delete result ; result = nullptr ; } else { snapshots_ . emplace_back ( result ) ; } } ids_ -> RemoveDeadEntries ( ) ; is_tracking_object_moves_ = true ; heap ( ) -> isolate ( ) -> debug ( ) -> feature_tracker ( ) -> Track ( DebugFeatureTracker :: kHeapSnapshot ) ; return result ; }
nsBaseChannel :: HandleAsyncRedirect ( nsIChannel * newChannel ) { NS_ASSERTION ( ! mPump , "Shouldn't have gotten here" ) ; nsresult rv = Redirect ( newChannel , nsIChannelEventSink :: REDIRECT_INTERNAL , PR_TRUE ) ; if ( NS_FAILED ( rv ) ) { Cancel ( rv ) ; mListener -> OnStartRequest ( this , mListenerContext ) ; mListener -> OnStopRequest ( this , mListenerContext , mStatus ) ; mListener = nsnull ; mListenerContext = nsnull ; } if ( mLoadGroup ) mLoadGroup -> RemoveRequest ( this , nsnull , mStatus ) ; mCallbacks = nsnull ; CallbacksChanged ( ) ; }
static int __Pyx_modinit_type_import_code ( void ) { __Pyx_RefNannyDeclarations PyObject * __pyx_t_1 = NULL ; __Pyx_RefNannySetupContext ( "__Pyx_modinit_type_import_code" , 0 ) ; __pyx_t_1 = PyImport_ImportModule ( __Pyx_BUILTIN_MODULE_NAME ) ; if ( unlikely ( ! __pyx_t_1 ) ) __PYX_ERR ( 1 , 9 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_1 ) ; __pyx_ptype_7cpython_4type_type = __Pyx_ImportType ( __pyx_t_1 , __Pyx_BUILTIN_MODULE_NAME , "type" , #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000 sizeof ( PyTypeObject ) , #else sizeof ( PyHeapTypeObject ) , #endif __Pyx_ImportType_CheckSize_Warn ) ; if ( ! __pyx_ptype_7cpython_4type_type ) __PYX_ERR ( 1 , 9 , __pyx_L1_error ) __Pyx_DECREF ( __pyx_t_1 ) ; __pyx_t_1 = 0 ; __pyx_t_1 = PyImport_ImportModule ( __Pyx_BUILTIN_MODULE_NAME ) ; if ( unlikely ( ! __pyx_t_1 ) ) __PYX_ERR ( 2 , 8 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_1 ) ; __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType ( __pyx_t_1 , __Pyx_BUILTIN_MODULE_NAME , "bool" , sizeof ( PyBoolObject ) , __Pyx_ImportType_CheckSize_Warn ) ; if ( ! __pyx_ptype_7cpython_4bool_bool ) __PYX_ERR ( 2 , 8 , __pyx_L1_error ) __Pyx_DECREF ( __pyx_t_1 ) ; __pyx_t_1 = 0 ; __pyx_t_1 = PyImport_ImportModule ( __Pyx_BUILTIN_MODULE_NAME ) ; if ( unlikely ( ! __pyx_t_1 ) ) __PYX_ERR ( 3 , 15 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_1 ) ; __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType ( __pyx_t_1 , __Pyx_BUILTIN_MODULE_NAME , "complex" , sizeof ( PyComplexObject ) , __Pyx_ImportType_CheckSize_Warn ) ; if ( ! __pyx_ptype_7cpython_7complex_complex ) __PYX_ERR ( 3 , 15 , __pyx_L1_error ) __Pyx_DECREF ( __pyx_t_1 ) ; __pyx_t_1 = 0 ; __Pyx_RefNannyFinishContext ( ) ; return 0 ; __pyx_L1_error : ; __Pyx_XDECREF ( __pyx_t_1 ) ; __Pyx_RefNannyFinishContext ( ) ; return - 1 ; }
js :: CloneRegExpObject ( JSContext * cx , JSObject * obj_ ) { Rooted < RegExpObject * > regex ( cx , & obj_ -> as < RegExpObject > ( ) ) ; RegExpStatics * currentStatics = regex -> getProto ( ) -> global ( ) . getRegExpStatics ( cx ) ; if ( ! currentStatics ) return nullptr ; if ( ! EmptyShape :: ensureInitialCustomShape < RegExpObject > ( cx , clone ) ) return nullptr ; Rooted < JSAtom * > source ( cx , regex -> getSource ( ) ) ; RegExpFlag origFlags = regex -> getFlags ( ) ; RegExpFlag staticsFlags = currentStatics -> getFlags ( ) ; if ( ( origFlags & staticsFlags ) != staticsFlags ) { Rooted < RegExpObject * > clone ( cx , RegExpAlloc ( cx ) ) ; if ( ! clone ) return nullptr ; if ( ! RegExpObject :: initFromAtom ( cx , clone , source , RegExpFlag ( origFlags | staticsFlags ) ) ) return nullptr ; return clone ; } RootedObjectGroup group ( cx , regex -> group ( ) ) ; Rooted < RegExpObject * > clone ( cx , NewObjectWithGroup < RegExpObject > ( cx , group , TenuredObject ) ) ; if ( ! clone ) return nullptr ; clone -> initPrivate ( nullptr ) ; RegExpGuard g ( cx ) ; if ( ! regex -> getShared ( cx , & g ) ) return nullptr ; if ( ! RegExpObject :: initFromAtom ( cx , clone , source , g -> getFlags ( ) ) ) return nullptr ; clone -> setShared ( * g . re ( ) ) ; return clone ; }
png_ensure_fcTL_is_valid ( png_structp png_ptr , png_uint_32 width , png_uint_32 height , png_uint_32 x_offset , png_uint_32 y_offset , png_uint_16 delay_num , png_uint_16 delay_den , png_byte dispose_op , png_byte blend_op ) { if ( width == 0 || width > PNG_UINT_31_MAX ) png_error ( png_ptr , "invalid width in fcTL (> 2^31-1)" ) ; if ( height == 0 || height > PNG_UINT_31_MAX ) png_error ( png_ptr , "invalid height in fcTL (> 2^31-1)" ) ; if ( x_offset > PNG_UINT_31_MAX ) png_error ( png_ptr , "invalid x_offset in fcTL (> 2^31-1)" ) ; if ( y_offset > PNG_UINT_31_MAX ) png_error ( png_ptr , "invalid y_offset in fcTL (> 2^31-1)" ) ; if ( width + x_offset > png_ptr -> first_frame_width || height + y_offset > png_ptr -> first_frame_height ) png_error ( png_ptr , "dimensions of a frame are greater than " "the ones in IHDR" ) ; if ( dispose_op != PNG_DISPOSE_OP_NONE && dispose_op != PNG_DISPOSE_OP_BACKGROUND && dispose_op != PNG_DISPOSE_OP_PREVIOUS ) png_error ( png_ptr , "invalid dispose_op in fcTL" ) ; if ( blend_op != PNG_BLEND_OP_SOURCE && blend_op != PNG_BLEND_OP_OVER ) png_error ( png_ptr , "invalid blend_op in fcTL" ) ; PNG_UNUSED ( delay_num ) PNG_UNUSED ( delay_den ) }
MOBI_RET mobi_trie_insert_infl ( MOBITrie * * root , const MOBIIndx * indx , size_t i ) { MOBIIndexEntry e = indx -> entries [ i ] ; char * inflected = e . label ; for ( size_t j = 0 ; j < e . tags_count ; j ++ ) { MOBIIndexTag t = e . tags [ j ] ; if ( t . tagid == INDX_TAGARR_INFL_PARTS_V1 ) { for ( size_t k = 0 ; k < t . tagvalues_count - 1 ; k += 2 ) { uint32_t len = t . tagvalues [ k ] ; uint32_t offset = t . tagvalues [ k + 1 ] ; char * base = mobi_get_cncx_string_flat ( indx -> cncx_record , offset , len ) ; if ( base == NULL ) { return MOBI_MALLOC_FAILED ; } MOBI_RET ret = mobi_trie_insert_reversed ( root , base , inflected ) ; free ( base ) ; if ( ret != MOBI_SUCCESS ) { return ret ; } } } } return MOBI_SUCCESS ; }
void Heap :: CompactRetainedMaps ( WeakArrayList * retained_maps ) { DCHECK_EQ ( retained_maps , this -> retained_maps ( ) ) ; int length = retained_maps -> length ( ) ; int new_length = 0 ; int new_number_of_disposed_maps = 0 ; for ( int i = 0 ; i < length ; i += 2 ) { MaybeObject * maybe_object = retained_maps -> Get ( i ) ; if ( maybe_object -> IsClearedWeakHeapObject ( ) ) { continue ; } DCHECK ( maybe_object -> IsWeakHeapObject ( ) ) ; MaybeObject * age = retained_maps -> Get ( i + 1 ) ; DCHECK ( age -> IsSmi ( ) ) ; if ( i != new_length ) { retained_maps -> Set ( new_length , maybe_object ) ; retained_maps -> Set ( new_length + 1 , age ) ; } if ( i < number_of_disposed_maps_ ) { new_number_of_disposed_maps += 2 ; } new_length += 2 ; } number_of_disposed_maps_ = new_number_of_disposed_maps ; HeapObject * undefined = ReadOnlyRoots ( this ) . undefined_value ( ) ; for ( int i = new_length ; i < length ; i ++ ) { retained_maps -> Set ( i , HeapObjectReference :: Strong ( undefined ) ) ; } if ( new_length != length ) retained_maps -> set_length ( new_length ) ; }
Node * IntrinsicsGenerator :: CreateAsyncFromSyncIterator ( const InterpreterAssembler :: RegListNodePair & args , Node * context ) { InterpreterAssembler :: Label not_receiver ( assembler_ , InterpreterAssembler :: Label :: kDeferred ) ; InterpreterAssembler :: Label done ( assembler_ ) ; InterpreterAssembler :: Variable return_value ( assembler_ , MachineRepresentation :: kTagged ) ; Node * sync_iterator = __ LoadRegisterFromRegisterList ( args , 0 ) ; __ GotoIf ( __ TaggedIsSmi ( sync_iterator ) , & not_receiver ) ; __ GotoIfNot ( __ IsJSReceiver ( sync_iterator ) , & not_receiver ) ; Node * const next = __ GetProperty ( context , sync_iterator , factory ( ) -> next_string ( ) ) ; Node * const native_context = __ LoadNativeContext ( context ) ; Node * const map = __ LoadContextElement ( native_context , Context :: ASYNC_FROM_SYNC_ITERATOR_MAP_INDEX ) ; Node * const iterator = __ AllocateJSObjectFromMap ( map ) ; __ StoreObjectFieldNoWriteBarrier ( iterator , JSAsyncFromSyncIterator :: kSyncIteratorOffset , sync_iterator ) ; __ StoreObjectFieldNoWriteBarrier ( iterator , JSAsyncFromSyncIterator :: kNextOffset , next ) ; return_value . Bind ( iterator ) ; __ Goto ( & done ) ; __ BIND ( & not_receiver ) ; { return_value . Bind ( __ CallRuntime ( Runtime :: kThrowSymbolIteratorInvalid , context ) ) ; __ Goto ( & done ) ; } __ BIND ( & done ) ; return return_value . value ( ) ; }
static void unix_detach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; scm -> fp = UNIXCB ( skb ) . fp ; UNIXCB ( skb ) . fp = NULL ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) unix_notinflight ( scm -> fp -> fp [ i ] ) ; }
IPV6DefragInOrderSimpleTest ( void ) { Packet * p1 = NULL , * p2 = NULL , * p3 = NULL ; Packet * reassembled = NULL ; int id = 12 ; int i ; int ret = 0 ; DefragInit ( ) ; p1 = IPV6BuildTestPacket ( id , 0 , 1 , 'A' , 8 ) ; if ( p1 == NULL ) goto end ; p2 = IPV6BuildTestPacket ( id , 1 , 1 , 'B' , 8 ) ; if ( p2 == NULL ) goto end ; p3 = IPV6BuildTestPacket ( id , 2 , 0 , 'C' , 3 ) ; if ( p3 == NULL ) goto end ; if ( Defrag ( NULL , NULL , p1 , NULL ) != NULL ) goto end ; if ( Defrag ( NULL , NULL , p2 , NULL ) != NULL ) goto end ; reassembled = Defrag ( NULL , NULL , p3 , NULL ) ; if ( reassembled == NULL ) goto end ; if ( IPV6_GET_PLEN ( reassembled ) != 19 ) goto end ; for ( i = 40 ; i < 40 + 8 ; i ++ ) { if ( GET_PKT_DATA ( reassembled ) [ i ] != 'A' ) goto end ; } for ( i = 48 ; i < 48 + 8 ; i ++ ) { if ( GET_PKT_DATA ( reassembled ) [ i ] != 'B' ) goto end ; } for ( i = 56 ; i < 56 + 3 ; i ++ ) { if ( GET_PKT_DATA ( reassembled ) [ i ] != 'C' ) goto end ; } ret = 1 ; end : if ( p1 != NULL ) SCFree ( p1 ) ; if ( p2 != NULL ) SCFree ( p2 ) ; if ( p3 != NULL ) SCFree ( p3 ) ; if ( reassembled != NULL ) SCFree ( reassembled ) ; DefragDestroy ( ) ; return ret ; }
hstore_recv ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; int32 i ; int32 pcount ; StringInfo buf = ( StringInfo ) PG_GETARG_POINTER ( 0 ) ; pcount = pq_getmsgint ( buf , 4 ) ; if ( pcount == 0 ) { out = hstorePairs ( NULL , 0 , 0 ) ; PG_RETURN_POINTER ( out ) ; } pairs = palloc ( pcount * sizeof ( Pairs ) ) ; for ( i = 0 ; i < pcount ; ++ i ) { int rawlen = pq_getmsgint ( buf , 4 ) ; int len ; if ( rawlen < 0 ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( "null value not allowed for hstore key" ) ) ) ; pairs [ i ] . key = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( len ) ; pairs [ i ] . needfree = true ; rawlen = pq_getmsgint ( buf , 4 ) ; if ( rawlen < 0 ) { pairs [ i ] . val = NULL ; pairs [ i ] . vallen = 0 ; pairs [ i ] . isnull = true ; } else { pairs [ i ] . val = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . vallen = hstoreCheckValLen ( len ) ; pairs [ i ] . isnull = false ; } } pcount = hstoreUniquePairs ( pairs , pcount , & buflen ) ; out = hstorePairs ( pairs , pcount , buflen ) ; PG_RETURN_POINTER ( out ) ; }
xmlXPathFreeParserContext ( xmlXPathParserContextPtr ctxt ) { if ( ctxt -> valueTab != NULL ) { xmlFree ( ctxt -> valueTab ) ; } if ( ctxt -> comp != NULL ) { #ifdef XPATH_STREAMING if ( ctxt -> comp -> stream != NULL ) { xmlFreePatternList ( ctxt -> comp -> stream ) ; ctxt -> comp -> stream = NULL ; } #endif xmlXPathFreeCompExpr ( ctxt -> comp ) ; } xmlFree ( ctxt ) ; }
RUNTIME_FUNCTION ( Runtime_Interrupt ) { SealHandleScope shs ( isolate ) ; DCHECK_EQ ( 0 , args . length ( ) ) ; return isolate -> stack_guard ( ) -> HandleInterrupts ( ) ; }
static int shmem_remount_fs ( struct super_block * sb , int * flags , char * data ) { struct shmem_sb_info * sbinfo = SHMEM_SB ( sb ) ; struct shmem_sb_info config = * sbinfo ; unsigned long inodes ; int error = - EINVAL ; if ( shmem_parse_options ( data , & config , true ) ) return error ; spin_lock ( & sbinfo -> stat_lock ) ; inodes = sbinfo -> max_inodes - sbinfo -> free_inodes ; if ( percpu_counter_compare ( & sbinfo -> used_blocks , config . max_blocks ) > 0 ) goto out ; if ( config . max_inodes < inodes ) goto out ; if ( config . max_blocks && ! sbinfo -> max_blocks ) goto out ; if ( config . max_inodes && ! sbinfo -> max_inodes ) goto out ; error = 0 ; sbinfo -> max_blocks = config . max_blocks ; sbinfo -> max_inodes = config . max_inodes ; sbinfo -> free_inodes = config . max_inodes - inodes ; mpol_put ( sbinfo -> mpol ) ; sbinfo -> mpol = config . mpol ; out : spin_unlock ( & sbinfo -> stat_lock ) ; return error ; }
int ScopeIterator :: GetSourcePosition ( ) { if ( frame_inspector_ ) { return frame_inspector_ -> GetSourcePosition ( ) ; } else { DCHECK ( ! generator_ . is_null ( ) ) ; return generator_ -> source_position ( ) ; } }
static inline int round_down_to_int ( SkScalar x ) { double xx = x ; xx += 0.5 ; double floorXX = floor ( xx ) ; return ( int ) floorXX - ( xx == floorXX ) ; }
CryptoKey :: SetPublicKey ( SECKEYPublicKey * aPublicKey ) { nsNSSShutDownPreventionLock locker ; if ( ! aPublicKey || isAlreadyShutDown ( ) ) { mPublicKey = nullptr ; return ; } mPublicKey = SECKEY_CopyPublicKey ( aPublicKey ) ; }
Expression * Parser :: RewriteClassLiteral ( Scope * block_scope , const AstRawString * name , ClassInfo * class_info , int pos , int end_pos , bool * ok ) { DCHECK_NOT_NULL ( block_scope ) ; DCHECK_EQ ( block_scope -> scope_type ( ) , BLOCK_SCOPE ) ; DCHECK_EQ ( block_scope -> language_mode ( ) , LanguageMode :: kStrict ) ; bool has_extends = class_info -> extends != nullptr ; bool has_default_constructor = class_info -> constructor == nullptr ; if ( has_default_constructor ) { class_info -> constructor = DefaultConstructor ( name , has_extends , pos , end_pos ) ; } if ( name != nullptr ) { DCHECK_NOT_NULL ( class_info -> variable ) ; class_info -> variable -> set_initializer_position ( end_pos ) ; } FunctionLiteral * static_fields_initializer = nullptr ; if ( class_info -> has_static_class_fields ) { static_fields_initializer = CreateInitializerFunction ( class_info -> static_fields_scope , class_info -> static_fields ) ; } FunctionLiteral * instance_fields_initializer_function = nullptr ; if ( class_info -> has_instance_class_fields ) { instance_fields_initializer_function = CreateInitializerFunction ( class_info -> instance_fields_scope , class_info -> instance_fields ) ; class_info -> constructor -> set_requires_instance_fields_initializer ( true ) ; } ClassLiteral * class_literal = factory ( ) -> NewClassLiteral ( block_scope , class_info -> variable , class_info -> extends , class_info -> constructor , class_info -> properties , static_fields_initializer , instance_fields_initializer_function , pos , end_pos , class_info -> has_name_static_property , class_info -> has_static_computed_names , class_info -> is_anonymous ) ; AddFunctionForNameInference ( class_info -> constructor ) ; return class_literal ; }
GetRunner ( const ReferenceHandle & that , Local < Value > key_handle , MaybeLocal < Object > maybe_options , bool inherit ) : context { that . context } , reference { that . reference } , options { maybe_options , inherit ? TransferOptions :: Type :: DeepReference : TransferOptions :: Type :: Reference } , inherit { inherit } { that . CheckDisposed ( ) ; key = ExternalCopy :: CopyIfPrimitive ( key_handle ) ; if ( ! key ) { throw RuntimeTypeError ( "Invalid `key`" ) ; } }
void AsmJsParser :: ValidateFunctionLocals ( size_t param_count , ZoneVector < ValueType > * locals ) { DCHECK ( locals -> empty ( ) ) ; while ( Peek ( TOK ( var ) ) ) { scanner_ . EnterLocalScope ( ) ; EXPECT_TOKEN ( TOK ( var ) ) ; scanner_ . EnterGlobalScope ( ) ; for ( ; ; ) { if ( ! scanner_ . IsLocal ( ) ) { FAIL ( "Expected local variable identifier" ) ; } VarInfo * info = GetVarInfo ( Consume ( ) ) ; if ( info -> kind != VarKind :: kUnused ) { FAIL ( "Duplicate local variable name" ) ; } EXPECT_TOKEN ( '=' ) ; double dvalue = 0.0 ; uint32_t uvalue = 0 ; if ( Check ( '-' ) ) { if ( CheckForDouble ( & dvalue ) ) { info -> kind = VarKind :: kLocal ; info -> type = AsmType :: Double ( ) ; info -> index = static_cast < uint32_t > ( param_count + locals -> size ( ) ) ; locals -> push_back ( kWasmF64 ) ; current_function_builder_ -> EmitF64Const ( - dvalue ) ; current_function_builder_ -> EmitSetLocal ( info -> index ) ; } else if ( CheckForUnsigned ( & uvalue ) ) { if ( uvalue > 0x7FFFFFFF ) { FAIL ( "Numeric literal out of range" ) ; } info -> kind = VarKind :: kLocal ; info -> type = AsmType :: Int ( ) ; info -> index = static_cast < uint32_t > ( param_count + locals -> size ( ) ) ; locals -> push_back ( kWasmI32 ) ; int32_t value = - static_cast < int32_t > ( uvalue ) ; current_function_builder_ -> EmitI32Const ( value ) ; current_function_builder_ -> EmitSetLocal ( info -> index ) ; } else { FAIL ( "Expected variable initial value" ) ; } } else if ( scanner_ . IsGlobal ( ) ) { VarInfo * sinfo = GetVarInfo ( Consume ( ) ) ; if ( sinfo -> kind == VarKind :: kGlobal ) { if ( sinfo -> mutable_variable ) { FAIL ( "Initializing from global requires const variable" ) ; } info -> kind = VarKind :: kLocal ; info -> type = sinfo -> type ; info -> index = static_cast < uint32_t > ( param_count + locals -> size ( ) ) ; if ( sinfo -> type -> IsA ( AsmType :: Int ( ) ) ) { locals -> push_back ( kWasmI32 ) ; } else if ( sinfo -> type -> IsA ( AsmType :: Float ( ) ) ) { locals -> push_back ( kWasmF32 ) ; } else if ( sinfo -> type -> IsA ( AsmType :: Double ( ) ) ) { locals -> push_back ( kWasmF64 ) ; } else { FAIL ( "Bad local variable definition" ) ; } current_function_builder_ -> EmitWithI32V ( kExprGetGlobal , VarIndex ( sinfo ) ) ; current_function_builder_ -> EmitSetLocal ( info -> index ) ; } else if ( sinfo -> type -> IsA ( stdlib_fround_ ) ) { EXPECT_TOKEN ( '(' ) ; bool negate = false ; if ( Check ( '-' ) ) { negate = true ; } double dvalue = 0.0 ; if ( CheckForDouble ( & dvalue ) ) { info -> kind = VarKind :: kLocal ; info -> type = AsmType :: Float ( ) ; info -> index = static_cast < uint32_t > ( param_count + locals -> size ( ) ) ; locals -> push_back ( kWasmF32 ) ; if ( negate ) { dvalue = - dvalue ; } current_function_builder_ -> EmitF32Const ( dvalue ) ; current_function_builder_ -> EmitSetLocal ( info -> index ) ; } else if ( CheckForUnsigned ( & uvalue ) ) { if ( uvalue > 0x7FFFFFFF ) { FAIL ( "Numeric literal out of range" ) ; } info -> kind = VarKind :: kLocal ; info -> type = AsmType :: Float ( ) ; info -> index = static_cast < uint32_t > ( param_count + locals -> size ( ) ) ; locals -> push_back ( kWasmF32 ) ; int32_t value = static_cast < int32_t > ( uvalue ) ; if ( negate ) { value = - value ; } float fvalue = static_cast < float > ( value ) ; current_function_builder_ -> EmitF32Const ( fvalue ) ; current_function_builder_ -> EmitSetLocal ( info -> index ) ; } else { FAIL ( "Expected variable initial value" ) ; } EXPECT_TOKEN ( ')' ) ; } else { FAIL ( "expected fround or const global" ) ; } } else if ( CheckForDouble ( & dvalue ) ) { info -> kind = VarKind :: kLocal ; info -> type = AsmType :: Double ( ) ; info -> index = static_cast < uint32_t > ( param_count + locals -> size ( ) ) ; locals -> push_back ( kWasmF64 ) ; current_function_builder_ -> EmitF64Const ( dvalue ) ; current_function_builder_ -> EmitSetLocal ( info -> index ) ; } else if ( CheckForUnsigned ( & uvalue ) ) { info -> kind = VarKind :: kLocal ; info -> type = AsmType :: Int ( ) ; info -> index = static_cast < uint32_t > ( param_count + locals -> size ( ) ) ; locals -> push_back ( kWasmI32 ) ; int32_t value = static_cast < int32_t > ( uvalue ) ; current_function_builder_ -> EmitI32Const ( value ) ; current_function_builder_ -> EmitSetLocal ( info -> index ) ; } else { FAIL ( "Expected variable initial value" ) ; } if ( ! Peek ( ',' ) ) { break ; } scanner_ . EnterLocalScope ( ) ; EXPECT_TOKEN ( ',' ) ; scanner_ . EnterGlobalScope ( ) ; } SkipSemicolon ( ) ; } }
void vp8_yv12_extend_frame_borders_c ( YV12_BUFFER_CONFIG * ybf ) { assert ( ybf -> y_height - ybf -> y_crop_height < 16 ) ; assert ( ybf -> y_width - ybf -> y_crop_width < 16 ) ; assert ( ybf -> y_height - ybf -> y_crop_height >= 0 ) ; assert ( ybf -> y_width - ybf -> y_crop_width >= 0 ) ; extend_plane ( ybf -> y_buffer , ybf -> y_stride , ybf -> y_crop_width , ybf -> y_crop_height , ybf -> border , ybf -> border , ybf -> border + ybf -> y_height - ybf -> y_crop_height , ybf -> border + ybf -> y_width - ybf -> y_crop_width ) ; extend_plane ( ybf -> u_buffer , ybf -> uv_stride , ( ybf -> y_crop_width + 1 ) / 2 , ( ybf -> y_crop_height + 1 ) / 2 , ybf -> border / 2 , ybf -> border / 2 , ( ybf -> border + ybf -> y_height - ybf -> y_crop_height + 1 ) / 2 , ( ybf -> border + ybf -> y_width - ybf -> y_crop_width + 1 ) / 2 ) ; extend_plane ( ybf -> v_buffer , ybf -> uv_stride , ( ybf -> y_crop_width + 1 ) / 2 , ( ybf -> y_crop_height + 1 ) / 2 , ybf -> border / 2 , ybf -> border / 2 , ( ybf -> border + ybf -> y_height - ybf -> y_crop_height + 1 ) / 2 , ( ybf -> border + ybf -> y_width - ybf -> y_crop_width + 1 ) / 2 ) ; }
Status check_memory_limit ( std :: size_t bytes ) TF_EXCLUSIVE_LOCKS_REQUIRED ( mu_ ) { if ( has_memory_limit ( ) && bytes > memory_limit_ ) { return Status ( errors :: ResourceExhausted ( "Attempted to insert tensors with combined size of '" , bytes , "' bytes into Staging Area with a memory limit of '" , memory_limit_ , "'." ) ) ; } return Status :: OK ( ) ; }
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN ( nsEditor ) NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR ( mRootElement ) NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR ( mInlineSpellChecker ) NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR ( mTxnMgr ) NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR ( mIMETextRangeList ) NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR ( mIMETextNode ) NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY ( mActionListeners ) NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY ( mEditorObservers ) NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY ( mDocStateListeners ) NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR ( mEventTarget ) NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR ( mEventListener ) NS_IMPL_CYCLE_COLLECTION_UNLINK_END NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN ( nsEditor ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR ( mRootElement ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR ( mInlineSpellChecker ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR ( mTxnMgr ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR ( mIMETextRangeList ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR ( mIMETextNode ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY ( mActionListeners ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY ( mEditorObservers ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY ( mDocStateListeners ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR ( mEventTarget ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR ( mEventListener ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION ( nsEditor ) NS_INTERFACE_MAP_ENTRY ( nsIPhonetic ) NS_INTERFACE_MAP_ENTRY ( nsISupportsWeakReference ) NS_INTERFACE_MAP_ENTRY ( nsIEditorIMESupport ) NS_INTERFACE_MAP_ENTRY ( nsIEditor ) NS_INTERFACE_MAP_ENTRY_AMBIGUOUS ( nsISupports , nsIEditor ) NS_INTERFACE_MAP_END NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS ( nsEditor , nsIEditor ) NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS ( nsEditor , nsIEditor ) #ifdef XP_MAC #pragma mark - #pragma mark  nsIEditorMethods  #pragma mark - #endif NS_IMETHODIMP nsEditor :: Init ( nsIDOMDocument * aDoc , nsIPresShell * aPresShell , nsIContent * aRoot , nsISelectionController * aSelCon , PRUint32 aFlags ) { NS_PRECONDITION ( aDoc && aPresShell , "bad arg" ) ; if ( ! aDoc || ! aPresShell ) return NS_ERROR_NULL_POINTER ; #ifdef DEBUG nsresult rv = #endif SetFlags ( aFlags ) ; NS_ASSERTION ( NS_SUCCEEDED ( rv ) , "SetFlags() failed" ) ; mDocWeak = do_GetWeakReference ( aDoc ) ; mPresShellWeak = do_GetWeakReference ( aPresShell ) ; mSelConWeak = do_GetWeakReference ( aSelCon ) ; nsCOMPtr < nsIPresShell > ps = do_QueryReferent ( mPresShellWeak ) ; NS_ENSURE_TRUE ( ps , NS_ERROR_NOT_INITIALIZED ) ; if ( aRoot ) mRootElement = do_QueryInterface ( aRoot ) ; mUpdateCount = 0 ; mIMETextNode = nsnull ; mIMETextOffset = 0 ; mIMEBufferLength = 0 ; aSelCon -> SetCaretReadOnly ( PR_FALSE ) ; aSelCon -> SetDisplaySelection ( nsISelectionController :: SELECTION_ON ) ; aSelCon -> SetSelectionFlags ( nsISelectionDisplay :: DISPLAY_ALL ) ; NS_POSTCONDITION ( mDocWeak && mPresShellWeak , "bad state" ) ; mDidPreDestroy = PR_FALSE ; return NS_OK ; }
void ClassBoilerplate :: AddToPropertiesTemplate ( Isolate * isolate , Handle < NameDictionary > dictionary , Handle < Name > name , int key_index , ClassBoilerplate :: ValueKind value_kind , Object * value ) { AddToDictionaryTemplate ( isolate , dictionary , name , key_index , value_kind , value ) ; }
get_dht ( j_decompress_ptr cinfo ) { INT32 length ; UINT8 bits [ 17 ] ; UINT8 huffval [ 256 ] ; int i , index , count ; JHUFF_TBL * * htblptr ; INPUT_VARS ( cinfo ) ; INPUT_2BYTES ( cinfo , length , return FALSE ) ; length -= 2 ; while ( length > 16 ) { INPUT_BYTE ( cinfo , index , return FALSE ) ; TRACEMS1 ( cinfo , 1 , JTRC_DHT , index ) ; bits [ 0 ] = 0 ; count = 0 ; for ( i = 1 ; i <= 16 ; i ++ ) { INPUT_BYTE ( cinfo , bits [ i ] , return FALSE ) ; count += bits [ i ] ; } length -= 1 + 16 ; TRACEMS8 ( cinfo , 2 , JTRC_HUFFBITS , bits [ 1 ] , bits [ 2 ] , bits [ 3 ] , bits [ 4 ] , bits [ 5 ] , bits [ 6 ] , bits [ 7 ] , bits [ 8 ] ) ; TRACEMS8 ( cinfo , 2 , JTRC_HUFFBITS , bits [ 9 ] , bits [ 10 ] , bits [ 11 ] , bits [ 12 ] , bits [ 13 ] , bits [ 14 ] , bits [ 15 ] , bits [ 16 ] ) ; if ( count > 256 || ( ( INT32 ) count ) > length ) ERREXIT ( cinfo , JERR_BAD_HUFF_TABLE ) ; for ( i = 0 ; i < count ; i ++ ) INPUT_BYTE ( cinfo , huffval [ i ] , return FALSE ) ; length -= count ; if ( index & 0x10 ) { index -= 0x10 ; htblptr = & cinfo -> ac_huff_tbl_ptrs [ index ] ; } else { htblptr = & cinfo -> dc_huff_tbl_ptrs [ index ] ; } if ( index < 0 || index >= NUM_HUFF_TBLS ) ERREXIT1 ( cinfo , JERR_DHT_INDEX , index ) ; if ( * htblptr == NULL ) * htblptr = jpeg_alloc_huff_table ( ( j_common_ptr ) cinfo ) ; MEMCOPY ( ( * htblptr ) -> bits , bits , SIZEOF ( ( * htblptr ) -> bits ) ) ; MEMCOPY ( ( * htblptr ) -> huffval , huffval , SIZEOF ( ( * htblptr ) -> huffval ) ) ; } if ( length != 0 ) ERREXIT ( cinfo , JERR_BAD_LENGTH ) ; INPUT_SYNC ( cinfo ) ; return TRUE ; }
static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) { if ( delta_q != 0 ) { vp9_wb_write_bit ( wb , 1 ) ; vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ; vp9_wb_write_bit ( wb , delta_q < 0 ) ; } else { vp9_wb_write_bit ( wb , 0 ) ; } }
void vp8_dequant_idct_add_c ( short * input , short * dq , unsigned char * dest , int stride ) { int i ; for ( i = 0 ; i < 16 ; i ++ ) { input [ i ] = dq [ i ] * input [ i ] ; } vp8_short_idct4x4llm_c ( input , dest , stride , dest , stride ) ; vpx_memset ( input , 0 , 32 ) ; }
JitFrameIterator :: safepoint ( ) const { if ( ! cachedSafepointIndex_ ) cachedSafepointIndex_ = ionScript ( ) -> getSafepointIndex ( returnAddressToFp ( ) ) ; return cachedSafepointIndex_ ; }
MaybeHandle < Code > PipelineImpl :: GenerateCode ( CallDescriptor * call_descriptor ) { Linkage linkage ( call_descriptor ) ; if ( ! SelectInstructions ( & linkage ) ) return MaybeHandle < Code > ( ) ; AssembleCode ( & linkage ) ; return FinalizeCode ( ) ; }
bool Bitmap :: AllBitsClearInRange ( uint32_t start_index , uint32_t end_index ) { unsigned int start_cell_index = start_index > > Bitmap :: kBitsPerCellLog2 ; MarkBit :: CellType start_index_mask = 1u < < Bitmap :: IndexInCell ( start_index ) ; unsigned int end_cell_index = end_index > > Bitmap :: kBitsPerCellLog2 ; MarkBit :: CellType end_index_mask = 1u < < Bitmap :: IndexInCell ( end_index ) ; MarkBit :: CellType matching_mask ; if ( start_cell_index != end_cell_index ) { matching_mask = ~ ( start_index_mask - 1 ) ; if ( ( cells ( ) [ start_cell_index ] & matching_mask ) ) return false ; for ( unsigned int i = start_cell_index + 1 ; i < end_cell_index ; i ++ ) { if ( cells ( ) [ i ] ) return false ; } matching_mask = ( end_index_mask - 1 ) ; return ( matching_mask == 0 ) || ! ( cells ( ) [ end_cell_index ] & matching_mask ) ; } else { matching_mask = end_index_mask - start_index_mask ; return ( matching_mask == 0 ) || ! ( cells ( ) [ end_cell_index ] & matching_mask ) ; } }
static jlong Region_createFromParcel ( JNIEnv * env , jobject clazz , jobject parcel ) { if ( parcel == NULL ) { return NULL ; } android :: Parcel * p = android :: parcelForJavaObject ( env , parcel ) ; SkRegion * region = new SkRegion ; size_t size = p -> readInt32 ( ) ; region -> readFromMemory ( p -> readInplace ( size ) , size ) ; return reinterpret_cast < jlong > ( region ) ; }
TF_BUILTIN ( MapPrototypeValues , CollectionsBuiltinsAssembler ) { Node * const receiver = Parameter ( Descriptor :: kReceiver ) ; Node * const context = Parameter ( Descriptor :: kContext ) ; ThrowIfNotInstanceType ( context , receiver , JS_MAP_TYPE , "Map.prototype.values" ) ; Return ( AllocateJSCollectionIterator < JSMapIterator > ( context , Context :: MAP_VALUE_ITERATOR_MAP_INDEX , receiver ) ) ; }
RegExpCompartment :: sweep ( JSRuntime * rt ) { for ( Set :: Enum e ( set_ ) ; ! e . empty ( ) ; e . popFront ( ) ) { RegExpShared * shared = e . front ( ) ; bool keep = shared -> marked ( ) && ! IsStringAboutToBeFinalizedFromAnyThread ( shared -> source . unsafeGet ( ) ) ; for ( size_t i = 0 ; i < ArrayLength ( shared -> compilationArray ) ; i ++ ) { RegExpShared :: RegExpCompilation & compilation = shared -> compilationArray [ i ] ; if ( compilation . jitCode && IsJitCodeAboutToBeFinalizedFromAnyThread ( compilation . jitCode . unsafeGet ( ) ) ) { keep = false ; } } if ( keep || rt -> isHeapCompacting ( ) ) { shared -> clearMarked ( ) ; } else { js_delete ( shared ) ; e . removeFront ( ) ; } } if ( matchResultTemplateObject_ && IsObjectAboutToBeFinalizedFromAnyThread ( matchResultTemplateObject_ . unsafeGet ( ) ) ) { matchResultTemplateObject_ . set ( nullptr ) ; } }
TPMI_RH_NV_AUTH_Unmarshal ( TPMI_RH_NV_AUTH * target , BYTE * * buffer , INT32 * size ) { TPM_RC rc = TPM_RC_SUCCESS ; if ( rc == TPM_RC_SUCCESS ) { rc = TPM_HANDLE_Unmarshal ( target , buffer , size ) ; } if ( rc == TPM_RC_SUCCESS ) { switch ( * target ) { case TPM_RH_OWNER : case TPM_RH_PLATFORM : break ; default : { BOOL isNotNv = ( * target < NV_INDEX_FIRST ) || ( * target > NV_INDEX_LAST ) ; if ( isNotNv ) { rc = TPM_RC_VALUE ; } } } } return rc ; }
static int dnxhd_find_frame_end ( DNXHDParserContext * dctx , const uint8_t * buf , int buf_size ) { ParseContext * pc = & dctx -> pc ; uint64_t state = pc -> state64 ; int pic_found = pc -> frame_start_found ; int i = 0 ; if ( ! pic_found ) { for ( i = 0 ; i < buf_size ; i ++ ) { state = ( state < < 8 ) | buf [ i ] ; if ( ff_dnxhd_check_header_prefix ( state & 0xffffffffff00LL ) != 0 ) { i ++ ; pic_found = 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; break ; } } } if ( pic_found && ! dctx -> remaining ) { if ( ! buf_size ) return 0 ; for ( ; i < buf_size ; i ++ ) { dctx -> cur_byte ++ ; state = ( state < < 8 ) | buf [ i ] ; if ( dctx -> cur_byte == 24 ) { dctx -> h = ( state > > 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 26 ) { dctx -> w = ( state > > 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 42 ) { int cid = ( state > > 32 ) & 0xFFFFFFFF ; if ( cid <= 0 ) continue ; dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( dctx -> remaining <= 0 ) { dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; if ( dctx -> remaining <= 0 ) return dctx -> remaining ; } if ( buf_size - i + 47 >= dctx -> remaining ) { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } else { dctx -> remaining -= buf_size ; } } } } else if ( pic_found ) { if ( dctx -> remaining > buf_size ) { dctx -> remaining -= buf_size ; } else { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } } pc -> frame_start_found = pic_found ; pc -> state64 = state ; return END_NOT_FOUND ; }
const Type * ImplementationVisitor :: Visit ( VarDeclarationStatement * stmt ) { base :: Optional < VisitResult > init_result ; if ( stmt -> initializer ) { init_result = Visit ( * stmt -> initializer ) ; } base :: Optional < const Type * > type ; if ( stmt -> type ) type = declarations ( ) -> GetType ( * stmt -> type ) ; GenerateVariableDeclaration ( stmt , stmt -> name , stmt -> const_qualified , type , init_result ) ; return TypeOracle :: GetVoidType ( ) ; }
read_png ( struct control * control ) { png_structp png_ptr ; png_infop info_ptr = NULL ; volatile png_bytep row = NULL , display = NULL ; volatile int rc ; png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , control , error_handler , warning_handler ) ; if ( png_ptr == NULL ) { log_error ( & control -> file , LIBPNG_ERROR_CODE , "OOM allocating png_struct" ) ; control -> file . status_code |= INTERNAL_ERROR ; return LIBPNG_ERROR_CODE ; } rc = setjmp ( control -> file . jmpbuf ) ; if ( rc == 0 ) { png_set_read_fn ( png_ptr , control , read_callback ) ; info_ptr = png_create_info_struct ( png_ptr ) ; if ( info_ptr == NULL ) png_error ( png_ptr , "OOM allocating info structure" ) ; if ( control -> file . global -> verbose ) fprintf ( stderr , " INFO\n" ) ; png_read_info ( png_ptr , info_ptr ) ; { png_size_t rowbytes = png_get_rowbytes ( png_ptr , info_ptr ) ; row = png_voidcast ( png_byte * , malloc ( rowbytes ) ) ; display = png_voidcast ( png_byte * , malloc ( rowbytes ) ) ; if ( row == NULL || display == NULL ) png_error ( png_ptr , "OOM allocating row buffers" ) ; { png_uint_32 height = png_get_image_height ( png_ptr , info_ptr ) ; int passes = png_set_interlace_handling ( png_ptr ) ; int pass ; png_start_read_image ( png_ptr ) ; for ( pass = 0 ; pass < passes ; ++ pass ) { png_uint_32 y = height ; while ( y -- > 0 ) png_read_row ( png_ptr , row , display ) ; } } } if ( control -> file . global -> verbose ) fprintf ( stderr , " END\n" ) ; png_read_end ( png_ptr , info_ptr ) ; } png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; if ( row != NULL ) free ( row ) ; if ( display != NULL ) free ( display ) ; return rc ; }
txMozillaXSLTProcessor :: TransformToDocument ( nsIDOMNode * aSource , nsIDOMDocument * * aResult ) { NS_ENSURE_ARG ( aSource ) ; NS_ENSURE_ARG_POINTER ( aResult ) ; NS_ENSURE_SUCCESS ( mCompileResult , mCompileResult ) ; if ( ! nsContentUtils :: CanCallerAccess ( aSource ) ) { return NS_ERROR_DOM_SECURITY_ERR ; } nsresult rv = ensureStylesheet ( ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; mSource = aSource ; return TransformToDoc ( aResult , true ) ; }
HttpIntegrationTest :: waitForNextUpstreamRequest ( const std :: vector < uint64_t > & upstream_indices ) { uint64_t upstream_with_request ; if ( ! fake_upstream_connection_ ) { AssertionResult result = AssertionFailure ( ) ; for ( auto upstream_index : upstream_indices ) { result = fake_upstreams_ [ upstream_index ] -> waitForHttpConnection ( * dispatcher_ , fake_upstream_connection_ , TestUtility :: DefaultTimeout , max_request_headers_kb_ ) ; if ( result ) { upstream_with_request = upstream_index ; break ; } } RELEASE_ASSERT ( result , result . message ( ) ) ; } AssertionResult result = fake_upstream_connection_ -> waitForNewStream ( * dispatcher_ , upstream_request_ ) ; RELEASE_ASSERT ( result , result . message ( ) ) ; result = upstream_request_ -> waitForEndStream ( * dispatcher_ ) ; RELEASE_ASSERT ( result , result . message ( ) ) ; return upstream_with_request ; }
static void save_client_addr ( struct ip_addr * client_ip , uint8_t * hwaddr ) { uint8_t d = ( uint8_t ) ip4_addr4 ( client_ip ) ; xSemaphoreTake ( dhcps_ip_table_semaphore , portMAX_DELAY ) ; memcpy ( ip_table . client_mac [ d ] , hwaddr , 6 ) ; #if (debug_dhcps)  printf ( "\r\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\n" , __func__ , ip4_addr1 ( client_ip ) , ip4_addr2 ( client_ip ) , ip4_addr3 ( client_ip ) , ip4_addr4 ( client_ip ) , hwaddr [ 0 ] , hwaddr [ 1 ] , hwaddr [ 2 ] , hwaddr [ 3 ] , hwaddr [ 4 ] , hwaddr [ 5 ] ) ; #endif  xSemaphoreGive ( dhcps_ip_table_semaphore ) ; }
Reduction JSTypedLowering :: ReduceJSStoreModule ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSStoreModule , node -> opcode ( ) ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; Node * value = NodeProperties :: GetValueInput ( node , 1 ) ; DCHECK_EQ ( ModuleDescriptor :: GetCellIndexKind ( OpParameter < int32_t > ( node -> op ( ) ) ) , ModuleDescriptor :: kExport ) ; Node * cell = BuildGetModuleCell ( node ) ; if ( cell -> op ( ) -> EffectOutputCount ( ) > 0 ) effect = cell ; effect = graph ( ) -> NewNode ( simplified ( ) -> StoreField ( AccessBuilder :: ForCellValue ( ) ) , cell , value , effect , control ) ; ReplaceWithValue ( node , effect , effect , control ) ; return Changed ( value ) ; }
Handle < Context > Factory :: NewBlockContext ( Handle < Context > previous , Handle < ScopeInfo > scope_info ) { DCHECK_EQ ( scope_info -> scope_type ( ) , BLOCK_SCOPE ) ; Handle < Context > context = NewFixedArrayWithMap < Context > ( Heap :: kBlockContextMapRootIndex , scope_info -> ContextLength ( ) ) ; context -> set_scope_info ( * scope_info ) ; context -> set_previous ( * previous ) ; context -> set_extension ( * the_hole_value ( ) ) ; context -> set_native_context ( previous -> native_context ( ) ) ; return context ; }
% * / static Image * ReadCAPTIONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * caption , geometry [ MaxTextExtent ] , * property , * text ; const char * gravity , * option ; DrawInfo * draw_info ; Image * image ; MagickBooleanType split , status ; register ssize_t i ; size_t height , width ; TypeMetric metrics ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; ( void ) ResetImagePage ( image , "0x0+0+0" ) ; option = GetImageOption ( image_info , "filename" ) ; if ( option == ( const char * ) NULL ) property = InterpretImageProperties ( image_info , image , image_info -> filename ) ; else if ( LocaleNCompare ( option , "caption:" , 8 ) == 0 ) property = InterpretImageProperties ( image_info , image , option + 8 ) ; else property = InterpretImageProperties ( image_info , image , option ) ; ( void ) SetImageProperty ( image , "caption" , property ) ; property = DestroyString ( property ) ; caption = ConstantString ( GetImageProperty ( image , "caption" ) ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; ( void ) CloneString ( & draw_info -> text , caption ) ; gravity = GetImageOption ( image_info , "gravity" ) ; if ( gravity != ( char * ) NULL ) draw_info -> gravity = ( GravityType ) ParseCommandOption ( MagickGravityOptions , MagickFalse , gravity ) ; split = MagickFalse ; status = MagickTrue ; if ( image -> columns == 0 ) { text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%+g%+g" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; image -> columns = width ; } if ( image -> rows == 0 ) { split = MagickTrue ; text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%+g%+g" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; image -> rows = ( size_t ) ( ( i + 1 ) * ( metrics . ascent - metrics . descent + draw_info -> interline_spacing + draw_info -> stroke_width ) + 0.5 ) ; } if ( status != MagickFalse ) status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ( fabs ( image_info -> pointsize ) < MagickEpsilon ) && ( strlen ( caption ) > 0 ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%+g%+g" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; ( void ) status ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%+g%+g" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = floor ( ( low + high ) / 2.0 - 0.5 ) ; } i = FormatMagickCaption ( image , draw_info , split , & metrics , & caption ) ; ( void ) CloneString ( & draw_info -> text , caption ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%+g%+g" , MagickMax ( draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : - metrics . bounds . x1 , 0.0 ) , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; draw_info -> geometry = AcquireString ( geometry ) ; status = AnnotateImage ( image , draw_info ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pointsize , MaxTextExtent , "%.20g" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , "caption:pointsize" , pointsize ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; caption = DestroyString ( caption ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; }
R_API bool r_socket_connect ( RSocket * s , const char * host , const char * port , int proto , unsigned int timeout ) { r_return_val_if_fail ( s , false ) ; #if __WINDOWS__ struct sockaddr_in sa ; struct hostent * he ; WSADATA wsadata ; TIMEVAL Timeout ; Timeout . tv_sec = timeout ; Timeout . tv_usec = 0 ; if ( WSAStartup ( MAKEWORD ( 1 , 1 ) , & wsadata ) == SOCKET_ERROR ) { eprintf ( "Error creating socket." ) ; return false ; } s -> fd = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( s -> fd == R_INVALID_SOCKET ) { return false ; } unsigned long iMode = 1 ; int iResult = ioctlsocket ( s -> fd , FIONBIO , & iMode ) ; if ( iResult != NO_ERROR ) { eprintf ( "ioctlsocket error: %d\n" , iResult ) ; } memset ( & sa , 0 , sizeof ( sa ) ) ; sa . sin_family = AF_INET ; he = ( struct hostent * ) gethostbyname ( host ) ; if ( he == ( struct hostent * ) 0 ) { #ifdef _MSC_VER closesocket ( s -> fd ) ; #else close ( s -> fd ) ; #endif return false ; } sa . sin_addr = * ( ( struct in_addr * ) he -> h_addr ) ; s -> port = r_socket_port_by_name ( port ) ; s -> proto = proto ; sa . sin_port = htons ( s -> port ) ; if ( ! connect ( s -> fd , ( const struct sockaddr * ) & sa , sizeof ( struct sockaddr ) ) ) { #ifdef _MSC_VER closesocket ( s -> fd ) ; #else close ( s -> fd ) ; #endif return false ; } iMode = 0 ; iResult = ioctlsocket ( s -> fd , FIONBIO , & iMode ) ; if ( iResult != NO_ERROR ) { eprintf ( "ioctlsocket error: %d\n" , iResult ) ; } if ( timeout > 0 ) { r_socket_block_time ( s , 1 , timeout , 0 ) ; } fd_set Write , Err ; FD_ZERO ( & Write ) ; FD_ZERO ( & Err ) ; FD_SET ( s -> fd , & Write ) ; FD_SET ( s -> fd , & Err ) ; select ( 0 , NULL , & Write , & Err , & Timeout ) ; if ( FD_ISSET ( s -> fd , & Write ) ) { return true ; } return false ; #elif __UNIX__ int ret ; struct addrinfo hints = { 0 } ; struct addrinfo * res , * rp ; if ( ! proto ) { proto = R_SOCKET_PROTO_TCP ; } r_sys_signal ( SIGPIPE , SIG_IGN ) ; if ( proto == R_SOCKET_PROTO_UNIX ) { if ( ! __connect_unix ( s , host ) ) { return false ; } } else { hints . ai_family = AF_UNSPEC ; hints . ai_protocol = proto ; int gai = getaddrinfo ( host , port , & hints , & res ) ; if ( gai != 0 ) { eprintf ( "r_socket_connect: Error in getaddrinfo: %s (%s:%s)\n" , gai_strerror ( gai ) , host , port ) ; return false ; } for ( rp = res ; rp != NULL ; rp = rp -> ai_next ) { int flag = 1 ; s -> fd = socket ( rp -> ai_family , rp -> ai_socktype , rp -> ai_protocol ) ; if ( s -> fd == - 1 ) { perror ( "socket" ) ; continue ; } ret = setsockopt ( s -> fd , IPPROTO_TCP , TCP_NODELAY , & flag , sizeof ( flag ) ) ; if ( ret < 0 ) { perror ( "setsockopt" ) ; close ( s -> fd ) ; s -> fd = - 1 ; continue ; } r_socket_block_time ( s , 0 , 0 , 0 ) ; ret = connect ( s -> fd , rp -> ai_addr , rp -> ai_addrlen ) ; if ( ret == 0 ) { freeaddrinfo ( res ) ; return true ; } if ( errno == EINPROGRESS ) { struct timeval tv ; tv . tv_sec = timeout ; tv . tv_usec = 0 ; fd_set wfds ; FD_ZERO ( & wfds ) ; FD_SET ( s -> fd , & wfds ) ; if ( ( ret = select ( s -> fd + 1 , NULL , & wfds , NULL , & tv ) ) != - 1 ) { if ( r_socket_is_connected ( s ) ) { freeaddrinfo ( res ) ; return true ; } } else { perror ( "connect" ) ; } } r_socket_close ( s ) ; } freeaddrinfo ( res ) ; if ( ! rp ) { eprintf ( "Could not resolve address '%s' or failed to connect\n" , host ) ; return false ; } } #endif #if HAVE_LIB_SSL if ( s -> is_ssl ) { s -> ctx = SSL_CTX_new ( SSLv23_client_method ( ) ) ; if ( ! s -> ctx ) { r_socket_free ( s ) ; return false ; } s -> sfd = SSL_new ( s -> ctx ) ; SSL_set_fd ( s -> sfd , s -> fd ) ; if ( SSL_connect ( s -> sfd ) != 1 ) { r_socket_free ( s ) ; return false ; } } #endif return true ; }
JSStructuredCloneWriter :: startWrite ( HandleValue v ) { assertSameCompartment ( context ( ) , v ) ; if ( v . isString ( ) ) { return writeString ( SCTAG_STRING , v . toString ( ) ) ; } else if ( v . isInt32 ( ) ) { return out . writePair ( SCTAG_INT32 , v . toInt32 ( ) ) ; } else if ( v . isDouble ( ) ) { return out . writeDouble ( v . toDouble ( ) ) ; } else if ( v . isBoolean ( ) ) { return out . writePair ( SCTAG_BOOLEAN , v . toBoolean ( ) ) ; } else if ( v . isNull ( ) ) { return out . writePair ( SCTAG_NULL , 0 ) ; } else if ( v . isUndefined ( ) ) { return out . writePair ( SCTAG_UNDEFINED , 0 ) ; } else if ( v . isObject ( ) ) { RootedObject obj ( context ( ) , & v . toObject ( ) ) ; obj = CheckedUnwrap ( obj ) ; if ( ! obj ) { JS_ReportErrorNumber ( context ( ) , js_GetErrorMessage , nullptr , JSMSG_UNWRAP_DENIED ) ; return false ; } AutoCompartment ac ( context ( ) , obj ) ; bool backref ; if ( ! startObject ( obj , & backref ) ) return false ; if ( backref ) return true ; if ( ObjectClassIs ( obj , ESClass_RegExp , context ( ) ) ) { RegExpGuard re ( context ( ) ) ; if ( ! RegExpToShared ( context ( ) , obj , & re ) ) return false ; return out . writePair ( SCTAG_REGEXP_OBJECT , re -> getFlags ( ) ) && writeString ( SCTAG_STRING , re -> getSource ( ) ) ; } else if ( ObjectClassIs ( obj , ESClass_Date , context ( ) ) ) { double d = js_DateGetMsecSinceEpoch ( obj ) ; return out . writePair ( SCTAG_DATE_OBJECT , 0 ) && out . writeDouble ( d ) ; } else if ( JS_IsTypedArrayObject ( obj ) ) { return writeTypedArray ( obj ) ; } else if ( JS_IsArrayBufferObject ( obj ) && JS_ArrayBufferHasData ( obj ) ) { return writeArrayBuffer ( obj ) ; } else if ( ObjectClassIs ( obj , ESClass_Object , context ( ) ) ) { return traverseObject ( obj ) ; } else if ( ObjectClassIs ( obj , ESClass_Array , context ( ) ) ) { return traverseObject ( obj ) ; } else if ( ObjectClassIs ( obj , ESClass_Boolean , context ( ) ) ) { RootedValue unboxed ( context ( ) ) ; if ( ! Unbox ( context ( ) , obj , & unboxed ) ) return false ; return out . writePair ( SCTAG_BOOLEAN_OBJECT , unboxed . toBoolean ( ) ) ; } else if ( ObjectClassIs ( obj , ESClass_Number , context ( ) ) ) { RootedValue unboxed ( context ( ) ) ; if ( ! Unbox ( context ( ) , obj , & unboxed ) ) return false ; return out . writePair ( SCTAG_NUMBER_OBJECT , 0 ) && out . writeDouble ( unboxed . toNumber ( ) ) ; } else if ( ObjectClassIs ( obj , ESClass_String , context ( ) ) ) { RootedValue unboxed ( context ( ) ) ; if ( ! Unbox ( context ( ) , obj , & unboxed ) ) return false ; return writeString ( SCTAG_STRING_OBJECT , unboxed . toString ( ) ) ; } else if ( ObjectClassIs ( obj , ESClass_Map , context ( ) ) ) { return traverseMap ( obj ) ; } else if ( ObjectClassIs ( obj , ESClass_Set , context ( ) ) ) { return traverseSet ( obj ) ; } if ( callbacks && callbacks -> write ) return callbacks -> write ( context ( ) , this , obj , closure ) ; } JS_ReportErrorNumber ( context ( ) , js_GetErrorMessage , nullptr , JSMSG_SC_UNSUPPORTED_TYPE ) ; return false ; }
base :: Optional < ParseResult > AddGlobalDeclaration ( ParseResultIterator * child_results ) { auto declaration = child_results -> NextAs < Declaration * > ( ) ; CurrentAst :: Get ( ) . declarations ( ) . push_back ( declaration ) ; return base :: nullopt ; }
static CURLcode smtp_connect ( struct connectdata * conn , bool * done ) { CURLcode result ; struct smtp_conn * smtpc = & conn -> proto . smtpc ; struct SessionHandle * data = conn -> data ; struct pingpong * pp = & smtpc -> pp ; const char * path = conn -> data -> state . path ; int len ; char localhost [ HOSTNAME_MAX + 1 ] ; * done = FALSE ; Curl_reset_reqproto ( conn ) ; result = smtp_init ( conn ) ; if ( CURLE_OK != result ) return result ; conn -> bits . close = FALSE ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( conn -> bits . tunnel_proxy && conn -> bits . httpproxy ) { struct HTTP http_proxy ; struct FTP * smtp_save ; smtp_save = data -> state . proto . smtp ; memset ( & http_proxy , 0 , sizeof ( http_proxy ) ) ; data -> state . proto . http = & http_proxy ; result = Curl_proxyCONNECT ( conn , FIRSTSOCKET , conn -> host . name , conn -> remote_port ) ; data -> state . proto . smtp = smtp_save ; if ( CURLE_OK != result ) return result ; } if ( ( conn -> handler -> protocol & CURLPROTO_SMTPS ) && data -> state . used_interface != Curl_if_multi ) { result = Curl_ssl_connect ( conn , FIRSTSOCKET ) ; if ( result ) return result ; } Curl_pp_init ( pp ) ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( ! * path ) { if ( ! Curl_gethostname ( localhost , sizeof localhost ) ) path = localhost ; else path = "localhost" ; } smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; if ( ! smtpc -> domain ) return CURLE_OUT_OF_MEMORY ; state ( conn , SMTP_SERVERGREET ) ; if ( data -> state . used_interface == Curl_if_multi ) result = smtp_multi_statemach ( conn , done ) ; else { result = smtp_easy_statemach ( conn ) ; if ( ! result ) * done = TRUE ; } return result ; }
[ ] ( TfLiteContext * context , TfLiteNode * node ) { - TfLiteTensor * output = tflite :: GetOutput ( context , node , 0 ) ; + TfLiteTensor * output ; + TF_LITE_ENSURE_OK ( context , + tflite :: GetOutputSafe ( context , node , 0 , & output ) ) ; std :: fill ( output -> data . f , output -> data . f + tflite :: NumElements ( output ) , 7.0f ) ; return kTfLiteOk ; } ,
njs_array_prototype_splice ( njs_vm_t * vm , njs_value_t * args , njs_uint_t nargs , njs_index_t unused ) { int64_t i , n , start , length , items , delta , delete ; njs_int_t ret ; njs_value_t * this , value , del_object ; njs_array_t * array , * deleted ; this = njs_argument ( args , 0 ) ; ret = njs_value_to_object ( vm , this ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } ret = njs_object_length ( vm , this , & length ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return ret ; } ret = njs_value_to_integer ( vm , njs_arg ( args , nargs , 1 ) , & start ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } start = ( start < 0 ) ? njs_max ( length + start , 0 ) : njs_min ( start , length ) ; items = 0 ; delete = 0 ; if ( nargs == 2 ) { delete = length - start ; } else if ( nargs > 2 ) { items = nargs - 3 ; ret = njs_value_to_integer ( vm , njs_arg ( args , nargs , 2 ) , & delete ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } delete = njs_min ( njs_max ( delete , 0 ) , length - start ) ; } delta = items - delete ; if ( njs_slow_path ( ( length + delta ) > NJS_MAX_LENGTH ) ) { njs_type_error ( vm , "Invalid length" ) ; return NJS_ERROR ; } deleted = njs_array_alloc ( vm , 0 , delete , 0 ) ; if ( njs_slow_path ( deleted == NULL ) ) { return NJS_ERROR ; } if ( njs_fast_path ( njs_is_fast_array ( this ) && deleted -> object . fast_array ) ) { array = njs_array ( this ) ; for ( i = 0 , n = start ; i < delete ; i ++ , n ++ ) { deleted -> start [ i ] = array -> start [ n ] ; } } else { njs_set_array ( & del_object , deleted ) ; for ( i = 0 , n = start ; i < delete ; i ++ , n ++ ) { ret = njs_value_property_i64 ( vm , this , n , & value ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return NJS_ERROR ; } if ( ret == NJS_OK ) { ret = njs_value_property_i64_set ( vm , & del_object , i , & value ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return ret ; } } } ret = njs_object_length_set ( vm , & del_object , delete ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return NJS_ERROR ; } } if ( njs_fast_path ( njs_is_fast_array ( this ) ) ) { array = njs_array ( this ) ; if ( delta != 0 ) { if ( delta > 0 ) { ret = njs_array_expand ( vm , array , 0 , delta ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } } ret = njs_array_copy_within ( vm , this , start + items , start + delete , array -> length - ( start + delete ) , 0 ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } array -> length += delta ; } if ( items > 0 ) { memcpy ( & array -> start [ start ] , & args [ 3 ] , items * sizeof ( njs_value_t ) ) ; } } else { if ( delta != 0 ) { ret = njs_array_copy_within ( vm , this , start + items , start + delete , length - ( start + delete ) , delta < 0 ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } for ( i = length - 1 ; i >= length + delta ; i -- ) { ret = njs_value_property_i64_delete ( vm , this , i , NULL ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return NJS_ERROR ; } } } for ( i = 3 , n = start ; items -- > 0 ; i ++ , n ++ ) { ret = njs_value_property_i64_set ( vm , this , n , & args [ i ] ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return NJS_ERROR ; } } ret = njs_object_length_set ( vm , this , length + delta ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return NJS_ERROR ; } } njs_set_array ( & vm -> retval , deleted ) ; return NJS_OK ; }
void JSCallN ( int arg_count , ConvertReceiverMode receiver_mode ) { const int kFirstArgumentOperandIndex = 1 ; const int kReceiverOperandCount = ( receiver_mode == ConvertReceiverMode :: kNullOrUndefined ) ? 0 : 1 ; const int kRecieverAndArgOperandCount = kReceiverOperandCount + arg_count ; const int kSlotOperandIndex = kFirstArgumentOperandIndex + kRecieverAndArgOperandCount ; Node * function = LoadRegisterAtOperandIndex ( 0 ) ; Node * slot_id = BytecodeOperandIdx ( kSlotOperandIndex ) ; Node * feedback_vector = LoadFeedbackVector ( ) ; Node * context = GetContext ( ) ; CollectCallFeedback ( function , context , feedback_vector , slot_id ) ; switch ( kRecieverAndArgOperandCount ) { case 0 : CallJSAndDispatch ( function , context , Int32Constant ( arg_count ) , receiver_mode ) ; break ; case 1 : CallJSAndDispatch ( function , context , Int32Constant ( arg_count ) , receiver_mode , LoadRegisterAtOperandIndex ( kFirstArgumentOperandIndex ) ) ; break ; case 2 : CallJSAndDispatch ( function , context , Int32Constant ( arg_count ) , receiver_mode , LoadRegisterAtOperandIndex ( kFirstArgumentOperandIndex ) , LoadRegisterAtOperandIndex ( kFirstArgumentOperandIndex + 1 ) ) ; break ; case 3 : CallJSAndDispatch ( function , context , Int32Constant ( arg_count ) , receiver_mode , LoadRegisterAtOperandIndex ( kFirstArgumentOperandIndex ) , LoadRegisterAtOperandIndex ( kFirstArgumentOperandIndex + 1 ) , LoadRegisterAtOperandIndex ( kFirstArgumentOperandIndex + 2 ) ) ; break ; default : UNREACHABLE ( ) ; } }
XPCCallContext :: XPCCallContext ( XPCContext :: LangType callerLanguage , JSContext * cx , JSBool callBeginRequest , HandleObject obj , HandleObject flattenedJSObject , XPCWrappedNative * wrapper , XPCWrappedNativeTearOff * tearOff ) : mState ( INIT_FAILED ) , mXPC ( nsXPConnect :: GetXPConnect ( ) ) , mXPCContext ( nullptr ) , mJSContext ( cx ) , mContextPopRequired ( false ) , mDestroyJSContextInDestructor ( false ) , mCallerLanguage ( callerLanguage ) , mScopeForNewJSObjects ( cx ) , mFlattenedJSObject ( cx , flattenedJSObject ) , mWrapper ( wrapper ) , mTearOff ( tearOff ) , mName ( cx ) { MOZ_ASSERT ( cx ) ; Init ( callerLanguage , callBeginRequest , obj , NullPtr ( ) , WRAPPER_PASSED_TO_CONSTRUCTOR , JSID_VOIDHANDLE , NO_ARGS , nullptr , nullptr ) ; }
FindNativeAnonymousSubtreeOwner ( nsIContent * aContent ) { if ( aContent -> IsInNativeAnonymousSubtree ( ) ) { bool isNativeAnon = false ; while ( aContent && ! isNativeAnon ) { isNativeAnon = aContent -> IsRootOfNativeAnonymousSubtree ( ) ; aContent = aContent -> GetParent ( ) ; } } return aContent ; }
nsGenericDOMDataNode :: SetTextInternal ( PRUint32 aOffset , PRUint32 aCount , const PRUnichar * aBuffer , PRUint32 aLength , PRBool aNotify ) { NS_PRECONDITION ( aBuffer || ! aLength , "Null buffer passed to SetTextInternal!" ) ; PRUint32 textLength = mText . GetLength ( ) ; if ( aOffset > textLength ) { return NS_ERROR_DOM_INDEX_SIZE_ERR ; } nsIDocument * document = GetCurrentDoc ( ) ; mozAutoDocUpdate updateBatch ( document , UPDATE_CONTENT_MODEL , aNotify ) ; PRBool haveMutationListeners = aNotify && nsContentUtils :: HasMutationListeners ( this , NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED , this ) ; nsCOMPtr < nsIAtom > oldValue ; if ( haveMutationListeners ) { oldValue = GetCurrentValueAtom ( ) ; } PRUint32 endOffset = aOffset + aCount ; if ( endOffset > textLength ) { aCount = textLength - aOffset ; endOffset = textLength ; } if ( aNotify ) { CharacterDataChangeInfo info = { aOffset == textLength , aOffset , endOffset , aLength } ; nsNodeUtils :: CharacterDataWillChange ( this , & info ) ; } if ( aOffset == 0 && endOffset == textLength ) { mText . SetTo ( aBuffer , aLength ) ; } else if ( aOffset == textLength ) { mText . Append ( aBuffer , aLength ) ; } else { PRInt32 newLength = textLength - aCount + aLength ; PRUnichar * to = new PRUnichar [ newLength ] ; NS_ENSURE_TRUE ( to , NS_ERROR_OUT_OF_MEMORY ) ; if ( 0 != aOffset ) { mText . CopyTo ( to , 0 , aOffset ) ; } if ( 0 != aLength ) { memcpy ( to + aOffset , aBuffer , aLength * sizeof ( PRUnichar ) ) ; } if ( endOffset != textLength ) { mText . CopyTo ( to + aOffset + aLength , endOffset , textLength - endOffset ) ; } mText . SetTo ( to , newLength ) ; delete [ ] to ; } SetBidiStatus ( ) ; if ( aNotify ) { CharacterDataChangeInfo info = { aOffset == textLength , aOffset , endOffset , aLength } ; nsNodeUtils :: CharacterDataChanged ( this , & info ) ; if ( haveMutationListeners ) { mozAutoRemovableBlockerRemover blockerRemover ; nsMutationEvent mutation ( PR_TRUE , NS_MUTATION_CHARACTERDATAMODIFIED ) ; mutation . mPrevAttrValue = oldValue ; if ( aLength > 0 ) { nsAutoString val ; mText . AppendTo ( val ) ; mutation . mNewAttrValue = do_GetAtom ( val ) ; } mozAutoSubtreeModified subtree ( GetOwnerDoc ( ) , this ) ; nsEventDispatcher :: Dispatch ( this , nsnull , & mutation ) ; } } return NS_OK ; }
void SourcePositionTable :: SetPosition ( int pc_offset , int line ) { DCHECK_GE ( pc_offset , 0 ) ; DCHECK_GT ( line , 0 ) ; DCHECK ( pc_offsets_to_lines_ . empty ( ) || pc_offsets_to_lines_ . back ( ) . pc_offset < pc_offset ) ; if ( pc_offsets_to_lines_ . empty ( ) || pc_offsets_to_lines_ . back ( ) . line_number != line ) { pc_offsets_to_lines_ . push_back ( { pc_offset , line } ) ; } }
char const * parse_int ( char const * start , char const * end , char delimiter , boost :: int64_t & val ) { while ( start < end && * start != delimiter ) { if ( ! is_digit ( * start ) ) { return 0 ; } val *= 10 ; val += * start - '0' ; ++ start ; } return start ; }
unsigned FLAC__format_get_max_rice_partition_order_from_blocksize ( unsigned blocksize ) { unsigned max_rice_partition_order = 0 ; while ( ! ( blocksize & 1 ) ) { max_rice_partition_order ++ ; blocksize >>= 1 ; } return min ( FLAC__MAX_RICE_PARTITION_ORDER , max_rice_partition_order ) ; }
decode_entities ( pTHX_ SV * sv , HV * entity2char , bool expand_prefix ) { STRLEN len ; char * s = SvPV_force ( sv , len ) ; char * t = s ; char * end = s + len ; char * ent_start ; char * repl ; STRLEN repl_len ; #ifdef UNICODE_HTML_PARSER char buf [ UTF8_MAXLEN ] ; int repl_utf8 ; int high_surrogate = 0 ; #else char buf [ 1 ] ; #endif #if defined(__GNUC__) && defined(UNICODE_HTML_PARSER) repl_utf8 = 0 ; #endif while ( s < end ) { assert ( t <= s ) ; if ( ( * t ++ = * s ++ ) != '&' ) continue ; ent_start = s ; repl = 0 ; if ( * s == '#' ) { UV num = 0 ; UV prev = 0 ; int ok = 0 ; s ++ ; if ( * s == 'x' || * s == 'X' ) { s ++ ; while ( * s ) { char * tmp = strchr ( PL_hexdigit , * s ) ; if ( ! tmp ) break ; num = num < < 4 | ( ( tmp - PL_hexdigit ) & 15 ) ; if ( prev && num <= prev ) { ok = 0 ; break ; } prev = num ; s ++ ; ok = 1 ; } } else { while ( isDIGIT ( * s ) ) { num = num * 10 + ( * s - '0' ) ; if ( prev && num < prev ) { ok = 0 ; break ; } prev = num ; s ++ ; ok = 1 ; } } if ( ok ) { #ifdef UNICODE_HTML_PARSER if ( ! SvUTF8 ( sv ) && num <= 255 ) { buf [ 0 ] = ( char ) num ; repl = buf ; repl_len = 1 ; repl_utf8 = 0 ; } else { char * tmp ; if ( ( num & 0xFFFFFC00 ) == 0xDC00 ) { if ( high_surrogate != 0 ) { t -= 3 ; num = ( ( high_surrogate - 0xD800 ) < < 10 ) + ( num - 0xDC00 ) + 0x10000 ; high_surrogate = 0 ; } else { num = 0xFFFD ; } } else if ( ( num & 0xFFFFFC00 ) == 0xD800 ) { high_surrogate = num ; num = 0xFFFD ; } else { high_surrogate = 0 ; if ( ( num >= 0xFDD0 && num <= 0xFDEF ) || ( ( num & 0xFFFE ) == 0xFFFE ) || num > 0x10FFFF ) { num = 0xFFFD ; } } tmp = ( char * ) uvuni_to_utf8 ( ( U8 * ) buf , num ) ; repl = buf ; repl_len = tmp - buf ; repl_utf8 = 1 ; } #else if ( num <= 255 ) { buf [ 0 ] = ( char ) num & 0xFF ; repl = buf ; repl_len = 1 ; } #endif } } else { char * ent_name = s ; while ( isALNUM ( * s ) ) s ++ ; if ( ent_name != s && entity2char ) { SV * * svp ; if ( ( svp = hv_fetch ( entity2char , ent_name , s - ent_name , 0 ) ) || ( * s == ';' && ( svp = hv_fetch ( entity2char , ent_name , s - ent_name + 1 , 0 ) ) ) ) { repl = SvPV ( * svp , repl_len ) ; #ifdef UNICODE_HTML_PARSER repl_utf8 = SvUTF8 ( * svp ) ; #endif } else if ( expand_prefix ) { char * ss = s - 1 ; while ( ss > ent_name ) { svp = hv_fetch ( entity2char , ent_name , ss - ent_name , 0 ) ; if ( svp ) { repl = SvPV ( * svp , repl_len ) ; #ifdef UNICODE_HTML_PARSER repl_utf8 = SvUTF8 ( * svp ) ; #endif s = ss ; break ; } ss -- ; } } } #ifdef UNICODE_HTML_PARSER high_surrogate = 0 ; #endif } if ( repl ) { char * repl_allocated = 0 ; if ( * s == ';' ) s ++ ; t -- ; #ifdef UNICODE_HTML_PARSER if ( * s != '&' ) { high_surrogate = 0 ; } if ( ! SvUTF8 ( sv ) && repl_utf8 ) { STRLEN before_gap_len = t - SvPVX ( sv ) ; char * before_gap = ( char * ) bytes_to_utf8 ( ( U8 * ) SvPVX ( sv ) , & before_gap_len ) ; STRLEN after_gap_len = end - s ; char * after_gap = ( char * ) bytes_to_utf8 ( ( U8 * ) s , & after_gap_len ) ; sv_setpvn ( sv , before_gap , before_gap_len ) ; sv_catpvn ( sv , after_gap , after_gap_len ) ; SvUTF8_on ( sv ) ; Safefree ( before_gap ) ; Safefree ( after_gap ) ; s = t = SvPVX ( sv ) + before_gap_len ; end = SvPVX ( sv ) + before_gap_len + after_gap_len ; } else if ( SvUTF8 ( sv ) && ! repl_utf8 ) { repl = ( char * ) bytes_to_utf8 ( ( U8 * ) repl , & repl_len ) ; repl_allocated = repl ; } #endif if ( t + repl_len > s ) { grow_gap ( aTHX_ sv , repl_len - ( s - t ) , & t , & s , & end ) ; } while ( repl_len -- ) * t ++ = * repl ++ ; if ( repl_allocated ) Safefree ( repl_allocated ) ; } else { while ( ent_start < s ) * t ++ = * ent_start ++ ; } } * t = '\0' ; SvCUR_set ( sv , t - SvPVX ( sv ) ) ; return sv ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TFLITE_DCHECK ( node -> user_data != nullptr ) ; TFLITE_DCHECK ( node -> builtin_data != nullptr ) ; OpData * data = static_cast < OpData * > ( node -> user_data ) ; auto * params = reinterpret_cast < TfLiteSubParams * > ( node -> builtin_data ) ; const TfLiteTensor * input1 = GetInput ( context , node , kInputTensor1 ) ; const TfLiteTensor * input2 = GetInput ( context , node , kInputTensor2 ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; TF_LITE_ENSURE_STATUS ( CalculateOpData ( context , params , input1 , input2 , output , data ) ) ; return kTfLiteOk ; }
sc_pkcs15emu_oberthur_add_pubkey ( struct sc_pkcs15_card * p15card , unsigned int file_id , unsigned int size ) { struct sc_context * ctx = p15card -> card -> ctx ; struct sc_pkcs15_pubkey_info key_info ; struct sc_pkcs15_object key_obj ; char ch_tmp [ 0x100 ] ; unsigned char * info_blob = NULL ; size_t len , info_len , offs ; unsigned flags ; int rv ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , "public key(file-id:%04X,size:%X)" , file_id , size ) ; memset ( & key_info , 0 , sizeof ( key_info ) ) ; memset ( & key_obj , 0 , sizeof ( key_obj ) ) ; snprintf ( ch_tmp , sizeof ( ch_tmp ) , "%s%04X" , AWP_OBJECTS_DF_PUB , file_id | 0x100 ) ; rv = sc_oberthur_read_file ( p15card , ch_tmp , & info_blob , & info_len , 1 ) ; LOG_TEST_RET ( ctx , rv , "Failed to add public key: read oberthur file error" ) ; offs = 2 ; if ( offs > info_len ) { free ( info_blob ) ; LOG_TEST_RET ( ctx , SC_ERROR_UNKNOWN_DATA_RECEIVED , "Failed to add public key: no 'tag'" ) ; } flags = * ( info_blob + 0 ) * 0x100 + * ( info_blob + 1 ) ; key_info . usage = sc_oberthur_decode_usage ( flags ) ; if ( flags & OBERTHUR_ATTR_MODIFIABLE ) key_obj . flags = SC_PKCS15_CO_FLAG_MODIFIABLE ; sc_log ( ctx , "Public key key-usage:%04X" , key_info . usage ) ; if ( offs + 2 > info_len ) { free ( info_blob ) ; LOG_TEST_RET ( ctx , SC_ERROR_UNKNOWN_DATA_RECEIVED , "Failed to add public key: no 'Label'" ) ; } len = * ( info_blob + offs + 1 ) + * ( info_blob + offs ) * 0x100 ; if ( len ) { if ( len > sizeof ( key_obj . label ) - 1 ) len = sizeof ( key_obj . label ) - 1 ; memcpy ( key_obj . label , info_blob + offs + 2 , len ) ; } offs += 2 + len ; if ( offs > info_len ) { free ( info_blob ) ; LOG_TEST_RET ( ctx , SC_ERROR_UNKNOWN_DATA_RECEIVED , "Failed to add public key: no 'ID'" ) ; } len = * ( info_blob + offs + 1 ) + * ( info_blob + offs ) * 0x100 ; if ( ! len || len > sizeof ( key_info . id . value ) ) { free ( info_blob ) ; LOG_TEST_RET ( ctx , SC_ERROR_INVALID_DATA , "Failed to add public key: invalid 'ID' length" ) ; } memcpy ( key_info . id . value , info_blob + offs + 2 , len ) ; key_info . id . len = len ; free ( info_blob ) ; snprintf ( ch_tmp , sizeof ( ch_tmp ) , "%s%04X" , AWP_OBJECTS_DF_PUB , file_id ) ; sc_format_path ( ch_tmp , & key_info . path ) ; key_info . native = 1 ; key_info . key_reference = file_id & 0xFF ; key_info . modulus_length = size ; rv = sc_pkcs15emu_add_rsa_pubkey ( p15card , & key_obj , & key_info ) ; LOG_FUNC_RETURN ( ctx , rv ) ; }
status_t AudioFlinger :: EffectModule :: setEnabled_l ( bool enabled ) { ALOGV ( "setEnabled %p enabled %d" , this , enabled ) ; if ( enabled != isEnabled ( ) ) { status_t status = AudioSystem :: setEffectEnabled ( mId , enabled ) ; if ( enabled && status != NO_ERROR ) { return status ; } switch ( mState ) { case IDLE : mState = STARTING ; break ; case STOPPED : mState = RESTART ; break ; case STOPPING : mState = ACTIVE ; break ; case RESTART : mState = STOPPED ; break ; case STARTING : mState = IDLE ; break ; case ACTIVE : mState = STOPPING ; break ; case DESTROYED : return NO_ERROR ; } for ( size_t i = 1 ; i < mHandles . size ( ) ; i ++ ) { EffectHandle * h = mHandles [ i ] ; if ( h != NULL && ! h -> destroyed_l ( ) ) { h -> setEnabled ( enabled ) ; } } } return NO_ERROR ; }
AddFile :: Parse ( NS_tchar * line ) { mFile = get_valid_path ( & line ) ; if ( ! mFile ) return PARSE_ERROR ; return OK ; }
void ComputeLoopInfo ( ZoneVector < SpecialRPOStackFrame > & queue , size_t num_loops , ZoneVector < Backedge > * backedges ) { for ( LoopInfo & loop : loops_ ) { loop . members -> Resize ( static_cast < int > ( schedule_ -> BasicBlockCount ( ) ) , zone_ ) ; } loops_ . resize ( num_loops , LoopInfo ( ) ) ; for ( size_t i = 0 ; i < backedges -> size ( ) ; i ++ ) { BasicBlock * member = backedges -> at ( i ) . first ; BasicBlock * header = member -> SuccessorAt ( backedges -> at ( i ) . second ) ; size_t loop_num = GetLoopNumber ( header ) ; if ( loops_ [ loop_num ] . header == nullptr ) { loops_ [ loop_num ] . header = header ; loops_ [ loop_num ] . members = new ( zone_ ) BitVector ( static_cast < int > ( schedule_ -> BasicBlockCount ( ) ) , zone_ ) ; } int queue_length = 0 ; if ( member != header ) { if ( ! loops_ [ loop_num ] . members -> Contains ( member -> id ( ) . ToInt ( ) ) ) { loops_ [ loop_num ] . members -> Add ( member -> id ( ) . ToInt ( ) ) ; } queue [ queue_length ++ ] . block = member ; } while ( queue_length > 0 ) { BasicBlock * block = queue [ -- queue_length ] . block ; for ( size_t i = 0 ; i < block -> PredecessorCount ( ) ; i ++ ) { BasicBlock * pred = block -> PredecessorAt ( i ) ; if ( pred != header ) { if ( ! loops_ [ loop_num ] . members -> Contains ( pred -> id ( ) . ToInt ( ) ) ) { loops_ [ loop_num ] . members -> Add ( pred -> id ( ) . ToInt ( ) ) ; queue [ queue_length ++ ] . block = pred ; } } } } } }
static int rm_read_multi ( AVFormatContext * s , AVIOContext * pb , AVStream * st , char * mime ) { int number_of_streams = avio_rb16 ( pb ) ; int number_of_mdpr ; int i , ret ; unsigned size2 ; for ( i = 0 ; i < number_of_streams ; i ++ ) avio_rb16 ( pb ) ; number_of_mdpr = avio_rb16 ( pb ) ; if ( number_of_mdpr != 1 ) { avpriv_request_sample ( s , "MLTI with multiple (%d) MDPR" , number_of_mdpr ) ; } for ( i = 0 ; i < number_of_mdpr ; i ++ ) { AVStream * st2 ; if ( i > 0 ) { st2 = avformat_new_stream ( s , NULL ) ; if ( ! st2 ) { ret = AVERROR ( ENOMEM ) ; return ret ; } st2 -> id = st -> id + ( i < < 16 ) ; st2 -> codecpar -> bit_rate = st -> codecpar -> bit_rate ; st2 -> start_time = st -> start_time ; st2 -> duration = st -> duration ; st2 -> codecpar -> codec_type = AVMEDIA_TYPE_DATA ; st2 -> priv_data = ff_rm_alloc_rmstream ( ) ; if ( ! st2 -> priv_data ) return AVERROR ( ENOMEM ) ; } else st2 = st ; size2 = avio_rb32 ( pb ) ; ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data , size2 , mime ) ; if ( ret < 0 ) return ret ; } return 0 ; }
int blkcg_init_queue ( struct request_queue * q ) { struct blkcg_gq * new_blkg , * blkg ; bool preloaded ; int ret ; new_blkg = blkg_alloc ( & blkcg_root , q , GFP_KERNEL ) ; if ( ! new_blkg ) return - ENOMEM ; preloaded = ! radix_tree_preload ( GFP_KERNEL ) ; rcu_read_lock ( ) ; spin_lock_irq ( q -> queue_lock ) ; blkg = blkg_create ( & blkcg_root , q , new_blkg ) ; spin_unlock_irq ( q -> queue_lock ) ; rcu_read_unlock ( ) ; if ( preloaded ) radix_tree_preload_end ( ) ; if ( IS_ERR ( blkg ) ) { blkg_free ( new_blkg ) ; return PTR_ERR ( blkg ) ; } q -> root_blkg = blkg ; q -> root_rl . blkg = blkg ; ret = blk_throtl_init ( q ) ; if ( ret ) { spin_lock_irq ( q -> queue_lock ) ; blkg_destroy_all ( q ) ; spin_unlock_irq ( q -> queue_lock ) ; } return ret ; }
static int tcp_mtu_probe ( struct sock * sk ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; struct sk_buff * skb , * nskb , * next ; struct net * net = sock_net ( sk ) ; int probe_size ; int size_needed ; int copy , len ; int mss_now ; int interval ; if ( likely ( ! icsk -> icsk_mtup . enabled || icsk -> icsk_mtup . probe_size || inet_csk ( sk ) -> icsk_ca_state != TCP_CA_Open || tp -> snd_cwnd < 11 || tp -> rx_opt . num_sacks || tp -> rx_opt . dsack ) ) return - 1 ; mss_now = tcp_current_mss ( sk ) ; probe_size = tcp_mtu_to_mss ( sk , ( icsk -> icsk_mtup . search_high + icsk -> icsk_mtup . search_low ) > > 1 ) ; size_needed = probe_size + ( tp -> reordering + 1 ) * tp -> mss_cache ; interval = icsk -> icsk_mtup . search_high - icsk -> icsk_mtup . search_low ; if ( probe_size > tcp_mtu_to_mss ( sk , icsk -> icsk_mtup . search_high ) || interval < net -> ipv4 . sysctl_tcp_probe_threshold ) { tcp_mtu_check_reprobe ( sk ) ; return - 1 ; } if ( tp -> write_seq - tp -> snd_nxt < size_needed ) return - 1 ; if ( tp -> snd_wnd < size_needed ) return - 1 ; if ( after ( tp -> snd_nxt + size_needed , tcp_wnd_end ( tp ) ) ) return 0 ; if ( tcp_packets_in_flight ( tp ) + 2 > tp -> snd_cwnd ) { if ( ! tcp_packets_in_flight ( tp ) ) return - 1 ; else return 0 ; } if ( ! tcp_can_coalesce_send_queue_head ( sk , probe_size ) ) return - 1 ; nskb = sk_stream_alloc_skb ( sk , probe_size , GFP_ATOMIC , false ) ; if ( ! nskb ) return - 1 ; sk -> sk_wmem_queued += nskb -> truesize ; sk_mem_charge ( sk , nskb -> truesize ) ; skb = tcp_send_head ( sk ) ; TCP_SKB_CB ( nskb ) -> seq = TCP_SKB_CB ( skb ) -> seq ; TCP_SKB_CB ( nskb ) -> end_seq = TCP_SKB_CB ( skb ) -> seq + probe_size ; TCP_SKB_CB ( nskb ) -> tcp_flags = TCPHDR_ACK ; TCP_SKB_CB ( nskb ) -> sacked = 0 ; nskb -> csum = 0 ; nskb -> ip_summed = CHECKSUM_PARTIAL ; tcp_insert_write_queue_before ( nskb , skb , sk ) ; tcp_highest_sack_replace ( sk , skb , nskb ) ; len = 0 ; tcp_for_write_queue_from_safe ( skb , next , sk ) { copy = min_t ( int , skb -> len , probe_size - len ) ; skb_copy_bits ( skb , 0 , skb_put ( nskb , copy ) , copy ) ; if ( skb -> len <= copy ) { TCP_SKB_CB ( nskb ) -> tcp_flags |= TCP_SKB_CB ( skb ) -> tcp_flags ; TCP_SKB_CB ( nskb ) -> eor = TCP_SKB_CB ( skb ) -> eor ; tcp_skb_collapse_tstamp ( nskb , skb ) ; tcp_unlink_write_queue ( skb , sk ) ; sk_wmem_free_skb ( sk , skb ) ; } else { TCP_SKB_CB ( nskb ) -> tcp_flags |= TCP_SKB_CB ( skb ) -> tcp_flags & ~ ( TCPHDR_FIN | TCPHDR_PSH ) ; if ( ! skb_shinfo ( skb ) -> nr_frags ) { skb_pull ( skb , copy ) ; } else { __pskb_trim_head ( skb , copy ) ; tcp_set_skb_tso_segs ( skb , mss_now ) ; } TCP_SKB_CB ( skb ) -> seq += copy ; } len += copy ; if ( len >= probe_size ) break ; } tcp_init_tso_segs ( nskb , nskb -> len ) ; if ( ! tcp_transmit_skb ( sk , nskb , 1 , GFP_ATOMIC ) ) { tp -> snd_cwnd -- ; tcp_event_new_data_sent ( sk , nskb ) ; icsk -> icsk_mtup . probe_size = tcp_mss_to_mtu ( sk , nskb -> len ) ; tp -> mtu_probe . probe_seq_start = TCP_SKB_CB ( nskb ) -> seq ; tp -> mtu_probe . probe_seq_end = TCP_SKB_CB ( nskb ) -> end_seq ; return 1 ; } return - 1 ; }
png_do_read_interlace ( png_row_infop row_info , png_bytep row , int pass , png_uint_32 transformations ) { static PNG_CONST int png_pass_inc [ 7 ] = { 8 , 8 , 4 , 4 , 2 , 2 , 1 } ; png_debug ( 1 , "in png_do_read_interlace" ) ; if ( row != NULL && row_info != NULL ) { png_uint_32 final_width ; final_width = row_info -> width * png_pass_inc [ pass ] ; switch ( row_info -> pixel_depth ) { case 1 : { png_bytep sp = row + ( png_size_t ) ( ( row_info -> width - 1 ) > > 3 ) ; png_bytep dp = row + ( png_size_t ) ( ( final_width - 1 ) > > 3 ) ; int sshift , dshift ; int s_start , s_end , s_inc ; int jstop = png_pass_inc [ pass ] ; png_byte v ; png_uint_32 i ; int j ; #ifdef PNG_READ_PACKSWAP_SUPPORTED if ( transformations & PNG_PACKSWAP ) { sshift = ( int ) ( ( row_info -> width + 7 ) & 0x07 ) ; dshift = ( int ) ( ( final_width + 7 ) & 0x07 ) ; s_start = 7 ; s_end = 0 ; s_inc = - 1 ; } else #endif { sshift = 7 - ( int ) ( ( row_info -> width + 7 ) & 0x07 ) ; dshift = 7 - ( int ) ( ( final_width + 7 ) & 0x07 ) ; s_start = 0 ; s_end = 7 ; s_inc = 1 ; } for ( i = 0 ; i < row_info -> width ; i ++ ) { v = ( png_byte ) ( ( * sp > > sshift ) & 0x01 ) ; for ( j = 0 ; j < jstop ; j ++ ) { unsigned int tmp = * dp & ( 0x7f7f > > ( 7 - dshift ) ) ; tmp |= v < < dshift ; * dp = ( png_byte ) ( tmp & 0xff ) ; if ( dshift == s_end ) { dshift = s_start ; dp -- ; } else dshift += s_inc ; } if ( sshift == s_end ) { sshift = s_start ; sp -- ; } else sshift += s_inc ; } break ; } case 2 : { png_bytep sp = row + ( png_uint_32 ) ( ( row_info -> width - 1 ) > > 2 ) ; png_bytep dp = row + ( png_uint_32 ) ( ( final_width - 1 ) > > 2 ) ; int sshift , dshift ; int s_start , s_end , s_inc ; int jstop = png_pass_inc [ pass ] ; png_uint_32 i ; #ifdef PNG_READ_PACKSWAP_SUPPORTED if ( transformations & PNG_PACKSWAP ) { sshift = ( int ) ( ( ( row_info -> width + 3 ) & 0x03 ) < < 1 ) ; dshift = ( int ) ( ( ( final_width + 3 ) & 0x03 ) < < 1 ) ; s_start = 6 ; s_end = 0 ; s_inc = - 2 ; } else #endif { sshift = ( int ) ( ( 3 - ( ( row_info -> width + 3 ) & 0x03 ) ) < < 1 ) ; dshift = ( int ) ( ( 3 - ( ( final_width + 3 ) & 0x03 ) ) < < 1 ) ; s_start = 0 ; s_end = 6 ; s_inc = 2 ; } for ( i = 0 ; i < row_info -> width ; i ++ ) { png_byte v ; int j ; v = ( png_byte ) ( ( * sp > > sshift ) & 0x03 ) ; for ( j = 0 ; j < jstop ; j ++ ) { unsigned int tmp = * dp & ( 0x3f3f > > ( 6 - dshift ) ) ; tmp |= v < < dshift ; * dp = ( png_byte ) ( tmp & 0xff ) ; if ( dshift == s_end ) { dshift = s_start ; dp -- ; } else dshift += s_inc ; } if ( sshift == s_end ) { sshift = s_start ; sp -- ; } else sshift += s_inc ; } break ; } case 4 : { png_bytep sp = row + ( png_size_t ) ( ( row_info -> width - 1 ) > > 1 ) ; png_bytep dp = row + ( png_size_t ) ( ( final_width - 1 ) > > 1 ) ; int sshift , dshift ; int s_start , s_end , s_inc ; png_uint_32 i ; int jstop = png_pass_inc [ pass ] ; #ifdef PNG_READ_PACKSWAP_SUPPORTED if ( transformations & PNG_PACKSWAP ) { sshift = ( int ) ( ( ( row_info -> width + 1 ) & 0x01 ) < < 2 ) ; dshift = ( int ) ( ( ( final_width + 1 ) & 0x01 ) < < 2 ) ; s_start = 4 ; s_end = 0 ; s_inc = - 4 ; } else #endif { sshift = ( int ) ( ( 1 - ( ( row_info -> width + 1 ) & 0x01 ) ) < < 2 ) ; dshift = ( int ) ( ( 1 - ( ( final_width + 1 ) & 0x01 ) ) < < 2 ) ; s_start = 0 ; s_end = 4 ; s_inc = 4 ; } for ( i = 0 ; i < row_info -> width ; i ++ ) { png_byte v = ( png_byte ) ( ( * sp > > sshift ) & 0x0f ) ; int j ; for ( j = 0 ; j < jstop ; j ++ ) { unsigned int tmp = * dp & ( 0xf0f > > ( 4 - dshift ) ) ; tmp |= v < < dshift ; * dp = ( png_byte ) ( tmp & 0xff ) ; if ( dshift == s_end ) { dshift = s_start ; dp -- ; } else dshift += s_inc ; } if ( sshift == s_end ) { sshift = s_start ; sp -- ; } else sshift += s_inc ; } break ; } default : { png_size_t pixel_bytes = ( row_info -> pixel_depth > > 3 ) ; png_bytep sp = row + ( png_size_t ) ( row_info -> width - 1 ) * pixel_bytes ; png_bytep dp = row + ( png_size_t ) ( final_width - 1 ) * pixel_bytes ; int jstop = png_pass_inc [ pass ] ; png_uint_32 i ; for ( i = 0 ; i < row_info -> width ; i ++ ) { png_byte v [ 8 ] ; int j ; memcpy ( v , sp , pixel_bytes ) ; for ( j = 0 ; j < jstop ; j ++ ) { memcpy ( dp , v , pixel_bytes ) ; dp -= pixel_bytes ; } sp -= pixel_bytes ; } break ; } } row_info -> width = final_width ; row_info -> rowbytes = PNG_ROWBYTES ( row_info -> pixel_depth , final_width ) ; } #ifndef PNG_READ_PACKSWAP_SUPPORTED PNG_UNUSED ( transformations ) #endif }
Handle < Object > DebugInfo :: FindBreakPointInfo ( Isolate * isolate , Handle < DebugInfo > debug_info , Handle < BreakPoint > break_point ) { DCHECK ( debug_info -> HasBreakInfo ( ) ) ; for ( int i = 0 ; i < debug_info -> break_points ( ) -> length ( ) ; i ++ ) { if ( ! debug_info -> break_points ( ) -> get ( i ) -> IsUndefined ( isolate ) ) { Handle < BreakPointInfo > break_point_info = Handle < BreakPointInfo > ( BreakPointInfo :: cast ( debug_info -> break_points ( ) -> get ( i ) ) , isolate ) ; if ( BreakPointInfo :: HasBreakPoint ( isolate , break_point_info , break_point ) ) { return break_point_info ; } } } return isolate -> factory ( ) -> undefined_value ( ) ; }
WebGLContext :: BindBuffer ( WebGLenum target , nsIWebGLBuffer * bobj ) { WebGLuint bufname ; WebGLBuffer * buf ; PRBool isNull ; if ( ! GetConcreteObjectAndGLName ( "bindBuffer" , bobj , & buf , & bufname , & isNull ) ) return NS_OK ; if ( target == LOCAL_GL_ARRAY_BUFFER ) { mBoundArrayBuffer = buf ; } else if ( target == LOCAL_GL_ELEMENT_ARRAY_BUFFER ) { mBoundElementArrayBuffer = buf ; } else { return ErrorInvalidEnumInfo ( "BindBuffer: target" , target ) ; } if ( ! isNull ) { if ( ( buf -> Target ( ) != LOCAL_GL_NONE ) && ( target != buf -> Target ( ) ) ) return ErrorInvalidOperation ( "BindBuffer: buffer already bound to a different target" ) ; buf -> SetTarget ( target ) ; buf -> SetHasEverBeenBound ( PR_TRUE ) ; } MakeContextCurrent ( ) ; gl -> fBindBuffer ( target , bufname ) ; return NS_OK ; }
std :: pair < Node * , Node * > AsyncFromSyncBuiltinsAssembler :: LoadIteratorResult ( Node * const context , Node * const native_context , Node * const iter_result , Label * if_exception , Variable * var_exception ) { Label if_fastpath ( this ) , if_slowpath ( this ) , merge ( this ) , to_boolean ( this ) , done ( this ) , if_notanobject ( this , Label :: kDeferred ) ; GotoIf ( TaggedIsSmi ( iter_result ) , & if_notanobject ) ; Node * const iter_result_map = LoadMap ( iter_result ) ; GotoIfNot ( IsJSReceiverMap ( iter_result_map ) , & if_notanobject ) ; Node * const fast_iter_result_map = LoadContextElement ( native_context , Context :: ITERATOR_RESULT_MAP_INDEX ) ; VARIABLE ( var_value , MachineRepresentation :: kTagged ) ; VARIABLE ( var_done , MachineRepresentation :: kTagged ) ; Branch ( WordEqual ( iter_result_map , fast_iter_result_map ) , & if_fastpath , & if_slowpath ) ; BIND ( & if_fastpath ) ; { var_done . Bind ( LoadObjectField ( iter_result , JSIteratorResult :: kDoneOffset ) ) ; var_value . Bind ( LoadObjectField ( iter_result , JSIteratorResult :: kValueOffset ) ) ; Goto ( & merge ) ; } BIND ( & if_slowpath ) ; { Node * const done = GetProperty ( context , iter_result , factory ( ) -> done_string ( ) ) ; GotoIfException ( done , if_exception , var_exception ) ; Node * const value = GetProperty ( context , iter_result , factory ( ) -> value_string ( ) ) ; GotoIfException ( value , if_exception , var_exception ) ; var_value . Bind ( value ) ; var_done . Bind ( done ) ; Goto ( & merge ) ; } BIND ( & if_notanobject ) ; { Node * const error = MakeTypeError ( MessageTemplate :: kIteratorResultNotAnObject , context , iter_result ) ; var_exception -> Bind ( error ) ; Goto ( if_exception ) ; } BIND ( & merge ) ; GotoIf ( TaggedIsSmi ( var_done . value ( ) ) , & to_boolean ) ; Branch ( IsBoolean ( var_done . value ( ) ) , & done , & to_boolean ) ; BIND ( & to_boolean ) ; { Node * const result = CallBuiltin ( Builtins :: kToBoolean , context , var_done . value ( ) ) ; var_done . Bind ( result ) ; Goto ( & done ) ; } BIND ( & done ) ; return std :: make_pair ( var_value . value ( ) , var_done . value ( ) ) ; }
ipp_write_file ( int * fd , ipp_uchar_t * buffer , size_t length ) { #ifdef WIN32 return ( ( ssize_t ) write ( * fd , buffer , ( unsigned ) length ) ) ; #else return ( write ( * fd , buffer , length ) ) ; #endif /* WIN32 */ }
win_enter_ext ( win_T * wp , int undo_sync , int curwin_invalid , int trigger_new_autocmds , int trigger_enter_autocmds , int trigger_leave_autocmds ) { int other_buffer = FALSE ; if ( wp == curwin && ! curwin_invalid ) return ; #ifdef FEAT_JOB_CHANNEL if ( ! curwin_invalid ) leaving_window ( curwin ) ; #endif if ( ! curwin_invalid && trigger_leave_autocmds ) { if ( wp -> w_buffer != curbuf ) { apply_autocmds ( EVENT_BUFLEAVE , NULL , NULL , FALSE , curbuf ) ; other_buffer = TRUE ; if ( ! win_valid ( wp ) ) return ; } apply_autocmds ( EVENT_WINLEAVE , NULL , NULL , FALSE , curbuf ) ; if ( ! win_valid ( wp ) ) return ; #ifdef FEAT_EVAL if ( aborting ( ) ) return ; #endif } if ( undo_sync && curbuf != wp -> w_buffer ) u_sync ( FALSE ) ; update_topline ( ) ; if ( wp -> w_buffer != curbuf ) buf_copy_options ( wp -> w_buffer , BCO_ENTER | BCO_NOHELP ) ; if ( ! curwin_invalid ) { prevwin = curwin ; curwin -> w_redr_status = TRUE ; } curwin = wp ; curbuf = wp -> w_buffer ; check_cursor ( ) ; if ( ! virtual_active ( ) ) curwin -> w_cursor . coladd = 0 ; changed_line_abv_curs ( ) ; if ( curwin -> w_localdir != NULL || curtab -> tp_localdir != NULL ) { char_u * dirname ; if ( globaldir == NULL ) { char_u cwd [ MAXPATHL ] ; if ( mch_dirname ( cwd , MAXPATHL ) == OK ) globaldir = vim_strsave ( cwd ) ; } if ( curwin -> w_localdir != NULL ) dirname = curwin -> w_localdir ; else dirname = curtab -> tp_localdir ; if ( mch_chdir ( ( char * ) dirname ) == 0 ) shorten_fnames ( TRUE ) ; } else if ( globaldir != NULL ) { vim_ignored = mch_chdir ( ( char * ) globaldir ) ; VIM_CLEAR ( globaldir ) ; shorten_fnames ( TRUE ) ; } #ifdef FEAT_JOB_CHANNEL entering_window ( curwin ) ; #endif if ( trigger_new_autocmds ) apply_autocmds ( EVENT_WINNEW , NULL , NULL , FALSE , curbuf ) ; if ( trigger_enter_autocmds ) { apply_autocmds ( EVENT_WINENTER , NULL , NULL , FALSE , curbuf ) ; if ( other_buffer ) apply_autocmds ( EVENT_BUFENTER , NULL , NULL , FALSE , curbuf ) ; } #ifdef FEAT_TITLE maketitle ( ) ; #endif curwin -> w_redr_status = TRUE ; #ifdef FEAT_TERMINAL if ( bt_terminal ( wp -> w_buffer ) ) redraw_mode = TRUE ; #endif redraw_tabline = TRUE ; if ( restart_edit ) redraw_later ( VALID ) ; if ( curwin -> w_height < p_wh && ! curwin -> w_p_wfh #ifdef FEAT_TEXT_PROP && ! popup_is_popup ( curwin ) #endif ) win_setheight ( ( int ) p_wh ) ; else if ( curwin -> w_height == 0 ) win_setheight ( 1 ) ; if ( curwin -> w_width < p_wiw && ! curwin -> w_p_wfw ) win_setwidth ( ( int ) p_wiw ) ; setmouse ( ) ; DO_AUTOCHDIR ; }
nsJSContext :: CallEventHandler ( nsISupports * aTarget , JSObject * aScope , JSObject * aHandler , nsIArray * aargv , nsIVariant * * arv ) { NS_ENSURE_TRUE ( mIsInitialized , NS_ERROR_NOT_INITIALIZED ) ; if ( ! mScriptsEnabled ) { return NS_OK ; } SAMPLE_LABEL ( "JS" , "CallEventHandler" ) ; nsAutoMicroTask mt ; xpc_UnmarkGrayObject ( aScope ) ; xpc_UnmarkGrayObject ( aHandler ) ; XPCAutoRequest ar ( mContext ) ; JSObject * target = nullptr ; nsresult rv = JSObjectFromInterface ( aTarget , aScope , & target ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; JS :: AutoObjectRooter targetVal ( mContext , target ) ; jsval rval = JSVAL_VOID ; nsCxPusher pusher ; if ( ! pusher . Push ( mContext ) ) return NS_ERROR_FAILURE ; rv = sSecurityManager -> CheckFunctionAccess ( mContext , aHandler , target ) ; nsJSContext :: TerminationFuncHolder holder ( this ) ; if ( NS_SUCCEEDED ( rv ) ) { uint32_t argc = 0 ; jsval * argv = nullptr ; JSObject * funobj = aHandler ; jsval funval = OBJECT_TO_JSVAL ( funobj ) ; JSAutoCompartment ac ( mContext , funobj ) ; if ( ! JS_WrapObject ( mContext , & target ) ) { ReportPendingException ( ) ; return NS_ERROR_FAILURE ; } Maybe < nsRootedJSValueArray > tempStorage ; rv = ConvertSupportsTojsvals ( aargv , target , & argc , & argv , tempStorage ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; for ( uint32_t i = 0 ; i < argc ; i ++ ) { if ( ! JSVAL_IS_PRIMITIVE ( argv [ i ] ) ) { xpc_UnmarkGrayObject ( JSVAL_TO_OBJECT ( argv [ i ] ) ) ; } } ++ mExecuteDepth ; bool ok = :: JS_CallFunctionValue ( mContext , target , funval , argc , argv , & rval ) ; -- mExecuteDepth ; if ( ! ok ) { rval = JSVAL_VOID ; rv = NS_ERROR_FAILURE ; } else if ( rval == JSVAL_NULL ) { * arv = nullptr ; } else if ( ! JS_WrapValue ( mContext , & rval ) ) { rv = NS_ERROR_FAILURE ; } else { rv = nsContentUtils :: XPConnect ( ) -> JSToVariant ( mContext , rval , arv ) ; } if ( NS_FAILED ( rv ) ) ReportPendingException ( ) ; } pusher . Pop ( ) ; ScriptEvaluated ( true ) ; return rv ; }
RandomNumberGenerator :: RandomNumberGenerator ( ) { { LockGuard < Mutex > lock_guard ( entropy_mutex . Pointer ( ) ) ; if ( entropy_source != nullptr ) { int64_t seed ; if ( entropy_source ( reinterpret_cast < unsigned char * > ( & seed ) , sizeof ( seed ) ) ) { SetSeed ( seed ) ; return ; } } } #if V8_OS_CYGWIN || V8_OS_WIN unsigned first_half , second_half ; errno_t result = rand_s ( & first_half ) ; DCHECK_EQ ( 0 , result ) ; result = rand_s ( & second_half ) ; DCHECK_EQ ( 0 , result ) ; SetSeed ( ( static_cast < int64_t > ( first_half ) < < 32 ) + second_half ) ; #else FILE * fp = fopen ( "/dev/urandom" , "rb" ) ; if ( fp != nullptr ) { int64_t seed ; size_t n = fread ( & seed , sizeof ( seed ) , 1 , fp ) ; fclose ( fp ) ; if ( n == 1 ) { SetSeed ( seed ) ; return ; } } int64_t seed = Time :: NowFromSystemTime ( ) . ToInternalValue ( ) < < 24 ; seed ^= TimeTicks :: HighResolutionNow ( ) . ToInternalValue ( ) < < 16 ; seed ^= TimeTicks :: Now ( ) . ToInternalValue ( ) < < 8 ; SetSeed ( seed ) ; #endif // V8_OS_CYGWIN || V8_OS_WIN }
void nsPluginInstanceOwner :: PerformDelayedBlurs ( ) { nsCOMPtr < EventTarget > windowRoot = mContent -> OwnerDoc ( ) -> GetWindow ( ) -> GetTopWindowRoot ( ) ; nsContentUtils :: DispatchTrustedEvent ( mContent -> OwnerDoc ( ) , windowRoot , NS_LITERAL_STRING ( "MozPerformDelayedBlur" ) , false , false , nullptr ) ; }
static vpx_codec_err_t encoder_common_init ( vpx_codec_ctx_t * ctx ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ctx -> priv == NULL ) { int i ; vpx_codec_enc_cfg_t * cfg ; struct vpx_codec_alg_priv * priv = calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ; ctx -> priv = & priv -> base ; ctx -> priv -> sz = sizeof ( * ctx -> priv ) ; ctx -> priv -> iface = ctx -> iface ; ctx -> priv -> alg_priv = priv ; ctx -> priv -> init_flags = ctx -> init_flags ; ctx -> priv -> enc . total_encoders = 1 ; if ( ctx -> config . enc ) { ctx -> priv -> alg_priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & ctx -> priv -> alg_priv -> cfg ; } cfg = & ctx -> priv -> alg_priv -> cfg ; for ( i = 0 ; extracfg_map [ i ] . usage && extracfg_map [ i ] . usage != cfg -> g_usage ; ++ i ) { } priv -> extra_cfg = extracfg_map [ i ] . cfg ; priv -> extra_cfg . pkt_list = & priv -> pkt_list . head ; priv -> cx_data_sz = priv -> cfg . g_w * priv -> cfg . g_h * 3 / 2 * 8 ; if ( priv -> cx_data_sz < 4096 ) priv -> cx_data_sz = 4096 ; priv -> cx_data = ( unsigned char * ) malloc ( priv -> cx_data_sz ) ; if ( priv -> cx_data == NULL ) return VPX_CODEC_MEM_ERROR ; vp9_initialize_enc ( ) ; res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { VP9_COMP * cpi ; set_encoder_config ( & ctx -> priv -> alg_priv -> oxcf , & ctx -> priv -> alg_priv -> cfg , & ctx -> priv -> alg_priv -> extra_cfg ) ; cpi = vp9_create_compressor ( & ctx -> priv -> alg_priv -> oxcf ) ; if ( cpi == NULL ) res = VPX_CODEC_MEM_ERROR ; else ctx -> priv -> alg_priv -> cpi = cpi ; } } return res ; }
TfLiteStatus EvalSimple ( TfLiteContext * context , TfLiteNode * node , const TfLiteTensor * lookup , const TfLiteTensor * value , TfLiteTensor * output ) { const int row_size = SizeOfDimension ( value , 0 ) ; const int row_bytes = value -> bytes / row_size ; char * output_raw = GetTensorData < char > ( output ) ; const char * value_raw = GetTensorData < char > ( value ) ; const int32_t * lookup_data = GetTensorData < int32_t > ( lookup ) ; for ( int i = 0 ; i < SizeOfDimension ( lookup , 0 ) ; i ++ ) { int idx = lookup_data [ i ] ; if ( idx >= row_size || idx < 0 ) { context -> ReportError ( context , "Embedding Lookup: index out of bounds. " "Got %d, and bounds are [0, %d]" , idx , row_size - 1 ) ; return kTfLiteError ; } else { std :: memcpy ( output_raw + i * row_bytes , value_raw + idx * row_bytes , row_bytes ) ; } } return kTfLiteOk ; }
static void nfs4_xdr_enc_getacl ( struct rpc_rqst * req , struct xdr_stream * xdr , struct nfs_getaclargs * args ) { struct compound_hdr hdr = { . minorversion = nfs4_xdr_minorversion ( & args -> seq_args ) , } ; uint32_t replen ; encode_compound_hdr ( xdr , req , & hdr ) ; encode_sequence ( xdr , & args -> seq_args , & hdr ) ; encode_putfh ( xdr , args -> fh , & hdr ) ; replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ; encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ; xdr_inline_pages ( & req -> rq_rcv_buf , replen < < 2 , args -> acl_pages , args -> acl_pgbase , args -> acl_len ) ; encode_nops ( & hdr ) ; }
Status ConstantFolding :: IsSimplifiableReshape ( const NodeDef & node , const GraphProperties & properties ) const { if ( ! IsReshape ( node ) ) { return errors :: Internal ( "Node " , node . name ( ) , " is not a Reshape node" ) ; } CHECK_LE ( 2 , node . input_size ( ) ) ; const NodeDef * new_shape = node_map_ -> GetNode ( node . input ( 1 ) ) ; if ( ! IsReallyConstant ( * new_shape ) ) { return errors :: Internal ( "Node " , node . name ( ) , " has shape " , new_shape -> DebugString ( ) , " which is not a constant" ) ; } TensorVector outputs ; auto outputs_cleanup = gtl :: MakeCleanup ( [ & outputs ] { for ( const auto & output : outputs ) { delete output . tensor ; } } ) ; Status s = EvaluateNode ( * new_shape , TensorVector ( ) , & outputs ) ; if ( ! s . ok ( ) ) { return errors :: Internal ( "Could not evaluate node " , node . name ( ) ) ; } CHECK_EQ ( 1 , outputs . size ( ) ) ; const std :: vector < OpInfo :: TensorProperties > & props = properties . GetInputProperties ( node . name ( ) ) ; if ( props . empty ( ) ) { return errors :: Internal ( "Node " , node . name ( ) , " has no properties" ) ; } const OpInfo :: TensorProperties & prop = props [ 0 ] ; if ( prop . dtype ( ) == DT_INVALID ) { return errors :: Internal ( "Node " , node . name ( ) , " has property " , prop . DebugString ( ) , " with invalid dtype" ) ; } const PartialTensorShape shape ( prop . shape ( ) ) ; if ( ! shape . IsFullyDefined ( ) ) { return errors :: Internal ( "Node " , node . name ( ) , " has property " , prop . DebugString ( ) , " with shape " , shape . DebugString ( ) , " which is not fully defined" ) ; } PartialTensorShape new_dims ; if ( outputs [ 0 ] -> dtype ( ) == DT_INT32 ) { std :: vector < int32 > shp ; for ( int i = 0 ; i < outputs [ 0 ] -> NumElements ( ) ; ++ i ) { int32_t dim = outputs [ 0 ] -> flat < int32 > ( ) ( i ) ; shp . push_back ( dim ) ; } TF_CHECK_OK ( TensorShapeUtils :: MakeShape ( shp , & new_dims ) ) ; } else { std :: vector < int64_t > shp ; for ( int i = 0 ; i < outputs [ 0 ] -> NumElements ( ) ; ++ i ) { int64_t dim = outputs [ 0 ] -> flat < int64_t > ( ) ( i ) ; shp . push_back ( dim ) ; } TF_CHECK_OK ( TensorShapeUtils :: MakeShape ( shp , & new_dims ) ) ; } if ( ! shape . IsCompatibleWith ( new_dims ) ) { return errors :: Internal ( "Expected shape " , shape . DebugString ( ) , "to be compatible with " , new_dims . DebugString ( ) ) ; } return Status :: OK ( ) ; }
HeapEntry :: HeapEntry ( HeapSnapshot * snapshot , Type type , const char * name , SnapshotObjectId id , size_t self_size , unsigned trace_node_id ) : type_ ( type ) , children_count_ ( 0 ) , children_index_ ( - 1 ) , self_size_ ( self_size ) , snapshot_ ( snapshot ) , name_ ( name ) , id_ ( id ) , trace_node_id_ ( trace_node_id ) { }
long ContentEncoding :: ParseEncryptionEntry ( long long start , long long size , IMkvReader * pReader , ContentEncryption * encryption ) { assert ( pReader ) ; assert ( encryption ) ; long long pos = start ; const long long stop = start + size ; while ( pos < stop ) { long long id , size ; const long status = ParseElementHeader ( pReader , pos , stop , id , size ) ; if ( status < 0 ) return status ; if ( id == 0x7E1 ) { encryption -> algo = UnserializeUInt ( pReader , pos , size ) ; if ( encryption -> algo != 5 ) return E_FILE_FORMAT_INVALID ; } else if ( id == 0x7E2 ) { delete [ ] encryption -> key_id ; encryption -> key_id = NULL ; encryption -> key_id_len = 0 ; if ( size <= 0 ) return E_FILE_FORMAT_INVALID ; const size_t buflen = static_cast < size_t > ( size ) ; typedef unsigned char * buf_t ; const buf_t buf = new ( std :: nothrow ) unsigned char [ buflen ] ; if ( buf == NULL ) return - 1 ; const int read_status = pReader -> Read ( pos , buflen , buf ) ; if ( read_status ) { delete [ ] buf ; return status ; } encryption -> key_id = buf ; encryption -> key_id_len = buflen ; } else if ( id == 0x7E3 ) { delete [ ] encryption -> signature ; encryption -> signature = NULL ; encryption -> signature_len = 0 ; if ( size <= 0 ) return E_FILE_FORMAT_INVALID ; const size_t buflen = static_cast < size_t > ( size ) ; typedef unsigned char * buf_t ; const buf_t buf = new ( std :: nothrow ) unsigned char [ buflen ] ; if ( buf == NULL ) return - 1 ; const int read_status = pReader -> Read ( pos , buflen , buf ) ; if ( read_status ) { delete [ ] buf ; return status ; } encryption -> signature = buf ; encryption -> signature_len = buflen ; } else if ( id == 0x7E4 ) { delete [ ] encryption -> sig_key_id ; encryption -> sig_key_id = NULL ; encryption -> sig_key_id_len = 0 ; if ( size <= 0 ) return E_FILE_FORMAT_INVALID ; const size_t buflen = static_cast < size_t > ( size ) ; typedef unsigned char * buf_t ; const buf_t buf = new ( std :: nothrow ) unsigned char [ buflen ] ; if ( buf == NULL ) return - 1 ; const int read_status = pReader -> Read ( pos , buflen , buf ) ; if ( read_status ) { delete [ ] buf ; return status ; } encryption -> sig_key_id = buf ; encryption -> sig_key_id_len = buflen ; } else if ( id == 0x7E5 ) { encryption -> sig_algo = UnserializeUInt ( pReader , pos , size ) ; } else if ( id == 0x7E6 ) { encryption -> sig_hash_algo = UnserializeUInt ( pReader , pos , size ) ; } else if ( id == 0x7E7 ) { const long status = ParseContentEncAESSettingsEntry ( pos , size , pReader , & encryption -> aes_settings ) ; if ( status ) return status ; } pos += size ; assert ( pos <= stop ) ; } return 0 ; }
static int __init ip6_tunnel_init ( void ) { int err ; if ( xfrm6_tunnel_register ( & ip4ip6_handler , AF_INET ) ) { printk ( KERN_ERR "ip6_tunnel init: can't register ip4ip6\n" ) ; err = - EAGAIN ; goto out ; } if ( xfrm6_tunnel_register ( & ip6ip6_handler , AF_INET6 ) ) { printk ( KERN_ERR "ip6_tunnel init: can't register ip6ip6\n" ) ; err = - EAGAIN ; goto unreg_ip4ip6 ; } err = register_pernet_device ( & ip6_tnl_net_ops ) ; if ( err < 0 ) goto err_pernet ; return 0 ; err_pernet : xfrm6_tunnel_deregister ( & ip6ip6_handler , AF_INET6 ) ; unreg_ip4ip6 : xfrm6_tunnel_deregister ( & ip4ip6_handler , AF_INET ) ; out : return err ; }
static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid ) { FILE * fp = fopen ( dest_filename , "w" ) ; if ( ! fp ) return false ; unsigned fd = 0 ; while ( fd <= 99999 ) { sprintf ( source_filename + source_base_ofs , "fd/%u" , fd ) ; char * name = malloc_readlink ( source_filename ) ; if ( ! name ) break ; fprintf ( fp , "%u:%s\n" , fd , name ) ; free ( name ) ; sprintf ( source_filename + source_base_ofs , "fdinfo/%u" , fd ) ; fd ++ ; FILE * in = fopen ( source_filename , "r" ) ; if ( ! in ) continue ; char buf [ 128 ] ; while ( fgets ( buf , sizeof ( buf ) - 1 , in ) ) { char * eol = strchrnul ( buf , '\n' ) ; eol [ 0 ] = '\n' ; eol [ 1 ] = '\0' ; fputs ( buf , fp ) ; } fclose ( in ) ; } const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( "Can't change '%s' ownership to %lu:%lu" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; } fclose ( fp ) ; return true ; }
int passwd_to_utf16 ( unsigned char * in_passwd , int length , int max_length , unsigned char * out_passwd ) { #ifdef WIN32 int ret ; ( void ) length ; ret = MultiByteToWideChar ( CP_ACP , 0 , ( LPCSTR ) in_passwd , - 1 , ( LPWSTR ) out_passwd , max_length / 2 ) ; if ( ret == 0 ) return AESCRYPT_READPWD_ICONV ; return ret * 2 ; #else #ifndef ENABLE_ICONV int i ; for ( i = 0 ; i < length + 1 ; i ++ ) { out_passwd [ i * 2 ] = in_passwd [ i ] ; out_passwd [ i * 2 + 1 ] = 0 ; } return length * 2 ; #else unsigned char * ic_outbuf , * ic_inbuf ; iconv_t condesc ; size_t ic_inbytesleft , ic_outbytesleft ; max_length *= 2 ; ic_inbuf = in_passwd ; ic_inbytesleft = length ; ic_outbytesleft = max_length ; ic_outbuf = out_passwd ; setlocale ( LC_CTYPE , "" ) ; if ( ( condesc = iconv_open ( "UTF-16LE" , nl_langinfo ( CODESET ) ) ) == ( iconv_t ) ( - 1 ) ) { perror ( "Error in iconv_open" ) ; return - 1 ; } if ( iconv ( condesc , ( char * * const ) & ic_inbuf , & ic_inbytesleft , ( char * * const ) & ic_outbuf , & ic_outbytesleft ) == ( size_t ) - 1 ) { switch ( errno ) { case E2BIG : fprintf ( stderr , "Error: password too long\n" ) ; iconv_close ( condesc ) ; return - 1 ; break ; default : perror ( "Password conversion error" ) ; iconv_close ( condesc ) ; return - 1 ; } } iconv_close ( condesc ) ; return ( max_length - ic_outbytesleft ) ; #endif #endif }
status_t SurfaceFlinger :: captureScreenImplLocked ( const RenderArea & renderArea , TraverseLayersFunction traverseLayers , ANativeWindowBuffer * buffer , bool useIdentityTransform , bool forSystem , int * outSyncFd ) { ATRACE_CALL ( ) ; bool secureLayerIsVisible = false ; traverseLayers ( [ & ] ( Layer * layer ) { secureLayerIsVisible = secureLayerIsVisible || ( layer -> isVisible ( ) && layer -> isSecure ( ) ) ; } ) ; if ( secureLayerIsVisible && ! forSystem ) { ALOGW ( "FB is protected: PERMISSION_DENIED" ) ; return PERMISSION_DENIED ; } RE :: BindNativeBufferAsFramebuffer bufferBond ( getRenderEngine ( ) , buffer ) ; if ( bufferBond . getStatus ( ) != NO_ERROR ) { ALOGE ( "got ANWB binding error while taking screenshot" ) ; return INVALID_OPERATION ; } renderScreenImplLocked ( renderArea , traverseLayers , true , useIdentityTransform ) ; if ( DEBUG_SCREENSHOTS ) { getRenderEngine ( ) . finish ( ) ; * outSyncFd = - 1 ; const auto reqWidth = renderArea . getReqWidth ( ) ; const auto reqHeight = renderArea . getReqHeight ( ) ; uint32_t * pixels = new uint32_t [ reqWidth * reqHeight ] ; getRenderEngine ( ) . readPixels ( 0 , 0 , reqWidth , reqHeight , pixels ) ; checkScreenshot ( reqWidth , reqHeight , reqWidth , pixels , traverseLayers ) ; delete [ ] pixels ; } else { base :: unique_fd syncFd = getRenderEngine ( ) . flush ( ) ; if ( syncFd < 0 ) { getRenderEngine ( ) . finish ( ) ; } * outSyncFd = syncFd . release ( ) ; } return NO_ERROR ; }
RUNTIME_FUNCTION ( Runtime_NewClosure ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 2 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( SharedFunctionInfo , shared , 0 ) ; CONVERT_ARG_HANDLE_CHECKED ( FeedbackCell , feedback_cell , 1 ) ; Handle < Context > context ( isolate -> context ( ) , isolate ) ; Handle < JSFunction > function = isolate -> factory ( ) -> NewFunctionFromSharedFunctionInfo ( shared , context , feedback_cell , NOT_TENURED ) ; return * function ; }
bool Chapters :: ExpandEditionsArray ( ) { if ( m_editions_size > m_editions_count ) return true ; const int size = ( m_editions_size == 0 ) ? 1 : 2 * m_editions_size ; Edition * const editions = new ( std :: nothrow ) Edition [ size ] ; if ( editions == NULL ) return false ; for ( int idx = 0 ; idx < m_editions_count ; ++ idx ) { m_editions [ idx ] . ShallowCopy ( editions [ idx ] ) ; } delete [ ] m_editions ; m_editions = editions ; m_editions_size = size ; return true ; }
static int wanxl_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { const size_t size = sizeof ( sync_serial_settings ) ; sync_serial_settings line ; port_t * port = dev_to_port ( dev ) ; if ( cmd != SIOCWANDEV ) return hdlc_ioctl ( dev , ifr , cmd ) ; switch ( ifr -> ifr_settings . type ) { case IF_GET_IFACE : ifr -> ifr_settings . type = IF_IFACE_SYNC_SERIAL ; if ( ifr -> ifr_settings . size < size ) { ifr -> ifr_settings . size = size ; return - ENOBUFS ; } line . clock_type = get_status ( port ) -> clocking ; line . clock_rate = 0 ; line . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & line , size ) ) return - EFAULT ; return 0 ; case IF_IFACE_SYNC_SERIAL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( dev -> flags & IFF_UP ) return - EBUSY ; if ( copy_from_user ( & line , ifr -> ifr_settings . ifs_ifsu . sync , size ) ) return - EFAULT ; if ( line . clock_type != CLOCK_EXT && line . clock_type != CLOCK_TXFROMRX ) return - EINVAL ; if ( line . loopback != 0 ) return - EINVAL ; get_status ( port ) -> clocking = line . clock_type ; return 0 ; default : return hdlc_ioctl ( dev , ifr , cmd ) ; } }
base :: Optional < ParseResult > MakeGotoStatement ( ParseResultIterator * child_results ) { auto label = child_results -> NextAs < std :: string > ( ) ; auto arguments = child_results -> NextAs < std :: vector < Expression * > > ( ) ; Statement * result = MakeNode < GotoStatement > ( std :: move ( label ) , std :: move ( arguments ) ) ; return ParseResult { result } ; }
ObjectValueMap :: findZoneEdges ( ) { JS :: AutoSuppressGCAnalysis nogc ; for ( Range r = all ( ) ; ! r . empty ( ) ; r . popFront ( ) ) { JSObject * key = r . front ( ) . key ( ) ; if ( key -> asTenured ( ) . isMarked ( BLACK ) && ! key -> asTenured ( ) . isMarked ( GRAY ) ) continue ; JSObject * delegate = getDelegate ( key ) ; if ( ! delegate ) continue ; Zone * delegateZone = delegate -> zone ( ) ; if ( delegateZone == zone ) continue ; if ( ! delegateZone -> gcZoneGroupEdges ( ) . put ( key -> zone ( ) ) ) return false ; } return true ; }
void bnep_net_setup ( struct net_device * dev ) { memset ( dev -> broadcast , 0xff , ETH_ALEN ) ; dev -> addr_len = ETH_ALEN ; ether_setup ( dev ) ; dev -> netdev_ops = & bnep_netdev_ops ; dev -> watchdog_timeo = HZ * 2 ; }
static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize ) { MACROBLOCK * const x = & cpi -> mb ; if ( bsize < BLOCK_8X8 ) { if ( x -> ab_index > 0 ) return ; } set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize , output_enabled ) ; encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; if ( output_enabled ) { update_stats ( cpi ) ; ( * tp ) -> token = EOSB_TOKEN ; ( * tp ) ++ ; } }
Reduction JSCreateLowering :: ReduceNewArray ( Node * node , Node * length , MapRef initial_map , PretenureFlag pretenure , const SlackTrackingPrediction & slack_tracking_prediction ) { DCHECK_EQ ( IrOpcode :: kJSCreateArray , node -> opcode ( ) ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; ASSIGN_RETURN_NO_CHANGE_IF_DATA_MISSING ( initial_map , initial_map . AsElementsKind ( GetHoleyElementsKind ( initial_map . elements_kind ( ) ) ) ) ; length = effect = graph ( ) -> NewNode ( simplified ( ) -> CheckBounds ( VectorSlotPair ( ) ) , length , jsgraph ( ) -> Constant ( JSArray :: kInitialMaxFastElementArray ) , effect , control ) ; Node * elements = effect = graph ( ) -> NewNode ( IsDoubleElementsKind ( initial_map . elements_kind ( ) ) ? simplified ( ) -> NewDoubleElements ( pretenure ) : simplified ( ) -> NewSmiOrObjectElements ( pretenure ) , length , effect , control ) ; Node * properties = jsgraph ( ) -> EmptyFixedArrayConstant ( ) ; AllocationBuilder a ( jsgraph ( ) , effect , control ) ; a . Allocate ( slack_tracking_prediction . instance_size ( ) , pretenure ) ; a . Store ( AccessBuilder :: ForMap ( ) , initial_map ) ; a . Store ( AccessBuilder :: ForJSObjectPropertiesOrHash ( ) , properties ) ; a . Store ( AccessBuilder :: ForJSObjectElements ( ) , elements ) ; a . Store ( AccessBuilder :: ForJSArrayLength ( initial_map . elements_kind ( ) ) , length ) ; for ( int i = 0 ; i < slack_tracking_prediction . inobject_property_count ( ) ; ++ i ) { a . Store ( AccessBuilder :: ForJSObjectInObjectProperty ( initial_map , i ) , jsgraph ( ) -> UndefinedConstant ( ) ) ; } RelaxControls ( node ) ; a . FinishAndChange ( node ) ; return Changed ( node ) ; }
nsPasswordManager :: FillDocument ( nsIDOMDocument * aDomDoc ) { nsCOMPtr < nsIDOMHTMLDocument > htmlDoc = do_QueryInterface ( aDomDoc ) ; if ( ! htmlDoc ) return NS_OK ; nsCOMPtr < nsIDOMHTMLCollection > forms ; htmlDoc -> GetForms ( getter_AddRefs ( forms ) ) ; nsCOMPtr < nsIDocument > doc = do_QueryInterface ( aDomDoc ) ; nsCAutoString realm ; if ( ! GetPasswordRealm ( doc -> GetDocumentURI ( ) , realm ) ) return NS_OK ; SignonHashEntry * hashEnt ; if ( ! mSignonTable . Get ( realm , & hashEnt ) ) return NS_OK ; PRUint32 formCount ; forms -> GetLength ( & formCount ) ; PRBool prefillForm = PR_TRUE ; mPrefBranch -> GetBoolPref ( "autofillForms" , & prefillForm ) ; for ( PRUint32 i = 0 ; i < formCount ; ++ i ) { nsCOMPtr < nsIDOMNode > formNode ; forms -> Item ( i , getter_AddRefs ( formNode ) ) ; nsCOMPtr < nsIForm > form = do_QueryInterface ( formNode ) ; SignonDataEntry * firstMatch = nsnull ; PRBool attachedToInput = PR_FALSE ; PRBool prefilledUser = PR_FALSE ; nsCOMPtr < nsIDOMHTMLInputElement > userField , passField ; nsCOMPtr < nsIDOMHTMLInputElement > temp ; nsAutoString fieldType ; for ( SignonDataEntry * e = hashEnt -> head ; e ; e = e -> next ) { nsCOMPtr < nsISupports > foundNode ; if ( ! ( e -> userField ) . IsEmpty ( ) ) { form -> ResolveName ( e -> userField , getter_AddRefs ( foundNode ) ) ; temp = do_QueryInterface ( foundNode ) ; } nsAutoString oldUserValue ; PRBool userFieldFound = PR_FALSE ; if ( temp ) { temp -> GetType ( fieldType ) ; if ( ! fieldType . Equals ( NS_LITERAL_STRING ( "text" ) ) ) continue ; temp -> GetValue ( oldUserValue ) ; userField = temp ; userFieldFound = PR_TRUE ; } else if ( ( e -> passField ) . IsEmpty ( ) ) { PRUint32 count ; form -> GetElementCount ( & count ) ; PRUint32 i ; nsCOMPtr < nsIFormControl > formControl ; for ( i = 0 ; i < count ; i ++ ) { form -> GetElementAt ( i , getter_AddRefs ( formControl ) ) ; if ( formControl && formControl -> GetType ( ) == NS_FORM_INPUT_TEXT ) { nsCOMPtr < nsIDOMHTMLInputElement > inputField = do_QueryInterface ( formControl ) ; nsAutoString name ; inputField -> GetName ( name ) ; if ( name . EqualsIgnoreCase ( NS_ConvertUTF16toUTF8 ( e -> userField ) . get ( ) ) ) { inputField -> GetValue ( oldUserValue ) ; userField = inputField ; foundNode = inputField ; e -> userField . Assign ( name ) ; userFieldFound = PR_TRUE ; break ; } } } } if ( ! userFieldFound && ! ( e -> userField ) . IsEmpty ( ) ) continue ; if ( ! ( e -> passField ) . IsEmpty ( ) ) { form -> ResolveName ( e -> passField , getter_AddRefs ( foundNode ) ) ; temp = do_QueryInterface ( foundNode ) ; } else if ( userField ) { nsCOMPtr < nsIFormControl > fc ( do_QueryInterface ( foundNode ) ) ; PRInt32 index = - 1 ; form -> IndexOfControl ( fc , & index ) ; if ( index >= 0 ) { PRUint32 count ; form -> GetElementCount ( & count ) ; PRUint32 i ; temp = nsnull ; nsCOMPtr < nsIFormControl > passField ; for ( i = index + 1 ; i < count ; ++ i ) { form -> GetElementAt ( i , getter_AddRefs ( passField ) ) ; if ( passField && passField -> GetType ( ) == NS_FORM_INPUT_PASSWORD ) { foundNode = passField ; temp = do_QueryInterface ( foundNode ) ; } } if ( ! temp && index != 0 ) { i = index ; do { form -> GetElementAt ( i , getter_AddRefs ( passField ) ) ; if ( passField && passField -> GetType ( ) == NS_FORM_INPUT_PASSWORD ) { foundNode = passField ; temp = do_QueryInterface ( foundNode ) ; } } while ( i -- != 0 ) ; } } } nsAutoString oldPassValue ; if ( temp ) { temp -> GetType ( fieldType ) ; if ( ! fieldType . Equals ( NS_LITERAL_STRING ( "password" ) ) ) continue ; temp -> GetValue ( oldPassValue ) ; passField = temp ; if ( ( e -> passField ) . IsEmpty ( ) ) passField -> GetName ( e -> passField ) ; } else { continue ; } if ( ! oldUserValue . IsEmpty ( ) && prefillForm ) { prefilledUser = PR_TRUE ; nsAutoString userValue ; if ( NS_FAILED ( DecryptData ( e -> userValue , userValue ) ) ) return NS_OK ; if ( userValue . Equals ( oldUserValue ) ) { nsAutoString passValue ; if ( NS_FAILED ( DecryptData ( e -> passValue , passValue ) ) ) return NS_OK ; passField -> SetValue ( passValue ) ; } } if ( firstMatch && userField && ! attachedToInput ) { AttachToInput ( userField ) ; attachedToInput = PR_TRUE ; } else { firstMatch = e ; } } if ( firstMatch && ! attachedToInput ) { if ( userField ) AttachToInput ( userField ) ; if ( ! prefilledUser && prefillForm ) { nsAutoString buffer ; if ( userField ) { if ( NS_FAILED ( DecryptData ( firstMatch -> userValue , buffer ) ) ) return NS_OK ; userField -> SetValue ( buffer ) ; } if ( NS_FAILED ( DecryptData ( firstMatch -> passValue , buffer ) ) ) return NS_OK ; passField -> SetValue ( buffer ) ; } } } return NS_OK ; }
asmlinkage int arm_syscall ( int no , struct pt_regs * regs ) { struct thread_info * thread = current_thread_info ( ) ; siginfo_t info ; if ( ( no > > 16 ) != ( __ARM_NR_BASE > > 16 ) ) return bad_syscall ( no , regs ) ; switch ( no & 0xffff ) { case 0 : info . si_signo = SIGSEGV ; info . si_errno = 0 ; info . si_code = SEGV_MAPERR ; info . si_addr = NULL ; arm_notify_die ( "branch through zero" , regs , & info , 0 , 0 ) ; return 0 ; case NR ( breakpoint ) : regs -> ARM_pc -= thumb_mode ( regs ) ? 2 : 4 ; ptrace_break ( current , regs ) ; return regs -> ARM_r0 ; case NR ( cacheflush ) : return do_cache_op ( regs -> ARM_r0 , regs -> ARM_r1 , regs -> ARM_r2 ) ; case NR ( usr26 ) : if ( ! ( elf_hwcap & HWCAP_26BIT ) ) break ; regs -> ARM_cpsr &= ~ MODE32_BIT ; return regs -> ARM_r0 ; case NR ( usr32 ) : if ( ! ( elf_hwcap & HWCAP_26BIT ) ) break ; regs -> ARM_cpsr |= MODE32_BIT ; return regs -> ARM_r0 ; case NR ( set_tls ) : thread -> tp_value = regs -> ARM_r0 ; if ( tls_emu ) return 0 ; if ( has_tls_reg ) { asm ( "mcr p15, 0, %0, c13, c0, 3" : : "r" ( regs -> ARM_r0 ) ) ; } else { * ( ( unsigned int * ) 0xffff0ff0 ) = regs -> ARM_r0 ; } return 0 ; #ifdef CONFIG_NEEDS_SYSCALL_FOR_CMPXCHG case NR ( cmpxchg ) : for ( ; ; ) { extern void do_DataAbort ( unsigned long addr , unsigned int fsr , struct pt_regs * regs ) ; unsigned long val ; unsigned long addr = regs -> ARM_r2 ; struct mm_struct * mm = current -> mm ; pgd_t * pgd ; pmd_t * pmd ; pte_t * pte ; spinlock_t * ptl ; regs -> ARM_cpsr &= ~ PSR_C_BIT ; down_read ( & mm -> mmap_sem ) ; pgd = pgd_offset ( mm , addr ) ; if ( ! pgd_present ( * pgd ) ) goto bad_access ; pmd = pmd_offset ( pgd , addr ) ; if ( ! pmd_present ( * pmd ) ) goto bad_access ; pte = pte_offset_map_lock ( mm , pmd , addr , & ptl ) ; if ( ! pte_present ( * pte ) || ! pte_write ( * pte ) || ! pte_dirty ( * pte ) ) { pte_unmap_unlock ( pte , ptl ) ; goto bad_access ; } val = * ( unsigned long * ) addr ; val -= regs -> ARM_r0 ; if ( val == 0 ) { * ( unsigned long * ) addr = regs -> ARM_r1 ; regs -> ARM_cpsr |= PSR_C_BIT ; } pte_unmap_unlock ( pte , ptl ) ; up_read ( & mm -> mmap_sem ) ; return val ; bad_access : up_read ( & mm -> mmap_sem ) ; do_DataAbort ( addr , 15 + ( 1 < < 11 ) , regs ) ; } #endif default : if ( ( no & 0xffff ) <= 0x7ff ) return - ENOSYS ; break ; } #ifdef CONFIG_DEBUG_USER if ( user_debug & UDBG_SYSCALL ) { printk ( "[%d] %s: arm syscall %d\n" , task_pid_nr ( current ) , current -> comm , no ) ; dump_instr ( "" , regs ) ; if ( user_mode ( regs ) ) { __show_regs ( regs ) ; c_backtrace ( regs -> ARM_fp , processor_mode ( regs ) ) ; } } #endif info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLTRP ; info . si_addr = ( void __user * ) instruction_pointer ( regs ) - ( thumb_mode ( regs ) ? 2 : 4 ) ; arm_notify_die ( "Oops - bad syscall(2)" , regs , & info , no , 0 ) ; return 0 ; }
TfLiteStatus ExpandTensorDim ( TfLiteContext * context , const TfLiteTensor & input , int axis , TfLiteTensor * output ) { const TfLiteIntArray & input_dims = * input . dims ; if ( axis < 0 ) { axis = input_dims . size + 1 + axis ; } TF_LITE_ENSURE ( context , axis <= input_dims . size ) ; TfLiteIntArray * output_dims = TfLiteIntArrayCreate ( input_dims . size + 1 ) ; for ( int i = 0 ; i < output_dims -> size ; ++ i ) { if ( i < axis ) { output_dims -> data [ i ] = input_dims . data [ i ] ; } else if ( i == axis ) { output_dims -> data [ i ] = 1 ; } else { output_dims -> data [ i ] = input_dims . data [ i - 1 ] ; } } return context -> ResizeTensor ( context , output , output_dims ) ; }
ModuleSQL :: ~ ModuleSQL ( ) { if ( Dispatcher ) { Dispatcher -> join ( ) ; Dispatcher -> OnNotify ( ) ; delete Dispatcher ; } for ( ConnMap :: iterator i = connections . begin ( ) ; i != connections . end ( ) ; i ++ ) { delete i -> second ; } }
static int pf_detect ( void ) { struct pf_unit * pf = units ; int k , unit ; printk ( "%s: %s version %s, major %d, cluster %d, nice %d\n" , name , name , PF_VERSION , major , cluster , nice ) ; par_drv = pi_register_driver ( name ) ; if ( ! par_drv ) { pr_err ( "failed to register %s driver\n" , name ) ; return - 1 ; } k = 0 ; if ( pf_drive_count == 0 ) { if ( pi_init ( pf -> pi , 1 , - 1 , - 1 , - 1 , - 1 , - 1 , pf_scratch , PI_PF , verbose , pf -> name ) ) { if ( ! pf_probe ( pf ) && pf -> disk ) { pf -> present = 1 ; k ++ ; } else pi_release ( pf -> pi ) ; } } else for ( unit = 0 ; unit < PF_UNITS ; unit ++ , pf ++ ) { int * conf = * drives [ unit ] ; if ( ! conf [ D_PRT ] ) continue ; if ( pi_init ( pf -> pi , 0 , conf [ D_PRT ] , conf [ D_MOD ] , conf [ D_UNI ] , conf [ D_PRO ] , conf [ D_DLY ] , pf_scratch , PI_PF , verbose , pf -> name ) ) { if ( pf -> disk && ! pf_probe ( pf ) ) { pf -> present = 1 ; k ++ ; } else pi_release ( pf -> pi ) ; } } if ( k ) return 0 ; printk ( "%s: No ATAPI disk detected\n" , name ) ; for ( pf = units , unit = 0 ; unit < PF_UNITS ; pf ++ , unit ++ ) { blk_cleanup_queue ( pf -> disk -> queue ) ; pf -> disk -> queue = NULL ; blk_mq_free_tag_set ( & pf -> tag_set ) ; put_disk ( pf -> disk ) ; } pi_unregister_driver ( par_drv ) ; return - 1 ; }
int ar6000_create_ap_interface ( struct ar6_softc * ar , char * ap_ifname ) { struct net_device * dev ; struct ar_virtual_interface * arApDev ; dev = alloc_etherdev ( sizeof ( struct ar_virtual_interface ) ) ; if ( dev == NULL ) { AR_DEBUG_PRINTF ( ATH_DEBUG_ERR , ( "ar6000_create_ap_interface: can't alloc etherdev\n" ) ) ; return A_ERROR ; } ether_setup ( dev ) ; init_netdev ( dev , ap_ifname ) ; if ( register_netdev ( dev ) ) { AR_DEBUG_PRINTF ( ATH_DEBUG_ERR , ( "ar6000_create_ap_interface: register_netdev failed\n" ) ) ; return A_ERROR ; } arApDev = netdev_priv ( dev ) ; arApDev -> arDev = ar ; arApDev -> arNetDev = dev ; arApDev -> arStaNetDev = ar -> arNetDev ; ar -> arApDev = arApDev ; arApNetDev = dev ; memcpy ( dev -> dev_addr , ar -> arNetDev -> dev_addr , AR6000_ETH_ADDR_LEN ) ; return 0 ; }
BytecodeGenerator :: IteratorRecord BytecodeGenerator :: BuildGetIteratorRecord ( Expression * iterable , Register next , Register object , IteratorType hint ) { DCHECK ( next . is_valid ( ) && object . is_valid ( ) ) ; BuildGetIterator ( iterable , hint ) ; builder ( ) -> StoreAccumulatorInRegister ( object ) . LoadNamedProperty ( object , ast_string_constants ( ) -> next_string ( ) , feedback_index ( feedback_spec ( ) -> AddLoadICSlot ( ) ) ) . StoreAccumulatorInRegister ( next ) ; return IteratorRecord ( object , next , hint ) ; }
static void php_wddx_push_element ( void * user_data , const XML_Char * name , const XML_Char * * atts ) { st_entry ent ; wddx_stack * stack = ( wddx_stack * ) user_data ; if ( ! strcmp ( name , EL_PACKET ) ) { int i ; if ( atts ) for ( i = 0 ; atts [ i ] ; i ++ ) { if ( ! strcmp ( atts [ i ] , EL_VERSION ) ) { } } } else if ( ! strcmp ( name , EL_STRING ) ) { ent . type = ST_STRING ; SET_STACK_VARNAME ; ALLOC_ZVAL ( ent . data ) ; INIT_PZVAL ( ent . data ) ; Z_TYPE_P ( ent . data ) = IS_STRING ; Z_STRVAL_P ( ent . data ) = STR_EMPTY_ALLOC ( ) ; Z_STRLEN_P ( ent . data ) = 0 ; wddx_stack_push ( ( wddx_stack * ) stack , & ent , sizeof ( st_entry ) ) ; } else if ( ! strcmp ( name , EL_BINARY ) ) { ent . type = ST_BINARY ; SET_STACK_VARNAME ; ALLOC_ZVAL ( ent . data ) ; INIT_PZVAL ( ent . data ) ; Z_TYPE_P ( ent . data ) = IS_STRING ; Z_STRVAL_P ( ent . data ) = STR_EMPTY_ALLOC ( ) ; Z_STRLEN_P ( ent . data ) = 0 ; wddx_stack_push ( ( wddx_stack * ) stack , & ent , sizeof ( st_entry ) ) ; } else if ( ! strcmp ( name , EL_CHAR ) ) { int i ; if ( atts ) for ( i = 0 ; atts [ i ] ; i ++ ) { if ( ! strcmp ( atts [ i ] , EL_CHAR_CODE ) && atts [ ++ i ] && atts [ i ] [ 0 ] ) { char tmp_buf [ 2 ] ; snprintf ( tmp_buf , sizeof ( tmp_buf ) , "%c" , ( char ) strtol ( atts [ i ] , NULL , 16 ) ) ; php_wddx_process_data ( user_data , tmp_buf , strlen ( tmp_buf ) ) ; break ; } } } else if ( ! strcmp ( name , EL_NUMBER ) ) { ent . type = ST_NUMBER ; SET_STACK_VARNAME ; ALLOC_ZVAL ( ent . data ) ; INIT_PZVAL ( ent . data ) ; Z_TYPE_P ( ent . data ) = IS_LONG ; Z_LVAL_P ( ent . data ) = 0 ; wddx_stack_push ( ( wddx_stack * ) stack , & ent , sizeof ( st_entry ) ) ; } else if ( ! strcmp ( name , EL_BOOLEAN ) ) { int i ; if ( atts ) for ( i = 0 ; atts [ i ] ; i ++ ) { if ( ! strcmp ( atts [ i ] , EL_VALUE ) && atts [ ++ i ] && atts [ i ] [ 0 ] ) { ent . type = ST_BOOLEAN ; SET_STACK_VARNAME ; ALLOC_ZVAL ( ent . data ) ; INIT_PZVAL ( ent . data ) ; Z_TYPE_P ( ent . data ) = IS_BOOL ; wddx_stack_push ( ( wddx_stack * ) stack , & ent , sizeof ( st_entry ) ) ; php_wddx_process_data ( user_data , atts [ i ] , strlen ( atts [ i ] ) ) ; break ; } } } else if ( ! strcmp ( name , EL_NULL ) ) { ent . type = ST_NULL ; SET_STACK_VARNAME ; ALLOC_ZVAL ( ent . data ) ; INIT_PZVAL ( ent . data ) ; ZVAL_NULL ( ent . data ) ; wddx_stack_push ( ( wddx_stack * ) stack , & ent , sizeof ( st_entry ) ) ; } else if ( ! strcmp ( name , EL_ARRAY ) ) { ent . type = ST_ARRAY ; SET_STACK_VARNAME ; ALLOC_ZVAL ( ent . data ) ; array_init ( ent . data ) ; INIT_PZVAL ( ent . data ) ; wddx_stack_push ( ( wddx_stack * ) stack , & ent , sizeof ( st_entry ) ) ; } else if ( ! strcmp ( name , EL_STRUCT ) ) { ent . type = ST_STRUCT ; SET_STACK_VARNAME ; ALLOC_ZVAL ( ent . data ) ; array_init ( ent . data ) ; INIT_PZVAL ( ent . data ) ; wddx_stack_push ( ( wddx_stack * ) stack , & ent , sizeof ( st_entry ) ) ; } else if ( ! strcmp ( name , EL_VAR ) ) { int i ; if ( atts ) for ( i = 0 ; atts [ i ] ; i ++ ) { if ( ! strcmp ( atts [ i ] , EL_NAME ) && atts [ ++ i ] && atts [ i ] [ 0 ] ) { if ( stack -> varname ) efree ( stack -> varname ) ; stack -> varname = estrdup ( atts [ i ] ) ; break ; } } } else if ( ! strcmp ( name , EL_RECORDSET ) ) { int i ; ent . type = ST_RECORDSET ; SET_STACK_VARNAME ; MAKE_STD_ZVAL ( ent . data ) ; array_init ( ent . data ) ; if ( atts ) for ( i = 0 ; atts [ i ] ; i ++ ) { if ( ! strcmp ( atts [ i ] , "fieldNames" ) && atts [ ++ i ] && atts [ i ] [ 0 ] ) { zval * tmp ; char * key ; char * p1 , * p2 , * endp ; endp = ( char * ) atts [ i ] + strlen ( atts [ i ] ) ; p1 = ( char * ) atts [ i ] ; while ( ( p2 = php_memnstr ( p1 , "," , sizeof ( "," ) - 1 , endp ) ) != NULL ) { key = estrndup ( p1 , p2 - p1 ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( ent . data , key , p2 - p1 + 1 , tmp ) ; p1 = p2 + sizeof ( "," ) - 1 ; efree ( key ) ; } if ( p1 <= endp ) { MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( ent . data , p1 , endp - p1 + 1 , tmp ) ; } break ; } } wddx_stack_push ( ( wddx_stack * ) stack , & ent , sizeof ( st_entry ) ) ; } else if ( ! strcmp ( name , EL_FIELD ) ) { int i ; st_entry ent ; ent . type = ST_FIELD ; ent . varname = NULL ; ent . data = NULL ; if ( atts ) for ( i = 0 ; atts [ i ] ; i ++ ) { if ( ! strcmp ( atts [ i ] , EL_NAME ) && atts [ ++ i ] && atts [ i ] [ 0 ] ) { st_entry * recordset ; zval * * field ; if ( wddx_stack_top ( stack , ( void * * ) & recordset ) == SUCCESS && recordset -> type == ST_RECORDSET && zend_hash_find ( Z_ARRVAL_P ( recordset -> data ) , ( char * ) atts [ i ] , strlen ( atts [ i ] ) + 1 , ( void * * ) & field ) == SUCCESS ) { ent . data = * field ; } break ; } } wddx_stack_push ( ( wddx_stack * ) stack , & ent , sizeof ( st_entry ) ) ; } else if ( ! strcmp ( name , EL_DATETIME ) ) { ent . type = ST_DATETIME ; SET_STACK_VARNAME ; ALLOC_ZVAL ( ent . data ) ; INIT_PZVAL ( ent . data ) ; Z_TYPE_P ( ent . data ) = IS_LONG ; wddx_stack_push ( ( wddx_stack * ) stack , & ent , sizeof ( st_entry ) ) ; } }
JSCompartment :: clearTables ( ) { global_ = nullptr ; regExps . clearTables ( ) ; JS_ASSERT ( crossCompartmentWrappers . empty ( ) ) ; JS_ASSERT_IF ( callsiteClones . initialized ( ) , callsiteClones . empty ( ) ) ; #ifdef JS_ION JS_ASSERT ( ! jitCompartment_ ) ; #endif JS_ASSERT ( ! debugScopes ) ; JS_ASSERT ( ! gcWeakMapList ) ; JS_ASSERT ( enumerators -> next ( ) == enumerators ) ; if ( baseShapes . initialized ( ) ) baseShapes . clear ( ) ; if ( initialShapes . initialized ( ) ) initialShapes . clear ( ) ; if ( newTypeObjects . initialized ( ) ) newTypeObjects . clear ( ) ; if ( lazyTypeObjects . initialized ( ) ) lazyTypeObjects . clear ( ) ; if ( savedStacks_ . initialized ( ) ) savedStacks_ . clear ( ) ; }
void convolve4RowsHorizontally_SSE2 ( const unsigned char * src_data [ 4 ] , const SkConvolutionFilter1D & filter , unsigned char * out_row [ 4 ] , size_t outRowBytes ) { SkDEBUGCODE ( const unsigned char * out_row_0_start = out_row [ 0 ] ; ) int num_values = filter . numValues ( ) ; int filter_offset , filter_length ; __m128i zero = _mm_setzero_si128 ( ) ; __m128i mask [ 4 ] ; mask [ 1 ] = _mm_set_epi16 ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , - 1 ) ; mask [ 2 ] = _mm_set_epi16 ( 0 , 0 , 0 , 0 , 0 , 0 , - 1 , - 1 ) ; mask [ 3 ] = _mm_set_epi16 ( 0 , 0 , 0 , 0 , 0 , - 1 , - 1 , - 1 ) ; for ( int out_x = 0 ; out_x < num_values ; out_x ++ ) { const SkConvolutionFilter1D :: ConvolutionFixed * filter_values = filter . FilterForValue ( out_x , & filter_offset , & filter_length ) ; __m128i accum0 = _mm_setzero_si128 ( ) ; __m128i accum1 = _mm_setzero_si128 ( ) ; __m128i accum2 = _mm_setzero_si128 ( ) ; __m128i accum3 = _mm_setzero_si128 ( ) ; int start = ( filter_offset < < 2 ) ; for ( int filter_x = 0 ; filter_x < ( filter_length > > 2 ) ; filter_x ++ ) { __m128i coeff , coeff16lo , coeff16hi ; coeff = _mm_loadl_epi64 ( reinterpret_cast < const __m128i * > ( filter_values ) ) ; coeff16lo = _mm_shufflelo_epi16 ( coeff , _MM_SHUFFLE ( 1 , 1 , 0 , 0 ) ) ; coeff16lo = _mm_unpacklo_epi16 ( coeff16lo , coeff16lo ) ; coeff16hi = _mm_shufflelo_epi16 ( coeff , _MM_SHUFFLE ( 3 , 3 , 2 , 2 ) ) ; coeff16hi = _mm_unpacklo_epi16 ( coeff16hi , coeff16hi ) ; __m128i src8 , src16 , mul_hi , mul_lo , t ; #define ITERATION(src, accum)                                                \             src8 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(src));   \             src16 = _mm_unpacklo_epi8(src8, zero);                           \             mul_hi = _mm_mulhi_epi16(src16, coeff16lo);                      \             mul_lo = _mm_mullo_epi16(src16, coeff16lo);                      \             t = _mm_unpacklo_epi16(mul_lo, mul_hi);                          \             accum = _mm_add_epi32(accum, t);                                 \             t = _mm_unpackhi_epi16(mul_lo, mul_hi);                          \             accum = _mm_add_epi32(accum, t);                                 \             src16 = _mm_unpackhi_epi8(src8, zero);                           \             mul_hi = _mm_mulhi_epi16(src16, coeff16hi);                      \             mul_lo = _mm_mullo_epi16(src16, coeff16hi);                      \             t = _mm_unpacklo_epi16(mul_lo, mul_hi);                          \             accum = _mm_add_epi32(accum, t);                                 \             t = _mm_unpackhi_epi16(mul_lo, mul_hi);                          \             accum = _mm_add_epi32(accum, t) ITERATION ( src_data [ 0 ] + start , accum0 ) ; ITERATION ( src_data [ 1 ] + start , accum1 ) ; ITERATION ( src_data [ 2 ] + start , accum2 ) ; ITERATION ( src_data [ 3 ] + start , accum3 ) ; start += 16 ; filter_values += 4 ; } int r = filter_length & 3 ; if ( r ) { __m128i coeff ; coeff = _mm_loadl_epi64 ( reinterpret_cast < const __m128i * > ( filter_values ) ) ; coeff = _mm_and_si128 ( coeff , mask [ r ] ) ; __m128i coeff16lo = _mm_shufflelo_epi16 ( coeff , _MM_SHUFFLE ( 1 , 1 , 0 , 0 ) ) ; coeff16lo = _mm_unpacklo_epi16 ( coeff16lo , coeff16lo ) ; __m128i coeff16hi = _mm_shufflelo_epi16 ( coeff , _MM_SHUFFLE ( 3 , 3 , 2 , 2 ) ) ; coeff16hi = _mm_unpacklo_epi16 ( coeff16hi , coeff16hi ) ; __m128i src8 , src16 , mul_hi , mul_lo , t ; ITERATION ( src_data [ 0 ] + start , accum0 ) ; ITERATION ( src_data [ 1 ] + start , accum1 ) ; ITERATION ( src_data [ 2 ] + start , accum2 ) ; ITERATION ( src_data [ 3 ] + start , accum3 ) ; } accum0 = _mm_srai_epi32 ( accum0 , SkConvolutionFilter1D :: kShiftBits ) ; accum0 = _mm_packs_epi32 ( accum0 , zero ) ; accum0 = _mm_packus_epi16 ( accum0 , zero ) ; accum1 = _mm_srai_epi32 ( accum1 , SkConvolutionFilter1D :: kShiftBits ) ; accum1 = _mm_packs_epi32 ( accum1 , zero ) ; accum1 = _mm_packus_epi16 ( accum1 , zero ) ; accum2 = _mm_srai_epi32 ( accum2 , SkConvolutionFilter1D :: kShiftBits ) ; accum2 = _mm_packs_epi32 ( accum2 , zero ) ; accum2 = _mm_packus_epi16 ( accum2 , zero ) ; accum3 = _mm_srai_epi32 ( accum3 , SkConvolutionFilter1D :: kShiftBits ) ; accum3 = _mm_packs_epi32 ( accum3 , zero ) ; accum3 = _mm_packus_epi16 ( accum3 , zero ) ; SkASSERT ( ( ( size_t ) out_row [ 0 ] - ( size_t ) out_row_0_start ) < outRowBytes ) ; * ( reinterpret_cast < int * > ( out_row [ 0 ] ) ) = _mm_cvtsi128_si32 ( accum0 ) ; * ( reinterpret_cast < int * > ( out_row [ 1 ] ) ) = _mm_cvtsi128_si32 ( accum1 ) ; * ( reinterpret_cast < int * > ( out_row [ 2 ] ) ) = _mm_cvtsi128_si32 ( accum2 ) ; * ( reinterpret_cast < int * > ( out_row [ 3 ] ) ) = _mm_cvtsi128_si32 ( accum3 ) ; out_row [ 0 ] += 4 ; out_row [ 1 ] += 4 ; out_row [ 2 ] += 4 ; out_row [ 3 ] += 4 ; } }
static int sched_read_attr ( struct sched_attr __user * uattr , struct sched_attr * attr , unsigned int usize ) { int ret ; if ( ! access_ok ( VERIFY_WRITE , uattr , usize ) ) return - EFAULT ; if ( usize < sizeof ( * attr ) ) { unsigned char * addr ; unsigned char * end ; addr = ( void * ) attr + usize ; end = ( void * ) attr + sizeof ( * attr ) ; for ( ; addr < end ; addr ++ ) { if ( * addr ) goto err_size ; } attr -> size = usize ; } ret = copy_to_user ( uattr , attr , usize ) ; if ( ret ) return - EFAULT ; out : return ret ; err_size : ret = - E2BIG ; goto out ; }
kg_unseal ( minor_status , context_handle , input_token_buffer , message_buffer , conf_state , qop_state , toktype ) OM_uint32 * minor_status ; gss_ctx_id_t context_handle ; gss_buffer_t input_token_buffer ; gss_buffer_t message_buffer ; int * conf_state ; gss_qop_t * qop_state ; int toktype ; { krb5_gss_ctx_id_rec * ctx ; unsigned char * ptr ; unsigned int bodysize ; int err ; int toktype2 ; int vfyflags = 0 ; OM_uint32 ret ; ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; if ( ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return ( GSS_S_NO_CONTEXT ) ; } ptr = ( unsigned char * ) input_token_buffer -> value ; err = g_verify_token_header ( ctx -> mech_used , & bodysize , & ptr , - 1 , input_token_buffer -> length , vfyflags ) ; if ( err ) { * minor_status = err ; return GSS_S_DEFECTIVE_TOKEN ; } if ( bodysize < 2 ) { * minor_status = ( OM_uint32 ) G_BAD_TOK_HEADER ; return GSS_S_DEFECTIVE_TOKEN ; } toktype2 = load_16_be ( ptr ) ; ptr += 2 ; bodysize -= 2 ; switch ( toktype2 ) { case KG2_TOK_MIC_MSG : case KG2_TOK_WRAP_MSG : case KG2_TOK_DEL_CTX : ret = gss_krb5int_unseal_token_v3 ( & ctx -> k5_context , minor_status , ctx , ptr , bodysize , message_buffer , conf_state , qop_state , toktype ) ; break ; case KG_TOK_MIC_MSG : case KG_TOK_WRAP_MSG : case KG_TOK_DEL_CTX : ret = kg_unseal_v1 ( ctx -> k5_context , minor_status , ctx , ptr , bodysize , message_buffer , conf_state , qop_state , toktype ) ; break ; default : * minor_status = ( OM_uint32 ) G_BAD_TOK_HEADER ; ret = GSS_S_DEFECTIVE_TOKEN ; break ; } if ( ret != 0 ) save_error_info ( * minor_status , ctx -> k5_context ) ; return ret ; }
char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = gf_fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] > > 6 ) & 0x3 ) ; j ++ ; szLine [ i ] &= 0xbf ; } else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf8 ) == 0xf0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { i += 1 ; continue ; } } szLineConv [ j ] = szLine [ i ] ; j ++ ; } szLineConv [ j ] = 0 ; strcpy ( szLine , szLineConv ) ; return sOK ; } #ifdef GPAC_BIG_ENDIAN if ( unicode_type == 3 ) #else if ( unicode_type == 2 ) #endif { i = 0 ; while ( 1 ) { char c ; if ( ! szLine [ i ] && ! szLine [ i + 1 ] ) break ; c = szLine [ i + 1 ] ; szLine [ i + 1 ] = szLine [ i ] ; szLine [ i ] = c ; i += 2 ; } } sptr = ( u16 * ) szLine ; i = ( u32 ) gf_utf8_wcstombs ( szLineConv , 1024 , ( const unsigned short * * ) & sptr ) ; szLineConv [ i ] = 0 ; strcpy ( szLine , szLineConv ) ; if ( unicode_type == 3 ) gf_fgetc ( txt_in ) ; return sOK ; }
nsGenericHTMLElement :: GetItemValue ( JSContext * aCx , JSObject * aScope , ErrorResult & aError ) { JS :: Rooted < JSObject * > scope ( aCx , aScope ) ; if ( ! HasAttr ( kNameSpaceID_None , nsGkAtoms :: itemprop ) ) { return JS :: NullValue ( ) ; } if ( ItemScope ( ) ) { JS :: Rooted < JS :: Value > v ( aCx ) ; JSAutoCompartment ac ( aCx , scope ) ; if ( ! mozilla :: dom :: WrapObject ( aCx , this , & v ) ) { aError . Throw ( NS_ERROR_FAILURE ) ; return JS :: UndefinedValue ( ) ; } return v ; } nsString string ; GetItemValueText ( string ) ; JS :: Rooted < JS :: Value > v ( aCx ) ; if ( ! xpc :: NonVoidStringToJsval ( aCx , string , & v ) ) { aError . Throw ( NS_ERROR_FAILURE ) ; return JS :: UndefinedValue ( ) ; } return v ; }
Symbol :: newInternal ( ExclusiveContext * cx , JS :: SymbolCode code , JSAtom * description , AutoLockForExclusiveAccess & lock ) { MOZ_ASSERT ( cx -> compartment ( ) == cx -> atomsCompartment ( lock ) ) ; Symbol * p = Allocate < JS :: Symbol , NoGC > ( cx ) ; if ( ! p ) { ReportOutOfMemory ( cx ) ; return nullptr ; } return new ( p ) Symbol ( code , description ) ; }
void V8Debugger :: externalAsyncTaskStarted ( const V8StackTraceId & parent ) { if ( ! m_maxAsyncCallStackDepth || parent . IsInvalid ( ) ) return ; m_currentExternalParent . push_back ( parent ) ; m_currentAsyncParent . emplace_back ( ) ; m_currentTasks . push_back ( reinterpret_cast < void * > ( parent . id ) ) ; if ( m_breakRequested ) return ; if ( ! m_taskWithScheduledBreakDebuggerId . isEmpty ( ) && reinterpret_cast < uintptr_t > ( m_taskWithScheduledBreak ) == parent . id && m_taskWithScheduledBreakDebuggerId == debuggerIdToString ( parent . debugger_id ) ) { v8 :: debug :: SetBreakOnNextFunctionCall ( m_isolate ) ; } }
void Transform :: interpolate_bilinear ( RawTile & in , unsigned int resampled_width , unsigned int resampled_height ) { unsigned char * input = ( unsigned char * ) in . data ; int channels = in . channels ; unsigned int width = in . width ; unsigned int height = in . height ; unsigned long max = ( ( width * height ) - 1 ) * channels ; unsigned char * output = new unsigned char [ ( unsigned long long ) resampled_width * resampled_height * channels ] ; float xscale = ( float ) ( width ) / ( float ) resampled_width ; float yscale = ( float ) ( height ) / ( float ) resampled_height ; #if defined(__ICC) || defined(__INTEL_COMPILER) #pragma ivdep #elif defined(_OPENMP) #pragma omp parallel for if( resampled_width*resampled_height > PARALLEL_THRESHOLD ) #endif for ( unsigned int j = 0 ; j < resampled_height ; j ++ ) { int jj = ( int ) floor ( j * yscale ) ; float jscale = j * yscale ; float c = ( float ) ( jj + 1 ) - jscale ; float d = jscale - ( float ) jj ; for ( unsigned int i = 0 ; i < resampled_width ; i ++ ) { int ii = ( int ) floor ( i * xscale ) ; unsigned long p11 , p12 , p21 , p22 ; unsigned long jj_w = jj * width ; p11 = ( unsigned long ) ( channels * ( ii + jj_w ) ) ; p12 = ( unsigned long ) ( channels * ( ii + ( jj_w + width ) ) ) ; p21 = ( unsigned long ) ( channels * ( ( ii + 1 ) + jj_w ) ) ; p22 = ( unsigned long ) ( channels * ( ( ii + 1 ) + ( jj_w + width ) ) ) ; p12 = ( p12 <= max ) ? p12 : max ; p21 = ( p21 <= max ) ? p21 : max ; p22 = ( p22 <= max ) ? p22 : max ; float iscale = i * xscale ; float a = ( float ) ( ii + 1 ) - iscale ; float b = iscale - ( float ) ii ; unsigned long long resampled_index = ( unsigned long long ) ( ( j * resampled_width + i ) * channels ) ; for ( int k = 0 ; k < channels ; k ++ ) { float tx = input [ p11 + k ] * a + input [ p21 + k ] * b ; float ty = input [ p12 + k ] * a + input [ p22 + k ] * b ; unsigned char r = ( unsigned char ) ( c * tx + d * ty ) ; output [ resampled_index + k ] = r ; } } } delete [ ] ( unsigned char * ) input ; in . width = resampled_width ; in . height = resampled_height ; in . dataLength = resampled_width * resampled_height * channels * ( in . bpc / 8 ) ; in . data = output ; }
int SoundPool :: play ( int sampleID , float leftVolume , float rightVolume , int priority , int loop , float rate ) { ALOGV ( "play sampleID=%d, leftVolume=%f, rightVolume=%f, priority=%d, loop=%d, rate=%f" , sampleID , leftVolume , rightVolume , priority , loop , rate ) ; sp < Sample > sample ; SoundChannel * channel ; int channelID ; Mutex :: Autolock lock ( & mLock ) ; if ( mQuit ) { return 0 ; } sample = findSample ( sampleID ) ; if ( ( sample == 0 ) || ( sample -> state ( ) != Sample :: READY ) ) { ALOGW ( "  sample %d not READY" , sampleID ) ; return 0 ; } dump ( ) ; channel = allocateChannel_l ( priority ) ; if ( ! channel ) { ALOGV ( "No channel allocated" ) ; return 0 ; } channelID = ++ mNextChannelID ; ALOGV ( "play channel %p state = %d" , channel , channel -> state ( ) ) ; channel -> play ( sample , channelID , leftVolume , rightVolume , priority , loop , rate ) ; return channelID ; }
void LeaveArgumentsAdaptorFrame ( MacroAssembler * masm ) { __ Ldr ( x10 , MemOperand ( fp , ArgumentsAdaptorFrameConstants :: kLengthOffset ) ) ; __ Mov ( sp , fp ) ; __ Pop ( fp , lr ) ; __ SmiUntag ( x10 ) ; __ DropArguments ( x10 , TurboAssembler :: kCountExcludesReceiver ) ; }
void BytecodeGraphBuilder :: VisitStaKeyedProperty ( ) { PrepareEagerCheckpoint ( ) ; Node * value = environment ( ) -> LookupAccumulator ( ) ; Node * object = environment ( ) -> LookupRegister ( bytecode_iterator ( ) . GetRegisterOperand ( 0 ) ) ; Node * key = environment ( ) -> LookupRegister ( bytecode_iterator ( ) . GetRegisterOperand ( 1 ) ) ; VectorSlotPair feedback = CreateVectorSlotPair ( bytecode_iterator ( ) . GetIndexOperand ( 2 ) ) ; LanguageMode language_mode = feedback . vector ( ) -> GetLanguageMode ( feedback . slot ( ) ) ; const Operator * op = javascript ( ) -> StoreProperty ( language_mode , feedback ) ; JSTypeHintLowering :: LoweringResult lowering = TryBuildSimplifiedStoreKeyed ( op , object , key , value , feedback . slot ( ) ) ; if ( lowering . IsExit ( ) ) return ; Node * node = nullptr ; if ( lowering . IsSideEffectFree ( ) ) { node = lowering . value ( ) ; } else { DCHECK ( ! lowering . Changed ( ) ) ; node = NewNode ( op , object , key , value ) ; } environment ( ) -> RecordAfterState ( node , Environment :: kAttachFrameState ) ; }
NS_IMETHOD Run ( ) override { if ( mNumber -> AsElement ( ) -> State ( ) . HasState ( NS_EVENT_STATE_FOCUS ) ) { FocusOptions options ; HTMLInputElement :: FromNode ( mTextField ) -> Focus ( options , IgnoreErrors ( ) ) ; } return NS_OK ; }
Node * EffectControlLinearizer :: LowerFindOrderedHashMapEntry ( Node * node ) { Node * table = NodeProperties :: GetValueInput ( node , 0 ) ; Node * key = NodeProperties :: GetValueInput ( node , 1 ) ; { Callable const callable = Builtins :: CallableFor ( isolate ( ) , Builtins :: kFindOrderedHashMapEntry ) ; Operator :: Properties const properties = node -> op ( ) -> properties ( ) ; CallDescriptor :: Flags const flags = CallDescriptor :: kNoFlags ; auto call_descriptor = Linkage :: GetStubCallDescriptor ( graph ( ) -> zone ( ) , callable . descriptor ( ) , 0 , flags , properties ) ; return __ Call ( call_descriptor , __ HeapConstant ( callable . code ( ) ) , table , key , __ NoContextConstant ( ) ) ; } }
gss_wrap_size_limit ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int conf_req_flag , gss_qop_t qop_req , OM_uint32 req_output_size , OM_uint32 * max_input_size ) { gss_union_ctx_id_t ctx ; gss_mechanism mech ; OM_uint32 major_status ; if ( minor_status == NULL ) return ( GSS_S_CALL_INACCESSIBLE_WRITE ) ; * minor_status = 0 ; if ( context_handle == GSS_C_NO_CONTEXT ) return ( GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT ) ; if ( max_input_size == NULL ) return ( GSS_S_CALL_INACCESSIBLE_WRITE ) ; ctx = ( gss_union_ctx_id_t ) context_handle ; mech = gssint_get_mechanism ( ctx -> mech_type ) ; if ( ! mech ) return ( GSS_S_BAD_MECH ) ; if ( mech -> gss_wrap_size_limit ) major_status = mech -> gss_wrap_size_limit ( minor_status , ctx -> internal_ctx_id , conf_req_flag , qop_req , req_output_size , max_input_size ) ; else if ( mech -> gss_wrap_iov_length ) major_status = gssint_wrap_size_limit_iov_shim ( mech , minor_status , ctx -> internal_ctx_id , conf_req_flag , qop_req , req_output_size , max_input_size ) ; else major_status = GSS_S_UNAVAILABLE ; if ( major_status != GSS_S_COMPLETE ) map_error ( minor_status , mech ) ; return major_status ; }
sctp_abort_an_association ( struct sctp_inpcb * inp , struct sctp_tcb * stcb , struct mbuf * op_err , int so_locked #if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING) SCTP_UNUSED #endif ) { #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING) struct socket * so ; #endif #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING) so = SCTP_INP_SO ( inp ) ; #endif #if defined(__APPLE__) if ( so_locked ) { sctp_lock_assert ( SCTP_INP_SO ( inp ) ) ; } else { sctp_unlock_assert ( SCTP_INP_SO ( inp ) ) ; } #endif if ( stcb == NULL ) { if ( inp -> sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE ) { if ( LIST_EMPTY ( & inp -> sctp_asoc_list ) ) { #if defined(__APPLE__) if ( ! so_locked ) { SCTP_SOCKET_LOCK ( so , 1 ) ; } #endif sctp_inpcb_free ( inp , SCTP_FREE_SHOULD_USE_ABORT , SCTP_CALLED_DIRECTLY_NOCMPSET ) ; #if defined(__APPLE__) if ( ! so_locked ) { SCTP_SOCKET_UNLOCK ( so , 1 ) ; } #endif } } return ; } else { stcb -> asoc . state |= SCTP_STATE_WAS_ABORTED ; } if ( ( inp -> sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE ) == 0 ) { sctp_abort_notification ( stcb , 0 , 0 , NULL , so_locked ) ; } sctp_send_abort_tcb ( stcb , op_err , so_locked ) ; SCTP_STAT_INCR_COUNTER32 ( sctps_aborted ) ; if ( ( SCTP_GET_STATE ( & stcb -> asoc ) == SCTP_STATE_OPEN ) || ( SCTP_GET_STATE ( & stcb -> asoc ) == SCTP_STATE_SHUTDOWN_RECEIVED ) ) { SCTP_STAT_DECR_GAUGE32 ( sctps_currestab ) ; } #ifdef SCTP_ASOCLOG_OF_TSNS sctp_print_out_track_log ( stcb ) ; #endif #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING) if ( ! so_locked ) { atomic_add_int ( & stcb -> asoc . refcnt , 1 ) ; SCTP_TCB_UNLOCK ( stcb ) ; SCTP_SOCKET_LOCK ( so , 1 ) ; SCTP_TCB_LOCK ( stcb ) ; atomic_subtract_int ( & stcb -> asoc . refcnt , 1 ) ; } #endif ( void ) sctp_free_assoc ( inp , stcb , SCTP_NORMAL_PROC , SCTP_FROM_SCTPUTIL + SCTP_LOC_5 ) ; #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING) if ( ! so_locked ) { SCTP_SOCKET_UNLOCK ( so , 1 ) ; } #endif }
char IC :: TransitionMarkFromState ( IC :: State state ) { switch ( state ) { case UNINITIALIZED : return '0' ; case PREMONOMORPHIC : return '.' ; case MONOMORPHIC : return '1' ; case RECOMPUTE_HANDLER : return '^' ; case POLYMORPHIC : return 'P' ; case MEGAMORPHIC : return 'N' ; case GENERIC : return 'G' ; } UNREACHABLE ( ) ; }
void CallCFunction1WithCallerSavedRegistersMode ( MachineType return_type , MachineType arg0_type , Node * function , Node * arg0 , Node * mode , Label * next ) { Label dont_save_fp ( this ) , save_fp ( this ) ; Branch ( ShouldSkipFPRegs ( mode ) , & dont_save_fp , & save_fp ) ; BIND ( & dont_save_fp ) ; { CallCFunction1WithCallerSavedRegisters ( return_type , arg0_type , function , arg0 , kDontSaveFPRegs ) ; Goto ( next ) ; } BIND ( & save_fp ) ; { CallCFunction1WithCallerSavedRegisters ( return_type , arg0_type , function , arg0 , kSaveFPRegs ) ; Goto ( next ) ; } }
nfssvc_decode_readlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readlinkargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; return xdr_argsize_check ( rqstp , p ) ; }
const char * Interpreter :: LookupNameOfBytecodeHandler ( const Code * code ) { #ifdef ENABLE_DISASSEMBLER #define RETURN_NAME(Name, ...)                                 \  if (dispatch_table_[Bytecodes::ToByte(Bytecode::k##Name)] == \       code->entry()) {                                         \  return #Name;                                              \  } BYTECODE_LIST ( RETURN_NAME ) #undef RETURN_NAME #endif // ENABLE_DISASSEMBLER return nullptr ; }
bool OrderedHashTable < Derived , entrysize > :: HasKey ( Isolate * isolate , Derived * table , Object * key ) { DCHECK ( ( entrysize == 1 && table -> IsOrderedHashSet ( ) ) || ( entrysize == 2 && table -> IsOrderedHashMap ( ) ) ) ; DisallowHeapAllocation no_gc ; int entry = table -> FindEntry ( isolate , key ) ; return entry != kNotFound ; }
base :: Optional < ParseResult > MakeDebugStatement ( ParseResultIterator * child_results ) { auto kind = child_results -> NextAs < std :: string > ( ) ; DCHECK ( kind == "unreachable" || kind == "debug" ) ; Statement * result = MakeNode < DebugStatement > ( kind , kind == "unreachable" ) ; return ParseResult { result } ; }
irc_mode_channel_update ( struct t_irc_server * server , struct t_irc_channel * channel , char set_flag , char chanmode , const char * argument ) { char * pos_args , * str_modes , * * argv , * pos , * ptr_arg ; char * new_modes , * new_args , str_mode [ 2 ] , * str_temp ; int argc , current_arg , chanmode_found , length ; if ( ! channel -> modes ) channel -> modes = strdup ( "+" ) ; if ( ! channel -> modes ) return ; argc = 0 ; argv = NULL ; pos_args = strchr ( channel -> modes , ' ' ) ; if ( pos_args ) { str_modes = weechat_strndup ( channel -> modes , pos_args - channel -> modes ) ; if ( ! str_modes ) return ; pos_args ++ ; while ( pos_args [ 0 ] == ' ' ) pos_args ++ ; argv = weechat_string_split ( pos_args , " " , NULL , WEECHAT_STRING_SPLIT_STRIP_LEFT | WEECHAT_STRING_SPLIT_STRIP_RIGHT | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS , 0 , & argc ) ; } else { str_modes = strdup ( channel -> modes ) ; if ( ! str_modes ) return ; } new_modes = malloc ( strlen ( channel -> modes ) + 1 + 1 ) ; new_args = malloc ( ( ( pos_args ) ? strlen ( pos_args ) : 0 ) + ( ( argument ) ? 1 + strlen ( argument ) : 0 ) + 1 ) ; if ( new_modes && new_args ) { new_modes [ 0 ] = '\0' ; new_args [ 0 ] = '\0' ; current_arg = 0 ; chanmode_found = 0 ; pos = str_modes ; while ( pos && pos [ 0 ] ) { if ( ( pos [ 0 ] == '+' ) || ( pos [ 0 ] == '-' ) ) { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\0' ; strcat ( new_modes , str_mode ) ; } else { ptr_arg = NULL ; switch ( irc_mode_get_chanmode_type ( server , pos [ 0 ] ) ) { case 'A' : case 'B' : case 'C' : ptr_arg = ( current_arg < argc ) ? argv [ current_arg ] : NULL ; break ; case 'D' : break ; } if ( ptr_arg ) current_arg ++ ; if ( pos [ 0 ] == chanmode ) { chanmode_found = 1 ; if ( set_flag == '+' ) { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\0' ; strcat ( new_modes , str_mode ) ; if ( argument ) { if ( new_args [ 0 ] ) strcat ( new_args , " " ) ; strcat ( new_args , argument ) ; } } } else { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\0' ; strcat ( new_modes , str_mode ) ; if ( ptr_arg ) { if ( new_args [ 0 ] ) strcat ( new_args , " " ) ; strcat ( new_args , ptr_arg ) ; } } } pos ++ ; } if ( ! chanmode_found ) { if ( set_flag == '+' ) { if ( argument ) { str_mode [ 0 ] = chanmode ; str_mode [ 1 ] = '\0' ; strcat ( new_modes , str_mode ) ; if ( new_args [ 0 ] ) strcat ( new_args , " " ) ; strcat ( new_args , argument ) ; } else { pos = new_modes ; while ( pos [ 0 ] == '+' ) pos ++ ; memmove ( pos + 1 , pos , strlen ( pos ) + 1 ) ; pos [ 0 ] = chanmode ; } } } if ( new_args [ 0 ] ) { length = strlen ( new_modes ) + 1 + strlen ( new_args ) + 1 ; str_temp = malloc ( length ) ; if ( str_temp ) { snprintf ( str_temp , length , "%s %s" , new_modes , new_args ) ; if ( channel -> modes ) free ( channel -> modes ) ; channel -> modes = str_temp ; } } else { if ( channel -> modes ) free ( channel -> modes ) ; channel -> modes = strdup ( new_modes ) ; } } if ( new_modes ) free ( new_modes ) ; if ( new_args ) free ( new_args ) ; if ( str_modes ) free ( str_modes ) ; if ( argv ) weechat_string_free_split ( argv ) ; }
FilterNodeTileSoftware :: Render ( const IntRect & aRect ) { if ( mSourceRect . IsEmpty ( ) ) { return nullptr ; } if ( mSourceRect . Contains ( aRect ) ) { return GetInputDataSourceSurface ( IN_TILE_IN , aRect ) ; } RefPtr < DataSourceSurface > target ; typedef std :: map < IntRect , RefPtr < DataSourceSurface > , CompareIntRects > InputMap ; InputMap inputs ; IntPoint startIndex = TileIndex ( mSourceRect , aRect . TopLeft ( ) ) ; IntPoint endIndex = TileIndex ( mSourceRect , aRect . BottomRight ( ) ) ; for ( int32_t ix = startIndex . x ; ix <= endIndex . x ; ix ++ ) { for ( int32_t iy = startIndex . y ; iy <= endIndex . y ; iy ++ ) { IntPoint sourceToDestOffset ( ix * mSourceRect . width , iy * mSourceRect . height ) ; IntRect destRect = aRect . Intersect ( mSourceRect + sourceToDestOffset ) ; IntRect srcRect = destRect - sourceToDestOffset ; if ( srcRect . IsEmpty ( ) ) { continue ; } RefPtr < DataSourceSurface > input ; InputMap :: iterator it = inputs . find ( srcRect ) ; if ( it == inputs . end ( ) ) { input = GetInputDataSourceSurface ( IN_TILE_IN , srcRect ) ; inputs [ srcRect ] = input ; } else { input = it -> second ; } if ( ! input ) { return nullptr ; } if ( ! target ) { target = Factory :: CreateDataSourceSurface ( aRect . Size ( ) , input -> GetFormat ( ) ) ; if ( MOZ2D_WARN_IF ( ! target ) ) { return nullptr ; } } MOZ_ASSERT ( input -> GetFormat ( ) == target -> GetFormat ( ) , "different surface formats from the same input?" ) ; CopyRect ( input , target , srcRect - srcRect . TopLeft ( ) , destRect . TopLeft ( ) - aRect . TopLeft ( ) ) ; } } return target . forget ( ) ; }
void js :: AddPropertyTypesAfterProtoChange ( JSContext * cx , NativeObject * obj , ObjectGroup * oldGroup ) { AutoSweepObjectGroup sweepObjGroup ( obj -> group ( ) ) ; MOZ_ASSERT ( obj -> group ( ) != oldGroup ) ; MOZ_ASSERT ( ! obj -> group ( ) -> unknownProperties ( sweepObjGroup ) ) ; AutoSweepObjectGroup sweepOldGroup ( oldGroup ) ; MarkObjectGroupFlags ( cx , obj , oldGroup -> flags ( sweepOldGroup ) & ( OBJECT_FLAG_DYNAMIC_MASK & ~ OBJECT_FLAG_UNKNOWN_PROPERTIES ) ) ; static const size_t MaxPropertyCount = 40 ; size_t nprops = obj -> getDenseInitializedLength ( ) ; if ( nprops > MaxPropertyCount ) { MarkObjectGroupUnknownProperties ( cx , obj -> group ( ) ) ; return ; } for ( size_t i = 0 ; i < obj -> getDenseInitializedLength ( ) ; i ++ ) { Value val = obj -> getDenseElement ( i ) ; if ( ! val . isMagic ( JS_ELEMENTS_HOLE ) ) { AddTypePropertyId ( cx , obj , JSID_VOID , val ) ; } } for ( Shape :: Range < NoGC > r ( obj -> lastProperty ( ) ) ; ! r . empty ( ) ; r . popFront ( ) ) { Shape * shape = & r . front ( ) ; jsid id = shape -> propid ( ) ; if ( JSID_IS_EMPTY ( id ) ) { continue ; } if ( nprops ++ > MaxPropertyCount ) { MarkObjectGroupUnknownProperties ( cx , obj -> group ( ) ) ; return ; } Value val = shape -> isDataProperty ( ) ? obj -> getSlot ( shape -> slot ( ) ) : UndefinedValue ( ) ; UpdateShapeTypeAndValue ( cx , obj , shape , id , val ) ; } }
std :: unique_ptr < v8 :: Platform > NewDefaultPlatform ( int thread_pool_size , IdleTaskSupport idle_task_support , InProcessStackDumping in_process_stack_dumping , std :: unique_ptr < v8 :: TracingController > tracing_controller ) { if ( in_process_stack_dumping == InProcessStackDumping :: kEnabled ) { v8 :: base :: debug :: EnableInProcessStackDumping ( ) ; } std :: unique_ptr < DefaultPlatform > platform ( new DefaultPlatform ( idle_task_support , std :: move ( tracing_controller ) ) ) ; platform -> SetThreadPoolSize ( thread_pool_size ) ; platform -> EnsureBackgroundTaskRunnerInitialized ( ) ; return std :: move ( platform ) ; }
bool SmallOrderedHashTable < Derived > :: Delete ( Isolate * isolate , Derived * table , Object * key ) { DisallowHeapAllocation no_gc ; int entry = table -> FindEntry ( isolate , key ) ; if ( entry == kNotFound ) return false ; int nof = table -> NumberOfElements ( ) ; int nod = table -> NumberOfDeletedElements ( ) ; Object * hole = ReadOnlyRoots ( isolate ) . the_hole_value ( ) ; for ( int j = 0 ; j < Derived :: kEntrySize ; j ++ ) { table -> SetDataEntry ( entry , j , hole ) ; } table -> SetNumberOfElements ( nof - 1 ) ; table -> SetNumberOfDeletedElements ( nod + 1 ) ; return true ; }
static int dwc3_qcom_acpi_register_core ( struct platform_device * pdev ) { struct dwc3_qcom * qcom = platform_get_drvdata ( pdev ) ; struct device * dev = & pdev -> dev ; struct resource * res , * child_res = NULL ; struct platform_device * pdev_irq = qcom -> urs_usb ? qcom -> urs_usb : pdev ; int irq ; int ret ; qcom -> dwc3 = platform_device_alloc ( "dwc3" , PLATFORM_DEVID_AUTO ) ; if ( ! qcom -> dwc3 ) return - ENOMEM ; qcom -> dwc3 -> dev . parent = dev ; qcom -> dwc3 -> dev . type = dev -> type ; qcom -> dwc3 -> dev . dma_mask = dev -> dma_mask ; qcom -> dwc3 -> dev . dma_parms = dev -> dma_parms ; qcom -> dwc3 -> dev . coherent_dma_mask = dev -> coherent_dma_mask ; child_res = kcalloc ( 2 , sizeof ( * child_res ) , GFP_KERNEL ) ; if ( ! child_res ) return - ENOMEM ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) { dev_err ( & pdev -> dev , "failed to get memory resource\n" ) ; ret = - ENODEV ; goto out ; } child_res [ 0 ] . flags = res -> flags ; child_res [ 0 ] . start = res -> start ; child_res [ 0 ] . end = child_res [ 0 ] . start + qcom -> acpi_pdata -> dwc3_core_base_size ; irq = platform_get_irq ( pdev_irq , 0 ) ; if ( irq < 0 ) { ret = irq ; goto out ; } child_res [ 1 ] . flags = IORESOURCE_IRQ ; child_res [ 1 ] . start = child_res [ 1 ] . end = irq ; ret = platform_device_add_resources ( qcom -> dwc3 , child_res , 2 ) ; if ( ret ) { dev_err ( & pdev -> dev , "failed to add resources\n" ) ; goto out ; } ret = device_add_software_node ( & qcom -> dwc3 -> dev , & dwc3_qcom_swnode ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , "failed to add properties\n" ) ; goto out ; } ret = platform_device_add ( qcom -> dwc3 ) ; if ( ret ) { dev_err ( & pdev -> dev , "failed to add device\n" ) ; device_remove_software_node ( & qcom -> dwc3 -> dev ) ; } out : kfree ( child_res ) ; return ret ; }
void PropertyAccessBuilder :: BuildCheckMaps ( Node * receiver , Node * * effect , Node * control , std :: vector < Handle < Map > > const & receiver_maps ) { HeapObjectMatcher m ( receiver ) ; if ( m . HasValue ( ) ) { Handle < Map > receiver_map ( m . Value ( ) -> map ( ) , isolate ( ) ) ; if ( receiver_map -> is_stable ( ) ) { for ( Handle < Map > map : receiver_maps ) { if ( map . is_identical_to ( receiver_map ) ) { dependencies ( ) -> DependOnStableMap ( MapRef ( js_heap_broker ( ) , receiver_map ) ) ; return ; } } } } ZoneHandleSet < Map > maps ; CheckMapsFlags flags = CheckMapsFlag :: kNone ; for ( Handle < Map > map : receiver_maps ) { maps . insert ( map , graph ( ) -> zone ( ) ) ; if ( map -> is_migration_target ( ) ) { flags |= CheckMapsFlag :: kTryMigrateInstance ; } } * effect = graph ( ) -> NewNode ( simplified ( ) -> CheckMaps ( flags , maps ) , receiver , * effect , control ) ; }
long kvm_arch_vcpu_ioctl ( struct file * filp , unsigned int ioctl , unsigned long arg ) { struct kvm_vcpu * vcpu = filp -> private_data ; void __user * argp = ( void __user * ) arg ; switch ( ioctl ) { case KVM_ARM_VCPU_INIT : { struct kvm_vcpu_init init ; if ( copy_from_user ( & init , argp , sizeof ( init ) ) ) return - EFAULT ; return kvm_vcpu_set_target ( vcpu , & init ) ; } case KVM_SET_ONE_REG : case KVM_GET_ONE_REG : { struct kvm_one_reg reg ; if ( copy_from_user ( & reg , argp , sizeof ( reg ) ) ) return - EFAULT ; if ( ioctl == KVM_SET_ONE_REG ) return kvm_arm_set_reg ( vcpu , & reg ) ; else return kvm_arm_get_reg ( vcpu , & reg ) ; } case KVM_GET_REG_LIST : { struct kvm_reg_list __user * user_list = argp ; struct kvm_reg_list reg_list ; unsigned n ; if ( copy_from_user ( & reg_list , user_list , sizeof ( reg_list ) ) ) return - EFAULT ; n = reg_list . n ; reg_list . n = kvm_arm_num_regs ( vcpu ) ; if ( copy_to_user ( user_list , & reg_list , sizeof ( reg_list ) ) ) return - EFAULT ; if ( n < reg_list . n ) return - E2BIG ; return kvm_arm_copy_reg_indices ( vcpu , user_list -> reg ) ; } default : return - EINVAL ; } }
TEST_F ( BookmarkEditorViewTest , ChangeTitleNoTree ) { CreateEditor ( profile_ . get ( ) , NULL , BookmarkEditor :: EditDetails :: EditNode ( model_ -> other_node ( ) -> GetChild ( 0 ) ) , BookmarkEditorView :: NO_TREE ) ; SetTitleText ( ASCIIToUTF16 ( "new_a" ) ) ; ApplyEdits ( NULL ) ; const BookmarkNode * other_node = model_ -> other_node ( ) ; ASSERT_EQ ( 2 , other_node -> child_count ( ) ) ; const BookmarkNode * new_node = other_node -> GetChild ( 0 ) ; EXPECT_EQ ( ASCIIToUTF16 ( "new_a" ) , new_node -> GetTitle ( ) ) ; }
js :: TypedObjectIsAttached ( ThreadSafeContext * cx , unsigned argc , Value * vp ) { CallArgs args = CallArgsFromVp ( argc , vp ) ; JS_ASSERT ( args [ 0 ] . isObject ( ) && args [ 0 ] . toObject ( ) . is < TypedObject > ( ) ) ; TypedObject & typedObj = args [ 0 ] . toObject ( ) . as < TypedObject > ( ) ; args . rval ( ) . setBoolean ( typedObj . typedMem ( ) != nullptr ) ; return true ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TFLITE_DCHECK ( node -> user_data != nullptr ) ; OpData * data = static_cast < OpData * > ( node -> user_data ) ; TF_LITE_ENSURE ( context , NumInputs ( node ) == 2 || NumInputs ( node ) == 3 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * input = GetInput ( context , node , 0 ) ; const TfLiteTensor * paddings = GetInput ( context , node , 1 ) ; const TfLiteTensor * constant_values = NumInputs ( node ) == 3 ? GetInput ( context , node , 2 ) : nullptr ; TfLiteTensor * output = GetOutput ( context , node , 0 ) ; TF_LITE_ENSURE_EQ ( context , input -> type , output -> type ) ; TF_LITE_ENSURE ( context , NumDimensions ( input ) <= reference_ops :: PadKernelMaxDimensionCount ( ) ) ; if ( constant_values != nullptr ) { TF_LITE_ENSURE_EQ ( context , input -> type , constant_values -> type ) ; TF_LITE_ENSURE_EQ ( context , NumElements ( constant_values ) , 1 ) ; } TF_LITE_ENSURE_EQ ( context , GetTensorShape ( paddings ) . FlatSize ( ) , output -> dims -> size * 2 ) ; TF_LITE_ENSURE ( context , IsConstantTensor ( paddings ) ) ; const int32_t * paddings_data = GetTensorData < int32_t > ( paddings ) ; for ( int i = 0 ; i < output -> dims -> size ; i ++ ) { int output_dim = output -> dims -> data [ i ] ; int expected_dim = input -> dims -> data [ i ] + paddings_data [ i * 2 ] + paddings_data [ i * 2 + 1 ] ; TF_LITE_ENSURE_EQ ( context , output_dim , expected_dim ) ; } data -> params . resizing_category = ResizingCategory :: kGenericResize ; const int paddings_total = GetTensorShape ( paddings ) . FlatSize ( ) ; if ( paddings_total == 8 && ( paddings_data [ 0 ] == 0 && paddings_data [ 1 ] == 0 ) && ( paddings_data [ 6 ] == 0 && paddings_data [ 7 ] == 0 ) ) { data -> params . resizing_category = ResizingCategory :: kImageStyle ; } const int num_input_dimensions = NumDimensions ( input ) ; data -> params . left_padding_count = num_input_dimensions ; data -> params . right_padding_count = num_input_dimensions ; for ( int idx = num_input_dimensions - 1 ; idx >= 0 ; -- idx ) { data -> params . left_padding [ idx ] = paddings_data [ idx * 2 ] ; data -> params . right_padding [ idx ] = paddings_data [ idx * 2 + 1 ] ; } if ( input -> type == kTfLiteInt8 || input -> type == kTfLiteUInt8 ) { if ( constant_values == nullptr ) { if ( input -> type == kTfLiteUInt8 ) { TF_LITE_ENSURE ( context , output -> params . zero_point >= std :: numeric_limits < uint8_t > :: min ( ) ) ; TF_LITE_ENSURE ( context , output -> params . zero_point <= std :: numeric_limits < uint8_t > :: max ( ) ) ; } else { TF_LITE_ENSURE ( context , output -> params . zero_point >= std :: numeric_limits < int8_t > :: min ( ) ) ; TF_LITE_ENSURE ( context , output -> params . zero_point <= std :: numeric_limits < int8_t > :: max ( ) ) ; } } else { TF_LITE_ENSURE_EQ ( context , output -> params . zero_point , constant_values -> params . zero_point ) ; TF_LITE_ENSURE_EQ ( context , static_cast < double > ( output -> params . scale ) , static_cast < double > ( constant_values -> params . scale ) ) ; } data -> output_zero_point = output -> params . zero_point ; } return kTfLiteOk ; }
break ; } p += count ; if ( ( count & 0x01 ) != 0 ) p ++ ; } } static void RemoveResolutionFromResourceBlock ( StringInfo * bim_profile ) { register const unsigned char * p ; size_t length ; unsigned char * datum ; unsigned int count , long_sans ; unsigned short id , short_sans ; length = GetStringInfoLength ( bim_profile ) ; if ( length < 16 ) return ; datum = GetStringInfoDatum ( bim_profile ) ; for ( p = datum ; ( p >= datum ) && ( p < ( datum + length - 16 ) ) ; ) { register unsigned char * q ; q = ( unsigned char * ) p ; if ( LocaleNCompare ( ( const char * ) p , "8BIM" , 4 ) != 0 ) break ; p = PushLongPixel ( MSBEndian , p , & long_sans ) ; p = PushShortPixel ( MSBEndian , p , & id ) ; p = PushShortPixel ( MSBEndian , p , & short_sans ) ; p = PushLongPixel ( MSBEndian , p , & count ) ; if ( ( id == 0x000003ed ) && ( PSDQuantum ( count ) < ( ssize_t ) ( length - 12 ) ) ) { ( void ) CopyMagickMemory ( q , q + PSDQuantum ( count ) + 12 , length - ( PSDQuantum ( count ) + 12 ) - ( q - datum ) ) ;
Reduction JSCallReducer :: ReducePromiseResolveTrampoline ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSCall , node -> opcode ( ) ) ; Node * receiver = NodeProperties :: GetValueInput ( node , 1 ) ; Node * value = node -> op ( ) -> ValueInputCount ( ) > 2 ? NodeProperties :: GetValueInput ( node , 2 ) : jsgraph ( ) -> UndefinedConstant ( ) ; Node * context = NodeProperties :: GetContextInput ( node ) ; Node * frame_state = NodeProperties :: GetFrameStateInput ( node ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; ZoneHandleSet < Map > receiver_maps ; NodeProperties :: InferReceiverMapsResult infer_receiver_maps_result = NodeProperties :: InferReceiverMaps ( isolate ( ) , receiver , effect , & receiver_maps ) ; if ( infer_receiver_maps_result == NodeProperties :: kNoReceiverMaps ) { return NoChange ( ) ; } DCHECK_NE ( 0 , receiver_maps . size ( ) ) ; for ( Handle < Map > receiver_map : receiver_maps ) { if ( ! receiver_map -> IsJSReceiverMap ( ) ) return NoChange ( ) ; } node -> ReplaceInput ( 0 , receiver ) ; node -> ReplaceInput ( 1 , value ) ; node -> ReplaceInput ( 2 , context ) ; node -> ReplaceInput ( 3 , frame_state ) ; node -> ReplaceInput ( 4 , effect ) ; node -> ReplaceInput ( 5 , control ) ; node -> TrimInputCount ( 6 ) ; NodeProperties :: ChangeOp ( node , javascript ( ) -> PromiseResolve ( ) ) ; return Changed ( node ) ; }
void MarkCompactCollector :: PerformWrapperTracing ( ) { if ( heap_ -> local_embedder_heap_tracer ( ) -> InUse ( ) ) { TRACE_GC ( heap ( ) -> tracer ( ) , GCTracer :: Scope :: MC_MARK_WRAPPER_TRACING ) ; heap_ -> local_embedder_heap_tracer ( ) -> RegisterWrappersWithRemoteTracer ( ) ; heap_ -> local_embedder_heap_tracer ( ) -> Trace ( std :: numeric_limits < double > :: infinity ( ) ) ; } }
static const char * findvararg ( CallInfo * ci , int n , StkId * pos ) { if ( clLvalue ( s2v ( ci -> func ) ) -> p -> is_vararg ) { int nextra = ci -> u . l . nextraargs ; if ( n <= nextra ) { * pos = ci -> func - nextra + ( n - 1 ) ; return "(vararg)" ; } } return NULL ; }
nsXBLPrototypeBinding :: InitClass ( const nsCString & aClassName , JSContext * aContext , JSObject * aGlobal , JSObject * aScriptObject , JSObject * * aClassObject ) { NS_ENSURE_ARG_POINTER ( aClassObject ) ; * aClassObject = nullptr ; return nsXBLBinding :: DoInitJSClass ( aContext , aGlobal , aScriptObject , aClassName , this , aClassObject ) ; }
TransactionDatabaseOperationBase :: NoteContinueReceived ( ) { AssertIsOnOwningThread ( ) ; MOZ_ASSERT ( mInternalState == InternalState :: WaitingForContinue ) ; mInternalState = InternalState :: SendingResults ; Unused < < this -> Run ( ) ; }
static int kvm_vm_ioctl_set_pit2 ( struct kvm * kvm , struct kvm_pit_state2 * ps ) { int start = 0 ; u32 prev_legacy , cur_legacy ; mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ; prev_legacy = kvm -> arch . vpit -> pit_state . flags & KVM_PIT_FLAGS_HPET_LEGACY ; cur_legacy = ps -> flags & KVM_PIT_FLAGS_HPET_LEGACY ; if ( ! prev_legacy && cur_legacy ) start = 1 ; memcpy ( & kvm -> arch . vpit -> pit_state . channels , & ps -> channels , sizeof ( kvm -> arch . vpit -> pit_state . channels ) ) ; kvm -> arch . vpit -> pit_state . flags = ps -> flags ; kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; return 0 ; }
int hashtable_set ( hashtable_t * hashtable , const char * key , size_t serial , json_t * value ) { pair_t * pair ; bucket_t * bucket ; size_t hash , index ; if ( hashtable -> size >= num_buckets ( hashtable ) ) if ( hashtable_do_rehash ( hashtable ) ) return - 1 ; hash = hash_str ( key ) ; index = hash % num_buckets ( hashtable ) ; bucket = & hashtable -> buckets [ index ] ; pair = hashtable_find_pair ( hashtable , bucket , key , hash ) ; if ( pair ) { json_decref ( pair -> value ) ; pair -> value = value ; } else { pair = jsonp_malloc ( offsetof ( pair_t , key ) + strlen ( key ) + 1 ) ; if ( ! pair ) return - 1 ; pair -> hash = hash ; pair -> serial = serial ; strcpy ( pair -> key , key ) ; pair -> value = value ; list_init ( & pair -> list ) ; insert_to_bucket ( hashtable , bucket , & pair -> list ) ; hashtable -> size ++ ; } return 0 ; }
request_env ( agooReq req , VALUE self ) { if ( Qnil == ( VALUE ) req -> env ) { volatile VALUE env = rb_hash_new ( ) ; rb_hash_aset ( env , request_method_val , req_method ( req ) ) ; rb_hash_aset ( env , script_name_val , req_script_name ( req ) ) ; rb_hash_aset ( env , path_info_val , req_path_info ( req ) ) ; rb_hash_aset ( env , query_string_val , req_query_string ( req ) ) ; rb_hash_aset ( env , server_name_val , req_server_name ( req ) ) ; rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ; fill_headers ( req , env ) ; rb_hash_aset ( env , rack_version_val , rack_version_val_val ) ; rb_hash_aset ( env , rack_url_scheme_val , req_rack_url_scheme ( req ) ) ; rb_hash_aset ( env , rack_input_val , req_rack_input ( req ) ) ; rb_hash_aset ( env , rack_errors_val , req_rack_errors ( req ) ) ; rb_hash_aset ( env , rack_multithread_val , req_rack_multithread ( req ) ) ; rb_hash_aset ( env , rack_multiprocess_val , Qfalse ) ; rb_hash_aset ( env , rack_run_once_val , Qfalse ) ; rb_hash_aset ( env , rack_logger_val , req_rack_logger ( req ) ) ; rb_hash_aset ( env , rack_upgrade_val , req_rack_upgrade ( req ) ) ; rb_hash_aset ( env , rack_hijackq_val , Qtrue ) ; rb_hash_aset ( env , rack_hijack_val , self ) ; rb_hash_aset ( env , rack_hijack_io_val , Qnil ) ; if ( agoo_server . rack_early_hints ) { volatile VALUE eh = agoo_early_hints_new ( req ) ; rb_hash_aset ( env , early_hints_val , eh ) ; } req -> env = ( void * ) env ; } return ( VALUE ) req -> env ; }
void Serializer < AllocatorT > :: Pad ( ) { for ( unsigned i = 0 ; i < sizeof ( int32_t ) - 1 ; i ++ ) { sink_ . Put ( kNop , "Padding" ) ; } while ( ! IsAligned ( sink_ . Position ( ) , kPointerAlignment ) ) { sink_ . Put ( kNop , "Padding" ) ; } }
static int32_t MapCentralDirectory0 ( int fd , const char * debug_file_name , ZipArchive * archive , off64_t file_length , off64_t read_amount , uint8_t * scan_buffer ) { const off64_t search_start = file_length - read_amount ; if ( lseek64 ( fd , search_start , SEEK_SET ) != search_start ) { ALOGW ( "Zip: seek %" PRId64 " failed: %s" , static_cast < int64_t > ( search_start ) , strerror ( errno ) ) ; return kIoError ; } ssize_t actual = TEMP_FAILURE_RETRY ( read ( fd , scan_buffer , static_cast < size_t > ( read_amount ) ) ) ; if ( actual != static_cast < ssize_t > ( read_amount ) ) { ALOGW ( "Zip: read %" PRId64 " failed: %s" , static_cast < int64_t > ( read_amount ) , strerror ( errno ) ) ; return kIoError ; } int i = read_amount - sizeof ( EocdRecord ) ; for ( ; i >= 0 ; i -- ) { if ( scan_buffer [ i ] == 0x50 && ( ( * reinterpret_cast < uint32_t * > ( & scan_buffer [ i ] ) ) == EocdRecord :: kSignature ) ) { ALOGV ( "+++ Found EOCD at buf+%d" , i ) ; break ; } } if ( i < 0 ) { ALOGD ( "Zip: EOCD not found, %s is not zip" , debug_file_name ) ; return kInvalidFile ; } const off64_t eocd_offset = search_start + i ; const EocdRecord * eocd = reinterpret_cast < const EocdRecord * > ( scan_buffer + i ) ; const off64_t calculated_length = eocd_offset + sizeof ( EocdRecord ) + eocd -> comment_length ; if ( calculated_length != file_length ) { ALOGW ( "Zip: %" PRId64 " extraneous bytes at the end of the central directory" , static_cast < int64_t > ( file_length - calculated_length ) ) ; return kInvalidFile ; } if ( eocd -> cd_start_offset + eocd -> cd_size > eocd_offset ) { ALOGW ( "Zip: bad offsets (dir %" PRIu32 ", size %" PRIu32 ", eocd %" PRId64 ")" , eocd -> cd_start_offset , eocd -> cd_size , static_cast < int64_t > ( eocd_offset ) ) ; return kInvalidOffset ; } if ( eocd -> num_records == 0 ) { ALOGW ( "Zip: empty archive?" ) ; return kEmptyArchive ; } ALOGV ( "+++ num_entries=%" PRIu32 "dir_size=%" PRIu32 " dir_offset=%" PRIu32 , eocd -> num_records , eocd -> cd_size , eocd -> cd_start_offset ) ; android :: FileMap * map = MapFileSegment ( fd , static_cast < off64_t > ( eocd -> cd_start_offset ) , static_cast < size_t > ( eocd -> cd_size ) , true , debug_file_name ) ; if ( map == NULL ) { archive -> directory_map = NULL ; return kMmapFailed ; } archive -> directory_map = map ; archive -> num_entries = eocd -> num_records ; archive -> directory_offset = eocd -> cd_start_offset ; return 0 ; }
R_API void r_anal_bb_free ( RAnalBlock * bb ) { if ( ! bb ) { return ; } r_anal_cond_free ( bb -> cond ) ; R_FREE ( bb -> fingerprint ) ; r_anal_diff_free ( bb -> diff ) ; bb -> diff = NULL ; R_FREE ( bb -> op_bytes ) ; r_anal_switch_op_free ( bb -> switch_op ) ; bb -> switch_op = NULL ; bb -> fingerprint = NULL ; bb -> cond = NULL ; R_FREE ( bb -> label ) ; R_FREE ( bb -> op_pos ) ; R_FREE ( bb -> parent_reg_arena ) ; if ( bb -> prev ) { if ( bb -> prev -> jumpbb == bb ) { bb -> prev -> jumpbb = NULL ; } if ( bb -> prev -> failbb == bb ) { bb -> prev -> failbb = NULL ; } bb -> prev = NULL ; } if ( bb -> jumpbb ) { bb -> jumpbb -> prev = NULL ; bb -> jumpbb = NULL ; } if ( bb -> failbb ) { bb -> failbb -> prev = NULL ; bb -> failbb = NULL ; } R_FREE ( bb ) ; }
bool Scanner :: ScanSignedInteger ( ) { if ( c0_ == '+' || c0_ == '-' ) AddLiteralCharAdvance ( ) ; if ( ! IsDecimalDigit ( c0_ ) ) return false ; return ScanDecimalDigits ( ) ; }
static int ati_remote2_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct usb_host_interface * alt = interface -> cur_altsetting ; struct ati_remote2 * ar2 ; int r ; if ( alt -> desc . bInterfaceNumber ) return - ENODEV ; ar2 = kzalloc ( sizeof ( struct ati_remote2 ) , GFP_KERNEL ) ; if ( ! ar2 ) return - ENOMEM ; ar2 -> udev = udev ; ar2 -> intf [ 0 ] = interface ; ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ; ar2 -> intf [ 1 ] = usb_ifnum_to_if ( udev , 1 ) ; r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ; if ( r ) goto fail1 ; alt = ar2 -> intf [ 1 ] -> cur_altsetting ; ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ; r = ati_remote2_urb_init ( ar2 ) ; if ( r ) goto fail2 ; ar2 -> channel_mask = channel_mask ; ar2 -> mode_mask = mode_mask ; r = ati_remote2_setup ( ar2 , ar2 -> channel_mask ) ; if ( r ) goto fail2 ; usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> phys , "/input0" , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> name , "ATI Remote Wonder II" , sizeof ( ar2 -> name ) ) ; r = sysfs_create_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; if ( r ) goto fail2 ; r = ati_remote2_input_init ( ar2 ) ; if ( r ) goto fail3 ; usb_set_intfdata ( interface , ar2 ) ; interface -> needs_remote_wakeup = 1 ; return 0 ; fail3 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail2 : ati_remote2_urb_cleanup ( ar2 ) ; usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ; fail1 : kfree ( ar2 ) ; return r ; }
std :: string ImplementationVisitor :: GetBaseAssemblerName ( Module * module ) { if ( module == global_context_ . GetDefaultModule ( ) ) { return "CodeStubAssembler" ; } else { std :: string assembler_name ( CamelifyString ( module -> name ( ) ) + "BuiltinsAssembler" ) ; return assembler_name ; } }
static void LeaveInterpreterFrame ( MacroAssembler * masm , Register scratch ) { Register args_count = scratch ; __ Ld ( args_count , MemOperand ( fp , InterpreterFrameConstants :: kBytecodeArrayFromFp ) ) ; __ Lw ( t0 , FieldMemOperand ( args_count , BytecodeArray :: kParameterSizeOffset ) ) ; __ LeaveFrame ( StackFrame :: INTERPRETED ) ; __ Daddu ( sp , sp , args_count ) ; }
static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) { u8 obuf [ ] = { 0x51 } ; u8 ibuf [ ] = { 0 } ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( "command 0x51 transfer failed." ) ; d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , & d -> dev -> i2c_adap ) ; if ( d -> fe_adap [ 0 ] . fe == NULL ) return - EIO ; if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , & dw2104_ts2020_config , & d -> dev -> i2c_adap ) ) { info ( "Attached RS2000/TS2020!" ) ; return 0 ; } info ( "Failed to attach RS2000/TS2020!" ) ; return - EIO ; }
Range :: intersect ( TempAllocator & alloc , const Range * lhs , const Range * rhs , bool * emptyRange ) { * emptyRange = false ; if ( ! lhs && ! rhs ) return nullptr ; if ( ! lhs ) return new ( alloc ) Range ( * rhs ) ; if ( ! rhs ) return new ( alloc ) Range ( * lhs ) ; int32_t newLower = Max ( lhs -> lower_ , rhs -> lower_ ) ; int32_t newUpper = Min ( lhs -> upper_ , rhs -> upper_ ) ; if ( newUpper < newLower ) { * emptyRange = true ; return nullptr ; } bool newHasInt32LowerBound = lhs -> hasInt32LowerBound_ || rhs -> hasInt32LowerBound_ ; bool newHasInt32UpperBound = lhs -> hasInt32UpperBound_ || rhs -> hasInt32UpperBound_ ; bool newFractional = lhs -> canHaveFractionalPart_ && rhs -> canHaveFractionalPart_ ; uint16_t newExponent = Min ( lhs -> max_exponent_ , rhs -> max_exponent_ ) ; if ( newHasInt32LowerBound && newHasInt32UpperBound && newExponent == IncludesInfinityAndNaN ) return nullptr ; if ( lhs -> canHaveFractionalPart_ != rhs -> canHaveFractionalPart_ || ( lhs -> canHaveFractionalPart_ && newHasInt32LowerBound && newHasInt32UpperBound && newLower == newUpper ) ) { refineInt32BoundsByExponent ( newExponent , & newLower , & newUpper ) ; if ( newLower > newUpper ) { * emptyRange = true ; return nullptr ; } } return new ( alloc ) Range ( newLower , newHasInt32LowerBound , newUpper , newHasInt32UpperBound , newFractional , newExponent ) ; }
IGNITION_HANDLER ( CreateMappedArguments , InterpreterAssembler ) { Node * closure = LoadRegister ( Register :: function_closure ( ) ) ; Node * context = GetContext ( ) ; Label if_duplicate_parameters ( this , Label :: kDeferred ) ; Label if_not_duplicate_parameters ( this ) ; Node * shared_info = LoadObjectField ( closure , JSFunction :: kSharedFunctionInfoOffset ) ; Node * flags = LoadObjectField ( shared_info , SharedFunctionInfo :: kFlagsOffset , MachineType :: Uint32 ( ) ) ; Node * has_duplicate_parameters = IsSetWord32 < SharedFunctionInfo :: HasDuplicateParametersBit > ( flags ) ; Branch ( has_duplicate_parameters , & if_duplicate_parameters , & if_not_duplicate_parameters ) ; BIND ( & if_not_duplicate_parameters ) ; { ArgumentsBuiltinsAssembler constructor_assembler ( state ( ) ) ; Node * result = constructor_assembler . EmitFastNewSloppyArguments ( context , closure ) ; SetAccumulator ( result ) ; Dispatch ( ) ; } BIND ( & if_duplicate_parameters ) ; { Node * result = CallRuntime ( Runtime :: kNewSloppyArguments_Generic , context , closure ) ; SetAccumulator ( result ) ; Dispatch ( ) ; } }
void RecordFallThroughPath ( ) { builder ( ) -> LoadLiteral ( Smi :: FromInt ( - 1 ) ) ; builder ( ) -> StoreAccumulatorInRegister ( token_register_ ) ; builder ( ) -> StoreAccumulatorInRegister ( result_register_ ) ; }
static void singlevar ( LexState * ls , expdesc * var ) { TString * varname = str_checkname ( ls ) ; FuncState * fs = ls -> fs ; singlevaraux ( fs , varname , var , 1 ) ; if ( var -> k == VVOID ) { expdesc key ; singlevaraux ( fs , ls -> envn , var , 1 ) ; lua_assert ( var -> k != VVOID ) ; codestring ( & key , varname ) ; luaK_indexed ( fs , var , & key ) ; } }
static int aio_poll_cancel ( struct kiocb * iocb ) { struct aio_kiocb * aiocb = container_of ( iocb , struct aio_kiocb , rw ) ; struct poll_iocb * req = & aiocb -> poll ; spin_lock ( & req -> head -> lock ) ; WRITE_ONCE ( req -> cancelled , true ) ; if ( ! req -> work_scheduled ) { schedule_work ( & aiocb -> poll . work ) ; req -> work_scheduled = true ; } spin_unlock ( & req -> head -> lock ) ; return 0 ; }
Reduction LoadElimination :: ReduceStoreField ( Node * node ) { FieldAccess const & access = FieldAccessOf ( node -> op ( ) ) ; Node * const object = NodeProperties :: GetValueInput ( node , 0 ) ; Node * const new_value = NodeProperties :: GetValueInput ( node , 1 ) ; Node * const effect = NodeProperties :: GetEffectInput ( node ) ; AbstractState const * state = node_states_ . Get ( effect ) ; if ( state == nullptr ) return NoChange ( ) ; if ( access . offset == HeapObject :: kMapOffset && access . base_is_tagged == kTaggedBase ) { DCHECK ( IsAnyTagged ( access . machine_type . representation ( ) ) ) ; state = state -> KillMaps ( object , zone ( ) ) ; Type const new_value_type = NodeProperties :: GetType ( new_value ) ; if ( new_value_type . IsHeapConstant ( ) ) { ZoneHandleSet < Map > object_maps ( bit_cast < Handle < Map > > ( new_value_type . AsHeapConstant ( ) -> Value ( ) ) ) ; state = state -> SetMaps ( object , object_maps , zone ( ) ) ; } } else { int field_index = FieldIndexOf ( access ) ; if ( field_index >= 0 ) { Node * const old_value = state -> LookupField ( object , field_index ) ; if ( old_value == new_value ) { return Replace ( effect ) ; } state = state -> KillField ( object , field_index , access . name , zone ( ) ) ; state = state -> AddField ( object , field_index , new_value , access . name , zone ( ) ) ; } else { state = state -> KillFields ( object , access . name , zone ( ) ) ; } } return UpdateState ( node , state ) ; }
PJ_DEF ( pj_status_t ) pjmedia_rtcp_fb_build_pli ( pjmedia_rtcp_session * session , void * buf , pj_size_t * length ) { pjmedia_rtcp_common * hdr ; unsigned len ; PJ_ASSERT_RETURN ( session && buf && length , PJ_EINVAL ) ; len = 12 ; if ( len > * length ) return PJ_ETOOSMALL ; hdr = ( pjmedia_rtcp_common * ) buf ; pj_memcpy ( hdr , & session -> rtcp_rr_pkt . common , sizeof ( * hdr ) ) ; hdr -> pt = RTCP_PSFB ; hdr -> count = 1 ; hdr -> length = pj_htons ( ( pj_uint16_t ) ( len / 4 - 1 ) ) ; * length = len ; return PJ_SUCCESS ; }
int btrfs_add_link ( struct btrfs_trans_handle * trans , struct inode * parent_inode , struct inode * inode , const char * name , int name_len , int add_backref , u64 index ) { int ret = 0 ; struct btrfs_key key ; struct btrfs_root * root = BTRFS_I ( parent_inode ) -> root ; u64 ino = btrfs_ino ( inode ) ; u64 parent_ino = btrfs_ino ( parent_inode ) ; if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { memcpy ( & key , & BTRFS_I ( inode ) -> root -> root_key , sizeof ( key ) ) ; } else { key . objectid = ino ; btrfs_set_key_type ( & key , BTRFS_INODE_ITEM_KEY ) ; key . offset = 0 ; } if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { ret = btrfs_add_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , index , name , name_len ) ; } else if ( add_backref ) { ret = btrfs_insert_inode_ref ( trans , root , name , name_len , ino , parent_ino , index ) ; } if ( ret ) return ret ; ret = btrfs_insert_dir_item ( trans , root , name , name_len , parent_inode , & key , btrfs_inode_type ( inode ) , index ) ; if ( ret == - EEXIST ) goto fail_dir_item ; else if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; return ret ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + name_len * 2 ) ; inode_inc_iversion ( parent_inode ) ; parent_inode -> i_mtime = parent_inode -> i_ctime = CURRENT_TIME ; ret = btrfs_update_inode ( trans , root , parent_inode ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; return ret ; fail_dir_item : if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { u64 local_index ; int err ; err = btrfs_del_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , & local_index , name , name_len ) ; } else if ( add_backref ) { u64 local_index ; int err ; err = btrfs_del_inode_ref ( trans , root , name , name_len , ino , parent_ino , & local_index ) ; } return ret ; }
void MarkCompactCollector :: ClearFullMapTransitions ( ) { TransitionArray * array ; while ( weak_objects_ . transition_arrays . Pop ( kMainThread , & array ) ) { int num_transitions = array -> number_of_entries ( ) ; if ( num_transitions > 0 ) { Map * map ; if ( array -> GetTargetIfExists ( 0 , isolate ( ) , & map ) ) { DCHECK_NOT_NULL ( map ) ; Map * parent = Map :: cast ( map -> constructor_or_backpointer ( ) ) ; bool parent_is_alive = non_atomic_marking_state ( ) -> IsBlackOrGrey ( parent ) ; DescriptorArray * descriptors = parent_is_alive ? parent -> instance_descriptors ( ) : nullptr ; bool descriptors_owner_died = CompactTransitionArray ( parent , array , descriptors ) ; if ( descriptors_owner_died ) { TrimDescriptorArray ( parent , descriptors ) ; } } } } }
char * LibRaw_file_datastream :: gets ( char * str , int sz ) { LR_STREAM_CHK ( ) ; std :: istream is ( f . get ( ) ) ; is . getline ( str , sz ) ; if ( is . fail ( ) ) return 0 ; return str ; }
GetArrayElement ( JSContext * cx , JSObject * obj , jsuint index , JSBool * hole , jsval * vp ) { jsid id ; JSObject * obj2 ; JSProperty * prop ; if ( OBJ_IS_DENSE_ARRAY ( cx , obj ) && index < js_DenseArrayCapacity ( obj ) && ( * vp = obj -> dslots [ index ] ) != JSVAL_HOLE ) { * hole = JS_FALSE ; return JS_TRUE ; } if ( index <= JSVAL_INT_MAX ) { id = INT_TO_JSID ( index ) ; } else { if ( ! BigIndexToId ( cx , obj , index , JS_FALSE , & id ) ) return JS_FALSE ; if ( JSVAL_IS_VOID ( id ) ) { * hole = JS_TRUE ; * vp = JSVAL_VOID ; return JS_TRUE ; } } if ( ! OBJ_LOOKUP_PROPERTY ( cx , obj , id , & obj2 , & prop ) ) return JS_FALSE ; if ( ! prop ) { * hole = JS_TRUE ; * vp = JSVAL_VOID ; } else { OBJ_DROP_PROPERTY ( cx , obj2 , prop ) ; if ( ! OBJ_GET_PROPERTY ( cx , obj , id , vp ) ) return JS_FALSE ; * hole = JS_FALSE ; } return JS_TRUE ; }
nsDocument :: IsScriptEnabled ( ) { if ( mSandboxFlags & SANDBOXED_SCRIPTS ) { return false ; } nsCOMPtr < nsIScriptSecurityManager > sm ( do_GetService ( NS_SCRIPTSECURITYMANAGER_CONTRACTID ) ) ; NS_ENSURE_TRUE ( sm , false ) ; nsIScriptGlobalObject * globalObject = GetScriptGlobalObject ( ) ; NS_ENSURE_TRUE ( globalObject , false ) ; nsIScriptContext * scriptContext = globalObject -> GetContext ( ) ; NS_ENSURE_TRUE ( scriptContext , false ) ; JSContext * cx = scriptContext -> GetNativeContext ( ) ; NS_ENSURE_TRUE ( cx , false ) ; bool enabled ; nsresult rv = sm -> CanExecuteScripts ( cx , NodePrincipal ( ) , & enabled ) ; NS_ENSURE_SUCCESS ( rv , false ) ; return enabled ; }
void freeListData ( char * * * data , unsigned int length ) { for ( int i = 0 ; i < length ; i ++ ) { free ( ( * data ) [ i ] ) ; } free ( * data ) ; }
BUILTIN ( DateConstructor ) { HandleScope scope ( isolate ) ; if ( args . new_target ( ) -> IsUndefined ( isolate ) ) { double const time_val = JSDate :: CurrentTimeValue ( isolate ) ; char buffer [ 128 ] ; ToDateString ( time_val , ArrayVector ( buffer ) , isolate -> date_cache ( ) ) ; RETURN_RESULT_OR_FAILURE ( isolate , isolate -> factory ( ) -> NewStringFromUtf8 ( CStrVector ( buffer ) ) ) ; } int const argc = args . length ( ) - 1 ; Handle < JSFunction > target = args . target ( ) ; Handle < JSReceiver > new_target = Handle < JSReceiver > :: cast ( args . new_target ( ) ) ; double time_val ; if ( argc == 0 ) { time_val = JSDate :: CurrentTimeValue ( isolate ) ; } else if ( argc == 1 ) { Handle < Object > value = args . at ( 1 ) ; if ( value -> IsJSDate ( ) ) { time_val = Handle < JSDate > :: cast ( value ) -> value ( ) -> Number ( ) ; } else { ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , value , Object :: ToPrimitive ( value ) ) ; if ( value -> IsString ( ) ) { time_val = ParseDateTimeString ( isolate , Handle < String > :: cast ( value ) ) ; } else { ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , value , Object :: ToNumber ( isolate , value ) ) ; time_val = value -> Number ( ) ; } } } else { Handle < Object > year_object ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , year_object , Object :: ToNumber ( isolate , args . at ( 1 ) ) ) ; Handle < Object > month_object ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , month_object , Object :: ToNumber ( isolate , args . at ( 2 ) ) ) ; double year = year_object -> Number ( ) ; double month = month_object -> Number ( ) ; double date = 1.0 , hours = 0.0 , minutes = 0.0 , seconds = 0.0 , ms = 0.0 ; if ( argc >= 3 ) { Handle < Object > date_object ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , date_object , Object :: ToNumber ( isolate , args . at ( 3 ) ) ) ; date = date_object -> Number ( ) ; if ( argc >= 4 ) { Handle < Object > hours_object ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , hours_object , Object :: ToNumber ( isolate , args . at ( 4 ) ) ) ; hours = hours_object -> Number ( ) ; if ( argc >= 5 ) { Handle < Object > minutes_object ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , minutes_object , Object :: ToNumber ( isolate , args . at ( 5 ) ) ) ; minutes = minutes_object -> Number ( ) ; if ( argc >= 6 ) { Handle < Object > seconds_object ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , seconds_object , Object :: ToNumber ( isolate , args . at ( 6 ) ) ) ; seconds = seconds_object -> Number ( ) ; if ( argc >= 7 ) { Handle < Object > ms_object ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , ms_object , Object :: ToNumber ( isolate , args . at ( 7 ) ) ) ; ms = ms_object -> Number ( ) ; } } } } } if ( ! std :: isnan ( year ) ) { double const y = DoubleToInteger ( year ) ; if ( 0.0 <= y && y <= 99 ) year = 1900 + y ; } double const day = MakeDay ( year , month , date ) ; double const time = MakeTime ( hours , minutes , seconds , ms ) ; time_val = MakeDate ( day , time ) ; if ( time_val >= - DateCache :: kMaxTimeBeforeUTCInMs && time_val <= DateCache :: kMaxTimeBeforeUTCInMs ) { time_val = isolate -> date_cache ( ) -> ToUTC ( static_cast < int64_t > ( time_val ) ) ; } else { time_val = std :: numeric_limits < double > :: quiet_NaN ( ) ; } } RETURN_RESULT_OR_FAILURE ( isolate , JSDate :: New ( target , new_target , time_val ) ) ; }
void vp9_setup_src_planes ( MACROBLOCK * x , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , src -> alpha_buffer } ; const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , src -> alpha_stride } ; int i ; x -> e_mbd . cur_buf = src ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) setup_pred_plane ( & x -> plane [ i ] . src , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , x -> e_mbd . plane [ i ] . subsampling_x , x -> e_mbd . plane [ i ] . subsampling_y ) ; }
BUILTIN ( NumberFormatInternalFormatNumber ) { HandleScope scope ( isolate ) ; Handle < Context > context = Handle < Context > ( isolate -> context ( ) , isolate ) ; Handle < JSObject > number_format_holder = Handle < JSObject > ( JSObject :: cast ( context -> get ( NumberFormat :: ContextSlot :: kNumberFormat ) ) , isolate ) ; DCHECK ( Intl :: IsObjectOfType ( isolate , number_format_holder , Intl :: Type :: kNumberFormat ) ) ; Handle < Object > value = args . atOrUndefined ( isolate , 1 ) ; Handle < Object > number_obj ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , number_obj , Object :: ToNumber ( isolate , value ) ) ; if ( number_obj -> IsMinusZero ( ) ) { number_obj = Handle < Smi > ( Smi :: kZero , isolate ) ; } double number = number_obj -> Number ( ) ; RETURN_RESULT_OR_FAILURE ( isolate , NumberFormat :: FormatNumber ( isolate , number_format_holder , number ) ) ; }
ResetDirectionSetByTextNode ( nsTextNode * aTextNode ) { if ( ! NodeAffectsDirAutoAncestor ( aTextNode ) ) { nsTextNodeDirectionalityMap :: EnsureMapIsClearFor ( aTextNode ) ; return ; } Directionality dir = GetDirectionFromText ( aTextNode -> GetText ( ) ) ; if ( dir != eDir_NotSet && aTextNode -> HasTextNodeDirectionalityMap ( ) ) { nsTextNodeDirectionalityMap :: ResetTextNodeDirection ( aTextNode ) ; } }
DNSRequest :: DNSRequest ( DNS * dns , int rid , const std :: string & original ) : dnsobj ( dns ) { res = new unsigned char [ 512 ] ; * res = 0 ; orig = original ; RequestTimeout * RT = new RequestTimeout ( ServerInstance -> Config -> dns_timeout ? ServerInstance -> Config -> dns_timeout : 5 , this , rid ) ; ServerInstance -> Timers -> AddTimer ( RT ) ; }
ft_var_readpackeddeltas ( FT_Stream stream , FT_UInt delta_cnt ) { FT_Short * deltas = NULL ; FT_UInt runcnt , cnt ; FT_UInt i , j ; FT_Memory memory = stream -> memory ; FT_Error error = FT_Err_Ok ; FT_UNUSED ( error ) ; if ( FT_NEW_ARRAY ( deltas , delta_cnt ) ) return NULL ; i = 0 ; while ( i < delta_cnt ) { runcnt = FT_GET_BYTE ( ) ; cnt = runcnt & GX_DT_DELTA_RUN_COUNT_MASK ; if ( runcnt & GX_DT_DELTAS_ARE_ZERO ) { for ( j = 0 ; j <= cnt && i < delta_cnt ; j ++ ) deltas [ i ++ ] = 0 ; } else if ( runcnt & GX_DT_DELTAS_ARE_WORDS ) { for ( j = 0 ; j <= cnt && i < delta_cnt ; j ++ ) deltas [ i ++ ] = FT_GET_SHORT ( ) ; } else { for ( j = 0 ; j <= cnt && i < delta_cnt ; j ++ ) deltas [ i ++ ] = FT_GET_CHAR ( ) ; } if ( j <= cnt ) { FT_FREE ( deltas ) ; return NULL ; } } return deltas ; }
static ssize_t ib_ucm_write ( struct file * filp , const char __user * buf , size_t len , loff_t * pos ) { struct ib_ucm_file * file = filp -> private_data ; struct ib_ucm_cmd_hdr hdr ; ssize_t result ; if ( len < sizeof ( hdr ) ) return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . cmd >= ARRAY_SIZE ( ucm_cmd_table ) ) return - EINVAL ; if ( hdr . in + sizeof ( hdr ) > len ) return - EINVAL ; result = ucm_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; if ( ! result ) result = len ; return result ; }
static int _hostsock_getpeername ( oe_fd_t * sock_ , struct oe_sockaddr * addr , oe_socklen_t * addrlen ) { int ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_socklen_t addrlen_in = 0 ; oe_errno = 0 ; if ( ! sock ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( addrlen ) addrlen_in = * addrlen ; if ( oe_syscall_getpeername_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in , addrlen ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } done : return ret ; }
nsJARChannel :: GetContentType ( nsACString & result ) { if ( ! mOpened ) { result . AssignLiteral ( UNKNOWN_CONTENT_TYPE ) ; return NS_OK ; } if ( mContentType . IsEmpty ( ) ) { const char * ext = nullptr , * fileName = mJarEntry . get ( ) ; int32_t len = mJarEntry . Length ( ) ; if ( ENTRY_IS_DIRECTORY ( mJarEntry ) ) { mContentType . AssignLiteral ( APPLICATION_HTTP_INDEX_FORMAT ) ; } else { for ( int32_t i = len - 1 ; i >= 0 ; i -- ) { if ( fileName [ i ] == '.' ) { ext = & fileName [ i + 1 ] ; break ; } } if ( ext ) { nsIMIMEService * mimeServ = gJarHandler -> MimeService ( ) ; if ( mimeServ ) mimeServ -> GetTypeFromExtension ( nsDependentCString ( ext ) , mContentType ) ; } if ( mContentType . IsEmpty ( ) ) mContentType . AssignLiteral ( UNKNOWN_CONTENT_TYPE ) ; } } result = mContentType ; return NS_OK ; }
static bool cgm_bind_dir ( const char * root , const char * dirname ) { nih_local char * cgpath = NULL ; cgpath = NIH_MUST ( nih_strdup ( NULL , root ) ) ; NIH_MUST ( nih_strcat ( & cgpath , NULL , "/sys/fs/cgroup" ) ) ; if ( ! dir_exists ( cgpath ) ) { ERROR ( "%s does not exist" , cgpath ) ; return false ; } if ( mount ( "cgroup" , cgpath , "tmpfs" , 0 , "size=10000,mode=755" ) ) { SYSERROR ( "Failed to mount tmpfs at %s" , cgpath ) ; return false ; } NIH_MUST ( nih_strcat ( & cgpath , NULL , "/cgmanager" ) ) ; if ( mkdir ( cgpath , 0755 ) < 0 ) { SYSERROR ( "Failed to create %s" , cgpath ) ; return false ; } if ( mount ( dirname , cgpath , "none" , MS_BIND , 0 ) ) { SYSERROR ( "Failed to bind mount %s to %s" , dirname , cgpath ) ; return false ; } return true ; }
RUNTIME_FUNCTION ( Runtime_AddElement ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 3 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSObject , object , 0 ) ; CONVERT_ARG_HANDLE_CHECKED ( Object , key , 1 ) ; CONVERT_ARG_HANDLE_CHECKED ( Object , value , 2 ) ; uint32_t index = 0 ; CHECK ( key -> ToArrayIndex ( & index ) ) ; #ifdef DEBUG LookupIterator it ( isolate , object , index , object , LookupIterator :: OWN_SKIP_INTERCEPTOR ) ; Maybe < PropertyAttributes > maybe = JSReceiver :: GetPropertyAttributes ( & it ) ; if ( maybe . IsNothing ( ) ) return ReadOnlyRoots ( isolate ) . exception ( ) ; DCHECK ( ! it . IsFound ( ) ) ; if ( object -> IsJSArray ( ) ) { Handle < JSArray > array = Handle < JSArray > :: cast ( object ) ; DCHECK ( ! JSArray :: WouldChangeReadOnlyLength ( array , index ) ) ; } #endif RETURN_RESULT_OR_FAILURE ( isolate , JSObject :: SetOwnElementIgnoreAttributes ( object , index , value , NONE ) ) ; }
void Compute ( OpKernelContext * context ) override { const Tensor & input = context -> input ( 0 ) ; const TensorShape & input_shape = input . shape ( ) ; const int32_t input_dims = input_shape . dims ( ) ; const Tensor & segment_id = context -> input ( 1 ) ; const TensorShape & segment_id_shape = segment_id . shape ( ) ; const int32_t segment_dims = segment_id_shape . dims ( ) ; const Tensor & num_segments_tensor = context -> input ( 2 ) ; OP_REQUIRES ( context , num_segments_tensor . NumElements ( ) != 0 , errors :: InvalidArgument ( "Number of segments cannot be empty." ) ) ; auto num_segments = num_segments_tensor . scalar < NUM_SEGMENTS_TYPE > ( ) ( ) ; OP_REQUIRES ( context , num_segments >= 0 , errors :: InvalidArgument ( "Number of segments must be non-negative but got " , num_segments ) ) ; OP_REQUIRES ( context , segment_dims != 0 , errors :: InvalidArgument ( "Segment_id cannot have rank 0" ) ) ; OP_REQUIRES ( context , segment_dims <= input_dims , errors :: OutOfRange ( "Invalid segment_id rank " , segment_dims , " for input with " , input_dims , " dimension(s)" ) ) ; for ( auto i = 0 ; i < segment_dims ; i ++ ) { OP_REQUIRES ( context , segment_id_shape . dim_size ( i ) == input_shape . dim_size ( i ) , errors :: InvalidArgument ( "Segment dimension is " , segment_id_shape . dim_size ( i ) , " while input dimension is " , input_dims , " in rank " , i ) ) ; } Tensor * output_tensor = nullptr ; TensorShape output_shape = GetOutputShape ( input_shape , segment_id_shape , num_segments ) ; OP_REQUIRES_OK ( context , context -> allocate_output ( "output" , output_shape , & output_tensor ) ) ; auto output_flat = output_tensor -> flat < tstring > ( ) ; auto flat_segment_id = segment_id . flat < INDICES_TYPE > ( ) ; auto flat_input = input . flat < tstring > ( ) ; for ( int i = 0 ; i < flat_segment_id . size ( ) ; i ++ ) { OP_REQUIRES ( context , ( ( flat_segment_id ( i ) < num_segments ) && ( flat_segment_id ( i ) >= 0 ) ) , errors :: InvalidArgument ( "segment_ids are not allowed to exceed num_segments or" " to have negative values." ) ) ; } int64_t big_stride ; int64_t small_stride ; std :: tie ( big_stride , small_stride ) = GetStrides < INDICES_TYPE > ( input_shape , segment_id_shape ) ; auto relative_offset_set = GetFlattenedRelativeOffsets < INDICES_TYPE > ( small_stride , big_stride ) ; for ( auto start_offset = 0 ; start_offset < big_stride ; start_offset ++ ) { for ( auto i = 0 ; i < relative_offset_set . size ( ) ; i ++ ) { auto output_index = start_offset + flat_segment_id ( i ) * big_stride ; auto offset = start_offset + relative_offset_set [ i ] ; if ( output_flat ( output_index ) . length ( ) != 0 ) output_flat ( output_index ) . append ( separator_ . c_str ( ) ) ; output_flat ( output_index ) . append ( flat_input ( offset ) ) ; } } }
ChopUpSingleUncompressedStrip ( TIFF * tif ) { register TIFFDirectory * td = & tif -> tif_dir ; uint64 bytecount ; uint64 offset ; uint32 rowblock ; uint64 rowblockbytes ; uint64 stripbytes ; uint32 strip ; uint64 nstrips64 ; uint32 nstrips32 ; uint32 rowsperstrip ; uint64 * newcounts ; uint64 * newoffsets ; bytecount = td -> td_stripbytecount [ 0 ] ; offset = td -> td_stripoffset [ 0 ] ; assert ( td -> td_planarconfig == PLANARCONFIG_CONTIG ) ; if ( ( td -> td_photometric == PHOTOMETRIC_YCBCR ) && ( ! isUpSampled ( tif ) ) ) rowblock = td -> td_ycbcrsubsampling [ 1 ] ; else rowblock = 1 ; rowblockbytes = TIFFVTileSize64 ( tif , rowblock ) ; if ( rowblockbytes > STRIP_SIZE_DEFAULT ) { stripbytes = rowblockbytes ; rowsperstrip = rowblock ; } else if ( rowblockbytes > 0 ) { uint32 rowblocksperstrip ; rowblocksperstrip = ( uint32 ) ( STRIP_SIZE_DEFAULT / rowblockbytes ) ; rowsperstrip = rowblocksperstrip * rowblock ; stripbytes = rowblocksperstrip * rowblockbytes ; } else return ; if ( rowsperstrip >= td -> td_rowsperstrip ) return ; nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) return ; nstrips32 = ( uint32 ) nstrips64 ; newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , "for chopped \"StripByteCounts\" array" ) ; newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , "for chopped \"StripOffsets\" array" ) ; if ( newcounts == NULL || newoffsets == NULL ) { if ( newcounts != NULL ) _TIFFfree ( newcounts ) ; if ( newoffsets != NULL ) _TIFFfree ( newoffsets ) ; return ; } for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { if ( stripbytes > bytecount ) stripbytes = bytecount ; newcounts [ strip ] = stripbytes ; newoffsets [ strip ] = offset ; offset += stripbytes ; bytecount -= stripbytes ; } td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; _TIFFfree ( td -> td_stripbytecount ) ; _TIFFfree ( td -> td_stripoffset ) ; td -> td_stripbytecount = newcounts ; td -> td_stripoffset = newoffsets ; td -> td_stripbytecountsorted = 1 ; }
char * curl_easy_escape ( CURL * handle , const char * string , int inlength ) { size_t alloc = ( inlength ? ( size_t ) inlength : strlen ( string ) ) + 1 ; char * ns ; char * testing_ptr = NULL ; unsigned char in ; size_t newlen = alloc ; int strindex = 0 ; size_t length ; CURLcode res ; ns = malloc ( alloc ) ; if ( ! ns ) return NULL ; length = alloc - 1 ; while ( length -- ) { in = * string ; if ( Curl_isunreserved ( in ) ) ns [ strindex ++ ] = in ; else { newlen += 2 ; if ( newlen > alloc ) { alloc *= 2 ; testing_ptr = realloc ( ns , alloc ) ; if ( ! testing_ptr ) { free ( ns ) ; return NULL ; } else { ns = testing_ptr ; } } res = Curl_convert_to_network ( handle , & in , 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } snprintf ( & ns [ strindex ] , 4 , "%%%02X" , in ) ; strindex += 3 ; } string ++ ; } ns [ strindex ] = 0 ; return ns ; }
static WORD32 ihevcd_parse_vui_parameters ( bitstrm_t * ps_bitstrm , vui_t * ps_vui , WORD32 sps_max_sub_layers_minus1 ) { WORD32 ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; BITS_PARSE ( "aspect_ratio_info_present_flag" , ps_vui -> u1_aspect_ratio_info_present_flag , ps_bitstrm , 1 ) ; ps_vui -> u1_aspect_ratio_idc = SAR_UNUSED ; ps_vui -> u2_sar_width = 0 ; ps_vui -> u2_sar_height = 0 ; if ( ps_vui -> u1_aspect_ratio_info_present_flag ) { BITS_PARSE ( "aspect_ratio_idc" , ps_vui -> u1_aspect_ratio_idc , ps_bitstrm , 8 ) ; if ( ps_vui -> u1_aspect_ratio_idc == EXTENDED_SAR ) { BITS_PARSE ( "sar_width" , ps_vui -> u2_sar_width , ps_bitstrm , 16 ) ; BITS_PARSE ( "sar_height" , ps_vui -> u2_sar_height , ps_bitstrm , 16 ) ; } } BITS_PARSE ( "overscan_info_present_flag" , ps_vui -> u1_overscan_info_present_flag , ps_bitstrm , 1 ) ; ps_vui -> u1_overscan_appropriate_flag = 0 ; if ( ps_vui -> u1_overscan_info_present_flag ) BITS_PARSE ( "overscan_appropriate_flag" , ps_vui -> u1_overscan_appropriate_flag , ps_bitstrm , 1 ) ; BITS_PARSE ( "video_signal_type_present_flag" , ps_vui -> u1_video_signal_type_present_flag , ps_bitstrm , 1 ) ; ps_vui -> u1_video_format = VID_FMT_UNSPECIFIED ; ps_vui -> u1_video_full_range_flag = 0 ; ps_vui -> u1_colour_description_present_flag = 0 ; ps_vui -> u1_colour_primaries = 2 ; ps_vui -> u1_transfer_characteristics = 2 ; ps_vui -> u1_matrix_coefficients = 2 ; if ( ps_vui -> u1_video_signal_type_present_flag ) { BITS_PARSE ( "video_format" , ps_vui -> u1_video_format , ps_bitstrm , 3 ) ; BITS_PARSE ( "video_full_range_flag" , ps_vui -> u1_video_full_range_flag , ps_bitstrm , 1 ) ; BITS_PARSE ( "colour_description_present_flag" , ps_vui -> u1_colour_description_present_flag , ps_bitstrm , 1 ) ; if ( ps_vui -> u1_colour_description_present_flag ) { BITS_PARSE ( "colour_primaries" , ps_vui -> u1_colour_primaries , ps_bitstrm , 8 ) ; BITS_PARSE ( "transfer_characteristics" , ps_vui -> u1_transfer_characteristics , ps_bitstrm , 8 ) ; BITS_PARSE ( "matrix_coeffs" , ps_vui -> u1_matrix_coefficients , ps_bitstrm , 8 ) ; } } BITS_PARSE ( "chroma_loc_info_present_flag" , ps_vui -> u1_chroma_loc_info_present_flag , ps_bitstrm , 1 ) ; ps_vui -> u1_chroma_sample_loc_type_top_field = 0 ; ps_vui -> u1_chroma_sample_loc_type_bottom_field = 0 ; if ( ps_vui -> u1_chroma_loc_info_present_flag ) { UEV_PARSE ( "chroma_sample_loc_type_top_field" , ps_vui -> u1_chroma_sample_loc_type_top_field , ps_bitstrm ) ; UEV_PARSE ( "chroma_sample_loc_type_bottom_field" , ps_vui -> u1_chroma_sample_loc_type_bottom_field , ps_bitstrm ) ; } BITS_PARSE ( "neutral_chroma_indication_flag" , ps_vui -> u1_neutral_chroma_indication_flag , ps_bitstrm , 1 ) ; BITS_PARSE ( "field_seq_flag" , ps_vui -> u1_field_seq_flag , ps_bitstrm , 1 ) ; BITS_PARSE ( "frame_field_info_present_flag" , ps_vui -> u1_frame_field_info_present_flag , ps_bitstrm , 1 ) ; BITS_PARSE ( "default_display_window_flag" , ps_vui -> u1_default_display_window_flag , ps_bitstrm , 1 ) ; ps_vui -> u4_def_disp_win_left_offset = 0 ; ps_vui -> u4_def_disp_win_right_offset = 0 ; ps_vui -> u4_def_disp_win_top_offset = 0 ; ps_vui -> u4_def_disp_win_bottom_offset = 0 ; if ( ps_vui -> u1_default_display_window_flag ) { UEV_PARSE ( "def_disp_win_left_offset" , ps_vui -> u4_def_disp_win_left_offset , ps_bitstrm ) ; UEV_PARSE ( "def_disp_win_right_offset" , ps_vui -> u4_def_disp_win_right_offset , ps_bitstrm ) ; UEV_PARSE ( "def_disp_win_top_offset" , ps_vui -> u4_def_disp_win_top_offset , ps_bitstrm ) ; UEV_PARSE ( "def_disp_win_bottom_offset" , ps_vui -> u4_def_disp_win_bottom_offset , ps_bitstrm ) ; } BITS_PARSE ( "vui_timing_info_present_flag" , ps_vui -> u1_vui_timing_info_present_flag , ps_bitstrm , 1 ) ; if ( ps_vui -> u1_vui_timing_info_present_flag ) { BITS_PARSE ( "vui_num_units_in_tick" , ps_vui -> u4_vui_num_units_in_tick , ps_bitstrm , 32 ) ; BITS_PARSE ( "vui_time_scale" , ps_vui -> u4_vui_time_scale , ps_bitstrm , 32 ) ; BITS_PARSE ( "vui_poc_proportional_to_timing_flag" , ps_vui -> u1_poc_proportional_to_timing_flag , ps_bitstrm , 1 ) ; if ( ps_vui -> u1_poc_proportional_to_timing_flag ) UEV_PARSE ( "vui_num_ticks_poc_diff_one_minus1" , ps_vui -> u1_num_ticks_poc_diff_one_minus1 , ps_bitstrm ) ; BITS_PARSE ( "vui_hrd_parameters_present_flag" , ps_vui -> u1_vui_hrd_parameters_present_flag , ps_bitstrm , 1 ) ; if ( ps_vui -> u1_vui_hrd_parameters_present_flag ) ihevcd_parse_hrd_parameters ( ps_bitstrm , & ps_vui -> s_vui_hrd_parameters , 1 , sps_max_sub_layers_minus1 ) ; } BITS_PARSE ( "bitstream_restriction_flag" , ps_vui -> u1_bitstream_restriction_flag , ps_bitstrm , 1 ) ; ps_vui -> u1_tiles_fixed_structure_flag = 0 ; ps_vui -> u1_motion_vectors_over_pic_boundaries_flag = 1 ; ps_vui -> u1_restricted_ref_pic_lists_flag = 0 ; ps_vui -> u4_min_spatial_segmentation_idc = 0 ; ps_vui -> u1_max_bytes_per_pic_denom = 2 ; ps_vui -> u1_max_bits_per_mincu_denom = 1 ; ps_vui -> u1_log2_max_mv_length_horizontal = 15 ; ps_vui -> u1_log2_max_mv_length_vertical = 15 ; if ( ps_vui -> u1_bitstream_restriction_flag ) { BITS_PARSE ( "tiles_fixed_structure_flag" , ps_vui -> u1_tiles_fixed_structure_flag , ps_bitstrm , 1 ) ; BITS_PARSE ( "motion_vectors_over_pic_boundaries_flag" , ps_vui -> u1_motion_vectors_over_pic_boundaries_flag , ps_bitstrm , 1 ) ; BITS_PARSE ( "restricted_ref_pic_lists_flag" , ps_vui -> u1_restricted_ref_pic_lists_flag , ps_bitstrm , 1 ) ; UEV_PARSE ( "min_spatial_segmentation_idc" , ps_vui -> u4_min_spatial_segmentation_idc , ps_bitstrm ) ; UEV_PARSE ( "max_bytes_per_pic_denom" , ps_vui -> u1_max_bytes_per_pic_denom , ps_bitstrm ) ; UEV_PARSE ( "max_bits_per_min_cu_denom" , ps_vui -> u1_max_bits_per_mincu_denom , ps_bitstrm ) ; UEV_PARSE ( "log2_max_mv_length_horizontal" , ps_vui -> u1_log2_max_mv_length_horizontal , ps_bitstrm ) ; UEV_PARSE ( "log2_max_mv_length_vertical" , ps_vui -> u1_log2_max_mv_length_vertical , ps_bitstrm ) ; } return ret ; }
jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; size_t size ; matrix = 0 ; if ( numrows < 0 || numcols < 0 ) { goto error ; } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { goto error ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { goto error ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { goto error ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ; }
bool ParseScript ( Isolate * isolate , ParseInfo * parse_info , bool compile_as_well , std :: vector < FunctionLiteral * > * literals , debug :: LiveEditResult * result ) { parse_info -> set_eager ( ) ; v8 :: TryCatch try_catch ( reinterpret_cast < v8 :: Isolate * > ( isolate ) ) ; Handle < SharedFunctionInfo > shared ; bool success = false ; if ( compile_as_well ) { success = Compiler :: CompileForLiveEdit ( parse_info , isolate ) . ToHandle ( & shared ) ; } else { success = parsing :: ParseProgram ( parse_info , isolate ) ; if ( success ) { success = Compiler :: Analyze ( parse_info ) ; parse_info -> ast_value_factory ( ) -> Internalize ( isolate ) ; } } if ( ! success ) { isolate -> OptionalRescheduleException ( false ) ; DCHECK ( try_catch . HasCaught ( ) ) ; result -> message = try_catch . Message ( ) -> Get ( ) ; auto self = Utils :: OpenHandle ( * try_catch . Message ( ) ) ; auto msg = i :: Handle < i :: JSMessageObject > :: cast ( self ) ; result -> line_number = msg -> GetLineNumber ( ) ; result -> column_number = msg -> GetColumnNumber ( ) ; result -> status = debug :: LiveEditResult :: COMPILE_ERROR ; return false ; } CollectFunctionLiterals ( isolate , parse_info -> literal ( ) ) . Run ( literals ) ; return true ; }
void opj_image_comp_header_update ( opj_image_t * p_image_header , const struct opj_cp * p_cp ) { OPJ_UINT32 i , l_width , l_height ; OPJ_UINT32 l_x0 , l_y0 , l_x1 , l_y1 ; OPJ_UINT32 l_comp_x0 , l_comp_y0 , l_comp_x1 , l_comp_y1 ; opj_image_comp_t * l_img_comp = NULL ; l_x0 = opj_uint_max ( p_cp -> tx0 , p_image_header -> x0 ) ; l_y0 = opj_uint_max ( p_cp -> ty0 , p_image_header -> y0 ) ; l_x1 = p_cp -> tx0 + ( p_cp -> tw - 1U ) * p_cp -> tdx ; l_y1 = p_cp -> ty0 + ( p_cp -> th - 1U ) * p_cp -> tdy ; l_x1 = opj_uint_min ( opj_uint_adds ( l_x1 , p_cp -> tdx ) , p_image_header -> x1 ) ; l_y1 = opj_uint_min ( opj_uint_adds ( l_y1 , p_cp -> tdy ) , p_image_header -> y1 ) ; l_img_comp = p_image_header -> comps ; for ( i = 0 ; i < p_image_header -> numcomps ; ++ i ) { l_comp_x0 = opj_uint_ceildiv ( l_x0 , l_img_comp -> dx ) ; l_comp_y0 = opj_uint_ceildiv ( l_y0 , l_img_comp -> dy ) ; l_comp_x1 = opj_uint_ceildiv ( l_x1 , l_img_comp -> dx ) ; l_comp_y1 = opj_uint_ceildiv ( l_y1 , l_img_comp -> dy ) ; l_width = opj_uint_ceildivpow2 ( l_comp_x1 - l_comp_x0 , l_img_comp -> factor ) ; l_height = opj_uint_ceildivpow2 ( l_comp_y1 - l_comp_y0 , l_img_comp -> factor ) ; l_img_comp -> w = l_width ; l_img_comp -> h = l_height ; l_img_comp -> x0 = l_comp_x0 ; l_img_comp -> y0 = l_comp_y0 ; ++ l_img_comp ; } }
process_secondary_order ( STREAM s ) { uint16 length ; uint16 flags ; uint8 type ; uint8 * next_order ; in_uint16_le ( s , length ) ; in_uint16_le ( s , flags ) ; in_uint8 ( s , type ) ; next_order = s -> p + ( sint16 ) length + 7 ; switch ( type ) { case RDP_ORDER_RAW_BMPCACHE : process_raw_bmpcache ( s ) ; break ; case RDP_ORDER_COLCACHE : process_colcache ( s ) ; break ; case RDP_ORDER_BMPCACHE : process_bmpcache ( s ) ; break ; case RDP_ORDER_FONTCACHE : process_fontcache ( s ) ; break ; case RDP_ORDER_RAW_BMPCACHE2 : process_bmpcache2 ( s , flags , False ) ; break ; case RDP_ORDER_BMPCACHE2 : process_bmpcache2 ( s , flags , True ) ; break ; case RDP_ORDER_BRUSHCACHE : process_brushcache ( s , flags ) ; break ; default : logger ( Graphics , Warning , "process_secondary_order(), unhandled secondary order %d" , type ) ; } s -> p = next_order ; }
static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; OPJ_UNUSED ( p_manager ) ; opj_write_bytes ( p_data , J2K_MS_SOT , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , 10 , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , 2 ) ; p_data += 2 ; p_data += 4 ; opj_write_bytes ( p_data , p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , 1 ) ; ++ p_data ; opj_write_bytes ( p_data , p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , 1 ) ; ++ p_data ; #ifdef USE_JPWL assert ( 0 && "TODO" ) ; #endif /* USE_JPWL */ * p_data_written = 12 ; return OPJ_TRUE ; }
nsresult MediaEngineRemoteVideoSource :: Start ( ) { LOG ( "%s" , __PRETTY_FUNCTION__ ) ; AssertIsOnOwningThread ( ) ; MOZ_ASSERT ( mState == kAllocated || mState == kStopped ) ; MOZ_ASSERT ( mInitDone ) ; MOZ_ASSERT ( mTrack ) ; { MutexAutoLock lock ( mMutex ) ; mState = kStarted ; } mSettingsUpdatedByFrame -> mValue = false ; if ( camera :: GetChildAndCall ( & camera :: CamerasChild :: StartCapture , mCapEngine , mCaptureIndex , mCapability , this ) ) { LOG ( "StartCapture failed" ) ; MutexAutoLock lock ( mMutex ) ; mState = kStopped ; return NS_ERROR_FAILURE ; } NS_DispatchToMainThread ( NS_NewRunnableFunction ( "MediaEngineRemoteVideoSource::SetLastCapability" , [ settings = mSettings , updated = mSettingsUpdatedByFrame , capEngine = mCapEngine , cap = mCapability ] ( ) mutable { switch ( capEngine ) { case camera :: ScreenEngine : case camera :: WinEngine : cap . width = std :: min ( cap . width > > 16 , cap . width & 0xffff ) ; cap . height = std :: min ( cap . height > > 16 , cap . height & 0xffff ) ; break ; default : break ; } if ( ! updated -> mValue ) { settings -> mWidth . Value ( ) = cap . width ; settings -> mHeight . Value ( ) = cap . height ; } settings -> mFrameRate . Value ( ) = cap . maxFPS ; } ) ) ; return NS_OK ; }
status_t SampleTable :: setCompositionTimeToSampleParams ( off64_t data_offset , size_t data_size ) { ALOGI ( "There are reordered frames present." ) ; if ( mCompositionTimeDeltaEntries != NULL || data_size < 8 ) { return ERROR_MALFORMED ; } uint8_t header [ 8 ] ; if ( mDataSource -> readAt ( data_offset , header , sizeof ( header ) ) < ( ssize_t ) sizeof ( header ) ) { return ERROR_IO ; } if ( U32_AT ( header ) != 0 ) { return ERROR_MALFORMED ; } size_t numEntries = U32_AT ( & header [ 4 ] ) ; if ( data_size != ( numEntries + 1 ) * 8 ) { return ERROR_MALFORMED ; } mNumCompositionTimeDeltaEntries = numEntries ; mCompositionTimeDeltaEntries = new uint32_t [ 2 * numEntries ] ; if ( mDataSource -> readAt ( data_offset + 8 , mCompositionTimeDeltaEntries , numEntries * 8 ) < ( ssize_t ) numEntries * 8 ) { delete [ ] mCompositionTimeDeltaEntries ; mCompositionTimeDeltaEntries = NULL ; return ERROR_IO ; } for ( size_t i = 0 ; i < 2 * numEntries ; ++ i ) { mCompositionTimeDeltaEntries [ i ] = ntohl ( mCompositionTimeDeltaEntries [ i ] ) ; } mCompositionDeltaLookup -> setEntries ( mCompositionTimeDeltaEntries , mNumCompositionTimeDeltaEntries ) ; return OK ; }
bgp_open_option_parse ( struct peer * peer , u_char length , int * capability ) { int ret ; u_char * end ; u_char opt_type ; u_char opt_length ; u_char * pnt ; u_char * error ; u_char error_data [ BGP_MAX_PACKET_SIZE ] ; pnt = stream_pnt ( peer -> ibuf ) ; ret = 0 ; opt_type = 0 ; opt_length = 0 ; end = pnt + length ; error = error_data ; if ( BGP_DEBUG ( normal , NORMAL ) ) zlog_debug ( "%s rcv OPEN w/ OPTION parameter len: %u" , peer -> host , length ) ; while ( pnt < end ) { if ( pnt + 2 > end ) { zlog_info ( "%s Option length error" , peer -> host ) ; bgp_notify_send ( peer , BGP_NOTIFY_CEASE , 0 ) ; return - 1 ; } opt_type = * pnt ++ ; opt_length = * pnt ++ ; if ( pnt + opt_length > end ) { zlog_info ( "%s Option length error" , peer -> host ) ; bgp_notify_send ( peer , BGP_NOTIFY_CEASE , 0 ) ; return - 1 ; } if ( BGP_DEBUG ( normal , NORMAL ) ) zlog_debug ( "%s rcvd OPEN w/ optional parameter type %u (%s) len %u" , peer -> host , opt_type , opt_type == BGP_OPEN_OPT_AUTH ? "Authentication" : opt_type == BGP_OPEN_OPT_CAP ? "Capability" : "Unknown" , opt_length ) ; switch ( opt_type ) { case BGP_OPEN_OPT_AUTH : ret = bgp_auth_parse ( peer , pnt , opt_length ) ; break ; case BGP_OPEN_OPT_CAP : ret = bgp_capability_parse ( peer , pnt , opt_length , & error ) ; * capability = 1 ; break ; default : bgp_notify_send ( peer , BGP_NOTIFY_OPEN_ERR , BGP_NOTIFY_OPEN_UNSUP_PARAM ) ; ret = - 1 ; break ; } if ( ret < 0 ) return - 1 ; pnt += opt_length ; } if ( CHECK_FLAG ( peer -> flags , PEER_FLAG_STRICT_CAP_MATCH ) ) { if ( error != error_data ) { bgp_notify_send_with_data ( peer , BGP_NOTIFY_OPEN_ERR , BGP_NOTIFY_OPEN_UNSUP_CAPBL , error_data , error - error_data ) ; return - 1 ; } if ( ! strict_capability_same ( peer ) ) { bgp_notify_send ( peer , BGP_NOTIFY_OPEN_ERR , BGP_NOTIFY_OPEN_UNSUP_CAPBL ) ; return - 1 ; } } if ( * capability && ! CHECK_FLAG ( peer -> flags , PEER_FLAG_OVERRIDE_CAPABILITY ) ) { if ( ! peer -> afc_nego [ AFI_IP ] [ SAFI_UNICAST ] && ! peer -> afc_nego [ AFI_IP ] [ SAFI_MULTICAST ] && ! peer -> afc_nego [ AFI_IP ] [ SAFI_MPLS_VPN ] && ! peer -> afc_nego [ AFI_IP6 ] [ SAFI_UNICAST ] && ! peer -> afc_nego [ AFI_IP6 ] [ SAFI_MULTICAST ] ) { plog_err ( peer -> log , "%s [Error] No common capability" , peer -> host ) ; if ( error != error_data ) bgp_notify_send_with_data ( peer , BGP_NOTIFY_OPEN_ERR , BGP_NOTIFY_OPEN_UNSUP_CAPBL , error_data , error - error_data ) ; else bgp_notify_send ( peer , BGP_NOTIFY_OPEN_ERR , BGP_NOTIFY_OPEN_UNSUP_CAPBL ) ; return - 1 ; } } return 0 ; }
static int ntlm_decode_u16l_str_hdr ( struct ntlm_ctx * ctx , struct wire_field_hdr * str_hdr , struct ntlm_buffer * buffer , size_t payload_offs , char * * str ) { char * in , * out = NULL ; uint16_t str_len ; uint32_t str_offs ; size_t outlen ; int ret = 0 ; str_len = le16toh ( str_hdr -> len ) ; if ( str_len == 0 ) goto done ; str_offs = le32toh ( str_hdr -> offset ) ; if ( ( str_offs < payload_offs ) || ( str_offs > buffer -> length ) || ( UINT32_MAX - str_offs < str_len ) || ( str_offs + str_len > buffer -> length ) ) { return ERR_DECODE ; } in = ( char * ) & buffer -> data [ str_offs ] ; out = malloc ( str_len * 2 + 1 ) ; if ( ! out ) return ENOMEM ; ret = ntlm_str_convert ( ctx -> to_oem , in , out , str_len , & outlen ) ; out [ outlen ] = '\0' ; done : if ( ret ) { safefree ( out ) ; } * str = out ; return ret ; }
* / return ( image ) ; } static Image * ReadPNGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType logging , status ; MngInfo * mng_info ; char magic_number [ MaxTextExtent ] ; ssize_t count ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "Enter ReadPNGImage()" ) ; image = AcquireImage ( image_info ) ; mng_info = ( MngInfo * ) NULL ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( FileOpenError , "UnableToOpenFile" ) ; count = ReadBlob ( image , 8 , ( unsigned char * ) magic_number ) ; if ( count < 8 || memcmp ( magic_number , "\211PNG\r\n\032\n" , 8 ) != 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; mng_info = ( MngInfo * ) AcquireMagickMemory ( sizeof ( MngInfo ) ) ; if ( mng_info == ( MngInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( mng_info , 0 , sizeof ( MngInfo ) ) ; mng_info -> image = image ; image = ReadOnePNGImage ( mng_info , image_info , exception ) ; mng_info = MngInfoFreeStruct ( mng_info ) ; if ( image == ( Image * ) NULL ) { if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "exit ReadPNGImage() with error" ) ; return ( ( Image * ) NULL ) ; } ( void ) CloseBlob ( image ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) { if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "exit ReadPNGImage() with error." ) ; ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; } if ( ( IssRGBColorspace ( image -> colorspace ) != MagickFalse ) && ( ( image -> gamma < .45 ) || ( image -> gamma > .46 ) ) && ! ( image -> chromaticity . red_primary . x > 0.6399f && image -> chromaticity . red_primary . x < 0.6401f && image -> chromaticity . red_primary . y > 0.3299f && image -> chromaticity . red_primary . y < 0.3301f && image -> chromaticity . green_primary . x > 0.2999f && image -> chromaticity . green_primary . x < 0.3001f && image -> chromaticity . green_primary . y > 0.5999f && image -> chromaticity . green_primary . y < 0.6001f && image -> chromaticity . blue_primary . x > 0.1499f && image -> chromaticity . blue_primary . x < 0.1501f && image -> chromaticity . blue_primary . y > 0.0599f && image -> chromaticity . blue_primary . y < 0.0601f && image -> chromaticity . white_point . x > 0.3126f && image -> chromaticity . white_point . x < 0.3128f && image -> chromaticity . white_point . y > 0.3289f && image -> chromaticity . white_point . y < 0.3291f ) ) SetImageColorspace ( image , RGBColorspace ) ; if ( logging != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "  page.w: %.20g, page.h: %.20g,page.x: %.20g, page.y: %.20g." , ( double ) image -> page . width , ( double ) image -> page . height ,
void nsHistory :: Back ( ErrorResult & aRv ) { nsCOMPtr < nsPIDOMWindowInner > win ( do_QueryReferent ( mInnerWindow ) ) ; if ( ! win || ! win -> HasActiveDocument ( ) ) { aRv . Throw ( NS_ERROR_DOM_SECURITY_ERR ) ; return ; } RefPtr < ChildSHistory > sHistory = GetSessionHistory ( ) ; if ( ! sHistory ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return ; } if ( StaticPrefs :: dom_window_history_async ( ) ) { sHistory -> AsyncGo ( - 1 , false ) ; } else { sHistory -> Go ( - 1 , false , IgnoreErrors ( ) ) ; } }
png_have_neon ( png_structp png_ptr ) { FILE * f = fopen ( "/proc/cpuinfo" , "rb" ) ; if ( f != NULL ) { static const char ch_feature [ ] = { 70 , 69 , 65 , 84 , 85 , 82 , 69 , 83 } ; static const char ch_neon [ ] = { 78 , 69 , 79 , 78 } ; enum { StartLine , Feature , Colon , StartTag , Neon , HaveNeon , SkipTag , SkipLine } state ; int counter ; for ( state = StartLine , counter = 0 ; ; ) { int ch = fgetc ( f ) ; if ( ch == EOF ) { fclose ( f ) ; return 0 ; } switch ( state ) { case StartLine : if ( ch <= 32 ) break ; counter = 0 ; state = Feature ; case Feature : if ( ( ch & ~ 0x20 ) == ch_feature [ counter ] ) { if ( ++ counter == ( sizeof ch_feature ) ) state = Colon ; break ; } state = SkipLine ; case SkipLine : skipLine : if ( ch != 10 && ch != 13 ) break ; state = StartLine ; break ; case Colon : if ( ch == 32 || ch == 9 ) break ; if ( ch == 58 ) { state = StartTag ; break ; } state = SkipLine ; goto skipLine ; case StartTag : if ( ch == 32 || ch == 9 ) break ; state = Neon ; counter = 0 ; case Neon : if ( ( ch & ~ 0x20 ) == ch_neon [ counter ] ) { if ( ++ counter == ( sizeof ch_neon ) ) state = HaveNeon ; break ; } state = SkipTag ; case SkipTag : if ( ch == 10 || ch == 13 ) state = StartLine ; else if ( ch == 32 || ch == 9 ) state = StartTag ; break ; case HaveNeon : if ( ch == 10 || ch == 13 || ch == 32 || ch == 9 ) { fclose ( f ) ; return 1 ; } state = SkipTag ; break ; default : png_error ( png_ptr , "png_have_neon: internal error (bug)" ) ; } } } else png_warning ( png_ptr , "/proc/cpuinfo open failed" ) ; return 0 ; }
Node * JSCreateLowering :: AllocateAliasedArguments ( Node * effect , Node * control , Node * context , Node * arguments_frame , Node * arguments_length , const SharedFunctionInfoRef & shared , bool * has_aliased_arguments ) { int parameter_count = shared . internal_formal_parameter_count ( ) ; if ( parameter_count == 0 ) { return graph ( ) -> NewNode ( simplified ( ) -> NewArgumentsElements ( 0 ) , arguments_frame , arguments_length , effect ) ; } int mapped_count = parameter_count ; * has_aliased_arguments = true ; Node * arguments = graph ( ) -> NewNode ( simplified ( ) -> NewArgumentsElements ( mapped_count ) , arguments_frame , arguments_length , effect ) ; AllocationBuilder a ( jsgraph ( ) , arguments , control ) ; a . AllocateArray ( mapped_count + 2 , factory ( ) -> sloppy_arguments_elements_map ( ) ) ; a . Store ( AccessBuilder :: ForFixedArraySlot ( 0 ) , context ) ; a . Store ( AccessBuilder :: ForFixedArraySlot ( 1 ) , arguments ) ; for ( int i = 0 ; i < mapped_count ; ++ i ) { int idx = Context :: MIN_CONTEXT_SLOTS + parameter_count - 1 - i ; Node * value = graph ( ) -> NewNode ( common ( ) -> Select ( MachineRepresentation :: kTagged ) , graph ( ) -> NewNode ( simplified ( ) -> NumberLessThan ( ) , jsgraph ( ) -> Constant ( i ) , arguments_length ) , jsgraph ( ) -> Constant ( idx ) , jsgraph ( ) -> TheHoleConstant ( ) ) ; a . Store ( AccessBuilder :: ForFixedArraySlot ( i + 2 ) , value ) ; } return a . Finish ( ) ; }
jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; long rem ; value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; value -> tv_usec = rem / NSEC_PER_USEC ; }
char * _multi_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { return in ; } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( len + 2 ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\0' ; chr [ len ++ ] = '\0' ; return chr ; }
Handle < JSArray > GetCustomSections ( Isolate * isolate , Handle < WasmModuleObject > module_object , Handle < String > name , ErrorThrower * thrower ) { Factory * factory = isolate -> factory ( ) ; Vector < const uint8_t > wire_bytes = module_object -> native_module ( ) -> wire_bytes ( ) ; std :: vector < CustomSectionOffset > custom_sections = DecodeCustomSections ( wire_bytes . start ( ) , wire_bytes . end ( ) ) ; std :: vector < Handle < Object > > matching_sections ; for ( auto & section : custom_sections ) { MaybeHandle < String > section_name = WasmModuleObject :: ExtractUtf8StringFromModuleBytes ( isolate , module_object , section . name ) ; if ( ! name -> Equals ( * section_name . ToHandleChecked ( ) ) ) continue ; size_t size = section . payload . length ( ) ; void * memory = size == 0 ? nullptr : isolate -> array_buffer_allocator ( ) -> Allocate ( size ) ; if ( size && ! memory ) { thrower -> RangeError ( "out of memory allocating custom section data" ) ; return Handle < JSArray > ( ) ; } Handle < JSArrayBuffer > buffer = isolate -> factory ( ) -> NewJSArrayBuffer ( ) ; constexpr bool is_external = false ; JSArrayBuffer :: Setup ( buffer , isolate , is_external , memory , size ) ; memcpy ( memory , wire_bytes . start ( ) + section . payload . offset ( ) , section . payload . length ( ) ) ; matching_sections . push_back ( buffer ) ; } int num_custom_sections = static_cast < int > ( matching_sections . size ( ) ) ; Handle < JSArray > array_object = factory -> NewJSArray ( PACKED_ELEMENTS , 0 , 0 ) ; Handle < FixedArray > storage = factory -> NewFixedArray ( num_custom_sections ) ; JSArray :: SetContent ( array_object , storage ) ; array_object -> set_length ( Smi :: FromInt ( num_custom_sections ) ) ; for ( int i = 0 ; i < num_custom_sections ; i ++ ) { storage -> set ( i , * matching_sections [ i ] ) ; } return array_object ; }
static long madvise_remove ( struct vm_area_struct * vma , struct vm_area_struct * * prev , unsigned long start , unsigned long end ) { loff_t offset ; int error ; * prev = NULL ; if ( vma -> vm_flags & ( VM_LOCKED | VM_NONLINEAR | VM_HUGETLB ) ) return - EINVAL ; if ( ! vma -> vm_file || ! vma -> vm_file -> f_mapping || ! vma -> vm_file -> f_mapping -> host ) { return - EINVAL ; } if ( ( vma -> vm_flags & ( VM_SHARED | VM_WRITE ) ) != ( VM_SHARED | VM_WRITE ) ) return - EACCES ; offset = ( loff_t ) ( start - vma -> vm_start ) + ( ( loff_t ) vma -> vm_pgoff < < PAGE_SHIFT ) ; up_read ( & current -> mm -> mmap_sem ) ; error = do_fallocate ( vma -> vm_file , FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE , offset , end - start ) ; down_read ( & current -> mm -> mmap_sem ) ; return error ; }
PJ_DEF ( void ) pj_scan_advance_n ( pj_scanner * scanner , unsigned N , pj_bool_t skip_ws ) { if ( scanner -> curptr + N > scanner -> end ) { pj_scan_syntax_err ( scanner ) ; return ; } scanner -> curptr += N ; if ( PJ_SCAN_IS_PROBABLY_SPACE ( * scanner -> curptr ) && skip_ws ) { pj_scan_skip_whitespace ( scanner ) ; } }
bool NuPlayer :: CCDecoder :: parseDTVCCPacket ( int64_t timeUs , const uint8_t * data , size_t size ) { ABitReader br ( data , size ) ; br . skipBits ( 2 ) ; size_t packet_size = br . getBits ( 6 ) ; if ( packet_size == 0 ) packet_size = 64 ; packet_size *= 2 ; if ( size != packet_size ) { return false ; } bool trackAdded = false ; while ( br . numBitsLeft ( ) >= 16 ) { uint8_t service_number = br . getBits ( 3 ) ; size_t block_size = br . getBits ( 5 ) ; if ( service_number == 64 ) { br . skipBits ( 2 ) ; service_number = br . getBits ( 6 ) ; if ( service_number < 64 ) { return trackAdded ; } } if ( br . numBitsLeft ( ) < block_size * 8 ) { return trackAdded ; } if ( block_size > 0 ) { size_t trackIndex = getTrackIndex ( kTrackTypeCEA708 , service_number , & trackAdded ) ; if ( mSelectedTrack == ( ssize_t ) trackIndex ) { sp < ABuffer > ccPacket = new ABuffer ( block_size ) ; memcpy ( ccPacket -> data ( ) , br . data ( ) , block_size ) ; mCCMap . add ( timeUs , ccPacket ) ; } } br . skipBits ( block_size * 8 ) ; } return trackAdded ; }
static pj_status_t decode_errcode_attr ( pj_pool_t * pool , const pj_uint8_t * buf , const pj_stun_msg_hdr * msghdr , void * * p_attr ) { pj_stun_errcode_attr * attr ; pj_str_t value ; PJ_UNUSED_ARG ( msghdr ) ; attr = PJ_POOL_ZALLOC_T ( pool , pj_stun_errcode_attr ) ; GETATTRHDR ( buf , & attr -> hdr ) ; attr -> err_code = buf [ 6 ] * 100 + buf [ 7 ] ; value . ptr = ( ( char * ) buf + ATTR_HDR_LEN + 4 ) ; value . slen = attr -> hdr . length - 4 ; if ( value . slen < 0 ) value . slen = 0 ; pj_strdup ( pool , & attr -> reason , & value ) ; * p_attr = attr ; return PJ_SUCCESS ; }
static void aio_poll_complete_work ( struct work_struct * work ) { struct poll_iocb * req = container_of ( work , struct poll_iocb , work ) ; struct aio_kiocb * iocb = container_of ( req , struct aio_kiocb , poll ) ; struct poll_table_struct pt = { . _key = req -> events } ; struct kioctx * ctx = iocb -> ki_ctx ; __poll_t mask = 0 ; if ( ! READ_ONCE ( req -> cancelled ) ) mask = vfs_poll ( req -> file , & pt ) & req -> events ; spin_lock_irq ( & ctx -> ctx_lock ) ; if ( ! mask && ! READ_ONCE ( req -> cancelled ) ) { add_wait_queue ( req -> head , & req -> wait ) ; spin_unlock_irq ( & ctx -> ctx_lock ) ; return ; } list_del_init ( & iocb -> ki_list ) ; iocb -> ki_res . res = mangle_poll ( mask ) ; req -> done = true ; spin_unlock_irq ( & ctx -> ctx_lock ) ; iocb_put ( iocb ) ; }
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
MediaResource * FileMediaResource :: CloneData ( MediaDecoder * aDecoder ) { NS_ASSERTION ( NS_IsMainThread ( ) , "Only call on main thread" ) ; MediaDecoderOwner * owner = mDecoder -> GetMediaOwner ( ) ; if ( ! owner ) { return nullptr ; } HTMLMediaElement * element = owner -> GetMediaElement ( ) ; if ( ! element ) { return nullptr ; } nsCOMPtr < nsILoadGroup > loadGroup = element -> GetDocumentLoadGroup ( ) ; NS_ENSURE_TRUE ( loadGroup , nullptr ) ; nsCOMPtr < nsIChannel > channel ; nsresult rv = NS_NewChannel ( getter_AddRefs ( channel ) , mURI , nullptr , loadGroup , nullptr , 0 ) ; if ( NS_FAILED ( rv ) ) return nullptr ; return new FileMediaResource ( aDecoder , channel , mURI , GetContentType ( ) ) ; }
int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) { struct page * page = vmf -> page ; loff_t size ; unsigned long len ; int ret ; struct file * file = vma -> vm_file ; struct inode * inode = file_inode ( file ) ; struct address_space * mapping = inode -> i_mapping ; handle_t * handle ; get_block_t * get_block ; int retries = 0 ; sb_start_pagefault ( inode -> i_sb ) ; file_update_time ( vma -> vm_file ) ; if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) { do { ret = block_page_mkwrite ( vma , vmf , ext4_da_get_block_prep ) ; } while ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) ; goto out_ret ; } lock_page ( page ) ; size = i_size_read ( inode ) ; if ( page -> mapping != mapping || page_offset ( page ) > size ) { unlock_page ( page ) ; ret = VM_FAULT_NOPAGE ; goto out ; } if ( page -> index == size > > PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { if ( ! ext4_walk_page_buffers ( NULL , page_buffers ( page ) , 0 , len , NULL , ext4_bh_unmapped ) ) { wait_for_stable_page ( page ) ; ret = VM_FAULT_LOCKED ; goto out ; } } unlock_page ( page ) ; if ( ext4_should_dioread_nolock ( inode ) ) get_block = ext4_get_block_write ; else get_block = ext4_get_block ; retry_alloc : handle = ext4_journal_start ( inode , EXT4_HT_WRITE_PAGE , ext4_writepage_trans_blocks ( inode ) ) ; if ( IS_ERR ( handle ) ) { ret = VM_FAULT_SIGBUS ; goto out ; } ret = block_page_mkwrite ( vma , vmf , get_block ) ; if ( ! ret && ext4_should_journal_data ( inode ) ) { if ( ext4_walk_page_buffers ( handle , page_buffers ( page ) , 0 , PAGE_CACHE_SIZE , NULL , do_journal_get_write_access ) ) { unlock_page ( page ) ; ret = VM_FAULT_SIGBUS ; ext4_journal_stop ( handle ) ; goto out ; } ext4_set_inode_state ( inode , EXT4_STATE_JDATA ) ; } ext4_journal_stop ( handle ) ; if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) goto retry_alloc ; out_ret : ret = block_page_mkwrite_return ( ret ) ; out : sb_end_pagefault ( inode -> i_sb ) ; return ret ; }
const Operator * JSOperatorBuilder :: CreateBlockContext ( const Handle < ScopeInfo > & scope_info ) { return new ( zone ( ) ) Operator1 < Handle < ScopeInfo > > ( IrOpcode :: kJSCreateBlockContext , Operator :: kNoProperties , "JSCreateBlockContext" , 0 , 1 , 1 , 1 , 1 , 2 , scope_info ) ; }
TfLiteStatus GatherStrings ( TfLiteContext * context , const TfLiteTensor * input , const TfLiteTensor * positions , TfLiteTensor * output ) { DynamicBuffer buffer ; const PositionT * indexes = GetTensorData < PositionT > ( positions ) ; const PositionT num_strings = GetStringCount ( input ) ; const int num_indexes = NumElements ( positions ) ; for ( int i = 0 ; i < num_indexes ; ++ i ) { const PositionT pos = indexes [ i ] ; TF_LITE_ENSURE ( context , pos < num_strings ) ; const auto string_ref = GetString ( input , pos ) ; buffer . AddString ( string_ref . str , string_ref . len ) ; } buffer . WriteToTensor ( output , nullptr ) ; return kTfLiteOk ; }
Reduction LoadElimination :: ReduceTransitionAndStoreElement ( Node * node ) { Node * const object = NodeProperties :: GetValueInput ( node , 0 ) ; Handle < Map > double_map ( DoubleMapParameterOf ( node -> op ( ) ) ) ; Handle < Map > fast_map ( FastMapParameterOf ( node -> op ( ) ) ) ; Node * const effect = NodeProperties :: GetEffectInput ( node ) ; AbstractState const * state = node_states_ . Get ( effect ) ; if ( state == nullptr ) return NoChange ( ) ; ZoneHandleSet < Map > object_maps ; if ( state -> LookupMaps ( object , & object_maps ) ) { object_maps . insert ( double_map , zone ( ) ) ; object_maps . insert ( fast_map , zone ( ) ) ; state = state -> KillMaps ( object , zone ( ) ) ; state = state -> SetMaps ( object , object_maps , zone ( ) ) ; } state = state -> KillField ( object , FieldIndexOf ( JSObject :: kElementsOffset ) , MaybeHandle < Name > ( ) , zone ( ) ) ; return UpdateState ( node , state ) ; }
RegExpObject :: createNoStatics ( ExclusiveContext * cx , HandleAtom source , RegExpFlag flags , TokenStream * tokenStream , LifoAlloc & alloc ) { Maybe < CompileOptions > dummyOptions ; Maybe < TokenStream > dummyTokenStream ; if ( ! tokenStream ) { dummyOptions . emplace ( cx -> asJSContext ( ) ) ; dummyTokenStream . emplace ( cx , * dummyOptions , ( const char16_t * ) nullptr , 0 , ( frontend :: StrictModeGetter * ) nullptr ) ; tokenStream = dummyTokenStream . ptr ( ) ; } if ( ! irregexp :: ParsePatternSyntax ( * tokenStream , alloc , source , flags & UnicodeFlag ) ) return nullptr ; Rooted < RegExpObject * > regexp ( cx , RegExpAlloc ( cx ) ) ; if ( ! regexp ) return nullptr ; if ( ! RegExpObject :: initFromAtom ( cx , regexp , source , flags ) ) return nullptr ; return regexp ; }
% % o image : the address of a structure of type Image . % % o data_size : The number of bits in the compressed packet . % * / static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size , ExceptionInfo * exception ) { #define MaxCode(number_bits)  ((one << (number_bits))-1) #define MaxHashTable  5003 #define MaxGIFBits  12UL #define MaxGIFTable  (1UL << MaxGIFBits) #define GIFOutputCode(code) \ { \   /*  \     Emit a code. \   */ \   if (bits > 0) \     datum|=(size_t) (code) << bits; \   else \     datum=(size_t) (code); \   bits+=number_bits; \   while (bits >= 8) \   { \     /*  \       Add a character to current packet. \     */ \     packet[length++]=(unsigned char) (datum & 0xff); \     if (length >= 254) \       { \         (void) WriteBlobByte(image,(unsigned char) length); \         (void) WriteBlob(image,length,packet); \         length=0; \       } \     datum>>=8; \     bits-=8; \   } \   if (free_code > max_code)  \     { \       number_bits++; \       if (number_bits == MaxGIFBits) \         max_code=MaxGIFTable; \       else \         max_code=MaxCode(number_bits); \     } \ } Quantum index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one < < ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const Quantum * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( p == ( const Quantum * ) NULL ) break ; if ( y == 0 ) { waiting_code = ( short ) GetPixelIndex ( image , p ) ; p += GetPixelChannels ( image ) ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ; p += GetPixelChannels ( image ) ; k = ( ssize_t ) ( ( ( size_t ) index < < ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; next_pixel = MagickFalse ; displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; }
static void __exit xfrm6_tunnel_fini ( void ) { unregister_pernet_subsys ( & xfrm6_tunnel_net_ops ) ; xfrm6_tunnel_spi_fini ( ) ; xfrm6_tunnel_deregister ( & xfrm46_tunnel_handler , AF_INET ) ; xfrm6_tunnel_deregister ( & xfrm6_tunnel_handler , AF_INET6 ) ; xfrm_unregister_type ( & xfrm6_tunnel_type , AF_INET6 ) ; }
int read_image_tga ( gdIOCtx * ctx , oTga * tga ) { int pixel_block_size = ( tga -> bits / 8 ) ; int image_block_size = ( tga -> width * tga -> height ) * pixel_block_size ; uint8_t * decompression_buffer = NULL ; unsigned char * conversion_buffer = NULL ; int buffer_caret = 0 ; int bitmap_caret = 0 ; int i = 0 ; int j = 0 ; uint8_t encoded_pixels ; if ( overflow2 ( tga -> width , tga -> height ) ) { return - 1 ; } if ( overflow2 ( tga -> width * tga -> height , pixel_block_size ) ) { return - 1 ; } if ( overflow2 ( image_block_size , sizeof ( int ) ) ) { return - 1 ; } if ( tga -> imagetype != TGA_TYPE_RGB && tga -> imagetype != TGA_TYPE_RGB_RLE ) return - 1 ; tga -> bitmap = ( int * ) gdMalloc ( image_block_size * sizeof ( int ) ) ; if ( tga -> bitmap == NULL ) return - 1 ; switch ( tga -> imagetype ) { case TGA_TYPE_RGB : conversion_buffer = ( unsigned char * ) gdMalloc ( image_block_size * sizeof ( unsigned char ) ) ; if ( conversion_buffer == NULL ) { return - 1 ; } if ( gdGetBuf ( conversion_buffer , image_block_size , ctx ) != image_block_size ) { gd_error ( "gd-tga: premature end of image data\n" ) ; gdFree ( conversion_buffer ) ; return - 1 ; } while ( buffer_caret < image_block_size ) { tga -> bitmap [ buffer_caret ] = ( int ) conversion_buffer [ buffer_caret ] ; buffer_caret ++ ; } gdFree ( conversion_buffer ) ; break ; case TGA_TYPE_RGB_RLE : decompression_buffer = ( uint8_t * ) gdMalloc ( image_block_size * sizeof ( uint8_t ) ) ; if ( decompression_buffer == NULL ) { return - 1 ; } conversion_buffer = ( unsigned char * ) gdMalloc ( image_block_size * sizeof ( unsigned char ) ) ; if ( conversion_buffer == NULL ) { gd_error ( "gd-tga: premature end of image data\n" ) ; gdFree ( decompression_buffer ) ; return - 1 ; } if ( gdGetBuf ( conversion_buffer , image_block_size , ctx ) != image_block_size ) { gdFree ( conversion_buffer ) ; gdFree ( decompression_buffer ) ; return - 1 ; } buffer_caret = 0 ; while ( buffer_caret < image_block_size ) { decompression_buffer [ buffer_caret ] = ( int ) conversion_buffer [ buffer_caret ] ; buffer_caret ++ ; } buffer_caret = 0 ; while ( bitmap_caret < image_block_size ) { if ( ( decompression_buffer [ buffer_caret ] & TGA_RLE_FLAG ) == TGA_RLE_FLAG ) { encoded_pixels = ( ( decompression_buffer [ buffer_caret ] & 127 ) + 1 ) ; buffer_caret ++ ; for ( i = 0 ; i < encoded_pixels ; i ++ ) { for ( j = 0 ; j < pixel_block_size ; j ++ , bitmap_caret ++ ) { tga -> bitmap [ bitmap_caret ] = decompression_buffer [ buffer_caret + j ] ; } } buffer_caret += pixel_block_size ; } else { encoded_pixels = decompression_buffer [ buffer_caret ] + 1 ; buffer_caret ++ ; for ( i = 0 ; i < encoded_pixels ; i ++ ) { for ( j = 0 ; j < pixel_block_size ; j ++ , bitmap_caret ++ ) { tga -> bitmap [ bitmap_caret ] = decompression_buffer [ buffer_caret + j ] ; } buffer_caret += pixel_block_size ; } } } gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; break ; } return 1 ; }
Symbol :: new_ ( ExclusiveContext * cx , JS :: SymbolCode code , JSString * description ) { JSAtom * atom = nullptr ; if ( description ) { atom = AtomizeString ( cx , description ) ; if ( ! atom ) return nullptr ; } AutoLockForExclusiveAccess lock ( cx ) ; AutoCompartment ac ( cx , cx -> atomsCompartment ( lock ) , & lock ) ; return newInternal ( cx , code , atom , lock ) ; }
ppdErrorString ( ppd_status_t status ) { static const char * const messages [ ] = { _ ( "OK" ) , _ ( "Unable to open PPD file" ) , _ ( "NULL PPD file pointer" ) , _ ( "Memory allocation error" ) , _ ( "Missing PPD-Adobe-4.x header" ) , _ ( "Missing value string" ) , _ ( "Internal error" ) , _ ( "Bad OpenGroup" ) , _ ( "OpenGroup without a CloseGroup first" ) , _ ( "Bad OpenUI/JCLOpenUI" ) , _ ( "OpenUI/JCLOpenUI without a CloseUI/JCLCloseUI first" ) , _ ( "Bad OrderDependency" ) , _ ( "Bad UIConstraints" ) , _ ( "Missing asterisk in column 1" ) , _ ( "Line longer than the maximum allowed (255 characters)" ) , _ ( "Illegal control character" ) , _ ( "Illegal main keyword string" ) , _ ( "Illegal option keyword string" ) , _ ( "Illegal translation string" ) , _ ( "Illegal whitespace character" ) , _ ( "Bad custom parameter" ) , _ ( "Missing option keyword" ) , _ ( "Bad value string" ) , _ ( "Missing CloseGroup" ) } ; if ( status < PPD_OK || status >= PPD_MAX_STATUS ) return ( _cupsLangString ( cupsLangDefault ( ) , _ ( "Unknown" ) ) ) ; else return ( _cupsLangString ( cupsLangDefault ( ) , messages [ status ] ) ) ; }
void vp9_save_layer_context ( VP9_COMP * const cpi ) { const VP9_CONFIG * const oxcf = & cpi -> oxcf ; LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; lc -> rc = cpi -> rc ; lc -> twopass = cpi -> twopass ; lc -> target_bandwidth = ( int ) oxcf -> target_bandwidth ; lc -> starting_buffer_level = oxcf -> starting_buffer_level ; lc -> optimal_buffer_level = oxcf -> optimal_buffer_level ; lc -> maximum_buffer_size = oxcf -> maximum_buffer_size ; lc -> framerate = cpi -> output_framerate ; }
void impeg2d_dec_pic_data_thread ( dec_state_t * ps_dec ) { WORD32 i4_continue_decode ; WORD32 i4_cur_row , temp ; UWORD32 u4_bits_read ; WORD32 i4_dequeue_job ; IMPEG2D_ERROR_CODES_T e_error ; i4_cur_row = ps_dec -> u2_mb_y + 1 ; i4_continue_decode = 1 ; i4_dequeue_job = 1 ; do { if ( i4_cur_row > ps_dec -> u2_num_vert_mb ) { i4_continue_decode = 0 ; break ; } { if ( ( ps_dec -> i4_num_cores > 1 ) && ( i4_dequeue_job ) ) { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; UWORD8 * pu1_buf ; e_ret = impeg2_jobq_dequeue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 1 ) ; if ( e_ret != IV_SUCCESS ) break ; if ( CMD_PROCESS == s_job . i4_cmd ) { pu1_buf = ps_dec -> pu1_inp_bits_buf + s_job . i4_bistream_ofst ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , pu1_buf , ( ps_dec -> u4_num_inp_bytes - s_job . i4_bistream_ofst ) ) ; i4_cur_row = s_job . i2_start_mb_y ; ps_dec -> i4_start_mb_y = s_job . i2_start_mb_y ; ps_dec -> i4_end_mb_y = s_job . i2_end_mb_y ; ps_dec -> u2_mb_x = 0 ; ps_dec -> u2_mb_y = ps_dec -> i4_start_mb_y ; ps_dec -> u2_num_mbs_left = ( ps_dec -> i4_end_mb_y - ps_dec -> i4_start_mb_y ) * ps_dec -> u2_num_horiz_mb ; } else { WORD32 start_row ; WORD32 num_rows ; start_row = s_job . i2_start_mb_y < < 4 ; num_rows = MIN ( ( s_job . i2_end_mb_y < < 4 ) , ps_dec -> u2_vertical_size ) ; num_rows -= start_row ; if ( ps_dec -> u4_deinterlace && ( 0 == ps_dec -> u2_progressive_frame ) ) { impeg2d_deinterlace ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , start_row , num_rows ) ; } else { impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , start_row , num_rows ) ; } break ; } } e_error = impeg2d_dec_slice ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { impeg2d_next_start_code ( ps_dec ) ; if ( ps_dec -> s_bit_stream . u4_offset >= ps_dec -> s_bit_stream . u4_max_offset ) { ps_dec -> u4_error_code = IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR ; return ; } } } while ( 1 ) { u4_bits_read = impeg2d_bit_stream_nxt ( & ps_dec -> s_bit_stream , START_CODE_LEN ) ; temp = u4_bits_read & 0xFF ; i4_continue_decode = ( ( ( u4_bits_read > > 8 ) == 0x01 ) && ( temp ) && ( temp <= 0xAF ) ) ; if ( 1 == ps_dec -> i4_num_cores && 0 == ps_dec -> u2_num_mbs_left ) { i4_continue_decode = 0 ; #ifdef __ANDROID__ android_errorWriteLog ( 0x534e4554 , "26070014" ) ; #endif } if ( i4_continue_decode ) { if ( ( temp - 1 ) == i4_cur_row ) { i4_dequeue_job = 0 ; break ; } if ( temp < ps_dec -> i4_end_mb_y ) { i4_cur_row = ps_dec -> u2_mb_y ; } else { i4_dequeue_job = 1 ; } break ; } else break ; } } while ( i4_continue_decode ) ; if ( ps_dec -> i4_num_cores > 1 ) { while ( 1 ) { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; e_ret = impeg2_jobq_dequeue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 1 ) ; if ( e_ret != IV_SUCCESS ) break ; if ( CMD_FMTCONV == s_job . i4_cmd ) { WORD32 start_row ; WORD32 num_rows ; start_row = s_job . i2_start_mb_y < < 4 ; num_rows = MIN ( ( s_job . i2_end_mb_y < < 4 ) , ps_dec -> u2_vertical_size ) ; num_rows -= start_row ; if ( ps_dec -> u4_deinterlace && ( 0 == ps_dec -> u2_progressive_frame ) ) { impeg2d_deinterlace ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , start_row , num_rows ) ; } else { impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , start_row , num_rows ) ; } } } } else { if ( ( NULL != ps_dec -> ps_disp_pic ) && ( ( 0 == ps_dec -> u4_share_disp_buf ) || ( IV_YUV_420P != ps_dec -> i4_chromaFormat ) ) ) { if ( ps_dec -> u4_deinterlace && ( 0 == ps_dec -> u2_progressive_frame ) ) { impeg2d_deinterlace ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , 0 , ps_dec -> u2_vertical_size ) ; } else { impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , 0 , ps_dec -> u2_vertical_size ) ; } } } }
static void sctp_generate_timeout_event ( struct sctp_association * asoc , sctp_event_timeout_t timeout_type ) { struct net * net = sock_net ( asoc -> base . sk ) ; int error = 0 ; bh_lock_sock ( asoc -> base . sk ) ; if ( sock_owned_by_user ( asoc -> base . sk ) ) { pr_debug ( "%s: sock is busy: timer %d\n" , __func__ , timeout_type ) ; if ( ! mod_timer ( & asoc -> timers [ timeout_type ] , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( timeout_type ) , asoc -> state , asoc -> ep , asoc , ( void * ) timeout_type , GFP_ATOMIC ) ; if ( error ) asoc -> base . sk -> sk_err = - error ; out_unlock : bh_unlock_sock ( asoc -> base . sk ) ; sctp_association_put ( asoc ) ; }
ft_gzip_get_uncompressed_size ( FT_Stream stream ) { FT_Error error ; FT_ULong old_pos ; FT_ULong result = 0 ; old_pos = stream -> pos ; if ( ! FT_Stream_Seek ( stream , stream -> size - 4 ) ) { result = FT_Stream_ReadULong ( stream , & error ) ; if ( error ) result = 0 ; ( void ) FT_Stream_Seek ( stream , old_pos ) ; } return result ; }
AudioContext :: DecodeAudioData ( const ArrayBuffer & aBuffer , DecodeSuccessCallback & aSuccessCallback , const Optional < OwningNonNull < DecodeErrorCallback > > & aFailureCallback ) { nsAutoCString contentType ; NS_SniffContent ( NS_DATA_SNIFFER_CATEGORY , nullptr , aBuffer . Data ( ) , aBuffer . Length ( ) , contentType ) ; nsRefPtr < DecodeErrorCallback > failureCallback ; if ( aFailureCallback . WasPassed ( ) ) { failureCallback = & aFailureCallback . Value ( ) ; } nsRefPtr < WebAudioDecodeJob > job ( new WebAudioDecodeJob ( contentType , this , aBuffer , & aSuccessCallback , failureCallback ) ) ; mDecoder . AsyncDecodeMedia ( contentType . get ( ) , aBuffer . Data ( ) , aBuffer . Length ( ) , * job ) ; mDecodeJobs . AppendElement ( job ) ; }
qedi_dbg_err ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; struct va_format vaf ; char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( "[%s]:[%s:%d]:%d: %pV" , dev_name ( & qedi -> pdev -> dev ) , nfunc , line , qedi -> host_no , & vaf ) ; else pr_err ( "[0000:00:00.0]:[%s:%d]: %pV" , nfunc , line , & vaf ) ; va_end ( va ) ; }
png_set_background_fixed ( png_structrp png_ptr , png_const_color_16p background_color , int background_gamma_code , int need_expand , png_fixed_point background_gamma ) { png_debug ( 1 , "in png_set_background_fixed" ) ; if ( ! png_rtran_ok ( png_ptr , 0 ) || background_color == NULL ) return ; if ( background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN ) { png_warning ( png_ptr , "Application must supply a known background gamma" ) ; return ; } png_ptr -> transformations |= PNG_COMPOSE | PNG_STRIP_ALPHA ; png_ptr -> transformations &= ~ PNG_ENCODE_ALPHA ; png_ptr -> flags &= ~ PNG_FLAG_OPTIMIZE_ALPHA ; png_ptr -> background = * background_color ; png_ptr -> background_gamma = background_gamma ; png_ptr -> background_gamma_type = ( png_byte ) ( background_gamma_code ) ; if ( need_expand ) png_ptr -> transformations |= PNG_BACKGROUND_EXPAND ; else png_ptr -> transformations &= ~ PNG_BACKGROUND_EXPAND ; }
static int parse_exports_table ( long long * table_start ) { int res ; int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ; long long export_index_table [ indexes ] ; res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk . s . inodes ) , export_index_table ) ; if ( res == FALSE ) { ERROR ( "parse_exports_table: failed to read export index table\n" ) ; return FALSE ; } SQUASHFS_INSWAP_LOOKUP_BLOCKS ( export_index_table , indexes ) ; * table_start = export_index_table [ 0 ] ; return TRUE ; }
nsLocalFile :: IsExecutable ( bool * aResult ) { CHECK_mPath ( ) ; if ( NS_WARN_IF ( ! aResult ) ) { return NS_ERROR_INVALID_ARG ; } bool symLink ; nsresult rv = IsSymlink ( & symLink ) ; if ( NS_FAILED ( rv ) ) { return rv ; } nsAutoString path ; if ( symLink ) { GetTarget ( path ) ; } else { GetPath ( path ) ; } int32_t dotIdx = path . RFindChar ( char16_t ( '.' ) ) ; if ( dotIdx != kNotFound ) { char16_t * p = path . BeginWriting ( ) ; for ( p += dotIdx + 1 ; * p ; ++ p ) { * p += ( * p >= L'A' && * p <= L'Z' ) ? 'a' - 'A' : 0 ; } static const char * const executableExts [ ] = { "air" , "jar" } ; nsDependentSubstring ext = Substring ( path , dotIdx + 1 ) ; for ( auto executableExt : executableExts ) { if ( ext . EqualsASCII ( executableExt ) ) { * aResult = true ; return NS_OK ; } } } #ifdef MOZ_WIDGET_COCOA CFURLRef url ; if ( NS_FAILED ( GetCFURL ( & url ) ) ) { return NS_ERROR_FAILURE ; } LSRequestedInfo theInfoRequest = kLSRequestAllInfo ; LSItemInfoRecord theInfo ; OSStatus result = :: LSCopyItemInfoForURL ( url , theInfoRequest , & theInfo ) ; :: CFRelease ( url ) ; if ( result == noErr ) { if ( ( theInfo . flags & kLSItemInfoIsApplication ) != 0 ) { * aResult = true ; return NS_OK ; } } #endif * aResult = ( access ( mPath . get ( ) , X_OK ) == 0 ) ; #ifdef SOLARIS if ( * aResult ) { struct STAT buf ; * aResult = ( STAT ( mPath . get ( ) , & buf ) == 0 ) ; if ( * aResult || errno == EACCES ) { * aResult = * aResult && ( buf . st_mode & ( S_IXUSR | S_IXGRP | S_IXOTH ) ) ; return NS_OK ; } return NSRESULT_FOR_ERRNO ( ) ; } #endif if ( * aResult || errno == EACCES ) { return NS_OK ; } return NSRESULT_FOR_ERRNO ( ) ; }
void next ( ) { if ( ! decoder_ . more ( ) ) { section_code_ = kUnknownSectionCode ; return ; } section_start_ = decoder_ . pc ( ) ; uint8_t section_code = decoder_ . consume_u8 ( "section code" ) ; uint32_t section_length = decoder_ . consume_u32v ( "section length" ) ; payload_start_ = decoder_ . pc ( ) ; if ( decoder_ . checkAvailable ( section_length ) ) { section_end_ = payload_start_ + section_length ; } else { section_end_ = payload_start_ ; } if ( section_code == kUnknownSectionCode ) { section_code = ModuleDecoder :: IdentifyUnknownSection ( decoder_ , section_end_ ) ; payload_start_ = decoder_ . pc ( ) ; } else if ( ! IsValidSectionCode ( section_code ) ) { decoder_ . errorf ( decoder_ . pc ( ) , "unknown section code #0x%02x" , section_code ) ; section_code = kUnknownSectionCode ; } section_code_ = decoder_ . failed ( ) ? kUnknownSectionCode : static_cast < SectionCode > ( section_code ) ; if ( section_code_ == kUnknownSectionCode && section_end_ > decoder_ . pc ( ) ) { uint32_t remaining = static_cast < uint32_t > ( section_end_ - decoder_ . pc ( ) ) ; decoder_ . consume_bytes ( remaining , "section payload" ) ; } }
void AccessorAssembler :: LoadGlobalIC_TryHandlerCase ( TNode < FeedbackVector > vector , Node * slot , const LazyNode < Context > & lazy_context , const LazyNode < Name > & lazy_name , TypeofMode typeof_mode , ExitPoint * exit_point , Label * miss , ParameterMode slot_mode ) { Comment ( "LoadGlobalIC_TryHandlerCase" ) ; Label call_handler ( this ) , non_smi ( this ) ; TNode < MaybeObject > feedback_element = LoadFeedbackVectorSlot ( vector , slot , kPointerSize , slot_mode ) ; TNode < Object > handler = CAST ( feedback_element ) ; GotoIf ( WordEqual ( handler , LoadRoot ( Heap :: kuninitialized_symbolRootIndex ) ) , miss ) ; OnNonExistent on_nonexistent = typeof_mode == NOT_INSIDE_TYPEOF ? OnNonExistent :: kThrowReferenceError : OnNonExistent :: kReturnUndefined ; TNode < Context > context = lazy_context ( ) ; TNode < Context > native_context = LoadNativeContext ( context ) ; TNode < JSGlobalProxy > receiver = CAST ( LoadContextElement ( native_context , Context :: GLOBAL_PROXY_INDEX ) ) ; Node * holder = LoadContextElement ( native_context , Context :: EXTENSION_INDEX ) ; LoadICParameters p ( context , receiver , lazy_name ( ) , ParameterToTagged ( slot , slot_mode ) , vector , holder ) ; HandleLoadICHandlerCase ( & p , handler , miss , exit_point , ICMode :: kGlobalIC , on_nonexistent ) ; }
Handle < BreakPoint > Factory :: NewBreakPoint ( int id , Handle < String > condition ) { Handle < BreakPoint > new_break_point = Handle < BreakPoint > :: cast ( NewStruct ( TUPLE2_TYPE , TENURED ) ) ; new_break_point -> set_id ( id ) ; new_break_point -> set_condition ( * condition ) ; return new_break_point ; }
VisitResult ImplementationVisitor :: Visit ( AssignmentExpression * expr ) { LocationReference location_ref = GetLocationReference ( expr -> location ) ; VisitResult assignment_value ; if ( expr -> op ) { VisitResult location_value = GenerateFetchFromLocation ( expr -> location , location_ref ) ; assignment_value = Visit ( expr -> value ) ; Arguments args ; args . parameters = { location_value , assignment_value } ; assignment_value = GenerateCall ( * expr -> op , args ) ; GenerateAssignToLocation ( expr -> location , location_ref , assignment_value ) ; } else { assignment_value = Visit ( expr -> value ) ; GenerateAssignToLocation ( expr -> location , location_ref , assignment_value ) ; } return assignment_value ; }
txExecutionState :: end ( nsresult aResult ) { popTemplateRule ( ) ; return mOutputHandler -> endDocument ( aResult ) ; }
MaybeHandle < Object > GetMethodAndSetHomeObjectAndName ( Isolate * isolate , Arguments & args , Smi * index , Handle < JSObject > home_object , Handle < String > name_prefix , Handle < Object > key ) { int int_index = Smi :: ToInt ( index ) ; if ( int_index < ClassBoilerplate :: kFirstDynamicArgumentIndex ) { return args . at < Object > ( int_index ) ; } Handle < JSFunction > method = args . at < JSFunction > ( int_index ) ; SetHomeObject ( isolate , * method , * home_object ) ; if ( ! method -> shared ( ) -> HasSharedName ( ) ) { Handle < Name > name = KeyToName < Dictionary > ( isolate , key ) ; if ( ! JSFunction :: SetName ( method , name , name_prefix ) ) { return MaybeHandle < Object > ( ) ; } } return method ; }
nsClipboardHelper :: CopyString ( const nsAString & aString ) { nsresult rv ; rv = CopyStringToClipboard ( aString , nsIClipboard :: kGlobalClipboard ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; CopyStringToClipboard ( aString , nsIClipboard :: kSelectionClipboard ) ; return NS_OK ; }
static void dist_block ( int plane , int block , TX_SIZE tx_size , struct rdcost_block_args * args ) { const int ss_txfrm_size = tx_size < < 1 ; MACROBLOCK * const x = args -> x ; MACROBLOCKD * const xd = & x -> e_mbd ; const struct macroblock_plane * const p = & x -> plane [ plane ] ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; int64_t this_sse ; int shift = tx_size == TX_32X32 ? 0 : 2 ; int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; args -> dist = vp9_block_error ( coeff , dqcoeff , 16 < < ss_txfrm_size , & this_sse ) > > shift ; args -> sse = this_sse > > shift ; if ( x -> skip_encode && ! is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ) { int64_t p = ( pd -> dequant [ 1 ] * pd -> dequant [ 1 ] * ( 1 < < ss_txfrm_size ) ) > > ( shift + 2 ) ; args -> dist += ( p > > 4 ) ; args -> sse += p ; } }
static Bool FFD_CanHandleURL ( GF_InputService * plug , const char * url ) { Bool has_audio , has_video ; s32 i ; AVFormatContext * ctx ; AVOutputFormat * fmt_out ; Bool ret = GF_FALSE ; char * ext , szName [ 1000 ] , szExt [ 20 ] ; const char * szExtList ; FFDemux * ffd ; if ( ! plug || ! url ) return GF_FALSE ; if ( ! strnicmp ( url , "rtsp://" , 7 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "rtspu://" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "rtp://" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "plato://" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "udp://" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "tcp://" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "data:" , 5 ) ) return GF_FALSE ; ffd = ( FFDemux * ) plug -> priv ; strcpy ( szName , url ) ; ext = strrchr ( szName , '#' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '?' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '.' ) ; if ( ext && strlen ( ext ) > 19 ) ext = NULL ; if ( ext && strlen ( ext ) > 1 ) { strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; #ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS if ( strstr ( "ts m2t mts dmb trp" , szExt ) ) return GF_FALSE ; #endif if ( ! strcmp ( szExt , "mp4" ) || ! strcmp ( szExt , "mpg4" ) || ! strcmp ( szExt , "m4a" ) || ! strcmp ( szExt , "m21" ) || ! strcmp ( szExt , "m4v" ) || ! strcmp ( szExt , "m4a" ) || ! strcmp ( szExt , "m4s" ) || ! strcmp ( szExt , "3gs" ) || ! strcmp ( szExt , "3gp" ) || ! strcmp ( szExt , "3gpp" ) || ! strcmp ( szExt , "3gp2" ) || ! strcmp ( szExt , "3g2" ) || ! strcmp ( szExt , "mp3" ) || ! strcmp ( szExt , "ac3" ) || ! strcmp ( szExt , "amr" ) || ! strcmp ( szExt , "bt" ) || ! strcmp ( szExt , "wrl" ) || ! strcmp ( szExt , "x3dv" ) || ! strcmp ( szExt , "xmt" ) || ! strcmp ( szExt , "xmta" ) || ! strcmp ( szExt , "x3d" ) || ! strcmp ( szExt , "jpg" ) || ! strcmp ( szExt , "jpeg" ) || ! strcmp ( szExt , "png" ) ) return GF_FALSE ; { u32 i ; for ( i = 0 ; FFD_MIME_TYPES [ i ] ; i += 3 ) { if ( gf_service_check_mime_register ( plug , FFD_MIME_TYPES [ i ] , FFD_MIME_TYPES [ i + 1 ] , FFD_MIME_TYPES [ i + 2 ] , ext ) ) return GF_TRUE ; } } } ffd_parse_options ( ffd , url ) ; ctx = NULL ; if ( open_file ( & ctx , szName , NULL , ffd -> options ? & ffd -> options : NULL ) < 0 ) { AVInputFormat * av_in = NULL ; if ( ext && ! strcmp ( szExt , "cmp" ) ) av_in = av_find_input_format ( "m4v" ) ; if ( open_file ( & ctx , szName , av_in , ffd -> options ? & ffd -> options : NULL ) < 0 ) { return GF_FALSE ; } } if ( ! ctx ) goto exit ; if ( av_find_stream_info ( ctx ) < 0 ) goto exit ; has_video = has_audio = GF_FALSE ; for ( i = 0 ; i < ( s32 ) ctx -> nb_streams ; i ++ ) { AVCodecContext * enc = ctx -> streams [ i ] -> codec ; switch ( enc -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ! has_audio ) has_audio = GF_TRUE ; break ; case AVMEDIA_TYPE_VIDEO : if ( ! has_video ) has_video = GF_TRUE ; break ; default : break ; } } if ( ! has_audio && ! has_video ) goto exit ; ret = GF_TRUE ; #if ((LIBAVFORMAT_VERSION_MAJOR == 52) && (LIBAVFORMAT_VERSION_MINOR <= 47)) || (LIBAVFORMAT_VERSION_MAJOR < 52) fmt_out = guess_stream_format ( NULL , url , NULL ) ; #else fmt_out = av_guess_format ( NULL , url , NULL ) ; #endif if ( fmt_out ) gf_service_register_mime ( plug , fmt_out -> mime_type , fmt_out -> extensions , fmt_out -> name ) ; else { ext = strrchr ( szName , '.' ) ; if ( ext ) { strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; szExtList = gf_modules_get_option ( ( GF_BaseInterface * ) plug , "MimeTypes" , "application/x-ffmpeg" ) ; if ( ! szExtList ) { gf_service_register_mime ( plug , "application/x-ffmpeg" , szExt , "Other Movies (FFMPEG)" ) ; } else if ( ! strstr ( szExtList , szExt ) ) { u32 len ; char * buf ; len = ( u32 ) ( strlen ( szExtList ) + strlen ( szExt ) + 10 ) ; buf = ( char * ) gf_malloc ( sizeof ( char ) * len ) ; sprintf ( buf , "\"%s " , szExt ) ; strcat ( buf , & szExtList [ 1 ] ) ; gf_modules_set_option ( ( GF_BaseInterface * ) plug , "MimeTypes" , "application/x-ffmpeg" , buf ) ; gf_free ( buf ) ; } } } exit : #if FF_API_CLOSE_INPUT_FILE if ( ctx ) av_close_input_file ( ctx ) ; #else if ( ctx ) avformat_close_input ( & ctx ) ; #endif return ret ; }
static void write_partition ( VP9_COMMON * cm , MACROBLOCKD * xd , int hbs , int mi_row , int mi_col , PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) { const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ; const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ; const int has_cols = ( mi_col + hbs ) < cm -> mi_cols ; if ( has_rows && has_cols ) { vp9_write_token ( w , vp9_partition_tree , probs , & partition_encodings [ p ] ) ; } else if ( ! has_rows && has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_HORZ ) ; vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ; } else if ( has_rows && ! has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_VERT ) ; vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ; } else { assert ( p == PARTITION_SPLIT ) ; } }
void Heap :: EvaluateOldSpaceLocalPretenuring ( uint64_t size_of_objects_before_gc ) { uint64_t size_of_objects_after_gc = SizeOfObjects ( ) ; double old_generation_survival_rate = ( static_cast < double > ( size_of_objects_after_gc ) * 100 ) / static_cast < double > ( size_of_objects_before_gc ) ; if ( old_generation_survival_rate < kOldSurvivalRateLowThreshold ) { ResetAllAllocationSitesDependentCode ( TENURED ) ; if ( FLAG_trace_pretenuring ) { PrintF ( "Deopt all allocation sites dependent code due to low survival " "rate in the old generation %f\n" , old_generation_survival_rate ) ; } } }
status_t CameraBase < TCam , TCamTraits > :: addServiceListener ( const sp < ICameraServiceListener > & listener ) { const sp < ICameraService > & cs = getCameraService ( ) ; if ( cs == 0 ) return UNKNOWN_ERROR ; return cs -> addListener ( listener ) ; }
bool Utf8ExternalStreamingStream :: FetchChunk ( ) { RuntimeCallTimerScope scope ( stats_ , RuntimeCallCounterId :: kGetMoreDataCallback ) ; DCHECK_EQ ( current_ . chunk_no , chunks_ . size ( ) ) ; DCHECK ( chunks_ . empty ( ) || chunks_ . back ( ) . length != 0 ) ; const uint8_t * chunk = nullptr ; size_t length = source_stream_ -> GetMoreData ( & chunk ) ; chunks_ . push_back ( { chunk , length , current_ . pos } ) ; return length > 0 ; }
const std :: wstring Channel :: ChannelImpl :: PipeName ( const std :: wstring & channel_id ) const { std :: wostringstream ss ; ss < < L"\\\\.\\pipe\\chrome." < < channel_id ; return ss . str ( ) ; }
void ObjectDeserializer :: CommitPostProcessedObjects ( ) { CHECK_LE ( new_internalized_strings ( ) . size ( ) , kMaxInt ) ; StringTable :: EnsureCapacityForDeserialization ( isolate ( ) , static_cast < int > ( new_internalized_strings ( ) . size ( ) ) ) ; for ( Handle < String > string : new_internalized_strings ( ) ) { DisallowHeapAllocation no_gc ; StringTableInsertionKey key ( * string ) ; DCHECK_NULL ( StringTable :: ForwardStringIfExists ( isolate ( ) , & key , * string ) ) ; StringTable :: AddKeyNoResize ( isolate ( ) , & key ) ; } Heap * heap = isolate ( ) -> heap ( ) ; Factory * factory = isolate ( ) -> factory ( ) ; for ( Handle < Script > script : new_scripts ( ) ) { script -> set_id ( isolate ( ) -> heap ( ) -> NextScriptId ( ) ) ; LOG ( isolate ( ) , ScriptEvent ( Logger :: ScriptEventType :: kDeserialize , script -> id ( ) ) ) ; LOG ( isolate ( ) , ScriptDetails ( * script ) ) ; Handle < WeakArrayList > list = factory -> script_list ( ) ; list = WeakArrayList :: AddToEnd ( isolate ( ) , list , MaybeObjectHandle :: Weak ( script ) ) ; heap -> SetRootScriptList ( * list ) ; } }
rb_dlhandle_sym ( VALUE self , VALUE sym ) { void ( * func ) ( ) ; struct dl_handle * dlhandle ; void * handle ; const char * name ; const char * err ; int i ; #if defined(HAVE_DLERROR) # define CHECK_DLERROR if( err = dlerror() ){ func = 0; } #else # define CHECK_DLERROR #endif rb_secure ( 2 ) ; name = StringValuePtr ( sym ) ; Data_Get_Struct ( self , struct dl_handle , dlhandle ) ; if ( ! dlhandle -> open ) { rb_raise ( rb_eDLError , "closed handle" ) ; } handle = dlhandle -> ptr ; func = dlsym ( handle , name ) ; CHECK_DLERROR ; #if defined(FUNC_STDCALL) if ( ! func ) { int len = strlen ( name ) ; char * name_n ; #if defined(__CYGWIN__) || defined(_WIN32) || defined(__MINGW32__) { char * name_a = ( char * ) xmalloc ( len + 2 ) ; strcpy ( name_a , name ) ; name_n = name_a ; name_a [ len ] = 'A' ; name_a [ len + 1 ] = '\0' ; func = dlsym ( handle , name_a ) ; CHECK_DLERROR ; if ( func ) goto found ; name_n = xrealloc ( name_a , len + 6 ) ; } #else name_n = ( char * ) xmalloc ( len + 6 ) ; #endif memcpy ( name_n , name , len ) ; name_n [ len ++ ] = '@' ; for ( i = 0 ; i < 256 ; i += 4 ) { sprintf ( name_n + len , "%d" , i ) ; func = dlsym ( handle , name_n ) ; CHECK_DLERROR ; if ( func ) break ; } if ( func ) goto found ; name_n [ len - 1 ] = 'A' ; name_n [ len ++ ] = '@' ; for ( i = 0 ; i < 256 ; i += 4 ) { sprintf ( name_n + len , "%d" , i ) ; func = dlsym ( handle , name_n ) ; CHECK_DLERROR ; if ( func ) break ; } found : xfree ( name_n ) ; } #endif if ( ! func ) { rb_raise ( rb_eDLError , "unknown symbol \"%s\"" , name ) ; } return PTR2NUM ( func ) ; }
static void sctp_v6_from_addr_param ( union sctp_addr * addr , union sctp_addr_param * param , __be16 port , int iif ) { addr -> v6 . sin6_family = AF_INET6 ; addr -> v6 . sin6_port = port ; addr -> v6 . sin6_flowinfo = 0 ; addr -> v6 . sin6_addr = param -> v6 . addr ; addr -> v6 . sin6_scope_id = iif ; }
static int crypto_rng_report ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_rng rrng ; snprintf ( rrng . type , CRYPTO_MAX_ALG_NAME , "%s" , "rng" ) ; rrng . seedsize = alg -> cra_rng . seedsize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_RNG , sizeof ( struct crypto_report_rng ) , & rrng ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
void AddToDescriptorArrayTemplate ( Isolate * isolate , Handle < DescriptorArray > descriptor_array_template , Handle < Name > name , ClassBoilerplate :: ValueKind value_kind , Handle < Object > value ) { int entry = descriptor_array_template -> Search ( * name , descriptor_array_template -> number_of_descriptors ( ) ) ; if ( entry == DescriptorArray :: kNotFound ) { Descriptor d ; if ( value_kind == ClassBoilerplate :: kData ) { d = Descriptor :: DataConstant ( name , value , DONT_ENUM ) ; } else { DCHECK ( value_kind == ClassBoilerplate :: kGetter || value_kind == ClassBoilerplate :: kSetter ) ; Handle < AccessorPair > pair = isolate -> factory ( ) -> NewAccessorPair ( ) ; pair -> set ( value_kind == ClassBoilerplate :: kGetter ? ACCESSOR_GETTER : ACCESSOR_SETTER , * value ) ; d = Descriptor :: AccessorConstant ( name , pair , DONT_ENUM ) ; } descriptor_array_template -> Append ( & d ) ; } else { int sorted_index = descriptor_array_template -> GetDetails ( entry ) . pointer ( ) ; if ( value_kind == ClassBoilerplate :: kData ) { Descriptor d = Descriptor :: DataConstant ( name , value , DONT_ENUM ) ; d . SetSortedKeyIndex ( sorted_index ) ; descriptor_array_template -> Set ( entry , & d ) ; } else { DCHECK ( value_kind == ClassBoilerplate :: kGetter || value_kind == ClassBoilerplate :: kSetter ) ; Object * raw_accessor = descriptor_array_template -> GetStrongValue ( entry ) ; AccessorPair * pair ; if ( raw_accessor -> IsAccessorPair ( ) ) { pair = AccessorPair :: cast ( raw_accessor ) ; } else { Handle < AccessorPair > new_pair = isolate -> factory ( ) -> NewAccessorPair ( ) ; Descriptor d = Descriptor :: AccessorConstant ( name , new_pair , DONT_ENUM ) ; d . SetSortedKeyIndex ( sorted_index ) ; descriptor_array_template -> Set ( entry , & d ) ; pair = * new_pair ; } pair -> set ( value_kind == ClassBoilerplate :: kGetter ? ACCESSOR_GETTER : ACCESSOR_SETTER , * value ) ; } } }
int anon_vma_clone ( struct vm_area_struct * dst , struct vm_area_struct * src ) { struct anon_vma_chain * avc , * pavc ; struct anon_vma * root = NULL ; list_for_each_entry_reverse ( pavc , & src -> anon_vma_chain , same_vma ) { struct anon_vma * anon_vma ; avc = anon_vma_chain_alloc ( GFP_NOWAIT | __GFP_NOWARN ) ; if ( unlikely ( ! avc ) ) { unlock_anon_vma_root ( root ) ; root = NULL ; avc = anon_vma_chain_alloc ( GFP_KERNEL ) ; if ( ! avc ) goto enomem_failure ; } anon_vma = pavc -> anon_vma ; root = lock_anon_vma_root ( root , anon_vma ) ; anon_vma_chain_link ( dst , avc , anon_vma ) ; if ( ! dst -> anon_vma && src -> anon_vma && anon_vma != src -> anon_vma && anon_vma -> degree < 2 ) dst -> anon_vma = anon_vma ; } if ( dst -> anon_vma ) dst -> anon_vma -> degree ++ ; unlock_anon_vma_root ( root ) ; return 0 ; enomem_failure : dst -> anon_vma = NULL ; unlink_anon_vmas ( dst ) ; return - ENOMEM ; }
openvpn_decrypt ( struct buffer * buf , struct buffer work , const struct crypto_options * opt , const struct frame * frame ) { static const char error_prefix [ ] = "Authenticate/Decrypt packet error" ; struct gc_arena gc ; gc_init ( & gc ) ; if ( buf -> len > 0 && opt -> key_ctx_bi ) { struct key_ctx * ctx = & opt -> key_ctx_bi -> decrypt ; struct packet_id_net pin ; bool have_pin = false ; if ( ctx -> hmac ) { int hmac_len ; uint8_t local_hmac [ MAX_HMAC_KEY_LENGTH ] ; hmac_ctx_reset ( ctx -> hmac ) ; hmac_len = hmac_ctx_size ( ctx -> hmac ) ; if ( buf -> len < hmac_len ) CRYPT_ERROR ( "missing authentication info" ) ; hmac_ctx_update ( ctx -> hmac , BPTR ( buf ) + hmac_len , BLEN ( buf ) - hmac_len ) ; hmac_ctx_final ( ctx -> hmac , local_hmac ) ; if ( memcmp ( local_hmac , BPTR ( buf ) , hmac_len ) ) CRYPT_ERROR ( "packet HMAC authentication failed" ) ; ASSERT ( buf_advance ( buf , hmac_len ) ) ; } if ( ctx -> cipher ) { const unsigned int mode = cipher_ctx_mode ( ctx -> cipher ) ; const int iv_size = cipher_ctx_iv_length ( ctx -> cipher ) ; uint8_t iv_buf [ OPENVPN_MAX_IV_LENGTH ] ; int outlen ; ASSERT ( buf_init ( & work , FRAME_HEADROOM_ADJ ( frame , FRAME_HEADROOM_MARKER_DECRYPT ) ) ) ; CLEAR ( iv_buf ) ; if ( opt -> flags & CO_USE_IV ) { if ( buf -> len < iv_size ) CRYPT_ERROR ( "missing IV info" ) ; memcpy ( iv_buf , BPTR ( buf ) , iv_size ) ; ASSERT ( buf_advance ( buf , iv_size ) ) ; } if ( opt -> flags & CO_USE_IV ) dmsg ( D_PACKET_CONTENT , "DECRYPT IV: %s" , format_hex ( iv_buf , iv_size , 0 , & gc ) ) ; if ( buf -> len < 1 ) CRYPT_ERROR ( "missing payload" ) ; if ( ! cipher_ctx_reset ( ctx -> cipher , iv_buf ) ) CRYPT_ERROR ( "cipher init failed" ) ; if ( ! buf_safe ( & work , buf -> len ) ) CRYPT_ERROR ( "buffer overflow" ) ; if ( ! cipher_ctx_update ( ctx -> cipher , BPTR ( & work ) , & outlen , BPTR ( buf ) , BLEN ( buf ) ) ) CRYPT_ERROR ( "cipher update failed" ) ; work . len += outlen ; if ( ! cipher_ctx_final ( ctx -> cipher , BPTR ( & work ) + outlen , & outlen ) ) CRYPT_ERROR ( "cipher final failed" ) ; work . len += outlen ; dmsg ( D_PACKET_CONTENT , "DECRYPT TO: %s" , format_hex ( BPTR ( & work ) , BLEN ( & work ) , 80 , & gc ) ) ; { if ( mode == OPENVPN_MODE_CBC ) { if ( opt -> packet_id ) { if ( ! packet_id_read ( & pin , & work , BOOL_CAST ( opt -> flags & CO_PACKET_ID_LONG_FORM ) ) ) CRYPT_ERROR ( "error reading CBC packet-id" ) ; have_pin = true ; } } else if ( mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB ) { struct buffer b ; ASSERT ( opt -> flags & CO_USE_IV ) ; ASSERT ( opt -> packet_id ) ; buf_set_read ( & b , iv_buf , iv_size ) ; if ( ! packet_id_read ( & pin , & b , true ) ) CRYPT_ERROR ( "error reading CFB/OFB packet-id" ) ; have_pin = true ; } else { ASSERT ( 0 ) ; } } } else { work = * buf ; if ( opt -> packet_id ) { if ( ! packet_id_read ( & pin , & work , BOOL_CAST ( opt -> flags & CO_PACKET_ID_LONG_FORM ) ) ) CRYPT_ERROR ( "error reading packet-id" ) ; have_pin = ! BOOL_CAST ( opt -> flags & CO_IGNORE_PACKET_ID ) ; } } if ( have_pin ) { packet_id_reap_test ( & opt -> packet_id -> rec ) ; if ( packet_id_test ( & opt -> packet_id -> rec , & pin ) ) { packet_id_add ( & opt -> packet_id -> rec , & pin ) ; if ( opt -> pid_persist && ( opt -> flags & CO_PACKET_ID_LONG_FORM ) ) packet_id_persist_save_obj ( opt -> pid_persist , opt -> packet_id ) ; } else { if ( ! ( opt -> flags & CO_MUTE_REPLAY_WARNINGS ) ) msg ( D_REPLAY_ERRORS , "%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings" , error_prefix , packet_id_net_print ( & pin , true , & gc ) ) ; goto error_exit ; } } * buf = work ; } gc_free ( & gc ) ; return true ; error_exit : crypto_clear_error ( ) ; buf -> len = 0 ; gc_free ( & gc ) ; return false ; }
PHP_FUNCTION ( imageconvolution ) { zval * SIM , * hash_matrix ; zval * * var = NULL , * * var2 = NULL ; gdImagePtr im_src = NULL ; double div , offset ; int nelem , i , j , res ; float matrix [ 3 ] [ 3 ] = { { 0 , 0 , 0 } , { 0 , 0 , 0 } , { 0 , 0 , 0 } } ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "radd" , & SIM , & hash_matrix , & div , & offset ) == FAILURE ) { RETURN_FALSE ; } ZEND_FETCH_RESOURCE ( im_src , gdImagePtr , & SIM , - 1 , "Image" , le_gd ) ; nelem = zend_hash_num_elements ( Z_ARRVAL_P ( hash_matrix ) ) ; if ( nelem != 3 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You must have 3x3 array" ) ; RETURN_FALSE ; } for ( i = 0 ; i < 3 ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( hash_matrix ) , ( i ) , ( void * * ) & var ) == SUCCESS && Z_TYPE_PP ( var ) == IS_ARRAY ) { if ( Z_TYPE_PP ( var ) != IS_ARRAY || zend_hash_num_elements ( Z_ARRVAL_PP ( var ) ) != 3 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You must have 3x3 array" ) ; RETURN_FALSE ; } for ( j = 0 ; j < 3 ; j ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_PP ( var ) , ( j ) , ( void * * ) & var2 ) == SUCCESS ) { SEPARATE_ZVAL ( var2 ) ; convert_to_double ( * var2 ) ; matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You must have a 3x3 matrix" ) ; RETURN_FALSE ; } } } } res = gdImageConvolution ( im_src , matrix , ( float ) div , ( float ) offset ) ; if ( res ) { RETURN_TRUE ; } else { RETURN_FALSE ; } }
XPCWrappedNativeScope :: ~ XPCWrappedNativeScope ( ) { MOZ_COUNT_DTOR ( XPCWrappedNativeScope ) ; DEBUG_TrackDeleteScope ( this ) ; if ( mWrappedNativeMap ) { NS_ASSERTION ( 0 == mWrappedNativeMap -> Count ( ) , "scope has non-empty map" ) ; delete mWrappedNativeMap ; } if ( mWrappedNativeProtoMap ) { NS_ASSERTION ( 0 == mWrappedNativeProtoMap -> Count ( ) , "scope has non-empty map" ) ; delete mWrappedNativeProtoMap ; } if ( mMainThreadWrappedNativeProtoMap ) { NS_ASSERTION ( 0 == mMainThreadWrappedNativeProtoMap -> Count ( ) , "scope has non-empty map" ) ; delete mMainThreadWrappedNativeProtoMap ; } if ( mContext ) mContext -> RemoveScope ( this ) ; if ( mComponents ) mComponents -> mScope = nullptr ; mComponents = nullptr ; JSRuntime * rt = XPCJSRuntime :: Get ( ) -> GetJSRuntime ( ) ; mGlobalJSObject . finalize ( rt ) ; }
TPM2B_SENSITIVE_CREATE_Unmarshal ( TPM2B_SENSITIVE_CREATE * target , BYTE * * buffer , INT32 * size ) { TPM_RC rc = TPM_RC_SUCCESS ; INT32 startSize ; if ( rc == TPM_RC_SUCCESS ) { rc = UINT16_Unmarshal ( & target -> size , buffer , size ) ; } if ( rc == TPM_RC_SUCCESS ) { if ( target -> size == 0 ) { rc = TPM_RC_SIZE ; } } if ( rc == TPM_RC_SUCCESS ) { startSize = * size ; } if ( rc == TPM_RC_SUCCESS ) { rc = TPMS_SENSITIVE_CREATE_Unmarshal ( & target -> sensitive , buffer , size ) ; } if ( rc == TPM_RC_SUCCESS ) { if ( target -> size != startSize - * size ) { rc = TPM_RC_SIZE ; } } return rc ; }
static __always_inline int __do_follow_link ( struct path * path , struct nameidata * nd ) { int error ; void * cookie ; struct dentry * dentry = path -> dentry ; touch_atime ( path -> mnt , dentry ) ; nd_set_link ( nd , NULL ) ; if ( path -> mnt != nd -> path . mnt ) { path_to_nameidata ( path , nd ) ; dget ( dentry ) ; } mntget ( path -> mnt ) ; cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ; error = PTR_ERR ( cookie ) ; if ( ! IS_ERR ( cookie ) ) { char * s = nd_get_link ( nd ) ; error = 0 ; if ( s ) error = __vfs_follow_link ( nd , s ) ; else if ( nd -> last_type == LAST_BIND ) { error = force_reval_path ( & nd -> path , nd ) ; if ( error ) path_put ( & nd -> path ) ; } if ( dentry -> d_inode -> i_op -> put_link ) dentry -> d_inode -> i_op -> put_link ( dentry , nd , cookie ) ; } return error ; }
void spider_db_mbase :: print_warnings ( struct tm * l_time ) { DBUG_ENTER ( "spider_db_mbase::print_warnings" ) ; DBUG_PRINT ( "info" , ( "spider this=%p" , this ) ) ; if ( db_conn -> status == MYSQL_STATUS_READY ) { #if MYSQL_VERSION_ID < 50500 if ( ! ( db_conn -> last_used_con -> server_status & SERVER_MORE_RESULTS_EXISTS ) ) #else if ( ! ( db_conn -> server_status & SERVER_MORE_RESULTS_EXISTS ) ) #endif { if ( spider_param_dry_access ( ) || ! mysql_real_query ( db_conn , SPIDER_SQL_SHOW_WARNINGS_STR , SPIDER_SQL_SHOW_WARNINGS_LEN ) ) { MYSQL_RES * res = NULL ; MYSQL_ROW row = NULL ; uint num_fields ; if ( spider_param_dry_access ( ) || ! ( res = mysql_store_result ( db_conn ) ) || ! ( row = mysql_fetch_row ( res ) ) ) { if ( mysql_errno ( db_conn ) ) { if ( res ) mysql_free_result ( res ) ; DBUG_VOID_RETURN ; } } num_fields = mysql_num_fields ( res ) ; if ( num_fields != 3 ) { mysql_free_result ( res ) ; DBUG_VOID_RETURN ; } while ( row ) { fprintf ( stderr , "%04d%02d%02d %02d:%02d:%02d [WARN SPIDER RESULT] " "from [%s] %ld to %ld: %s %s %s\n" , l_time -> tm_year + 1900 , l_time -> tm_mon + 1 , l_time -> tm_mday , l_time -> tm_hour , l_time -> tm_min , l_time -> tm_sec , conn -> tgt_host , ( ulong ) db_conn -> thread_id , ( ulong ) current_thd -> thread_id , row [ 0 ] , row [ 1 ] , row [ 2 ] ) ; row = mysql_fetch_row ( res ) ; } if ( res ) mysql_free_result ( res ) ; } } } DBUG_VOID_RETURN ; }
nsRuleNode :: GetStyleData ( nsStyleStructID aSID , nsStyleContext * aContext , bool aComputeData ) { NS_ASSERTION ( IsUsedDirectly ( ) , "if we ever call this on rule nodes that aren't used " "directly, we should adjust handling of mDependentBits " "in some way." ) ; MOZ_ASSERT ( ! aContext -> GetCachedStyleData ( aSID ) , "style context should not have cached data for struct" ) ; const void * data ; if ( ! ( HasAnimationData ( ) && ParentHasPseudoElementData ( aContext ) ) ) { data = mStyleData . GetStyleData ( aSID , aContext , aComputeData ) ; if ( MOZ_LIKELY ( data != nullptr ) ) { if ( ! nsCachedStyleData :: IsReset ( aSID ) ) { aContext -> AddStyleBit ( nsCachedStyleData :: GetBitForSID ( aSID ) ) ; } return data ; } } if ( MOZ_UNLIKELY ( ! aComputeData ) ) return nullptr ; data = WalkRuleTree ( aSID , aContext ) ; MOZ_ASSERT ( data , "should have aborted on out-of-memory" ) ; return data ; }
ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg = NULL ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , "non-default argument follows default argument" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , "named arguments must follow bare *" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , "bare * has associated type comment" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , "unexpected node in varargslist: %d @ %d" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }
int main ( int argc , char * * argv ) { int opt ; uid_t uid = geteuid ( ) ; gid_t gid = getgid ( ) ; mode_t mode = 0 ; struct passwd * pw = NULL ; struct group * gr = NULL ; inode_t type = inode_unknown ; int retval = EXIT_SUCCESS ; bool trunc = false ; bool chowner = false ; bool symlinks = false ; bool writable = false ; bool selinux_on = false ; applet = basename_c ( argv [ 0 ] ) ; while ( ( opt = getopt_long ( argc , argv , getoptstring , longopts , ( int * ) 0 ) ) != - 1 ) { switch ( opt ) { case 'D' : trunc = true ; case 'd' : type = inode_dir ; break ; case 'F' : trunc = true ; case 'f' : type = inode_file ; break ; case 'p' : type = inode_fifo ; break ; case 'm' : if ( parse_mode ( & mode , optarg ) != 0 ) eerrorx ( "%s: invalid mode `%s'" , applet , optarg ) ; break ; case 'o' : chowner = true ; if ( parse_owner ( & pw , & gr , optarg ) != 0 ) eerrorx ( "%s: owner `%s' not found" , applet , optarg ) ; break ; case 's' : #ifndef O_PATH symlinks = true ; #endif break ; case 'W' : writable = true ; break ; case_RC_COMMON_GETOPT } } if ( optind >= argc ) usage ( EXIT_FAILURE ) ; if ( writable && type != inode_unknown ) eerrorx ( "%s: -W cannot be specified along with -d, -f or -p" , applet ) ; if ( pw ) { uid = pw -> pw_uid ; gid = pw -> pw_gid ; } if ( gr ) gid = gr -> gr_gid ; if ( selinux_util_open ( ) == 1 ) selinux_on = true ; while ( optind < argc ) { if ( writable ) exit ( ! is_writable ( argv [ optind ] ) ) ; if ( do_check ( argv [ optind ] , uid , gid , mode , type , trunc , chowner , symlinks , selinux_on ) ) retval = EXIT_FAILURE ; optind ++ ; } if ( selinux_on ) selinux_util_close ( ) ; return retval ; }
GetLocationProperty ( JSContext * cx , unsigned argc , Value * vp ) { CallArgs args = CallArgsFromVp ( argc , vp ) ; if ( ! args . thisv ( ) . isObject ( ) ) { JS_ReportError ( cx , "Unexpected this value for GetLocationProperty" ) ; return false ; } #if !defined(XP_WIN) && !defined(XP_UNIX) return false ; #else JS :: UniqueChars filename ; if ( JS :: DescribeScriptedCaller ( cx , & filename ) && filename . get ( ) ) { nsresult rv ; nsCOMPtr < nsIXPConnect > xpc = do_GetService ( kXPConnectServiceContractID , & rv ) ; #if defined(XP_WIN) int bufferSize = MultiByteToWideChar ( CP_ACP , 0 , filename . get ( ) , - 1 , nullptr , 0 ) ; nsAutoString filenameString ; filenameString . SetLength ( bufferSize ) ; MultiByteToWideChar ( CP_ACP , 0 , filename . get ( ) , - 1 , ( LPWSTR ) filenameString . BeginWriting ( ) , filenameString . Length ( ) ) ; filenameString . SetLength ( bufferSize - 1 ) ; char16_t * start = filenameString . BeginWriting ( ) ; char16_t * end = filenameString . EndWriting ( ) ; while ( start != end ) { if ( * start == L'/' ) * start = L'\\' ; start ++ ; } #elif defined(XP_UNIX) NS_ConvertUTF8toUTF16 filenameString ( filename . get ( ) ) ; #endif nsCOMPtr < nsIFile > location ; if ( NS_SUCCEEDED ( rv ) ) { rv = NS_NewLocalFile ( filenameString , false , getter_AddRefs ( location ) ) ; } if ( ! location && gWorkingDirectory ) { nsAutoString absolutePath ( * gWorkingDirectory ) ; absolutePath . Append ( filenameString ) ; rv = NS_NewLocalFile ( absolutePath , false , getter_AddRefs ( location ) ) ; } if ( location ) { bool symlink ; if ( NS_SUCCEEDED ( location -> IsSymlink ( & symlink ) ) && ! symlink ) location -> Normalize ( ) ; RootedObject locationObj ( cx ) ; rv = xpc -> WrapNative ( cx , & args . thisv ( ) . toObject ( ) , location , NS_GET_IID ( nsIFile ) , locationObj . address ( ) ) ; if ( NS_SUCCEEDED ( rv ) && locationObj ) { args . rval ( ) . setObject ( * locationObj ) ; } } } return true ; #endif }
MediaKeyNeededEvent :: GetInitData ( JSContext * cx , ErrorResult & aRv ) { if ( mRawInitData . Length ( ) ) { mInitData = Uint8Array :: Create ( cx , this , mRawInitData . Length ( ) , mRawInitData . Elements ( ) ) ; if ( ! mInitData ) { aRv . Throw ( NS_ERROR_OUT_OF_MEMORY ) ; return nullptr ; } mRawInitData . Clear ( ) ; } if ( mInitData ) { JS :: ExposeObjectToActiveJS ( mInitData ) ; } return mInitData ; }
WorkerPermissionOperationCompleted ( WorkerPrivate * aWorkerPrivate , WorkerPermissionChallenge * aChallenge ) : WorkerRunnable ( aWorkerPrivate , WorkerThreadUnchangedBusyCount ) , mChallenge ( aChallenge ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; }
void ZstdDecompressorImpl :: decompress ( const Buffer :: Instance & input_buffer , Buffer :: Instance & output_buffer ) { for ( const Buffer :: RawSlice & input_slice : input_buffer . getRawSlices ( ) ) { if ( input_slice . len_ > 0 ) { if ( ddict_manager_ && ! is_dictionary_set_ ) { is_dictionary_set_ = true ; dictionary_id_ = ZSTD_getDictID_fromFrame ( static_cast < uint8_t * > ( input_slice . mem_ ) , input_slice . len_ ) ; if ( dictionary_id_ != 0 ) { auto dictionary = ddict_manager_ -> getDictionaryById ( dictionary_id_ ) ; if ( ! dictionary ) { stats_ . zstd_dictionary_error_ . inc ( ) ; return ; } const size_t result = ZSTD_DCtx_refDDict ( dctx_ . get ( ) , dictionary ) ; if ( isError ( result ) ) { return ; } } } setInput ( input_slice ) ; if ( ! process ( output_buffer ) ) { return ; } } } }
static String HHVM_FUNCTION ( bcmul , const String & left , const String & right , int64_t scale ) { if ( scale < 0 ) scale = BCG ( bc_precision ) ; bc_num first , second , result ; bc_init_num ( & first ) ; bc_init_num ( & second ) ; bc_init_num ( & result ) ; php_str2num ( & first , ( char * ) left . data ( ) ) ; php_str2num ( & second , ( char * ) right . data ( ) ) ; bc_multiply ( first , second , & result , scale ) ; if ( result -> n_scale > scale ) { result -> n_scale = scale ; } String ret ( bc_num2str ( result ) , AttachString ) ; bc_free_num ( & first ) ; bc_free_num ( & second ) ; bc_free_num ( & result ) ; return ret ; }
static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx , int ctr_id , va_list args ) { int update = va_arg ( args , int ) ; vp8_update_reference ( ctx -> cpi , update ) ; return VPX_CODEC_OK ; }
void GetUserMediaWindowListener :: StopSharing ( ) { MOZ_ASSERT ( NS_IsMainThread ( ) , "Only call on main thread" ) ; for ( auto & l : mActiveListeners . Clone ( ) ) { l -> StopSharing ( ) ; } }
Node * BinaryOpAssembler :: Generate_ModulusWithFeedback ( Node * context , Node * dividend , Node * divisor , Node * slot_id , Node * feedback_vector , bool rhs_is_smi ) { auto smiFunction = [ = ] ( Node * lhs , Node * rhs , Variable * var_type_feedback ) { TNode < Number > result = SmiMod ( CAST ( lhs ) , CAST ( rhs ) ) ; var_type_feedback -> Bind ( SelectSmiConstant ( TaggedIsSmi ( result ) , BinaryOperationFeedback :: kSignedSmall , BinaryOperationFeedback :: kNumber ) ) ; return result ; } ; auto floatFunction = [ = ] ( Node * lhs , Node * rhs ) { return Float64Mod ( lhs , rhs ) ; } ; return Generate_BinaryOperationWithFeedback ( context , dividend , divisor , slot_id , feedback_vector , smiFunction , floatFunction , Operation :: kModulus , rhs_is_smi ) ; }
inline int jpeg_decoder :: huff_decode ( huff_tables * pH ) { int symbol ; if ( ( symbol = pH -> look_up [ m_bit_buf > > 24 ] ) < 0 ) { int ofs = 23 ; do { symbol = pH -> tree [ - ( int ) ( symbol + ( ( m_bit_buf > > ofs ) & 1 ) ) ] ; ofs -- ; } while ( symbol < 0 ) ; get_bits_no_markers ( 8 + ( 23 - ofs ) ) ; } else get_bits_no_markers ( pH -> code_size [ symbol ] ) ; return symbol ; }
Reduction MachineOperatorReducer :: ReduceFloat64RoundDown ( Node * node ) { DCHECK_EQ ( IrOpcode :: kFloat64RoundDown , node -> opcode ( ) ) ; Float64Matcher m ( node -> InputAt ( 0 ) ) ; if ( m . HasValue ( ) ) { return ReplaceFloat64 ( Floor ( m . Value ( ) ) ) ; } return NoChange ( ) ; }
PuppetWidget :: Paint ( ) { NS_ABORT_IF_FALSE ( ! mDirtyRegion . IsEmpty ( ) , "paint event logic messed up" ) ; if ( ! mAttachedWidgetListener ) return NS_OK ; nsIntRegion region = mDirtyRegion ; mDirtyRegion . SetEmpty ( ) ; mPaintTask . Revoke ( ) ; { #ifdef DEBUG debug_DumpPaintEvent ( stderr , this , region , nsAutoCString ( "PuppetWidget" ) , 0 ) ; #endif if ( mozilla :: layers :: LAYERS_D3D10 == mLayerManager -> GetBackendType ( ) ) { mAttachedWidgetListener -> PaintWindow ( this , region , nsIWidgetListener :: WILL_SEND_DID_PAINT ) ; } else { nsRefPtr < gfxContext > ctx = new gfxContext ( mSurface ) ; ctx -> Rectangle ( gfxRect ( 0 , 0 , 0 , 0 ) ) ; ctx -> Clip ( ) ; AutoLayerManagerSetup setupLayerManager ( this , ctx , BUFFER_NONE ) ; mAttachedWidgetListener -> PaintWindow ( this , region , nsIWidgetListener :: WILL_SEND_DID_PAINT ) ; mTabChild -> NotifyPainted ( ) ; } } mAttachedWidgetListener -> DidPaintWindow ( ) ; return NS_OK ; }
void carray2Hex ( const unsigned char * d , uint64_t _len , char * _hexArray , uint64_t _hexArrayLen ) { CHECK_STATE ( d ) ; CHECK_STATE ( _hexArray ) ; char hexval [ 16 ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' } ; CHECK_STATE ( _hexArrayLen > 2 * _len ) ; for ( int j = 0 ; j < _len ; j ++ ) { _hexArray [ j * 2 ] = hexval [ ( ( d [ j ] > > 4 ) & 0xF ) ] ; _hexArray [ j * 2 + 1 ] = hexval [ ( d [ j ] ) & 0x0F ] ; } _hexArray [ _len * 2 ] = 0 ; }
ProfileNode * ProfileTree :: AddPathFromEnd ( const ProfileStackTrace & path , int src_line , bool update_stats , ProfilingMode mode ) { ProfileNode * node = root_ ; CodeEntry * last_entry = nullptr ; int parent_line_number = v8 :: CpuProfileNode :: kNoLineNumberInfo ; for ( auto it = path . rbegin ( ) ; it != path . rend ( ) ; ++ it ) { if ( ( * it ) . code_entry == nullptr ) continue ; last_entry = ( * it ) . code_entry ; node = node -> FindOrAddChild ( ( * it ) . code_entry , parent_line_number ) ; parent_line_number = mode == ProfilingMode :: kCallerLineNumbers ? ( * it ) . line_number : v8 :: CpuProfileNode :: kNoLineNumberInfo ; } if ( last_entry && last_entry -> has_deopt_info ( ) ) { node -> CollectDeoptInfo ( last_entry ) ; } if ( update_stats ) { node -> IncrementSelfTicks ( ) ; if ( src_line != v8 :: CpuProfileNode :: kNoLineNumberInfo ) { node -> IncrementLineTicks ( src_line ) ; } } return node ; }
bool RegistryPolicy :: OpenKeyAction ( EvalResult eval_result , const ClientInfo & client_info , const base :: string16 & key , uint32_t attributes , HANDLE root_directory , uint32_t desired_access , HANDLE * handle , NTSTATUS * nt_status ) { if ( ASK_BROKER != eval_result ) { * nt_status = STATUS_ACCESS_DENIED ; return true ; } UNICODE_STRING uni_name = { 0 } ; OBJECT_ATTRIBUTES obj_attributes = { 0 } ; InitObjectAttribs ( key , attributes , root_directory , & obj_attributes , & uni_name , NULL ) ; * nt_status = NtOpenKeyInTarget ( handle , desired_access , & obj_attributes , client_info . process ) ; return true ; }
txFnStartIf ( PRInt32 aNamespaceID , nsIAtom * aLocalName , nsIAtom * aPrefix , txStylesheetAttr * aAttributes , PRInt32 aAttrCount , txStylesheetCompilerState & aState ) { nsresult rv = NS_OK ; nsAutoPtr < Expr > test ; rv = getExprAttr ( aAttributes , aAttrCount , nsGkAtoms :: test , true , aState , test ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsAutoPtr < txConditionalGoto > condGoto ( new txConditionalGoto ( test , nsnull ) ) ; NS_ENSURE_TRUE ( condGoto , NS_ERROR_OUT_OF_MEMORY ) ; rv = aState . pushPtr ( condGoto ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsAutoPtr < txInstruction > instr ( condGoto . forget ( ) ) ; rv = aState . addInstruction ( instr ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; return NS_OK ; }
Node * ConstructorBuiltinsAssembler :: EmitCreateEmptyArrayLiteral ( Node * feedback_vector , Node * slot , Node * context ) { TNode < Object > maybe_allocation_site = CAST ( LoadFeedbackVectorSlot ( feedback_vector , slot , 0 , INTPTR_PARAMETERS ) ) ; TVARIABLE ( AllocationSite , allocation_site ) ; Label create_empty_array ( this ) , initialize_allocation_site ( this , Label :: kDeferred ) , done ( this ) ; GotoIf ( TaggedIsSmi ( maybe_allocation_site ) , & initialize_allocation_site ) ; { allocation_site = CAST ( maybe_allocation_site ) ; Goto ( & create_empty_array ) ; } BIND ( & initialize_allocation_site ) ; { allocation_site = CreateAllocationSiteInFeedbackVector ( feedback_vector , SmiTag ( slot ) ) ; Goto ( & create_empty_array ) ; } BIND ( & create_empty_array ) ; TNode < Int32T > kind = LoadElementsKind ( allocation_site . value ( ) ) ; TNode < Context > native_context = LoadNativeContext ( context ) ; Comment ( "LoadJSArrayElementsMap" ) ; Node * array_map = LoadJSArrayElementsMap ( kind , native_context ) ; Node * zero = SmiConstant ( 0 ) ; Comment ( "Allocate JSArray" ) ; Node * result = AllocateJSArray ( GetInitialFastElementsKind ( ) , array_map , zero , zero , allocation_site . value ( ) , ParameterMode :: SMI_PARAMETERS ) ; Goto ( & done ) ; BIND ( & done ) ; return result ; }
static jlong NativeCrypto_EVP_get_cipherbyname ( JNIEnv * env , jclass , jstring algorithm ) { JNI_TRACE ( "EVP_get_cipherbyname(%p)" , algorithm ) ; #if !defined(OPENSSL_IS_BORINGSSL) if ( algorithm == NULL ) { JNI_TRACE ( "EVP_get_cipherbyname(%p) => threw exception algorithm == null" , algorithm ) ; jniThrowNullPointerException ( env , NULL ) ; return - 1 ; } ScopedUtfChars algorithmChars ( env , algorithm ) ; if ( algorithmChars . c_str ( ) == NULL ) { return 0 ; } JNI_TRACE ( "EVP_get_cipherbyname(%p) => algorithm = %s" , algorithm , algorithmChars . c_str ( ) ) ; const EVP_CIPHER * evp_cipher = EVP_get_cipherbyname ( algorithmChars . c_str ( ) ) ; if ( evp_cipher == NULL ) { freeOpenSslErrorState ( ) ; } JNI_TRACE ( "EVP_get_cipherbyname(%s) => %p" , algorithmChars . c_str ( ) , evp_cipher ) ; return reinterpret_cast < uintptr_t > ( evp_cipher ) ; #else ScopedUtfChars scoped_alg ( env , algorithm ) ; const char * alg = scoped_alg . c_str ( ) ; const EVP_CIPHER * cipher ; if ( strcasecmp ( alg , "rc4" ) == 0 ) { cipher = EVP_rc4 ( ) ; } else if ( strcasecmp ( alg , "des-cbc" ) == 0 ) { cipher = EVP_des_cbc ( ) ; } else if ( strcasecmp ( alg , "des-ede-cbc" ) == 0 ) { cipher = EVP_des_cbc ( ) ; } else if ( strcasecmp ( alg , "des-ede3-cbc" ) == 0 ) { cipher = EVP_des_ede3_cbc ( ) ; } else if ( strcasecmp ( alg , "aes-128-ecb" ) == 0 ) { cipher = EVP_aes_128_ecb ( ) ; } else if ( strcasecmp ( alg , "aes-128-cbc" ) == 0 ) { cipher = EVP_aes_128_cbc ( ) ; } else if ( strcasecmp ( alg , "aes-128-ctr" ) == 0 ) { cipher = EVP_aes_128_ctr ( ) ; } else if ( strcasecmp ( alg , "aes-128-gcm" ) == 0 ) { cipher = EVP_aes_128_gcm ( ) ; } else if ( strcasecmp ( alg , "aes-192-ecb" ) == 0 ) { cipher = EVP_aes_192_ecb ( ) ; } else if ( strcasecmp ( alg , "aes-192-cbc" ) == 0 ) { cipher = EVP_aes_192_cbc ( ) ; } else if ( strcasecmp ( alg , "aes-192-ctr" ) == 0 ) { cipher = EVP_aes_192_ctr ( ) ; } else if ( strcasecmp ( alg , "aes-192-gcm" ) == 0 ) { cipher = EVP_aes_192_gcm ( ) ; } else if ( strcasecmp ( alg , "aes-256-ecb" ) == 0 ) { cipher = EVP_aes_256_ecb ( ) ; } else if ( strcasecmp ( alg , "aes-256-cbc" ) == 0 ) { cipher = EVP_aes_256_cbc ( ) ; } else if ( strcasecmp ( alg , "aes-256-ctr" ) == 0 ) { cipher = EVP_aes_256_ctr ( ) ; } else if ( strcasecmp ( alg , "aes-256-gcm" ) == 0 ) { cipher = EVP_aes_256_gcm ( ) ; } else { JNI_TRACE ( "NativeCrypto_EVP_get_digestbyname(%s) => error" , alg ) ; return 0 ; } return reinterpret_cast < uintptr_t > ( cipher ) ; #endif }
void CIRCSock :: ReadLine ( const CString & sData ) { CString sLine = sData ; sLine . TrimRight ( "\n\r" ) ; DEBUG ( "(" < < m_pNetwork -> GetUser ( ) -> GetUserName ( ) < < "/" < < m_pNetwork -> GetName ( ) < < ") IRC -> ZNC [" < < sLine < < "]" ) ; bool bReturn = false ; IRCSOCKMODULECALL ( OnRaw ( sLine ) , & bReturn ) ; if ( bReturn ) return ; CMessage Message ( sLine ) ; Message . SetNetwork ( m_pNetwork ) ; IRCSOCKMODULECALL ( OnRawMessage ( Message ) , & bReturn ) ; if ( bReturn ) return ; switch ( Message . GetType ( ) ) { case CMessage :: Type :: Account : bReturn = OnAccountMessage ( Message ) ; break ; case CMessage :: Type :: Action : bReturn = OnActionMessage ( Message ) ; break ; case CMessage :: Type :: Away : bReturn = OnAwayMessage ( Message ) ; break ; case CMessage :: Type :: Capability : bReturn = OnCapabilityMessage ( Message ) ; break ; case CMessage :: Type :: CTCP : bReturn = OnCTCPMessage ( Message ) ; break ; case CMessage :: Type :: Error : bReturn = OnErrorMessage ( Message ) ; break ; case CMessage :: Type :: Invite : bReturn = OnInviteMessage ( Message ) ; break ; case CMessage :: Type :: Join : bReturn = OnJoinMessage ( Message ) ; break ; case CMessage :: Type :: Kick : bReturn = OnKickMessage ( Message ) ; break ; case CMessage :: Type :: Mode : bReturn = OnModeMessage ( Message ) ; break ; case CMessage :: Type :: Nick : bReturn = OnNickMessage ( Message ) ; break ; case CMessage :: Type :: Notice : bReturn = OnNoticeMessage ( Message ) ; break ; case CMessage :: Type :: Numeric : bReturn = OnNumericMessage ( Message ) ; break ; case CMessage :: Type :: Part : bReturn = OnPartMessage ( Message ) ; break ; case CMessage :: Type :: Ping : bReturn = OnPingMessage ( Message ) ; break ; case CMessage :: Type :: Pong : bReturn = OnPongMessage ( Message ) ; break ; case CMessage :: Type :: Quit : bReturn = OnQuitMessage ( Message ) ; break ; case CMessage :: Type :: Text : bReturn = OnTextMessage ( Message ) ; break ; case CMessage :: Type :: Topic : bReturn = OnTopicMessage ( Message ) ; break ; case CMessage :: Type :: Wallops : bReturn = OnWallopsMessage ( Message ) ; break ; default : break ; } if ( bReturn ) return ; m_pNetwork -> PutUser ( Message ) ; }
void vp9_setup_pre_planes ( MACROBLOCKD * xd , int idx , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col , const struct scale_factors * sf ) { if ( src != NULL ) { int i ; uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , src -> alpha_buffer } ; const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , src -> alpha_stride } ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { struct macroblockd_plane * const pd = & xd -> plane [ i ] ; setup_pred_plane ( & pd -> pre [ idx ] , buffers [ i ] , strides [ i ] , mi_row , mi_col , sf , pd -> subsampling_x , pd -> subsampling_y ) ; } } }
ppdEmitFd ( ppd_file_t * ppd , int fd , ppd_section_t section ) { char * buffer , * bufptr ; size_t buflength ; ssize_t bytes ; int status ; if ( ! ppd || fd < 0 ) return ( - 1 ) ; buffer = ppdEmitString ( ppd , section , 0.0 ) ; if ( buffer ) { buflength = strlen ( buffer ) ; bufptr = buffer ; bytes = 0 ; while ( buflength > 0 ) { #ifdef WIN32 if ( ( bytes = ( ssize_t ) write ( fd , bufptr , ( unsigned ) buflength ) ) < 0 ) #else if ( ( bytes = write ( fd , bufptr , buflength ) ) < 0 ) #endif /* WIN32 */ { if ( errno == EAGAIN || errno == EINTR ) continue ; break ; } buflength -= ( size_t ) bytes ; bufptr += bytes ; } status = bytes < 0 ? - 1 : 0 ; free ( buffer ) ; } else status = 0 ; return ( status ) ; }
CbrDetectorRemote :: Result CbrDetectorRemote :: Decrypt ( cricket :: MediaType media_type , const std :: vector < uint32_t > & csrcs , rtc :: ArrayView < const uint8_t > additional_data , rtc :: ArrayView < const uint8_t > encrypted_frame , rtc :: ArrayView < uint8_t > frame ) { const uint8_t * src = encrypted_frame . data ( ) ; uint8_t * dst = frame . data ( ) ; uint32_t data_len = encrypted_frame . size ( ) ; if ( media_type == cricket :: MEDIA_TYPE_AUDIO ) { if ( data_len == frame_size && frame_size >= 40 ) { frame_count ++ ; if ( frame_count > 200 && ! detected ) { info ( "CBR detector: remote cbr detected\n" ) ; detected = true ; } } else { frame_count = 0 ; frame_size = data_len ; if ( detected ) { info ( "CBR detector: remote cbr detected disabled\n" ) ; detected = false ; } } } memcpy ( dst , src , data_len ) ; out : return CbrDetectorRemote :: Result ( CbrDetectorRemote :: Status :: kOk , data_len ) ; }
void ScheduleNode ( BasicBlock * block , Node * node ) { schedule_ -> PlanNode ( block , node ) ; size_t block_id = block -> id ( ) . ToSize ( ) ; if ( ! scheduler_ -> scheduled_nodes_ [ block_id ] ) { scheduler_ -> scheduled_nodes_ [ block_id ] = new ( zone_ -> New ( sizeof ( NodeVector ) ) ) NodeVector ( zone_ ) ; } scheduler_ -> scheduled_nodes_ [ block_id ] -> push_back ( node ) ; scheduler_ -> UpdatePlacement ( node , Scheduler :: kScheduled ) ; }
Node * WasmGraphBuilder :: SimdLaneOp ( wasm :: WasmOpcode opcode , uint8_t lane , Node * const * inputs ) { has_simd_ = true ; switch ( opcode ) { case wasm :: kExprF32x4ExtractLane : return graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> F32x4ExtractLane ( lane ) , inputs [ 0 ] ) ; case wasm :: kExprF32x4ReplaceLane : return graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> F32x4ReplaceLane ( lane ) , inputs [ 0 ] , inputs [ 1 ] ) ; case wasm :: kExprI32x4ExtractLane : return graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> I32x4ExtractLane ( lane ) , inputs [ 0 ] ) ; case wasm :: kExprI32x4ReplaceLane : return graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> I32x4ReplaceLane ( lane ) , inputs [ 0 ] , inputs [ 1 ] ) ; case wasm :: kExprI16x8ExtractLane : return graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> I16x8ExtractLane ( lane ) , inputs [ 0 ] ) ; case wasm :: kExprI16x8ReplaceLane : return graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> I16x8ReplaceLane ( lane ) , inputs [ 0 ] , inputs [ 1 ] ) ; case wasm :: kExprI8x16ExtractLane : return graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> I8x16ExtractLane ( lane ) , inputs [ 0 ] ) ; case wasm :: kExprI8x16ReplaceLane : return graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> I8x16ReplaceLane ( lane ) , inputs [ 0 ] , inputs [ 1 ] ) ; default : FATAL_UNSUPPORTED_OPCODE ( opcode ) ; } }
char * compose_path ( ctrl_t * ctrl , char * path ) { struct stat st ; static char rpath [ PATH_MAX ] ; char * name , * ptr ; char dir [ PATH_MAX ] = { 0 } ; strlcpy ( dir , ctrl -> cwd , sizeof ( dir ) ) ; DBG ( "Compose path from cwd: %s, arg: %s" , ctrl -> cwd , path ? : "" ) ; if ( ! path || ! strlen ( path ) ) goto check ; if ( path ) { if ( path [ 0 ] != '/' ) { if ( dir [ strlen ( dir ) - 1 ] != '/' ) strlcat ( dir , "/" , sizeof ( dir ) ) ; } strlcat ( dir , path , sizeof ( dir ) ) ; } check : while ( ( ptr = strstr ( dir , "//" ) ) ) memmove ( ptr , & ptr [ 1 ] , strlen ( & ptr [ 1 ] ) + 1 ) ; if ( ! chrooted ) { size_t len = strlen ( home ) ; DBG ( "Server path from CWD: %s" , dir ) ; if ( len > 0 && home [ len - 1 ] == '/' ) len -- ; memmove ( dir + len , dir , strlen ( dir ) + 1 ) ; memcpy ( dir , home , len ) ; DBG ( "Resulting non-chroot path: %s" , dir ) ; } if ( ! stat ( dir , & st ) && S_ISDIR ( st . st_mode ) ) { if ( ! realpath ( dir , rpath ) ) return NULL ; } else { name = basename ( path ) ; ptr = dirname ( dir ) ; memset ( rpath , 0 , sizeof ( rpath ) ) ; if ( ! realpath ( ptr , rpath ) ) { INFO ( "Failed realpath(%s): %m" , ptr ) ; return NULL ; } if ( rpath [ 1 ] != 0 ) strlcat ( rpath , "/" , sizeof ( rpath ) ) ; strlcat ( rpath , name , sizeof ( rpath ) ) ; } if ( ! chrooted && strncmp ( dir , home , strlen ( home ) ) ) { DBG ( "Failed non-chroot dir:%s vs home:%s" , dir , home ) ; return NULL ; } return rpath ; }
TF_BUILTIN ( ArrayFindLoopContinuation , ArrayBuiltinsAssembler ) { TNode < Context > context = CAST ( Parameter ( Descriptor :: kContext ) ) ; TNode < Object > receiver = CAST ( Parameter ( Descriptor :: kReceiver ) ) ; Node * callbackfn = Parameter ( Descriptor :: kCallbackFn ) ; Node * this_arg = Parameter ( Descriptor :: kThisArg ) ; Node * array = Parameter ( Descriptor :: kArray ) ; TNode < JSReceiver > object = CAST ( Parameter ( Descriptor :: kObject ) ) ; Node * initial_k = Parameter ( Descriptor :: kInitialK ) ; TNode < Number > len = CAST ( Parameter ( Descriptor :: kLength ) ) ; Node * to = Parameter ( Descriptor :: kTo ) ; InitIteratingArrayBuiltinLoopContinuation ( context , receiver , callbackfn , this_arg , array , object , initial_k , len , to ) ; GenerateIteratingArrayBuiltinLoopContinuation ( & ArrayBuiltinsAssembler :: FindProcessor , & ArrayBuiltinsAssembler :: NullPostLoopAction , MissingPropertyMode :: kUseUndefined , ForEachDirection :: kForward ) ; }
fep_client_open ( const char * address ) { FepClient * client ; struct sockaddr_un sun ; ssize_t sun_len ; int retval ; if ( ! address ) address = getenv ( "LIBFEP_CONTROL_SOCK" ) ; if ( ! address ) return NULL ; if ( strlen ( address ) + 1 >= sizeof ( sun . sun_path ) ) { fep_log ( FEP_LOG_LEVEL_WARNING , "unix domain socket path too long: %d + 1 >= %d" , strlen ( address ) , sizeof ( sun . sun_path ) ) ; free ( address ) ; return NULL ; } client = xzalloc ( sizeof ( FepClient ) ) ; client -> filter_running = false ; client -> messages = NULL ; memset ( & sun , 0 , sizeof ( struct sockaddr_un ) ) ; sun . sun_family = AF_UNIX ; #ifdef __linux__ sun . sun_path [ 0 ] = '\0' ; memcpy ( sun . sun_path + 1 , address , strlen ( address ) ) ; sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ; #else memcpy ( sun . sun_path , address , strlen ( address ) ) ; sun_len = sizeof ( struct sockaddr_un ) ; #endif client -> control = socket ( AF_UNIX , SOCK_STREAM , 0 ) ; if ( client -> control < 0 ) { free ( client ) ; return NULL ; } retval = connect ( client -> control , ( const struct sockaddr * ) & sun , sun_len ) ; if ( retval < 0 ) { close ( client -> control ) ; free ( client ) ; return NULL ; } return client ; }
js :: SetTypedObjectOffset ( ThreadSafeContext * , unsigned argc , Value * vp ) { CallArgs args = CallArgsFromVp ( argc , vp ) ; JS_ASSERT ( argc == 2 ) ; JS_ASSERT ( args [ 0 ] . isObject ( ) && args [ 0 ] . toObject ( ) . is < TypedObject > ( ) ) ; JS_ASSERT ( args [ 1 ] . isInt32 ( ) ) ; TypedObject & typedObj = args [ 0 ] . toObject ( ) . as < TypedObject > ( ) ; int32_t offset = args [ 1 ] . toInt32 ( ) ; JS_ASSERT ( typedObj . typedMem ( ) != nullptr ) ; typedObj . setPrivate ( typedObj . owner ( ) . dataPointer ( ) + offset ) ; typedObj . setReservedSlot ( JS_TYPEDOBJ_SLOT_BYTEOFFSET , Int32Value ( offset ) ) ; return true ; }
const Operator * JSOperatorBuilder :: CreateGeneratorObject ( ) { return new ( zone ( ) ) Operator ( IrOpcode :: kJSCreateGeneratorObject , Operator :: kEliminatable , "JSCreateGeneratorObject" , 2 , 1 , 1 , 1 , 1 , 0 ) ; }
static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; if ( pmc_overflow ( val ) ) write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
void Generate_ContinueToBuiltinHelper ( MacroAssembler * masm , bool java_script_builtin , bool with_result ) { const RegisterConfiguration * config ( RegisterConfiguration :: Default ( ) ) ; int allocatable_register_count = config -> num_allocatable_general_registers ( ) ; if ( with_result ) { __ mov ( Operand ( esp , config -> num_allocatable_general_registers ( ) * kPointerSize + BuiltinContinuationFrameConstants :: kFixedFrameSize ) , eax ) ; } for ( int i = allocatable_register_count - 1 ; i >= 0 ; -- i ) { int code = config -> GetAllocatableGeneralCode ( i ) ; __ pop ( Register :: from_code ( code ) ) ; if ( java_script_builtin && code == kJavaScriptCallArgCountRegister . code ( ) ) { __ SmiUntag ( Register :: from_code ( code ) ) ; } } __ mov ( ebp , Operand ( esp , BuiltinContinuationFrameConstants :: kFixedFrameSizeFromFp ) ) ; const int offsetToPC = BuiltinContinuationFrameConstants :: kFixedFrameSizeFromFp - kPointerSize ; __ pop ( Operand ( esp , offsetToPC ) ) ; __ Drop ( offsetToPC / kPointerSize ) ; __ add ( Operand ( esp , 0 ) , Immediate ( Code :: kHeaderSize - kHeapObjectTag ) ) ; __ ret ( 0 ) ; }
find_file_in_path_option ( char_u * ptr , int len , int options , int first , char_u * path_option , int find_what , char_u * rel_fname , char_u * suffixes ) { static char_u * dir ; static int did_findfile_init = FALSE ; char_u save_char ; char_u * file_name = NULL ; char_u * buf = NULL ; int rel_to_curdir ; # ifdef AMIGA struct Process * proc = ( struct Process * ) FindTask ( 0L ) ; APTR save_winptr = proc -> pr_WindowPtr ; proc -> pr_WindowPtr = ( APTR ) - 1L ; # endif if ( first == TRUE ) { save_char = ptr [ len ] ; ptr [ len ] = NUL ; expand_env_esc ( ptr , NameBuff , MAXPATHL , FALSE , TRUE , NULL ) ; ptr [ len ] = save_char ; vim_free ( ff_file_to_find ) ; ff_file_to_find = vim_strsave ( NameBuff ) ; if ( ff_file_to_find == NULL ) { file_name = NULL ; goto theend ; } if ( options & FNAME_UNESC ) { for ( ptr = ff_file_to_find ; * ptr != NUL ; ++ ptr ) if ( ptr [ 0 ] == '\\' && ptr [ 1 ] == ' ' ) mch_memmove ( ptr , ptr + 1 , STRLEN ( ptr ) ) ; } } rel_to_curdir = ( ff_file_to_find [ 0 ] == '.' && ( ff_file_to_find [ 1 ] == NUL || vim_ispathsep ( ff_file_to_find [ 1 ] ) || ( ff_file_to_find [ 1 ] == '.' && ( ff_file_to_find [ 2 ] == NUL || vim_ispathsep ( ff_file_to_find [ 2 ] ) ) ) ) ) ; if ( vim_isAbsName ( ff_file_to_find ) || rel_to_curdir # if defined(MSWIN) || vim_ispathsep ( ff_file_to_find [ 0 ] ) || ( ff_file_to_find [ 0 ] != NUL && ff_file_to_find [ 1 ] == ':' ) # endif # ifdef AMIGA || ff_file_to_find [ 0 ] == ':' # endif ) { if ( first == TRUE ) { int l ; int run ; if ( path_with_url ( ff_file_to_find ) ) { file_name = vim_strsave ( ff_file_to_find ) ; goto theend ; } for ( run = 1 ; run <= 2 ; ++ run ) { l = ( int ) STRLEN ( ff_file_to_find ) ; if ( run == 1 && rel_to_curdir && ( options & FNAME_REL ) && rel_fname != NULL && STRLEN ( rel_fname ) + l < MAXPATHL ) { STRCPY ( NameBuff , rel_fname ) ; STRCPY ( gettail ( NameBuff ) , ff_file_to_find ) ; l = ( int ) STRLEN ( NameBuff ) ; } else { STRCPY ( NameBuff , ff_file_to_find ) ; run = 2 ; } buf = suffixes ; for ( ; ; ) { if ( mch_getperm ( NameBuff ) >= 0 && ( find_what == FINDFILE_BOTH || ( ( find_what == FINDFILE_DIR ) == mch_isdir ( NameBuff ) ) ) ) { file_name = vim_strsave ( NameBuff ) ; goto theend ; } if ( * buf == NUL ) break ; copy_option_part ( & buf , NameBuff + l , MAXPATHL - l , "," ) ; } } } } else { if ( first == TRUE ) { vim_findfile_free_visited ( fdip_search_ctx ) ; dir = path_option ; did_findfile_init = FALSE ; } for ( ; ; ) { if ( did_findfile_init ) { file_name = vim_findfile ( fdip_search_ctx ) ; if ( file_name != NULL ) break ; did_findfile_init = FALSE ; } else { char_u * r_ptr ; if ( dir == NULL || * dir == NUL ) { vim_findfile_cleanup ( fdip_search_ctx ) ; fdip_search_ctx = NULL ; break ; } if ( ( buf = alloc ( MAXPATHL ) ) == NULL ) break ; buf [ 0 ] = 0 ; copy_option_part ( & dir , buf , MAXPATHL , " ," ) ; # ifdef FEAT_PATH_EXTRA r_ptr = vim_findfile_stopdir ( buf ) ; # else r_ptr = NULL ; # endif fdip_search_ctx = vim_findfile_init ( buf , ff_file_to_find , r_ptr , 100 , FALSE , find_what , fdip_search_ctx , FALSE , rel_fname ) ; if ( fdip_search_ctx != NULL ) did_findfile_init = TRUE ; vim_free ( buf ) ; } } } if ( file_name == NULL && ( options & FNAME_MESS ) ) { if ( first == TRUE ) { if ( find_what == FINDFILE_DIR ) semsg ( _ ( "E344: Can't find directory \"%s\" in cdpath" ) , ff_file_to_find ) ; else semsg ( _ ( "E345: Can't find file \"%s\" in path" ) , ff_file_to_find ) ; } else { if ( find_what == FINDFILE_DIR ) semsg ( _ ( "E346: No more directory \"%s\" found in cdpath" ) , ff_file_to_find ) ; else semsg ( _ ( "E347: No more file \"%s\" found in path" ) , ff_file_to_find ) ; } } theend : # ifdef AMIGA proc -> pr_WindowPtr = save_winptr ; # endif return file_name ; }
Reduction TypedOptimization :: Reduce ( Node * node ) { DisallowHeapAccess no_heap_access ; switch ( node -> opcode ( ) ) { case IrOpcode :: kConvertReceiver : return ReduceConvertReceiver ( node ) ; case IrOpcode :: kCheckHeapObject : return ReduceCheckHeapObject ( node ) ; case IrOpcode :: kCheckNotTaggedHole : return ReduceCheckNotTaggedHole ( node ) ; case IrOpcode :: kCheckMaps : return ReduceCheckMaps ( node ) ; case IrOpcode :: kCheckNumber : return ReduceCheckNumber ( node ) ; case IrOpcode :: kCheckString : return ReduceCheckString ( node ) ; case IrOpcode :: kCheckEqualsInternalizedString : return ReduceCheckEqualsInternalizedString ( node ) ; case IrOpcode :: kCheckEqualsSymbol : return ReduceCheckEqualsSymbol ( node ) ; case IrOpcode :: kLoadField : return ReduceLoadField ( node ) ; case IrOpcode :: kNumberCeil : case IrOpcode :: kNumberRound : case IrOpcode :: kNumberTrunc : return ReduceNumberRoundop ( node ) ; case IrOpcode :: kNumberFloor : return ReduceNumberFloor ( node ) ; case IrOpcode :: kNumberToUint8Clamped : return ReduceNumberToUint8Clamped ( node ) ; case IrOpcode :: kPhi : return ReducePhi ( node ) ; case IrOpcode :: kReferenceEqual : return ReduceReferenceEqual ( node ) ; case IrOpcode :: kStringEqual : case IrOpcode :: kStringLessThan : case IrOpcode :: kStringLessThanOrEqual : return ReduceStringComparison ( node ) ; case IrOpcode :: kSameValue : return ReduceSameValue ( node ) ; case IrOpcode :: kSelect : return ReduceSelect ( node ) ; case IrOpcode :: kTypeOf : return ReduceTypeOf ( node ) ; case IrOpcode :: kToBoolean : return ReduceToBoolean ( node ) ; case IrOpcode :: kSpeculativeToNumber : return ReduceSpeculativeToNumber ( node ) ; default : break ; } return NoChange ( ) ; }
static ssize_t oz_cdev_write ( struct file * filp , const char __user * buf , size_t count , loff_t * fpos ) { struct oz_pd * pd ; struct oz_elt_buf * eb ; struct oz_elt_info * ei ; struct oz_elt * elt ; struct oz_app_hdr * app_hdr ; struct oz_serial_ctx * ctx ; spin_lock_bh ( & g_cdev . lock ) ; pd = g_cdev . active_pd ; if ( pd ) oz_pd_get ( pd ) ; spin_unlock_bh ( & g_cdev . lock ) ; if ( pd == NULL ) return - ENXIO ; if ( ! ( pd -> state & OZ_PD_S_CONNECTED ) ) return - EAGAIN ; eb = & pd -> elt_buff ; ei = oz_elt_info_alloc ( eb ) ; if ( ei == NULL ) { count = 0 ; goto out ; } elt = ( struct oz_elt * ) ei -> data ; app_hdr = ( struct oz_app_hdr * ) ( elt + 1 ) ; elt -> length = sizeof ( struct oz_app_hdr ) + count ; elt -> type = OZ_ELT_APP_DATA ; ei -> app_id = OZ_APPID_SERIAL ; ei -> length = elt -> length + sizeof ( struct oz_elt ) ; app_hdr -> app_id = OZ_APPID_SERIAL ; if ( copy_from_user ( app_hdr + 1 , buf , count ) ) goto out ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; ctx = ( struct oz_serial_ctx * ) pd -> app_ctx [ OZ_APPID_SERIAL - 1 ] ; if ( ctx ) { app_hdr -> elt_seq_num = ctx -> tx_seq_num ++ ; if ( ctx -> tx_seq_num == 0 ) ctx -> tx_seq_num = 1 ; spin_lock ( & eb -> lock ) ; if ( oz_queue_elt_info ( eb , 0 , 0 , ei ) == 0 ) ei = NULL ; spin_unlock ( & eb -> lock ) ; } spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; out : if ( ei ) { count = 0 ; spin_lock_bh ( & eb -> lock ) ; oz_elt_info_free ( eb , ei ) ; spin_unlock_bh ( & eb -> lock ) ; } oz_pd_put ( pd ) ; return count ; }
unix_client_connect ( hsm_com_client_hdl_t * hdl ) { int fd , len ; struct sockaddr_un unix_addr ; if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 ) { return HSM_COM_ERROR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; if ( strlen ( hdl -> c_path ) >= sizeof ( unix_addr . sun_path ) ) { close ( fd ) ; return HSM_COM_PATH_ERR ; } snprintf ( unix_addr . sun_path , sizeof ( unix_addr . sun_path ) , "%s" , hdl -> c_path ) ; len = SUN_LEN ( & unix_addr ) ; unlink ( unix_addr . sun_path ) ; if ( bind ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) { unlink ( hdl -> c_path ) ; close ( fd ) ; return HSM_COM_BIND_ERR ; } if ( chmod ( unix_addr . sun_path , S_IRWXU ) < 0 ) { unlink ( hdl -> c_path ) ; close ( fd ) ; return HSM_COM_CHMOD_ERR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; strncpy ( unix_addr . sun_path , hdl -> s_path , sizeof ( unix_addr . sun_path ) ) ; unix_addr . sun_path [ sizeof ( unix_addr . sun_path ) - 1 ] = 0 ; len = SUN_LEN ( & unix_addr ) ; if ( connect ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) { unlink ( hdl -> c_path ) ; close ( fd ) ; return HSM_COM_CONX_ERR ; } hdl -> client_fd = fd ; hdl -> client_state = HSM_COM_C_STATE_CT ; if ( unix_sck_send_conn ( hdl , 2 ) != HSM_COM_OK ) { hdl -> client_state = HSM_COM_C_STATE_IN ; return HSM_COM_SEND_ERR ; } return HSM_COM_OK ; }
static int rtnl_fill_link_ifmap ( struct sk_buff * skb , struct net_device * dev ) { struct rtnl_link_ifmap map = { . mem_start = dev -> mem_start , . mem_end = dev -> mem_end , . base_addr = dev -> base_addr , . irq = dev -> irq , . dma = dev -> dma , . port = dev -> if_port , } ; if ( nla_put ( skb , IFLA_MAP , sizeof ( map ) , & map ) ) return - EMSGSIZE ; return 0 ; }
static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; if ( likely ( walk . nbytes == nbytes ) ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }
static bool check_client_passwd ( PgSocket * client , const char * passwd ) { char md5 [ MD5_PASSWD_LEN + 1 ] ; const char * correct ; PgUser * user = client -> auth_user ; if ( ! * passwd || ! * user -> passwd ) return false ; switch ( cf_auth_type ) { case AUTH_PLAIN : return strcmp ( user -> passwd , passwd ) == 0 ; case AUTH_CRYPT : correct = crypt ( user -> passwd , ( char * ) client -> tmp_login_salt ) ; return correct && strcmp ( correct , passwd ) == 0 ; case AUTH_MD5 : if ( strlen ( passwd ) != MD5_PASSWD_LEN ) return false ; if ( ! isMD5 ( user -> passwd ) ) pg_md5_encrypt ( user -> passwd , user -> name , strlen ( user -> name ) , user -> passwd ) ; pg_md5_encrypt ( user -> passwd + 3 , ( char * ) client -> tmp_login_salt , 4 , md5 ) ; return strcmp ( md5 , passwd ) == 0 ; } return false ; }
void BuildBlocks ( Node * node ) { switch ( node -> opcode ( ) ) { case IrOpcode :: kEnd : FixNode ( schedule_ -> end ( ) , node ) ; break ; case IrOpcode :: kStart : FixNode ( schedule_ -> start ( ) , node ) ; break ; case IrOpcode :: kLoop : case IrOpcode :: kMerge : BuildBlockForNode ( node ) ; break ; case IrOpcode :: kTerminate : { Node * loop = NodeProperties :: GetControlInput ( node ) ; BasicBlock * block = BuildBlockForNode ( loop ) ; FixNode ( block , node ) ; break ; } case IrOpcode :: kBranch : case IrOpcode :: kSwitch : BuildBlocksForSuccessors ( node ) ; break ; #define BUILD_BLOCK_JS_CASE(Name) case IrOpcode::k##Name: JS_OP_LIST ( BUILD_BLOCK_JS_CASE ) #undef BUILD_BLOCK_JS_CASE case IrOpcode :: kCall : case IrOpcode :: kCallWithCallerSavedRegisters : if ( NodeProperties :: IsExceptionalCall ( node ) ) { BuildBlocksForSuccessors ( node ) ; } break ; default : break ; } }
base :: Optional < MapRef > MapRef :: AsElementsKind ( ElementsKind kind ) const { if ( broker ( ) -> mode ( ) == JSHeapBroker :: kDisabled ) { AllowHandleAllocation handle_allocation ; AllowHeapAllocation heap_allocation ; AllowHandleDereference allow_handle_dereference ; return MapRef ( broker ( ) , Map :: AsElementsKind ( broker ( ) -> isolate ( ) , object < Map > ( ) , kind ) ) ; } else { if ( kind == elements_kind ( ) ) return * this ; const ZoneVector < MapData * > & elements_kind_generalizations = data ( ) -> AsMap ( ) -> elements_kind_generalizations ( ) ; for ( auto data : elements_kind_generalizations ) { MapRef map ( data ) ; if ( map . elements_kind ( ) == kind ) return map ; } return base :: Optional < MapRef > ( ) ; } }
static nsCheapSetOperator ResetNodeDirection ( nsPtrHashKey < Element > * aEntry , void * aData ) { MOZ_ASSERT ( aEntry -> GetKey ( ) -> IsElement ( ) , "Must be an Element" ) ; nsINode * oldTextNode = static_cast < Element * > ( aData ) ; Element * rootNode = aEntry -> GetKey ( ) ; nsTextNode * newTextNode = nullptr ; if ( rootNode -> GetParentNode ( ) && rootNode -> HasDirAuto ( ) ) { newTextNode = WalkDescendantsSetDirectionFromText ( rootNode , true , oldTextNode ) ; } if ( newTextNode ) { nsTextNodeDirectionalityMap :: AddEntryToMap ( newTextNode , rootNode ) ; } else { rootNode -> ClearHasDirAutoSet ( ) ; rootNode -> UnsetProperty ( nsGkAtoms :: dirAutoSetBy ) ; } return OpRemove ; }
LinearScanAllocator :: allocateSlotFor ( const LiveInterval * interval ) { LinearScanVirtualRegister * reg = & vregs [ interval -> vreg ( ) ] ; SlotList * freed ; if ( reg -> type ( ) == LDefinition :: DOUBLE || IsNunbox ( reg ) ) freed = & finishedDoubleSlots_ ; else freed = & finishedSlots_ ; if ( ! freed -> empty ( ) ) { LiveInterval * maybeDead = freed -> back ( ) ; if ( maybeDead -> end ( ) < reg -> getInterval ( 0 ) -> start ( ) ) { freed -> popBack ( ) ; LinearScanVirtualRegister * dead = & vregs [ maybeDead -> vreg ( ) ] ; #ifdef JS_NUNBOX32 if ( IsNunbox ( dead ) ) return BaseOfNunboxSlot ( dead -> type ( ) , dead -> canonicalSpillSlot ( ) ) ; #endif return dead -> canonicalSpillSlot ( ) ; } } if ( IsNunbox ( reg ) ) return stackSlotAllocator . allocateValueSlot ( ) ; if ( reg -> isDouble ( ) ) return stackSlotAllocator . allocateDoubleSlot ( ) ; return stackSlotAllocator . allocateSlot ( ) ; }
static vpx_codec_err_t vp8e_set_previewpp ( vpx_codec_alg_priv_t * ctx , int ctr_id , va_list args ) { #if CONFIG_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; ( void ) ctr_id ; if ( data ) { ctx -> preview_ppcfg = * ( ( vp8_postproc_cfg_t * ) data ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; #else ( void ) ctx ; ( void ) ctr_id ; ( void ) args ; return VPX_CODEC_INCAPABLE ; #endif }
nsXMLHttpRequest :: GetInterface ( JSContext * aCx , nsIJSID * aIID , ErrorResult & aRv ) { const nsID * iid = aIID -> GetID ( ) ; nsCOMPtr < nsISupports > result ; JS :: Value v = JSVAL_NULL ; aRv = GetInterface ( * iid , getter_AddRefs ( result ) ) ; NS_ENSURE_FALSE ( aRv . Failed ( ) , JSVAL_NULL ) ; JSObject * global = JS_GetGlobalForObject ( aCx , GetWrapper ( ) ) ; aRv = nsContentUtils :: WrapNative ( aCx , global , result , iid , & v ) ; return aRv . Failed ( ) ? JSVAL_NULL : v ; }
YarrPatternConstructor ( YarrPattern & pattern ) : m_pattern ( pattern ) , m_stackBase ( nullptr ) , m_characterClassConstructor ( pattern . m_ignoreCase ) , m_invertParentheticalAssertion ( false ) { m_pattern . m_body = js_new < PatternDisjunction > ( ) ; m_alternative = m_pattern . m_body -> addNewAlternative ( ) ; m_pattern . m_disjunctions . append ( m_pattern . m_body ) ; }
sp < IEffect > AudioFlinger :: createEffect ( effect_descriptor_t * pDesc , const sp < IEffectClient > & effectClient , int32_t priority , audio_io_handle_t io , audio_session_t sessionId , const String16 & opPackageName , pid_t pid , status_t * status , int * id , int * enabled ) { status_t lStatus = NO_ERROR ; sp < EffectHandle > handle ; effect_descriptor_t desc ; const uid_t callingUid = IPCThreadState :: self ( ) -> getCallingUid ( ) ; if ( pid == - 1 || ! isTrustedCallingUid ( callingUid ) ) { const pid_t callingPid = IPCThreadState :: self ( ) -> getCallingPid ( ) ; ALOGW_IF ( pid != - 1 && pid != callingPid , "%s uid %d pid %d tried to pass itself off as pid %d" , __func__ , callingUid , callingPid , pid ) ; pid = callingPid ; } ALOGV ( "createEffect pid %d, effectClient %p, priority %d, sessionId %d, io %d, factory %p" , pid , effectClient . get ( ) , priority , sessionId , io , mEffectsFactoryHal . get ( ) ) ; if ( pDesc == NULL ) { lStatus = BAD_VALUE ; goto Exit ; } if ( sessionId == AUDIO_SESSION_OUTPUT_MIX && ! settingsAllowed ( ) ) { lStatus = PERMISSION_DENIED ; goto Exit ; } if ( sessionId == AUDIO_SESSION_OUTPUT_STAGE && getpid_cached != pid ) { lStatus = PERMISSION_DENIED ; goto Exit ; } if ( mEffectsFactoryHal == 0 ) { lStatus = NO_INIT ; goto Exit ; } { Mutex :: Autolock _l ( mLock ) ; if ( ! EffectsFactoryHalInterface :: isNullUuid ( & pDesc -> uuid ) ) { lStatus = mEffectsFactoryHal -> getDescriptor ( & pDesc -> uuid , & desc ) ; if ( lStatus < 0 ) { ALOGW ( "createEffect() error %d from EffectGetDescriptor" , lStatus ) ; goto Exit ; } } else { if ( EffectsFactoryHalInterface :: isNullUuid ( & pDesc -> type ) ) { ALOGW ( "createEffect() no effect type" ) ; lStatus = BAD_VALUE ; goto Exit ; } uint32_t numEffects = 0 ; effect_descriptor_t d ; d . flags = 0 ; bool found = false ; lStatus = mEffectsFactoryHal -> queryNumberEffects ( & numEffects ) ; if ( lStatus < 0 ) { ALOGW ( "createEffect() error %d from EffectQueryNumberEffects" , lStatus ) ; goto Exit ; } for ( uint32_t i = 0 ; i < numEffects ; i ++ ) { lStatus = mEffectsFactoryHal -> getDescriptor ( i , & desc ) ; if ( lStatus < 0 ) { ALOGW ( "createEffect() error %d from EffectQueryEffect" , lStatus ) ; continue ; } if ( memcmp ( & desc . type , & pDesc -> type , sizeof ( effect_uuid_t ) ) == 0 ) { found = true ; d = desc ; if ( sessionId != AUDIO_SESSION_OUTPUT_MIX || ( desc . flags & EFFECT_FLAG_TYPE_MASK ) == EFFECT_FLAG_TYPE_AUXILIARY ) { break ; } } } if ( ! found ) { lStatus = BAD_VALUE ; ALOGW ( "createEffect() effect not found" ) ; goto Exit ; } if ( sessionId == AUDIO_SESSION_OUTPUT_MIX && ( d . flags & EFFECT_FLAG_TYPE_MASK ) != EFFECT_FLAG_TYPE_AUXILIARY ) { desc = d ; } } } { if ( sessionId != AUDIO_SESSION_OUTPUT_MIX && ( desc . flags & EFFECT_FLAG_TYPE_MASK ) == EFFECT_FLAG_TYPE_AUXILIARY ) { lStatus = INVALID_OPERATION ; goto Exit ; } if ( ( memcmp ( & desc . type , SL_IID_VISUALIZATION , sizeof ( effect_uuid_t ) ) == 0 ) && ! recordingAllowed ( opPackageName , pid , IPCThreadState :: self ( ) -> getCallingUid ( ) ) ) { lStatus = PERMISSION_DENIED ; goto Exit ; } * pDesc = desc ; if ( io == AUDIO_IO_HANDLE_NONE && sessionId == AUDIO_SESSION_OUTPUT_MIX ) { io = AudioSystem :: getOutputForEffect ( & desc ) ; ALOGV ( "createEffect got output %d" , io ) ; } Mutex :: Autolock _l ( mLock ) ; if ( io == AUDIO_IO_HANDLE_NONE ) { if ( sessionId == AUDIO_SESSION_OUTPUT_STAGE ) { lStatus = BAD_VALUE ; goto Exit ; } for ( size_t i = 0 ; i < mPlaybackThreads . size ( ) ; i ++ ) { if ( mPlaybackThreads . valueAt ( i ) -> hasAudioSession ( sessionId ) != 0 ) { io = mPlaybackThreads . keyAt ( i ) ; break ; } } if ( io == AUDIO_IO_HANDLE_NONE ) { for ( size_t i = 0 ; i < mRecordThreads . size ( ) ; i ++ ) { if ( mRecordThreads . valueAt ( i ) -> hasAudioSession ( sessionId ) != 0 ) { io = mRecordThreads . keyAt ( i ) ; break ; } } } if ( io == AUDIO_IO_HANDLE_NONE ) { for ( size_t i = 0 ; i < mMmapThreads . size ( ) ; i ++ ) { if ( mMmapThreads . valueAt ( i ) -> hasAudioSession ( sessionId ) != 0 ) { io = mMmapThreads . keyAt ( i ) ; break ; } } } if ( io == AUDIO_IO_HANDLE_NONE && mPlaybackThreads . size ( ) > 0 ) { io = mPlaybackThreads . keyAt ( 0 ) ; } ALOGV ( "createEffect() got io %d for effect %s" , io , desc . name ) ; } ThreadBase * thread = checkRecordThread_l ( io ) ; if ( thread == NULL ) { thread = checkPlaybackThread_l ( io ) ; if ( thread == NULL ) { thread = checkMmapThread_l ( io ) ; if ( thread == NULL ) { ALOGE ( "createEffect() unknown output thread" ) ; lStatus = BAD_VALUE ; goto Exit ; } } } else { sp < EffectChain > chain = getOrphanEffectChain_l ( sessionId ) ; if ( chain != 0 ) { Mutex :: Autolock _l ( thread -> mLock ) ; thread -> addEffectChain_l ( chain ) ; } } sp < Client > client = registerPid ( pid ) ; bool pinned = ( sessionId > AUDIO_SESSION_OUTPUT_MIX ) && isSessionAcquired_l ( sessionId ) ; handle = thread -> createEffect_l ( client , effectClient , priority , sessionId , & desc , enabled , & lStatus , pinned ) ; if ( lStatus != NO_ERROR && lStatus != ALREADY_EXISTS ) { Mutex :: Autolock _cl ( mClientLock ) ; client . clear ( ) ; } else { if ( handle . get ( ) != nullptr && id != nullptr ) * id = handle -> id ( ) ; } } if ( lStatus != NO_ERROR && lStatus != ALREADY_EXISTS ) { handle . clear ( ) ; } Exit : * status = lStatus ; return handle ; }
void Builtins :: Generate_CallOrConstructForwardVarargs ( MacroAssembler * masm , CallOrConstructMode mode , Handle < Code > code ) { if ( mode == CallOrConstructMode :: kConstruct ) { Label new_target_constructor , new_target_not_constructor ; __ JumpIfSmi ( rdx , & new_target_not_constructor , Label :: kNear ) ; __ movp ( rbx , FieldOperand ( rdx , HeapObject :: kMapOffset ) ) ; __ testb ( FieldOperand ( rbx , Map :: kBitFieldOffset ) , Immediate ( Map :: IsConstructorBit :: kMask ) ) ; __ j ( not_zero , & new_target_constructor , Label :: kNear ) ; __ bind ( & new_target_not_constructor ) ; { FrameScope scope ( masm , StackFrame :: MANUAL ) ; __ EnterFrame ( StackFrame :: INTERNAL ) ; __ Push ( rdx ) ; __ CallRuntime ( Runtime :: kThrowNotConstructor ) ; } __ bind ( & new_target_constructor ) ; } Label arguments_adaptor , arguments_done ; __ movp ( rbx , Operand ( rbp , StandardFrameConstants :: kCallerFPOffset ) ) ; __ cmpp ( Operand ( rbx , CommonFrameConstants :: kContextOrFrameTypeOffset ) , Immediate ( StackFrame :: TypeToMarker ( StackFrame :: ARGUMENTS_ADAPTOR ) ) ) ; __ j ( equal , & arguments_adaptor , Label :: kNear ) ; { __ movp ( r8 , Operand ( rbp , JavaScriptFrameConstants :: kFunctionOffset ) ) ; __ movp ( r8 , FieldOperand ( r8 , JSFunction :: kSharedFunctionInfoOffset ) ) ; __ movzxwq ( r8 , FieldOperand ( r8 , SharedFunctionInfo :: kFormalParameterCountOffset ) ) ; __ movp ( rbx , rbp ) ; } __ jmp ( & arguments_done , Label :: kNear ) ; __ bind ( & arguments_adaptor ) ; { __ SmiUntag ( r8 , Operand ( rbx , ArgumentsAdaptorFrameConstants :: kLengthOffset ) ) ; } __ bind ( & arguments_done ) ; Label stack_done , stack_overflow ; __ subl ( r8 , rcx ) ; __ j ( less_equal , & stack_done ) ; { Generate_StackOverflowCheck ( masm , r8 , rcx , & stack_overflow , Label :: kNear ) ; { Label loop ; __ addl ( rax , r8 ) ; __ PopReturnAddressTo ( rcx ) ; __ bind ( & loop ) ; { StackArgumentsAccessor args ( rbx , r8 , ARGUMENTS_DONT_CONTAIN_RECEIVER ) ; __ Push ( args . GetArgumentOperand ( 0 ) ) ; __ decl ( r8 ) ; __ j ( not_zero , & loop ) ; } __ PushReturnAddressFrom ( rcx ) ; } } __ jmp ( & stack_done , Label :: kNear ) ; __ bind ( & stack_overflow ) ; __ TailCallRuntime ( Runtime :: kThrowStackOverflow ) ; __ bind ( & stack_done ) ; __ Jump ( code , RelocInfo :: CODE_TARGET ) ; }
static void __account_cfs_rq_runtime ( struct cfs_rq * cfs_rq , u64 delta_exec ) { cfs_rq -> runtime_remaining -= delta_exec ; expire_cfs_rq_runtime ( cfs_rq ) ; if ( likely ( cfs_rq -> runtime_remaining > 0 ) ) return ; if ( ! assign_cfs_rq_runtime ( cfs_rq ) && likely ( cfs_rq -> curr ) ) resched_curr ( rq_of ( cfs_rq ) ) ; }
void AstPrinter :: VisitForInStatement ( ForInStatement * node ) { IndentedScope indent ( this , "FOR IN" , node -> position ( ) ) ; PrintLabelsIndented ( node -> labels ( ) ) ; PrintLabelsIndented ( node -> own_labels ( ) , "OWN " ) ; PrintIndentedVisit ( "FOR" , node -> each ( ) ) ; PrintIndentedVisit ( "IN" , node -> enumerable ( ) ) ; PrintIndentedVisit ( "BODY" , node -> body ( ) ) ; }
void RegExpBuilder :: AddTrailSurrogate ( uc16 trail_surrogate ) { DCHECK ( unibrow :: Utf16 :: IsTrailSurrogate ( trail_surrogate ) ) ; if ( pending_surrogate_ != kNoPendingSurrogate ) { uc16 lead_surrogate = pending_surrogate_ ; pending_surrogate_ = kNoPendingSurrogate ; DCHECK ( unibrow :: Utf16 :: IsLeadSurrogate ( lead_surrogate ) ) ; uc32 combined = unibrow :: Utf16 :: CombineSurrogatePair ( lead_surrogate , trail_surrogate ) ; if ( NeedsDesugaringForIgnoreCase ( combined ) ) { AddCharacterClassForDesugaring ( combined ) ; } else { ZoneList < uc16 > surrogate_pair ( 2 , zone ( ) ) ; surrogate_pair . Add ( lead_surrogate , zone ( ) ) ; surrogate_pair . Add ( trail_surrogate , zone ( ) ) ; RegExpAtom * atom = new ( zone ( ) ) RegExpAtom ( surrogate_pair . ToConstVector ( ) , flags_ ) ; AddAtom ( atom ) ; } } else { pending_surrogate_ = trail_surrogate ; FlushPendingSurrogate ( ) ; } }
static long media_device_enum_entities ( struct media_device * mdev , struct media_entity_desc __user * uent ) { struct media_entity * ent ; struct media_entity_desc u_ent ; if ( copy_from_user ( & u_ent . id , & uent -> id , sizeof ( u_ent . id ) ) ) return - EFAULT ; ent = find_entity ( mdev , u_ent . id ) ; if ( ent == NULL ) return - EINVAL ; u_ent . id = ent -> id ; if ( ent -> name ) { strncpy ( u_ent . name , ent -> name , sizeof ( u_ent . name ) ) ; u_ent . name [ sizeof ( u_ent . name ) - 1 ] = '\0' ; } else { memset ( u_ent . name , 0 , sizeof ( u_ent . name ) ) ; } u_ent . type = ent -> type ; u_ent . revision = ent -> revision ; u_ent . flags = ent -> flags ; u_ent . group_id = ent -> group_id ; u_ent . pads = ent -> num_pads ; u_ent . links = ent -> num_links - ent -> num_backlinks ; memcpy ( & u_ent . raw , & ent -> info , sizeof ( ent -> info ) ) ; if ( copy_to_user ( uent , & u_ent , sizeof ( u_ent ) ) ) return - EFAULT ; return 0 ; }
int wc_SignatureGenerateHash ( enum wc_HashType hash_type , enum wc_SignatureType sig_type , const byte * hash_data , word32 hash_len , byte * sig , word32 * sig_len , const void * key , word32 key_len , WC_RNG * rng ) { int ret ; ( void ) rng ; if ( hash_data == NULL || hash_len <= 0 || sig == NULL || sig_len == NULL || * sig_len <= 0 || key == NULL || key_len <= 0 ) { return BAD_FUNC_ARG ; } if ( ( int ) * sig_len < wc_SignatureGetSize ( sig_type , key , key_len ) ) { WOLFSSL_MSG ( "wc_SignatureGenerate: Invalid sig type/len" ) ; return BAD_FUNC_ARG ; } ret = wc_HashGetDigestSize ( hash_type ) ; if ( ret < 0 ) { WOLFSSL_MSG ( "wc_SignatureGenerate: Invalid hash type/len" ) ; return ret ; } ret = 0 ; switch ( sig_type ) { case WC_SIGNATURE_TYPE_ECC : #if defined(HAVE_ECC) && defined(HAVE_ECC_SIGN) do { #ifdef WOLFSSL_ASYNC_CRYPT ret = wc_AsyncWait ( ret , & ( ( ecc_key * ) key ) -> asyncDev , WC_ASYNC_FLAG_CALL_AGAIN ) ; #endif if ( ret >= 0 ) ret = wc_ecc_sign_hash ( hash_data , hash_len , sig , sig_len , rng , ( ecc_key * ) key ) ; } while ( ret == WC_PENDING_E ) ; #else ret = SIG_TYPE_E ; #endif break ; case WC_SIGNATURE_TYPE_RSA_W_ENC : case WC_SIGNATURE_TYPE_RSA : #if !defined(NO_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY) do { #ifdef WOLFSSL_ASYNC_CRYPT ret = wc_AsyncWait ( ret , & ( ( RsaKey * ) key ) -> asyncDev , WC_ASYNC_FLAG_CALL_AGAIN ) ; #endif if ( ret >= 0 ) ret = wc_RsaSSL_Sign ( hash_data , hash_len , sig , * sig_len , ( RsaKey * ) key , rng ) ; } while ( ret == WC_PENDING_E ) ; if ( ret >= 0 ) { * sig_len = ret ; ret = 0 ; } #else ret = SIG_TYPE_E ; #endif break ; case WC_SIGNATURE_TYPE_NONE : default : ret = BAD_FUNC_ARG ; break ; } return ret ; }
bool recovery_cipher_abort ( void ) { if ( awaiting_character ) { awaiting_character = false ; return true ; } return false ; }
static int http_read_header ( URLContext * h , int * new_location ) { HTTPContext * s = h -> priv_data ; char line [ MAX_URL_SIZE ] ; int err = 0 ; s -> chunksize = - 1 ; for ( ; ; ) { if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) return err ; av_log ( h , AV_LOG_TRACE , "header='%s'\n" , line ) ; err = process_line ( h , line , s -> line_count , new_location ) ; if ( err < 0 ) return err ; if ( err == 0 ) break ; s -> line_count ++ ; } if ( s -> seekable == - 1 && s -> is_mediagateway && s -> filesize == 2000000000 ) h -> is_streamed = 1 ; cookie_string ( s -> cookie_dict , & s -> cookies ) ; av_dict_free ( & s -> cookie_dict ) ; return err ; }
mark_context_stack ( mrb_state * mrb , struct mrb_context * c ) { size_t i ; size_t e ; if ( c -> stack == NULL ) return ; e = c -> stack - c -> stbase ; if ( c -> ci ) e += c -> ci -> nregs ; if ( c -> stbase + e > c -> stend ) e = c -> stend - c -> stbase ; for ( i = 0 ; i < e ; i ++ ) { mrb_value v = c -> stbase [ i ] ; if ( ! mrb_immediate_p ( v ) ) { if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { c -> stbase [ i ] = mrb_nil_value ( ) ; } else { mrb_gc_mark ( mrb , mrb_basic_ptr ( v ) ) ; } } } }
PipelineStatistics :: ~ PipelineStatistics ( ) { if ( InPhaseKind ( ) ) EndPhaseKind ( ) ; CompilationStatistics :: BasicStats diff ; total_stats_ . End ( this , & diff ) ; compilation_stats_ -> RecordTotalStats ( source_size_ , diff ) ; }
inline void init ( hb_face_t * face , hb_tag_t _hea_tag , hb_tag_t _mtx_tag , unsigned int default_advance_ ) { this -> default_advance = default_advance_ ; this -> num_metrics = face -> get_num_glyphs ( ) ; hb_blob_t * _hea_blob = OT :: Sanitizer < OT :: _hea > :: sanitize ( face -> reference_table ( _hea_tag ) ) ; const OT :: _hea * _hea = OT :: Sanitizer < OT :: _hea > :: lock_instance ( _hea_blob ) ; this -> num_advances = _hea -> numberOfLongMetrics ; hb_blob_destroy ( _hea_blob ) ; this -> blob = OT :: Sanitizer < OT :: _mtx > :: sanitize ( face -> reference_table ( _mtx_tag ) ) ; if ( unlikely ( ! this -> num_advances || 2 * ( this -> num_advances + this -> num_metrics ) < hb_blob_get_length ( this -> blob ) ) ) { this -> num_metrics = this -> num_advances = 0 ; hb_blob_destroy ( this -> blob ) ; this -> blob = hb_blob_get_empty ( ) ; } this -> table = OT :: Sanitizer < OT :: _mtx > :: lock_instance ( this -> blob ) ; }
void SocketLineReader :: dataReceived ( ) { while ( m_socket -> canReadLine ( ) ) { const QByteArray line = m_socket -> readLine ( ) ; if ( line . length ( ) > 1 ) { m_packets . enqueue ( line ) ; } } if ( m_socket -> bytesAvailable ( ) > 0 ) { QMetaObject :: invokeMethod ( this , "dataReceived" , Qt :: QueuedConnection ) ; return ; } if ( ! m_packets . isEmpty ( ) ) { Q_EMIT readyRead ( ) ; } }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TFLITE_DCHECK ( node -> user_data != nullptr ) ; TFLITE_DCHECK ( node -> builtin_data != nullptr ) ; auto * params = reinterpret_cast < TfLiteDepthwiseConvParams * > ( node -> builtin_data ) ; OpData * data = static_cast < OpData * > ( node -> user_data ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; const TfLiteTensor * filter = GetInput ( context , node , kFilterTensor ) ; const TfLiteType data_type = input -> type ; int width = SizeOfDimension ( input , 2 ) ; int height = SizeOfDimension ( input , 1 ) ; int filter_width = SizeOfDimension ( filter , 2 ) ; int filter_height = SizeOfDimension ( filter , 1 ) ; const int num_channels = filter -> dims -> data [ kDepthwiseConvQuantizedDimension ] ; data -> per_channel_output_multiplier = reinterpret_cast < int32_t * > ( context -> AllocatePersistentBuffer ( context , num_channels * sizeof ( int32_t ) ) ) ; data -> per_channel_output_shift = reinterpret_cast < int32_t * > ( context -> AllocatePersistentBuffer ( context , num_channels * sizeof ( int32_t ) ) ) ; if ( input -> type == kTfLiteInt8 ) { TF_LITE_ENSURE_EQ ( context , filter -> quantization . type , kTfLiteAffineQuantization ) ; const auto * affine_quantization = reinterpret_cast < TfLiteAffineQuantization * > ( filter -> quantization . params ) ; TF_LITE_ENSURE ( context , affine_quantization ) ; TF_LITE_ENSURE ( context , affine_quantization -> scale ) ; TF_LITE_ENSURE ( context , affine_quantization -> zero_point ) ; TF_LITE_ENSURE ( context , affine_quantization -> scale -> size == 1 || affine_quantization -> scale -> size == filter -> dims -> data [ kDepthwiseConvQuantizedDimension ] ) ; TF_LITE_ENSURE_EQ ( context , affine_quantization -> scale -> size , affine_quantization -> zero_point -> size ) ; } TF_LITE_ENSURE_STATUS ( CalculateOpData ( context , node , params , width , height , filter_width , filter_height , data_type , data ) ) ; data -> input_zero_point = input -> params . zero_point ; data -> filter_zero_point = filter -> params . zero_point ; data -> output_zero_point = output -> params . zero_point ; return kTfLiteOk ; }
RUNTIME_FUNCTION ( Runtime_GetGeneratorScopeCount ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 1 , args . length ( ) ) ; if ( ! args [ 0 ] -> IsJSGeneratorObject ( ) ) return Smi :: kZero ; CONVERT_ARG_HANDLE_CHECKED ( JSGeneratorObject , gen , 0 ) ; if ( ! gen -> is_suspended ( ) ) { return Smi :: kZero ; } int n = 0 ; for ( ScopeIterator it ( isolate , gen ) ; ! it . Done ( ) ; it . Next ( ) ) { n ++ ; } return Smi :: FromInt ( n ) ; }
Status RangeSize ( const Tensor * start_t , const Tensor * limit_t , const Tensor * delta_t , InferenceContext * const c ) { T start = start_t -> scalar < T > ( ) ( ) ; T limit = limit_t -> scalar < T > ( ) ( ) ; T delta = delta_t -> scalar < T > ( ) ( ) ; if ( start > limit && delta > T ( 0 ) ) { return errors :: InvalidArgument ( "Requires start <= limit when delta > 0: " , start , "/" , limit ) ; } if ( start < limit && delta < T ( 0 ) ) { return errors :: InvalidArgument ( "Requires start >= limit when delta < 0: " , start , "/" , limit ) ; } if ( delta == T ( 0 ) ) { return errors :: InvalidArgument ( "Requires delta != 0" ) ; } auto size = ( std :: is_integral < T > :: value ? ( ( Eigen :: numext :: abs ( limit - start ) + Eigen :: numext :: abs ( delta ) - T ( 1 ) ) / Eigen :: numext :: abs ( delta ) ) : ( Eigen :: numext :: ceil ( Eigen :: numext :: abs ( ( limit - start ) / delta ) ) ) ) ; if ( size > std :: numeric_limits < int64_t > :: max ( ) ) { return errors :: InvalidArgument ( "Requires ((limit - start) / delta) <= " , std :: numeric_limits < int64_t > :: max ( ) ) ; } c -> set_output ( 0 , c -> Vector ( static_cast < int64_t > ( size ) ) ) ; return Status :: OK ( ) ; }
void MarkCompactCollector :: TrimEnumCache ( Map * map , DescriptorArray * descriptors ) { int live_enum = map -> EnumLength ( ) ; if ( live_enum == kInvalidEnumCacheSentinel ) { live_enum = map -> NumberOfEnumerableProperties ( ) ; } if ( live_enum == 0 ) return descriptors -> ClearEnumCache ( ) ; EnumCache * enum_cache = descriptors -> GetEnumCache ( ) ; FixedArray * keys = enum_cache -> keys ( ) ; int to_trim = keys -> length ( ) - live_enum ; if ( to_trim <= 0 ) return ; heap_ -> RightTrimFixedArray ( keys , to_trim ) ; FixedArray * indices = enum_cache -> indices ( ) ; to_trim = indices -> length ( ) - live_enum ; if ( to_trim <= 0 ) return ; heap_ -> RightTrimFixedArray ( indices , to_trim ) ; }
IDBObjectStore :: GetKeyPath ( JSContext * aCx , ErrorResult & aRv ) { NS_ASSERTION ( NS_IsMainThread ( ) , "Wrong thread!" ) ; if ( ! mCachedKeyPath . isUndefined ( ) ) { return mCachedKeyPath ; } aRv = GetKeyPath ( ) . ToJSVal ( aCx , mCachedKeyPath ) ; ENSURE_SUCCESS ( aRv , JSVAL_VOID ) ; if ( mCachedKeyPath . isGCThing ( ) ) { mozilla :: HoldJSObjects ( this ) ; mRooted = true ; } return mCachedKeyPath ; }
static BT_HDR * avct_lcb_msg_asmbl ( tAVCT_LCB * p_lcb , BT_HDR * p_buf ) { uint8_t * p ; uint8_t pkt_type ; BT_HDR * p_ret ; if ( p_buf -> len < 1 ) { osi_free ( p_buf ) ; p_ret = NULL ; return p_ret ; } p = ( uint8_t * ) ( p_buf + 1 ) + p_buf -> offset ; pkt_type = AVCT_PKT_TYPE ( p ) ; if ( p_buf -> len < avct_lcb_pkt_type_len [ pkt_type ] ) { osi_free ( p_buf ) ; AVCT_TRACE_WARNING ( "Bad length during reassembly" ) ; p_ret = NULL ; } else if ( pkt_type == AVCT_PKT_TYPE_SINGLE ) { if ( p_lcb -> p_rx_msg != NULL ) AVCT_TRACE_WARNING ( "Got single during reassembly" ) ; osi_free_and_reset ( ( void * * ) & p_lcb -> p_rx_msg ) ; p_ret = p_buf ; } else if ( pkt_type == AVCT_PKT_TYPE_START ) { if ( p_lcb -> p_rx_msg != NULL ) AVCT_TRACE_WARNING ( "Got start during reassembly" ) ; osi_free ( p_lcb -> p_rx_msg ) ; p_lcb -> p_rx_msg = ( BT_HDR * ) osi_malloc ( BT_DEFAULT_BUFFER_SIZE ) ; memcpy ( p_lcb -> p_rx_msg , p_buf , sizeof ( BT_HDR ) + p_buf -> offset + p_buf -> len ) ; osi_free ( p_buf ) ; p = ( uint8_t * ) ( p_lcb -> p_rx_msg + 1 ) + p_lcb -> p_rx_msg -> offset ; * ( p + 1 ) = * p ; p_lcb -> p_rx_msg -> offset += p_lcb -> p_rx_msg -> len ; p_lcb -> p_rx_msg -> len -= 1 ; p_ret = NULL ; } else { if ( p_lcb -> p_rx_msg == NULL ) { osi_free ( p_buf ) ; AVCT_TRACE_WARNING ( "Pkt type=%d out of order" , pkt_type ) ; p_ret = NULL ; } else { uint16_t buf_len = BT_DEFAULT_BUFFER_SIZE - sizeof ( BT_HDR ) ; p_buf -> offset += AVCT_HDR_LEN_CONT ; p_buf -> len -= AVCT_HDR_LEN_CONT ; if ( ( p_lcb -> p_rx_msg -> offset + p_buf -> len ) > buf_len ) { AVCT_TRACE_WARNING ( "%s: Fragmented message too big!" , __func__ ) ; osi_free_and_reset ( ( void * * ) & p_lcb -> p_rx_msg ) ; osi_free ( p_buf ) ; p_ret = NULL ; } else { memcpy ( ( uint8_t * ) ( p_lcb -> p_rx_msg + 1 ) + p_lcb -> p_rx_msg -> offset , ( uint8_t * ) ( p_buf + 1 ) + p_buf -> offset , p_buf -> len ) ; if ( pkt_type == AVCT_PKT_TYPE_END ) { p_lcb -> p_rx_msg -> offset -= p_lcb -> p_rx_msg -> len ; p_lcb -> p_rx_msg -> len += p_buf -> len ; p_ret = p_lcb -> p_rx_msg ; p_lcb -> p_rx_msg = NULL ; } else { p_lcb -> p_rx_msg -> offset += p_buf -> len ; p_lcb -> p_rx_msg -> len += p_buf -> len ; p_ret = NULL ; } osi_free ( p_buf ) ; } } } return p_ret ; }
SourceListener :: ApplyConstraintsToTrack ( MediaTrack * aTrack , const MediaTrackConstraints & aConstraints , CallerType aCallerType ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; DeviceState & state = GetDeviceStateFor ( aTrack ) ; if ( mStopped || state . mStopped ) { LOG ( "gUM %s track for track %p applyConstraints, but source is stopped" , & state == mAudioDeviceState . get ( ) ? "audio" : "video" , aTrack ) ; return SourceListenerPromise :: CreateAndResolve ( false , __func__ ) ; } MediaManager * mgr = MediaManager :: GetIfExists ( ) ; if ( ! mgr ) { return SourceListenerPromise :: CreateAndResolve ( false , __func__ ) ; } return MediaManager :: Dispatch < SourceListenerPromise > ( __func__ , [ device = state . mDevice , aConstraints , isChrome = aCallerType == CallerType :: System ] ( MozPromiseHolder < SourceListenerPromise > & aHolder ) mutable { MOZ_ASSERT ( MediaManager :: IsInMediaThread ( ) ) ; MediaManager * mgr = MediaManager :: GetIfExists ( ) ; MOZ_RELEASE_ASSERT ( mgr ) ; const char * badConstraint = nullptr ; nsresult rv = device -> Reconfigure ( aConstraints , mgr -> mPrefs , & badConstraint ) ; if ( NS_FAILED ( rv ) ) { if ( rv == NS_ERROR_INVALID_ARG ) { if ( ! badConstraint ) { nsTArray < RefPtr < MediaDevice > > devices ; devices . AppendElement ( device ) ; badConstraint = MediaConstraintsHelper :: SelectSettings ( NormalizedConstraints ( aConstraints ) , devices , isChrome ) ; } } else { badConstraint = "" ; LOG ( "ApplyConstraintsToTrack-Task: Unexpected fail %" PRIx32 , static_cast < uint32_t > ( rv ) ) ; } aHolder . Reject ( MakeRefPtr < MediaMgrError > ( MediaMgrError :: Name :: OverconstrainedError , "" , NS_ConvertASCIItoUTF16 ( badConstraint ) ) , __func__ ) ; return ; } aHolder . Resolve ( false , __func__ ) ; } ) ; }
mwifiex_set_wmm_params ( struct mwifiex_private * priv , struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { const u8 * vendor_ie ; const u8 * wmm_ie ; u8 wmm_oui [ ] = { 0x00 , 0x50 , 0xf2 , 0x02 } ; vendor_ie = cfg80211_find_vendor_ie ( WLAN_OUI_MICROSOFT , WLAN_OUI_TYPE_MICROSOFT_WMM , params -> beacon . tail , params -> beacon . tail_len ) ; if ( vendor_ie ) { wmm_ie = vendor_ie ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; priv -> wmm_enabled = 1 ; } else { memset ( & bss_cfg -> wmm_info , 0 , sizeof ( bss_cfg -> wmm_info ) ) ; memcpy ( & bss_cfg -> wmm_info . oui , wmm_oui , sizeof ( wmm_oui ) ) ; bss_cfg -> wmm_info . subtype = MWIFIEX_WMM_SUBTYPE ; bss_cfg -> wmm_info . version = MWIFIEX_WMM_VERSION ; priv -> wmm_enabled = 0 ; } bss_cfg -> qos_info = 0x00 ; return ; }
sf_open ( const char * path , int mode , SF_INFO * sfinfo ) { SF_PRIVATE * psf ; assert ( sizeof ( sf_count_t ) == 8 ) ; if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) { sf_errno = SFE_MALLOC_FAILED ; return NULL ; } ; psf_init_files ( psf ) ; psf_log_printf ( psf , "File : %s\n" , path ) ; if ( copy_filename ( psf , path ) != 0 ) { sf_errno = psf -> error ; return NULL ; } ; psf -> file . mode = mode ; if ( strcmp ( path , "-" ) == 0 ) psf -> error = psf_set_stdio ( psf ) ; else psf -> error = psf_fopen ( psf ) ; return psf_open_file ( psf , sfinfo ) ; }
static struct nfs4_state * nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred ) { struct nfs4_exception exception = { } ; struct nfs4_state * res ; int status ; do { status = _nfs4_do_open ( dir , path , flags , sattr , cred , & res ) ; if ( status == 0 ) break ; if ( status == - NFS4ERR_BAD_SEQID ) { printk ( KERN_WARNING "NFS: v4 server %s " " returned a bad sequence-id error!\n" , NFS_SERVER ( dir ) -> nfs_client -> cl_hostname ) ; exception . retry = 1 ; continue ; } if ( status == - NFS4ERR_BAD_STATEID ) { exception . retry = 1 ; continue ; } if ( status == - EAGAIN ) { exception . retry = 1 ; continue ; } res = ERR_PTR ( nfs4_handle_exception ( NFS_SERVER ( dir ) , status , & exception ) ) ; } while ( exception . retry ) ; return res ; }
mozilla :: ipc :: IPCResult BrowserChild :: RecvRealDragEvent ( const WidgetDragEvent & aEvent , const uint32_t & aDragAction , const uint32_t & aDropEffect , nsIPrincipal * aPrincipal ) { WidgetDragEvent localEvent ( aEvent ) ; localEvent . mWidget = mPuppetWidget ; nsCOMPtr < nsIDragSession > dragSession = nsContentUtils :: GetDragSession ( ) ; if ( dragSession ) { dragSession -> SetDragAction ( aDragAction ) ; dragSession -> SetTriggeringPrincipal ( aPrincipal ) ; RefPtr < DataTransfer > initialDataTransfer = dragSession -> GetDataTransfer ( ) ; if ( initialDataTransfer ) { initialDataTransfer -> SetDropEffectInt ( aDropEffect ) ; } } if ( aEvent . mMessage == eDrop ) { bool canDrop = true ; if ( ! dragSession || NS_FAILED ( dragSession -> GetCanDrop ( & canDrop ) ) || ! canDrop ) { localEvent . mMessage = eDragExit ; } } else if ( aEvent . mMessage == eDragOver ) { nsCOMPtr < nsIDragService > dragService = do_GetService ( "@mozilla.org/widget/dragservice;1" ) ; if ( dragService ) { dragService -> FireDragEventAtSource ( eDrag , aEvent . mModifiers ) ; } } DispatchWidgetEventViaAPZ ( localEvent ) ; return IPC_OK ( ) ; }
char * unescape ( char * dest , const char * src ) { while ( * src ) { if ( * src == '\\' ) { ++ src ; switch ( * src ) { case 'n' : * dest = '\n' ; break ; case 'r' : * dest = '\r' ; break ; case 't' : * dest = '\t' ; break ; case 'f' : * dest = '\f' ; break ; case 'v' : * dest = '\v' ; break ; default : * dest = * src ; } } else { * dest = * src ; } ++ src ; ++ dest ; } * dest = '\0' ; return dest ; }
void vp8_setup_intra_recon_top_line ( YV12_BUFFER_CONFIG * ybf ) { vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ; vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; }
void ScopeIterator :: VisitLocalScope ( const Visitor & visitor , Mode mode ) const { if ( InInnerScope ( ) ) { if ( VisitLocals ( visitor , mode ) ) return ; if ( mode == Mode :: STACK && Type ( ) == ScopeTypeLocal ) { if ( ! closure_scope_ -> has_this_declaration ( ) && ! non_locals_ -> Has ( isolate_ , isolate_ -> factory ( ) -> this_string ( ) ) ) { if ( visitor ( isolate_ -> factory ( ) -> this_string ( ) , isolate_ -> factory ( ) -> undefined_value ( ) ) ) return ; } if ( frame_inspector_ != nullptr && ! closure_scope_ -> is_arrow_scope ( ) && ( closure_scope_ -> arguments ( ) == nullptr || frame_inspector_ -> GetExpression ( closure_scope_ -> arguments ( ) -> index ( ) ) -> IsOptimizedOut ( isolate_ ) ) ) { JavaScriptFrame * frame = GetFrame ( ) ; Handle < JSObject > arguments = Accessors :: FunctionGetArguments ( frame , frame_inspector_ -> inlined_frame_index ( ) ) ; if ( visitor ( isolate_ -> factory ( ) -> arguments_string ( ) , arguments ) ) return ; } } } else { DCHECK_EQ ( Mode :: ALL , mode ) ; Handle < ScopeInfo > scope_info ( context_ -> scope_info ( ) , isolate_ ) ; if ( VisitContextLocals ( visitor , scope_info , context_ ) ) return ; } if ( mode == Mode :: ALL && HasContext ( ) ) { DCHECK ( ! context_ -> IsScriptContext ( ) ) ; DCHECK ( ! context_ -> IsNativeContext ( ) ) ; DCHECK ( ! context_ -> IsWithContext ( ) ) ; if ( ! context_ -> scope_info ( ) -> CallsSloppyEval ( ) ) return ; if ( context_ -> extension_object ( ) == nullptr ) return ; Handle < JSObject > extension ( context_ -> extension_object ( ) , isolate_ ) ; Handle < FixedArray > keys = KeyAccumulator :: GetKeys ( extension , KeyCollectionMode :: kOwnOnly , ENUMERABLE_STRINGS ) . ToHandleChecked ( ) ; for ( int i = 0 ; i < keys -> length ( ) ; i ++ ) { DCHECK ( keys -> get ( i ) -> IsString ( ) ) ; Handle < String > key ( String :: cast ( keys -> get ( i ) ) , isolate_ ) ; Handle < Object > value = JSReceiver :: GetDataProperty ( extension , key ) ; if ( visitor ( key , value ) ) return ; } } }
void SPECTRA :: run ( Session * session , const std :: string & argument ) { if ( session -> loglevel >= 3 ) ( * session -> logfile ) < < "SPECTRA handler reached" < < endl ; int resolution , tile , x , y ; if ( session -> loglevel >= 2 ) command_timer . start ( ) ; string arg = argument ; int delimitter = arg . find ( "," ) ; resolution = atoi ( arg . substr ( 0 , delimitter ) . c_str ( ) ) ; arg = arg . substr ( delimitter + 1 , arg . length ( ) ) ; delimitter = arg . find ( "," ) ; tile = atoi ( arg . substr ( 0 , delimitter ) . c_str ( ) ) ; arg = arg . substr ( delimitter + 1 , arg . length ( ) ) ; delimitter = arg . find ( "," ) ; x = atoi ( arg . substr ( 0 , delimitter ) . c_str ( ) ) ; arg = arg . substr ( delimitter + 1 , arg . length ( ) ) ; delimitter = arg . find ( "," ) ; y = atoi ( arg . substr ( 0 , arg . length ( ) ) . c_str ( ) ) ; if ( session -> loglevel >= 5 ) { ( * session -> logfile ) < < "SPECTRA :: resolution: " < < resolution < < ", tile: " < < tile < < ", x: " < < x < < ", y: " < < y < < endl ; } if ( x < 0 || x >= ( int ) ( * session -> image ) -> getTileWidth ( ) || y < 0 || y >= ( int ) ( * session -> image ) -> getTileHeight ( ) ) { throw invalid_argument ( "SPECTRA :: Error: x,y coordinates outside of tile boundaries" ) ; } TileManager tilemanager ( session -> tileCache , * session -> image , session -> watermark , session -> jpeg , session -> logfile , session -> loglevel ) ; list < int > views = ( * session -> image ) -> getHorizontalViewsList ( ) ; list < int > :: const_iterator i ; list < float > spectrum ; #ifndef DEBUG stringstream header ; header < < session -> response -> createHTTPHeader ( "xml" , ( * session -> image ) -> getTimestamp ( ) ) ; session -> out -> putStr ( ( const char * ) header . str ( ) . c_str ( ) , header . tellp ( ) ) ; session -> out -> flush ( ) ; #endif session -> out -> putS ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; session -> out -> putS ( "<spectra>\n" ) ; session -> out -> flush ( ) ; for ( i = views . begin ( ) ; i != views . end ( ) ; i ++ ) { int n = * i ; RawTile rawtile = tilemanager . getTile ( resolution , tile , n , session -> view -> yangle , session -> view -> getLayers ( ) , UNCOMPRESSED ) ; if ( x >= ( int ) rawtile . width || y >= ( int ) rawtile . height ) { if ( session -> loglevel >= 1 ) { ( * session -> logfile ) < < "SPECTRA :: Error: x,y coordinates outside of tile boundaries" < < endl ; } break ; } unsigned int tw = ( * session -> image ) -> getTileWidth ( ) ; unsigned int index = y * tw + x ; void * ptr ; float reflectance = 0.0 ; if ( session -> loglevel >= 5 ) ( * session -> logfile ) < < "SPECTRA :: " < < rawtile . bpc < < " bits per channel data" < < endl ; if ( rawtile . bpc == 8 ) { ptr = ( unsigned char * ) ( rawtile . data ) ; reflectance = static_cast < float > ( ( float ) ( ( unsigned char * ) ptr ) [ index ] ) / 255.0 ; } else if ( rawtile . bpc == 16 ) { ptr = ( unsigned short * ) ( rawtile . data ) ; reflectance = static_cast < float > ( ( float ) ( ( unsigned short * ) ptr ) [ index ] ) / 65535.0 ; } else if ( rawtile . bpc == 32 ) { if ( rawtile . sampleType == FIXEDPOINT ) { ptr = ( unsigned int * ) rawtile . data ; reflectance = static_cast < float > ( ( float ) ( ( unsigned int * ) ptr ) [ index ] ) ; } else { ptr = ( float * ) rawtile . data ; reflectance = static_cast < float > ( ( float ) ( ( float * ) ptr ) [ index ] ) ; } } spectrum . push_front ( reflectance ) ; string metadata = ( * session -> image ) -> getMetadata ( "subject" ) ; char tmp [ 1024 ] ; snprintf ( tmp , 1024 , "\t<point>\n\t\t<wavelength>%d</wavelength>\n\t\t<reflectance>%f</reflectance>\n\t</point>\n" , n , reflectance ) ; session -> out -> putS ( tmp ) ; session -> out -> flush ( ) ; if ( session -> loglevel >= 3 ) ( * session -> logfile ) < < "SPECTRA :: Band: " < < n < < ", reflectance: " < < reflectance < < endl ; } session -> out -> putS ( "</spectra>" ) ; if ( session -> out -> flush ( ) == - 1 ) { if ( session -> loglevel >= 1 ) { * ( session -> logfile ) < < "SPECTRA :: Error flushing XML" < < endl ; } } session -> response -> setImageSent ( ) ; if ( session -> loglevel >= 2 ) { * ( session -> logfile ) < < "SPECTRA :: Total command time " < < command_timer . getTime ( ) < < " microseconds" < < endl ; } }
% Image * image ) % % A description of each parameter follows : % % o image_info : the image info . % % o image : The image . % * / static MagickBooleanType WriteGROUP4Image ( const ImageInfo * image_info , Image * image ) { char filename [ MaxTextExtent ] ; FILE * file ; Image * huffman_image ; ImageInfo * write_info ; int unique_file ; MagickBooleanType status ; register ssize_t i ; ssize_t count ; TIFF * tiff ; toff_t * byte_count , strip_size ; unsigned char * buffer ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image -> filename ) ; status = OpenBlob ( image_info , image , WriteBinaryBlobMode , & image -> exception ) ; if ( status == MagickFalse ) return ( status ) ; huffman_image = CloneImage ( image , 0 , 0 , MagickTrue , & image -> exception ) ; if ( huffman_image == ( Image * ) NULL ) { ( void ) CloseBlob ( image ) ; return ( MagickFalse ) ; } huffman_image -> endian = MSBEndian ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ThrowFileException ( & image -> exception , FileOpenError , "UnableToCreateTemporaryFile" , filename ) ; return ( MagickFalse ) ; } ( void ) FormatLocaleString ( huffman_image -> filename , MaxTextExtent , "tiff:%s" , filename ) ; ( void ) SetImageType ( huffman_image , BilevelType ) ; write_info = CloneImageInfo ( ( ImageInfo * ) NULL ) ; SetImageInfoFile ( write_info , file ) ; ( void ) SetImageType ( image , BilevelType ) ; ( void ) SetImageDepth ( image , 1 ) ; write_info -> compression = Group4Compression ; write_info -> type = BilevelType ; ( void ) SetImageOption ( write_info , "quantum:polarity" , "min-is-white" ) ; status = WriteTIFFImage ( write_info , huffman_image ) ; ( void ) fflush ( file ) ; write_info = DestroyImageInfo ( write_info ) ; if ( status == MagickFalse ) { InheritException ( & image -> exception , & huffman_image -> exception ) ; huffman_image = DestroyImage ( huffman_image ) ; ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; return ( MagickFalse ) ; } tiff = TIFFOpen ( filename , "rb" ) ; if ( tiff == ( TIFF * ) NULL ) { huffman_image = DestroyImage ( huffman_image ) ; ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( & image -> exception , FileOpenError , "UnableToOpenFile" , image_info -> filename ) ; return ( MagickFalse ) ; } if ( TIFFGetField ( tiff , TIFFTAG_STRIPBYTECOUNTS , & byte_count ) != 1 ) { TIFFClose ( tiff ) ; huffman_image = DestroyImage ( huffman_image ) ; ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; return ( MagickFalse ) ; } strip_size = byte_count [ 0 ] ; for ( i = 1 ; i < ( ssize_t ) TIFFNumberOfStrips ( tiff ) ; i ++ ) if ( byte_count [ i ] > strip_size ) strip_size = byte_count [ i ] ; buffer = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) strip_size , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) { TIFFClose ( tiff ) ; huffman_image = DestroyImage ( huffman_image ) ; ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , image_info -> filename ) ; } for ( i = 0 ; i < ( ssize_t ) TIFFNumberOfStrips ( tiff ) ; i ++ ) { count = ( ssize_t ) TIFFReadRawStrip ( tiff , ( uint32 ) i , buffer , strip_size ) ; if ( WriteBlob ( image , ( size_t ) count , buffer ) != count ) status = MagickFalse ;
httpCredentialsString ( cups_array_t * credentials , char * buffer , size_t bufsize ) { http_credential_t * first ; gnutls_x509_crt_t cert ; DEBUG_printf ( ( "httpCredentialsString(credentials=%p, buffer=%p, bufsize=" CUPS_LLFMT ")" , credentials , buffer , CUPS_LLCAST bufsize ) ) ; if ( ! buffer ) return ( 0 ) ; if ( buffer && bufsize > 0 ) * buffer = '\0' ; if ( ( first = ( http_credential_t * ) cupsArrayFirst ( credentials ) ) != NULL && ( cert = http_gnutls_create_credential ( first ) ) != NULL ) { char name [ 256 ] ; size_t namelen ; time_t expiration ; _cups_md5_state_t md5_state ; unsigned char md5_digest [ 16 ] ; namelen = sizeof ( name ) - 1 ; if ( gnutls_x509_crt_get_dn_by_oid ( cert , GNUTLS_OID_X520_COMMON_NAME , 0 , 0 , name , & namelen ) >= 0 ) name [ namelen ] = '\0' ; else strlcpy ( name , "unknown" , sizeof ( name ) ) ; expiration = gnutls_x509_crt_get_expiration_time ( cert ) ; _cupsMD5Init ( & md5_state ) ; _cupsMD5Append ( & md5_state , first -> data , ( int ) first -> datalen ) ; _cupsMD5Finish ( & md5_state , md5_digest ) ; snprintf ( buffer , bufsize , "%s / %s / %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X" , name , httpGetDateString ( expiration ) , md5_digest [ 0 ] , md5_digest [ 1 ] , md5_digest [ 2 ] , md5_digest [ 3 ] , md5_digest [ 4 ] , md5_digest [ 5 ] , md5_digest [ 6 ] , md5_digest [ 7 ] , md5_digest [ 8 ] , md5_digest [ 9 ] , md5_digest [ 10 ] , md5_digest [ 11 ] , md5_digest [ 12 ] , md5_digest [ 13 ] , md5_digest [ 14 ] , md5_digest [ 15 ] ) ; gnutls_x509_crt_deinit ( cert ) ; } DEBUG_printf ( ( "1httpCredentialsString: Returning \"%s\"." , buffer ) ) ; return ( strlen ( buffer ) ) ; }
image_transform_png_set_palette_to_rgb_add ( image_transform * this , PNG_CONST image_transform * * that , png_byte colour_type , png_byte bit_depth ) { UNUSED ( bit_depth ) this -> next = * that ; * that = this ; return colour_type == PNG_COLOR_TYPE_PALETTE ; }
nsCSSRuleProcessor :: RefreshRuleCascade ( nsPresContext * aPresContext ) { for ( RuleCascadeData * * cascadep = & mRuleCascades , * cascade ; ( cascade = * cascadep ) ; cascadep = & cascade -> mNext ) { if ( cascade -> mCacheKey . Matches ( aPresContext ) ) { * cascadep = cascade -> mNext ; cascade -> mNext = mRuleCascades ; mRuleCascades = cascade ; return ; } } if ( mSheets . Length ( ) != 0 ) { nsAutoPtr < RuleCascadeData > newCascade ( new RuleCascadeData ( aPresContext -> Medium ( ) , eCompatibility_NavQuirks == aPresContext -> CompatibilityMode ( ) ) ) ; if ( newCascade ) { CascadeEnumData data ( aPresContext , newCascade -> mFontFaceRules , newCascade -> mKeyframesRules , newCascade -> mFontFeatureValuesRules , newCascade -> mPageRules , newCascade -> mCacheKey , mSheetType ) ; if ( ! data . mRulesByWeight . ops ) return ; for ( uint32_t i = 0 ; i < mSheets . Length ( ) ; ++ i ) { if ( ! CascadeSheet ( mSheets . ElementAt ( i ) , & data ) ) return ; } uint32_t weightCount = data . mRulesByWeight . entryCount ; nsAutoArrayPtr < PerWeightData > weightArray ( new PerWeightData [ weightCount ] ) ; FillWeightArrayData fwData ( weightArray ) ; PL_DHashTableEnumerate ( & data . mRulesByWeight , FillWeightArray , & fwData ) ; NS_QuickSort ( weightArray , weightCount , sizeof ( PerWeightData ) , CompareWeightData , nullptr ) ; for ( uint32_t i = 0 ; i < weightCount ; ++ i ) { for ( PerWeightDataListItem * cur = weightArray [ i ] . mRuleSelectorPairs ; cur ; cur = cur -> mNext ) { if ( ! AddRule ( cur , newCascade ) ) return ; } } newCascade -> mNext = mRuleCascades ; mRuleCascades = newCascade . forget ( ) ; } } return ; }
pci_emul_mem_handler ( struct vmctx * ctx , int vcpu , int dir , uint64_t addr , int size , uint64_t * val , void * arg1 , long arg2 ) { struct pci_vdev * pdi = arg1 ; struct pci_vdev_ops * ops = pdi -> dev_ops ; uint64_t offset ; int bidx = ( int ) arg2 ; assert ( bidx <= PCI_BARMAX ) ; assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ; assert ( addr >= pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . size ) ; offset = addr - pdi -> bar [ bidx ] . addr ; if ( dir == MEM_F_WRITE ) { if ( size == 8 ) { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , 4 , * val & 0xffffffff ) ; ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 , * val > > 32 ) ; } else { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , size , bar_value ( size , * val ) ) ; } } else { if ( size == 8 ) { uint64_t val_lo , val_hi ; val_lo = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , 4 ) ; val_lo = bar_value ( 4 , val_lo ) ; val_hi = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 ) ; * val = val_lo | ( val_hi < < 32 ) ; } else { * val = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , size ) ; * val = bar_value ( size , * val ) ; } } return 0 ; }
SoftAACEncoder :: ~ SoftAACEncoder ( ) { delete [ ] mInputFrame ; mInputFrame = NULL ; if ( mEncoderHandle ) { CHECK_EQ ( VO_ERR_NONE , mApiHandle -> Uninit ( mEncoderHandle ) ) ; mEncoderHandle = NULL ; } delete mApiHandle ; mApiHandle = NULL ; delete mMemOperator ; mMemOperator = NULL ; }
size_t V8Debugger :: nearHeapLimitCallback ( void * data , size_t current_heap_limit , size_t initial_heap_limit ) { V8Debugger * thisPtr = static_cast < V8Debugger * > ( data ) ; thisPtr -> m_originalHeapLimit = current_heap_limit ; thisPtr -> m_scheduledOOMBreak = true ; v8 :: Local < v8 :: Context > context = thisPtr -> m_isolate -> GetEnteredContext ( ) ; thisPtr -> m_targetContextGroupId = context . IsEmpty ( ) ? 0 : thisPtr -> m_inspector -> contextGroupId ( context ) ; thisPtr -> m_isolate -> RequestInterrupt ( [ ] ( v8 :: Isolate * isolate , void * ) { v8 :: debug :: BreakRightNow ( isolate ) ; } , nullptr ) ; return HeapLimitForDebugging ( initial_heap_limit ) ; }
status_t AudioFlinger :: EffectHandle :: enable ( ) { ALOGV ( "enable %p" , this ) ; if ( ! mHasControl ) { return INVALID_OPERATION ; } if ( mEffect == 0 ) { return DEAD_OBJECT ; } if ( mEnabled ) { return NO_ERROR ; } mEnabled = true ; sp < ThreadBase > thread = mEffect -> thread ( ) . promote ( ) ; if ( thread != 0 ) { thread -> checkSuspendOnEffectEnabled ( mEffect , true , mEffect -> sessionId ( ) ) ; } if ( mEffect -> suspended ( ) ) { return NO_ERROR ; } status_t status = mEffect -> setEnabled ( true ) ; if ( status != NO_ERROR ) { if ( thread != 0 ) { thread -> checkSuspendOnEffectEnabled ( mEffect , false , mEffect -> sessionId ( ) ) ; } mEnabled = false ; } else { if ( thread != 0 ) { if ( thread -> type ( ) == ThreadBase :: OFFLOAD ) { PlaybackThread * t = ( PlaybackThread * ) thread . get ( ) ; Mutex :: Autolock _l ( t -> mLock ) ; t -> broadcast_l ( ) ; } if ( ! mEffect -> isOffloadable ( ) ) { if ( thread -> type ( ) == ThreadBase :: OFFLOAD ) { PlaybackThread * t = ( PlaybackThread * ) thread . get ( ) ; t -> invalidateTracks ( AUDIO_STREAM_MUSIC ) ; } if ( mEffect -> sessionId ( ) == AUDIO_SESSION_OUTPUT_MIX ) { thread -> mAudioFlinger -> onNonOffloadableGlobalEffectEnable ( ) ; } } } } return status ; }
void HeaderMapImpl :: insertByKey ( HeaderString && key , HeaderString && value ) { EntryCb cb = ConstSingleton < StaticLookupTable > :: get ( ) . find ( key . getStringView ( ) ) ; if ( cb ) { key . clear ( ) ; StaticLookupResponse ref_lookup_response = cb ( * this ) ; if ( * ref_lookup_response . entry_ == nullptr ) { maybeCreateInline ( ref_lookup_response . entry_ , * ref_lookup_response . key_ , std :: move ( value ) ) ; } else { appendToHeader ( ( * ref_lookup_response . entry_ ) -> value ( ) , value . getStringView ( ) ) ; value . clear ( ) ; } } else { std :: list < HeaderEntryImpl > :: iterator i = headers_ . insert ( std :: move ( key ) , std :: move ( value ) ) ; i -> entry_ = i ; } }
static void mark_screen_rdonly ( struct mm_struct * mm ) { pgd_t * pgd ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; spinlock_t * ptl ; int i ; pgd = pgd_offset ( mm , 0xA0000 ) ; if ( pgd_none_or_clear_bad ( pgd ) ) goto out ; pud = pud_offset ( pgd , 0xA0000 ) ; if ( pud_none_or_clear_bad ( pud ) ) goto out ; pmd = pmd_offset ( pud , 0xA0000 ) ; split_huge_page_pmd ( mm , pmd ) ; if ( pmd_none_or_clear_bad ( pmd ) ) goto out ; pte = pte_offset_map_lock ( mm , pmd , 0xA0000 , & ptl ) ; for ( i = 0 ; i < 32 ; i ++ ) { if ( pte_present ( * pte ) ) set_pte ( pte , pte_wrprotect ( * pte ) ) ; pte ++ ; } pte_unmap_unlock ( pte , ptl ) ; out : flush_tlb ( ) ; }
tabstop_set ( char_u * var , int * * array ) { int valcount = 1 ; int t ; char_u * cp ; if ( var [ 0 ] == NUL || ( var [ 0 ] == '0' && var [ 1 ] == NUL ) ) { * array = NULL ; return OK ; } for ( cp = var ; * cp != NUL ; ++ cp ) { if ( cp == var || cp [ - 1 ] == ',' ) { char_u * end ; if ( strtol ( ( char * ) cp , ( char * * ) & end , 10 ) <= 0 ) { if ( cp != end ) emsg ( _ ( e_argument_must_be_positive ) ) ; else semsg ( _ ( e_invalid_argument_str ) , cp ) ; return FAIL ; } } if ( VIM_ISDIGIT ( * cp ) ) continue ; if ( cp [ 0 ] == ',' && cp > var && cp [ - 1 ] != ',' && cp [ 1 ] != NUL ) { ++ valcount ; continue ; } semsg ( _ ( e_invalid_argument_str ) , var ) ; return FAIL ; } * array = ALLOC_MULT ( int , valcount + 1 ) ; if ( * array == NULL ) return FAIL ; ( * array ) [ 0 ] = valcount ; t = 1 ; for ( cp = var ; * cp != NUL ; ) { int n = atoi ( ( char * ) cp ) ; if ( n < 0 || n > 9999 ) { semsg ( _ ( e_invalid_argument_str ) , cp ) ; vim_free ( * array ) ; * array = NULL ; return FAIL ; } ( * array ) [ t ++ ] = n ; while ( * cp != NUL && * cp != ',' ) ++ cp ; if ( * cp != NUL ) ++ cp ; } return OK ; }
JpegInput ( String filename ) : filename_ ( std :: move ( filename ) ) { infile_ = std :: fopen ( filename_ . c_str ( ) , "rb" ) ; if ( infile_ == nullptr ) { if ( ! FileHasExtension ( filename_ ) ) { filename_ = FileAddExtension ( filename_ , "jpg" ) ; infile_ = std :: fopen ( filename_ . c_str ( ) , "rb" ) ; if ( infile_ == nullptr ) { filename_ = FileAddExtension ( filename_ , "jpeg" ) ; infile_ = std :: fopen ( filename_ . c_str ( ) , "rb" ) ; } } } if ( infile_ == nullptr ) { DIP_THROW_RUNTIME ( "Could not open the specified JPEG file" ) ; } cinfo_ . err = jpeg_std_error ( & jerr_ . pub ) ; jerr_ . pub . error_exit = my_error_exit ; jerr_ . pub . output_message = my_output_message ; if ( setjmp ( jerr_ . setjmp_buffer ) ) { DIP_THROW_RUNTIME ( "Error reading JPEG file." ) ; } jpeg_create_decompress ( & cinfo_ ) ; initialized_ = true ; jpeg_stdio_src ( & cinfo_ , infile_ ) ; jpeg_read_header ( & cinfo_ , TRUE ) ; }
static int kvm_vm_ioctl_create_vcpu ( struct kvm * kvm , u32 id ) { int r ; struct kvm_vcpu * vcpu , * v ; vcpu = kvm_arch_vcpu_create ( kvm , id ) ; if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ; preempt_notifier_init ( & vcpu -> preempt_notifier , & kvm_preempt_ops ) ; r = kvm_arch_vcpu_setup ( vcpu ) ; if ( r ) goto vcpu_destroy ; mutex_lock ( & kvm -> lock ) ; if ( ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } kvm_for_each_vcpu ( r , v , kvm ) if ( v -> vcpu_id == id ) { r = - EEXIST ; goto unlock_vcpu_destroy ; } BUG_ON ( kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] ) ; kvm_get_kvm ( kvm ) ; r = create_vcpu_fd ( vcpu ) ; if ( r < 0 ) { kvm_put_kvm ( kvm ) ; goto unlock_vcpu_destroy ; } kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] = vcpu ; smp_wmb ( ) ; atomic_inc ( & kvm -> online_vcpus ) ; mutex_unlock ( & kvm -> lock ) ; kvm_arch_vcpu_postcreate ( vcpu ) ; return r ; unlock_vcpu_destroy : mutex_unlock ( & kvm -> lock ) ; vcpu_destroy : kvm_arch_vcpu_destroy ( vcpu ) ; return r ; }
TPM2B_MAX_NV_BUFFER_Marshal ( TPM2B_MAX_NV_BUFFER * source , BYTE * * buffer , INT32 * size ) { UINT16 written = 0 ; written += TPM2B_Marshal ( & source -> b , buffer , size ) ; return written ; }
otError Commissioner :: GeneratePskc ( const char * aPassPhrase , const char * aNetworkName , const Mac :: ExtendedPanId & aExtPanId , Pskc & aPskc ) { otError error = OT_ERROR_NONE ; const char * saltPrefix = "Thread" ; uint8_t salt [ OT_PBKDF2_SALT_MAX_LEN ] ; uint16_t saltLen = 0 ; VerifyOrExit ( ( strlen ( aPassPhrase ) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE ) && ( strlen ( aPassPhrase ) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE ) && ( strlen ( aNetworkName ) <= OT_NETWORK_NAME_MAX_SIZE ) , error = OT_ERROR_INVALID_ARGS ) ; memset ( salt , 0 , sizeof ( salt ) ) ; memcpy ( salt , saltPrefix , strlen ( saltPrefix ) ) ; saltLen += static_cast < uint16_t > ( strlen ( saltPrefix ) ) ; memcpy ( salt + saltLen , aExtPanId . m8 , sizeof ( aExtPanId ) ) ; saltLen += OT_EXT_PAN_ID_SIZE ; memcpy ( salt + saltLen , aNetworkName , strlen ( aNetworkName ) ) ; saltLen += static_cast < uint16_t > ( strlen ( aNetworkName ) ) ; otPbkdf2Cmac ( reinterpret_cast < const uint8_t * > ( aPassPhrase ) , static_cast < uint16_t > ( strlen ( aPassPhrase ) ) , reinterpret_cast < const uint8_t * > ( salt ) , saltLen , 16384 , OT_PSKC_MAX_SIZE , aPskc . m8 ) ; exit : return error ; }
TF_BUILTIN ( ObjectGetOwnPropertyDescriptor , ObjectBuiltinsAssembler ) { Node * argc = Parameter ( Descriptor :: kJSActualArgumentsCount ) ; Node * context = Parameter ( Descriptor :: kContext ) ; CSA_ASSERT ( this , IsUndefined ( Parameter ( Descriptor :: kJSNewTarget ) ) ) ; CodeStubArguments args ( this , ChangeInt32ToIntPtr ( argc ) ) ; Node * object = args . GetOptionalArgumentValue ( 0 ) ; Node * key = args . GetOptionalArgumentValue ( 1 ) ; object = ToObject_Inline ( CAST ( context ) , CAST ( object ) ) ; key = ToName ( context , key ) ; Label if_keyisindex ( this ) , if_iskeyunique ( this ) , call_runtime ( this , Label :: kDeferred ) , return_undefined ( this , Label :: kDeferred ) , if_notunique_name ( this ) ; Node * map = LoadMap ( object ) ; TNode < Int32T > instance_type = LoadMapInstanceType ( map ) ; GotoIf ( IsSpecialReceiverInstanceType ( instance_type ) , & call_runtime ) ; { VARIABLE ( var_index , MachineType :: PointerRepresentation ( ) , IntPtrConstant ( 0 ) ) ; VARIABLE ( var_name , MachineRepresentation :: kTagged ) ; TryToName ( key , & if_keyisindex , & var_index , & if_iskeyunique , & var_name , & call_runtime , & if_notunique_name ) ; BIND ( & if_notunique_name ) ; { Label not_in_string_table ( this ) ; TryInternalizeString ( key , & if_keyisindex , & var_index , & if_iskeyunique , & var_name , & not_in_string_table , & call_runtime ) ; BIND ( & not_in_string_table ) ; { Goto ( & return_undefined ) ; } } BIND ( & if_iskeyunique ) ; { Label if_found_value ( this ) , return_empty ( this ) , if_not_found ( this ) ; VARIABLE ( var_value , MachineRepresentation :: kTagged ) ; VARIABLE ( var_details , MachineRepresentation :: kWord32 ) ; VARIABLE ( var_raw_value , MachineRepresentation :: kTagged ) ; TryGetOwnProperty ( context , object , object , map , instance_type , var_name . value ( ) , & if_found_value , & var_value , & var_details , & var_raw_value , & return_empty , & if_not_found , kReturnAccessorPair ) ; BIND ( & if_found_value ) ; Node * js_desc = FromPropertyDetails ( context , var_value . value ( ) , var_details . value ( ) , & call_runtime ) ; args . PopAndReturn ( js_desc ) ; BIND ( & return_empty ) ; var_value . Bind ( UndefinedConstant ( ) ) ; args . PopAndReturn ( UndefinedConstant ( ) ) ; BIND ( & if_not_found ) ; Goto ( & call_runtime ) ; } } BIND ( & if_keyisindex ) ; Goto ( & call_runtime ) ; BIND ( & call_runtime ) ; { Node * desc = CallRuntime ( Runtime :: kGetOwnPropertyDescriptor , context , object , key ) ; GotoIf ( IsUndefined ( desc ) , & return_undefined ) ; CSA_ASSERT ( this , IsFixedArray ( desc ) ) ; Node * js_desc = FromPropertyDescriptor ( context , desc ) ; args . PopAndReturn ( js_desc ) ; } BIND ( & return_undefined ) ; args . PopAndReturn ( UndefinedConstant ( ) ) ; }
static void zero_stats ( FIRSTPASS_STATS * section ) { section -> frame = 0.0 ; section -> intra_error = 0.0 ; section -> coded_error = 0.0 ; section -> sr_coded_error = 0.0 ; section -> ssim_weighted_pred_err = 0.0 ; section -> pcnt_inter = 0.0 ; section -> pcnt_motion = 0.0 ; section -> pcnt_second_ref = 0.0 ; section -> pcnt_neutral = 0.0 ; section -> MVr = 0.0 ; section -> mvr_abs = 0.0 ; section -> MVc = 0.0 ; section -> mvc_abs = 0.0 ; section -> MVrv = 0.0 ; section -> MVcv = 0.0 ; section -> mv_in_out_count = 0.0 ; section -> new_mv_count = 0.0 ; section -> count = 0.0 ; section -> duration = 1.0 ; section -> spatial_layer_id = 0 ; }
static ExprList * exprListAppendList ( Parse * pParse , ExprList * pList , ExprList * pAppend , int bIntToNull ) { if ( pAppend ) { int i ; int nInit = pList ? pList -> nExpr : 0 ; for ( i = 0 ; i < pAppend -> nExpr ; i ++ ) { Expr * pDup = sqlite3ExprDup ( pParse -> db , pAppend -> a [ i ] . pExpr , 0 ) ; if ( bIntToNull && pDup && pDup -> op == TK_INTEGER ) { pDup -> op = TK_NULL ; pDup -> flags &= ~ ( EP_IntValue | EP_IsTrue | EP_IsFalse ) ; } pList = sqlite3ExprListAppend ( pParse , pList , pDup ) ; if ( pList ) pList -> a [ nInit + i ] . sortFlags = pAppend -> a [ i ] . sortFlags ; } } return pList ; }
GetElementIC :: attachTypedArrayElement ( JSContext * cx , IonScript * ion , TypedArrayObject * tarr , const Value & idval ) { MacroAssembler masm ( cx , ion ) ; RepatchStubAppender attacher ( * this ) ; GenerateGetTypedArrayElement ( cx , masm , attacher , tarr , idval , object ( ) , index ( ) , output ( ) ) ; return linkAndAttachStub ( cx , masm , attacher , ion , "typed array" ) ; }
int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , "failed to apply delta: base size does not match given data" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , "failed to apply delta: base size does not match given data" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { size_t off = 0 , len = 0 ; if ( cmd & 0x01 ) off = * delta ++ ; if ( cmd & 0x02 ) off |= * delta ++ < < 8UL ; if ( cmd & 0x04 ) off |= * delta ++ < < 16UL ; if ( cmd & 0x08 ) off |= * delta ++ < < 24UL ; if ( cmd & 0x10 ) len = * delta ++ ; if ( cmd & 0x20 ) len |= * delta ++ < < 8UL ; if ( cmd & 0x40 ) len |= * delta ++ < < 16UL ; if ( ! len ) len = 0x10000 ; if ( base_len < off + len || res_sz < len ) goto fail ; memcpy ( res_dp , base + off , len ) ; res_dp += len ; res_sz -= len ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp , delta , cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else { goto fail ; } } if ( delta != delta_end || res_sz ) goto fail ; return 0 ; fail : git__free ( * out ) ; * out = NULL ; * out_len = 0 ; giterr_set ( GITERR_INVALID , "failed to apply delta" ) ; return - 1 ; }
JS_BrokenFrameIterator ( JSContext * cx , JSStackFrame * * iteratorp ) { StackFrame * fp = Valueify ( * iteratorp ) ; * iteratorp = Jsvalify ( ( fp == NULL ) ? js_GetTopStackFrame ( cx , FRAME_EXPAND_ALL ) : fp -> prev ( ) ) ; return * iteratorp ; }
JS_NondeterministicGetWeakMapKeys ( JSContext * cx , JSObject * obj , JSObject * * ret ) { if ( ! obj || ! obj -> isWeakMap ( ) ) { * ret = NULL ; return true ; } RootedObject arr ( cx , NewDenseEmptyArray ( cx ) ) ; if ( ! arr ) return false ; ObjectValueMap * map = GetObjectMap ( obj ) ; if ( map ) { for ( ObjectValueMap :: Base :: Range r = map -> all ( ) ; ! r . empty ( ) ; r . popFront ( ) ) { if ( ! js_NewbornArrayPush ( cx , arr , ObjectValue ( * r . front ( ) . key ) ) ) return false ; } } * ret = arr ; return true ; }
con_header_read ( agooCon c , size_t * mlenp ) { char * hend = strstr ( c -> buf , "\r\n\r\n" ) ; agooMethod method ; struct _agooSeg path ; char * query = NULL ; char * qend ; char * b ; size_t clen = 0 ; long mlen ; agooHook hook = NULL ; agooPage p ; struct _agooErr err = AGOO_ERR_INIT ; if ( NULL == hend ) { if ( sizeof ( c -> buf ) - 1 <= c -> bcnt ) { return bad_request ( c , 431 , __LINE__ ) ; } return HEAD_AGAIN ; } if ( agoo_req_cat . on ) { * hend = '\0' ; agoo_log_cat ( & agoo_req_cat , "%s %llu: %s" , agoo_con_kind_str ( c -> bind -> kind ) , ( unsigned long long ) c -> id , c -> buf ) ; * hend = '\r' ; } for ( b = c -> buf ; ' ' != * b ; b ++ ) { if ( '\0' == * b ) { return bad_request ( c , 400 , __LINE__ ) ; } } switch ( toupper ( * c -> buf ) ) { case 'G' : if ( 3 != b - c -> buf || 0 != strncmp ( "GET" , c -> buf , 3 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_GET ; break ; case 'P' : { const char * v ; int vlen = 0 ; char * vend ; if ( 3 == b - c -> buf && 0 == strncmp ( "PUT" , c -> buf , 3 ) ) { method = AGOO_PUT ; } else if ( 4 == b - c -> buf && 0 == strncmp ( "POST" , c -> buf , 4 ) ) { method = AGOO_POST ; } else { return bad_request ( c , 400 , __LINE__ ) ; } if ( NULL == ( v = agoo_con_header_value ( c -> buf , ( int ) ( hend - c -> buf ) , "Content-Length" , & vlen ) ) ) { return bad_request ( c , 411 , __LINE__ ) ; } clen = ( size_t ) strtoul ( v , & vend , 10 ) ; if ( vend != v + vlen ) { return bad_request ( c , 411 , __LINE__ ) ; } break ; } case 'D' : if ( 6 != b - c -> buf || 0 != strncmp ( "DELETE" , c -> buf , 6 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_DELETE ; break ; case 'H' : if ( 4 != b - c -> buf || 0 != strncmp ( "HEAD" , c -> buf , 4 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_HEAD ; break ; case 'O' : if ( 7 != b - c -> buf || 0 != strncmp ( "OPTIONS" , c -> buf , 7 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_OPTIONS ; break ; case 'C' : if ( 7 != b - c -> buf || 0 != strncmp ( "CONNECT" , c -> buf , 7 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_CONNECT ; break ; default : return bad_request ( c , 400 , __LINE__ ) ; } for ( ; ' ' == * b ; b ++ ) { if ( '\0' == * b ) { return bad_request ( c , 400 , __LINE__ ) ; } } path . start = b ; for ( ; ' ' != * b ; b ++ ) { switch ( * b ) { case '?' : path . end = b ; query = b + 1 ; break ; case '\0' : return bad_request ( c , 400 , __LINE__ ) ; default : break ; } } if ( NULL == query ) { path . end = b ; query = b ; qend = b ; } else { qend = b ; } mlen = hend - c -> buf + 4 + clen ; * mlenp = mlen ; if ( AGOO_GET == method ) { char root_buf [ 20148 ] ; const char * root = NULL ; if ( NULL != ( p = agoo_group_get ( & err , path . start , ( int ) ( path . end - path . start ) ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( agoo_domain_use ( ) ) { const char * host ; int vlen = 0 ; if ( NULL == ( host = agoo_con_header_value ( c -> buf , ( int ) ( hend - c -> buf ) , "Host" , & vlen ) ) ) { return bad_request ( c , 411 , __LINE__ ) ; } ( ( char * ) host ) [ vlen ] = '\0' ; root = agoo_domain_resolve ( host , root_buf , sizeof ( root_buf ) ) ; ( ( char * ) host ) [ vlen ] = '\r' ; } if ( agoo_server . root_first && NULL != ( p = agoo_page_get ( & err , path . start , ( int ) ( path . end - path . start ) , root ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( NULL == ( hook = agoo_hook_find ( agoo_server . hooks , method , & path ) ) ) { if ( NULL != ( p = agoo_page_get ( & err , path . start , ( int ) ( path . end - path . start ) , root ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( NULL == agoo_server . hook404 ) { return bad_request ( c , 404 , __LINE__ ) ; } hook = agoo_server . hook404 ; } } else if ( NULL == ( hook = agoo_hook_find ( agoo_server . hooks , method , & path ) ) ) { return bad_request ( c , 404 , __LINE__ ) ; } if ( NULL == ( c -> req = agoo_req_create ( mlen ) ) ) { return bad_request ( c , 413 , __LINE__ ) ; } if ( ( long ) c -> bcnt <= mlen ) { memcpy ( c -> req -> msg , c -> buf , c -> bcnt ) ; if ( ( long ) c -> bcnt < mlen ) { memset ( c -> req -> msg + c -> bcnt , 0 , mlen - c -> bcnt ) ; } } else { memcpy ( c -> req -> msg , c -> buf , mlen ) ; } c -> req -> msg [ mlen ] = '\0' ; c -> req -> method = method ; c -> req -> upgrade = AGOO_UP_NONE ; c -> req -> up = NULL ; c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ; c -> req -> path . len = ( int ) ( path . end - path . start ) ; c -> req -> query . start = c -> req -> msg + ( query - c -> buf ) ; c -> req -> query . len = ( int ) ( qend - query ) ; c -> req -> query . start [ c -> req -> query . len ] = '\0' ; c -> req -> body . start = c -> req -> msg + ( hend - c -> buf + 4 ) ; c -> req -> body . len = ( unsigned int ) clen ; b = strstr ( b , "\r\n" ) ; c -> req -> header . start = c -> req -> msg + ( b + 2 - c -> buf ) ; if ( b < hend ) { c -> req -> header . len = ( unsigned int ) ( hend - b - 2 ) ; } else { c -> req -> header . len = 0 ; } c -> req -> res = NULL ; c -> req -> hook = hook ; return HEAD_OK ; }
void GCRuntime :: finishCollection ( ) { assertBackgroundSweepingFinished ( ) ; MOZ_ASSERT ( marker . isDrained ( ) ) ; marker . stop ( ) ; maybeStopPretenuring ( ) ; TimeStamp currentTime = TimeStamp :: Now ( ) ; updateSchedulingStateAfterCollection ( currentTime ) ; for ( GCZonesIter zone ( this ) ; ! zone . done ( ) ; zone . next ( ) ) { zone -> changeGCState ( Zone :: Finished , Zone :: NoGC ) ; zone -> notifyObservingDebuggers ( ) ; for ( RealmsInZoneIter realm ( zone ) ; ! realm . done ( ) ; realm . next ( ) ) { realm -> clearAllocatedDuringGC ( ) ; } } #ifdef JS_GC_ZEAL clearSelectedForMarking ( ) ; #endif schedulingState . updateHighFrequencyMode ( lastGCEndTime_ , currentTime , tunables ) ; lastGCEndTime_ = currentTime ; checkGCStateNotInUse ( ) ; }
TEST_P ( SixtapPredictTest , TestWithRandomData ) { ACMRandom rnd ( ACMRandom :: DeterministicSeed ( ) ) ; for ( int i = 0 ; i < kSrcSize ; ++ i ) src_ [ i ] = rnd . Rand8 ( ) ; for ( int xoffset = 0 ; xoffset < 8 ; ++ xoffset ) { for ( int yoffset = 0 ; yoffset < 8 ; ++ yoffset ) { vp8_sixtap_predict16x16_c ( & src_ [ kSrcStride * 2 + 2 + 1 ] , kSrcStride , xoffset , yoffset , dst_c_ , kDstStride ) ; REGISTER_STATE_CHECK ( sixtap_predict_ ( & src_ [ kSrcStride * 2 + 2 + 1 ] , kSrcStride , xoffset , yoffset , dst_ , kDstStride ) ) ; for ( int i = 0 ; i < height_ ; ++ i ) for ( int j = 0 ; j < width_ ; ++ j ) ASSERT_EQ ( dst_c_ [ i * kDstStride + j ] , dst_ [ i * kDstStride + j ] ) < < "i==" < < ( i * width_ + j ) ; } } }
void smp_proc_srk_info ( tSMP_CB * p_cb , tSMP_INT_DATA * p_data ) { tBTM_LE_PCSRK_KEYS le_key ; SMP_TRACE_DEBUG ( "%s" , __func__ ) ; smp_update_key_mask ( p_cb , SMP_SEC_KEY_TYPE_CSRK , true ) ; le_key . sec_level = p_cb -> sec_level ; maybe_non_aligned_memcpy ( le_key . csrk , p_data -> p_data , BT_OCTET16_LEN ) ; le_key . counter = 0 ; if ( ( p_cb -> peer_auth_req & SMP_AUTH_BOND ) && ( p_cb -> loc_auth_req & SMP_AUTH_BOND ) ) btm_sec_save_le_key ( p_cb -> pairing_bda , BTM_LE_KEY_PCSRK , ( tBTM_LE_KEY_VALUE * ) & le_key , true ) ; smp_key_distribution_by_transport ( p_cb , NULL ) ; }
sctp_disposition_t sctp_sf_do_5_1D_ce ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; sctp_init_chunk_t * peer_init ; struct sctp_chunk * repl ; struct sctp_ulpevent * ev , * ai_ev = NULL ; int error = 0 ; struct sctp_chunk * err_chk_p ; struct sock * sk ; if ( ep == sctp_sk ( net -> sctp . ctl_sock ) -> ep ) { SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; sk = ep -> base . sk ; if ( ! sctp_sstate ( sk , LISTENING ) || ( sctp_style ( sk , TCP ) && sk_acceptq_is_full ( sk ) ) ) return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } peer_init = & chunk -> subh . cookie_hdr -> c . peer_init [ 0 ] ; if ( ! sctp_process_init ( new_asoc , chunk , & chunk -> subh . cookie_hdr -> c . peer_addr , peer_init , GFP_ATOMIC ) ) goto nomem_init ; error = sctp_auth_asoc_init_active_key ( new_asoc , GFP_ATOMIC ) ; if ( error ) goto nomem_init ; if ( chunk -> auth_chunk ) { struct sctp_chunk auth ; sctp_ierror_t ret ; auth . skb = chunk -> auth_chunk ; auth . asoc = chunk -> asoc ; auth . sctp_hdr = chunk -> sctp_hdr ; auth . chunk_hdr = ( sctp_chunkhdr_t * ) skb_push ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; skb_pull ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; auth . transport = chunk -> transport ; ret = sctp_sf_authenticate ( net , ep , new_asoc , type , & auth ) ; kfree_skb ( chunk -> auth_chunk ) ; if ( ret != SCTP_IERROR_NO_ERROR ) { sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } repl = sctp_make_cookie_ack ( new_asoc , chunk ) ; if ( ! repl ) goto nomem_init ; ev = sctp_ulpevent_make_assoc_change ( new_asoc , 0 , SCTP_COMM_UP , 0 , new_asoc -> c . sinit_num_ostreams , new_asoc -> c . sinit_max_instreams , NULL , GFP_ATOMIC ) ; if ( ! ev ) goto nomem_ev ; if ( new_asoc -> peer . adaptation_ind ) { ai_ev = sctp_ulpevent_make_adaptation_indication ( new_asoc , GFP_ATOMIC ) ; if ( ! ai_ev ) goto nomem_aiev ; } sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_STATE , SCTP_STATE ( SCTP_STATE_ESTABLISHED ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_CURRESTAB ) ; SCTP_INC_STATS ( net , SCTP_MIB_PASSIVEESTABS ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_HB_TIMERS_START , SCTP_NULL ( ) ) ; if ( new_asoc -> timeouts [ SCTP_EVENT_TIMEOUT_AUTOCLOSE ] ) sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_START , SCTP_TO ( SCTP_EVENT_TIMEOUT_AUTOCLOSE ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( repl ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ev ) ) ; if ( ai_ev ) sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ai_ev ) ) ; return SCTP_DISPOSITION_CONSUME ; nomem_aiev : sctp_ulpevent_free ( ev ) ; nomem_ev : sctp_chunk_free ( repl ) ; nomem_init : sctp_association_free ( new_asoc ) ; nomem : return SCTP_DISPOSITION_NOMEM ; }
PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = "PredictorEncodeTile" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , "Out of memory allocating " TIFF_SSIZE_FORMAT " byte temp buffer." , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; if ( ( cc0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "PredictorEncodeTile" , "%s" , "(cc0%rowsize)!=0" ) ; return 0 ; } while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }
Node * AccessorAssembler :: ExtendPropertiesBackingStore ( Node * object , Node * index ) { Comment ( "[ Extend storage" ) ; ParameterMode mode = OptimalParameterMode ( ) ; VARIABLE ( var_properties , MachineRepresentation :: kTaggedPointer ) ; VARIABLE ( var_encoded_hash , MachineRepresentation :: kWord32 ) ; VARIABLE ( var_length , ParameterRepresentation ( mode ) ) ; Node * properties = LoadObjectField ( object , JSObject :: kPropertiesOrHashOffset ) ; var_properties . Bind ( properties ) ; Label if_smi_hash ( this ) , if_property_array ( this ) , extend_store ( this ) ; Branch ( TaggedIsSmi ( properties ) , & if_smi_hash , & if_property_array ) ; BIND ( & if_smi_hash ) ; { Node * hash = SmiToInt32 ( properties ) ; Node * encoded_hash = Word32Shl ( hash , Int32Constant ( PropertyArray :: HashField :: kShift ) ) ; var_encoded_hash . Bind ( encoded_hash ) ; var_length . Bind ( IntPtrOrSmiConstant ( 0 , mode ) ) ; var_properties . Bind ( EmptyFixedArrayConstant ( ) ) ; Goto ( & extend_store ) ; } BIND ( & if_property_array ) ; { Node * length_and_hash_int32 = LoadAndUntagToWord32ObjectField ( var_properties . value ( ) , PropertyArray :: kLengthAndHashOffset ) ; var_encoded_hash . Bind ( Word32And ( length_and_hash_int32 , Int32Constant ( PropertyArray :: HashField :: kMask ) ) ) ; Node * length_intptr = ChangeInt32ToIntPtr ( Word32And ( length_and_hash_int32 , Int32Constant ( PropertyArray :: LengthField :: kMask ) ) ) ; Node * length = IntPtrToParameter ( length_intptr , mode ) ; var_length . Bind ( length ) ; Goto ( & extend_store ) ; } BIND ( & extend_store ) ; { VARIABLE ( var_new_properties , MachineRepresentation :: kTaggedPointer , var_properties . value ( ) ) ; Label done ( this ) ; GotoIf ( UintPtrLessThan ( index , ParameterToIntPtr ( var_length . value ( ) , mode ) ) , & done ) ; Node * delta = IntPtrOrSmiConstant ( JSObject :: kFieldsAdded , mode ) ; Node * new_capacity = IntPtrOrSmiAdd ( var_length . value ( ) , delta , mode ) ; DCHECK ( kMaxNumberOfDescriptors + JSObject :: kFieldsAdded < FixedArrayBase :: GetMaxLengthForNewSpaceAllocation ( PACKED_ELEMENTS ) ) ; CSA_ASSERT ( this , UintPtrOrSmiLessThan ( new_capacity , IntPtrOrSmiConstant ( kMaxNumberOfDescriptors + JSObject :: kFieldsAdded , mode ) , mode ) ) ; Node * new_properties = AllocatePropertyArray ( new_capacity , mode ) ; var_new_properties . Bind ( new_properties ) ; FillPropertyArrayWithUndefined ( new_properties , var_length . value ( ) , new_capacity , mode ) ; CopyPropertyArrayValues ( var_properties . value ( ) , new_properties , var_length . value ( ) , SKIP_WRITE_BARRIER , mode ) ; Node * new_capacity_int32 = TruncateIntPtrToInt32 ( ParameterToIntPtr ( new_capacity , mode ) ) ; Node * new_length_and_hash_int32 = Word32Or ( var_encoded_hash . value ( ) , new_capacity_int32 ) ; StoreObjectField ( new_properties , PropertyArray :: kLengthAndHashOffset , SmiFromInt32 ( new_length_and_hash_int32 ) ) ; StoreObjectField ( object , JSObject :: kPropertiesOrHashOffset , new_properties ) ; Comment ( "] Extend storage" ) ; Goto ( & done ) ; BIND ( & done ) ; return var_new_properties . value ( ) ; } }
static void renameColumnFunc ( sqlite3_context * context , int NotUsed , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; RenameCtx sCtx ; const char * zSql = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zDb = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * zTable = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; int iCol = sqlite3_value_int ( argv [ 5 ] ) ; const char * zNew = ( const char * ) sqlite3_value_text ( argv [ 6 ] ) ; int bQuote = sqlite3_value_int ( argv [ 7 ] ) ; int bTemp = sqlite3_value_int ( argv [ 8 ] ) ; const char * zOld ; int rc ; Parse sParse ; Walker sWalker ; Index * pIdx ; int i ; Table * pTab ; #ifndef SQLITE_OMIT_AUTHORIZATION sqlite3_xauth xAuth = db -> xAuth ; #endif UNUSED_PARAMETER ( NotUsed ) ; if ( zSql == 0 ) return ; if ( zTable == 0 ) return ; if ( zNew == 0 ) return ; if ( iCol < 0 ) return ; sqlite3BtreeEnterAll ( db ) ; pTab = sqlite3FindTable ( db , zTable , zDb ) ; if ( pTab == 0 || iCol >= pTab -> nCol ) { sqlite3BtreeLeaveAll ( db ) ; return ; } zOld = pTab -> aCol [ iCol ] . zName ; memset ( & sCtx , 0 , sizeof ( sCtx ) ) ; sCtx . iCol = ( ( iCol == pTab -> iPKey ) ? - 1 : iCol ) ; #ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = 0 ; #endif rc = renameParseSql ( & sParse , zDb , 0 , db , zSql , bTemp ) ; memset ( & sWalker , 0 , sizeof ( Walker ) ) ; sWalker . pParse = & sParse ; sWalker . xExprCallback = renameColumnExprCb ; sWalker . xSelectCallback = renameColumnSelectCb ; sWalker . u . pRename = & sCtx ; sCtx . pTab = pTab ; if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; if ( sParse . pNewTable ) { Select * pSelect = sParse . pNewTable -> pSelect ; if ( pSelect ) { sParse . rc = SQLITE_OK ; sqlite3SelectPrep ( & sParse , sParse . pNewTable -> pSelect , 0 ) ; rc = ( db -> mallocFailed ? SQLITE_NOMEM : sParse . rc ) ; if ( rc == SQLITE_OK ) { sqlite3WalkSelect ( & sWalker , pSelect ) ; } if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; } else { int bFKOnly = sqlite3_stricmp ( zTable , sParse . pNewTable -> zName ) ; FKey * pFKey ; assert ( sParse . pNewTable -> pSelect == 0 ) ; sCtx . pTab = sParse . pNewTable ; if ( bFKOnly == 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) sParse . pNewTable -> aCol [ iCol ] . zName ) ; if ( sCtx . iCol < 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) & sParse . pNewTable -> iPKey ) ; } sqlite3WalkExprList ( & sWalker , sParse . pNewTable -> pCheck ) ; for ( pIdx = sParse . pNewTable -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3WalkExprList ( & sWalker , pIdx -> aColExpr ) ; } for ( pIdx = sParse . pNewIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3WalkExprList ( & sWalker , pIdx -> aColExpr ) ; } } #ifndef SQLITE_OMIT_GENERATED_COLUMNS for ( i = 0 ; i < sParse . pNewTable -> nCol ; i ++ ) { sqlite3WalkExpr ( & sWalker , sParse . pNewTable -> aCol [ i ] . pDflt ) ; } #endif for ( pFKey = sParse . pNewTable -> pFKey ; pFKey ; pFKey = pFKey -> pNextFrom ) { for ( i = 0 ; i < pFKey -> nCol ; i ++ ) { if ( bFKOnly == 0 && pFKey -> aCol [ i ] . iFrom == iCol ) { renameTokenFind ( & sParse , & sCtx , ( void * ) & pFKey -> aCol [ i ] ) ; } if ( 0 == sqlite3_stricmp ( pFKey -> zTo , zTable ) && 0 == sqlite3_stricmp ( pFKey -> aCol [ i ] . zCol , zOld ) ) { renameTokenFind ( & sParse , & sCtx , ( void * ) pFKey -> aCol [ i ] . zCol ) ; } } } } } else if ( sParse . pNewIndex ) { sqlite3WalkExprList ( & sWalker , sParse . pNewIndex -> aColExpr ) ; sqlite3WalkExpr ( & sWalker , sParse . pNewIndex -> pPartIdxWhere ) ; } else { TriggerStep * pStep ; rc = renameResolveTrigger ( & sParse , ( bTemp ? 0 : zDb ) ) ; if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; for ( pStep = sParse . pNewTrigger -> step_list ; pStep ; pStep = pStep -> pNext ) { if ( pStep -> zTarget ) { Table * pTarget = sqlite3LocateTable ( & sParse , 0 , pStep -> zTarget , zDb ) ; if ( pTarget == pTab ) { if ( pStep -> pUpsert ) { ExprList * pUpsertSet = pStep -> pUpsert -> pUpsertSet ; renameColumnElistNames ( & sParse , & sCtx , pUpsertSet , zOld ) ; } renameColumnIdlistNames ( & sParse , & sCtx , pStep -> pIdList , zOld ) ; renameColumnElistNames ( & sParse , & sCtx , pStep -> pExprList , zOld ) ; } } } if ( sParse . pTriggerTab == pTab ) { renameColumnIdlistNames ( & sParse , & sCtx , sParse . pNewTrigger -> pColumns , zOld ) ; } renameWalkTrigger ( & sWalker , sParse . pNewTrigger ) ; } assert ( rc == SQLITE_OK ) ; rc = renameEditSql ( context , & sCtx , zSql , zNew , bQuote ) ; renameColumnFunc_done : if ( rc != SQLITE_OK ) { if ( sParse . zErrMsg ) { renameColumnParseError ( context , 0 , argv [ 1 ] , argv [ 2 ] , & sParse ) ; } else { sqlite3_result_error_code ( context , rc ) ; } } renameParseCleanup ( & sParse ) ; renameTokenFree ( db , sCtx . pList ) ; #ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = xAuth ; #endif sqlite3BtreeLeaveAll ( db ) ; }
png_cache_unknown_chunk ( png_structrp png_ptr , png_uint_32 length ) { png_alloc_size_t limit = PNG_SIZE_MAX ; if ( png_ptr -> unknown_chunk . data != NULL ) { png_free ( png_ptr , png_ptr -> unknown_chunk . data ) ; png_ptr -> unknown_chunk . data = NULL ; } #  ifdef PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED if ( png_ptr -> user_chunk_malloc_max > 0 && png_ptr -> user_chunk_malloc_max < limit ) limit = png_ptr -> user_chunk_malloc_max ; #  elif PNG_USER_CHUNK_MALLOC_MAX > 0 if ( PNG_USER_CHUNK_MALLOC_MAX < limit ) limit = PNG_USER_CHUNK_MALLOC_MAX ; #  endif if ( length <= limit ) { PNG_CSTRING_FROM_CHUNK ( png_ptr -> unknown_chunk . name , png_ptr -> chunk_name ) ; png_ptr -> unknown_chunk . size = ( png_size_t ) length ; png_ptr -> unknown_chunk . location = ( png_byte ) png_ptr -> mode ; if ( length == 0 ) png_ptr -> unknown_chunk . data = NULL ; else { png_ptr -> unknown_chunk . data = png_voidcast ( png_bytep , png_malloc_warn ( png_ptr , length ) ) ; } } if ( png_ptr -> unknown_chunk . data == NULL && length > 0 ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "unknown chunk exceeds memory limits" ) ; return 0 ; } else { if ( length > 0 ) png_crc_read ( png_ptr , png_ptr -> unknown_chunk . data , length ) ; png_crc_finish ( png_ptr , 0 ) ; return 1 ; } }
ConcurrentMarking :: PauseScope :: PauseScope ( ConcurrentMarking * concurrent_marking ) : concurrent_marking_ ( concurrent_marking ) , resume_on_exit_ ( concurrent_marking_ -> Stop ( ConcurrentMarking :: StopRequest :: PREEMPT_TASKS ) ) { DCHECK_IMPLIES ( resume_on_exit_ , FLAG_concurrent_marking ) ; }
base :: Optional < ParseResult > MakeTypeAliasDeclaration ( ParseResultIterator * child_results ) { auto name = child_results -> NextAs < std :: string > ( ) ; auto type = child_results -> NextAs < TypeExpression * > ( ) ; Declaration * result = MakeNode < TypeAliasDeclaration > ( std :: move ( name ) , type ) ; return ParseResult { result } ; }
MachineRepresentation GetOutputInfoForPhi ( Node * node , Type type , Truncation use ) { if ( type . Is ( Type :: None ( ) ) ) { return MachineRepresentation :: kNone ; } else if ( type . Is ( Type :: Signed32 ( ) ) || type . Is ( Type :: Unsigned32 ( ) ) ) { return MachineRepresentation :: kWord32 ; } else if ( type . Is ( Type :: NumberOrOddball ( ) ) && use . IsUsedAsWord32 ( ) ) { return MachineRepresentation :: kWord32 ; } else if ( type . Is ( Type :: Boolean ( ) ) ) { return MachineRepresentation :: kBit ; } else if ( type . Is ( Type :: NumberOrOddball ( ) ) && use . IsUsedAsFloat64 ( ) ) { return MachineRepresentation :: kFloat64 ; } else if ( type . Is ( Type :: Union ( Type :: SignedSmall ( ) , Type :: NaN ( ) , zone ( ) ) ) ) { return MachineRepresentation :: kTagged ; } else if ( type . Is ( Type :: Number ( ) ) ) { return MachineRepresentation :: kFloat64 ; } else if ( type . Is ( Type :: ExternalPointer ( ) ) ) { return MachineType :: PointerRepresentation ( ) ; } return MachineRepresentation :: kTagged ; }
static int picolcd_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * raw_data , int size ) { struct picolcd_data * data = hid_get_drvdata ( hdev ) ; unsigned long flags ; int ret = 0 ; if ( ! data ) return 1 ; if ( report -> id == REPORT_KEY_STATE ) { if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ; } else if ( report -> id == REPORT_IR_DATA ) { ret = picolcd_raw_cir ( data , report , raw_data + 1 , size - 1 ) ; } else { spin_lock_irqsave ( & data -> lock , flags ) ; if ( data -> pending ) { memcpy ( data -> pending -> raw_data , raw_data + 1 , size - 1 ) ; data -> pending -> raw_size = size - 1 ; data -> pending -> in_report = report ; complete ( & data -> pending -> ready ) ; } spin_unlock_irqrestore ( & data -> lock , flags ) ; } picolcd_debug_raw_event ( data , hdev , report , raw_data , size ) ; return 1 ; }
bool ShouldCreateConsString ( ) { DCHECK_EQ ( IrOpcode :: kJSAdd , node_ -> opcode ( ) ) ; DCHECK ( OneInputIs ( Type :: String ( ) ) ) ; if ( BothInputsAre ( Type :: String ( ) ) || BinaryOperationHintOf ( node_ -> op ( ) ) == BinaryOperationHint :: kString ) { HeapObjectBinopMatcher m ( node_ ) ; JSHeapBroker * broker = lowering_ -> js_heap_broker ( ) ; if ( m . right ( ) . HasValue ( ) && m . right ( ) . Ref ( broker ) . IsString ( ) ) { StringRef right_string = m . right ( ) . Ref ( broker ) . AsString ( ) ; if ( right_string . length ( ) >= ConsString :: kMinLength ) return true ; } if ( m . left ( ) . HasValue ( ) && m . left ( ) . Ref ( broker ) . IsString ( ) ) { StringRef left_string = m . left ( ) . Ref ( broker ) . AsString ( ) ; if ( left_string . length ( ) >= ConsString :: kMinLength ) { return left_string . IsSeqString ( ) || left_string . IsExternalString ( ) ; } } } return false ; }
JS_PUBLIC_API ( StackDescription * ) JS :: DescribeStack ( JSContext * cx , unsigned maxFrames ) { Vector < FrameDescription > frames ( cx ) ; for ( ScriptFrameIter i ( cx ) ; ! i . done ( ) ; ++ i ) { FrameDescription desc ; desc . script = i . script ( ) ; desc . lineno = PCToLineNumber ( i . script ( ) , i . pc ( ) ) ; desc . fun = i . fp ( ) -> maybeFun ( ) ; if ( ! frames . append ( desc ) ) return NULL ; if ( frames . length ( ) == maxFrames ) break ; } StackDescription * desc = js_new < StackDescription > ( ) ; if ( ! desc ) return NULL ; desc -> nframes = frames . length ( ) ; desc -> frames = frames . extractRawBuffer ( ) ; return desc ; }
long Track :: GetNext ( const BlockEntry * pCurrEntry , const BlockEntry * & pNextEntry ) const { assert ( pCurrEntry ) ; assert ( ! pCurrEntry -> EOS ( ) ) ; const Block * const pCurrBlock = pCurrEntry -> GetBlock ( ) ; assert ( pCurrBlock && pCurrBlock -> GetTrackNumber ( ) == m_info . number ) ; if ( ! pCurrBlock || pCurrBlock -> GetTrackNumber ( ) != m_info . number ) return - 1 ; const Cluster * pCluster = pCurrEntry -> GetCluster ( ) ; assert ( pCluster ) ; assert ( ! pCluster -> EOS ( ) ) ; long status = pCluster -> GetNext ( pCurrEntry , pNextEntry ) ; if ( status < 0 ) return status ; for ( int i = 0 ; ; ) { while ( pNextEntry ) { const Block * const pNextBlock = pNextEntry -> GetBlock ( ) ; assert ( pNextBlock ) ; if ( pNextBlock -> GetTrackNumber ( ) == m_info . number ) return 0 ; pCurrEntry = pNextEntry ; status = pCluster -> GetNext ( pCurrEntry , pNextEntry ) ; if ( status < 0 ) return status ; } pCluster = m_pSegment -> GetNext ( pCluster ) ; if ( pCluster == NULL ) { pNextEntry = GetEOS ( ) ; return 1 ; } if ( pCluster -> EOS ( ) ) { #if 0 if ( m_pSegment -> Unparsed ( ) <= 0 ) { pNextEntry = GetEOS ( ) ; return 1 ; } #else if ( m_pSegment -> DoneParsing ( ) ) { pNextEntry = GetEOS ( ) ; return 1 ; } #endif pNextEntry = NULL ; return E_BUFFER_NOT_FULL ; } status = pCluster -> GetFirst ( pNextEntry ) ; if ( status < 0 ) return status ; if ( pNextEntry == NULL ) continue ; ++ i ; if ( i >= 100 ) break ; } pNextEntry = GetEOS ( ) ; return 1 ; }
uint32_t GetARMFlags ( ) { static bool isSet = false ; static uint32_t flags = 0 ; if ( isSet ) return flags ; #if WTF_OS_LINUX int fd = open ( "/proc/self/auxv" , O_RDONLY ) ; if ( fd > 0 ) { Elf32_auxv_t aux ; while ( read ( fd , & aux , sizeof ( Elf32_auxv_t ) ) ) { if ( aux . a_type == AT_HWCAP ) { close ( fd ) ; flags = aux . a_un . a_val ; isSet = true ; #if defined(__ARM_ARCH_7__) || defined (__ARM_ARCH_7A__) flags |= HWCAP_ARMv7 ; #endif return flags ; } } close ( fd ) ; } #if defined(__ARM_ARCH_7__) || defined (__ARM_ARCH_7A__) flags = HWCAP_ARMv7 ; #endif isSet = true ; return flags ; #elif defined(WTF_OS_ANDROID) || defined(MOZ_B2G) FILE * fp = fopen ( "/proc/cpuinfo" , "r" ) ; if ( ! fp ) return false ; char buf [ 1024 ] ; fread ( buf , sizeof ( char ) , sizeof ( buf ) , fp ) ; fclose ( fp ) ; if ( strstr ( buf , "vfp" ) ) flags |= HWCAP_VFP ; if ( strstr ( buf , "vfpv3" ) ) flags |= HWCAP_VFPv3 ; if ( strstr ( buf , "vfpv3d16" ) ) flags |= HWCAP_VFPv3D16 ; if ( strstr ( buf , "vfpv4" ) ) flags |= HWCAP_VFPv4 ; if ( strstr ( buf , "idiva" ) ) flags |= HWCAP_IDIVA ; if ( strstr ( buf , "idivt" ) ) flags |= HWCAP_IDIVT ; if ( strstr ( buf , "neon" ) ) flags |= HWCAP_NEON ; if ( strstr ( buf , "ARMv7" ) ) flags |= HWCAP_ARMv7 ; isSet = true ; return flags ; #endif return 0 ; }
void Run ( PipelineData * data , Zone * temp_zone ) { RegAllocator allocator ( data -> register_allocation_data ( ) , FP_REGISTERS , temp_zone ) ; allocator . AllocateRegisters ( ) ; }
Downscaler :: BeginFrame ( const nsIntSize & aOriginalSize , const Maybe < nsIntRect > & aFrameRect , uint8_t * aOutputBuffer , bool aHasAlpha , bool aFlipVertically ) { MOZ_ASSERT ( aOutputBuffer ) ; MOZ_ASSERT ( mTargetSize != aOriginalSize , "Created a downscaler, but not downscaling?" ) ; MOZ_ASSERT ( mTargetSize . width <= aOriginalSize . width , "Created a downscaler, but width is larger" ) ; MOZ_ASSERT ( mTargetSize . height <= aOriginalSize . height , "Created a downscaler, but height is larger" ) ; MOZ_ASSERT ( aOriginalSize . width > 0 && aOriginalSize . height > 0 , "Invalid original size" ) ; mFrameRect = aFrameRect . valueOr ( nsIntRect ( nsIntPoint ( ) , aOriginalSize ) ) ; MOZ_ASSERT ( mFrameRect . x >= 0 && mFrameRect . y >= 0 && mFrameRect . width >= 0 && mFrameRect . height >= 0 , "Frame rect must have non-negative components" ) ; MOZ_ASSERT ( nsIntRect ( 0 , 0 , aOriginalSize . width , aOriginalSize . height ) . Contains ( mFrameRect ) , "Frame rect must fit inside image" ) ; MOZ_ASSERT_IF ( ! nsIntRect ( 0 , 0 , aOriginalSize . width , aOriginalSize . height ) . IsEqualEdges ( mFrameRect ) , aHasAlpha ) ; mOriginalSize = aOriginalSize ; mScale = gfxSize ( double ( mOriginalSize . width ) / mTargetSize . width , double ( mOriginalSize . height ) / mTargetSize . height ) ; mOutputBuffer = aOutputBuffer ; mHasAlpha = aHasAlpha ; mFlipVertically = aFlipVertically ; ReleaseWindow ( ) ; auto resizeMethod = skia :: ImageOperations :: RESIZE_LANCZOS3 ; skia :: resize :: ComputeFilters ( resizeMethod , mOriginalSize . width , mTargetSize . width , 0 , mTargetSize . width , mXFilter . get ( ) ) ; skia :: resize :: ComputeFilters ( resizeMethod , mOriginalSize . height , mTargetSize . height , 0 , mTargetSize . height , mYFilter . get ( ) ) ; mRowBuffer . reset ( new ( fallible ) uint8_t [ mOriginalSize . width * sizeof ( uint32_t ) + 15 ] ) ; if ( MOZ_UNLIKELY ( ! mRowBuffer ) ) { return NS_ERROR_OUT_OF_MEMORY ; } mWindowCapacity = mYFilter -> max_filter ( ) ; mWindow . reset ( new ( fallible ) uint8_t * [ mWindowCapacity ] ) ; if ( MOZ_UNLIKELY ( ! mWindow ) ) { return NS_ERROR_OUT_OF_MEMORY ; } bool anyAllocationFailed = false ; const int rowSize = mTargetSize . width * sizeof ( uint32_t ) + 15 ; for ( int32_t i = 0 ; i < mWindowCapacity ; ++ i ) { mWindow [ i ] = new ( fallible ) uint8_t [ rowSize ] ; anyAllocationFailed = anyAllocationFailed || mWindow [ i ] == nullptr ; } if ( MOZ_UNLIKELY ( anyAllocationFailed ) ) { return NS_ERROR_OUT_OF_MEMORY ; } ResetForNextProgressivePass ( ) ; return NS_OK ; }
static OPJ_BOOL opj_j2k_get_end_header ( opj_j2k_t * p_j2k , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; p_j2k -> cstr_index -> main_head_end = opj_stream_tell ( p_stream ) ; return OPJ_TRUE ; }
NS_IMETHODIMP nsXULPopupShownEvent :: Run ( ) { nsMenuPopupFrame * popup = do_QueryFrame ( mPopup -> GetPrimaryFrame ( ) ) ; if ( popup && popup -> IsOpen ( ) ) { popup -> SetPopupState ( ePopupShown ) ; } WidgetMouseEvent event ( true , eXULPopupShown , nullptr , WidgetMouseEvent :: eReal ) ; return EventDispatcher :: Dispatch ( mPopup , mPresContext , & event ) ; }
void DebugCodegen :: GenerateFrameDropperTrampoline ( MacroAssembler * masm ) { __ mov ( fp , r1 ) ; __ ldr ( r1 , MemOperand ( fp , JavaScriptFrameConstants :: kFunctionOffset ) ) ; __ LeaveFrame ( StackFrame :: INTERNAL ) ; __ ldr ( r0 , FieldMemOperand ( r1 , JSFunction :: kSharedFunctionInfoOffset ) ) ; __ ldrh ( r0 , FieldMemOperand ( r0 , SharedFunctionInfo :: kFormalParameterCountOffset ) ) ; __ mov ( r2 , r0 ) ; ParameterCount dummy1 ( r2 ) ; ParameterCount dummy2 ( r0 ) ; __ InvokeFunction ( r1 , dummy1 , dummy2 , JUMP_FUNCTION ) ; }
int crxSetupImageData ( crx_data_header_t * hdr , CrxImage * img , int16_t * outBuf , uint64_t mdatOffset , uint32_t mdatSize , uint8_t * mdatHdrPtr ) { int IncrBitTable [ 32 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 } ; img -> planeWidth = hdr -> f_width ; img -> planeHeight = hdr -> f_height ; if ( hdr -> tileWidth < 0x16 || hdr -> tileHeight < 0x16 || img -> planeWidth > 0x7FFF || img -> planeHeight > 0x7FFF ) return - 1 ; img -> tileCols = ( img -> planeWidth + hdr -> tileWidth - 1 ) / hdr -> tileWidth ; img -> tileRows = ( img -> planeHeight + hdr -> tileHeight - 1 ) / hdr -> tileHeight ; if ( img -> tileCols > 0xFF || img -> tileRows > 0xFF || img -> planeWidth - hdr -> tileWidth * ( img -> tileCols - 1 ) < 0x16 || img -> planeHeight - hdr -> tileHeight * ( img -> tileRows - 1 ) < 0x16 ) return - 1 ; img -> tiles = 0 ; img -> levels = hdr -> imageLevels ; img -> subbandCount = 3 * img -> levels + 1 ; img -> nPlanes = hdr -> nPlanes ; img -> nBits = hdr -> nBits ; img -> encType = hdr -> encType ; img -> samplePrecision = hdr -> nBits + IncrBitTable [ 4 * hdr -> encType + 2 ] + 1 ; img -> mdatOffset = mdatOffset + hdr -> mdatHdrSize ; img -> mdatSize = mdatSize ; img -> planeBuf = 0 ; img -> outBufs [ 0 ] = img -> outBufs [ 1 ] = img -> outBufs [ 2 ] = img -> outBufs [ 3 ] = 0 ; if ( img -> encType == 3 && img -> nPlanes == 4 && img -> nBits > 8 ) { img -> planeBuf = ( int16_t * ) malloc ( img -> planeHeight * img -> planeWidth * img -> nPlanes * ( ( img -> samplePrecision + 7 ) > > 3 ) ) ; if ( ! img -> planeBuf ) return - 1 ; } int32_t rowSize = 2 * img -> planeWidth ; if ( img -> nPlanes == 1 ) img -> outBufs [ 0 ] = outBuf ; else switch ( hdr -> cfaLayout ) { case 0 : img -> outBufs [ 0 ] = outBuf ; img -> outBufs [ 1 ] = outBuf + 1 ; img -> outBufs [ 2 ] = outBuf + rowSize ; img -> outBufs [ 3 ] = img -> outBufs [ 2 ] + 1 ; break ; case 1 : img -> outBufs [ 1 ] = outBuf ; img -> outBufs [ 0 ] = outBuf + 1 ; img -> outBufs [ 3 ] = outBuf + rowSize ; img -> outBufs [ 2 ] = img -> outBufs [ 3 ] + 1 ; break ; case 2 : img -> outBufs [ 2 ] = outBuf ; img -> outBufs [ 3 ] = outBuf + 1 ; img -> outBufs [ 0 ] = outBuf + rowSize ; img -> outBufs [ 1 ] = img -> outBufs [ 0 ] + 1 ; break ; case 3 : img -> outBufs [ 3 ] = outBuf ; img -> outBufs [ 2 ] = outBuf + 1 ; img -> outBufs [ 1 ] = outBuf + rowSize ; img -> outBufs [ 0 ] = img -> outBufs [ 1 ] + 1 ; break ; } return crxReadImageHeaders ( hdr , img , mdatHdrPtr , mdatSize ) ; }
win_redr_status ( win_T * wp , int ignore_pum UNUSED ) { int row ; char_u * p ; int len ; int fillchar ; int attr ; int this_ru_col ; static int busy = FALSE ; if ( busy ) return ; busy = TRUE ; row = statusline_row ( wp ) ; wp -> w_redr_status = FALSE ; if ( wp -> w_status_height == 0 ) { redraw_cmdline = TRUE ; } else if ( ! redrawing ( ) || ( ! ignore_pum && pum_visible ( ) ) ) { wp -> w_redr_status = TRUE ; } #ifdef FEAT_STL_OPT else if ( * p_stl != NUL || * wp -> w_p_stl != NUL ) { redraw_custom_statusline ( wp ) ; } #endif else { fillchar = fillchar_status ( & attr , wp ) ; get_trans_bufname ( wp -> w_buffer ) ; p = NameBuff ; len = ( int ) STRLEN ( p ) ; if ( bt_help ( wp -> w_buffer ) #ifdef FEAT_QUICKFIX || wp -> w_p_pvw #endif || bufIsChanged ( wp -> w_buffer ) || wp -> w_buffer -> b_p_ro ) * ( p + len ++ ) = ' ' ; if ( bt_help ( wp -> w_buffer ) ) { vim_snprintf ( ( char * ) p + len , MAXPATHL - len , "%s" , _ ( "[Help]" ) ) ; len += ( int ) STRLEN ( p + len ) ; } #ifdef FEAT_QUICKFIX if ( wp -> w_p_pvw ) { vim_snprintf ( ( char * ) p + len , MAXPATHL - len , "%s" , _ ( "[Preview]" ) ) ; len += ( int ) STRLEN ( p + len ) ; } #endif if ( bufIsChanged ( wp -> w_buffer ) #ifdef FEAT_TERMINAL && ! bt_terminal ( wp -> w_buffer ) #endif ) { vim_snprintf ( ( char * ) p + len , MAXPATHL - len , "%s" , "[+]" ) ; len += ( int ) STRLEN ( p + len ) ; } if ( wp -> w_buffer -> b_p_ro ) { vim_snprintf ( ( char * ) p + len , MAXPATHL - len , "%s" , _ ( "[RO]" ) ) ; len += ( int ) STRLEN ( p + len ) ; } this_ru_col = ru_col - ( Columns - wp -> w_width ) ; if ( this_ru_col < ( wp -> w_width + 1 ) / 2 ) this_ru_col = ( wp -> w_width + 1 ) / 2 ; if ( this_ru_col <= 1 ) { p = ( char_u * ) "<" ; len = 1 ; } else if ( has_mbyte ) { int clen = 0 , i ; clen = mb_string2cells ( p , - 1 ) ; for ( i = 0 ; p [ i ] != NUL && clen >= this_ru_col - 1 ; i += ( * mb_ptr2len ) ( p + i ) ) clen -= ( * mb_ptr2cells ) ( p + i ) ; len = clen ; if ( i > 0 ) { p = p + i - 1 ; * p = '<' ; ++ len ; } } else if ( len > this_ru_col - 1 ) { p += len - ( this_ru_col - 1 ) ; * p = '<' ; len = this_ru_col - 1 ; } screen_puts ( p , row , wp -> w_wincol , attr ) ; screen_fill ( row , row + 1 , len + wp -> w_wincol , this_ru_col + wp -> w_wincol , fillchar , fillchar , attr ) ; if ( get_keymap_str ( wp , ( char_u * ) "<%s>" , NameBuff , MAXPATHL ) && ( int ) ( this_ru_col - len ) > ( int ) ( STRLEN ( NameBuff ) + 1 ) ) screen_puts ( NameBuff , row , ( int ) ( this_ru_col - STRLEN ( NameBuff ) - 1 + wp -> w_wincol ) , attr ) ; #ifdef FEAT_CMDL_INFO win_redr_ruler ( wp , TRUE , ignore_pum ) ; #endif } if ( wp -> w_vsep_width != 0 && wp -> w_status_height != 0 && redrawing ( ) ) { if ( stl_connected ( wp ) ) fillchar = fillchar_status ( & attr , wp ) ; else fillchar = fillchar_vsep ( & attr ) ; screen_putchar ( fillchar , row , W_ENDCOL ( wp ) , attr ) ; } busy = FALSE ; }
const char * StringsStorage :: GetVFormatted ( const char * format , va_list args ) { Vector < char > str = Vector < char > :: New ( 1024 ) ; int len = VSNPrintF ( str , format , args ) ; if ( len == - 1 ) { DeleteArray ( str . start ( ) ) ; return GetCopy ( format ) ; } return AddOrDisposeString ( str . start ( ) , len ) ; }
OpenDatabaseHelper :: CreateDatabaseConnection ( nsIFile * aDBFile , nsIFile * aFMDirectory , const nsAString & aName , const nsACString & aOrigin , mozIStorageConnection * * aConnection ) { NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread!" ) ; NS_ASSERTION ( IndexedDatabaseManager :: IsMainProcess ( ) , "Wrong process!" ) ; PROFILER_LABEL ( "IndexedDB" , "OpenDatabaseHelper::CreateDatabaseConnection" ) ; nsresult rv ; bool exists ; if ( IndexedDatabaseManager :: InLowDiskSpaceMode ( ) ) { rv = aDBFile -> Exists ( & exists ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! exists ) { NS_WARNING ( "Refusing to create database because disk space is low!" ) ; return NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR ; } } nsCOMPtr < nsIFileURL > dbFileUrl = IDBFactory :: GetDatabaseFileURL ( aDBFile , aOrigin ) ; NS_ENSURE_TRUE ( dbFileUrl , NS_ERROR_FAILURE ) ; nsCOMPtr < mozIStorageService > ss = do_GetService ( MOZ_STORAGE_SERVICE_CONTRACTID ) ; NS_ENSURE_TRUE ( ss , NS_ERROR_FAILURE ) ; nsCOMPtr < mozIStorageConnection > connection ; rv = ss -> OpenDatabaseWithFileURL ( dbFileUrl , getter_AddRefs ( connection ) ) ; if ( rv == NS_ERROR_FILE_CORRUPTED ) { if ( aName . IsVoid ( ) ) { return rv ; } rv = aDBFile -> Remove ( false ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aFMDirectory -> Exists ( & exists ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( exists ) { bool isDirectory ; rv = aFMDirectory -> IsDirectory ( & isDirectory ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; NS_ENSURE_TRUE ( isDirectory , NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ) ; rv = aFMDirectory -> Remove ( true ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } rv = ss -> OpenDatabaseWithFileURL ( dbFileUrl , getter_AddRefs ( connection ) ) ; } NS_ENSURE_SUCCESS ( rv , rv ) ; rv = IDBFactory :: SetDefaultPragmas ( connection ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = connection -> EnableModule ( NS_LITERAL_CSTRING ( "filesystem" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; int32_t schemaVersion ; rv = connection -> GetSchemaVersion ( & schemaVersion ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! schemaVersion && aName . IsVoid ( ) ) { NS_WARNING ( "Unable to open IndexedDB database, schema is not set!" ) ; return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ; } if ( schemaVersion > kSQLiteSchemaVersion ) { NS_WARNING ( "Unable to open IndexedDB database, schema is too high!" ) ; return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ; } bool vacuumNeeded = false ; if ( schemaVersion != kSQLiteSchemaVersion ) { #if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GONK) if ( ! schemaVersion ) { rv = connection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( "PRAGMA auto_vacuum = FULL; " ) ) ; NS_ENSURE_SUCCESS ( rv , NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ) ; } #endif mozStorageTransaction transaction ( connection , false , mozIStorageConnection :: TRANSACTION_IMMEDIATE ) ; if ( ! schemaVersion ) { rv = CreateTables ( connection ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; NS_ASSERTION ( NS_SUCCEEDED ( connection -> GetSchemaVersion ( & schemaVersion ) ) && schemaVersion == kSQLiteSchemaVersion , "CreateTables set a bad schema version!" ) ; nsCOMPtr < mozIStorageStatement > stmt ; nsresult rv = connection -> CreateStatement ( NS_LITERAL_CSTRING ( "INSERT INTO database (name) " "VALUES (:name)" ) , getter_AddRefs ( stmt ) ) ; NS_ENSURE_SUCCESS ( rv , NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ) ; rv = stmt -> BindStringByName ( NS_LITERAL_CSTRING ( "name" ) , aName ) ; NS_ENSURE_SUCCESS ( rv , NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ) ; rv = stmt -> Execute ( ) ; NS_ENSURE_SUCCESS ( rv , NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ) ; } else { MOZ_STATIC_ASSERT ( kSQLiteSchemaVersion == int32_t ( ( 14 < < 4 ) + 0 ) , "Need upgrade code from schema version increase." ) ; while ( schemaVersion != kSQLiteSchemaVersion ) { if ( schemaVersion == 4 ) { rv = UpgradeSchemaFrom4To5 ( connection ) ; } else if ( schemaVersion == 5 ) { rv = UpgradeSchemaFrom5To6 ( connection ) ; } else if ( schemaVersion == 6 ) { rv = UpgradeSchemaFrom6To7 ( connection ) ; } else if ( schemaVersion == 7 ) { rv = UpgradeSchemaFrom7To8 ( connection ) ; } else if ( schemaVersion == 8 ) { rv = UpgradeSchemaFrom8To9_0 ( connection ) ; vacuumNeeded = true ; } else if ( schemaVersion == MakeSchemaVersion ( 9 , 0 ) ) { rv = UpgradeSchemaFrom9_0To10_0 ( connection ) ; } else if ( schemaVersion == MakeSchemaVersion ( 10 , 0 ) ) { rv = UpgradeSchemaFrom10_0To11_0 ( connection ) ; } else if ( schemaVersion == MakeSchemaVersion ( 11 , 0 ) ) { rv = UpgradeSchemaFrom11_0To12_0 ( connection ) ; } else if ( schemaVersion == MakeSchemaVersion ( 12 , 0 ) ) { rv = UpgradeSchemaFrom12_0To13_0 ( connection , & vacuumNeeded ) ; } else if ( schemaVersion == MakeSchemaVersion ( 13 , 0 ) ) { rv = UpgradeSchemaFrom13_0To14_0 ( connection ) ; } else { NS_WARNING ( "Unable to open IndexedDB database, no upgrade path is " "available!" ) ; return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ; } NS_ENSURE_SUCCESS ( rv , rv ) ; rv = connection -> GetSchemaVersion ( & schemaVersion ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } NS_ASSERTION ( schemaVersion == kSQLiteSchemaVersion , "Huh?!" ) ; } rv = transaction . Commit ( ) ; if ( rv == NS_ERROR_FILE_NO_DEVICE_SPACE ) { rv = NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR ; } NS_ENSURE_SUCCESS ( rv , rv ) ; } if ( vacuumNeeded ) { rv = connection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( "VACUUM;" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } connection . forget ( aConnection ) ; return NS_OK ; }
static pyc_object * get_object ( RBuffer * buffer ) { bool error = false ; pyc_object * ret = NULL ; ut8 code = get_ut8 ( buffer , & error ) ; ut8 flag = code & FLAG_REF ; RListIter * ref_idx = NULL ; ut8 type = code & ~ FLAG_REF ; if ( error ) { return NULL ; } if ( flag ) { ret = get_none_object ( ) ; if ( ! ret ) { return NULL ; } ref_idx = r_list_append ( refs , ret ) ; if ( ! ref_idx ) { free_object ( ret ) ; return NULL ; } } switch ( type ) { case TYPE_NULL : free_object ( ret ) ; return NULL ; case TYPE_TRUE : free_object ( ret ) ; return get_true_object ( ) ; case TYPE_FALSE : free_object ( ret ) ; return get_false_object ( ) ; case TYPE_NONE : free_object ( ret ) ; return get_none_object ( ) ; case TYPE_REF : free_object ( ret ) ; return get_ref_object ( buffer ) ; case TYPE_SMALL_TUPLE : ret = get_small_tuple_object ( buffer ) ; break ; case TYPE_TUPLE : ret = get_tuple_object ( buffer ) ; break ; case TYPE_STRING : ret = get_string_object ( buffer ) ; break ; case TYPE_CODE_v0 : ret = get_code_object ( buffer ) ; if ( ret ) { ret -> type = TYPE_CODE_v0 ; } break ; case TYPE_CODE_v1 : ret = get_code_object ( buffer ) ; if ( ret ) { ret -> type = TYPE_CODE_v1 ; } break ; case TYPE_INT : ret = get_int_object ( buffer ) ; break ; case TYPE_ASCII_INTERNED : ret = get_ascii_interned_object ( buffer ) ; break ; case TYPE_SHORT_ASCII : ret = get_short_ascii_object ( buffer ) ; break ; case TYPE_ASCII : ret = get_ascii_object ( buffer ) ; break ; case TYPE_SHORT_ASCII_INTERNED : ret = get_short_ascii_interned_object ( buffer ) ; break ; case TYPE_INT64 : ret = get_int64_object ( buffer ) ; break ; case TYPE_INTERNED : ret = get_interned_object ( buffer ) ; break ; case TYPE_STRINGREF : ret = get_stringref_object ( buffer ) ; break ; case TYPE_FLOAT : ret = get_float_object ( buffer ) ; break ; case TYPE_BINARY_FLOAT : ret = get_binary_float_object ( buffer ) ; break ; case TYPE_COMPLEX : ret = get_complex_object ( buffer ) ; break ; case TYPE_BINARY_COMPLEX : ret = get_binary_complex_object ( buffer ) ; break ; case TYPE_LIST : ret = get_list_object ( buffer ) ; break ; case TYPE_LONG : ret = get_long_object ( buffer ) ; break ; case TYPE_UNICODE : ret = get_unicode_object ( buffer ) ; break ; case TYPE_DICT : ret = get_dict_object ( buffer ) ; break ; case TYPE_FROZENSET : case TYPE_SET : ret = get_set_object ( buffer ) ; break ; case TYPE_STOPITER : case TYPE_ELLIPSIS : ret = R_NEW0 ( pyc_object ) ; break ; case TYPE_UNKNOWN : eprintf ( "Get not implemented for type 0x%x\n" , type ) ; free_object ( ret ) ; return NULL ; case 0 : break ; default : eprintf ( "Undefined type in get_object (0x%x)\n" , type ) ; free_object ( ret ) ; return NULL ; } if ( flag && ref_idx ) { free_object ( ref_idx -> data ) ; ref_idx -> data = copy_object ( ret ) ; } return ret ; }
xmlTextWriterWriteDocCallback ( void * context , const xmlChar * str , int len ) { xmlParserCtxtPtr ctxt = ( xmlParserCtxtPtr ) context ; int rc ; if ( ( rc = xmlParseChunk ( ctxt , ( const char * ) str , len , 0 ) ) != 0 ) { xmlWriterErrMsgInt ( NULL , XML_ERR_INTERNAL_ERROR , "xmlTextWriterWriteDocCallback : XML error %d !\n" , rc ) ; return - 1 ; } return len ; }
string LogHandler :: stderrToFile ( const string & pathPrefix ) { time_t rawtime ; struct tm * timeinfo ; char buffer [ 80 ] ; time ( & rawtime ) ; timeinfo = localtime ( & rawtime ) ; strftime ( buffer , sizeof ( buffer ) , "%Y-%m-%d_%I-%M" , timeinfo ) ; string current_time ( buffer ) ; string stderrFilename = pathPrefix + "_stderr_" + current_time ; FILE * stderr_stream = freopen ( stderrFilename . c_str ( ) , "w" , stderr ) ; if ( ! stderr_stream ) { STFATAL < < "Invalid filename " < < stderrFilename ; } setvbuf ( stderr_stream , NULL , _IOLBF , BUFSIZ ) ; return stderrFilename ; }
static void read_intra_frame_mode_info ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int mi_row , int mi_col , vp9_reader * r ) { MODE_INFO * const mi = xd -> mi [ 0 ] ; MB_MODE_INFO * const mbmi = & mi -> mbmi ; const MODE_INFO * above_mi = xd -> mi [ - cm -> mi_stride ] ; const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; const BLOCK_SIZE bsize = mbmi -> sb_type ; int i ; mbmi -> segment_id = read_intra_segment_id ( cm , xd , mi_row , mi_col , r ) ; mbmi -> skip = read_skip ( cm , xd , mbmi -> segment_id , r ) ; mbmi -> tx_size = read_tx_size ( cm , xd , cm -> tx_mode , bsize , 1 , r ) ; mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; mbmi -> ref_frame [ 1 ] = NONE ; switch ( bsize ) { case BLOCK_4X4 : for ( i = 0 ; i < 4 ; ++ i ) mi -> bmi [ i ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , i ) ) ; mbmi -> mode = mi -> bmi [ 3 ] . as_mode ; break ; case BLOCK_4X8 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 2 ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; mi -> bmi [ 1 ] . as_mode = mi -> bmi [ 3 ] . as_mode = mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 1 ) ) ; break ; case BLOCK_8X4 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 1 ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; mi -> bmi [ 2 ] . as_mode = mi -> bmi [ 3 ] . as_mode = mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 2 ) ) ; break ; default : mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; } mbmi -> uv_mode = read_intra_mode ( r , vp9_kf_uv_mode_prob [ mbmi -> mode ] ) ; }
static ssize_t environ_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { char * page ; unsigned long src = * ppos ; int ret = 0 ; struct mm_struct * mm = file -> private_data ; unsigned long env_start , env_end ; if ( ! mm ) return 0 ; page = ( char * ) __get_free_page ( GFP_TEMPORARY ) ; if ( ! page ) return - ENOMEM ; ret = 0 ; if ( ! atomic_inc_not_zero ( & mm -> mm_users ) ) goto free ; down_read ( & mm -> mmap_sem ) ; env_start = mm -> env_start ; env_end = mm -> env_end ; up_read ( & mm -> mmap_sem ) ; while ( count > 0 ) { size_t this_len , max_len ; int retval ; if ( src >= ( env_end - env_start ) ) break ; this_len = env_end - ( env_start + src ) ; max_len = min_t ( size_t , PAGE_SIZE , count ) ; this_len = min ( max_len , this_len ) ; retval = access_remote_vm ( mm , ( env_start + src ) , page , this_len , 0 ) ; if ( retval <= 0 ) { ret = retval ; break ; } if ( copy_to_user ( buf , page , retval ) ) { ret = - EFAULT ; break ; } ret += retval ; src += retval ; buf += retval ; count -= retval ; } * ppos = src ; mmput ( mm ) ; free : free_page ( ( unsigned long ) page ) ; return ret ; }
jbig2_image_compose ( Jbig2Ctx * ctx , Jbig2Image * dst , Jbig2Image * src , int x , int y , Jbig2ComposeOp op ) { uint32_t w , h ; uint32_t shift ; uint32_t leftbyte ; uint8_t * ss ; uint8_t * dd ; uint8_t leftmask , rightmask ; int early = x >= 0 ; int late ; uint32_t bytewidth ; uint32_t syoffset = 0 ; if ( src == NULL ) return 0 ; w = src -> width ; h = src -> height ; shift = ( x & 7 ) ; ss = src -> data - early ; if ( x < 0 ) { if ( w < ( uint32_t ) - x ) w = 0 ; else w += x ; ss += ( - x - 1 ) > > 3 ; x = 0 ; } if ( y < 0 ) { if ( h < ( uint32_t ) - y ) h = 0 ; else h += y ; syoffset = - y * src -> stride ; y = 0 ; } if ( ( uint32_t ) x + w > dst -> width ) { if ( dst -> width < ( uint32_t ) x ) w = 0 ; else w = dst -> width - x ; } if ( ( uint32_t ) y + h > dst -> height ) { if ( dst -> height < ( uint32_t ) y ) h = 0 ; else h = dst -> height - y ; } #ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , "compositing %dx%d at (%d, %d) after clipping" , w , h , x , y ) ; #endif if ( ( w <= 0 ) || ( h <= 0 ) ) { #ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , "zero clipping region" ) ; #endif return 0 ; } leftbyte = ( uint32_t ) x > > 3 ; dd = dst -> data + y * dst -> stride + leftbyte ; bytewidth = ( ( ( uint32_t ) x + w - 1 ) > > 3 ) - leftbyte + 1 ; leftmask = 255 > > ( x & 7 ) ; rightmask = ( ( ( x + w ) & 7 ) == 0 ) ? 255 : ~ ( 255 > > ( ( x + w ) & 7 ) ) ; if ( bytewidth == 1 ) leftmask &= rightmask ; late = ( ss + bytewidth >= src -> data + ( ( src -> width + 7 ) > > 3 ) ) ; ss += syoffset ; switch ( op ) { case JBIG2_COMPOSE_OR : jbig2_image_compose_opt_OR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_AND : jbig2_image_compose_opt_AND ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_XOR : jbig2_image_compose_opt_XOR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_XNOR : jbig2_image_compose_opt_XNOR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_REPLACE : jbig2_image_compose_opt_REPLACE ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; } return 0 ; }
frontend :: CompileFunctionBody ( JSContext * cx , JSFunction * fun , JSPrincipals * principals , Bindings * bindings , const jschar * chars , size_t length , const char * filename , uintN lineno , JSVersion version ) { Parser parser ( cx , principals ) ; if ( ! parser . init ( chars , length , filename , lineno , version ) ) return false ; TokenStream & tokenStream = parser . tokenStream ; BytecodeEmitter funbce ( & parser , tokenStream . getLineno ( ) ) ; if ( ! funbce . init ( cx , TreeContext :: USED_AS_TREE_CONTEXT ) ) return false ; funbce . flags |= TCF_IN_FUNCTION ; funbce . setFunction ( fun ) ; funbce . bindings . transfer ( cx , bindings ) ; fun -> setArgCount ( funbce . bindings . countArgs ( ) ) ; if ( ! GenerateBlockId ( & funbce , funbce . bodyid ) ) return false ; ParseNode * fn = FunctionNode :: create ( PNK_NAME , & funbce ) ; if ( fn ) { fn -> pn_body = NULL ; fn -> pn_cookie . makeFree ( ) ; uintN nargs = fun -> nargs ; if ( nargs ) { Vector < JSAtom * > names ( cx ) ; if ( ! funbce . bindings . getLocalNameArray ( cx , & names ) ) { fn = NULL ; } else { for ( uintN i = 0 ; i < nargs ; i ++ ) { if ( ! DefineArg ( fn , names [ i ] , i , & funbce ) ) { fn = NULL ; break ; } } } } } ParseNode * pn = fn ? parser . functionBody ( Parser :: StatementListBody ) : NULL ; if ( pn ) { if ( ! CheckStrictParameters ( cx , & funbce ) ) { pn = NULL ; } else if ( ! tokenStream . matchToken ( TOK_EOF ) ) { parser . reportErrorNumber ( NULL , JSREPORT_ERROR , JSMSG_SYNTAX_ERROR ) ; pn = NULL ; } else if ( ! FoldConstants ( cx , pn , & funbce ) ) { pn = NULL ; } else if ( ! AnalyzeFunctions ( & funbce ) ) { pn = NULL ; } else { if ( fn -> pn_body ) { JS_ASSERT ( fn -> pn_body -> isKind ( PNK_ARGSBODY ) ) ; fn -> pn_body -> append ( pn ) ; fn -> pn_body -> pn_pos = pn -> pn_pos ; pn = fn -> pn_body ; } if ( ! EmitFunctionScript ( cx , & funbce , pn ) ) pn = NULL ; } } return pn != NULL ; }
Node * EffectControlLinearizer :: LowerStringFromSingleCharCode ( Node * node ) { Node * value = node -> InputAt ( 0 ) ; Node * code = __ Word32And ( value , __ Uint32Constant ( 0xFFFF ) ) ; auto if_not_one_byte = __ MakeDeferredLabel ( ) ; auto cache_miss = __ MakeDeferredLabel ( ) ; auto done = __ MakeLabel ( MachineRepresentation :: kTagged ) ; Node * check1 = __ Uint32LessThanOrEqual ( code , __ Uint32Constant ( String :: kMaxOneByteCharCode ) ) ; __ GotoIfNot ( check1 , & if_not_one_byte ) ; { Node * cache = __ HeapConstant ( factory ( ) -> single_character_string_cache ( ) ) ; Node * index = machine ( ) -> Is32 ( ) ? code : __ ChangeUint32ToUint64 ( code ) ; Node * entry = __ LoadElement ( AccessBuilder :: ForFixedArrayElement ( ) , cache , index ) ; Node * check2 = __ WordEqual ( entry , __ UndefinedConstant ( ) ) ; __ GotoIf ( check2 , & cache_miss ) ; __ Goto ( & done , entry ) ; __ Bind ( & cache_miss ) ; { Node * vtrue2 = __ Allocate ( NOT_TENURED , __ Int32Constant ( SeqOneByteString :: SizeFor ( 1 ) ) ) ; __ StoreField ( AccessBuilder :: ForMap ( ) , vtrue2 , __ HeapConstant ( factory ( ) -> one_byte_string_map ( ) ) ) ; __ StoreField ( AccessBuilder :: ForNameHashField ( ) , vtrue2 , __ IntPtrConstant ( Name :: kEmptyHashField ) ) ; __ StoreField ( AccessBuilder :: ForStringLength ( ) , vtrue2 , __ SmiConstant ( 1 ) ) ; __ Store ( StoreRepresentation ( MachineRepresentation :: kWord8 , kNoWriteBarrier ) , vtrue2 , __ IntPtrConstant ( SeqOneByteString :: kHeaderSize - kHeapObjectTag ) , code ) ; __ StoreElement ( AccessBuilder :: ForFixedArrayElement ( ) , cache , index , vtrue2 ) ; __ Goto ( & done , vtrue2 ) ; } } __ Bind ( & if_not_one_byte ) ; { Node * vfalse1 = __ Allocate ( NOT_TENURED , __ Int32Constant ( SeqTwoByteString :: SizeFor ( 1 ) ) ) ; __ StoreField ( AccessBuilder :: ForMap ( ) , vfalse1 , __ HeapConstant ( factory ( ) -> string_map ( ) ) ) ; __ StoreField ( AccessBuilder :: ForNameHashField ( ) , vfalse1 , __ IntPtrConstant ( Name :: kEmptyHashField ) ) ; __ StoreField ( AccessBuilder :: ForStringLength ( ) , vfalse1 , __ SmiConstant ( 1 ) ) ; __ Store ( StoreRepresentation ( MachineRepresentation :: kWord16 , kNoWriteBarrier ) , vfalse1 , __ IntPtrConstant ( SeqTwoByteString :: kHeaderSize - kHeapObjectTag ) , code ) ; __ Goto ( & done , vfalse1 ) ; } __ Bind ( & done ) ; return done . PhiAt ( 0 ) ; }
static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\n' ) ; if ( next_line ) { * next_line = '\0' ; next_line ++ ; if ( * next_line == '\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\0' ) goto out ; if ( ( extent . first == ( u32 ) - 1 ) || ( extent . lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent . first + extent . count ) <= extent . first ) goto out ; if ( ( extent . lower_first + extent . count ) <= extent . lower_first ) goto out ; if ( mappings_overlap ( & new_map , & extent ) ) goto out ; if ( ( new_map . nr_extents + 1 ) == UID_GID_MAP_MAX_EXTENTS && ( next_line != NULL ) ) goto out ; ret = insert_extent ( & new_map , & extent ) ; if ( ret < 0 ) goto out ; ret = - EINVAL ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ; if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) goto out ; ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ret = - EPERM ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { struct uid_gid_extent * e ; u32 lower_first ; if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) e = & new_map . extent [ idx ] ; else e = & new_map . forward [ idx ] ; lower_first = map_id_range_down ( parent_map , e -> lower_first , e -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; e -> lower_first = lower_first ; } if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; } else { map -> forward = new_map . forward ; map -> reverse = new_map . reverse ; } smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : if ( ret < 0 && new_map . nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS ) { kfree ( new_map . forward ) ; kfree ( new_map . reverse ) ; map -> forward = NULL ; map -> reverse = NULL ; map -> nr_extents = 0 ; } mutex_unlock ( & userns_state_mutex ) ; kfree ( kbuf ) ; return ret ; }
void Activate ( RefPtr < SourceListener > aListener , RefPtr < MediaDevice > aAudioDevice , RefPtr < LocalTrackSource > aAudioTrackSource , RefPtr < MediaDevice > aVideoDevice , RefPtr < LocalTrackSource > aVideoTrackSource ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; MOZ_ASSERT ( aListener ) ; MOZ_ASSERT ( ! aListener -> Activated ( ) ) ; MOZ_ASSERT ( mInactiveListeners . Contains ( aListener ) , "Must be registered to activate" ) ; MOZ_ASSERT ( ! mActiveListeners . Contains ( aListener ) , "Already activated" ) ; mInactiveListeners . RemoveElement ( aListener ) ; aListener -> Activate ( std :: move ( aAudioDevice ) , std :: move ( aAudioTrackSource ) , std :: move ( aVideoDevice ) , std :: move ( aVideoTrackSource ) , mCamerasAreMuted , mMicrophonesAreMuted ) ; mActiveListeners . AppendElement ( std :: move ( aListener ) ) ; }
void RegExpMacroAssemblerIA32 :: CallCheckStackGuardState ( Register scratch ) { static const int num_arguments = 3 ; __ PrepareCallCFunction ( num_arguments , scratch ) ; __ mov ( Operand ( esp , 2 * kPointerSize ) , ebp ) ; __ mov ( Operand ( esp , 1 * kPointerSize ) , Immediate ( masm_ -> CodeObject ( ) ) ) ; __ lea ( eax , Operand ( esp , - kPointerSize ) ) ; __ mov ( Operand ( esp , 0 * kPointerSize ) , eax ) ; ExternalReference check_stack_guard = ExternalReference :: re_check_stack_guard_state ( isolate ( ) ) ; __ CallCFunction ( check_stack_guard , num_arguments ) ; }
OMX_ERRORTYPE omx_video :: use_output_buffer ( OMX_IN OMX_HANDLETYPE hComp , OMX_INOUT OMX_BUFFERHEADERTYPE * * bufferHdr , OMX_IN OMX_U32 port , OMX_IN OMX_PTR appData , OMX_IN OMX_U32 bytes , OMX_IN OMX_U8 * buffer ) { ( void ) hComp , ( void ) port ; OMX_ERRORTYPE eRet = OMX_ErrorNone ; OMX_BUFFERHEADERTYPE * bufHdr = NULL ; unsigned i = 0 ; unsigned char * buf_addr = NULL ; #ifdef _MSM8974_ int align_size ; #endif DEBUG_PRINT_HIGH ( "Inside use_output_buffer()" ) ; if ( bytes != m_sOutPortDef . nBufferSize ) { DEBUG_PRINT_ERROR ( "ERROR: use_output_buffer: Size Mismatch!! " "bytes[%u] != Port.nBufferSize[%u]" , ( unsigned int ) bytes , ( unsigned int ) m_sOutPortDef . nBufferSize ) ; return OMX_ErrorBadParameter ; } if ( ! m_out_mem_ptr ) { output_use_buffer = true ; int nBufHdrSize = 0 ; DEBUG_PRINT_LOW ( "Allocating First Output Buffer(%u)" , ( unsigned int ) m_sOutPortDef . nBufferCountActual ) ; nBufHdrSize = m_sOutPortDef . nBufferCountActual * sizeof ( OMX_BUFFERHEADERTYPE ) ; m_out_mem_ptr = ( OMX_BUFFERHEADERTYPE * ) calloc ( nBufHdrSize , 1 ) ; if ( m_out_mem_ptr == NULL ) { DEBUG_PRINT_ERROR ( "ERROR: calloc() Failed for m_out_mem_ptr" ) ; return OMX_ErrorInsufficientResources ; } m_pOutput_pmem = ( struct pmem * ) calloc ( sizeof ( struct pmem ) , m_sOutPortDef . nBufferCountActual ) ; if ( m_pOutput_pmem == NULL ) { DEBUG_PRINT_ERROR ( "ERROR: calloc() Failed for m_pOutput_pmem" ) ; return OMX_ErrorInsufficientResources ; } #ifdef USE_ION m_pOutput_ion = ( struct venc_ion * ) calloc ( sizeof ( struct venc_ion ) , m_sOutPortDef . nBufferCountActual ) ; if ( m_pOutput_ion == NULL ) { DEBUG_PRINT_ERROR ( "ERROR: calloc() Failed for m_pOutput_ion" ) ; return OMX_ErrorInsufficientResources ; } #endif if ( m_out_mem_ptr ) { bufHdr = m_out_mem_ptr ; DEBUG_PRINT_LOW ( "Memory Allocation Succeeded for OUT port%p" , m_out_mem_ptr ) ; for ( i = 0 ; i < m_sOutPortDef . nBufferCountActual ; i ++ ) { bufHdr -> nSize = sizeof ( OMX_BUFFERHEADERTYPE ) ; bufHdr -> nVersion . nVersion = OMX_SPEC_VERSION ; bufHdr -> nAllocLen = bytes ; bufHdr -> nFilledLen = 0 ; bufHdr -> pAppPrivate = appData ; bufHdr -> nOutputPortIndex = PORT_INDEX_OUT ; bufHdr -> pBuffer = NULL ; bufHdr ++ ; m_pOutput_pmem [ i ] . fd = - 1 ; #ifdef USE_ION m_pOutput_ion [ i ] . ion_device_fd = - 1 ; m_pOutput_ion [ i ] . fd_ion_data . fd = - 1 ; m_pOutput_ion [ i ] . ion_alloc_data . handle = 0 ; #endif } } else { DEBUG_PRINT_ERROR ( "ERROR: Output buf mem alloc failed[0x%p]" , m_out_mem_ptr ) ; eRet = OMX_ErrorInsufficientResources ; } } for ( i = 0 ; i < m_sOutPortDef . nBufferCountActual ; i ++ ) { if ( BITMASK_ABSENT ( & m_out_bm_count , i ) ) { break ; } } if ( eRet == OMX_ErrorNone ) { if ( i < m_sOutPortDef . nBufferCountActual ) { * bufferHdr = ( m_out_mem_ptr + i ) ; ( * bufferHdr ) -> pBuffer = ( OMX_U8 * ) buffer ; ( * bufferHdr ) -> pAppPrivate = appData ; if ( ! m_use_output_pmem ) { #ifdef USE_ION #ifdef _MSM8974_ align_size = ( m_sOutPortDef . nBufferSize + ( SZ_4K - 1 ) ) & ~ ( SZ_4K - 1 ) ; m_pOutput_ion [ i ] . ion_device_fd = alloc_map_ion_memory ( align_size , & m_pOutput_ion [ i ] . ion_alloc_data , & m_pOutput_ion [ i ] . fd_ion_data , 0 ) ; #else m_pOutput_ion [ i ] . ion_device_fd = alloc_map_ion_memory ( m_sOutPortDef . nBufferSize , & m_pOutput_ion [ i ] . ion_alloc_data , & m_pOutput_ion [ i ] . fd_ion_data , ION_FLAG_CACHED ) ; #endif if ( m_pOutput_ion [ i ] . ion_device_fd < 0 ) { DEBUG_PRINT_ERROR ( "ERROR:ION device open() Failed" ) ; return OMX_ErrorInsufficientResources ; } m_pOutput_pmem [ i ] . fd = m_pOutput_ion [ i ] . fd_ion_data . fd ; #else m_pOutput_pmem [ i ] . fd = open ( MEM_DEVICE , O_RDWR ) ; if ( m_pOutput_pmem [ i ] . fd == 0 ) { m_pOutput_pmem [ i ] . fd = open ( MEM_DEVICE , O_RDWR ) ; } if ( m_pOutput_pmem [ i ] . fd < 0 ) { DEBUG_PRINT_ERROR ( "ERROR: /dev/pmem_adsp open() Failed" ) ; return OMX_ErrorInsufficientResources ; } #endif m_pOutput_pmem [ i ] . size = m_sOutPortDef . nBufferSize ; m_pOutput_pmem [ i ] . offset = 0 ; m_pOutput_pmem [ i ] . buffer = ( OMX_U8 * ) SECURE_BUFPTR ; if ( ! secure_session ) { #ifdef _MSM8974_ m_pOutput_pmem [ i ] . buffer = ( unsigned char * ) mmap ( NULL , align_size , PROT_READ | PROT_WRITE , MAP_SHARED , m_pOutput_pmem [ i ] . fd , 0 ) ; #else m_pOutput_pmem [ i ] . buffer = ( unsigned char * ) mmap ( NULL , m_pOutput_pmem [ i ] . size , PROT_READ | PROT_WRITE , MAP_SHARED , m_pOutput_pmem [ i ] . fd , 0 ) ; #endif if ( m_pOutput_pmem [ i ] . buffer == MAP_FAILED ) { DEBUG_PRINT_ERROR ( "ERROR: mmap() Failed" ) ; close ( m_pOutput_pmem [ i ] . fd ) ; #ifdef USE_ION free_ion_memory ( & m_pOutput_ion [ i ] ) ; #endif return OMX_ErrorInsufficientResources ; } } } else { OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO * pParam = reinterpret_cast < OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO * > ( ( * bufferHdr ) -> pAppPrivate ) ; DEBUG_PRINT_LOW ( "Inside qcom_ext pParam: %p" , pParam ) ; if ( pParam ) { DEBUG_PRINT_LOW ( "Inside qcom_ext with luma:(fd:%lu,offset:0x%x)" , pParam -> pmem_fd , ( int ) pParam -> offset ) ; m_pOutput_pmem [ i ] . fd = pParam -> pmem_fd ; m_pOutput_pmem [ i ] . offset = pParam -> offset ; m_pOutput_pmem [ i ] . size = m_sOutPortDef . nBufferSize ; m_pOutput_pmem [ i ] . buffer = ( unsigned char * ) buffer ; } else { DEBUG_PRINT_ERROR ( "ERROR: Invalid AppData given for PMEM o/p UseBuffer case" ) ; return OMX_ErrorBadParameter ; } buf_addr = ( unsigned char * ) buffer ; } DEBUG_PRINT_LOW ( "use_out:: bufhdr = %p, pBuffer = %p, m_pOutput_pmem[i].buffer = %p" , ( * bufferHdr ) , ( * bufferHdr ) -> pBuffer , m_pOutput_pmem [ i ] . buffer ) ; if ( dev_use_buf ( & m_pOutput_pmem [ i ] , PORT_INDEX_OUT , i ) != true ) { DEBUG_PRINT_ERROR ( "ERROR: dev_use_buf Failed for o/p buf" ) ; return OMX_ErrorInsufficientResources ; } BITMASK_SET ( & m_out_bm_count , i ) ; } else { DEBUG_PRINT_ERROR ( "ERROR: All o/p Buffers have been Used, invalid use_buf call for " "index = %u" , i ) ; eRet = OMX_ErrorInsufficientResources ; } } return eRet ; }
static void fix_interp_filter ( VP9_COMMON * cm ) { if ( cm -> interp_filter == SWITCHABLE ) { int count [ SWITCHABLE_FILTERS ] ; int i , j , c = 0 ; for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { count [ i ] = 0 ; for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j ) count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ; c += ( count [ i ] > 0 ) ; } if ( c == 1 ) { for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { if ( count [ i ] ) { cm -> interp_filter = i ; break ; } } } } }
Handle < Symbol > Factory :: NewPrivateFieldSymbol ( ) { Handle < Symbol > symbol = NewSymbol ( ) ; symbol -> set_is_private_field ( ) ; return symbol ; }
MessagePumpForNonMainThreads :: Run ( base :: MessagePump :: Delegate * aDelegate ) { MOZ_ASSERT ( keep_running_ ) ; MOZ_ASSERT ( ! NS_IsMainThread ( ) , "Use mozilla::ipc::MessagePump instead!" ) ; mThread = NS_GetCurrentThread ( ) ; MOZ_ASSERT ( mThread ) ; mDelayedWorkTimer = do_CreateInstance ( kNS_TIMER_CID ) ; MOZ_ASSERT ( mDelayedWorkTimer ) ; if ( NS_FAILED ( mDelayedWorkTimer -> SetTarget ( mThread ) ) ) { MOZ_CRASH ( "Failed to set timer target!" ) ; } while ( aDelegate -> DoWork ( ) ) { } base :: ScopedNSAutoreleasePool autoReleasePool ; for ( ; ; ) { autoReleasePool . Recycle ( ) ; bool didWork = NS_ProcessNextEvent ( mThread , false ) ? true : false ; if ( ! keep_running_ ) { break ; } didWork |= aDelegate -> DoDelayedWork ( & delayed_work_time_ ) ; if ( didWork && delayed_work_time_ . is_null ( ) ) { mDelayedWorkTimer -> Cancel ( ) ; } if ( ! keep_running_ ) { break ; } if ( didWork ) { continue ; } didWork = aDelegate -> DoIdleWork ( ) ; if ( ! keep_running_ ) { break ; } if ( didWork ) { continue ; } NS_ProcessNextEvent ( mThread , true ) ; } mDelayedWorkTimer -> Cancel ( ) ; keep_running_ = true ; }
void RegExpMacroAssemblerS390 :: CallCFunctionUsingStub ( ExternalReference function , int num_arguments ) { DCHECK_GE ( 8 , num_arguments ) ; __ mov ( code_pointer ( ) , Operand ( function ) ) ; Label ret ; __ larl ( r14 , & ret ) ; __ StoreP ( r14 , MemOperand ( sp , kStackFrameRASlot * kPointerSize ) ) ; __ b ( code_pointer ( ) ) ; __ bind ( & ret ) ; if ( base :: OS :: ActivationFrameAlignment ( ) > kPointerSize ) { __ LoadP ( sp , MemOperand ( sp , ( kNumRequiredStackFrameSlots * kPointerSize ) ) ) ; } else { __ la ( sp , MemOperand ( sp , ( kNumRequiredStackFrameSlots * kPointerSize ) ) ) ; } __ mov ( code_pointer ( ) , Operand ( masm_ -> CodeObject ( ) ) ) ; }
void BytecodeGraphBuilder :: VisitLdaGlobal ( ) { PrepareEagerCheckpoint ( ) ; Handle < Name > name ( Name :: cast ( bytecode_iterator ( ) . GetConstantForIndexOperand ( 0 ) ) , isolate ( ) ) ; uint32_t feedback_slot_index = bytecode_iterator ( ) . GetIndexOperand ( 1 ) ; Node * node = BuildLoadGlobal ( name , feedback_slot_index , TypeofMode :: NOT_INSIDE_TYPEOF ) ; environment ( ) -> BindAccumulator ( node , Environment :: kAttachFrameState ) ; }
Node * EffectControlLinearizer :: LowerCheckedInt32Mod ( Node * node , Node * frame_state ) { Node * lhs = node -> InputAt ( 0 ) ; Node * rhs = node -> InputAt ( 1 ) ; auto if_rhs_not_positive = __ MakeDeferredLabel ( ) ; auto if_lhs_negative = __ MakeDeferredLabel ( ) ; auto if_rhs_power_of_two = __ MakeLabel ( ) ; auto rhs_checked = __ MakeLabel ( MachineRepresentation :: kWord32 ) ; auto done = __ MakeLabel ( MachineRepresentation :: kWord32 ) ; Node * zero = __ Int32Constant ( 0 ) ; Node * check0 = __ Int32LessThanOrEqual ( rhs , zero ) ; __ GotoIf ( check0 , & if_rhs_not_positive ) ; __ Goto ( & rhs_checked , rhs ) ; __ Bind ( & if_rhs_not_positive ) ; { Node * vtrue0 = __ Int32Sub ( zero , rhs ) ; __ DeoptimizeIf ( DeoptimizeReason :: kDivisionByZero , VectorSlotPair ( ) , __ Word32Equal ( vtrue0 , zero ) , frame_state ) ; __ Goto ( & rhs_checked , vtrue0 ) ; } __ Bind ( & rhs_checked ) ; rhs = rhs_checked . PhiAt ( 0 ) ; __ GotoIf ( __ Int32LessThan ( lhs , zero ) , & if_lhs_negative ) ; { __ Goto ( & done , BuildUint32Mod ( lhs , rhs ) ) ; } __ Bind ( & if_lhs_negative ) ; { Node * res = BuildUint32Mod ( __ Int32Sub ( zero , lhs ) , rhs ) ; __ DeoptimizeIf ( DeoptimizeReason :: kMinusZero , VectorSlotPair ( ) , __ Word32Equal ( res , zero ) , frame_state ) ; __ Goto ( & done , __ Int32Sub ( zero , res ) ) ; } __ Bind ( & done ) ; return done . PhiAt ( 0 ) ; }
Chunk FindChunk ( size_t position ) { while ( V8_UNLIKELY ( chunks_ . empty ( ) ) ) FetchChunk ( size_t { 0 } ) ; while ( position >= chunks_ . back ( ) . end_position ( ) && chunks_ . back ( ) . length > 0 ) { FetchChunk ( chunks_ . back ( ) . end_position ( ) ) ; } for ( auto reverse_it = chunks_ . rbegin ( ) ; reverse_it != chunks_ . rend ( ) ; ++ reverse_it ) { if ( reverse_it -> position <= position ) return * reverse_it ; } UNREACHABLE ( ) ; }
Status KeyStoreService :: onUserPasswordChanged ( int32_t userId , const String16 & password , int32_t * aidl_return ) { if ( ! checkBinderPermission ( P_PASSWORD ) ) { * aidl_return = static_cast < int32_t > ( ResponseCode :: PERMISSION_DENIED ) ; return Status :: ok ( ) ; } const String8 password8 ( password ) ; mAuthTokenTable . Clear ( ) ; if ( password . size ( ) == 0 ) { ALOGI ( "Secure lockscreen for user %d removed, deleting encrypted entries" , userId ) ; mKeyStore -> resetUser ( userId , true ) ; * aidl_return = static_cast < int32_t > ( ResponseCode :: NO_ERROR ) ; return Status :: ok ( ) ; } else { switch ( mKeyStore -> getState ( userId ) ) { case :: STATE_UNINITIALIZED : { * aidl_return = static_cast < int32_t > ( mKeyStore -> initializeUser ( password8 , userId ) ) ; return Status :: ok ( ) ; } case :: STATE_NO_ERROR : { * aidl_return = static_cast < int32_t > ( mKeyStore -> writeMasterKey ( password8 , userId ) ) ; return Status :: ok ( ) ; } case :: STATE_LOCKED : { ALOGE ( "Changing user %d's password while locked, clearing old encryption" , userId ) ; mKeyStore -> resetUser ( userId , true ) ; * aidl_return = static_cast < int32_t > ( mKeyStore -> initializeUser ( password8 , userId ) ) ; return Status :: ok ( ) ; } } * aidl_return = static_cast < int32_t > ( ResponseCode :: SYSTEM_ERROR ) ; return Status :: ok ( ) ; } }
static void ax25_kill_by_device ( struct net_device * dev ) { ax25_dev * ax25_dev ; ax25_cb * s ; if ( ( ax25_dev = ax25_dev_ax25dev ( dev ) ) == NULL ) return ; spin_lock_bh ( & ax25_list_lock ) ; again : ax25_for_each ( s , & ax25_list ) { if ( s -> ax25_dev == ax25_dev ) { spin_unlock_bh ( & ax25_list_lock ) ; lock_sock ( s -> sk ) ; s -> ax25_dev = NULL ; release_sock ( s -> sk ) ; ax25_disconnect ( s , ENETUNREACH ) ; spin_lock_bh ( & ax25_list_lock ) ; goto again ; } } spin_unlock_bh ( & ax25_list_lock ) ; }
static void AddNumber64 ( v8 :: Isolate * isolate , v8 :: Local < v8 :: Object > object , int64_t value , const char * name ) { object -> Set ( isolate -> GetCurrentContext ( ) , v8 :: String :: NewFromUtf8 ( isolate , name , NewStringType :: kNormal ) . ToLocalChecked ( ) , v8 :: Number :: New ( isolate , static_cast < double > ( value ) ) ) . FromJust ( ) ; }
bool Code :: setAndBorrowTier2 ( UniqueCodeTier tier2 , const LinkData & linkData , const CodeTier * * borrowedTier ) const { MOZ_RELEASE_ASSERT ( ! hasTier2 ( ) ) ; MOZ_RELEASE_ASSERT ( tier2 -> tier ( ) == Tier :: Optimized && tier1_ -> tier ( ) == Tier :: Baseline ) ; if ( ! tier2 -> initialize ( IsTier2 :: Tier2 , * this , linkData , * metadata_ ) ) { return false ; } tier2_ = std :: move ( tier2 ) ; * borrowedTier = & * tier2_ ; return true ; }
VideoTrack :: VideoTrack ( unsigned int * seed ) : Track ( seed ) , display_height_ ( 0 ) , display_width_ ( 0 ) , frame_rate_ ( 0.0 ) , height_ ( 0 ) , stereo_mode_ ( 0 ) , alpha_mode_ ( 0 ) , width_ ( 0 ) { }
void DecodePngV2 ( OpKernelContext * context , StringPiece input ) { int channel_bits = ( data_type_ == DataType :: DT_UINT8 ) ? 8 : 16 ; png :: DecodeContext decode ; OP_REQUIRES ( context , png :: CommonInitDecode ( input , channels_ , channel_bits , & decode ) , errors :: InvalidArgument ( "Invalid PNG. Failed to initialize decoder." ) ) ; const int width = static_cast < int > ( decode . width ) ; const int height = static_cast < int > ( decode . height ) ; const int64_t total_size = static_cast < int64_t > ( width ) * static_cast < int64_t > ( height ) ; if ( width != static_cast < int64_t > ( decode . width ) || width <= 0 || width >= ( 1LL < < 27 ) || height != static_cast < int64_t > ( decode . height ) || height <= 0 || height >= ( 1LL < < 27 ) || total_size >= ( 1LL < < 29 ) ) { png :: CommonFreeDecode ( & decode ) ; OP_REQUIRES ( context , false , errors :: InvalidArgument ( "PNG size too large for int: " , decode . width , " by " , decode . height ) ) ; } Tensor * output = nullptr ; Status status ; if ( op_type_ == "DecodeGif" ) { status = context -> allocate_output ( 0 , TensorShape ( { 1 , height , width , decode . channels } ) , & output ) ; } else { status = context -> allocate_output ( 0 , TensorShape ( { height , width , decode . channels } ) , & output ) ; } if ( op_type_ == "DecodeBmp" ) { OP_REQUIRES ( context , false , errors :: InvalidArgument ( "Trying to decode PNG format using DecodeBmp op. Use " "`decode_png` or `decode_image` instead." ) ) ; } else if ( op_type_ == "DecodeAndCropJpeg" ) { OP_REQUIRES ( context , false , errors :: InvalidArgument ( "DecodeAndCropJpeg operation can run on JPEG only, but " "detected PNG." ) ) ; } if ( ! status . ok ( ) ) png :: CommonFreeDecode ( & decode ) ; OP_REQUIRES_OK ( context , status ) ; if ( data_type_ == DataType :: DT_UINT8 ) { OP_REQUIRES ( context , png :: CommonFinishDecode ( reinterpret_cast < png_bytep > ( output -> flat < uint8 > ( ) . data ( ) ) , decode . channels * width * sizeof ( uint8 ) , & decode ) , errors :: InvalidArgument ( "Invalid PNG data, size " , input . size ( ) ) ) ; } else if ( data_type_ == DataType :: DT_UINT16 ) { OP_REQUIRES ( context , png :: CommonFinishDecode ( reinterpret_cast < png_bytep > ( output -> flat < uint16 > ( ) . data ( ) ) , decode . channels * width * sizeof ( uint16 ) , & decode ) , errors :: InvalidArgument ( "Invalid PNG data, size " , input . size ( ) ) ) ; } else if ( data_type_ == DataType :: DT_FLOAT ) { std :: unique_ptr < uint16 [ ] > buffer ( new uint16 [ height * width * decode . channels ] ) ; OP_REQUIRES ( context , png :: CommonFinishDecode ( reinterpret_cast < png_bytep > ( buffer . get ( ) ) , decode . channels * width * sizeof ( uint16 ) , & decode ) , errors :: InvalidArgument ( "Invalid PNG data, size " , input . size ( ) ) ) ; const auto & device = context -> eigen_device < Eigen :: ThreadPoolDevice > ( ) ; TTypes < uint16 , 3 > :: UnalignedConstTensor buf ( buffer . get ( ) , height , width , decode . channels ) ; float scale = 1. / std :: numeric_limits < uint16 > :: max ( ) ; output -> tensor < float , 3 > ( ) . device ( device ) = buf . cast < float > ( ) * scale ; } }
OI_STATUS OI_CODEC_SBC_DecodeFrame ( OI_CODEC_SBC_DECODER_CONTEXT * context , const OI_BYTE * * frameData , uint32_t * frameBytes , int16_t * pcmData , uint32_t * pcmBytes ) { OI_STATUS status ; OI_UINT framelen ; uint8_t crc ; TRACE ( ( "+OI_CODEC_SBC_DecodeFrame" ) ) ; TRACE ( ( "Finding syncword" ) ) ; status = FindSyncword ( context , frameData , frameBytes ) ; if ( ! OI_SUCCESS ( status ) ) { return status ; } if ( * frameBytes < SBC_HEADER_LEN ) { TRACE ( ( "-OI_CODEC_SBC_DecodeFrame: OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA" ) ) ; return OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA ; } TRACE ( ( "Reading Header" ) ) ; OI_SBC_ReadHeader ( & context -> common , * frameData ) ; if ( context -> limitFrameFormat && ( context -> common . frameInfo . subbands != context -> restrictSubbands ) ) { ERROR ( ( "SBC parameters incompatible with loaded overlay" ) ) ; return OI_STATUS_INVALID_PARAMETERS ; } if ( context -> common . frameInfo . nrof_channels > context -> common . maxChannels ) { ERROR ( ( "SBC parameters incompatible with number of channels specified during " "reset" ) ) ; return OI_STATUS_INVALID_PARAMETERS ; } if ( context -> common . pcmStride < 1 || context -> common . pcmStride > 2 ) { ERROR ( ( "PCM stride not set correctly during reset" ) ) ; return OI_STATUS_INVALID_PARAMETERS ; } framelen = OI_CODEC_SBC_CalculateFramelen ( & context -> common . frameInfo ) ; if ( * frameBytes < framelen ) { TRACE ( ( "-OI_CODEC_SBC_DecodeFrame: OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA" ) ) ; return OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA ; } TRACE ( ( "Calculating checksum" ) ) ; crc = OI_SBC_CalculateChecksum ( & context -> common . frameInfo , * frameData ) ; if ( crc != context -> common . frameInfo . crc ) { TRACE ( ( "CRC Mismatch:  calc=%02x read=%02x\n" , crc , context -> common . frameInfo . crc ) ) ; TRACE ( ( "-OI_CODEC_SBC_DecodeFrame: OI_CODEC_SBC_CHECKSUM_MISMATCH" ) ) ; return OI_CODEC_SBC_CHECKSUM_MISMATCH ; } #ifdef OI_DEBUG if ( ( context -> common . frameInfo . bitpool < SBC_MIN_BITPOOL ) && ! context -> common . frameInfo . enhanced ) { ERROR ( ( "Bitpool too small: %d (must be >= 2)" , context -> common . frameInfo . bitpool ) ) ; return OI_STATUS_INVALID_PARAMETERS ; } if ( context -> common . frameInfo . bitpool > OI_SBC_MaxBitpool ( & context -> common . frameInfo ) ) { ERROR ( ( "Bitpool too large: %d (must be <= %ld)" , context -> common . frameInfo . bitpool , OI_SBC_MaxBitpool ( & context -> common . frameInfo ) ) ) ; return OI_STATUS_INVALID_PARAMETERS ; } #endif status = DecodeBody ( context , * frameData + SBC_HEADER_LEN , pcmData , pcmBytes , FALSE ) ; if ( OI_SUCCESS ( status ) ) { * frameData += framelen ; * frameBytes -= framelen ; } TRACE ( ( "-OI_CODEC_SBC_DecodeFrame: %d" , status ) ) ; return status ; }
static void Generate_JSEntryTrampolineHelper ( MacroAssembler * masm , bool is_construct ) { ProfileEntryHookStub :: MaybeCallEntryHook ( masm ) ; { FrameScope scope ( masm , StackFrame :: INTERNAL ) ; ExternalReference context_address = ExternalReference :: Create ( IsolateAddressId :: kContextAddress , masm -> isolate ( ) ) ; __ mov ( esi , __ StaticVariable ( context_address ) ) ; __ mov ( ebx , Operand ( ebp , 0 ) ) ; __ push ( Operand ( ebx , EntryFrameConstants :: kFunctionArgOffset ) ) ; __ push ( Operand ( ebx , EntryFrameConstants :: kReceiverArgOffset ) ) ; __ mov ( eax , Operand ( ebx , EntryFrameConstants :: kArgcOffset ) ) ; __ mov ( ebx , Operand ( ebx , EntryFrameConstants :: kArgvOffset ) ) ; Label enough_stack_space , stack_overflow ; Generate_StackOverflowCheck ( masm , eax , ecx , edx , & stack_overflow ) ; __ jmp ( & enough_stack_space ) ; __ bind ( & stack_overflow ) ; __ CallRuntime ( Runtime :: kThrowStackOverflow ) ; __ int3 ( ) ; __ bind ( & enough_stack_space ) ; Label loop , entry ; __ Move ( ecx , Immediate ( 0 ) ) ; __ jmp ( & entry , Label :: kNear ) ; __ bind ( & loop ) ; __ mov ( edx , Operand ( ebx , ecx , times_4 , 0 ) ) ; __ push ( Operand ( edx , 0 ) ) ; __ inc ( ecx ) ; __ bind ( & entry ) ; __ cmp ( ecx , eax ) ; __ j ( not_equal , & loop ) ; __ mov ( ebx , Operand ( ebp , 0 ) ) ; __ mov ( edx , Operand ( ebx , EntryFrameConstants :: kNewTargetArgOffset ) ) ; __ mov ( edi , Operand ( ebx , EntryFrameConstants :: kFunctionArgOffset ) ) ; Handle < Code > builtin = is_construct ? BUILTIN_CODE ( masm -> isolate ( ) , Construct ) : masm -> isolate ( ) -> builtins ( ) -> Call ( ) ; __ Call ( builtin , RelocInfo :: CODE_TARGET ) ; } __ ret ( 0 ) ; }
MediaDecodeTask ( const char * aContentType , uint8_t * aBuffer , uint32_t aLength , WebAudioDecodeJob & aDecodeJob ) : mContentType ( aContentType ) , mBuffer ( aBuffer ) , mLength ( aLength ) , mDecodeJob ( aDecodeJob ) , mPhase ( PhaseEnum :: Decode ) { MOZ_ASSERT ( aBuffer ) ; MOZ_ASSERT ( NS_IsMainThread ( ) ) ; }
nsSelectionState :: IsCollapsed ( ) { if ( 1 != mArray . Length ( ) ) return false ; nsRefPtr < nsRange > range ; mArray [ 0 ] . GetRange ( getter_AddRefs ( range ) ) ; NS_ENSURE_TRUE ( range , false ) ; bool bIsCollapsed = false ; range -> GetCollapsed ( & bIsCollapsed ) ; return bIsCollapsed ; }
void MetaData :: typed_data :: clear ( ) { freeStorage ( ) ; mType = 0 ; }
ThrowExceptionObject ( JSContext * aCx , Exception * aException ) { JS :: Rooted < JS :: Value > thrown ( aCx ) ; if ( NS_IsMainThread ( ) && ! nsContentUtils :: IsCallerChrome ( ) && aException -> StealJSVal ( thrown . address ( ) ) ) { if ( thrown . isNumber ( ) ) { nsresult exceptionResult ; if ( NS_SUCCEEDED ( aException -> GetResult ( & exceptionResult ) ) && double ( exceptionResult ) == thrown . toNumber ( ) ) { Throw ( aCx , exceptionResult ) ; return true ; } } if ( ! JS_WrapValue ( aCx , & thrown ) ) { return false ; } JS_SetPendingException ( aCx , thrown ) ; return true ; } JS :: Rooted < JSObject * > glob ( aCx , JS :: CurrentGlobalOrNull ( aCx ) ) ; if ( ! glob ) { return false ; } if ( ! GetOrCreateDOMReflector ( aCx , aException , & thrown ) ) { return false ; } JS_SetPendingException ( aCx , thrown ) ; return true ; }
nsFrameMessageManager :: Dump ( const nsAString & aStr ) { #ifdef ANDROID __android_log_print ( ANDROID_LOG_INFO , "Gecko" , NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) ) ; #endif fputs ( NS_ConvertUTF16toUTF8 ( aStr ) . get ( ) , stdout ) ; fflush ( stdout ) ; return NS_OK ; }
int64_t LineBasedFrameDecoder :: findEndOfLine ( IOBufQueue & buf ) { Cursor c ( buf . front ( ) ) ; for ( uint32_t i = 0 ; i < maxLength_ && i < buf . chainLength ( ) ; i ++ ) { auto b = c . read < char > ( ) ; if ( b == '\n' && terminatorType_ != TerminatorType :: CARRIAGENEWLINE ) { return i ; } else if ( terminatorType_ != TerminatorType :: NEWLINE && b == '\r' && ! c . isAtEnd ( ) && c . read < char > ( ) == '\n' ) { return i ; } } return - 1 ; }
PixarLogDecode ( TIFF * tif , uint8 * op , tmsize_t occ , uint16 s ) { static const char module [ ] = "PixarLogDecode" ; TIFFDirectory * td = & tif -> tif_dir ; PixarLogState * sp = DecoderState ( tif ) ; tmsize_t i ; tmsize_t nsamples ; int llen ; uint16 * up ; switch ( sp -> user_datafmt ) { case PIXARLOGDATAFMT_FLOAT : nsamples = occ / sizeof ( float ) ; break ; case PIXARLOGDATAFMT_16BIT : case PIXARLOGDATAFMT_12BITPICIO : case PIXARLOGDATAFMT_11BITLOG : nsamples = occ / sizeof ( uint16 ) ; break ; case PIXARLOGDATAFMT_8BIT : case PIXARLOGDATAFMT_8BITABGR : nsamples = occ ; break ; default : TIFFErrorExt ( tif -> tif_clientdata , module , "%d bit input not supported in PixarLog" , td -> td_bitspersample ) ; return 0 ; } llen = sp -> stride * td -> td_imagewidth ; ( void ) s ; assert ( sp != NULL ) ; sp -> stream . next_out = ( unsigned char * ) sp -> tbuf ; assert ( sizeof ( sp -> stream . avail_out ) == 4 ) ; sp -> stream . avail_out = ( uInt ) ( nsamples * sizeof ( uint16 ) ) ; if ( sp -> stream . avail_out != nsamples * sizeof ( uint16 ) ) { TIFFErrorExt ( tif -> tif_clientdata , module , "ZLib cannot deal with buffers this size" ) ; return ( 0 ) ; } do { int state = inflate ( & sp -> stream , Z_PARTIAL_FLUSH ) ; if ( state == Z_STREAM_END ) { break ; } if ( state == Z_DATA_ERROR ) { TIFFErrorExt ( tif -> tif_clientdata , module , "Decoding error at scanline %lu, %s" , ( unsigned long ) tif -> tif_row , sp -> stream . msg ? sp -> stream . msg : "(null)" ) ; if ( inflateSync ( & sp -> stream ) != Z_OK ) return ( 0 ) ; continue ; } if ( state != Z_OK ) { TIFFErrorExt ( tif -> tif_clientdata , module , "ZLib error: %s" , sp -> stream . msg ? sp -> stream . msg : "(null)" ) ; return ( 0 ) ; } } while ( sp -> stream . avail_out > 0 ) ; if ( sp -> stream . avail_out != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , module , "Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)" , ( unsigned long ) tif -> tif_row , ( TIFF_UINT64_T ) sp -> stream . avail_out ) ; return ( 0 ) ; } up = sp -> tbuf ; if ( tif -> tif_flags & TIFF_SWAB ) TIFFSwabArrayOfShort ( up , nsamples ) ; if ( nsamples % llen ) { TIFFWarningExt ( tif -> tif_clientdata , module , "stride %lu is not a multiple of sample count, " "%lu, data truncated." , ( unsigned long ) llen , ( unsigned long ) nsamples ) ; nsamples -= nsamples % llen ; } for ( i = 0 ; i < nsamples ; i += llen , up += llen ) { switch ( sp -> user_datafmt ) { case PIXARLOGDATAFMT_FLOAT : horizontalAccumulateF ( up , llen , sp -> stride , ( float * ) op , sp -> ToLinearF ) ; op += llen * sizeof ( float ) ; break ; case PIXARLOGDATAFMT_16BIT : horizontalAccumulate16 ( up , llen , sp -> stride , ( uint16 * ) op , sp -> ToLinear16 ) ; op += llen * sizeof ( uint16 ) ; break ; case PIXARLOGDATAFMT_12BITPICIO : horizontalAccumulate12 ( up , llen , sp -> stride , ( int16 * ) op , sp -> ToLinearF ) ; op += llen * sizeof ( int16 ) ; break ; case PIXARLOGDATAFMT_11BITLOG : horizontalAccumulate11 ( up , llen , sp -> stride , ( uint16 * ) op ) ; op += llen * sizeof ( uint16 ) ; break ; case PIXARLOGDATAFMT_8BIT : horizontalAccumulate8 ( up , llen , sp -> stride , ( unsigned char * ) op , sp -> ToLinear8 ) ; op += llen * sizeof ( unsigned char ) ; break ; case PIXARLOGDATAFMT_8BITABGR : horizontalAccumulate8abgr ( up , llen , sp -> stride , ( unsigned char * ) op , sp -> ToLinear8 ) ; op += llen * sizeof ( unsigned char ) ; break ; default : TIFFErrorExt ( tif -> tif_clientdata , module , "Unsupported bits/sample: %d" , td -> td_bitspersample ) ; return ( 0 ) ; } } return ( 1 ) ; }
xmlParse3986Port ( xmlURIPtr uri , const char * * str ) { const char * cur = * str ; unsigned port = 0 ; if ( ISA_DIGIT ( cur ) ) { while ( ISA_DIGIT ( cur ) ) { port = port * 10 + ( * cur - '0' ) ; cur ++ ; } if ( uri != NULL ) uri -> port = port & INT_MAX ; * str = cur ; return ( 0 ) ; } return ( 1 ) ; }
static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { PicContext * s = avctx -> priv_data ; AVFrame * frame = data ; uint32_t * palette ; int bits_per_plane , bpp , etype , esize , npal , pos_after_pal ; int i , x , y , plane , tmp , ret , val ; bytestream2_init ( & s -> g , avpkt -> data , avpkt -> size ) ; if ( bytestream2_get_bytes_left ( & s -> g ) < 11 ) return AVERROR_INVALIDDATA ; if ( bytestream2_get_le16u ( & s -> g ) != 0x1234 ) return AVERROR_INVALIDDATA ; s -> width = bytestream2_get_le16u ( & s -> g ) ; s -> height = bytestream2_get_le16u ( & s -> g ) ; bytestream2_skip ( & s -> g , 4 ) ; tmp = bytestream2_get_byteu ( & s -> g ) ; bits_per_plane = tmp & 0xF ; s -> nb_planes = ( tmp > > 4 ) + 1 ; bpp = bits_per_plane * s -> nb_planes ; if ( bits_per_plane > 8 || bpp < 1 || bpp > 32 ) { avpriv_request_sample ( avctx , "Unsupported bit depth" ) ; return AVERROR_PATCHWELCOME ; } if ( bytestream2_peek_byte ( & s -> g ) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8 ) { bytestream2_skip ( & s -> g , 2 ) ; etype = bytestream2_get_le16 ( & s -> g ) ; esize = bytestream2_get_le16 ( & s -> g ) ; if ( bytestream2_get_bytes_left ( & s -> g ) < esize ) return AVERROR_INVALIDDATA ; } else { etype = - 1 ; esize = 0 ; } avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; if ( av_image_check_size ( s -> width , s -> height , 0 , avctx ) < 0 ) return - 1 ; if ( s -> width != avctx -> width && s -> height != avctx -> height ) { ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ; if ( ret < 0 ) return ret ; } if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; memset ( frame -> data [ 0 ] , 0 , s -> height * frame -> linesize [ 0 ] ) ; frame -> pict_type = AV_PICTURE_TYPE_I ; frame -> palette_has_changed = 1 ; pos_after_pal = bytestream2_tell ( & s -> g ) + esize ; palette = ( uint32_t * ) frame -> data [ 1 ] ; if ( etype == 1 && esize > 1 && bytestream2_peek_byte ( & s -> g ) < 6 ) { int idx = bytestream2_get_byte ( & s -> g ) ; npal = 4 ; for ( i = 0 ; i < npal ; i ++ ) palette [ i ] = ff_cga_palette [ cga_mode45_index [ idx ] [ i ] ] ; } else if ( etype == 2 ) { npal = FFMIN ( esize , 16 ) ; for ( i = 0 ; i < npal ; i ++ ) { int pal_idx = bytestream2_get_byte ( & s -> g ) ; palette [ i ] = ff_cga_palette [ FFMIN ( pal_idx , 15 ) ] ; } } else if ( etype == 3 ) { npal = FFMIN ( esize , 16 ) ; for ( i = 0 ; i < npal ; i ++ ) { int pal_idx = bytestream2_get_byte ( & s -> g ) ; palette [ i ] = ff_ega_palette [ FFMIN ( pal_idx , 63 ) ] ; } } else if ( etype == 4 || etype == 5 ) { npal = FFMIN ( esize / 3 , 256 ) ; for ( i = 0 ; i < npal ; i ++ ) { palette [ i ] = bytestream2_get_be24 ( & s -> g ) < < 2 ; palette [ i ] |= 0xFFU < < 24 | palette [ i ] > > 6 & 0x30303 ; } } else { if ( bpp == 1 ) { npal = 2 ; palette [ 0 ] = 0xFF000000 ; palette [ 1 ] = 0xFFFFFFFF ; } else if ( bpp == 2 ) { npal = 4 ; for ( i = 0 ; i < npal ; i ++ ) palette [ i ] = ff_cga_palette [ cga_mode45_index [ 0 ] [ i ] ] ; } else { npal = 16 ; memcpy ( palette , ff_cga_palette , npal * 4 ) ; } } memset ( palette + npal , 0 , AVPALETTE_SIZE - npal * 4 ) ; bytestream2_seek ( & s -> g , pos_after_pal , SEEK_SET ) ; val = 0 ; y = s -> height - 1 ; if ( bytestream2_get_le16 ( & s -> g ) ) { x = 0 ; plane = 0 ; while ( bytestream2_get_bytes_left ( & s -> g ) >= 6 ) { int stop_size , marker , t1 , t2 ; t1 = bytestream2_get_bytes_left ( & s -> g ) ; t2 = bytestream2_get_le16 ( & s -> g ) ; stop_size = t1 - FFMIN ( t1 , t2 ) ; bytestream2_skip ( & s -> g , 2 ) ; marker = bytestream2_get_byte ( & s -> g ) ; while ( plane < s -> nb_planes && bytestream2_get_bytes_left ( & s -> g ) > stop_size ) { int run = 1 ; val = bytestream2_get_byte ( & s -> g ) ; if ( val == marker ) { run = bytestream2_get_byte ( & s -> g ) ; if ( run == 0 ) run = bytestream2_get_le16 ( & s -> g ) ; val = bytestream2_get_byte ( & s -> g ) ; } if ( ! bytestream2_get_bytes_left ( & s -> g ) ) break ; if ( bits_per_plane == 8 ) { picmemset_8bpp ( s , frame , val , run , & x , & y ) ; if ( y < 0 ) goto finish ; } else { picmemset ( s , frame , val , run , & x , & y , & plane , bits_per_plane ) ; } } } if ( x < avctx -> width ) { int run = ( y + 1 ) * avctx -> width - x ; if ( bits_per_plane == 8 ) picmemset_8bpp ( s , frame , val , run , & x , & y ) ; else picmemset ( s , frame , val , run / ( 8 / bits_per_plane ) , & x , & y , & plane , bits_per_plane ) ; } } else { while ( y >= 0 && bytestream2_get_bytes_left ( & s -> g ) > 0 ) { memcpy ( frame -> data [ 0 ] + y * frame -> linesize [ 0 ] , s -> g . buffer , FFMIN ( avctx -> width , bytestream2_get_bytes_left ( & s -> g ) ) ) ; bytestream2_skip ( & s -> g , avctx -> width ) ; y -- ; } } finish : * got_frame = 1 ; return avpkt -> size ; }
void Display :: startAuth ( const QString & user , const QString & password , const Session & session ) { m_passPhrase = password ; if ( ! session . isValid ( ) ) { qCritical ( ) < < "Invalid session" < < session . fileName ( ) ; return ; } if ( session . xdgSessionType ( ) . isEmpty ( ) ) { qCritical ( ) < < "Failed to find XDG session type for session" < < session . fileName ( ) ; return ; } if ( session . exec ( ) . isEmpty ( ) ) { qCritical ( ) < < "Failed to find command for session" < < session . fileName ( ) ; return ; } QString existingSessionId ; if ( Logind :: isAvailable ( ) && mainConfig . Users . ReuseSession . get ( ) ) { OrgFreedesktopLogin1ManagerInterface manager ( Logind :: serviceName ( ) , Logind :: managerPath ( ) , QDBusConnection :: systemBus ( ) ) ; auto reply = manager . ListSessions ( ) ; reply . waitForFinished ( ) ; foreach ( const SessionInfo & s , reply . value ( ) ) { if ( s . userName == user ) { OrgFreedesktopLogin1SessionInterface session ( Logind :: serviceName ( ) , s . sessionPath . path ( ) , QDBusConnection :: systemBus ( ) ) ; if ( session . service ( ) == QLatin1String ( "sddm" ) ) { existingSessionId = s . sessionId ; break ; } } } } m_lastSession = session ; m_sessionName = session . fileName ( ) ; qDebug ( ) < < "Session" < < m_sessionName < < "selected, command:" < < session . exec ( ) ; int vt = terminalId ( ) ; if ( session . xdgSessionType ( ) == QLatin1String ( "wayland" ) ) vt = VirtualTerminal :: setUpNewVt ( ) ; m_lastSession . setVt ( vt ) ; QProcessEnvironment env ; env . insert ( QStringLiteral ( "PATH" ) , mainConfig . Users . DefaultPath . get ( ) ) ; if ( session . xdgSessionType ( ) == QLatin1String ( "x11" ) ) env . insert ( QStringLiteral ( "DISPLAY" ) , name ( ) ) ; env . insert ( QStringLiteral ( "XDG_SEAT_PATH" ) , daemonApp -> displayManager ( ) -> seatPath ( seat ( ) -> name ( ) ) ) ; env . insert ( QStringLiteral ( "XDG_SESSION_PATH" ) , daemonApp -> displayManager ( ) -> sessionPath ( QStringLiteral ( "Session%1" ) . arg ( daemonApp -> newSessionId ( ) ) ) ) ; env . insert ( QStringLiteral ( "DESKTOP_SESSION" ) , session . desktopSession ( ) ) ; env . insert ( QStringLiteral ( "XDG_CURRENT_DESKTOP" ) , session . desktopNames ( ) ) ; env . insert ( QStringLiteral ( "XDG_SESSION_CLASS" ) , QStringLiteral ( "user" ) ) ; env . insert ( QStringLiteral ( "XDG_SESSION_TYPE" ) , session . xdgSessionType ( ) ) ; env . insert ( QStringLiteral ( "XDG_SEAT" ) , seat ( ) -> name ( ) ) ; env . insert ( QStringLiteral ( "XDG_SESSION_DESKTOP" ) , session . desktopNames ( ) ) ; if ( seat ( ) -> name ( ) == QLatin1String ( "seat0" ) ) { env . insert ( QStringLiteral ( "XDG_VTNR" ) , QString :: number ( vt ) ) ; } m_auth -> insertEnvironment ( env ) ; m_auth -> setUser ( user ) ; if ( existingSessionId . isNull ( ) ) { m_auth -> setSession ( session . exec ( ) ) ; } else { connect ( m_auth , & Auth :: authentication , this , [ = ] ( ) { qDebug ( ) < < "activating existing seat" ; OrgFreedesktopLogin1ManagerInterface manager ( Logind :: serviceName ( ) , Logind :: managerPath ( ) , QDBusConnection :: systemBus ( ) ) ; manager . UnlockSession ( existingSessionId ) ; manager . ActivateSession ( existingSessionId ) ; } ) ; } m_auth -> start ( ) ; }
. SetShapeFn ( [ ] ( InferenceContext * c ) { int axis ; TF_RETURN_IF_ERROR ( c -> GetAttr ( "axis" , & axis ) ) ; const int minmax_rank = ( axis == - 1 ) ? 0 : 1 ; ShapeHandle minmax ; TF_RETURN_IF_ERROR ( c -> WithRank ( c -> input ( 1 ) , minmax_rank , & minmax ) ) ; TF_RETURN_IF_ERROR ( c -> Merge ( c -> input ( 2 ) , minmax , & minmax ) ) ; if ( axis != - 1 ) { ShapeHandle input ; TF_RETURN_IF_ERROR ( c -> WithRankAtLeast ( c -> input ( 0 ) , axis + 1 , & input ) ) ; DimensionHandle depth ; TF_RETURN_IF_ERROR ( c -> Merge ( c -> Dim ( minmax , 0 ) , c -> Dim ( input , axis ) , & depth ) ) ; } ShapeHandle unused ; TF_RETURN_IF_ERROR ( c -> WithRank ( c -> input ( 3 ) , 0 , & unused ) ) ; c -> set_output ( 0 , c -> input ( 0 ) ) ; return Status :: OK ( ) ; } ) ;
Assembler :: as_bl ( Label * l , Condition c ) { if ( m_buffer . oom ( ) ) { BufferOffset ret ; return ret ; } m_buffer . markNextAsBranch ( ) ; if ( l -> bound ( ) ) { BufferOffset ret = as_nop ( ) ; as_bl ( BufferOffset ( l ) . diffB < BOffImm > ( ret ) , c , ret ) ; return ret ; } int32_t old ; BufferOffset ret ; if ( l -> used ( ) ) { old = l -> offset ( ) ; if ( ! BOffImm :: isInRange ( old ) ) { m_buffer . bail ( ) ; return ret ; } ret = as_bl ( BOffImm ( old ) , c ) ; } else { old = LabelBase :: INVALID_OFFSET ; BOffImm inv ; ret = as_bl ( inv , c ) ; } DebugOnly < int32_t > check = l -> use ( ret . getOffset ( ) ) ; JS_ASSERT ( check == old ) ; return ret ; }
fb_mmap ( struct file * file , struct vm_area_struct * vma ) { struct fb_info * info = file_fb_info ( file ) ; struct fb_ops * fb ; unsigned long off ; unsigned long start ; u32 len ; if ( ! info ) return - ENODEV ; if ( vma -> vm_pgoff > ( ~ 0UL > > PAGE_SHIFT ) ) return - EINVAL ; off = vma -> vm_pgoff < < PAGE_SHIFT ; fb = info -> fbops ; if ( ! fb ) return - ENODEV ; mutex_lock ( & info -> mm_lock ) ; if ( fb -> fb_mmap ) { int res ; res = fb -> fb_mmap ( info , vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix . smem_start ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . smem_len ) ; if ( off >= len ) { off -= len ; if ( info -> var . accel_flags ) { mutex_unlock ( & info -> mm_lock ) ; return - EINVAL ; } start = info -> fix . mmio_start ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . mmio_len ) ; } mutex_unlock ( & info -> mm_lock ) ; start &= PAGE_MASK ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) return - EINVAL ; off += start ; vma -> vm_pgoff = off > > PAGE_SHIFT ; vma -> vm_page_prot = vm_get_page_prot ( vma -> vm_flags ) ; fb_pgprotect ( file , vma , off ) ; if ( io_remap_pfn_range ( vma , vma -> vm_start , off > > PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) return - EAGAIN ; return 0 ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteTensor * output_shape = GetInput ( context , node , kOutputShapeTensor ) ; const TfLiteTensor * weights = GetInput ( context , node , kWeightsTensor ) ; const TfLiteTensor * input = GetInput ( context , node , kDataInputTensor ) ; const TfLiteTensor * bias = ( NumInputs ( node ) == 4 ) ? GetOptionalInputTensor ( context , node , kBiasTensor ) : nullptr ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; TfLiteTensor * col2im = data -> has_col2im ? GetTemporary ( context , node , data -> col2im_index ) : nullptr ; TfLiteTensor * transposed_weights = data -> weights_are_transposed ? GetTemporary ( context , node , data -> transposed_weights_index ) : nullptr ; const auto * params = reinterpret_cast < TfLiteTransposeConvParams * > ( node -> builtin_data ) ; if ( IsDynamicTensor ( output ) ) { TF_LITE_ENSURE_OK ( context , ResizeTensor ( context , output_shape , output ) ) ; } if ( data -> has_col2im && IsDynamicTensor ( col2im ) ) { TF_LITE_ENSURE_OK ( context , ResizeCol2ImTensor ( context , output_shape , weights , input , col2im ) ) ; } const int width = SizeOfDimension ( output , 2 ) ; const int height = SizeOfDimension ( output , 1 ) ; const int filter_width = SizeOfDimension ( weights , 2 ) ; const int filter_height = SizeOfDimension ( weights , 1 ) ; int unused_output_height , unused_output_width ; data -> padding = ComputePaddingHeightWidth ( params -> stride_height , params -> stride_width , 1 , 1 , height , width , filter_height , filter_width , params -> padding , & unused_output_height , & unused_output_width ) ; switch ( input -> type ) { case kTfLiteFloat32 : { if ( data -> weights_are_transposed ) { if ( ! IsConstantTensor ( weights ) ) { ResizeAndTransposeWeights ( context , weights , transposed_weights ) ; } } EvalFloat < kernel_type > ( context , params , data , input , weights , bias , transposed_weights , col2im , output ) ; break ; } case kTfLiteUInt8 : { TfLiteTensor * scratch_buffer = GetTemporary ( context , node , data -> scratch_tensor_index ) ; if ( IsDynamicTensor ( scratch_buffer ) ) { TF_LITE_ENSURE_OK ( context , ResizeTensor ( context , output_shape , scratch_buffer ) ) ; } if ( data -> weights_are_transposed ) { if ( ! IsConstantTensor ( weights ) ) { ResizeAndTransposeWeights ( context , weights , transposed_weights ) ; } } EvalQuantized < kernel_type > ( context , params , data , input , weights , transposed_weights , bias , col2im , output , scratch_buffer ) ; break ; } case kTfLiteInt8 : { TfLiteTensor * scratch_buffer = GetTemporary ( context , node , data -> scratch_tensor_index ) ; if ( IsDynamicTensor ( scratch_buffer ) ) { TF_LITE_ENSURE_OK ( context , ResizeTensor ( context , output_shape , scratch_buffer ) ) ; } if ( data -> weights_are_transposed && ! IsConstantTensor ( weights ) ) { ResizeAndTransposeWeights ( context , weights , transposed_weights ) ; } EvalQuantizedPerChannel < kernel_type > ( context , params , data , input , weights , transposed_weights , bias , col2im , output , scratch_buffer ) ; break ; } case kTfLiteInt16 : { TfLiteTensor * scratch_buffer = GetTemporary ( context , node , data -> scratch_tensor_index ) ; if ( IsDynamicTensor ( scratch_buffer ) ) { TF_LITE_ENSURE_OK ( context , ResizeTensor ( context , output_shape , scratch_buffer ) ) ; } if ( data -> weights_are_transposed && ! IsConstantTensor ( weights ) ) { ResizeAndTransposeWeights ( context , weights , transposed_weights ) ; } EvalQuantizedPerChannel16x8 ( context , params , data , input , weights , transposed_weights , bias , col2im , output , scratch_buffer ) ; break ; } default : context -> ReportError ( context , "Type '%s' is not currently supported." , TfLiteTypeGetName ( input -> type ) ) ; return kTfLiteError ; } return kTfLiteOk ; }
noko_init_xml_sax_parser_context ( ) { cNokogiriXmlSaxParserContext = rb_define_class_under ( mNokogiriXmlSax , "ParserContext" , rb_cObject ) ; rb_undef_alloc_func ( cNokogiriXmlSaxParserContext ) ; rb_define_singleton_method ( cNokogiriXmlSaxParserContext , "io" , parse_io , 2 ) ; rb_define_singleton_method ( cNokogiriXmlSaxParserContext , "memory" , parse_memory , 1 ) ; rb_define_singleton_method ( cNokogiriXmlSaxParserContext , "file" , parse_file , 1 ) ; rb_define_method ( cNokogiriXmlSaxParserContext , "parse_with" , parse_with , 1 ) ; rb_define_method ( cNokogiriXmlSaxParserContext , "replace_entities=" , set_replace_entities , 1 ) ; rb_define_method ( cNokogiriXmlSaxParserContext , "replace_entities" , get_replace_entities , 0 ) ; rb_define_method ( cNokogiriXmlSaxParserContext , "recovery=" , set_recovery , 1 ) ; rb_define_method ( cNokogiriXmlSaxParserContext , "recovery" , get_recovery , 0 ) ; rb_define_method ( cNokogiriXmlSaxParserContext , "line" , line , 0 ) ; rb_define_method ( cNokogiriXmlSaxParserContext , "column" , column , 0 ) ; }
void SetCaseFirstOption ( icu :: Collator * icu_collator , const char * value ) { CHECK_NOT_NULL ( icu_collator ) ; CHECK_NOT_NULL ( value ) ; UErrorCode status = U_ZERO_ERROR ; if ( strcmp ( value , "upper" ) == 0 ) { icu_collator -> setAttribute ( UCOL_CASE_FIRST , UCOL_UPPER_FIRST , status ) ; } else if ( strcmp ( value , "lower" ) == 0 ) { icu_collator -> setAttribute ( UCOL_CASE_FIRST , UCOL_LOWER_FIRST , status ) ; } else { icu_collator -> setAttribute ( UCOL_CASE_FIRST , UCOL_OFF , status ) ; } CHECK ( U_SUCCESS ( status ) ) ; }
init_random ( void ) { struct timeval now ; unsigned int seed ; ( void ) SCTP_GETTIME_TIMEVAL ( & now ) ; seed = 0 ; seed |= ( unsigned int ) now . tv_sec ; seed |= ( unsigned int ) now . tv_usec ; #if !defined(_WIN32) &&! defined(__native_client__) seed |= getpid ( ) ; #endif #if defined(_WIN32) || defined(__native_client__) srand ( seed ) ; #else srandom ( seed ) ; #endif return ; }
static StkId rethook ( lua_State * L , CallInfo * ci , StkId firstres , int nres ) { ptrdiff_t oldtop = savestack ( L , L -> top ) ; int delta = 0 ; if ( isLuacode ( ci ) ) { Proto * p = clLvalue ( s2v ( ci -> func ) ) -> p ; if ( p -> is_vararg ) delta = ci -> u . l . nextraargs + p -> numparams + 1 ; if ( L -> top < ci -> top ) L -> top = ci -> top ; } if ( L -> hookmask & LUA_MASKRET ) { int ftransfer ; ci -> func += delta ; ftransfer = cast ( unsigned short , firstres - ci -> func ) ; luaD_hook ( L , LUA_HOOKRET , - 1 , ftransfer , nres ) ; ci -> func -= delta ; } if ( isLua ( ci -> previous ) ) L -> oldpc = ci -> previous -> u . l . savedpc ; return restorestack ( L , oldtop ) ; }
static void search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , int partial_frame ) { VP9_COMMON * const cm = & cpi -> common ; struct loopfilter * const lf = & cm -> lf ; const int min_filter_level = 0 ; const int max_filter_level = get_max_filter_level ( cpi ) ; int best_err ; int filt_best ; int filt_direction = 0 ; int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ; int filter_step = filt_mid < 16 ? 4 : filt_mid / 4 ; int ss_err [ MAX_LOOP_FILTER + 1 ] ; vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ; vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ; best_err = try_filter_frame ( sd , cpi , filt_mid , partial_frame ) ; filt_best = filt_mid ; ss_err [ filt_mid ] = best_err ; while ( filter_step > 0 ) { const int filt_high = MIN ( filt_mid + filter_step , max_filter_level ) ; const int filt_low = MAX ( filt_mid - filter_step , min_filter_level ) ; int filt_err ; int bias = ( best_err > > ( 15 - ( filt_mid / 8 ) ) ) * filter_step ; if ( cpi -> twopass . section_intra_rating < 20 ) bias = bias * cpi -> twopass . section_intra_rating / 20 ; if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ; if ( filt_direction <= 0 && filt_low != filt_mid ) { if ( ss_err [ filt_low ] < 0 ) { filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ; ss_err [ filt_low ] = filt_err ; } else { filt_err = ss_err [ filt_low ] ; } if ( ( filt_err - bias ) < best_err ) { if ( filt_err < best_err ) best_err = filt_err ; filt_best = filt_low ; } } if ( filt_direction >= 0 && filt_high != filt_mid ) { if ( ss_err [ filt_high ] < 0 ) { filt_err = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ; ss_err [ filt_high ] = filt_err ; } else { filt_err = ss_err [ filt_high ] ; } if ( filt_err < ( best_err - bias ) ) { best_err = filt_err ; filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step /= 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } } lf -> filter_level = filt_best ; }
int econn_message_encode ( char * * strp , const struct econn_message * msg ) { struct json_object * jobj = NULL ; char * str = NULL ; int err ; if ( ! strp || ! msg ) return EINVAL ; err = jzon_creatf ( & jobj , "sss" , "version" , econn_proto_version , "type" , econn_msg_name ( msg -> msg_type ) , "sessid" , msg -> sessid_sender ) ; if ( err ) return err ; if ( str_isset ( msg -> src_userid ) ) { err = jzon_add_str ( jobj , "src_userid" , "%s" , msg -> src_userid ) ; if ( err ) goto out ; } if ( str_isset ( msg -> src_clientid ) ) { err = jzon_add_str ( jobj , "src_clientid" , "%s" , msg -> src_clientid ) ; if ( err ) goto out ; } if ( str_isset ( msg -> dest_userid ) ) { err = jzon_add_str ( jobj , "dest_userid" , "%s" , msg -> dest_userid ) ; if ( err ) goto out ; } if ( str_isset ( msg -> dest_clientid ) ) { err = jzon_add_str ( jobj , "dest_clientid" , "%s" , msg -> dest_clientid ) ; if ( err ) goto out ; } err = jzon_add_bool ( jobj , "resp" , msg -> resp ) ; if ( err ) goto out ; switch ( msg -> msg_type ) { case ECONN_SETUP : case ECONN_GROUP_SETUP : case ECONN_UPDATE : err = jzon_add_str ( jobj , "sdp" , "%s" , msg -> u . setup . sdp_msg ) ; if ( err ) goto out ; if ( msg -> u . setup . props ) { err = econn_props_encode ( jobj , msg -> u . setup . props ) ; if ( err ) goto out ; } if ( msg -> u . setup . url ) { err = jzon_add_str ( jobj , "url" , "%s" , msg -> u . setup . url ) ; if ( err ) goto out ; } break ; case ECONN_CANCEL : break ; case ECONN_HANGUP : break ; case ECONN_REJECT : break ; case ECONN_PROPSYNC : if ( ! msg -> u . propsync . props ) { warning ( "propsync: missing props\n" ) ; err = EINVAL ; goto out ; } err = econn_props_encode ( jobj , msg -> u . propsync . props ) ; if ( err ) goto out ; break ; case ECONN_GROUP_START : if ( msg -> u . groupstart . props ) { err = econn_props_encode ( jobj , msg -> u . groupstart . props ) ; if ( err ) goto out ; } break ; case ECONN_GROUP_LEAVE : case ECONN_GROUP_CHECK : break ; case ECONN_CONF_CONN : if ( msg -> u . confconn . turnc > 0 ) { err = zapi_iceservers_encode ( jobj , msg -> u . confconn . turnv , msg -> u . confconn . turnc ) ; if ( err ) goto out ; } jzon_add_bool ( jobj , "update" , msg -> u . confconn . update ) ; jzon_add_str ( jobj , "tool" , msg -> u . confconn . tool ) ; jzon_add_str ( jobj , "toolver" , msg -> u . confconn . toolver ) ; jzon_add_int ( jobj , "status" , msg -> u . confconn . status ) ; jzon_add_bool ( jobj , "selective_audio" , msg -> u . confconn . selective_audio ) ; jzon_add_bool ( jobj , "selective_video" , msg -> u . confconn . selective_video ) ; jzon_add_int ( jobj , "vstreams" , msg -> u . confconn . vstreams ) ; break ; case ECONN_CONF_START : jzon_add_str ( jobj , "sft_url" , "%s" , msg -> u . confstart . sft_url ) ; jzon_add_base64 ( jobj , "secret" , msg -> u . confstart . secret , msg -> u . confstart . secretlen ) ; jzon_add_str ( jobj , "timestamp" , "%llu" , msg -> u . confstart . timestamp ) ; jzon_add_str ( jobj , "seqno" , "%u" , msg -> u . confstart . seqno ) ; if ( msg -> u . confstart . props ) { err = econn_props_encode ( jobj , msg -> u . confstart . props ) ; if ( err ) goto out ; } break ; case ECONN_CONF_CHECK : jzon_add_str ( jobj , "sft_url" , "%s" , msg -> u . confcheck . sft_url ) ; jzon_add_base64 ( jobj , "secret" , msg -> u . confcheck . secret , msg -> u . confcheck . secretlen ) ; jzon_add_str ( jobj , "timestamp" , "%llu" , msg -> u . confcheck . timestamp ) ; jzon_add_str ( jobj , "seqno" , "%u" , msg -> u . confcheck . seqno ) ; break ; case ECONN_CONF_END : break ; case ECONN_CONF_PART : jzon_add_bool ( jobj , "should_start" , msg -> u . confpart . should_start ) ; jzon_add_str ( jobj , "timestamp" , "%llu" , msg -> u . confpart . timestamp ) ; jzon_add_str ( jobj , "seqno" , "%u" , msg -> u . confpart . seqno ) ; jzon_add_base64 ( jobj , "entropy" , msg -> u . confpart . entropy , msg -> u . confpart . entropylen ) ; econn_parts_encode ( jobj , & msg -> u . confpart . partl ) ; break ; case ECONN_CONF_KEY : econn_keys_encode ( jobj , & msg -> u . confkey . keyl ) ; break ; case ECONN_DEVPAIR_PUBLISH : err = zapi_iceservers_encode ( jobj , msg -> u . devpair_publish . turnv , msg -> u . devpair_publish . turnc ) ; if ( err ) goto out ; err = jzon_add_str ( jobj , "sdp" , "%s" , msg -> u . devpair_publish . sdp ) ; err |= jzon_add_str ( jobj , "username" , "%s" , msg -> u . devpair_publish . username ) ; if ( err ) goto out ; break ; case ECONN_DEVPAIR_ACCEPT : err = jzon_add_str ( jobj , "sdp" , "%s" , msg -> u . devpair_accept . sdp ) ; if ( err ) goto out ; break ; case ECONN_ALERT : err = jzon_add_int ( jobj , "level" , msg -> u . alert . level ) ; err |= jzon_add_str ( jobj , "descr" , "%s" , msg -> u . alert . descr ) ; if ( err ) goto out ; break ; case ECONN_PING : break ; default : warning ( "econn: dont know how to encode %d\n" , msg -> msg_type ) ; err = EBADMSG ; break ; } if ( err ) goto out ; err = jzon_encode ( & str , jobj ) ; if ( err ) goto out ; out : mem_deref ( jobj ) ; if ( err ) mem_deref ( str ) ; else * strp = str ; return err ; }
void ObjectLiteral :: BuildBoilerplateDescription ( Isolate * isolate ) { if ( ! boilerplate_description_ . is_null ( ) ) return ; int index_keys = 0 ; bool has_seen_proto = false ; for ( int i = 0 ; i < properties ( ) -> length ( ) ; i ++ ) { ObjectLiteral :: Property * property = properties ( ) -> at ( i ) ; if ( property -> IsPrototype ( ) ) { has_seen_proto = true ; continue ; } if ( property -> is_computed_name ( ) ) { continue ; } Literal * key = property -> key ( ) -> AsLiteral ( ) ; if ( ! key -> IsPropertyName ( ) ) { index_keys ++ ; } } Handle < ObjectBoilerplateDescription > boilerplate_description = isolate -> factory ( ) -> NewObjectBoilerplateDescription ( boilerplate_properties_ , properties ( ) -> length ( ) , index_keys , has_seen_proto ) ; int position = 0 ; for ( int i = 0 ; i < properties ( ) -> length ( ) ; i ++ ) { ObjectLiteral :: Property * property = properties ( ) -> at ( i ) ; if ( property -> IsPrototype ( ) ) continue ; if ( static_cast < uint32_t > ( position ) == boilerplate_properties_ ) { DCHECK ( property -> is_computed_name ( ) ) ; break ; } DCHECK ( ! property -> is_computed_name ( ) ) ; MaterializedLiteral * m_literal = property -> value ( ) -> AsMaterializedLiteral ( ) ; if ( m_literal != nullptr ) { m_literal -> BuildConstants ( isolate ) ; } Literal * key_literal = property -> key ( ) -> AsLiteral ( ) ; uint32_t element_index = 0 ; Handle < Object > key = key_literal -> AsArrayIndex ( & element_index ) ? isolate -> factory ( ) -> NewNumberFromUint ( element_index ) : Handle < Object > :: cast ( key_literal -> AsRawPropertyName ( ) -> string ( ) ) ; Handle < Object > value = GetBoilerplateValue ( property -> value ( ) , isolate ) ; boilerplate_description -> set_key_value ( position ++ , * key , * value ) ; } boilerplate_description -> set_flags ( EncodeLiteralType ( ) ) ; boilerplate_description_ = boilerplate_description ; }
static int ivr_read_header ( AVFormatContext * s ) { unsigned tag , type , len , tlen , value ; int i , j , n , count , nb_streams = 0 , ret ; uint8_t key [ 256 ] , val [ 256 ] ; AVIOContext * pb = s -> pb ; AVStream * st ; int64_t pos , offset , temp ; pos = avio_tell ( pb ) ; tag = avio_rl32 ( pb ) ; if ( tag == MKTAG ( '.' , 'R' , '1' , 'M' ) ) { if ( avio_rb16 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; len = avio_rb32 ( pb ) ; avio_skip ( pb , len ) ; avio_skip ( pb , 5 ) ; temp = avio_rb64 ( pb ) ; while ( ! avio_feof ( pb ) && temp ) { offset = temp ; temp = avio_rb64 ( pb ) ; } avio_skip ( pb , offset - avio_tell ( pb ) ) ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; len = avio_rb32 ( pb ) ; avio_skip ( pb , len ) ; if ( avio_r8 ( pb ) != 2 ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 16 ) ; pos = avio_tell ( pb ) ; tag = avio_rl32 ( pb ) ; } if ( tag != MKTAG ( '.' , 'R' , 'E' , 'C' ) ) return AVERROR_INVALIDDATA ; if ( avio_r8 ( pb ) != 0 ) return AVERROR_INVALIDDATA ; count = avio_rb32 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; type = avio_r8 ( pb ) ; tlen = avio_rb32 ( pb ) ; avio_get_str ( pb , tlen , key , sizeof ( key ) ) ; len = avio_rb32 ( pb ) ; if ( type == 5 ) { avio_get_str ( pb , len , val , sizeof ( val ) ) ; av_log ( s , AV_LOG_DEBUG , "%s = '%s'\n" , key , val ) ; } else if ( type == 4 ) { av_log ( s , AV_LOG_DEBUG , "%s = '0x" , key ) ; for ( j = 0 ; j < len ; j ++ ) av_log ( s , AV_LOG_DEBUG , "%X" , avio_r8 ( pb ) ) ; av_log ( s , AV_LOG_DEBUG , "'\n" ) ; } else if ( len == 4 && type == 3 && ! strncmp ( key , "StreamCount" , tlen ) ) { nb_streams = value = avio_rb32 ( pb ) ; } else if ( len == 4 && type == 3 ) { value = avio_rb32 ( pb ) ; av_log ( s , AV_LOG_DEBUG , "%s = %d\n" , key , value ) ; } else { av_log ( s , AV_LOG_DEBUG , "Skipping unsupported key: %s\n" , key ) ; avio_skip ( pb , len ) ; } } for ( n = 0 ; n < nb_streams ; n ++ ) { st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> priv_data = ff_rm_alloc_rmstream ( ) ; if ( ! st -> priv_data ) return AVERROR ( ENOMEM ) ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; count = avio_rb32 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; type = avio_r8 ( pb ) ; tlen = avio_rb32 ( pb ) ; avio_get_str ( pb , tlen , key , sizeof ( key ) ) ; len = avio_rb32 ( pb ) ; if ( type == 5 ) { avio_get_str ( pb , len , val , sizeof ( val ) ) ; av_log ( s , AV_LOG_DEBUG , "%s = '%s'\n" , key , val ) ; } else if ( type == 4 && ! strncmp ( key , "OpaqueData" , tlen ) ) { ret = ffio_ensure_seekback ( pb , 4 ) ; if ( ret < 0 ) return ret ; if ( avio_rb32 ( pb ) == MKBETAG ( 'M' , 'L' , 'T' , 'I' ) ) { ret = rm_read_multi ( s , pb , st , NULL ) ; } else { avio_seek ( pb , - 4 , SEEK_CUR ) ; ret = ff_rm_read_mdpr_codecdata ( s , pb , st , st -> priv_data , len , NULL ) ; } if ( ret < 0 ) return ret ; } else if ( type == 4 ) { int j ; av_log ( s , AV_LOG_DEBUG , "%s = '0x" , key ) ; for ( j = 0 ; j < len ; j ++ ) av_log ( s , AV_LOG_DEBUG , "%X" , avio_r8 ( pb ) ) ; av_log ( s , AV_LOG_DEBUG , "'\n" ) ; } else if ( len == 4 && type == 3 && ! strncmp ( key , "Duration" , tlen ) ) { st -> duration = avio_rb32 ( pb ) ; } else if ( len == 4 && type == 3 ) { value = avio_rb32 ( pb ) ; av_log ( s , AV_LOG_DEBUG , "%s = %d\n" , key , value ) ; } else { av_log ( s , AV_LOG_DEBUG , "Skipping unsupported key: %s\n" , key ) ; avio_skip ( pb , len ) ; } } } if ( avio_r8 ( pb ) != 6 ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 12 ) ; avio_skip ( pb , avio_rb64 ( pb ) + pos - avio_tell ( s -> pb ) ) ; if ( avio_r8 ( pb ) != 8 ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 8 ) ; return 0 ; }
void AsyncGeneratorBuiltinsAssembler :: AsyncGeneratorAwait ( bool is_catchable ) { Node * generator = Parameter ( Descriptor :: kGenerator ) ; Node * value = Parameter ( Descriptor :: kAwaited ) ; Node * context = Parameter ( Descriptor :: kContext ) ; CSA_SLOW_ASSERT ( this , TaggedIsAsyncGenerator ( generator ) ) ; Node * const request = LoadFirstAsyncGeneratorRequestFromQueue ( generator ) ; CSA_ASSERT ( this , IsNotUndefined ( request ) ) ; ContextInitializer init_closure_context = [ & ] ( Node * context ) { StoreContextElementNoWriteBarrier ( context , AwaitContext :: kGeneratorSlot , generator ) ; } ; Node * outer_promise = LoadObjectField ( request , AsyncGeneratorRequest :: kPromiseOffset ) ; const int resolve_index = Context :: ASYNC_GENERATOR_AWAIT_RESOLVE_SHARED_FUN ; const int reject_index = Context :: ASYNC_GENERATOR_AWAIT_REJECT_SHARED_FUN ; SetGeneratorAwaiting ( generator ) ; Await ( context , generator , value , outer_promise , AwaitContext :: kLength , init_closure_context , resolve_index , reject_index , is_catchable ) ; Return ( UndefinedConstant ( ) ) ; }
void Compute ( OpKernelContext * ctx ) override { const Tensor & val = ctx -> input ( 0 ) ; int64 id = ctx -> session_state ( ) -> GetNewId ( ) ; TensorStore :: TensorAndKey tk { val , id , requested_device ( ) } ; OP_REQUIRES_OK ( ctx , ctx -> tensor_store ( ) -> AddTensor ( name ( ) , tk ) ) ; Tensor * handle = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { } ) , & handle ) ) ; if ( ctx -> expected_output_dtype ( 0 ) == DT_RESOURCE ) { ResourceHandle resource_handle = MakeResourceHandle < Tensor > ( ctx , SessionState :: kTensorHandleResourceTypeName , tk . GetHandle ( name ( ) ) ) ; resource_handle . set_maybe_type_name ( SessionState :: kTensorHandleResourceTypeName ) ; handle -> scalar < ResourceHandle > ( ) ( ) = resource_handle ; } else { handle -> flat < tstring > ( ) . setConstant ( tk . GetHandle ( name ( ) ) ) ; } }
SweepPhase ( JSRuntime * rt , JSGCInvocationKind gckind , bool * startBackgroundSweep ) { gcstats :: AutoPhase ap ( rt -> gcStats , gcstats :: PHASE_SWEEP ) ; #ifdef JS_THREADSAFE * startBackgroundSweep = ( rt -> hasContexts ( ) && rt -> gcHelperThread . prepareForBackgroundSweep ( ) ) ; #else * startBackgroundSweep = false ; #endif for ( GCCompartmentsIter c ( rt ) ; ! c . done ( ) ; c . next ( ) ) c -> arenas . purge ( ) ; FreeOp fop ( rt , * startBackgroundSweep , false ) ; { gcstats :: AutoPhase ap ( rt -> gcStats , gcstats :: PHASE_FINALIZE_START ) ; if ( rt -> gcFinalizeCallback ) rt -> gcFinalizeCallback ( & fop , JSFINALIZE_START ) ; } WeakMapBase :: sweepAll ( & rt -> gcMarker ) ; rt -> debugScopes -> sweep ( ) ; SweepAtomState ( rt ) ; WatchpointMap :: sweepAll ( rt ) ; Debugger :: sweepAll ( & fop ) ; { gcstats :: AutoPhase ap ( rt -> gcStats , gcstats :: PHASE_SWEEP_COMPARTMENTS ) ; bool releaseTypes = ReleaseObservedTypes ( rt ) ; for ( GCCompartmentsIter c ( rt ) ; ! c . done ( ) ; c . next ( ) ) c -> sweep ( & fop , releaseTypes ) ; } { gcstats :: AutoPhase ap ( rt -> gcStats , gcstats :: PHASE_SWEEP_OBJECT ) ; for ( GCCompartmentsIter c ( rt ) ; ! c . done ( ) ; c . next ( ) ) c -> arenas . finalizeObjects ( & fop ) ; } { gcstats :: AutoPhase ap ( rt -> gcStats , gcstats :: PHASE_SWEEP_STRING ) ; for ( GCCompartmentsIter c ( rt ) ; ! c . done ( ) ; c . next ( ) ) c -> arenas . finalizeStrings ( & fop ) ; } { gcstats :: AutoPhase ap ( rt -> gcStats , gcstats :: PHASE_SWEEP_SCRIPT ) ; for ( GCCompartmentsIter c ( rt ) ; ! c . done ( ) ; c . next ( ) ) c -> arenas . finalizeScripts ( & fop ) ; } { gcstats :: AutoPhase ap ( rt -> gcStats , gcstats :: PHASE_SWEEP_SHAPE ) ; for ( GCCompartmentsIter c ( rt ) ; ! c . done ( ) ; c . next ( ) ) c -> arenas . finalizeShapes ( & fop ) ; } #ifdef DEBUG PropertyTree :: dumpShapes ( rt ) ; #endif { gcstats :: AutoPhase ap ( rt -> gcStats , gcstats :: PHASE_DESTROY ) ; if ( rt -> gcIsFull ) SweepScriptFilenames ( rt ) ; SweepCompartments ( & fop , gckind ) ; #ifndef JS_THREADSAFE ExpireChunksAndArenas ( rt , gckind == GC_SHRINK ) ; #endif } { gcstats :: AutoPhase ap ( rt -> gcStats , gcstats :: PHASE_FINALIZE_END ) ; if ( rt -> gcFinalizeCallback ) rt -> gcFinalizeCallback ( & fop , JSFINALIZE_END ) ; } for ( CompartmentsIter c ( rt ) ; ! c . done ( ) ; c . next ( ) ) c -> setGCLastBytes ( c -> gcBytes , c -> gcMallocAndFreeBytes , gckind ) ; }
UWORD16 impeg2d_get_mb_addr_incr ( stream_t * ps_stream ) { UWORD16 u2_mb_addr_incr = 0 ; while ( impeg2d_bit_stream_nxt ( ps_stream , MB_ESCAPE_CODE_LEN ) == MB_ESCAPE_CODE ) { impeg2d_bit_stream_flush ( ps_stream , MB_ESCAPE_CODE_LEN ) ; u2_mb_addr_incr += 33 ; } u2_mb_addr_incr += impeg2d_dec_vld_symbol ( ps_stream , gai2_impeg2d_mb_addr_incr , MB_ADDR_INCR_LEN ) + MB_ADDR_INCR_OFFSET ; return ( u2_mb_addr_incr ) ; }
void AsmJsParser :: SwitchStatement ( ) { EXPECT_TOKEN ( TOK ( switch ) ) ; EXPECT_TOKEN ( '(' ) ; AsmType * test ; RECURSE ( test = Expression ( nullptr ) ) ; if ( ! test -> IsA ( AsmType :: Signed ( ) ) ) { FAIL ( "Expected signed for switch value" ) ; } EXPECT_TOKEN ( ')' ) ; uint32_t tmp = TempVariable ( 0 ) ; current_function_builder_ -> EmitSetLocal ( tmp ) ; Begin ( pending_label_ ) ; pending_label_ = 0 ; CachedVector < int32_t > cases ( cached_int_vectors_ ) ; GatherCases ( & cases ) ; EXPECT_TOKEN ( '{' ) ; size_t count = cases . size ( ) + 1 ; for ( size_t i = 0 ; i < count ; ++ i ) { BareBegin ( BlockKind :: kOther ) ; current_function_builder_ -> EmitWithU8 ( kExprBlock , kLocalVoid ) ; } int table_pos = 0 ; for ( auto c : cases ) { current_function_builder_ -> EmitGetLocal ( tmp ) ; current_function_builder_ -> EmitI32Const ( c ) ; current_function_builder_ -> Emit ( kExprI32Eq ) ; current_function_builder_ -> EmitWithI32V ( kExprBrIf , table_pos ++ ) ; } current_function_builder_ -> EmitWithI32V ( kExprBr , table_pos ++ ) ; while ( ! failed_ && Peek ( TOK ( case ) ) ) { current_function_builder_ -> Emit ( kExprEnd ) ; BareEnd ( ) ; RECURSE ( ValidateCase ( ) ) ; } current_function_builder_ -> Emit ( kExprEnd ) ; BareEnd ( ) ; if ( Peek ( TOK ( default ) ) ) { RECURSE ( ValidateDefault ( ) ) ; } EXPECT_TOKEN ( '}' ) ; End ( ) ; }
nsListControlFrame :: MouseDown ( nsIDOMEvent * aMouseEvent ) { NS_ASSERTION ( aMouseEvent != nullptr , "aMouseEvent is null." ) ; nsCOMPtr < nsIDOMMouseEvent > mouseEvent = do_QueryInterface ( aMouseEvent ) ; NS_ENSURE_TRUE ( mouseEvent , NS_ERROR_FAILURE ) ; UpdateInListState ( aMouseEvent ) ; nsEventStates eventStates = mContent -> AsElement ( ) -> State ( ) ; if ( eventStates . HasState ( NS_EVENT_STATE_DISABLED ) ) { return NS_OK ; } if ( ! IsLeftButton ( aMouseEvent ) ) { if ( IsInDropDownMode ( ) ) { if ( ! IgnoreMouseEventForSelection ( aMouseEvent ) ) { aMouseEvent -> PreventDefault ( ) ; aMouseEvent -> StopPropagation ( ) ; } else { return NS_OK ; } return NS_ERROR_FAILURE ; } else { return NS_OK ; } } int32_t selectedIndex ; if ( NS_SUCCEEDED ( GetIndexFromDOMEvent ( aMouseEvent , selectedIndex ) ) ) { mButtonDown = true ; CaptureMouseEvents ( true ) ; mChangesSinceDragStart = HandleListSelection ( aMouseEvent , selectedIndex ) ; } else { if ( mComboboxFrame ) { if ( ! IgnoreMouseEventForSelection ( aMouseEvent ) ) { return NS_OK ; } if ( ! nsComboboxControlFrame :: ToolkitHasNativePopup ( ) ) { bool isDroppedDown = mComboboxFrame -> IsDroppedDown ( ) ; nsIFrame * comboFrame = do_QueryFrame ( mComboboxFrame ) ; nsWeakFrame weakFrame ( comboFrame ) ; mComboboxFrame -> ShowDropDown ( ! isDroppedDown ) ; if ( ! weakFrame . IsAlive ( ) ) return NS_OK ; if ( isDroppedDown ) { CaptureMouseEvents ( false ) ; } } } } return NS_OK ; }
void SourceListener :: GetSettingsFor ( MediaTrack * aTrack , MediaTrackSettings & aOutSettings ) const { MOZ_ASSERT ( NS_IsMainThread ( ) , "Only call on main thread" ) ; DeviceState & state = GetDeviceStateFor ( aTrack ) ; state . mDevice -> GetSettings ( aOutSettings ) ; MediaSourceEnum mediaSource = state . mDevice -> GetMediaSource ( ) ; if ( mediaSource == MediaSourceEnum :: Camera || mediaSource == MediaSourceEnum :: Microphone ) { aOutSettings . mDeviceId . Construct ( state . mDevice -> mID ) ; aOutSettings . mGroupId . Construct ( state . mDevice -> mGroupID ) ; } }
void AudioPolicyService :: releaseInput ( audio_io_handle_t input , audio_session_t session ) { if ( mAudioPolicyManager == NULL ) { return ; } sp < AudioPolicyEffects > audioPolicyEffects ; { Mutex :: Autolock _l ( mLock ) ; mAudioPolicyManager -> releaseInput ( input , session ) ; audioPolicyEffects = mAudioPolicyEffects ; } if ( audioPolicyEffects != 0 ) { status_t status = audioPolicyEffects -> releaseInputEffects ( input ) ; if ( status != NO_ERROR ) { ALOGW ( "Failed to release effects on input %d" , input ) ; } } }
njs_generate_try_catch ( njs_vm_t * vm , njs_generator_t * generator , njs_parser_node_t * node ) { njs_int_t ret ; njs_index_t exit_index ; njs_vmcode_finally_t * finally ; njs_generator_patch_t * patch ; njs_generator_block_t * block , * try_block ; njs_generator_try_ctx_t * ctx ; ctx = generator -> context ; try_block = ctx -> try_block ; exit_index = try_block -> index ; njs_code_set_jump_offset ( generator , njs_vmcode_try_end_t , ctx -> try_offset ) ; if ( try_block -> continuation != NULL || try_block -> exit != NULL ) { njs_generate_code_finally ( generator , finally , ctx -> exception_index , exit_index , NULL ) ; if ( try_block -> continuation != NULL ) { block = njs_generate_find_block ( vm , generator -> block , NJS_GENERATOR_LOOP , & ctx -> try_cont_label ) ; patch = njs_generate_make_continuation_patch ( vm , block , & ctx -> try_cont_label , njs_code_offset ( generator , finally ) + offsetof ( njs_vmcode_finally_t , continue_offset ) ) ; if ( njs_slow_path ( patch == NULL ) ) { return NJS_ERROR ; } } if ( try_block -> exit != NULL ) { block = njs_generate_find_block ( vm , generator -> block , NJS_GENERATOR_ALL , & ctx -> try_exit_label ) ; if ( block != NULL ) { patch = njs_generate_make_exit_patch ( vm , block , & ctx -> try_exit_label , njs_code_offset ( generator , finally ) + offsetof ( njs_vmcode_finally_t , break_offset ) ) ; if ( njs_slow_path ( patch == NULL ) ) { return NJS_ERROR ; } } } } ret = njs_generate_index_release ( vm , generator , ctx -> exception_index ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } return njs_generator_stack_pop ( vm , generator , ctx ) ; }
static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , size_t count , loff_t * offp ) { struct f_hidg * hidg = file -> private_data ; struct usb_request * req ; unsigned long flags ; ssize_t status = - ENOMEM ; if ( ! access_ok ( buffer , count ) ) return - EFAULT ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; #define WRITE_COND (!hidg->write_pending) try_again : while ( ! WRITE_COND ) { spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; if ( file -> f_flags & O_NONBLOCK ) return - EAGAIN ; if ( wait_event_interruptible_exclusive ( hidg -> write_queue , WRITE_COND ) ) return - ERESTARTSYS ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; } hidg -> write_pending = 1 ; req = hidg -> req ; count = min_t ( unsigned , count , hidg -> report_length ) ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; status = copy_from_user ( req -> buf , buffer , count ) ; if ( status != 0 ) { ERROR ( hidg -> func . config -> cdev , "copy_from_user error\n" ) ; status = - EINVAL ; goto release_write_pending ; } spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; if ( ! hidg -> req ) { free_ep_req ( hidg -> in_ep , req ) ; goto try_again ; } req -> status = 0 ; req -> zero = 0 ; req -> length = count ; req -> complete = f_hidg_req_complete ; req -> context = hidg ; status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; if ( status < 0 ) { ERROR ( hidg -> func . config -> cdev , "usb_ep_queue error on int endpoint %zd\n" , status ) ; goto release_write_pending_unlocked ; } else { status = count ; } spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; return status ; release_write_pending : spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; release_write_pending_unlocked : hidg -> write_pending = 0 ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; wake_up ( & hidg -> write_queue ) ; return status ; }
const Operator * MachineOperatorBuilder :: Word64AtomicStore ( MachineRepresentation rep ) { #define STORE(kRep)                          \  if (rep == MachineRepresentation::kRep) {  \  return &cache_.kWord64AtomicStore##kRep; \  } ATOMIC64_REPRESENTATION_LIST ( STORE ) #undef STORE UNREACHABLE ( ) ; }
static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied , err ; struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; #if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; #endif if ( flags & MSG_ERRQUEUE ) { err = packet_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; } sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; if ( sock -> type == SOCK_PACKET ) msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ; else msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ) ; if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; } put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }
size_t Heap :: Available ( ) { if ( ! HasBeenSetUp ( ) ) return 0 ; size_t total = 0 ; for ( SpaceIterator it ( this ) ; it . has_next ( ) ; ) { total += it . next ( ) -> Available ( ) ; } return total ; }
static int CopyCachedOneByteCharsToArray ( Heap * heap , const uint8_t * chars , FixedArray * elements , int length ) { DisallowHeapAllocation no_gc ; FixedArray * one_byte_cache = heap -> single_character_string_cache ( ) ; Object * undefined = ReadOnlyRoots ( heap ) . undefined_value ( ) ; int i ; WriteBarrierMode mode = elements -> GetWriteBarrierMode ( no_gc ) ; for ( i = 0 ; i < length ; ++ i ) { Object * value = one_byte_cache -> get ( chars [ i ] ) ; if ( value == undefined ) break ; elements -> set ( i , value , mode ) ; } if ( i < length ) { static_assert ( Smi :: kZero == 0 , "Can use memset since Smi::kZero is 0" ) ; memset ( elements -> data_start ( ) + i , 0 , kPointerSize * ( length - i ) ) ; } #ifdef DEBUG for ( int j = 0 ; j < length ; ++ j ) { Object * element = elements -> get ( j ) ; DCHECK ( element == Smi :: kZero || ( element -> IsString ( ) && String :: cast ( element ) -> LooksValid ( ) ) ) ; } #endif return i ; }
boost :: int64_t lazy_entry :: int_value ( ) const { TORRENT_ASSERT ( m_type == int_t ) ; boost :: int64_t val = 0 ; bool negative = false ; if ( * m_data . start == '-' ) negative = true ; parse_int ( negative ? m_data . start + 1 : m_data . start , m_data . start + m_size , 'e' , val ) ; if ( negative ) val = - val ; return val ; }
size_t Heap :: OldGenerationCapacity ( ) { if ( ! HasBeenSetUp ( ) ) return 0 ; PagedSpaces spaces ( this , PagedSpaces :: SpacesSpecifier :: kAllPagedSpaces ) ; size_t total = 0 ; for ( PagedSpace * space = spaces . next ( ) ; space != nullptr ; space = spaces . next ( ) ) { total += space -> Capacity ( ) ; } return total + lo_space_ -> SizeOfObjects ( ) ; }
Read ( JSContext * aCx , JSStructuredCloneReader * aReader , uint32_t aTag , uint32_t aData , void * aClosure ) { if ( aTag == DOMWORKER_SCTAG_FILE ) { MOZ_ASSERT ( ! aData ) ; DOMFileImpl * fileImpl ; if ( JS_ReadBytes ( aReader , & fileImpl , sizeof ( fileImpl ) ) ) { MOZ_ASSERT ( fileImpl ) ; #ifdef DEBUG { bool isMutable ; NS_ASSERTION ( NS_SUCCEEDED ( fileImpl -> GetMutable ( & isMutable ) ) && ! isMutable , "Only immutable file should be passed to worker" ) ; } #endif nsRefPtr < DOMFile > file = new DOMFile ( fileImpl ) ; JSObject * jsFile = file :: CreateFile ( aCx , file ) ; return jsFile ; } } else if ( aTag == DOMWORKER_SCTAG_BLOB ) { MOZ_ASSERT ( ! aData ) ; DOMFileImpl * blobImpl ; if ( JS_ReadBytes ( aReader , & blobImpl , sizeof ( blobImpl ) ) ) { MOZ_ASSERT ( blobImpl ) ; #ifdef DEBUG { bool isMutable ; NS_ASSERTION ( NS_SUCCEEDED ( blobImpl -> GetMutable ( & isMutable ) ) && ! isMutable , "Only immutable blob should be passed to worker" ) ; } #endif nsRefPtr < DOMFile > blob = new DOMFile ( blobImpl ) ; JSObject * jsBlob = file :: CreateBlob ( aCx , blob ) ; return jsBlob ; } } else if ( aTag == SCTAG_DOM_IMAGEDATA ) { MOZ_ASSERT ( ! aData ) ; uint32_t width , height ; JS :: Rooted < JS :: Value > dataArray ( aCx ) ; if ( ! JS_ReadUint32Pair ( aReader , & width , & height ) || ! JS_ReadTypedArray ( aReader , & dataArray ) ) { return nullptr ; } MOZ_ASSERT ( dataArray . isObject ( ) ) ; nsRefPtr < ImageData > imageData = new ImageData ( width , height , dataArray . toObject ( ) ) ; return imageData -> WrapObject ( aCx ) ; } Error ( aCx , 0 ) ; return nullptr ; }
set_acl ( struct archive * a , int fd , const char * name , struct archive_acl * abstract_acl , int ae_requested_type , const char * tname ) { aclent_t * aclent ; #if ARCHIVE_ACL_SUNOS_NFS4 ace_t * ace ; #endif int cmd , e , r ; void * aclp ; int ret ; int ae_type , ae_permset , ae_tag , ae_id ; int perm_map_size ; const acl_perm_map_t * perm_map ; uid_t ae_uid ; gid_t ae_gid ; const char * ae_name ; int entries ; int i ; ret = ARCHIVE_OK ; entries = archive_acl_reset ( abstract_acl , ae_requested_type ) ; if ( entries == 0 ) return ( ARCHIVE_OK ) ; switch ( ae_requested_type ) { case ARCHIVE_ENTRY_ACL_TYPE_POSIX1E : cmd = SETACL ; aclp = malloc ( entries * sizeof ( aclent_t ) ) ; break ; #if ARCHIVE_ACL_SUNOS_NFS4 case ARCHIVE_ENTRY_ACL_TYPE_NFS4 : cmd = ACE_SETACL ; aclp = malloc ( entries * sizeof ( ace_t ) ) ; break ; #endif default : errno = ENOENT ; archive_set_error ( a , errno , "Unsupported ACL type" ) ; return ( ARCHIVE_FAILED ) ; } if ( aclp == NULL ) { archive_set_error ( a , errno , "Can't allocate memory for acl buffer" ) ; return ( ARCHIVE_FAILED ) ; } e = 0 ; while ( archive_acl_next ( a , abstract_acl , ae_requested_type , & ae_type , & ae_permset , & ae_tag , & ae_id , & ae_name ) == ARCHIVE_OK ) { aclent = NULL ; #if ARCHIVE_ACL_SUNOS_NFS4 ace = NULL ; #endif if ( cmd == SETACL ) { aclent = & ( ( aclent_t * ) aclp ) [ e ] ; aclent -> a_id = - 1 ; aclent -> a_type = 0 ; aclent -> a_perm = 0 ; } #if ARCHIVE_ACL_SUNOS_NFS4 else { ace = & ( ( ace_t * ) aclp ) [ e ] ; ace -> a_who = - 1 ; ace -> a_access_mask = 0 ; ace -> a_flags = 0 ; } #endif /* ARCHIVE_ACL_SUNOS_NFS4 */ switch ( ae_tag ) { case ARCHIVE_ENTRY_ACL_USER : ae_uid = archive_write_disk_uid ( a , ae_name , ae_id ) ; if ( aclent != NULL ) { aclent -> a_id = ae_uid ; aclent -> a_type |= USER ; } #if ARCHIVE_ACL_SUNOS_NFS4 else { ace -> a_who = ae_uid ; } #endif break ; case ARCHIVE_ENTRY_ACL_GROUP : ae_gid = archive_write_disk_gid ( a , ae_name , ae_id ) ; if ( aclent != NULL ) { aclent -> a_id = ae_gid ; aclent -> a_type |= GROUP ; } #if ARCHIVE_ACL_SUNOS_NFS4 else { ace -> a_who = ae_gid ; ace -> a_flags |= ACE_IDENTIFIER_GROUP ; } #endif break ; case ARCHIVE_ENTRY_ACL_USER_OBJ : if ( aclent != NULL ) aclent -> a_type |= USER_OBJ ; #if ARCHIVE_ACL_SUNOS_NFS4 else { ace -> a_flags |= ACE_OWNER ; } #endif break ; case ARCHIVE_ENTRY_ACL_GROUP_OBJ : if ( aclent != NULL ) aclent -> a_type |= GROUP_OBJ ; #if ARCHIVE_ACL_SUNOS_NFS4 else { ace -> a_flags |= ACE_GROUP ; ace -> a_flags |= ACE_IDENTIFIER_GROUP ; } #endif break ; case ARCHIVE_ENTRY_ACL_MASK : if ( aclent != NULL ) aclent -> a_type |= CLASS_OBJ ; break ; case ARCHIVE_ENTRY_ACL_OTHER : if ( aclent != NULL ) aclent -> a_type |= OTHER_OBJ ; break ; #if ARCHIVE_ACL_SUNOS_NFS4 case ARCHIVE_ENTRY_ACL_EVERYONE : if ( ace != NULL ) ace -> a_flags |= ACE_EVERYONE ; break ; #endif default : archive_set_error ( a , ARCHIVE_ERRNO_MISC , "Unsupported ACL tag" ) ; ret = ARCHIVE_FAILED ; goto exit_free ; } r = 0 ; switch ( ae_type ) { #if ARCHIVE_ACL_SUNOS_NFS4 case ARCHIVE_ENTRY_ACL_TYPE_ALLOW : if ( ace != NULL ) ace -> a_type = ACE_ACCESS_ALLOWED_ACE_TYPE ; else r = - 1 ; break ; case ARCHIVE_ENTRY_ACL_TYPE_DENY : if ( ace != NULL ) ace -> a_type = ACE_ACCESS_DENIED_ACE_TYPE ; else r = - 1 ; break ; case ARCHIVE_ENTRY_ACL_TYPE_AUDIT : if ( ace != NULL ) ace -> a_type = ACE_SYSTEM_AUDIT_ACE_TYPE ; else r = - 1 ; break ; case ARCHIVE_ENTRY_ACL_TYPE_ALARM : if ( ace != NULL ) ace -> a_type = ACE_SYSTEM_ALARM_ACE_TYPE ; else r = - 1 ; break ; #endif case ARCHIVE_ENTRY_ACL_TYPE_ACCESS : if ( aclent == NULL ) r = - 1 ; break ; case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT : if ( aclent != NULL ) aclent -> a_type |= ACL_DEFAULT ; else r = - 1 ; break ; default : archive_set_error ( a , ARCHIVE_ERRNO_MISC , "Unsupported ACL entry type" ) ; ret = ARCHIVE_FAILED ; goto exit_free ; } if ( r != 0 ) { errno = EINVAL ; archive_set_error ( a , errno , "Failed to set ACL entry type" ) ; ret = ARCHIVE_FAILED ; goto exit_free ; } #if ARCHIVE_ACL_SUNOS_NFS4 if ( ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4 ) { perm_map_size = acl_nfs4_perm_map_size ; perm_map = acl_nfs4_perm_map ; } else { #endif perm_map_size = acl_posix_perm_map_size ; perm_map = acl_posix_perm_map ; #if ARCHIVE_ACL_SUNOS_NFS4 } #endif for ( i = 0 ; i < perm_map_size ; ++ i ) { if ( ae_permset & perm_map [ i ] . a_perm ) { #if ARCHIVE_ACL_SUNOS_NFS4 if ( ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4 ) ace -> a_access_mask |= perm_map [ i ] . p_perm ; else #endif aclent -> a_perm |= perm_map [ i ] . p_perm ; } } #if ARCHIVE_ACL_SUNOS_NFS4 if ( ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4 ) { for ( i = 0 ; i < acl_nfs4_flag_map_size ; ++ i ) { if ( ae_permset & acl_nfs4_flag_map [ i ] . a_perm ) { ace -> a_flags |= acl_nfs4_flag_map [ i ] . p_perm ; } } } #endif e ++ ; } if ( fd >= 0 ) { if ( facl ( fd , cmd , entries , aclp ) == 0 ) ret = ARCHIVE_OK ; else { if ( errno == EOPNOTSUPP ) { ret = ARCHIVE_OK ; } else { archive_set_error ( a , errno , "Failed to set acl on fd: %s" , tname ) ; ret = ARCHIVE_WARN ; } } } else if ( acl ( name , cmd , entries , aclp ) != 0 ) { if ( errno == EOPNOTSUPP ) { ret = ARCHIVE_OK ; } else { archive_set_error ( a , errno , "Failed to set acl: %s" , tname ) ; ret = ARCHIVE_WARN ; } } exit_free : free ( aclp ) ; return ( ret ) ; }
parse_sym_line ( buf , which_set ) char * buf ; int which_set ; { int val , i ; struct symparse * symp ; char * bufp , * commentp , * altp ; mungspaces ( buf ) ; if ( ( commentp = rindex ( buf , '#' ) ) != 0 && commentp [ - 1 ] == ' ' ) commentp [ - 1 ] = '\0' ; bufp = index ( buf , '=' ) ; altp = index ( buf , ':' ) ; if ( ! bufp || ( altp && altp < bufp ) ) bufp = altp ; if ( ! bufp ) { if ( strncmpi ( buf , "finish" , 6 ) == 0 ) { if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; return 1 ; } config_error_add ( "No \"finish\"" ) ; return 0 ; } ++ bufp ; if ( * bufp == ' ' ) ++ bufp ; symp = match_sym ( buf ) ; if ( ! symp ) { config_error_add ( "Unknown sym keyword" ) ; return 0 ; } if ( ! symset [ which_set ] . name ) { if ( symp -> range == SYM_CONTROL ) { struct symsetentry * tmpsp , * lastsp ; for ( lastsp = symset_list ; lastsp ; lastsp = lastsp -> next ) if ( ! lastsp -> next ) break ; switch ( symp -> idx ) { case 0 : tmpsp = ( struct symsetentry * ) alloc ( sizeof * tmpsp ) ; tmpsp -> next = ( struct symsetentry * ) 0 ; if ( ! lastsp ) symset_list = tmpsp ; else lastsp -> next = tmpsp ; tmpsp -> idx = symset_count ++ ; tmpsp -> name = dupstr ( bufp ) ; tmpsp -> desc = ( char * ) 0 ; tmpsp -> handling = H_UNK ; tmpsp -> nocolor = 0 ; tmpsp -> primary = 0 ; tmpsp -> rogue = 0 ; break ; case 2 : tmpsp = lastsp ; for ( i = 0 ; known_handling [ i ] ; ++ i ) if ( ! strcmpi ( known_handling [ i ] , bufp ) ) { tmpsp -> handling = i ; break ; } break ; case 3 : tmpsp = lastsp ; if ( tmpsp && ! tmpsp -> desc ) tmpsp -> desc = dupstr ( bufp ) ; break ; case 5 : tmpsp = lastsp ; for ( i = 0 ; known_restrictions [ i ] ; ++ i ) { if ( ! strcmpi ( known_restrictions [ i ] , bufp ) ) { switch ( i ) { case 0 : tmpsp -> primary = 1 ; break ; case 1 : tmpsp -> rogue = 1 ; break ; } break ; } } break ; } } return 1 ; } if ( symp -> range ) { if ( symp -> range == SYM_CONTROL ) { switch ( symp -> idx ) { case 0 : if ( ! strcmpi ( bufp , symset [ which_set ] . name ) ) { chosen_symset_start = TRUE ; if ( which_set == ROGUESET ) init_rogue_symbols ( ) ; else if ( which_set == PRIMARY ) init_primary_symbols ( ) ; } break ; case 1 : if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; break ; case 2 : if ( chosen_symset_start ) set_symhandling ( bufp , which_set ) ; break ; case 4 : if ( chosen_symset_start ) { if ( bufp ) { if ( ! strcmpi ( bufp , "true" ) || ! strcmpi ( bufp , "yes" ) || ! strcmpi ( bufp , "on" ) ) symset [ which_set ] . nocolor = 0 ; else if ( ! strcmpi ( bufp , "false" ) || ! strcmpi ( bufp , "no" ) || ! strcmpi ( bufp , "off" ) ) symset [ which_set ] . nocolor = 1 ; } } break ; case 5 : if ( chosen_symset_start ) { int n = 0 ; while ( known_restrictions [ n ] ) { if ( ! strcmpi ( known_restrictions [ n ] , bufp ) ) { switch ( n ) { case 0 : symset [ which_set ] . primary = 1 ; break ; case 1 : symset [ which_set ] . rogue = 1 ; break ; } break ; } n ++ ; } } break ; } } else { val = sym_val ( bufp ) ; if ( chosen_symset_start ) { if ( which_set == PRIMARY ) { update_primary_symset ( symp , val ) ; } else if ( which_set == ROGUESET ) { update_rogue_symset ( symp , val ) ; } } } } return 1 ; }
static int ext4_dax_fault ( struct vm_area_struct * vma , struct vm_fault * vmf ) { int result ; handle_t * handle = NULL ; struct super_block * sb = file_inode ( vma -> vm_file ) -> i_sb ; bool write = vmf -> flags & FAULT_FLAG_WRITE ; if ( write ) { sb_start_pagefault ( sb ) ; file_update_time ( vma -> vm_file ) ; handle = ext4_journal_start_sb ( sb , EXT4_HT_WRITE_PAGE , EXT4_DATA_TRANS_BLOCKS ( sb ) ) ; } if ( IS_ERR ( handle ) ) result = VM_FAULT_SIGBUS ; else result = __dax_fault ( vma , vmf , ext4_get_block_dax , ext4_end_io_unwritten ) ; if ( write ) { if ( ! IS_ERR ( handle ) ) ext4_journal_stop ( handle ) ; sb_end_pagefault ( sb ) ; } return result ; }
static bool checkreturn decode_pointer_field ( pb_istream_t * stream , pb_wire_type_t wire_type , pb_field_iterator_t * iter ) { #ifndef PB_ENABLE_MALLOC UNUSED ( wire_type ) ; UNUSED ( iter ) ; PB_RETURN_ERROR ( stream , "no malloc support" ) ; #else pb_type_t type ; pb_decoder_t func ; type = iter -> pos -> type ; func = PB_DECODERS [ PB_LTYPE ( type ) ] ; switch ( PB_HTYPE ( type ) ) { case PB_HTYPE_REQUIRED : case PB_HTYPE_OPTIONAL : if ( PB_LTYPE ( type ) == PB_LTYPE_SUBMESSAGE && * ( void * * ) iter -> pData != NULL ) { pb_release_single_field ( iter ) ; } if ( PB_LTYPE ( type ) == PB_LTYPE_STRING || PB_LTYPE ( type ) == PB_LTYPE_BYTES ) { return func ( stream , iter -> pos , iter -> pData ) ; } else { if ( ! allocate_field ( stream , iter -> pData , iter -> pos -> data_size , 1 ) ) return false ; initialize_pointer_field ( * ( void * * ) iter -> pData , iter ) ; return func ( stream , iter -> pos , * ( void * * ) iter -> pData ) ; } case PB_HTYPE_REPEATED : if ( wire_type == PB_WT_STRING && PB_LTYPE ( type ) <= PB_LTYPE_LAST_PACKABLE ) { bool status = true ; size_t * size = ( size_t * ) iter -> pSize ; size_t allocated_size = * size ; void * pItem ; pb_istream_t substream ; if ( ! pb_make_string_substream ( stream , & substream ) ) return false ; while ( substream . bytes_left ) { if ( * size + 1 > allocated_size ) { allocated_size += ( substream . bytes_left - 1 ) / iter -> pos -> data_size + 1 ; if ( ! allocate_field ( & substream , iter -> pData , iter -> pos -> data_size , allocated_size ) ) { status = false ; break ; } } pItem = * ( uint8_t * * ) iter -> pData + iter -> pos -> data_size * ( * size ) ; initialize_pointer_field ( pItem , iter ) ; if ( ! func ( & substream , iter -> pos , pItem ) ) { status = false ; break ; } ( * size ) ++ ; } pb_close_string_substream ( stream , & substream ) ; return status ; } else { size_t * size = ( size_t * ) iter -> pSize ; void * pItem ; ( * size ) ++ ; if ( ! allocate_field ( stream , iter -> pData , iter -> pos -> data_size , * size ) ) return false ; pItem = * ( uint8_t * * ) iter -> pData + iter -> pos -> data_size * ( * size - 1 ) ; initialize_pointer_field ( pItem , iter ) ; return func ( stream , iter -> pos , pItem ) ; } default : PB_RETURN_ERROR ( stream , "invalid field type" ) ; } #endif }
max3421_urb_done ( struct usb_hcd * hcd ) { struct max3421_hcd * max3421_hcd = hcd_to_max3421 ( hcd ) ; unsigned long flags ; struct urb * urb ; int status ; status = max3421_hcd -> urb_done ; max3421_hcd -> urb_done = 0 ; if ( status > 0 ) status = 0 ; urb = max3421_hcd -> curr_urb ; if ( urb ) { max3421_hcd -> curr_urb = NULL ; spin_lock_irqsave ( & max3421_hcd -> lock , flags ) ; usb_hcd_unlink_urb_from_ep ( hcd , urb ) ; spin_unlock_irqrestore ( & max3421_hcd -> lock , flags ) ; usb_hcd_giveback_urb ( hcd , urb , status ) ; } return 1 ; }
void DefaultPlatform :: SetTimeFunctionForTesting ( DefaultPlatform :: TimeFunction time_function ) { base :: LockGuard < base :: Mutex > guard ( & lock_ ) ; time_function_for_testing_ = time_function ; DCHECK ( foreground_task_runner_map_ . empty ( ) ) ; }
void BytecodeGraphBuilder :: VisitStaInArrayLiteral ( ) { PrepareEagerCheckpoint ( ) ; Node * value = environment ( ) -> LookupAccumulator ( ) ; Node * array = environment ( ) -> LookupRegister ( bytecode_iterator ( ) . GetRegisterOperand ( 0 ) ) ; Node * index = environment ( ) -> LookupRegister ( bytecode_iterator ( ) . GetRegisterOperand ( 1 ) ) ; VectorSlotPair feedback = CreateVectorSlotPair ( bytecode_iterator ( ) . GetIndexOperand ( 2 ) ) ; const Operator * op = javascript ( ) -> StoreInArrayLiteral ( feedback ) ; JSTypeHintLowering :: LoweringResult lowering = TryBuildSimplifiedStoreKeyed ( op , array , index , value , feedback . slot ( ) ) ; if ( lowering . IsExit ( ) ) return ; Node * node = nullptr ; if ( lowering . IsSideEffectFree ( ) ) { node = lowering . value ( ) ; } else { DCHECK ( ! lowering . Changed ( ) ) ; node = NewNode ( op , array , index , value ) ; } environment ( ) -> RecordAfterState ( node , Environment :: kAttachFrameState ) ; }
void TracingCpuProfilerImpl :: StopProfiling ( ) { base :: LockGuard < base :: Mutex > lock ( & mutex_ ) ; if ( ! profiler_ ) return ; profiler_ -> StopProfiling ( "" ) ; profiler_ . reset ( ) ; }
TfLiteStatus ResizeOutputTensors ( TfLiteContext * context , TfLiteNode * node , const TfLiteTensor * axis , const TfLiteTensor * input , int num_splits ) { int axis_value = GetTensorData < int > ( axis ) [ 0 ] ; if ( axis_value < 0 ) { axis_value += NumDimensions ( input ) ; } TF_LITE_ENSURE ( context , axis_value >= 0 ) ; TF_LITE_ENSURE ( context , axis_value < NumDimensions ( input ) ) ; const int input_size = SizeOfDimension ( input , axis_value ) ; TF_LITE_ENSURE_MSG ( context , input_size % num_splits == 0 , "Not an even split" ) ; const int slice_size = input_size / num_splits ; for ( int i = 0 ; i < NumOutputs ( node ) ; ++ i ) { TfLiteIntArray * output_dims = TfLiteIntArrayCopy ( input -> dims ) ; output_dims -> data [ axis_value ] = slice_size ; TfLiteTensor * output ; TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , i , & output ) ) ; TF_LITE_ENSURE_STATUS ( context -> ResizeTensor ( context , output , output_dims ) ) ; } return kTfLiteOk ; }
QuotaManager :: Observe ( nsISupports * aSubject , const char * aTopic , const PRUnichar * aData ) { NS_ASSERTION ( NS_IsMainThread ( ) , "Wrong thread!" ) ; if ( ! strcmp ( aTopic , PROFILE_BEFORE_CHANGE_OBSERVER_ID ) ) { if ( PR_ATOMIC_SET ( & gShutdown , 1 ) ) { NS_ERROR ( "Shutdown more than once?!" ) ; } if ( IsMainProcess ( ) ) { FileService * service = FileService :: Get ( ) ; if ( service ) { nsTArray < uint32_t > indexes ; for ( uint32_t index = 0 ; index < Client :: TYPE_MAX ; index ++ ) { if ( mClients [ index ] -> IsFileServiceUtilized ( ) ) { indexes . AppendElement ( index ) ; } } StorageMatcher < nsTArray < nsCOMPtr < nsIFileStorage > > > liveStorages ; liveStorages . Find ( mLiveStorages , & indexes ) ; if ( ! liveStorages . IsEmpty ( ) ) { nsRefPtr < WaitForLockedFilesToFinishRunnable > runnable = new WaitForLockedFilesToFinishRunnable ( ) ; service -> WaitForStoragesToComplete ( liveStorages , runnable ) ; nsIThread * thread = NS_GetCurrentThread ( ) ; while ( runnable -> IsBusy ( ) ) { if ( ! NS_ProcessNextEvent ( thread ) ) { NS_ERROR ( "Failed to process next event!" ) ; break ; } } } } if ( NS_FAILED ( mIOThread -> Shutdown ( ) ) ) { NS_WARNING ( "Failed to shutdown IO thread!" ) ; } if ( NS_FAILED ( mShutdownTimer -> Init ( this , DEFAULT_SHUTDOWN_TIMER_MS , nsITimer :: TYPE_ONE_SHOT ) ) ) { NS_WARNING ( "Failed to initialize shutdown timer!" ) ; } for ( uint32_t index = 0 ; index < Client :: TYPE_MAX ; index ++ ) { mClients [ index ] -> ShutdownTransactionService ( ) ; } if ( NS_FAILED ( mShutdownTimer -> Cancel ( ) ) ) { NS_WARNING ( "Failed to cancel shutdown timer!" ) ; } } for ( uint32_t index = 0 ; index < Client :: TYPE_MAX ; index ++ ) { mClients [ index ] -> OnShutdownCompleted ( ) ; } return NS_OK ; } if ( ! strcmp ( aTopic , NS_TIMER_CALLBACK_TOPIC ) ) { NS_ASSERTION ( IsMainProcess ( ) , "Should only happen in the main process!" ) ; NS_WARNING ( "Some storage operations are taking longer than expected " "during shutdown and will be aborted!" ) ; StorageMatcher < nsAutoTArray < nsIOfflineStorage * , 50 > > liveStorages ; liveStorages . Find ( mLiveStorages ) ; if ( ! liveStorages . IsEmpty ( ) ) { uint32_t count = liveStorages . Length ( ) ; for ( uint32_t index = 0 ; index < count ; index ++ ) { liveStorages [ index ] -> Invalidate ( ) ; } } return NS_OK ; } if ( ! strcmp ( aTopic , TOPIC_WEB_APP_CLEAR_DATA ) ) { nsCOMPtr < mozIApplicationClearPrivateDataParams > params = do_QueryInterface ( aSubject ) ; NS_ENSURE_TRUE ( params , NS_ERROR_UNEXPECTED ) ; uint32_t appId ; nsresult rv = params -> GetAppId ( & appId ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; bool browserOnly ; rv = params -> GetBrowserOnly ( & browserOnly ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = ClearStoragesForApp ( appId , browserOnly ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; return NS_OK ; } NS_NOTREACHED ( "Unknown topic!" ) ; return NS_ERROR_UNEXPECTED ; }
nsListControlFrame :: ComboboxFinish ( int32_t aIndex ) { gLastKeyTime = 0 ; if ( mComboboxFrame ) { PerformSelection ( aIndex , false , false ) ; int32_t displayIndex = mComboboxFrame -> GetIndexOfDisplayArea ( ) ; nsWeakFrame weakFrame ( this ) ; if ( displayIndex != aIndex ) { mComboboxFrame -> RedisplaySelectedText ( ) ; } if ( weakFrame . IsAlive ( ) && mComboboxFrame ) { mComboboxFrame -> RollupFromList ( ) ; } } }
Response V8HeapProfilerAgentImpl :: addInspectedHeapObject ( const String16 & inspectedHeapObjectId ) { bool ok ; int id = inspectedHeapObjectId . toInteger ( & ok ) ; if ( ! ok ) return Response :: Error ( "Invalid heap snapshot object id" ) ; v8 :: HandleScope handles ( m_isolate ) ; v8 :: Local < v8 :: Object > heapObject = objectByHeapObjectId ( m_isolate , id ) ; if ( heapObject . IsEmpty ( ) ) return Response :: Error ( "Object is not available" ) ; if ( ! m_session -> inspector ( ) -> client ( ) -> isInspectableHeapObject ( heapObject ) ) return Response :: Error ( "Object is not available" ) ; m_session -> addInspectedObject ( std :: unique_ptr < InspectableHeapObject > ( new InspectableHeapObject ( id ) ) ) ; return Response :: OK ( ) ; }
void DeclarationVisitor :: Specialize ( const SpecializationKey & key , CallableNode * callable , const CallableNodeSignature * signature , Statement * body ) { Generic * generic = key . first ; CurrentSourcePosition :: Scope pos_scope ( generic -> declaration ( ) -> pos ) ; size_t generic_parameter_count = generic -> declaration ( ) -> generic_parameters . size ( ) ; if ( generic_parameter_count != key . second . size ( ) ) { std :: stringstream stream ; stream < < "number of template parameters (" < < std :: to_string ( key . second . size ( ) ) < < ") to intantiation of generic " < < callable -> name < < " doesnt match the generic's declaration (" < < std :: to_string ( generic_parameter_count ) < < ")" ; ReportError ( stream . str ( ) ) ; } Signature type_signature ; { Declarations :: GenericScopeActivator namespace_scope ( declarations ( ) , key ) ; DeclareSpecializedTypes ( key ) ; type_signature = MakeSignature ( signature ) ; } Visit ( callable , type_signature , body ) ; }
Reduction JSTypedLowering :: ReduceJSIncrement ( Node * node ) { Node * input = NodeProperties :: GetValueInput ( node , 0 ) ; Type input_type = NodeProperties :: GetType ( input ) ; if ( input_type . Is ( Type :: PlainPrimitive ( ) ) ) { node -> InsertInput ( graph ( ) -> zone ( ) , 1 , jsgraph ( ) -> OneConstant ( ) ) ; BinaryOperationHint hint = BinaryOperationHint :: kAny ; NodeProperties :: ChangeOp ( node , javascript ( ) -> Add ( hint ) ) ; JSBinopReduction r ( this , node ) ; r . ConvertInputsToNumber ( ) ; DCHECK_EQ ( simplified ( ) -> NumberAdd ( ) , r . NumberOp ( ) ) ; return r . ChangeToPureOperator ( r . NumberOp ( ) , Type :: Number ( ) ) ; } return NoChange ( ) ; }
Node * WasmGraphBuilder :: BuildI32Rol ( Node * left , Node * right ) { Int32Matcher m ( right ) ; if ( m . HasValue ( ) ) { return Binop ( wasm :: kExprI32Ror , left , mcgraph ( ) -> Int32Constant ( 32 - m . Value ( ) ) ) ; } else { return Binop ( wasm :: kExprI32Ror , left , Binop ( wasm :: kExprI32Sub , mcgraph ( ) -> Int32Constant ( 32 ) , right ) ) ; } }
RUNTIME_FUNCTION ( Runtime_RegExpExec ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 4 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSRegExp , regexp , 0 ) ; CONVERT_ARG_HANDLE_CHECKED ( String , subject , 1 ) ; CONVERT_INT32_ARG_CHECKED ( index , 2 ) ; CONVERT_ARG_HANDLE_CHECKED ( RegExpMatchInfo , last_match_info , 3 ) ; CHECK_LE ( 0 , index ) ; CHECK_GE ( subject -> length ( ) , index ) ; isolate -> counters ( ) -> regexp_entry_runtime ( ) -> Increment ( ) ; RETURN_RESULT_OR_FAILURE ( isolate , RegExpImpl :: Exec ( isolate , regexp , subject , index , last_match_info ) ) ; }
uint16_t AVRC_UnitCmd ( uint8_t handle , uint8_t label ) { BT_HDR * p_cmd = ( BT_HDR * ) osi_malloc ( AVRC_CMD_BUF_SIZE ) ; uint8_t * p_data ; p_cmd -> offset = AVCT_MSG_OFFSET ; p_data = ( uint8_t * ) ( p_cmd + 1 ) + p_cmd -> offset ; * p_data ++ = AVRC_CMD_STATUS ; * p_data ++ = ( AVRC_SUB_UNIT < < AVRC_SUBTYPE_SHIFT ) | AVRC_SUBID_IGNORE ; * p_data ++ = AVRC_OP_UNIT_INFO ; memset ( p_data , AVRC_CMD_OPRND_PAD , AVRC_UNIT_OPRND_BYTES ) ; p_cmd -> len = p_data + AVRC_UNIT_OPRND_BYTES - ( uint8_t * ) ( p_cmd + 1 ) - p_cmd -> offset ; p_cmd -> layer_specific = AVCT_DATA_CTRL ; return AVCT_MsgReq ( handle , label , AVCT_CMD , p_cmd ) ; }
void Heap :: ExternalStringTable :: CleanUpAll ( ) { CleanUpNewSpaceStrings ( ) ; int last = 0 ; Isolate * isolate = heap_ -> isolate ( ) ; for ( size_t i = 0 ; i < old_space_strings_ . size ( ) ; ++ i ) { Object * o = old_space_strings_ [ i ] ; if ( o -> IsTheHole ( isolate ) ) { continue ; } if ( o -> IsThinString ( ) ) continue ; DCHECK ( o -> IsExternalString ( ) ) ; DCHECK ( ! InNewSpace ( o ) ) ; old_space_strings_ [ last ++ ] = o ; } old_space_strings_ . resize ( last ) ; #ifdef VERIFY_HEAP if ( FLAG_verify_heap ) { Verify ( ) ; } #endif }
TNode < JSArray > GrowableFixedArray :: ToJSArray ( TNode < Context > const context ) { const ElementsKind kind = PACKED_ELEMENTS ; TNode < Context > const native_context = LoadNativeContext ( context ) ; TNode < Map > const array_map = LoadJSArrayElementsMap ( kind , native_context ) ; { Label next ( this ) ; TNode < IntPtrT > const length = var_length_ . value ( ) ; TNode < IntPtrT > const capacity = var_capacity_ . value ( ) ; GotoIf ( WordEqual ( length , capacity ) , & next ) ; var_array_ = ResizeFixedArray ( length , length ) ; var_capacity_ = length ; Goto ( & next ) ; BIND ( & next ) ; } TNode < Smi > const result_length = SmiTag ( length ( ) ) ; TNode < JSArray > const result = CAST ( AllocateUninitializedJSArrayWithoutElements ( array_map , result_length , nullptr ) ) ; StoreObjectField ( result , JSObject :: kElementsOffset , var_array_ . value ( ) ) ; return result ; }
PGTYPEStimestamp_from_asc ( char * str , char * * endptr ) { timestamp result ; #ifdef HAVE_INT64_TIMESTAMP int64 noresult = 0 ; #else double noresult = 0.0 ; #endif fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; if ( strlen ( str ) >= sizeof ( lowstr ) ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } break ; case DTK_EPOCH : result = SetEpochTimestamp ( ) ; break ; case DTK_LATE : TIMESTAMP_NOEND ( result ) ; break ; case DTK_EARLY : TIMESTAMP_NOBEGIN ( result ) ; break ; case DTK_INVALID : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; default : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } errno = 0 ; return result ; }
static void copyMono8 ( short * dst , const int * const * src , unsigned nSamples , unsigned ) { for ( unsigned i = 0 ; i < nSamples ; ++ i ) { * dst ++ = src [ 0 ] [ i ] < < 8 ; } }
status_t OMXNodeInstance :: getConfig ( OMX_INDEXTYPE index , void * params , size_t ) { Mutex :: Autolock autoLock ( mLock ) ; OMX_ERRORTYPE err = OMX_GetConfig ( mHandle , index , params ) ; OMX_INDEXEXTTYPE extIndex = ( OMX_INDEXEXTTYPE ) index ; if ( err != OMX_ErrorNoMore ) { CLOG_IF_ERROR ( getConfig , err , "%s(%#x)" , asString ( extIndex ) , index ) ; } return StatusFromOMXError ( err ) ; }
jit :: MakeLoopsContiguous ( MIRGraph & graph ) { for ( MBasicBlockIterator i ( graph . begin ( ) ) ; i != graph . end ( ) ; i ++ ) { MBasicBlock * header = * i ; if ( ! header -> isLoopHeader ( ) ) continue ; bool canOsr ; size_t numMarked = MarkLoopBlocks ( graph , header , & canOsr ) ; if ( numMarked == 0 ) continue ; MakeLoopContiguous ( graph , header , numMarked ) ; } return true ; }
static int compareFileMem ( const char * filename , const char * mem , int size ) { int res ; int fd ; char bytes [ 4096 ] ; int idx = 0 ; struct stat info ; if ( update_results ) { fd = open ( filename , WR_FLAGS , 0644 ) ; if ( fd < 0 ) { fprintf ( stderr , "failed to open %s for writing" , filename ) ; return ( - 1 ) ; } res = write ( fd , mem , size ) ; close ( fd ) ; return ( res != size ) ; } if ( stat ( filename , & info ) < 0 ) { fprintf ( stderr , "failed to stat %s\n" , filename ) ; return ( - 1 ) ; } if ( info . st_size != size ) { fprintf ( stderr , "file %s is %ld bytes, result is %d bytes\n" , filename , info . st_size , size ) ; return ( - 1 ) ; } fd = open ( filename , RD_FLAGS ) ; if ( fd < 0 ) { fprintf ( stderr , "failed to open %s for reading" , filename ) ; return ( - 1 ) ; } while ( idx < size ) { res = read ( fd , bytes , 4096 ) ; if ( res <= 0 ) break ; if ( res + idx > size ) break ; if ( memcmp ( bytes , & mem [ idx ] , res ) != 0 ) { int ix ; for ( ix = 0 ; ix < res ; ix ++ ) if ( bytes [ ix ] != mem [ idx + ix ] ) break ; fprintf ( stderr , "Compare error at position %d\n" , idx + ix ) ; close ( fd ) ; return ( 1 ) ; } idx += res ; } close ( fd ) ; if ( idx != size ) { fprintf ( stderr , "Compare error index %d, size %d\n" , idx , size ) ; } return ( idx != size ) ; }
Object * DeclareEvalHelper ( Isolate * isolate , Handle < String > name , Handle < Object > value ) { Handle < Context > context_arg ( isolate -> context ( ) , isolate ) ; Handle < Context > context ( context_arg -> declaration_context ( ) , isolate ) ; DCHECK ( context -> IsFunctionContext ( ) || context -> IsNativeContext ( ) || context -> IsScriptContext ( ) || context -> IsEvalContext ( ) || ( context -> IsBlockContext ( ) && context -> scope_info ( ) -> is_declaration_scope ( ) ) ) ; bool is_function = value -> IsJSFunction ( ) ; bool is_var = ! is_function ; DCHECK ( ! is_var || value -> IsUndefined ( isolate ) ) ; int index ; PropertyAttributes attributes ; InitializationFlag init_flag ; VariableMode mode ; const ContextLookupFlags lookup_flags = static_cast < ContextLookupFlags > ( FOLLOW_CONTEXT_CHAIN | STOP_AT_DECLARATION_SCOPE | SKIP_WITH_CONTEXT ) ; context_arg -> Lookup ( name , lookup_flags , & index , & attributes , & init_flag , & mode ) ; if ( attributes != ABSENT && IsLexicalVariableMode ( mode ) ) { return ThrowRedeclarationError ( isolate , name , RedeclarationType :: kSyntaxError ) ; } Handle < Object > holder = context -> Lookup ( name , DONT_FOLLOW_CHAINS , & index , & attributes , & init_flag , & mode ) ; DCHECK ( holder . is_null ( ) || ! holder -> IsModule ( ) ) ; DCHECK ( ! isolate -> has_pending_exception ( ) ) ; Handle < JSObject > object ; if ( attributes != ABSENT && holder -> IsJSGlobalObject ( ) ) { return DeclareGlobal ( isolate , Handle < JSGlobalObject > :: cast ( holder ) , name , value , NONE , is_var , is_function , RedeclarationType :: kTypeError ) ; } if ( context_arg -> extension ( ) -> IsJSGlobalObject ( ) ) { Handle < JSGlobalObject > global ( JSGlobalObject :: cast ( context_arg -> extension ( ) ) , isolate ) ; return DeclareGlobal ( isolate , global , name , value , NONE , is_var , is_function , RedeclarationType :: kTypeError ) ; } else if ( context -> IsScriptContext ( ) ) { DCHECK ( context -> global_object ( ) -> IsJSGlobalObject ( ) ) ; Handle < JSGlobalObject > global ( JSGlobalObject :: cast ( context -> global_object ( ) ) , isolate ) ; return DeclareGlobal ( isolate , global , name , value , NONE , is_var , is_function , RedeclarationType :: kTypeError ) ; } if ( attributes != ABSENT ) { DCHECK_EQ ( NONE , attributes ) ; if ( is_var ) return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; DCHECK ( is_function ) ; if ( index != Context :: kNotFound ) { DCHECK ( holder . is_identical_to ( context ) ) ; context -> set ( index , * value ) ; return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; } object = Handle < JSObject > :: cast ( holder ) ; } else if ( context -> has_extension ( ) ) { object = handle ( context -> extension_object ( ) , isolate ) ; DCHECK ( object -> IsJSContextExtensionObject ( ) || object -> IsJSGlobalObject ( ) ) ; } else { DCHECK ( ( context -> IsBlockContext ( ) && context -> scope_info ( ) -> is_declaration_scope ( ) ) || context -> IsFunctionContext ( ) ) ; object = isolate -> factory ( ) -> NewJSObject ( isolate -> context_extension_function ( ) ) ; context -> set_extension ( * object ) ; } RETURN_FAILURE_ON_EXCEPTION ( isolate , JSObject :: SetOwnPropertyIgnoreAttributes ( object , name , value , NONE ) ) ; return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
static int mem_cgroup_count_precharge_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , struct mm_walk * walk ) { struct vm_area_struct * vma = walk -> private ; pte_t * pte ; spinlock_t * ptl ; split_huge_page_pmd ( walk -> mm , pmd ) ; pte = pte_offset_map_lock ( vma -> vm_mm , pmd , addr , & ptl ) ; for ( ; addr != end ; pte ++ , addr += PAGE_SIZE ) if ( is_target_pte_for_mc ( vma , addr , * pte , NULL ) ) mc . precharge ++ ; pte_unmap_unlock ( pte - 1 , ptl ) ; cond_resched ( ) ; return 0 ; }
xmlNanoHTTPScanAnswer ( xmlNanoHTTPCtxtPtr ctxt , const char * line ) { const char * cur = line ; if ( line == NULL ) return ; if ( ! strncmp ( line , "HTTP/" , 5 ) ) { int version = 0 ; int ret = 0 ; cur += 5 ; while ( ( * cur >= '0' ) && ( * cur <= '9' ) ) { version *= 10 ; version += * cur - '0' ; cur ++ ; } if ( * cur == '.' ) { cur ++ ; if ( ( * cur >= '0' ) && ( * cur <= '9' ) ) { version *= 10 ; version += * cur - '0' ; cur ++ ; } while ( ( * cur >= '0' ) && ( * cur <= '9' ) ) cur ++ ; } else version *= 10 ; if ( ( * cur != ' ' ) && ( * cur != '\t' ) ) return ; while ( ( * cur == ' ' ) || ( * cur == '\t' ) ) cur ++ ; if ( ( * cur < '0' ) || ( * cur > '9' ) ) return ; while ( ( * cur >= '0' ) && ( * cur <= '9' ) ) { ret *= 10 ; ret += * cur - '0' ; cur ++ ; } if ( ( * cur != 0 ) && ( * cur != ' ' ) && ( * cur != '\t' ) ) return ; ctxt -> returnValue = ret ; ctxt -> version = version ; } else if ( ! xmlStrncasecmp ( BAD_CAST line , BAD_CAST "Content-Type:" , 13 ) ) { const xmlChar * charset , * last , * mime ; cur += 13 ; while ( ( * cur == ' ' ) || ( * cur == '\t' ) ) cur ++ ; if ( ctxt -> contentType != NULL ) xmlFree ( ctxt -> contentType ) ; ctxt -> contentType = xmlMemStrdup ( cur ) ; mime = ( const xmlChar * ) cur ; last = mime ; while ( ( * last != 0 ) && ( * last != ' ' ) && ( * last != '\t' ) && ( * last != ';' ) && ( * last != ',' ) ) last ++ ; if ( ctxt -> mimeType != NULL ) xmlFree ( ctxt -> mimeType ) ; ctxt -> mimeType = ( char * ) xmlStrndup ( mime , last - mime ) ; charset = xmlStrstr ( BAD_CAST ctxt -> contentType , BAD_CAST "charset=" ) ; if ( charset != NULL ) { charset += 8 ; last = charset ; while ( ( * last != 0 ) && ( * last != ' ' ) && ( * last != '\t' ) && ( * last != ';' ) && ( * last != ',' ) ) last ++ ; if ( ctxt -> encoding != NULL ) xmlFree ( ctxt -> encoding ) ; ctxt -> encoding = ( char * ) xmlStrndup ( charset , last - charset ) ; } } else if ( ! xmlStrncasecmp ( BAD_CAST line , BAD_CAST "ContentType:" , 12 ) ) { const xmlChar * charset , * last , * mime ; cur += 12 ; if ( ctxt -> contentType != NULL ) return ; while ( ( * cur == ' ' ) || ( * cur == '\t' ) ) cur ++ ; ctxt -> contentType = xmlMemStrdup ( cur ) ; mime = ( const xmlChar * ) cur ; last = mime ; while ( ( * last != 0 ) && ( * last != ' ' ) && ( * last != '\t' ) && ( * last != ';' ) && ( * last != ',' ) ) last ++ ; if ( ctxt -> mimeType != NULL ) xmlFree ( ctxt -> mimeType ) ; ctxt -> mimeType = ( char * ) xmlStrndup ( mime , last - mime ) ; charset = xmlStrstr ( BAD_CAST ctxt -> contentType , BAD_CAST "charset=" ) ; if ( charset != NULL ) { charset += 8 ; last = charset ; while ( ( * last != 0 ) && ( * last != ' ' ) && ( * last != '\t' ) && ( * last != ';' ) && ( * last != ',' ) ) last ++ ; if ( ctxt -> encoding != NULL ) xmlFree ( ctxt -> encoding ) ; ctxt -> encoding = ( char * ) xmlStrndup ( charset , last - charset ) ; } } else if ( ! xmlStrncasecmp ( BAD_CAST line , BAD_CAST "Location:" , 9 ) ) { cur += 9 ; while ( ( * cur == ' ' ) || ( * cur == '\t' ) ) cur ++ ; if ( ctxt -> location != NULL ) xmlFree ( ctxt -> location ) ; if ( * cur == '/' ) { xmlChar * tmp_http = xmlStrdup ( BAD_CAST "http://" ) ; xmlChar * tmp_loc = xmlStrcat ( tmp_http , ( const xmlChar * ) ctxt -> hostname ) ; ctxt -> location = ( char * ) xmlStrcat ( tmp_loc , ( const xmlChar * ) cur ) ; } else { ctxt -> location = xmlMemStrdup ( cur ) ; } } else if ( ! xmlStrncasecmp ( BAD_CAST line , BAD_CAST "WWW-Authenticate:" , 17 ) ) { cur += 17 ; while ( ( * cur == ' ' ) || ( * cur == '\t' ) ) cur ++ ; if ( ctxt -> authHeader != NULL ) xmlFree ( ctxt -> authHeader ) ; ctxt -> authHeader = xmlMemStrdup ( cur ) ; } else if ( ! xmlStrncasecmp ( BAD_CAST line , BAD_CAST "Proxy-Authenticate:" , 19 ) ) { cur += 19 ; while ( ( * cur == ' ' ) || ( * cur == '\t' ) ) cur ++ ; if ( ctxt -> authHeader != NULL ) xmlFree ( ctxt -> authHeader ) ; ctxt -> authHeader = xmlMemStrdup ( cur ) ; #ifdef HAVE_ZLIB_H } else if ( ! xmlStrncasecmp ( BAD_CAST line , BAD_CAST "Content-Encoding:" , 17 ) ) { cur += 17 ; while ( ( * cur == ' ' ) || ( * cur == '\t' ) ) cur ++ ; if ( ! xmlStrncasecmp ( BAD_CAST cur , BAD_CAST "gzip" , 4 ) ) { ctxt -> usesGzip = 1 ; ctxt -> strm = xmlMalloc ( sizeof ( z_stream ) ) ; if ( ctxt -> strm != NULL ) { ctxt -> strm -> zalloc = Z_NULL ; ctxt -> strm -> zfree = Z_NULL ; ctxt -> strm -> opaque = Z_NULL ; ctxt -> strm -> avail_in = 0 ; ctxt -> strm -> next_in = Z_NULL ; inflateInit2 ( ctxt -> strm , 31 ) ; } } #endif } else if ( ! xmlStrncasecmp ( BAD_CAST line , BAD_CAST "Content-Length:" , 15 ) ) { cur += 15 ; ctxt -> ContentLength = strtol ( cur , NULL , 10 ) ; } }
WebGLTexture :: EnsureInitializedImageData ( TexImageTarget imageTarget , GLint level ) { const ImageInfo & imageInfo = ImageInfoAt ( imageTarget , level ) ; if ( ! imageInfo . HasUninitializedImageData ( ) ) return true ; mContext -> MakeContextCurrent ( ) ; if ( imageTarget == LOCAL_GL_TEXTURE_2D ) { bool cleared = ClearWithTempFB ( mContext , mGLName , imageTarget , level , imageInfo . mEffectiveInternalFormat , imageInfo . mHeight , imageInfo . mWidth ) ; if ( cleared ) { SetImageDataStatus ( imageTarget , level , WebGLImageDataStatus :: InitializedImageData ) ; return true ; } } size_t bitspertexel = GetBitsPerTexel ( imageInfo . mEffectiveInternalFormat ) ; MOZ_ASSERT ( ( bitspertexel % 8 ) == 0 ) ; size_t bytespertexel = bitspertexel / 8 ; CheckedUint32 checked_byteLength = WebGLContext :: GetImageSize ( imageInfo . mHeight , imageInfo . mWidth , imageInfo . mDepth , bytespertexel , mContext -> mPixelStoreUnpackAlignment ) ; MOZ_ASSERT ( checked_byteLength . isValid ( ) ) ; size_t byteCount = checked_byteLength . value ( ) ; UniquePtr < uint8_t > zeros ( ( uint8_t * ) calloc ( 1 , byteCount ) ) ; if ( zeros == nullptr ) { mContext -> ForceLoseContext ( true ) ; mContext -> ErrorOutOfMemory ( "EnsureInitializedImageData: Failed to alloc %u " "bytes to clear image target `%s` level `%d`." , byteCount , mContext -> EnumName ( imageTarget . get ( ) ) , level ) ; return false ; } gl :: GLContext * gl = mContext -> gl ; gl :: ScopedBindTexture autoBindTex ( gl , mGLName , mTarget ) ; GLenum driverInternalFormat = LOCAL_GL_NONE ; GLenum driverFormat = LOCAL_GL_NONE ; GLenum driverType = LOCAL_GL_NONE ; DriverFormatsFromEffectiveInternalFormat ( gl , imageInfo . mEffectiveInternalFormat , & driverInternalFormat , & driverFormat , & driverType ) ; mContext -> GetAndFlushUnderlyingGLErrors ( ) ; if ( imageTarget == LOCAL_GL_TEXTURE_3D ) { MOZ_ASSERT ( mImmutable , "Shouldn't be possible to have non-immutable-format 3D" " textures in WebGL" ) ; gl -> fTexSubImage3D ( imageTarget . get ( ) , level , 0 , 0 , 0 , imageInfo . mWidth , imageInfo . mHeight , imageInfo . mDepth , driverFormat , driverType , zeros . get ( ) ) ; } else { if ( mImmutable ) { gl -> fTexSubImage2D ( imageTarget . get ( ) , level , 0 , 0 , imageInfo . mWidth , imageInfo . mHeight , driverFormat , driverType , zeros . get ( ) ) ; } else { gl -> fTexImage2D ( imageTarget . get ( ) , level , driverInternalFormat , imageInfo . mWidth , imageInfo . mHeight , 0 , driverFormat , driverType , zeros . get ( ) ) ; } } GLenum error = mContext -> GetAndFlushUnderlyingGLErrors ( ) ; if ( error ) { gfxCriticalError ( ) < < "GL context GetAndFlushUnderlyingGLErrors " < < gfx :: hexa ( error ) ; printf_stderr ( "Error: 0x%4x\n" , error ) ; if ( error != LOCAL_GL_OUT_OF_MEMORY ) { mContext -> ForceLoseContext ( true ) ; return false ; } mContext -> ForceLoseContext ( true ) ; mContext -> ErrorOutOfMemory ( "EnsureNoUninitializedImageData: Failed to " "upload texture of width: %u, height: %u, " "depth: %u to target %s level %d." , imageInfo . mWidth , imageInfo . mHeight , imageInfo . mDepth , mContext -> EnumName ( imageTarget . get ( ) ) , level ) ; return false ; } SetImageDataStatus ( imageTarget , level , WebGLImageDataStatus :: InitializedImageData ) ; return true ; }
DataTextureSourceD3D11 :: Update ( DataSourceSurface * aSurface , nsIntRegion * aDestRegion , IntPoint * aSrcOffset ) { MOZ_ASSERT ( ! aSrcOffset ) ; MOZ_ASSERT ( aSurface ) ; HRESULT hr ; if ( ! mCompositor || ! mCompositor -> GetDevice ( ) ) { return false ; } uint32_t bpp = BytesPerPixel ( aSurface -> GetFormat ( ) ) ; DXGI_FORMAT dxgiFormat = SurfaceFormatToDXGIFormat ( aSurface -> GetFormat ( ) ) ; mSize = aSurface -> GetSize ( ) ; mFormat = aSurface -> GetFormat ( ) ; CD3D11_TEXTURE2D_DESC desc ( dxgiFormat , mSize . width , mSize . height , 1 , 1 ) ; int32_t maxSize = mCompositor -> GetMaxTextureSize ( ) ; if ( ( mSize . width <= maxSize && mSize . height <= maxSize ) || ( mFlags & TextureFlags :: DISALLOW_BIGIMAGE ) ) { if ( mTexture ) { D3D11_TEXTURE2D_DESC currentDesc ; mTexture -> GetDesc ( & currentDesc ) ; if ( currentDesc . Width != mSize . width || currentDesc . Height != mSize . height || currentDesc . Format != dxgiFormat ) { mTexture = nullptr ; aDestRegion = nullptr ; } } if ( ! mTexture ) { hr = mCompositor -> GetDevice ( ) -> CreateTexture2D ( & desc , nullptr , byRef ( mTexture ) ) ; mIsTiled = false ; if ( FAILED ( hr ) || ! mTexture ) { Reset ( ) ; return false ; } } DataSourceSurface :: MappedSurface map ; aSurface -> Map ( DataSourceSurface :: MapType :: READ , & map ) ; if ( aDestRegion ) { nsIntRegionRectIterator iter ( * aDestRegion ) ; const IntRect * iterRect ; while ( ( iterRect = iter . Next ( ) ) ) { D3D11_BOX box ; box . front = 0 ; box . back = 1 ; box . left = iterRect -> x ; box . top = iterRect -> y ; box . right = iterRect -> XMost ( ) ; box . bottom = iterRect -> YMost ( ) ; void * data = map . mData + map . mStride * iterRect -> y + BytesPerPixel ( aSurface -> GetFormat ( ) ) * iterRect -> x ; mCompositor -> GetDC ( ) -> UpdateSubresource ( mTexture , 0 , & box , data , map . mStride , map . mStride * mSize . height ) ; } } else { mCompositor -> GetDC ( ) -> UpdateSubresource ( mTexture , 0 , nullptr , aSurface -> GetData ( ) , aSurface -> Stride ( ) , aSurface -> Stride ( ) * mSize . height ) ; } aSurface -> Unmap ( ) ; } else { mIsTiled = true ; uint32_t tileCount = GetRequiredTilesD3D11 ( mSize . width , maxSize ) * GetRequiredTilesD3D11 ( mSize . height , maxSize ) ; mTileTextures . resize ( tileCount ) ; mTexture = nullptr ; for ( uint32_t i = 0 ; i < tileCount ; i ++ ) { IntRect tileRect = GetTileRect ( i ) ; desc . Width = tileRect . width ; desc . Height = tileRect . height ; desc . Usage = D3D11_USAGE_IMMUTABLE ; D3D11_SUBRESOURCE_DATA initData ; initData . pSysMem = aSurface -> GetData ( ) + tileRect . y * aSurface -> Stride ( ) + tileRect . x * bpp ; initData . SysMemPitch = aSurface -> Stride ( ) ; hr = mCompositor -> GetDevice ( ) -> CreateTexture2D ( & desc , & initData , byRef ( mTileTextures [ i ] ) ) ; if ( FAILED ( hr ) || ! mTileTextures [ i ] ) { Reset ( ) ; return false ; } } } return true ; }
nsSHistory :: nsSHistory ( BrowsingContext * aRootBC ) : mRootBC ( aRootBC ) , mHasOngoingUpdate ( false ) , mIndex ( - 1 ) , mRequestedIndex ( - 1 ) , mRootDocShellID ( aRootBC -> GetHistoryID ( ) ) { static bool sCalledStartup = false ; if ( ! sCalledStartup ) { Startup ( ) ; sCalledStartup = true ; } gSHistoryList . mList . insertBack ( this ) ; mHistoryTracker = mozilla :: MakeUnique < HistoryTracker > ( this , mozilla :: Preferences :: GetUint ( CONTENT_VIEWER_TIMEOUT_SECONDS , CONTENT_VIEWER_TIMEOUT_SECONDS_DEFAULT ) , GetCurrentSerialEventTarget ( ) ) ; }
DnsTlsSocket :: ~ DnsTlsSocket ( ) { ALOGV ( "Destructor" ) ; mIpcInFd . reset ( ) ; { std :: lock_guard < std :: mutex > guard ( mLock ) ; if ( mLoopThread && std :: this_thread :: get_id ( ) == mLoopThread -> get_id ( ) ) { ALOGE ( "Violation of re-entrance precondition" ) ; return ; } } if ( mLoopThread ) { ALOGV ( "Waiting for loop thread to terminate" ) ; mLoopThread -> join ( ) ; mLoopThread . reset ( ) ; } ALOGV ( "Destructor completed" ) ; }
static bool EnsureImageDataInitializedForUpload ( WebGLTexture * tex , TexImageTarget target , uint32_t level , const uvec3 & offset , const uvec3 & size , webgl :: ImageInfo * imageInfo ) { if ( ! imageInfo -> mUninitializedSlices ) return true ; if ( size . x == imageInfo -> mWidth && size . y == imageInfo -> mHeight ) { for ( const auto z : IntegerRange ( offset . z , offset . z + size . z ) ) { ( * imageInfo -> mUninitializedSlices ) [ z ] = false ; } bool hasUninitialized = false ; for ( const auto z : IntegerRange ( imageInfo -> mDepth ) ) { hasUninitialized |= ( * imageInfo -> mUninitializedSlices ) [ z ] ; } if ( ! hasUninitialized ) { imageInfo -> mUninitializedSlices = Nothing ( ) ; } return true ; } WebGLContext * webgl = tex -> mContext ; webgl -> GenerateWarning ( "Texture has not been initialized prior to a" " partial upload, forcing the browser to clear it." " This may be slow." ) ; if ( ! tex -> EnsureImageDataInitialized ( target , level ) ) { MOZ_ASSERT ( false , "Unexpected failure to init image data." ) ; return false ; } return true ; }
void Compute ( OpKernelContext * context ) override { const Tensor & diagonal = context -> input ( 0 ) ; int32_t lower_diag_index = 0 ; int32_t upper_diag_index = 0 ; int32_t num_rows = - 1 ; int32_t num_cols = - 1 ; T padding_value ( 0 ) ; if ( context -> num_inputs ( ) > kNumV1Inputs ) { auto & diag_index = context -> input ( 1 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( diag_index . shape ( ) ) || TensorShapeUtils :: IsVector ( diag_index . shape ( ) ) , errors :: InvalidArgument ( "diag_index must be a scalar or vector, received shape: " , diag_index . shape ( ) . DebugString ( ) ) ) ; lower_diag_index = diag_index . flat < int32 > ( ) ( 0 ) ; upper_diag_index = lower_diag_index ; if ( TensorShapeUtils :: IsVector ( diag_index . shape ( ) ) ) { auto diag_index_size = diag_index . dim_size ( 0 ) ; OP_REQUIRES ( context , 0 < diag_index_size && diag_index_size <= 2 , errors :: InvalidArgument ( "diag_index must have only one or two elements, received " , diag_index_size , " elements." ) ) ; if ( diag_index_size > 1 ) { upper_diag_index = diag_index . flat < int32 > ( ) ( 1 ) ; } } auto & num_rows_tensor = context -> input ( 2 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( num_rows_tensor . shape ( ) ) , errors :: InvalidArgument ( "num_rows must be a scalar" ) ) ; num_rows = num_rows_tensor . flat < int32 > ( ) ( 0 ) ; auto & num_cols_tensor = context -> input ( 3 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( num_cols_tensor . shape ( ) ) , errors :: InvalidArgument ( "num_cols must be a scalar" ) ) ; num_cols = num_cols_tensor . flat < int32 > ( ) ( 0 ) ; auto & padding_value_tensor = context -> input ( 4 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( padding_value_tensor . shape ( ) ) , errors :: InvalidArgument ( "padding_value must be a scalar" ) ) ; padding_value = padding_value_tensor . flat < T > ( ) ( 0 ) ; } const TensorShape & diagonal_shape = diagonal . shape ( ) ; const int diag_rank = diagonal_shape . dims ( ) ; const Eigen :: Index num_diags = upper_diag_index - lower_diag_index + 1 ; OP_REQUIRES ( context , TensorShapeUtils :: IsVectorOrHigher ( diagonal_shape ) , errors :: InvalidArgument ( "diagonal must be at least 1-dim, received shape: " , diagonal . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , lower_diag_index <= upper_diag_index , errors :: InvalidArgument ( "lower_diag_index must not be larger than upper_diag_index: " , lower_diag_index , " > " , upper_diag_index ) ) ; OP_REQUIRES ( context , lower_diag_index == upper_diag_index || diagonal_shape . dim_size ( diag_rank - 2 ) == num_diags , errors :: InvalidArgument ( "The number of diagonals provided in the input does not " "match the lower_diag_index and upper_diag_index range." ) ) ; const Eigen :: Index max_diag_len = diagonal_shape . dim_size ( diag_rank - 1 ) ; const int32_t min_num_rows = max_diag_len - std :: min ( upper_diag_index , 0 ) ; const int32_t min_num_cols = max_diag_len + std :: max ( lower_diag_index , 0 ) ; OP_REQUIRES ( context , num_rows == - 1 || num_rows >= min_num_rows , errors :: InvalidArgument ( "The number of rows is too small." ) ) ; OP_REQUIRES ( context , num_cols == - 1 || num_cols >= min_num_cols , errors :: InvalidArgument ( "The number of columns is too small." ) ) ; if ( num_rows == - 1 && num_cols == - 1 ) { num_rows = std :: max ( min_num_rows , min_num_cols ) ; num_cols = num_rows ; } else if ( num_rows == - 1 ) { num_rows = min_num_rows ; } else if ( num_cols == - 1 ) { num_cols = min_num_cols ; } OP_REQUIRES ( context , num_rows == min_num_rows || num_cols == min_num_cols , errors :: InvalidArgument ( "The number of rows or columns is not consistent with " "the specified d_lower, d_upper, and diagonal." ) ) ; TensorShape output_shape = diagonal_shape ; if ( num_diags == 1 ) { output_shape . set_dim ( diag_rank - 1 , num_rows ) ; output_shape . AddDim ( num_cols ) ; } else { output_shape . set_dim ( diag_rank - 2 , num_rows ) ; output_shape . set_dim ( diag_rank - 1 , num_cols ) ; } Tensor * output = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , output_shape , & output ) ) ; auto output_reshaped = output -> flat_inner_dims < T , 3 > ( ) ; auto diag_reshaped = diagonal . flat < T > ( ) ; functor :: MatrixDiag < Device , T > :: Compute ( context , context -> eigen_device < Device > ( ) , diag_reshaped , output_reshaped , lower_diag_index , upper_diag_index , max_diag_len , padding_value , left_align_superdiagonal_ , left_align_subdiagonal_ ) ; }
init_device ( u2fh_devs * devs , struct u2fdevice * dev ) { unsigned char resp [ 1024 ] ; unsigned char nonce [ 8 ] ; if ( obtain_nonce ( nonce ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } size_t resplen = sizeof ( resp ) ; dev -> cid = CID_BROADCAST ; if ( u2fh_sendrecv ( devs , dev -> id , U2FHID_INIT , nonce , sizeof ( nonce ) , resp , & resplen ) == U2FH_OK ) { U2FHID_INIT_RESP initresp ; if ( resplen > sizeof ( initresp ) ) { return U2FH_MEMORY_ERROR ; } memcpy ( & initresp , resp , resplen ) ; dev -> cid = initresp . cid ; dev -> versionInterface = initresp . versionInterface ; dev -> versionMajor = initresp . versionMajor ; dev -> versionMinor = initresp . versionMinor ; dev -> capFlags = initresp . capFlags ; } else { return U2FH_TRANSPORT_ERROR ; } return U2FH_OK ; }
safe_fprintf ( FILE * f , const char * fmt , ... ) { char fmtbuff_stack [ 256 ] ; char outbuff [ 256 ] ; char * fmtbuff_heap ; char * fmtbuff ; int fmtbuff_length ; int length , n ; va_list ap ; const char * p ; unsigned i ; wchar_t wc ; char try_wc ; fmtbuff_heap = NULL ; fmtbuff_length = sizeof ( fmtbuff_stack ) ; fmtbuff = fmtbuff_stack ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; while ( length < 0 || length >= fmtbuff_length ) { if ( length >= fmtbuff_length ) fmtbuff_length = length + 1 ; else if ( fmtbuff_length < 8192 ) fmtbuff_length *= 2 ; else if ( fmtbuff_length < 1000000 ) fmtbuff_length += fmtbuff_length / 4 ; else { length = fmtbuff_length ; fmtbuff_heap [ length - 1 ] = '\0' ; break ; } free ( fmtbuff_heap ) ; fmtbuff_heap = malloc ( fmtbuff_length ) ; if ( fmtbuff_heap != NULL ) { fmtbuff = fmtbuff_heap ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; } else { length = sizeof ( fmtbuff_stack ) - 1 ; break ; } } if ( mbtowc ( NULL , NULL , 1 ) == - 1 ) { free ( fmtbuff_heap ) ; return ; } p = fmtbuff ; i = 0 ; try_wc = 1 ; while ( * p != '\0' ) { if ( try_wc && ( n = mbtowc ( & wc , p , length ) ) != - 1 ) { length -= n ; if ( iswprint ( wc ) && wc != L'\\' ) { while ( n -- > 0 ) outbuff [ i ++ ] = * p ++ ; } else { while ( n -- > 0 ) i += ( unsigned ) bsdtar_expand_char ( outbuff , i , * p ++ ) ; } } else { i += ( unsigned ) bsdtar_expand_char ( outbuff , i , * p ++ ) ; try_wc = 0 ; } if ( i > ( sizeof ( outbuff ) - 20 ) ) { outbuff [ i ] = '\0' ; fprintf ( f , "%s" , outbuff ) ; i = 0 ; } } outbuff [ i ] = '\0' ; fprintf ( f , "%s" , outbuff ) ; free ( fmtbuff_heap ) ; }
nsresult nsContentUtils :: ConvertToPlainText ( const nsAString & aSourceBuffer , nsAString & aResultBuffer , uint32_t aFlags , uint32_t aWrapCol ) { nsCOMPtr < nsIURI > uri ; NS_NewURI ( getter_AddRefs ( uri ) , "about:blank" ) ; nsCOMPtr < nsIPrincipal > principal = NullPrincipal :: CreateWithoutOriginAttributes ( ) ; RefPtr < Document > document ; nsresult rv = NS_NewDOMDocument ( getter_AddRefs ( document ) , u""_ns , u""_ns , nullptr , uri , uri , principal , true , nullptr , DocumentFlavorHTML ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = nsContentUtils :: ParseDocumentHTML ( aSourceBuffer , document , ! ( aFlags & nsIDocumentEncoder :: OutputNoScriptContent ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIDocumentEncoder > encoder = do_createDocumentEncoder ( "text/plain" ) ; rv = encoder -> Init ( document , u"text/plain"_ns , aFlags ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; encoder -> SetWrapColumn ( aWrapCol ) ; return encoder -> EncodeToString ( aResultBuffer ) ; }
void jas_matrix_clip ( jas_matrix_t * matrix , jas_seqent_t minval , jas_seqent_t maxval ) { int i ; int j ; jas_seqent_t v ; jas_seqent_t * rowstart ; jas_seqent_t * data ; int rowstep ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { data = rowstart ; for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { v = * data ; if ( v < minval ) { * data = minval ; } else if ( v > maxval ) { * data = maxval ; } } } } }
nsJSContext :: CallEventHandler ( nsISupports * aTarget , JSObject * aScope , JSObject * aHandler , nsIArray * aargv , nsIVariant * * arv ) { NS_ENSURE_TRUE ( mIsInitialized , NS_ERROR_NOT_INITIALIZED ) ; if ( ! mScriptsEnabled ) { return NS_OK ; } SAMPLE_LABEL ( "JS" , "CallEventHandler" ) ; nsAutoMicroTask mt ; xpc_UnmarkGrayObject ( aScope ) ; xpc_UnmarkGrayObject ( aHandler ) ; XPCAutoRequest ar ( mContext ) ; JSObject * target = nullptr ; nsresult rv = JSObjectFromInterface ( aTarget , aScope , & target ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; JS :: AutoObjectRooter targetVal ( mContext , target ) ; jsval rval = JSVAL_VOID ; nsCxPusher pusher ; if ( ! pusher . Push ( mContext , true ) ) return NS_ERROR_FAILURE ; rv = sSecurityManager -> CheckFunctionAccess ( mContext , aHandler , target ) ; nsJSContext :: TerminationFuncHolder holder ( this ) ; if ( NS_SUCCEEDED ( rv ) ) { uint32_t argc = 0 ; jsval * argv = nullptr ; JSObject * funobj = aHandler ; jsval funval = OBJECT_TO_JSVAL ( funobj ) ; JSAutoCompartment ac ( mContext , funobj ) ; if ( ! JS_WrapObject ( mContext , & target ) ) { ReportPendingException ( ) ; return NS_ERROR_FAILURE ; } Maybe < nsRootedJSValueArray > tempStorage ; rv = ConvertSupportsTojsvals ( aargv , target , & argc , & argv , tempStorage ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; for ( uint32_t i = 0 ; i < argc ; i ++ ) { if ( ! JSVAL_IS_PRIMITIVE ( argv [ i ] ) ) { xpc_UnmarkGrayObject ( JSVAL_TO_OBJECT ( argv [ i ] ) ) ; } } ++ mExecuteDepth ; bool ok = :: JS_CallFunctionValue ( mContext , target , funval , argc , argv , & rval ) ; -- mExecuteDepth ; if ( ! ok ) { rval = JSVAL_VOID ; rv = NS_ERROR_FAILURE ; } else if ( rval == JSVAL_NULL ) { * arv = nullptr ; } else if ( ! JS_WrapValue ( mContext , & rval ) ) { rv = NS_ERROR_FAILURE ; } else { rv = nsContentUtils :: XPConnect ( ) -> JSToVariant ( mContext , rval , arv ) ; } if ( NS_FAILED ( rv ) ) ReportPendingException ( ) ; } pusher . Pop ( ) ; ScriptEvaluated ( true ) ; return rv ; }
MediaRecorder :: MediaRecorder ( const String16 & opPackageName ) : mSurfaceMediaSource ( NULL ) { ALOGV ( "constructor" ) ; const sp < IMediaPlayerService > & service ( getMediaPlayerService ( ) ) ; if ( service != NULL ) { mMediaRecorder = service -> createMediaRecorder ( opPackageName ) ; } if ( mMediaRecorder != NULL ) { mCurrentState = MEDIA_RECORDER_IDLE ; } doCleanUp ( ) ; }
v8 :: Local < v8 :: ObjectTemplate > GetInstanceTemplate ( ) { v8 :: EscapableHandleScope scope ( m_pIsolate ) ; v8 :: Local < v8 :: FunctionTemplate > function = m_FunctionTemplate . Get ( m_pIsolate ) ; return scope . Escape ( function -> InstanceTemplate ( ) ) ; }
already_AddRefed < SharedWorkerService > SharedWorkerService :: GetOrCreate ( ) { AssertIsOnBackgroundThread ( ) ; StaticMutexAutoLock lock ( sSharedWorkerMutex ) ; if ( sSharedWorkerService ) { RefPtr < SharedWorkerService > instance = sSharedWorkerService . get ( ) ; return instance . forget ( ) ; } RefPtr < SharedWorkerService > instance = new SharedWorkerService ( ) ; return instance . forget ( ) ; }
static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state ) { struct file * filp ; int ret ; if ( nd -> intent . open . flags & FMODE_EXEC ) { ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , nd -> intent . open . flags ) ; if ( ret < 0 ) goto out_close ; } filp = lookup_instantiate_filp ( nd , path -> dentry , NULL ) ; if ( ! IS_ERR ( filp ) ) { struct nfs_open_context * ctx ; ctx = nfs_file_open_context ( filp ) ; ctx -> state = state ; return 0 ; } ret = PTR_ERR ( filp ) ; out_close : nfs4_close_sync ( path , state , nd -> intent . open . flags ) ; return ret ; }
f_mzeval ( typval_T * argvars , typval_T * rettv ) { char_u * str ; char_u buf [ NUMBUFLEN ] ; str = tv_get_string_buf ( & argvars [ 0 ] , buf ) ; do_mzeval ( str , rettv ) ; }
std :: string utf16ToUtf8 ( const StringPiece16 & utf16 ) { ssize_t utf8Length = utf16_to_utf8_length ( utf16 . data ( ) , utf16 . length ( ) ) ; if ( utf8Length <= 0 ) { return { } ; } std :: string utf8 ; utf8 . resize ( utf8Length ) ; utf16_to_utf8 ( utf16 . data ( ) , utf16 . length ( ) , & * utf8 . begin ( ) ) ; return utf8 ; }
static void HcrPrepareSegmentationGrid ( H_HCR_INFO pHcr ) { USHORT i , j ; USHORT numSegment = 0 ; INT segmentStart = 0 ; UCHAR segmentWidth ; UCHAR lastSegmentWidth ; UCHAR sortedCodebook ; UCHAR endFlag = 0 ; INT intermediateResult ; SCHAR lengthOfLongestCodeword = pHcr -> decInOut . lengthOfLongestCodeword ; SHORT lengthOfReorderedSpectralData = pHcr -> decInOut . lengthOfReorderedSpectralData ; UINT numSortedSection = pHcr -> sectionInfo . numSortedSection ; UCHAR * pSortedCodebook = pHcr -> sectionInfo . pSortedCodebook ; USHORT * pNumSortedCodewordInSection = pHcr -> sectionInfo . pNumSortedCodewordInSection ; INT * pLeftStartOfSegment = pHcr -> segmentInfo . pLeftStartOfSegment ; INT * pRightStartOfSegment = pHcr -> segmentInfo . pRightStartOfSegment ; SCHAR * pRemainingBitsInSegment = pHcr -> segmentInfo . pRemainingBitsInSegment ; INT bitstreamIndex = pHcr -> decInOut . bitstreamIndex ; const UCHAR * pMaxCwLength = aMaxCwLen ; for ( i = numSortedSection ; i != 0 ; i -- ) { sortedCodebook = * pSortedCodebook ++ ; segmentWidth = fMin ( ( INT ) pMaxCwLength [ sortedCodebook ] , ( INT ) lengthOfLongestCodeword ) ; for ( j = * pNumSortedCodewordInSection ; j != 0 ; j -- ) { intermediateResult = bitstreamIndex + segmentStart ; if ( ( segmentStart + segmentWidth ) <= lengthOfReorderedSpectralData ) { * pLeftStartOfSegment ++ = intermediateResult ; * pRightStartOfSegment ++ = intermediateResult + segmentWidth - 1 ; * pRemainingBitsInSegment ++ = segmentWidth ; segmentStart += segmentWidth ; numSegment += 1 ; } else { pLeftStartOfSegment -- ; pRightStartOfSegment -- ; pRemainingBitsInSegment -- ; segmentStart = * pLeftStartOfSegment - bitstreamIndex ; lastSegmentWidth = lengthOfReorderedSpectralData - segmentStart ; * pRemainingBitsInSegment = lastSegmentWidth ; * pRightStartOfSegment = bitstreamIndex + segmentStart + lastSegmentWidth - 1 ; endFlag = 1 ; break ; } } pNumSortedCodewordInSection ++ ; if ( endFlag != 0 ) { break ; } } pHcr -> segmentInfo . numSegment = numSegment ; }
static struct mm_struct * mm_init ( struct mm_struct * mm , struct task_struct * p , struct user_namespace * user_ns ) { mm -> mmap = NULL ; mm -> mm_rb = RB_ROOT ; mm -> vmacache_seqnum = 0 ; atomic_set ( & mm -> mm_users , 1 ) ; atomic_set ( & mm -> mm_count , 1 ) ; init_rwsem ( & mm -> mmap_sem ) ; INIT_LIST_HEAD ( & mm -> mmlist ) ; mm -> core_state = NULL ; atomic_long_set ( & mm -> nr_ptes , 0 ) ; mm_nr_pmds_init ( mm ) ; mm -> map_count = 0 ; mm -> locked_vm = 0 ; mm -> pinned_vm = 0 ; memset ( & mm -> rss_stat , 0 , sizeof ( mm -> rss_stat ) ) ; spin_lock_init ( & mm -> page_table_lock ) ; mm_init_cpumask ( mm ) ; mm_init_aio ( mm ) ; mm_init_owner ( mm , p ) ; mmu_notifier_mm_init ( mm ) ; init_tlb_flush_pending ( mm ) ; #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS mm -> pmd_huge_pte = NULL ; #endif if ( current -> mm ) { mm -> flags = current -> mm -> flags & MMF_INIT_MASK ; mm -> def_flags = current -> mm -> def_flags & VM_INIT_DEF_MASK ; } else { mm -> flags = default_dump_filter ; mm -> def_flags = 0 ; } if ( mm_alloc_pgd ( mm ) ) goto fail_nopgd ; if ( init_new_context ( p , mm ) ) goto fail_nocontext ; mm -> user_ns = get_user_ns ( user_ns ) ; return mm ; fail_nocontext : mm_free_pgd ( mm ) ; fail_nopgd : free_mm ( mm ) ; return NULL ; }
static bool MatchWhitespace ( InputPosition * pos ) { while ( true ) { if ( MatchChar ( std :: isspace , pos ) ) continue ; if ( MatchString ( "//" , pos ) ) { while ( MatchChar ( [ ] ( char c ) { return c != '\n' ; } , pos ) ) { } continue ; } return true ; } }
static int do_mq_notify ( mqd_t mqdes , const struct sigevent * notification ) { int ret ; struct fd f ; struct sock * sock ; struct inode * inode ; struct mqueue_inode_info * info ; struct sk_buff * nc ; audit_mq_notify ( mqdes , notification ) ; nc = NULL ; sock = NULL ; if ( notification != NULL ) { if ( unlikely ( notification -> sigev_notify != SIGEV_NONE && notification -> sigev_notify != SIGEV_SIGNAL && notification -> sigev_notify != SIGEV_THREAD ) ) return - EINVAL ; if ( notification -> sigev_notify == SIGEV_SIGNAL && ! valid_signal ( notification -> sigev_signo ) ) { return - EINVAL ; } if ( notification -> sigev_notify == SIGEV_THREAD ) { long timeo ; nc = alloc_skb ( NOTIFY_COOKIE_LEN , GFP_KERNEL ) ; if ( ! nc ) { ret = - ENOMEM ; goto out ; } if ( copy_from_user ( nc -> data , notification -> sigev_value . sival_ptr , NOTIFY_COOKIE_LEN ) ) { ret = - EFAULT ; goto out ; } skb_put ( nc , NOTIFY_COOKIE_LEN ) ; retry : f = fdget ( notification -> sigev_signo ) ; if ( ! f . file ) { ret = - EBADF ; goto out ; } sock = netlink_getsockbyfilp ( f . file ) ; fdput ( f ) ; if ( IS_ERR ( sock ) ) { ret = PTR_ERR ( sock ) ; sock = NULL ; goto out ; } timeo = MAX_SCHEDULE_TIMEOUT ; ret = netlink_attachskb ( sock , nc , & timeo , NULL ) ; if ( ret == 1 ) goto retry ; if ( ret ) { sock = NULL ; nc = NULL ; goto out ; } } } f = fdget ( mqdes ) ; if ( ! f . file ) { ret = - EBADF ; goto out ; } inode = file_inode ( f . file ) ; if ( unlikely ( f . file -> f_op != & mqueue_file_operations ) ) { ret = - EBADF ; goto out_fput ; } info = MQUEUE_I ( inode ) ; ret = 0 ; spin_lock ( & info -> lock ) ; if ( notification == NULL ) { if ( info -> notify_owner == task_tgid ( current ) ) { remove_notification ( info ) ; inode -> i_atime = inode -> i_ctime = current_time ( inode ) ; } } else if ( info -> notify_owner != NULL ) { ret = - EBUSY ; } else { switch ( notification -> sigev_notify ) { case SIGEV_NONE : info -> notify . sigev_notify = SIGEV_NONE ; break ; case SIGEV_THREAD : info -> notify_sock = sock ; info -> notify_cookie = nc ; sock = NULL ; nc = NULL ; info -> notify . sigev_notify = SIGEV_THREAD ; break ; case SIGEV_SIGNAL : info -> notify . sigev_signo = notification -> sigev_signo ; info -> notify . sigev_value = notification -> sigev_value ; info -> notify . sigev_notify = SIGEV_SIGNAL ; break ; } info -> notify_owner = get_pid ( task_tgid ( current ) ) ; info -> notify_user_ns = get_user_ns ( current_user_ns ( ) ) ; inode -> i_atime = inode -> i_ctime = current_time ( inode ) ; } spin_unlock ( & info -> lock ) ; out_fput : fdput ( f ) ; out : if ( sock ) netlink_detachskb ( sock , nc ) ; else if ( nc ) dev_kfree_skb ( nc ) ; return ret ; }
static void set_roi_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { unsigned int i ; vpx_roi_map_t roi = { 0 } ; roi . rows = ( cfg -> g_h + 15 ) / 16 ; roi . cols = ( cfg -> g_w + 15 ) / 16 ; roi . delta_q [ 0 ] = 0 ; roi . delta_q [ 1 ] = - 2 ; roi . delta_q [ 2 ] = - 4 ; roi . delta_q [ 3 ] = - 6 ; roi . delta_lf [ 0 ] = 0 ; roi . delta_lf [ 1 ] = 1 ; roi . delta_lf [ 2 ] = 2 ; roi . delta_lf [ 3 ] = 3 ; roi . static_threshold [ 0 ] = 1500 ; roi . static_threshold [ 1 ] = 1000 ; roi . static_threshold [ 2 ] = 500 ; roi . static_threshold [ 3 ] = 0 ; roi . roi_map = ( uint8_t * ) malloc ( roi . rows * roi . cols ) ; for ( i = 0 ; i < roi . rows * roi . cols ; ++ i ) roi . roi_map [ i ] = i % 4 ; if ( vpx_codec_control ( codec , VP8E_SET_ROI_MAP , & roi ) ) die_codec ( codec , "Failed to set ROI map" ) ; free ( roi . roi_map ) ; }
Node * EffectControlLinearizer :: LowerConvertTaggedHoleToUndefined ( Node * node ) { Node * value = node -> InputAt ( 0 ) ; auto if_is_hole = __ MakeDeferredLabel ( ) ; auto done = __ MakeLabel ( MachineRepresentation :: kTagged ) ; Node * check = __ WordEqual ( value , __ TheHoleConstant ( ) ) ; __ GotoIf ( check , & if_is_hole ) ; __ Goto ( & done , value ) ; __ Bind ( & if_is_hole ) ; __ Goto ( & done , __ UndefinedConstant ( ) ) ; __ Bind ( & done ) ; return done . PhiAt ( 0 ) ; }
const void * fdt_offset_ptr ( const void * fdt , int offset , unsigned int len ) { unsigned absoffset = offset + fdt_off_dt_struct ( fdt ) ; if ( ! can_assume ( VALID_INPUT ) ) if ( ( absoffset < offset ) || ( ( absoffset + len ) < absoffset ) || ( absoffset + len ) > fdt_totalsize ( fdt ) ) return NULL ; if ( can_assume ( LATEST ) || fdt_version ( fdt ) >= 0x11 ) if ( ( ( offset + len ) < offset ) || ( ( offset + len ) > fdt_size_dt_struct ( fdt ) ) ) return NULL ; return fdt_offset_ptr_ ( fdt , offset ) ; }
void Compute ( OpKernelContext * ctx ) override { const Tensor & sorted_inputs_t = ctx -> input ( 0 ) ; const Tensor & values_t = ctx -> input ( 1 ) ; OP_REQUIRES ( ctx , sorted_inputs_t . dim_size ( 0 ) == values_t . dim_size ( 0 ) , Status ( error :: INVALID_ARGUMENT , "Leading dim_size of both tensors must match." ) ) ; OP_REQUIRES ( ctx , values_t . NumElements ( ) < std :: numeric_limits < int > :: max ( ) , Status ( error :: INVALID_ARGUMENT , "values tensor size must less than INT_MAX" ) ) ; Tensor * output_t ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , values_t . shape ( ) , & output_t ) ) ; if ( output_t -> dtype ( ) == DT_INT32 ) { OP_REQUIRES ( ctx , FastBoundsCheck ( sorted_inputs_t . dim_size ( 1 ) , std :: numeric_limits < int > :: max ( ) ) , errors :: InvalidArgument ( "trailing dim_size must less than " "INT_MAX for int32 output type, was " , sorted_inputs_t . dim_size ( 1 ) ) ) ; } auto output = output_t -> template flat < OutType > ( ) ; const auto sorted_inputs = sorted_inputs_t . template flat < T > ( ) ; const auto values = values_t . template flat < T > ( ) ; OP_REQUIRES_OK ( ctx , functor :: LowerBoundFunctor < Device , T , OutType > :: Compute ( ctx , sorted_inputs , values , sorted_inputs_t . dim_size ( 0 ) , sorted_inputs_t . dim_size ( 1 ) , values_t . dim_size ( 1 ) , & output ) ) ; }
nsXULPopupManager :: KeyDown ( nsIDOMKeyEvent * aKeyEvent ) { nsMenuChainItem * item = GetTopVisibleMenu ( ) ; if ( item && item -> Frame ( ) -> IsMenuLocked ( ) ) return NS_OK ; if ( HandleKeyboardEventWithKeyCode ( aKeyEvent , item ) ) { return NS_OK ; } if ( ! mActiveMenuBar && ( ! item || item -> PopupType ( ) != ePopupTypeMenu ) ) return NS_OK ; int32_t menuAccessKey = - 1 ; nsMenuBarListener :: GetMenuAccessKey ( & menuAccessKey ) ; if ( menuAccessKey ) { uint32_t theChar ; aKeyEvent -> GetKeyCode ( & theChar ) ; if ( theChar == ( uint32_t ) menuAccessKey ) { bool ctrl = false ; if ( menuAccessKey != nsIDOMKeyEvent :: DOM_VK_CONTROL ) aKeyEvent -> GetCtrlKey ( & ctrl ) ; bool alt = false ; if ( menuAccessKey != nsIDOMKeyEvent :: DOM_VK_ALT ) aKeyEvent -> GetAltKey ( & alt ) ; bool shift = false ; if ( menuAccessKey != nsIDOMKeyEvent :: DOM_VK_SHIFT ) aKeyEvent -> GetShiftKey ( & shift ) ; bool meta = false ; if ( menuAccessKey != nsIDOMKeyEvent :: DOM_VK_META ) aKeyEvent -> GetMetaKey ( & meta ) ; if ( ! ( ctrl || alt || shift || meta ) ) { if ( mPopups ) Rollup ( 0 , false , nullptr , nullptr ) ; else if ( mActiveMenuBar ) mActiveMenuBar -> MenuClosed ( ) ; } aKeyEvent -> AsEvent ( ) -> StopPropagation ( ) ; aKeyEvent -> AsEvent ( ) -> PreventDefault ( ) ; } } if ( ! item || item -> IgnoreKeys ( ) != eIgnoreKeys_Handled ) { aKeyEvent -> AsEvent ( ) -> StopPropagation ( ) ; } aKeyEvent -> AsEvent ( ) -> StopCrossProcessForwarding ( ) ; return NS_OK ; }
static int read_private_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; const sc_acl_entry_t * e ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( "I0012" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , "Unable to select private key file: %s\n" , sc_strerror ( r ) ) ; return 2 ; } e = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; if ( e == NULL || e -> method == SC_AC_NEVER ) return 10 ; bufsize = file -> size ; sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , "Unable to read private key file: %s\n" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] < < 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( "Key number %d not found.\n" , opt_key_num ) ; return 2 ; } return parse_private_key ( p , keysize , rsa ) ; }
bool MapRef :: IsFixedCowArrayMap ( ) const { AllowHandleDereference allow_handle_dereference ; return * object < Map > ( ) == ReadOnlyRoots ( broker ( ) -> isolate ( ) ) . fixed_cow_array_map ( ) ; }
void SpaceWithLinearArea :: RemoveAllocationObserver ( AllocationObserver * observer ) { Address top_for_next_step = allocation_observers_ . size ( ) == 1 ? kNullAddress : top ( ) ; InlineAllocationStep ( top ( ) , top_for_next_step , kNullAddress , 0 ) ; Space :: RemoveAllocationObserver ( observer ) ; DCHECK_IMPLIES ( top_on_previous_step_ , AllocationObserversActive ( ) ) ; }
void HeapSnapshot :: FillChildren ( ) { DCHECK ( children ( ) . empty ( ) ) ; children ( ) . resize ( edges ( ) . size ( ) ) ; int children_index = 0 ; for ( HeapEntry & entry : entries ( ) ) { children_index = entry . set_children_index ( children_index ) ; } DCHECK_EQ ( edges ( ) . size ( ) , static_cast < size_t > ( children_index ) ) ; for ( HeapGraphEdge & edge : edges ( ) ) { edge . ReplaceToIndexWithEntry ( this ) ; edge . from ( ) -> add_child ( & edge ) ; } }
static int dgram_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sk_buff * skb ; struct sockaddr_ieee802154 * saddr ; saddr = ( struct sockaddr_ieee802154 * ) msg -> msg_name ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( saddr ) { saddr -> family = AF_IEEE802154 ; saddr -> addr = mac_cb ( skb ) -> sa ; } if ( addr_len ) * addr_len = sizeof ( * saddr ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }
ProcessSoftwareUpdateCommand ( DWORD argc , LPWSTR * argv ) { BOOL result = TRUE ; if ( argc < 3 ) { LOG ( ( "Not enough command line parameters specified. " "Updating update.status.\n" ) ) ; if ( argc > 1 || ! WriteStatusFailure ( argv [ 1 ] , SERVICE_NOT_ENOUGH_COMMAND_LINE_ARGS ) ) { LOG ( ( "Could not write update.status service update failure." "Last error: %d\n" , GetLastError ( ) ) ) ; } return FALSE ; } WCHAR installDirUpdater [ MAX_PATH + 1 ] ; wcsncpy ( installDirUpdater , argv [ 2 ] , MAX_PATH ) ; if ( ! PathAppendSafe ( installDirUpdater , L"updater.exe" ) ) { LOG ( ( "Install directory updater could not be determined.\n" ) ) ; result = FALSE ; } BOOL updaterIsCorrect ; if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) ) { LOG ( ( "Error checking if the updaters are the same.\n" "Path 1: %ls\nPath 2: %ls\n" , argv [ 0 ] , installDirUpdater ) ) ; result = FALSE ; } if ( result && ! updaterIsCorrect ) { LOG ( ( "The updaters do not match, udpater will not run.\n" ) ) ; result = FALSE ; } if ( result ) { LOG ( ( "updater.exe was compared successfully to the installation directory" " updater.exe.\n" ) ) ; } else { if ( ! WriteStatusFailure ( argv [ 1 ] , SERVICE_UPDATER_COMPARE_ERROR ) ) { LOG ( ( "Could not write update.status updater compare failure.\n" ) ) ; } return FALSE ; } HMODULE updaterModule = LoadLibrary ( argv [ 0 ] ) ; if ( ! updaterModule ) { LOG ( ( "updater.exe module could not be loaded. (%d)\n" , GetLastError ( ) ) ) ; result = FALSE ; } else { char updaterIdentity [ 64 ] ; if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) ) { LOG ( ( "The updater.exe application does not contain the Mozilla" " updater identity.\n" ) ) ; result = FALSE ; } if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) ) { LOG ( ( "The updater.exe identity string is not valid.\n" ) ) ; result = FALSE ; } FreeLibrary ( updaterModule ) ; } if ( result ) { LOG ( ( "The updater.exe application contains the Mozilla" " updater identity.\n" ) ) ; } else { if ( ! WriteStatusFailure ( argv [ 1 ] , SERVICE_UPDATER_IDENTITY_ERROR ) ) { LOG ( ( "Could not write update.status no updater identity.\n" ) ) ; } return TRUE ; } BOOL updaterSignProblem = FALSE ; #ifndef DISABLE_UPDATER_AUTHENTICODE_CHECK updaterSignProblem = ! DoesBinaryMatchAllowedCertificates ( argv [ 2 ] , argv [ 0 ] ) ; #endif if ( ! updaterSignProblem ) { BOOL updateProcessWasStarted = FALSE ; if ( StartUpdateProcess ( argc , argv , updateProcessWasStarted ) ) { LOG ( ( "updater.exe was launched and run successfully!\n" ) ) ; LogFlush ( ) ; StartServiceUpdate ( argc , argv ) ; } else { result = FALSE ; LOG ( ( "Error running update process. Updating update.status" " Last error: %d\n" , GetLastError ( ) ) ) ; LogFlush ( ) ; if ( ! updateProcessWasStarted ) { if ( ! WriteStatusFailure ( argv [ 1 ] , SERVICE_UPDATER_COULD_NOT_BE_STARTED ) ) { LOG ( ( "Could not write update.status service update failure." "Last error: %d\n" , GetLastError ( ) ) ) ; } } } } else { result = FALSE ; LOG ( ( "Could not start process due to certificate check error on " "updater.exe. Updating update.status.  Last error: %d\n" , GetLastError ( ) ) ) ; if ( ! WriteStatusFailure ( argv [ 1 ] , SERVICE_UPDATER_SIGN_ERROR ) ) { LOG ( ( "Could not write pending state to update.status.  (%d)\n" , GetLastError ( ) ) ) ; } } return result ; }
static int do_last ( struct nameidata * nd , struct file * file , const struct open_flags * op ) { struct dentry * dir = nd -> path . dentry ; int open_flag = op -> open_flag ; bool will_truncate = ( open_flag & O_TRUNC ) != 0 ; bool got_write = false ; int acc_mode = op -> acc_mode ; unsigned seq ; struct inode * inode ; struct path path ; int error ; nd -> flags &= ~ LOOKUP_PARENT ; nd -> flags |= op -> intent ; if ( nd -> last_type != LAST_NORM ) { error = handle_dots ( nd , nd -> last_type ) ; if ( unlikely ( error ) ) return error ; goto finish_open ; } if ( ! ( open_flag & O_CREAT ) ) { if ( nd -> last . name [ nd -> last . len ] ) nd -> flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY ; error = lookup_fast ( nd , & path , & inode , & seq ) ; if ( likely ( error > 0 ) ) goto finish_lookup ; if ( error < 0 ) return error ; BUG_ON ( nd -> inode != dir -> d_inode ) ; BUG_ON ( nd -> flags & LOOKUP_RCU ) ; } else { error = complete_walk ( nd ) ; if ( error ) return error ; audit_inode ( nd -> name , dir , AUDIT_INODE_PARENT ) ; if ( unlikely ( nd -> last . name [ nd -> last . len ] ) ) return - EISDIR ; } if ( open_flag & ( O_CREAT | O_TRUNC | O_WRONLY | O_RDWR ) ) { error = mnt_want_write ( nd -> path . mnt ) ; if ( ! error ) got_write = true ; } if ( open_flag & O_CREAT ) inode_lock ( dir -> d_inode ) ; else inode_lock_shared ( dir -> d_inode ) ; error = lookup_open ( nd , & path , file , op , got_write ) ; if ( open_flag & O_CREAT ) inode_unlock ( dir -> d_inode ) ; else inode_unlock_shared ( dir -> d_inode ) ; if ( error ) goto out ; if ( file -> f_mode & FMODE_OPENED ) { if ( ( file -> f_mode & FMODE_CREATED ) || ! S_ISREG ( file_inode ( file ) -> i_mode ) ) will_truncate = false ; audit_inode ( nd -> name , file -> f_path . dentry , 0 ) ; goto opened ; } if ( file -> f_mode & FMODE_CREATED ) { open_flag &= ~ O_TRUNC ; will_truncate = false ; acc_mode = 0 ; path_to_nameidata ( & path , nd ) ; goto finish_open_created ; } if ( got_write ) { mnt_drop_write ( nd -> path . mnt ) ; got_write = false ; } error = follow_managed ( & path , nd ) ; if ( unlikely ( error < 0 ) ) return error ; audit_inode ( nd -> name , path . dentry , 0 ) ; if ( unlikely ( ( open_flag & ( O_EXCL | O_CREAT ) ) == ( O_EXCL | O_CREAT ) ) ) { path_to_nameidata ( & path , nd ) ; return - EEXIST ; } seq = 0 ; inode = d_backing_inode ( path . dentry ) ; finish_lookup : error = step_into ( nd , & path , 0 , inode , seq ) ; if ( unlikely ( error ) ) return error ; finish_open : error = complete_walk ( nd ) ; if ( error ) return error ; audit_inode ( nd -> name , nd -> path . dentry , 0 ) ; if ( open_flag & O_CREAT ) { error = - EISDIR ; if ( d_is_dir ( nd -> path . dentry ) ) goto out ; error = may_create_in_sticky ( dir , d_backing_inode ( nd -> path . dentry ) ) ; if ( unlikely ( error ) ) goto out ; } error = - ENOTDIR ; if ( ( nd -> flags & LOOKUP_DIRECTORY ) && ! d_can_lookup ( nd -> path . dentry ) ) goto out ; if ( ! d_is_reg ( nd -> path . dentry ) ) will_truncate = false ; if ( will_truncate ) { error = mnt_want_write ( nd -> path . mnt ) ; if ( error ) goto out ; got_write = true ; } finish_open_created : error = may_open ( & nd -> path , acc_mode , open_flag ) ; if ( error ) goto out ; BUG_ON ( file -> f_mode & FMODE_OPENED ) ; error = vfs_open ( & nd -> path , file ) ; if ( error ) goto out ; opened : error = ima_file_check ( file , op -> acc_mode ) ; if ( ! error && will_truncate ) error = handle_truncate ( file ) ; out : if ( unlikely ( error > 0 ) ) { WARN_ON ( 1 ) ; error = - EINVAL ; } if ( got_write ) mnt_drop_write ( nd -> path . mnt ) ; return error ; }
TEST_F ( QuantizedConv2DTest , Small ) { const int stride = 1 ; TF_ASSERT_OK ( NodeDefBuilder ( "quantized_conv_op" , "QuantizedConv2D" ) . Input ( FakeInput ( DT_QUINT8 ) ) . Input ( FakeInput ( DT_QUINT8 ) ) . Input ( FakeInput ( DT_FLOAT ) ) . Input ( FakeInput ( DT_FLOAT ) ) . Input ( FakeInput ( DT_FLOAT ) ) . Input ( FakeInput ( DT_FLOAT ) ) . Attr ( "out_type" , DataTypeToEnum < qint32 > :: v ( ) ) . Attr ( "strides" , { 1 , stride , stride , 1 } ) . Attr ( "padding" , "SAME" ) . Finalize ( node_def ( ) ) ) ; TF_ASSERT_OK ( InitOp ( ) ) ; const int depth = 1 ; const int image_width = 4 ; const int image_height = 3 ; const int image_batch_count = 1 ; const float image_min = 0.0f ; const float image_max = 12.0f ; Tensor image_float ( DT_FLOAT , { image_batch_count , image_height , image_width , depth } ) ; test :: FillValues < float > ( & image_float , { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 } ) ; Tensor image_quantized = FloatTensorToQuantized < quint8 > ( image_float , image_min , image_max ) ; const int filter_size = 3 ; const int filter_count = 1 ; const float filter_min = 1.0f ; const float filter_max = 9.0f ; Tensor filter_float ( DT_FLOAT , { filter_size , filter_size , depth , filter_count } ) ; test :: FillValues < float > ( & filter_float , { 1 , 4 , 7 , 2 , 5 , 8 , 3 , 6 , 9 } ) ; Tensor filter_quantized = FloatTensorToQuantized < quint8 > ( filter_float , filter_min , filter_max ) ; AddInputFromArray < quint8 > ( image_quantized . shape ( ) , image_quantized . flat < quint8 > ( ) ) ; AddInputFromArray < quint8 > ( filter_quantized . shape ( ) , filter_quantized . flat < quint8 > ( ) ) ; AddInputFromArray < float > ( TensorShape ( { 1 } ) , { image_min } ) ; AddInputFromArray < float > ( TensorShape ( { 1 } ) , { image_max } ) ; AddInputFromArray < float > ( TensorShape ( { 1 } ) , { filter_min } ) ; AddInputFromArray < float > ( TensorShape ( { 1 } ) , { filter_max } ) ; TF_ASSERT_OK ( RunOpKernel ( ) ) ; const int expected_width = image_width ; const int expected_height = image_height * filter_count ; Tensor expected_float ( DT_FLOAT , TensorShape ( { image_batch_count , expected_height , expected_width , filter_count } ) ) ; test :: FillValues < float > ( & expected_float , { 105 , 150 , 183 , 95 , 235 , 312 , 357 , 178 , 187 , 234 , 261 , 121 } ) ; const Tensor & output_quantized = * GetOutput ( 0 ) ; const float output_min = GetOutput ( 1 ) -> flat < float > ( ) ( 0 ) ; const float output_max = GetOutput ( 2 ) -> flat < float > ( ) ( 0 ) ; Tensor output_float = QuantizedTensorToFloat < qint32 > ( output_quantized , output_min , output_max ) ; test :: ExpectTensorNear < float > ( expected_float , output_float , 1.0 ) ; }
Node * WasmGraphBuilder :: BuildI64RemS ( Node * left , Node * right , wasm :: WasmCodePosition position ) { if ( mcgraph ( ) -> machine ( ) -> Is32 ( ) ) { return BuildDiv64Call ( left , right , ExternalReference :: wasm_int64_mod ( ) , MachineType :: Int64 ( ) , wasm :: kTrapRemByZero , position ) ; } ZeroCheck64 ( wasm :: kTrapRemByZero , right , position ) ; Diamond d ( mcgraph ( ) -> graph ( ) , mcgraph ( ) -> common ( ) , graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Word64Equal ( ) , right , mcgraph ( ) -> Int64Constant ( - 1 ) ) ) ; d . Chain ( Control ( ) ) ; Node * rem = graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Int64Mod ( ) , left , right , d . if_false ) ; return d . Phi ( MachineRepresentation :: kWord64 , mcgraph ( ) -> Int64Constant ( 0 ) , rem ) ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteConcatenationParams * params = reinterpret_cast < TfLiteConcatenationParams * > ( node -> builtin_data ) ; TfLiteType input_type = GetInput ( context , node , 0 ) -> type ; TfLiteType output_type = GetOutput ( context , node , kOutputTensor ) -> type ; TF_LITE_ENSURE_EQ ( context , params -> activation , kTfLiteActNone ) ; TF_LITE_ENSURE ( context , input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 || input_type == kTfLiteInt8 || input_type == kTfLiteInt32 || input_type == kTfLiteInt64 ) ; TF_LITE_ENSURE_EQ ( context , output_type , input_type ) ; const int num_inputs = NumInputs ( node ) ; TF_LITE_ENSURE ( context , num_inputs <= kMaxInputNum ) ; for ( int i = 0 ; i < num_inputs ; ++ i ) { const TfLiteTensor * input = GetInput ( context , node , i ) ; int num_dimensions = NumDimensions ( input ) ; if ( num_dimensions > 4 ) { TF_LITE_KERNEL_LOG ( context , "Op Concatenation does not currently support num dimensions >4 " "Tensor has %d dimensions." , num_dimensions ) ; return kTfLiteError ; } } TFLITE_DCHECK ( node -> user_data != nullptr ) ; OpData * data = static_cast < OpData * > ( node -> user_data ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; switch ( output_type ) { case kTfLiteFloat32 : case kTfLiteInt32 : case kTfLiteInt64 : { data -> params . axis = CalculatePositiveAxis ( params -> axis , output ) ; data -> params . inputs_count = node -> inputs -> size ; break ; } case kTfLiteUInt8 : case kTfLiteInt8 : { data -> params . axis = CalculatePositiveAxis ( params -> axis , output ) ; data -> params . inputs_count = node -> inputs -> size ; float * input_scales = reinterpret_cast < float * > ( context -> AllocatePersistentBuffer ( context , node -> inputs -> size * sizeof ( float ) ) ) ; int32_t * input_zero_points = reinterpret_cast < int32_t * > ( context -> AllocatePersistentBuffer ( context , node -> inputs -> size * sizeof ( int32_t ) ) ) ; for ( int i = 0 ; i < node -> inputs -> size ; ++ i ) { const TfLiteTensor * t = GetInput ( context , node , i ) ; input_scales [ i ] = t -> params . scale ; input_zero_points [ i ] = t -> params . zero_point ; } data -> params . input_scale = input_scales ; data -> params . input_zeropoint = input_zero_points ; data -> params . output_zeropoint = output -> params . zero_point ; data -> params . output_scale = output -> params . scale ; break ; } default : TF_LITE_KERNEL_LOG ( context , "Op Concatenation does not currently support Type '%s'." , TfLiteTypeGetName ( output_type ) ) ; return kTfLiteError ; } return kTfLiteOk ; }
MaybeHandle < JSReceiver > GetSuperHolder ( Isolate * isolate , Handle < Object > receiver , Handle < JSObject > home_object , SuperMode mode , MaybeHandle < Name > maybe_name , uint32_t index ) { if ( home_object -> IsAccessCheckNeeded ( ) && ! isolate -> MayAccess ( handle ( isolate -> context ( ) , isolate ) , home_object ) ) { isolate -> ReportFailedAccessCheck ( home_object ) ; RETURN_EXCEPTION_IF_SCHEDULED_EXCEPTION ( isolate , JSReceiver ) ; } PrototypeIterator iter ( isolate , home_object ) ; Handle < Object > proto = PrototypeIterator :: GetCurrent ( iter ) ; if ( ! proto -> IsJSReceiver ( ) ) { MessageTemplate :: Template message = mode == SuperMode :: kLoad ? MessageTemplate :: kNonObjectPropertyLoad : MessageTemplate :: kNonObjectPropertyStore ; Handle < Name > name ; if ( ! maybe_name . ToHandle ( & name ) ) { name = isolate -> factory ( ) -> Uint32ToString ( index ) ; } THROW_NEW_ERROR ( isolate , NewTypeError ( message , name , proto ) , JSReceiver ) ; } return Handle < JSReceiver > :: cast ( proto ) ; }
static int parse_token ( char * * name , char * * value , char * * cp ) { char * end ; if ( ! name || ! value || ! cp ) return - BLKID_ERR_PARAM ; if ( ! ( * value = strchr ( * cp , '=' ) ) ) return 0 ; * * value = '\0' ; * name = strip_line ( * cp ) ; * value = skip_over_blank ( * value + 1 ) ; if ( * * value == '"' ) { end = strchr ( * value + 1 , '"' ) ; if ( ! end ) { DBG ( READ , ul_debug ( "unbalanced quotes at: %s" , * value ) ) ; * cp = * value ; return - BLKID_ERR_CACHE ; } ( * value ) ++ ; * end = '\0' ; end ++ ; } else { end = skip_over_word ( * value ) ; if ( * end ) { * end = '\0' ; end ++ ; } } * cp = end ; return 1 ; }
int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
void UpdateLog :: Init ( NS_tchar * sourcePath , const NS_tchar * fileName ) { if ( logFP ) { return ; } int dstFilePathLen = NS_tsnprintf ( mDstFilePath , sizeof ( mDstFilePath ) / sizeof ( mDstFilePath [ 0 ] ) , NS_T ( "%s/%s" ) , sourcePath , fileName ) ; if ( ( dstFilePathLen > 0 ) && ( dstFilePathLen < static_cast < int > ( sizeof ( mDstFilePath ) / sizeof ( mDstFilePath [ 0 ] ) ) ) ) { #ifdef XP_WIN if ( GetUUIDTempFilePath ( sourcePath , L"log" , mTmpFilePath ) ) { logFP = NS_tfopen ( mTmpFilePath , NS_T ( "w" ) ) ; DeleteFileW ( mDstFilePath ) ; } #elif XP_MACOSX logFP = NS_tfopen ( mDstFilePath , NS_T ( "w" ) ) ; #else logFP = tmpfile ( ) ; #endif } }
static Jsi_RC jsiValueGetString ( Jsi_Interp * interp , Jsi_Value * v , Jsi_DString * dStr , objwalker * owPtr ) { char buf [ 100 ] , * str ; Jsi_DString eStr ; Jsi_DSInit ( & eStr ) ; if ( interp -> maxDepth > 0 && owPtr -> depth > interp -> maxDepth ) return Jsi_LogError ( "recursive ToString" ) ; int quote = owPtr -> quote ; int isjson = owPtr -> quote & JSI_OUTPUT_JSON ; Jsi_Number num ; switch ( v -> vt ) { case JSI_VT_UNDEF : Jsi_DSAppend ( dStr , "undefined" , NULL ) ; return JSI_OK ; case JSI_VT_NULL : Jsi_DSAppend ( dStr , "null" , NULL ) ; return JSI_OK ; case JSI_VT_VARIABLE : Jsi_DSAppend ( dStr , "variable" , NULL ) ; return JSI_OK ; case JSI_VT_BOOL : Jsi_DSAppend ( dStr , ( v -> d . val ? "true" : "false" ) , NULL ) ; return JSI_OK ; case JSI_VT_NUMBER : num = v -> d . num ; outnum : if ( isjson && ! Jsi_NumberIsNormal ( num ) ) { Jsi_DSAppend ( dStr , "null" , NULL ) ; } else if ( Jsi_NumberIsInteger ( num ) ) { Jsi_NumberItoA10 ( ( Jsi_Wide ) num , buf , sizeof ( buf ) ) ; Jsi_DSAppend ( dStr , buf , NULL ) ; } else if ( Jsi_NumberIsWide ( num ) ) { snprintf ( buf , sizeof ( buf ) , "%" PRId64 , ( Jsi_Wide ) num ) ; Jsi_DSAppend ( dStr , buf , NULL ) ; } else if ( Jsi_NumberIsNormal ( num ) || Jsi_NumberIsSubnormal ( num ) ) { Jsi_NumberDtoA ( interp , num , buf , sizeof ( buf ) , 0 ) ; Jsi_DSAppend ( dStr , buf , NULL ) ; } else if ( Jsi_NumberIsNaN ( num ) ) { Jsi_DSAppend ( dStr , "NaN" , NULL ) ; } else { int s = Jsi_NumberIsInfinity ( num ) ; if ( s > 0 ) Jsi_DSAppend ( dStr , "+Infinity" , NULL ) ; else if ( s < 0 ) Jsi_DSAppend ( dStr , "-Infinity" , NULL ) ; else Jsi_LogBug ( "Ieee function problem: %d" , fpclassify ( num ) ) ; } return JSI_OK ; case JSI_VT_STRING : str = v -> d . s . str ; outstr : if ( ! quote ) { Jsi_DSAppend ( dStr , str , NULL ) ; return JSI_OK ; } Jsi_DSAppend ( dStr , "\"" , NULL ) ; while ( * str ) { if ( ( * str == '\'' && ( ! isjson ) ) || * str == '\\' || * str == '\"' || ( * str == '\n' && ( ! ( owPtr -> quote & JSI_OUTPUT_NEWLINES ) ) ) || * str == '\r' || * str == '\t' || * str == '\f' || * str == '\b' ) { char pcp [ 2 ] ; * pcp = * str ; pcp [ 1 ] = 0 ; Jsi_DSAppendLen ( dStr , "\\" , 1 ) ; switch ( * str ) { case '\r' : * pcp = 'r' ; break ; case '\n' : * pcp = 'n' ; break ; case '\t' : * pcp = 't' ; break ; case '\f' : * pcp = 'f' ; break ; case '\b' : * pcp = 'b' ; break ; } Jsi_DSAppendLen ( dStr , pcp , 1 ) ; } else if ( isprint ( * str ) || ! isjson ) Jsi_DSAppendLen ( dStr , str , 1 ) ; else { char ubuf [ 10 ] ; int l = Jsi_UtfEncode ( str , ubuf ) ; Jsi_DSAppend ( dStr , ubuf , NULL ) ; str += l - 1 ; } str ++ ; } Jsi_DSAppend ( dStr , "\"" , NULL ) ; Jsi_DSFree ( & eStr ) ; return JSI_OK ; case JSI_VT_OBJECT : { Jsi_Obj * o = v -> d . obj ; switch ( o -> ot ) { case JSI_OT_BOOL : Jsi_DSAppend ( dStr , ( o -> d . val ? "true" : "false" ) , NULL ) ; return JSI_OK ; case JSI_OT_NUMBER : num = o -> d . num ; goto outnum ; return JSI_OK ; case JSI_OT_STRING : str = o -> d . s . str ; goto outstr ; case JSI_OT_FUNCTION : Jsi_FuncObjToString ( interp , o -> d . fobj -> func , & eStr , 3 | ( ( owPtr -> depth == 0 && owPtr -> quote ) ? 8 : 0 ) ) ; str = Jsi_DSValue ( & eStr ) ; goto outstr ; case JSI_OT_REGEXP : str = o -> d . robj -> pattern ; goto outstr ; case JSI_OT_USEROBJ : jsi_UserObjToName ( interp , o -> d . uobj , & eStr ) ; str = Jsi_DSValue ( & eStr ) ; goto outstr ; case JSI_OT_ITER : Jsi_DSAppend ( dStr , ( isjson ? "null" : "*ITER*" ) , NULL ) ; return JSI_OK ; default : break ; } if ( o -> isarrlist ) { Jsi_Value * nv ; int i , len = o -> arrCnt ; if ( ! o -> arr ) len = Jsi_ValueGetLength ( interp , v ) ; Jsi_DSAppend ( dStr , "[" , len ? " " : "" , NULL ) ; for ( i = 0 ; i < len ; ++ i ) { nv = Jsi_ValueArrayIndex ( interp , v , i ) ; if ( i ) Jsi_DSAppend ( dStr , ", " , NULL ) ; owPtr -> depth ++ ; if ( nv ) { if ( jsiValueGetString ( interp , nv , dStr , owPtr ) != JSI_OK ) { owPtr -> depth -- ; return JSI_ERROR ; } } else Jsi_DSAppend ( dStr , "undefined" , NULL ) ; owPtr -> depth -- ; } Jsi_DSAppend ( dStr , len ? " " : "" , "]" , NULL ) ; } else { int len = Jsi_TreeSize ( o -> tree ) ; Jsi_DSAppend ( dStr , "{" , len ? " " : "" , NULL ) ; owPtr -> depth ++ ; Jsi_TreeWalk ( o -> tree , _object_get_callback , owPtr , 0 ) ; owPtr -> depth -- ; Jsi_DSAppend ( dStr , len ? " " : "" , "}" , NULL ) ; } return JSI_OK ; } #ifndef __cplusplus default : Jsi_LogBug ( "Unexpected value type: %d" , v -> vt ) ; #endif } return JSI_OK ; }
static int dbgp_setup ( struct usb_gadget * gadget , const struct usb_ctrlrequest * ctrl ) { struct usb_request * req = dbgp . req ; u8 request = ctrl -> bRequest ; u16 value = le16_to_cpu ( ctrl -> wValue ) ; u16 length = le16_to_cpu ( ctrl -> wLength ) ; int err = - EOPNOTSUPP ; void * data = NULL ; u16 len = 0 ; if ( length > DBGP_REQ_LEN ) { if ( ctrl -> bRequestType == USB_DIR_OUT ) { return err ; } else { __le16 * temp = ( __le16 * ) & ctrl -> wLength ; * temp = cpu_to_le16 ( DBGP_REQ_LEN ) ; length = DBGP_REQ_LEN ; } } if ( request == USB_REQ_GET_DESCRIPTOR ) { switch ( value > > 8 ) { case USB_DT_DEVICE : dev_dbg ( & dbgp . gadget -> dev , "setup: desc device\n" ) ; len = sizeof device_desc ; data = & device_desc ; device_desc . bMaxPacketSize0 = gadget -> ep0 -> maxpacket ; break ; case USB_DT_DEBUG : dev_dbg ( & dbgp . gadget -> dev , "setup: desc debug\n" ) ; len = sizeof dbg_desc ; data = & dbg_desc ; break ; default : goto fail ; } err = 0 ; } else if ( request == USB_REQ_SET_FEATURE && value == USB_DEVICE_DEBUG_MODE ) { dev_dbg ( & dbgp . gadget -> dev , "setup: feat debug\n" ) ; #ifdef CONFIG_USB_G_DBGP_PRINTK err = dbgp_enable_ep ( ) ; #else err = dbgp_configure_endpoints ( gadget ) ; if ( err < 0 ) { goto fail ; } err = gserial_connect ( dbgp . serial , tty_line ) ; #endif if ( err < 0 ) goto fail ; } else goto fail ; req -> length = min ( length , len ) ; req -> zero = len < req -> length ; if ( data && req -> length ) memcpy ( req -> buf , data , req -> length ) ; req -> complete = dbgp_setup_complete ; return usb_ep_queue ( gadget -> ep0 , req , GFP_ATOMIC ) ; fail : dev_dbg ( & dbgp . gadget -> dev , "setup: failure req %x v %x\n" , request , value ) ; return err ; }
BytecodeRegisterOptimizer :: BytecodeRegisterOptimizer ( Zone * zone , BytecodeRegisterAllocator * register_allocator , int fixed_registers_count , int parameter_count , BytecodeWriter * bytecode_writer ) : accumulator_ ( Register :: virtual_accumulator ( ) ) , temporary_base_ ( fixed_registers_count ) , max_register_index_ ( fixed_registers_count - 1 ) , register_info_table_ ( zone ) , registers_needing_flushed_ ( zone ) , equivalence_id_ ( 0 ) , bytecode_writer_ ( bytecode_writer ) , flush_required_ ( false ) , zone_ ( zone ) { register_allocator -> set_observer ( this ) ; DCHECK_NE ( parameter_count , 0 ) ; register_info_table_offset_ = - Register :: FromParameterIndex ( 0 , parameter_count ) . index ( ) ; register_info_table_ . resize ( register_info_table_offset_ + static_cast < size_t > ( temporary_base_ . index ( ) ) ) ; for ( size_t i = 0 ; i < register_info_table_ . size ( ) ; ++ i ) { register_info_table_ [ i ] = new ( zone ) RegisterInfo ( RegisterFromRegisterInfoTableIndex ( i ) , NextEquivalenceId ( ) , true , true ) ; DCHECK_EQ ( register_info_table_ [ i ] -> register_value ( ) . index ( ) , RegisterFromRegisterInfoTableIndex ( i ) . index ( ) ) ; } accumulator_info_ = GetRegisterInfo ( accumulator_ ) ; DCHECK ( accumulator_info_ -> register_value ( ) == accumulator_ ) ; }
png_get_y_pixels_per_meter ( png_const_structrp png_ptr , png_const_inforp info_ptr ) { #ifdef PNG_pHYs_SUPPORTED if ( png_ptr != NULL && info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_pHYs ) ) { png_debug1 ( 1 , "in %s retrieval function" , "png_get_y_pixels_per_meter" ) ; if ( info_ptr -> phys_unit_type == PNG_RESOLUTION_METER ) return ( info_ptr -> y_pixels_per_unit ) ; } #endif return ( 0 ) ; }
IGNITION_HANDLER ( SwitchOnSmiNoFeedback , InterpreterAssembler ) { Node * acc = GetAccumulator ( ) ; Node * table_start = BytecodeOperandIdx ( 0 ) ; Node * table_length = BytecodeOperandUImmWord ( 1 ) ; Node * case_value_base = BytecodeOperandImmIntPtr ( 2 ) ; Label fall_through ( this ) ; CSA_ASSERT ( this , TaggedIsSmi ( acc ) ) ; Node * case_value = IntPtrSub ( SmiUntag ( acc ) , case_value_base ) ; GotoIf ( IntPtrLessThan ( case_value , IntPtrConstant ( 0 ) ) , & fall_through ) ; GotoIf ( IntPtrGreaterThanOrEqual ( case_value , table_length ) , & fall_through ) ; Node * entry = IntPtrAdd ( table_start , case_value ) ; Node * relative_jump = LoadAndUntagConstantPoolEntry ( entry ) ; Jump ( relative_jump ) ; BIND ( & fall_through ) ; Dispatch ( ) ; }
RUNTIME_FUNCTION ( Runtime_SetGrow ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 1 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSSet , holder , 0 ) ; Handle < OrderedHashSet > table ( OrderedHashSet :: cast ( holder -> table ( ) ) , isolate ) ; table = OrderedHashSet :: EnsureGrowable ( isolate , table ) ; holder -> set_table ( * table ) ; return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
std :: ostream & operator < < ( std :: ostream & os , CheckMapsFlags flags ) { bool empty = true ; if ( flags & CheckMapsFlag :: kTryMigrateInstance ) { os < < "TryMigrateInstance" ; empty = false ; } if ( empty ) os < < "None" ; return os ; }
nsXPCWrappedJS :: GetNewOrUsed ( XPCCallContext & ccx , JSObject * aJSObj , REFNSIID aIID , nsISupports * aOuter , nsXPCWrappedJS * * wrapperResult ) { JSObject2WrappedJSMap * map ; JSObject * rootJSObj ; nsXPCWrappedJS * root = nsnull ; nsXPCWrappedJS * wrapper = nsnull ; nsXPCWrappedJSClass * clazz = nsnull ; XPCJSRuntime * rt = ccx . GetRuntime ( ) ; JSBool release_root = JS_FALSE ; map = rt -> GetWrappedJSMap ( ) ; if ( ! map ) { NS_ASSERTION ( map , "bad map" ) ; return NS_ERROR_FAILURE ; } nsXPCWrappedJSClass :: GetNewOrUsed ( ccx , aIID , & clazz ) ; if ( ! clazz ) return NS_ERROR_FAILURE ; rootJSObj = clazz -> GetRootJSObject ( ccx , aJSObj ) ; if ( ! rootJSObj ) goto return_wrapper ; { XPCAutoLock lock ( rt -> GetMapLock ( ) ) ; root = map -> Find ( rootJSObj ) ; if ( root ) { if ( ( nsnull != ( wrapper = root -> Find ( aIID ) ) ) || ( nsnull != ( wrapper = root -> FindInherited ( aIID ) ) ) ) { NS_ADDREF ( wrapper ) ; goto return_wrapper ; } } } if ( ! root ) { if ( rootJSObj == aJSObj ) { wrapper = root = new nsXPCWrappedJS ( ccx , aJSObj , clazz , nsnull , aOuter ) ; if ( root ) { #if DEBUG_xpc_leaks printf ( "Created nsXPCWrappedJS %p, JSObject is %p\n" , ( void * ) wrapper , ( void * ) aJSObj ) ; #endif XPCAutoLock lock ( rt -> GetMapLock ( ) ) ; map -> Add ( root ) ; } goto return_wrapper ; } else { nsXPCWrappedJSClass * rootClazz = nsnull ; nsXPCWrappedJSClass :: GetNewOrUsed ( ccx , NS_GET_IID ( nsISupports ) , & rootClazz ) ; if ( ! rootClazz ) goto return_wrapper ; root = new nsXPCWrappedJS ( ccx , rootJSObj , rootClazz , nsnull , aOuter ) ; NS_RELEASE ( rootClazz ) ; if ( ! root ) goto return_wrapper ; release_root = JS_TRUE ; { #if DEBUG_xpc_leaks printf ( "Created nsXPCWrappedJS %p, JSObject is %p\n" , ( void * ) root , ( void * ) rootJSObj ) ; #endif XPCAutoLock lock ( rt -> GetMapLock ( ) ) ; map -> Add ( root ) ; } } } NS_ASSERTION ( root , "bad root" ) ; NS_ASSERTION ( clazz , "bad clazz" ) ; if ( ! wrapper ) { wrapper = new nsXPCWrappedJS ( ccx , aJSObj , clazz , root , aOuter ) ; if ( ! wrapper ) goto return_wrapper ; #if DEBUG_xpc_leaks printf ( "Created nsXPCWrappedJS %p, JSObject is %p\n" , ( void * ) wrapper , ( void * ) aJSObj ) ; #endif } wrapper -> mNext = root -> mNext ; root -> mNext = wrapper ; return_wrapper : if ( clazz ) NS_RELEASE ( clazz ) ; if ( release_root ) NS_RELEASE ( root ) ; if ( ! wrapper ) return NS_ERROR_FAILURE ; * wrapperResult = wrapper ; return NS_OK ; }
TEST_F ( AllowMissingInAndOfOrListTest , GoodAndBadJwts ) { EXPECT_CALL ( mock_cb_ , onComplete ( Status :: Ok ) ) ; auto headers = Http :: TestRequestHeaderMapImpl { { kExampleHeader , GoodToken } , { kOtherHeader , GoodToken } } ; context_ = Verifier :: createContext ( headers , parent_span_ , & mock_cb_ ) ; verifier_ -> verify ( context_ ) ; EXPECT_THAT ( headers , JwtOutputSuccess ( kExampleHeader ) ) ; EXPECT_THAT ( headers , JwtOutputFailedOrIgnore ( kOtherHeader ) ) ; }
void vp9_plane_add_noise_c ( uint8_t * start , char * noise , char blackclamp [ 16 ] , char whiteclamp [ 16 ] , char bothclamp [ 16 ] , unsigned int width , unsigned int height , int pitch ) { unsigned int i , j ; for ( i = 0 ; i < height ; i ++ ) { uint8_t * pos = start + i * pitch ; char * ref = ( char * ) ( noise + ( rand ( ) & 0xff ) ) ; for ( j = 0 ; j < width ; j ++ ) { if ( pos [ j ] < blackclamp [ 0 ] ) pos [ j ] = blackclamp [ 0 ] ; if ( pos [ j ] > 255 + whiteclamp [ 0 ] ) pos [ j ] = 255 + whiteclamp [ 0 ] ; pos [ j ] += ref [ j ] ; } } }
static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - EOPNOTSUPP ; if ( m -> msg_flags & MSG_OOB ) goto read_error ; skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= MSG_TRUNC ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }
bool radeon_atom_get_tv_timings ( struct radeon_device * rdev , int index , struct drm_display_mode * mode ) { struct radeon_mode_info * mode_info = & rdev -> mode_info ; ATOM_ANALOG_TV_INFO * tv_info ; ATOM_ANALOG_TV_INFO_V1_2 * tv_info_v1_2 ; ATOM_DTD_FORMAT * dtd_timings ; int data_index = GetIndexIntoMasterTable ( DATA , AnalogTV_Info ) ; u8 frev , crev ; u16 data_offset , misc ; if ( ! atom_parse_data_header ( mode_info -> atom_context , data_index , NULL , & frev , & crev , & data_offset ) ) return false ; switch ( crev ) { case 1 : tv_info = ( ATOM_ANALOG_TV_INFO * ) ( mode_info -> atom_context -> bios + data_offset ) ; if ( index > MAX_SUPPORTED_TV_TIMING ) return false ; mode -> crtc_htotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Total ) ; mode -> crtc_hdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Disp ) ; mode -> crtc_hsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) ; mode -> crtc_hsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) + le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncWidth ) ; mode -> crtc_vtotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Total ) ; mode -> crtc_vdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Disp ) ; mode -> crtc_vsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) ; mode -> crtc_vsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) + le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncWidth ) ; mode -> flags = 0 ; misc = le16_to_cpu ( tv_info -> aModeTimings [ index ] . susModeMiscInfo . usAccess ) ; if ( misc & ATOM_VSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NVSYNC ; if ( misc & ATOM_HSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NHSYNC ; if ( misc & ATOM_COMPOSITESYNC ) mode -> flags |= DRM_MODE_FLAG_CSYNC ; if ( misc & ATOM_INTERLACE ) mode -> flags |= DRM_MODE_FLAG_INTERLACE ; if ( misc & ATOM_DOUBLE_CLOCK_MODE ) mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; mode -> clock = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usPixelClock ) * 10 ; if ( index == 1 ) { mode -> crtc_htotal -= 1 ; mode -> crtc_vtotal -= 1 ; } break ; case 2 : tv_info_v1_2 = ( ATOM_ANALOG_TV_INFO_V1_2 * ) ( mode_info -> atom_context -> bios + data_offset ) ; if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 ) return false ; dtd_timings = & tv_info_v1_2 -> aModeTimings [ index ] ; mode -> crtc_htotal = le16_to_cpu ( dtd_timings -> usHActive ) + le16_to_cpu ( dtd_timings -> usHBlanking_Time ) ; mode -> crtc_hdisplay = le16_to_cpu ( dtd_timings -> usHActive ) ; mode -> crtc_hsync_start = le16_to_cpu ( dtd_timings -> usHActive ) + le16_to_cpu ( dtd_timings -> usHSyncOffset ) ; mode -> crtc_hsync_end = mode -> crtc_hsync_start + le16_to_cpu ( dtd_timings -> usHSyncWidth ) ; mode -> crtc_vtotal = le16_to_cpu ( dtd_timings -> usVActive ) + le16_to_cpu ( dtd_timings -> usVBlanking_Time ) ; mode -> crtc_vdisplay = le16_to_cpu ( dtd_timings -> usVActive ) ; mode -> crtc_vsync_start = le16_to_cpu ( dtd_timings -> usVActive ) + le16_to_cpu ( dtd_timings -> usVSyncOffset ) ; mode -> crtc_vsync_end = mode -> crtc_vsync_start + le16_to_cpu ( dtd_timings -> usVSyncWidth ) ; mode -> flags = 0 ; misc = le16_to_cpu ( dtd_timings -> susModeMiscInfo . usAccess ) ; if ( misc & ATOM_VSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NVSYNC ; if ( misc & ATOM_HSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NHSYNC ; if ( misc & ATOM_COMPOSITESYNC ) mode -> flags |= DRM_MODE_FLAG_CSYNC ; if ( misc & ATOM_INTERLACE ) mode -> flags |= DRM_MODE_FLAG_INTERLACE ; if ( misc & ATOM_DOUBLE_CLOCK_MODE ) mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; mode -> clock = le16_to_cpu ( dtd_timings -> usPixClk ) * 10 ; break ; } return true ; }
xmlBuildRelativeURI ( const xmlChar * URI , const xmlChar * base ) { xmlChar * val = NULL ; int ret ; int ix ; int pos = 0 ; int nbslash = 0 ; int len ; xmlURIPtr ref = NULL ; xmlURIPtr bas = NULL ; xmlChar * bptr , * uptr , * vptr ; int remove_path = 0 ; if ( ( URI == NULL ) || ( * URI == 0 ) ) return NULL ; ref = xmlCreateURI ( ) ; if ( ref == NULL ) return NULL ; if ( URI [ 0 ] != '.' ) { ret = xmlParseURIReference ( ref , ( const char * ) URI ) ; if ( ret != 0 ) goto done ; } else ref -> path = ( char * ) xmlStrdup ( URI ) ; if ( ( base == NULL ) || ( * base == 0 ) ) { val = xmlStrdup ( URI ) ; goto done ; } bas = xmlCreateURI ( ) ; if ( bas == NULL ) goto done ; if ( base [ 0 ] != '.' ) { ret = xmlParseURIReference ( bas , ( const char * ) base ) ; if ( ret != 0 ) goto done ; } else bas -> path = ( char * ) xmlStrdup ( base ) ; if ( ( ref -> scheme != NULL ) && ( ( bas -> scheme == NULL ) || ( xmlStrcmp ( ( xmlChar * ) bas -> scheme , ( xmlChar * ) ref -> scheme ) ) || ( xmlStrcmp ( ( xmlChar * ) bas -> server , ( xmlChar * ) ref -> server ) ) ) ) { val = xmlStrdup ( URI ) ; goto done ; } if ( xmlStrEqual ( ( xmlChar * ) bas -> path , ( xmlChar * ) ref -> path ) ) { val = xmlStrdup ( BAD_CAST "" ) ; goto done ; } if ( bas -> path == NULL ) { val = xmlStrdup ( ( xmlChar * ) ref -> path ) ; goto done ; } if ( ref -> path == NULL ) { ref -> path = ( char * ) "/" ; remove_path = 1 ; } if ( bas -> path == NULL ) { if ( ref -> path != NULL ) { uptr = ( xmlChar * ) ref -> path ; if ( * uptr == '/' ) uptr ++ ; val = xmlURIEscapeStr ( uptr , BAD_CAST "/;&=+$," ) ; } goto done ; } bptr = ( xmlChar * ) bas -> path ; if ( ref -> path == NULL ) { for ( ix = 0 ; bptr [ ix ] != 0 ; ix ++ ) { if ( bptr [ ix ] == '/' ) nbslash ++ ; } uptr = NULL ; len = 1 ; } else { if ( ( ref -> path [ pos ] == '.' ) && ( ref -> path [ pos + 1 ] == '/' ) ) pos += 2 ; if ( ( * bptr == '.' ) && ( bptr [ 1 ] == '/' ) ) bptr += 2 ; else if ( ( * bptr == '/' ) && ( ref -> path [ pos ] != '/' ) ) bptr ++ ; while ( ( bptr [ pos ] == ref -> path [ pos ] ) && ( bptr [ pos ] != 0 ) ) pos ++ ; if ( bptr [ pos ] == ref -> path [ pos ] ) { val = xmlStrdup ( BAD_CAST "" ) ; goto done ; } ix = pos ; if ( ( ref -> path [ ix ] == '/' ) && ( ix > 0 ) ) ix -- ; else if ( ( ref -> path [ ix ] == 0 ) && ( ix > 1 ) && ( ref -> path [ ix - 1 ] == '/' ) ) ix -= 2 ; for ( ; ix > 0 ; ix -- ) { if ( ref -> path [ ix ] == '/' ) break ; } if ( ix == 0 ) { uptr = ( xmlChar * ) ref -> path ; } else { ix ++ ; uptr = ( xmlChar * ) & ref -> path [ ix ] ; } if ( bptr [ pos ] != ref -> path [ pos ] ) { for ( ; bptr [ ix ] != 0 ; ix ++ ) { if ( bptr [ ix ] == '/' ) nbslash ++ ; } } len = xmlStrlen ( uptr ) + 1 ; } if ( nbslash == 0 ) { if ( uptr != NULL ) val = xmlURIEscapeStr ( uptr , BAD_CAST "/;&=+$," ) ; goto done ; } val = ( xmlChar * ) xmlMalloc ( len + 3 * nbslash ) ; if ( val == NULL ) { xmlURIErrMemory ( "building relative URI\n" ) ; goto done ; } vptr = val ; for ( ; nbslash > 0 ; nbslash -- ) { * vptr ++ = '.' ; * vptr ++ = '.' ; * vptr ++ = '/' ; } if ( uptr != NULL ) { if ( ( vptr > val ) && ( len > 0 ) && ( uptr [ 0 ] == '/' ) && ( vptr [ - 1 ] == '/' ) ) { memcpy ( vptr , uptr + 1 , len - 1 ) ; vptr [ len - 2 ] = 0 ; } else { memcpy ( vptr , uptr , len ) ; vptr [ len - 1 ] = 0 ; } } else { vptr [ len - 1 ] = 0 ; } vptr = val ; val = xmlURIEscapeStr ( vptr , BAD_CAST "/;&=+$," ) ; xmlFree ( vptr ) ; done : if ( remove_path != 0 ) ref -> path = NULL ; if ( ref != NULL ) xmlFreeURI ( ref ) ; if ( bas != NULL ) xmlFreeURI ( bas ) ; return val ; }
UpgradeSchemaFrom4To5 ( mozIStorageConnection * aConnection ) { NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread!" ) ; NS_ASSERTION ( IndexedDatabaseManager :: IsMainProcess ( ) , "Wrong process!" ) ; PROFILER_LABEL ( "IndexedDB" , "UpgradeSchemaFrom4To5" ) ; nsresult rv ; nsCOMPtr < mozIStorageStatement > stmt ; rv = aConnection -> CreateStatement ( NS_LITERAL_CSTRING ( "SELECT name, version, dataVersion " "FROM database" ) , getter_AddRefs ( stmt ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsString name ; int32_t intVersion ; int64_t dataVersion ; { mozStorageStatementScoper scoper ( stmt ) ; bool hasResults ; rv = stmt -> ExecuteStep ( & hasResults ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; NS_ENSURE_TRUE ( hasResults , NS_ERROR_FAILURE ) ; nsString version ; rv = stmt -> GetString ( 1 , version ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; intVersion = version . ToInteger ( & rv ) ; if ( NS_FAILED ( rv ) ) { intVersion = 0 ; } rv = stmt -> GetString ( 0 , name ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = stmt -> GetInt64 ( 2 , & dataVersion ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( "DROP TABLE database" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( "CREATE TABLE database (" "name TEXT NOT NULL, " "version INTEGER NOT NULL DEFAULT 0, " "dataVersion INTEGER NOT NULL" ");" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aConnection -> CreateStatement ( NS_LITERAL_CSTRING ( "INSERT INTO database (name, version, dataVersion) " "VALUES (:name, :version, :dataVersion)" ) , getter_AddRefs ( stmt ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; { mozStorageStatementScoper scoper ( stmt ) ; rv = stmt -> BindStringParameter ( 0 , name ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = stmt -> BindInt32Parameter ( 1 , intVersion ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = stmt -> BindInt64Parameter ( 2 , dataVersion ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = stmt -> Execute ( ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } rv = aConnection -> SetSchemaVersion ( 5 ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; return NS_OK ; }
Handle < WeakArrayList > CompactWeakArrayList ( Heap * heap , Handle < WeakArrayList > array , PretenureFlag pretenure ) { if ( array -> length ( ) == 0 ) { return array ; } int new_length = array -> CountLiveWeakReferences ( ) ; if ( new_length == array -> length ( ) ) { return array ; } Handle < WeakArrayList > new_array = WeakArrayList :: EnsureSpace ( heap -> isolate ( ) , handle ( ReadOnlyRoots ( heap ) . empty_weak_array_list ( ) , heap -> isolate ( ) ) , new_length , pretenure ) ; int copy_to = 0 ; for ( int i = 0 ; i < array -> length ( ) ; i ++ ) { MaybeObject * element = array -> Get ( i ) ; if ( element -> IsClearedWeakHeapObject ( ) ) continue ; new_array -> Set ( copy_to ++ , element ) ; } new_array -> set_length ( copy_to ) ; return new_array ; }
static inline void set_socket_blocking ( int s , int blocking ) { int opts ; opts = fcntl ( s , F_GETFL ) ; if ( opts < 0 ) APPL_TRACE_ERROR ( "set blocking (%s)" , strerror ( errno ) ) ; if ( blocking ) opts &= ~ O_NONBLOCK ; else opts |= O_NONBLOCK ; if ( fcntl ( s , F_SETFL , opts ) < 0 ) APPL_TRACE_ERROR ( "set blocking (%s)" , strerror ( errno ) ) ; }
static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( IS_MNT_NEW ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = CL_MAKE_SHARED ; } else { struct mount * n , * p ; bool done ; for ( n = m ; ; n = p ) { p = n -> mnt_master ; if ( p == dest_master || IS_MNT_MARKED ( p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; type = CL_SLAVE ; if ( IS_MNT_SHARED ( m ) ) type |= CL_MAKE_SHARED ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) return PTR_ERR ( child ) ; child -> mnt . mnt_flags &= ~ MNT_LOCKED ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; SET_MNT_MARK ( m -> mnt_master ) ; read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ; return 0 ; }
bool JavascriptArray :: IsMissingItem ( uint32 index ) { bool isIntArray = false , isFloatArray = false ; this -> GetArrayTypeAndConvert ( & isIntArray , & isFloatArray ) ; if ( isIntArray ) { return IsMissingItemAt < int32 > ( index ) ; } else if ( isFloatArray ) { return IsMissingItemAt < double > ( index ) ; } else { return IsMissingItemAt < Var > ( index ) ; } }
void CallCollectSample ( Isolate * isolate ) { base :: LockGuard < base :: Mutex > lock ( & mutex_ ) ; auto range = profilers_ . equal_range ( isolate ) ; for ( auto it = range . first ; it != range . second ; ++ it ) { it -> second -> CollectSample ( ) ; } }
long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , "Filesystem call made without initialization" ) ; for ( search = fs_searchpaths ; search ; search = search -> next ) { len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } #ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , "%s\n" , filename ) ; #endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }
YCbCrImageDataDeserializer :: ToDataSourceSurface ( ) { RefPtr < DataSourceSurface > result = Factory :: CreateDataSourceSurface ( GetYSize ( ) , gfx :: SurfaceFormat :: B8G8R8X8 ) ; if ( NS_WARN_IF ( ! result ) ) { return nullptr ; } DataSourceSurface :: MappedSurface map ; result -> Map ( DataSourceSurface :: MapType :: WRITE , & map ) ; gfx :: ConvertYCbCrToRGB32 ( GetYData ( ) , GetCbData ( ) , GetCrData ( ) , map . mData , 0 , 0 , GetYSize ( ) . width , GetYSize ( ) . height , GetYStride ( ) , GetCbCrStride ( ) , map . mStride , gfx :: YV12 ) ; result -> Unmap ( ) ; return result . forget ( ) ; }
bool SoftVPX :: outputBuffers ( bool flushDecoder , bool display , bool eos , bool * portWillReset ) { List < BufferInfo * > & inQueue = getPortQueue ( 0 ) ; List < BufferInfo * > & outQueue = getPortQueue ( 1 ) ; BufferInfo * outInfo = NULL ; OMX_BUFFERHEADERTYPE * outHeader = NULL ; vpx_codec_iter_t iter = NULL ; if ( flushDecoder && mFrameParallelMode ) { if ( vpx_codec_decode ( ( vpx_codec_ctx_t * ) mCtx , NULL , 0 , NULL , 0 ) ) { ALOGE ( "Failed to flush on2 decoder." ) ; return false ; } } if ( ! display ) { if ( ! flushDecoder ) { ALOGE ( "Invalid operation." ) ; return false ; } while ( ( mImg = vpx_codec_get_frame ( ( vpx_codec_ctx_t * ) mCtx , & iter ) ) ) { } return true ; } while ( ! outQueue . empty ( ) ) { if ( mImg == NULL ) { mImg = vpx_codec_get_frame ( ( vpx_codec_ctx_t * ) mCtx , & iter ) ; if ( mImg == NULL ) { break ; } } uint32_t width = mImg -> d_w ; uint32_t height = mImg -> d_h ; outInfo = * outQueue . begin ( ) ; outHeader = outInfo -> mHeader ; CHECK_EQ ( mImg -> fmt , VPX_IMG_FMT_I420 ) ; handlePortSettingsChange ( portWillReset , width , height ) ; if ( * portWillReset ) { return true ; } outHeader -> nOffset = 0 ; outHeader -> nFlags = 0 ; outHeader -> nFilledLen = ( outputBufferWidth ( ) * outputBufferHeight ( ) * 3 ) / 2 ; outHeader -> nTimeStamp = * ( OMX_TICKS * ) mImg -> user_priv ; uint8_t * dst = outHeader -> pBuffer ; const uint8_t * srcY = ( const uint8_t * ) mImg -> planes [ VPX_PLANE_Y ] ; const uint8_t * srcU = ( const uint8_t * ) mImg -> planes [ VPX_PLANE_U ] ; const uint8_t * srcV = ( const uint8_t * ) mImg -> planes [ VPX_PLANE_V ] ; size_t srcYStride = mImg -> stride [ VPX_PLANE_Y ] ; size_t srcUStride = mImg -> stride [ VPX_PLANE_U ] ; size_t srcVStride = mImg -> stride [ VPX_PLANE_V ] ; copyYV12FrameToOutputBuffer ( dst , srcY , srcU , srcV , srcYStride , srcUStride , srcVStride ) ; mImg = NULL ; outInfo -> mOwnedByUs = false ; outQueue . erase ( outQueue . begin ( ) ) ; outInfo = NULL ; notifyFillBufferDone ( outHeader ) ; outHeader = NULL ; } if ( ! eos ) { return true ; } if ( ! outQueue . empty ( ) ) { outInfo = * outQueue . begin ( ) ; outQueue . erase ( outQueue . begin ( ) ) ; outHeader = outInfo -> mHeader ; outHeader -> nTimeStamp = 0 ; outHeader -> nFilledLen = 0 ; outHeader -> nFlags = OMX_BUFFERFLAG_EOS ; outInfo -> mOwnedByUs = false ; notifyFillBufferDone ( outHeader ) ; mEOSStatus = OUTPUT_FRAMES_FLUSHED ; } return true ; }
JSCompartment :: fixupBaseShapeTable ( ) { if ( ! baseShapes . initialized ( ) ) return ; for ( BaseShapeSet :: Enum e ( baseShapes ) ; ! e . empty ( ) ; e . popFront ( ) ) { UnownedBaseShape * base = e . front ( ) . unbarrieredGet ( ) ; if ( base -> fixupBaseShapeTableEntry ( ) ) { StackBaseShape sbase ( base ) ; ReadBarriered < UnownedBaseShape * > b ( base ) ; e . rekeyFront ( & sbase , b ) ; } } }
bool Type :: SlowIs ( Type that ) const { DisallowHeapAllocation no_allocation ; if ( that . IsBitset ( ) ) { return BitsetType :: Is ( this -> BitsetLub ( ) , that . AsBitset ( ) ) ; } if ( this -> IsBitset ( ) ) { return BitsetType :: Is ( this -> AsBitset ( ) , that . BitsetGlb ( ) ) ; } if ( this -> IsUnion ( ) ) { for ( int i = 0 , n = this -> AsUnion ( ) -> Length ( ) ; i < n ; ++ i ) { if ( ! this -> AsUnion ( ) -> Get ( i ) . Is ( that ) ) return false ; } return true ; } if ( that . IsUnion ( ) ) { for ( int i = 0 , n = that . AsUnion ( ) -> Length ( ) ; i < n ; ++ i ) { if ( this -> Is ( that . AsUnion ( ) -> Get ( i ) ) ) return true ; if ( i > 1 && this -> IsRange ( ) ) return false ; } return false ; } if ( that . IsRange ( ) ) { return ( this -> IsRange ( ) && Contains ( that . AsRange ( ) , this -> AsRange ( ) ) ) ; } if ( this -> IsRange ( ) ) return false ; return this -> SimplyEquals ( that ) ; }
TEST ( fxcodec , YUV420ToRGB ) { opj_image_comp_t u ; memset ( & u , 0 , sizeof ( u ) ) ; u . dx = 1 ; u . dy = 1 ; u . w = 16 ; u . h = 16 ; u . prec = 8 ; u . bpp = 8 ; opj_image_comp_t v ; memset ( & v , 0 , sizeof ( v ) ) ; v . dx = 1 ; v . dy = 1 ; v . w = 16 ; v . h = 16 ; v . prec = 8 ; v . bpp = 8 ; opj_image_comp_t y ; memset ( & y , 0 , sizeof ( y ) ) ; y . dx = 1 ; y . dy = 1 ; y . prec = 8 ; y . bpp = 8 ; opj_image_t img ; memset ( & img , 0 , sizeof ( img ) ) ; img . numcomps = 3 ; img . color_space = OPJ_CLRSPC_SYCC ; img . comps = FX_Alloc ( opj_image_comp_t , 3 ) ; const struct { OPJ_UINT32 w ; bool expected ; } cases [ ] = { { 0 , false } , { 1 , false } , { 30 , false } , { 31 , true } , { 32 , true } , { 33 , false } , { 34 , false } , { UINT_MAX , false } } ; for ( int i = 0 ; i < sizeof ( cases ) / sizeof ( cases [ 0 ] ) ; ++ i ) { y . w = cases [ i ] . w ; y . h = y . w ; img . x1 = y . w ; img . y1 = y . h ; y . data = FX_Alloc ( OPJ_INT32 , y . w * y . h ) ; memset ( y . data , 1 , y . w * y . h * sizeof ( OPJ_INT32 ) ) ; u . data = FX_Alloc ( OPJ_INT32 , u . w * u . h ) ; memset ( u . data , 0 , u . w * u . h * sizeof ( OPJ_INT32 ) ) ; v . data = FX_Alloc ( OPJ_INT32 , v . w * v . h ) ; memset ( v . data , 0 , v . w * v . h * sizeof ( OPJ_INT32 ) ) ; img . comps [ 0 ] = y ; img . comps [ 1 ] = u ; img . comps [ 2 ] = v ; sycc420_to_rgb ( & img ) ; if ( cases [ i ] . expected ) { EXPECT_EQ ( img . comps [ 0 ] . w , img . comps [ 1 ] . w ) ; EXPECT_EQ ( img . comps [ 0 ] . h , img . comps [ 1 ] . h ) ; EXPECT_EQ ( img . comps [ 0 ] . w , img . comps [ 2 ] . w ) ; EXPECT_EQ ( img . comps [ 0 ] . h , img . comps [ 2 ] . h ) ; } else { EXPECT_NE ( img . comps [ 0 ] . w , img . comps [ 1 ] . w ) ; EXPECT_NE ( img . comps [ 0 ] . h , img . comps [ 1 ] . h ) ; EXPECT_NE ( img . comps [ 0 ] . w , img . comps [ 2 ] . w ) ; EXPECT_NE ( img . comps [ 0 ] . h , img . comps [ 2 ] . h ) ; } FX_Free ( img . comps [ 0 ] . data ) ; FX_Free ( img . comps [ 1 ] . data ) ; FX_Free ( img . comps [ 2 ] . data ) ; } FX_Free ( img . comps ) ; }
void vp8_rtcd ( ) { vpx_scale_rtcd ( ) ; once ( setup_rtcd_internal ) ; }
void StressMarkingObserver :: Step ( int bytes_allocated , Address soon_object , size_t size ) { heap_ . StartIncrementalMarkingIfAllocationLimitIsReached ( Heap :: kNoGCFlags , kNoGCCallbackFlags ) ; }
sctp_ss_default_select ( struct sctp_tcb * stcb SCTP_UNUSED , struct sctp_nets * net , struct sctp_association * asoc ) { struct sctp_stream_out * strq , * strqt ; if ( asoc -> ss_data . locked_on_sending ) { return ( asoc -> ss_data . locked_on_sending ) ; } strqt = asoc -> ss_data . last_out_stream ; default_again : if ( strqt == NULL ) { strq = TAILQ_FIRST ( & asoc -> ss_data . out . wheel ) ; } else { strq = TAILQ_NEXT ( strqt , ss_params . rr . next_spoke ) ; if ( strq == NULL ) { strq = TAILQ_FIRST ( & asoc -> ss_data . out . wheel ) ; } } if ( net != NULL && strq != NULL && SCTP_BASE_SYSCTL ( sctp_cmt_on_off ) == 0 ) { if ( TAILQ_FIRST ( & strq -> outqueue ) && TAILQ_FIRST ( & strq -> outqueue ) -> net != NULL && TAILQ_FIRST ( & strq -> outqueue ) -> net != net ) { if ( strq == asoc -> ss_data . last_out_stream ) { return ( NULL ) ; } else { strqt = strq ; goto default_again ; } } } return ( strq ) ; }
nsChromeRegistry :: Canonify ( nsIURL * aChromeURL ) { NS_NAMED_LITERAL_CSTRING ( kSlash , "/" ) ; nsresult rv ; nsAutoCString provider , path ; rv = GetProviderAndPath ( aChromeURL , provider , path ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( path . IsEmpty ( ) ) { nsAutoCString package ; rv = aChromeURL -> GetHost ( package ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; path . Assign ( kSlash + provider + kSlash + package ) ; if ( provider . EqualsLiteral ( "content" ) ) { path . AppendLiteral ( ".xul" ) ; } else if ( provider . EqualsLiteral ( "locale" ) ) { path . AppendLiteral ( ".dtd" ) ; } else if ( provider . EqualsLiteral ( "skin" ) ) { path . AppendLiteral ( ".css" ) ; } else { return NS_ERROR_INVALID_ARG ; } aChromeURL -> SetPathQueryRef ( path ) ; } else { const char * pos = path . BeginReading ( ) ; const char * end = path . EndReading ( ) ; while ( pos < end ) { switch ( * pos ) { case ':' : return NS_ERROR_DOM_BAD_URI ; case '.' : if ( pos [ 1 ] == '.' ) return NS_ERROR_DOM_BAD_URI ; break ; case '%' : if ( pos [ 1 ] == '2' && ( pos [ 2 ] == 'e' || pos [ 2 ] == 'E' || pos [ 2 ] == '5' ) ) return NS_ERROR_DOM_BAD_URI ; break ; case '?' : case '#' : pos = end ; continue ; } ++ pos ; } } return NS_OK ; }
bit_in ( PG_FUNCTION_ARGS ) { char * input_string = PG_GETARG_CSTRING ( 0 ) ; #ifdef NOT_USED Oid typelem = PG_GETARG_OID ( 1 ) ; #endif int32 atttypmod = PG_GETARG_INT32 ( 2 ) ; VarBit * result ; char * sp ; bits8 * r ; int len , bitlen , slen ; bool bit_not_hex ; int bc ; bits8 x = 0 ; if ( input_string [ 0 ] == 'b' || input_string [ 0 ] == 'B' ) { bit_not_hex = true ; sp = input_string + 1 ; } else if ( input_string [ 0 ] == 'x' || input_string [ 0 ] == 'X' ) { bit_not_hex = false ; sp = input_string + 1 ; } else { bit_not_hex = true ; sp = input_string ; } slen = strlen ( sp ) ; if ( bit_not_hex ) bitlen = slen ; else bitlen = slen * 4 ; if ( atttypmod <= 0 ) atttypmod = bitlen ; else if ( bitlen != atttypmod ) ereport ( ERROR , ( errcode ( ERRCODE_STRING_DATA_LENGTH_MISMATCH ) , errmsg ( "bit string length %d does not match type bit(%d)" , bitlen , atttypmod ) ) ) ; len = VARBITTOTALLEN ( atttypmod ) ; result = ( VarBit * ) palloc0 ( len ) ; SET_VARSIZE ( result , len ) ; VARBITLEN ( result ) = atttypmod ; r = VARBITS ( result ) ; if ( bit_not_hex ) { x = HIGHBIT ; for ( ; * sp ; sp ++ ) { if ( * sp == '1' ) * r |= x ; else if ( * sp != '0' ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( "\"%c\" is not a valid binary digit" , * sp ) ) ) ; x >>= 1 ; if ( x == 0 ) { x = HIGHBIT ; r ++ ; } } } else { for ( bc = 0 ; * sp ; sp ++ ) { if ( * sp >= '0' && * sp <= '9' ) x = ( bits8 ) ( * sp - '0' ) ; else if ( * sp >= 'A' && * sp <= 'F' ) x = ( bits8 ) ( * sp - 'A' ) + 10 ; else if ( * sp >= 'a' && * sp <= 'f' ) x = ( bits8 ) ( * sp - 'a' ) + 10 ; else ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( "\"%c\" is not a valid hexadecimal digit" , * sp ) ) ) ; if ( bc ) { * r ++ |= x ; bc = 0 ; } else { * r = x < < 4 ; bc = 1 ; } } } PG_RETURN_VARBIT_P ( result ) ; }
NS_IMPL_ELEMENT_CLONE_WITH_INIT ( SVGFEFloodElement ) FilterPrimitiveDescription SVGFEFloodElement :: GetPrimitiveDescription ( nsSVGFilterInstance * aInstance , const IntRect & aFilterSubregion , nsTArray < RefPtr < SourceSurface > > & aInputImages ) { FilterPrimitiveDescription descr ( FilterPrimitiveDescription :: eFlood ) ; nsIFrame * frame = GetPrimaryFrame ( ) ; if ( frame ) { nsStyleContext * style = frame -> StyleContext ( ) ; nscolor floodColor = style -> StyleSVGReset ( ) -> mFloodColor ; float floodOpacity = style -> StyleSVGReset ( ) -> mFloodOpacity ; Color color ( NS_GET_R ( floodColor ) / 255.0 , NS_GET_G ( floodColor ) / 255.0 , NS_GET_B ( floodColor ) / 255.0 , NS_GET_A ( floodColor ) / 255.0 * floodOpacity ) ; descr . Attributes ( ) . Set ( eFloodColor , color ) ; } else { descr . Attributes ( ) . Set ( eFloodColor , Color ( ) ) ; } return descr ; }
long long EBMLHeader :: Parse ( IMkvReader * pReader , long long & pos ) { assert ( pReader ) ; long long total , available ; long status = pReader -> Length ( & total , & available ) ; if ( status < 0 ) return status ; pos = 0 ; long long end = ( available >= 1024 ) ? 1024 : available ; for ( ; ; ) { unsigned char b = 0 ; while ( pos < end ) { status = pReader -> Read ( pos , 1 , & b ) ; if ( status < 0 ) return status ; if ( b == 0x1A ) break ; ++ pos ; } if ( b != 0x1A ) { if ( pos >= 1024 ) return E_FILE_FORMAT_INVALID ; if ( ( total >= 0 ) && ( ( total - available ) < 5 ) ) return E_FILE_FORMAT_INVALID ; return available + 5 ; } if ( ( total >= 0 ) && ( ( total - pos ) < 5 ) ) return E_FILE_FORMAT_INVALID ; if ( ( available - pos ) < 5 ) return pos + 5 ; long len ; const long long result = ReadUInt ( pReader , pos , len ) ; if ( result < 0 ) return result ; if ( result == 0x0A45DFA3 ) { pos += len ; break ; } ++ pos ; } long len ; long long result = GetUIntLength ( pReader , pos , len ) ; if ( result < 0 ) return result ; if ( result > 0 ) return result ; assert ( len > 0 ) ; assert ( len <= 8 ) ; if ( ( total >= 0 ) && ( ( total - pos ) < len ) ) return E_FILE_FORMAT_INVALID ; if ( ( available - pos ) < len ) return pos + len ; result = ReadUInt ( pReader , pos , len ) ; if ( result < 0 ) return result ; pos += len ; if ( ( total >= 0 ) && ( ( total - pos ) < result ) ) return E_FILE_FORMAT_INVALID ; if ( ( available - pos ) < result ) return pos + result ; end = pos + result ; Init ( ) ; while ( pos < end ) { long long id , size ; status = ParseElementHeader ( pReader , pos , end , id , size ) ; if ( status < 0 ) return status ; if ( size == 0 ) return E_FILE_FORMAT_INVALID ; if ( id == 0x0286 ) { m_version = UnserializeUInt ( pReader , pos , size ) ; if ( m_version <= 0 ) return E_FILE_FORMAT_INVALID ; } else if ( id == 0x02F7 ) { m_readVersion = UnserializeUInt ( pReader , pos , size ) ; if ( m_readVersion <= 0 ) return E_FILE_FORMAT_INVALID ; } else if ( id == 0x02F2 ) { m_maxIdLength = UnserializeUInt ( pReader , pos , size ) ; if ( m_maxIdLength <= 0 ) return E_FILE_FORMAT_INVALID ; } else if ( id == 0x02F3 ) { m_maxSizeLength = UnserializeUInt ( pReader , pos , size ) ; if ( m_maxSizeLength <= 0 ) return E_FILE_FORMAT_INVALID ; } else if ( id == 0x0282 ) { if ( m_docType ) return E_FILE_FORMAT_INVALID ; status = UnserializeString ( pReader , pos , size , m_docType ) ; if ( status ) return status ; } else if ( id == 0x0287 ) { m_docTypeVersion = UnserializeUInt ( pReader , pos , size ) ; if ( m_docTypeVersion <= 0 ) return E_FILE_FORMAT_INVALID ; } else if ( id == 0x0285 ) { m_docTypeReadVersion = UnserializeUInt ( pReader , pos , size ) ; if ( m_docTypeReadVersion <= 0 ) return E_FILE_FORMAT_INVALID ; } pos += size ; } assert ( pos == end ) ; return 0 ; }
nsComboboxControlFrame :: ShowDropDown ( bool aDoDropDown ) { nsEventStates eventStates = mContent -> AsElement ( ) -> State ( ) ; if ( eventStates . HasState ( NS_EVENT_STATE_DISABLED ) ) { return ; } if ( ! mDroppedDown && aDoDropDown ) { if ( mListControlFrame ) { mListControlFrame -> SyncViewWithFrame ( ) ; } ShowList ( aDoDropDown ) ; } else if ( mDroppedDown && ! aDoDropDown ) { ShowList ( aDoDropDown ) ; } }
void StringBuiltinsAssembler :: GenerateStringRelationalComparison ( Node * context , Node * left , Node * right , Operation op ) { VARIABLE ( var_left , MachineRepresentation :: kTagged , left ) ; VARIABLE ( var_right , MachineRepresentation :: kTagged , right ) ; Variable * input_vars [ 2 ] = { & var_left , & var_right } ; Label if_less ( this ) , if_equal ( this ) , if_greater ( this ) ; Label restart ( this , 2 , input_vars ) ; Goto ( & restart ) ; BIND ( & restart ) ; Node * lhs = var_left . value ( ) ; Node * rhs = var_right . value ( ) ; GotoIf ( WordEqual ( lhs , rhs ) , & if_equal ) ; Node * lhs_instance_type = LoadInstanceType ( lhs ) ; Node * rhs_instance_type = LoadInstanceType ( rhs ) ; Node * both_instance_types = Word32Or ( lhs_instance_type , Word32Shl ( rhs_instance_type , Int32Constant ( 8 ) ) ) ; int const kBothSeqOneByteStringMask = kStringEncodingMask | kStringRepresentationMask | ( ( kStringEncodingMask | kStringRepresentationMask ) < < 8 ) ; int const kBothSeqOneByteStringTag = kOneByteStringTag | kSeqStringTag | ( ( kOneByteStringTag | kSeqStringTag ) < < 8 ) ; Label if_bothonebyteseqstrings ( this ) , if_notbothonebyteseqstrings ( this ) ; Branch ( Word32Equal ( Word32And ( both_instance_types , Int32Constant ( kBothSeqOneByteStringMask ) ) , Int32Constant ( kBothSeqOneByteStringTag ) ) , & if_bothonebyteseqstrings , & if_notbothonebyteseqstrings ) ; BIND ( & if_bothonebyteseqstrings ) ; { TNode < IntPtrT > lhs_length = LoadStringLengthAsWord ( lhs ) ; TNode < IntPtrT > rhs_length = LoadStringLengthAsWord ( rhs ) ; TNode < IntPtrT > length = IntPtrMin ( lhs_length , rhs_length ) ; TNode < IntPtrT > begin = IntPtrConstant ( SeqOneByteString :: kHeaderSize - kHeapObjectTag ) ; TNode < IntPtrT > end = IntPtrAdd ( begin , length ) ; TVARIABLE ( IntPtrT , var_offset , begin ) ; Label loop ( this , & var_offset ) ; Goto ( & loop ) ; BIND ( & loop ) ; { Label if_done ( this ) , if_notdone ( this ) ; Branch ( WordEqual ( var_offset . value ( ) , end ) , & if_done , & if_notdone ) ; BIND ( & if_notdone ) ; { Node * lhs_value = Load ( MachineType :: Uint8 ( ) , lhs , var_offset . value ( ) ) ; Node * rhs_value = Load ( MachineType :: Uint8 ( ) , rhs , var_offset . value ( ) ) ; Label if_valueissame ( this ) , if_valueisnotsame ( this ) ; Branch ( Word32Equal ( lhs_value , rhs_value ) , & if_valueissame , & if_valueisnotsame ) ; BIND ( & if_valueissame ) ; { var_offset = IntPtrAdd ( var_offset . value ( ) , IntPtrConstant ( 1 ) ) ; } Goto ( & loop ) ; BIND ( & if_valueisnotsame ) ; Branch ( Uint32LessThan ( lhs_value , rhs_value ) , & if_less , & if_greater ) ; } BIND ( & if_done ) ; { GotoIf ( IntPtrEqual ( lhs_length , rhs_length ) , & if_equal ) ; Branch ( IntPtrLessThan ( lhs_length , rhs_length ) , & if_less , & if_greater ) ; } } } BIND ( & if_notbothonebyteseqstrings ) ; { MaybeDerefIndirectStrings ( & var_left , lhs_instance_type , & var_right , rhs_instance_type , & restart ) ; switch ( op ) { case Operation :: kLessThan : TailCallRuntime ( Runtime :: kStringLessThan , context , lhs , rhs ) ; break ; case Operation :: kLessThanOrEqual : TailCallRuntime ( Runtime :: kStringLessThanOrEqual , context , lhs , rhs ) ; break ; case Operation :: kGreaterThan : TailCallRuntime ( Runtime :: kStringGreaterThan , context , lhs , rhs ) ; break ; case Operation :: kGreaterThanOrEqual : TailCallRuntime ( Runtime :: kStringGreaterThanOrEqual , context , lhs , rhs ) ; break ; default : UNREACHABLE ( ) ; } } BIND ( & if_less ) ; switch ( op ) { case Operation :: kLessThan : case Operation :: kLessThanOrEqual : Return ( TrueConstant ( ) ) ; break ; case Operation :: kGreaterThan : case Operation :: kGreaterThanOrEqual : Return ( FalseConstant ( ) ) ; break ; default : UNREACHABLE ( ) ; } BIND ( & if_equal ) ; switch ( op ) { case Operation :: kLessThan : case Operation :: kGreaterThan : Return ( FalseConstant ( ) ) ; break ; case Operation :: kLessThanOrEqual : case Operation :: kGreaterThanOrEqual : Return ( TrueConstant ( ) ) ; break ; default : UNREACHABLE ( ) ; } BIND ( & if_greater ) ; switch ( op ) { case Operation :: kLessThan : case Operation :: kLessThanOrEqual : Return ( FalseConstant ( ) ) ; break ; case Operation :: kGreaterThan : case Operation :: kGreaterThanOrEqual : Return ( TrueConstant ( ) ) ; break ; default : UNREACHABLE ( ) ; } }
tt_cmap10_char_index ( TT_CMap cmap , FT_UInt32 char_code ) { FT_Byte * table = cmap -> data ; FT_UInt result = 0 ; FT_Byte * p = table + 12 ; FT_UInt32 start = TT_NEXT_ULONG ( p ) ; FT_UInt32 count = TT_NEXT_ULONG ( p ) ; FT_UInt32 idx = ( FT_ULong ) ( char_code - start ) ; if ( idx < count ) { p += 2 * idx ; result = TT_PEEK_USHORT ( p ) ; } return result ; }
static int l2cap_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_l2 * la = ( struct sockaddr_l2 * ) addr ; struct sock * sk = sock -> sk ; struct l2cap_chan * chan = l2cap_pi ( sk ) -> chan ; BT_DBG ( "sock %p, sk %p" , sock , sk ) ; addr -> sa_family = AF_BLUETOOTH ; * len = sizeof ( struct sockaddr_l2 ) ; if ( peer ) { la -> l2_psm = chan -> psm ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> dst ) ; la -> l2_cid = cpu_to_le16 ( chan -> dcid ) ; } else { la -> l2_psm = chan -> sport ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> src ) ; la -> l2_cid = cpu_to_le16 ( chan -> scid ) ; } return 0 ; }
static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , struct iovec * iovec ) { if ( unlikely ( ! access_ok ( ! rw , buf , kiocb -> ki_nbytes ) ) ) return - EFAULT ; iovec -> iov_base = buf ; iovec -> iov_len = kiocb -> ki_nbytes ; * nr_segs = 1 ; return 0 ; }
nsPrintEngine :: CommonPrint ( bool aIsPrintPreview , nsIPrintSettings * aPrintSettings , nsIWebProgressListener * aWebProgressListener , nsIDOMDocument * aDoc ) { nsresult rv = DoCommonPrint ( aIsPrintPreview , aPrintSettings , aWebProgressListener , aDoc ) ; if ( NS_FAILED ( rv ) ) { if ( aIsPrintPreview ) { SetIsCreatingPrintPreview ( false ) ; SetIsPrintPreview ( false ) ; } else { SetIsPrinting ( false ) ; } if ( mProgressDialogIsShown ) CloseProgressDialog ( aWebProgressListener ) ; if ( rv != NS_ERROR_ABORT && rv != NS_ERROR_OUT_OF_MEMORY ) ShowPrintErrorDialog ( rv , ! aIsPrintPreview ) ; delete mPrt ; mPrt = nullptr ; } return rv ; }
void BytecodeGenerator :: BuildVariableAssignment ( Variable * variable , Token :: Value op , HoleCheckMode hole_check_mode , LookupHoistingMode lookup_hoisting_mode ) { VariableMode mode = variable -> mode ( ) ; RegisterAllocationScope assignment_register_scope ( this ) ; BytecodeLabel end_label ; switch ( variable -> location ( ) ) { case VariableLocation :: PARAMETER : case VariableLocation :: LOCAL : { Register destination ; if ( VariableLocation :: PARAMETER == variable -> location ( ) ) { if ( variable -> IsReceiver ( ) ) { destination = builder ( ) -> Receiver ( ) ; } else { destination = builder ( ) -> Parameter ( variable -> index ( ) ) ; } } else { destination = builder ( ) -> Local ( variable -> index ( ) ) ; } if ( hole_check_mode == HoleCheckMode :: kRequired ) { Register value_temp = register_allocator ( ) -> NewRegister ( ) ; builder ( ) -> StoreAccumulatorInRegister ( value_temp ) . LoadAccumulatorWithRegister ( destination ) ; BuildHoleCheckForVariableAssignment ( variable , op ) ; builder ( ) -> LoadAccumulatorWithRegister ( value_temp ) ; } if ( mode != VariableMode :: kConst || op == Token :: INIT ) { builder ( ) -> StoreAccumulatorInRegister ( destination ) ; } else if ( variable -> throw_on_const_assignment ( language_mode ( ) ) ) { builder ( ) -> CallRuntime ( Runtime :: kThrowConstAssignError ) ; } break ; } case VariableLocation :: UNALLOCATED : { FeedbackSlot slot = GetCachedStoreGlobalICSlot ( language_mode ( ) , variable ) ; builder ( ) -> StoreGlobal ( variable -> raw_name ( ) , feedback_index ( slot ) ) ; break ; } case VariableLocation :: CONTEXT : { int depth = execution_context ( ) -> ContextChainDepth ( variable -> scope ( ) ) ; ContextScope * context = execution_context ( ) -> Previous ( depth ) ; Register context_reg ; if ( context ) { context_reg = context -> reg ( ) ; depth = 0 ; } else { context_reg = execution_context ( ) -> reg ( ) ; } if ( hole_check_mode == HoleCheckMode :: kRequired ) { Register value_temp = register_allocator ( ) -> NewRegister ( ) ; builder ( ) -> StoreAccumulatorInRegister ( value_temp ) . LoadContextSlot ( context_reg , variable -> index ( ) , depth , BytecodeArrayBuilder :: kMutableSlot ) ; BuildHoleCheckForVariableAssignment ( variable , op ) ; builder ( ) -> LoadAccumulatorWithRegister ( value_temp ) ; } if ( mode != VariableMode :: kConst || op == Token :: INIT ) { builder ( ) -> StoreContextSlot ( context_reg , variable -> index ( ) , depth ) ; } else if ( variable -> throw_on_const_assignment ( language_mode ( ) ) ) { builder ( ) -> CallRuntime ( Runtime :: kThrowConstAssignError ) ; } break ; } case VariableLocation :: LOOKUP : { builder ( ) -> StoreLookupSlot ( variable -> raw_name ( ) , language_mode ( ) , lookup_hoisting_mode ) ; break ; } case VariableLocation :: MODULE : { DCHECK ( IsDeclaredVariableMode ( mode ) ) ; if ( mode == VariableMode :: kConst && op != Token :: INIT ) { builder ( ) -> CallRuntime ( Runtime :: kThrowConstAssignError ) ; break ; } DCHECK ( variable -> IsExport ( ) ) ; int depth = execution_context ( ) -> ContextChainDepth ( variable -> scope ( ) ) ; if ( hole_check_mode == HoleCheckMode :: kRequired ) { Register value_temp = register_allocator ( ) -> NewRegister ( ) ; builder ( ) -> StoreAccumulatorInRegister ( value_temp ) . LoadModuleVariable ( variable -> index ( ) , depth ) ; BuildHoleCheckForVariableAssignment ( variable , op ) ; builder ( ) -> LoadAccumulatorWithRegister ( value_temp ) ; } builder ( ) -> StoreModuleVariable ( variable -> index ( ) , depth ) ; break ; } } }
BUILTIN ( LocalePrototypeRegion ) { HandleScope scope ( isolate ) ; CHECK_RECEIVER ( JSLocale , locale_holder , "Intl.Locale.prototype.region" ) ; return locale_holder -> region ( ) ; }
static vpx_codec_err_t vp8e_set_scalemode ( vpx_codec_alg_priv_t * ctx , int ctr_id , va_list args ) { vpx_scaling_mode_t * data = va_arg ( args , vpx_scaling_mode_t * ) ; if ( data ) { int res ; vpx_scaling_mode_t scalemode = * ( vpx_scaling_mode_t * ) data ; res = vp8_set_internal_size ( ctx -> cpi , ( VPX_SCALING ) scalemode . h_scaling_mode , ( VPX_SCALING ) scalemode . v_scaling_mode ) ; if ( ! res ) { ctx -> next_frame_flag |= FRAMEFLAGS_KEY ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; } else return VPX_CODEC_INVALID_PARAM ; }
void Compute ( OpKernelContext * context ) override { const Tensor & tensor_in_shape = context -> input ( 0 ) ; const Tensor & out_backprop = context -> input ( 1 ) ; OP_REQUIRES ( context , tensor_in_shape . dims ( ) == 1 && tensor_in_shape . NumElements ( ) == 4 , errors :: InvalidArgument ( "out_backprop must be 1-dimensional and 4 " "elements" ) ) ; OP_REQUIRES ( context , out_backprop . dims ( ) == 4 , errors :: InvalidArgument ( "out_backprop must be 4-dimensional" ) ) ; TensorShape output_shape ; auto shape_vec = tensor_in_shape . vec < int32 > ( ) ; for ( int64_t i = 0 ; i < tensor_in_shape . NumElements ( ) ; ++ i ) { output_shape . AddDim ( shape_vec ( i ) ) ; } if ( output_shape . num_elements ( ) == 0 ) { Tensor * output = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , output_shape , & output ) ) ; return ; } DnnPoolingGradOp < T > :: Compute ( context , se :: dnn :: PoolingMode :: kAverage , ksize_ , stride_ , padding_ , { } , data_format_ , nullptr , nullptr , out_backprop , output_shape , false ) ; }
void * pvPortMalloc ( size_t xWantedSize ) { BlockLink_t * pxBlock , * pxPreviousBlock , * pxNewBlockLink ; void * pvReturn = NULL ; vTaskSuspendAll ( ) ; { if ( pxEnd == NULL ) { prvHeapInit ( ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) { if ( xWantedSize > 0 ) { xWantedSize += xHeapStructSize ; if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; configASSERT ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) ) { pxPreviousBlock = & xStart ; pxBlock = xStart . pxNextFreeBlock ; while ( ( pxBlock -> xBlockSize < xWantedSize ) && ( pxBlock -> pxNextFreeBlock != NULL ) ) { pxPreviousBlock = pxBlock ; pxBlock = pxBlock -> pxNextFreeBlock ; } if ( pxBlock != pxEnd ) { pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock -> pxNextFreeBlock ) + xHeapStructSize ) ; pxPreviousBlock -> pxNextFreeBlock = pxBlock -> pxNextFreeBlock ; if ( ( pxBlock -> xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ) ; configASSERT ( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 ) ; pxNewBlockLink -> xBlockSize = pxBlock -> xBlockSize - xWantedSize ; pxBlock -> xBlockSize = xWantedSize ; prvInsertBlockIntoFreeList ( pxNewBlockLink ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } xFreeBytesRemaining -= pxBlock -> xBlockSize ; if ( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining ) { xMinimumEverFreeBytesRemaining = xFreeBytesRemaining ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } pxBlock -> xBlockSize |= xBlockAllocatedBit ; pxBlock -> pxNextFreeBlock = NULL ; xNumberOfSuccessfulAllocations ++ ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } traceMALLOC ( pvReturn , xWantedSize ) ; } ( void ) xTaskResumeAll ( ) ; #if ( configUSE_MALLOC_FAILED_HOOK == 1 ) { if ( pvReturn == NULL ) { extern void vApplicationMallocFailedHook ( void ) ; vApplicationMallocFailedHook ( ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */ configASSERT ( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 ) ; return pvReturn ; }
void PrintInlinedFunctionInfo ( OptimizedCompilationInfo * info , Isolate * isolate , int source_id , int inlining_id , const OptimizedCompilationInfo :: InlinedFunctionHolder & h ) { CodeTracer :: Scope tracing_scope ( isolate -> GetCodeTracer ( ) ) ; OFStream os ( tracing_scope . file ( ) ) ; os < < "INLINE (" < < h . shared_info -> DebugName ( ) -> ToCString ( ) . get ( ) < < ") id{" < < info -> optimization_id ( ) < < "," < < source_id < < "} AS " < < inlining_id < < " AT " ; const SourcePosition position = h . position . position ; if ( position . IsKnown ( ) ) { os < < "<" < < position . InliningId ( ) < < ":" < < position . ScriptOffset ( ) < < ">" ; } else { os < < "<?>" ; } os < < std :: endl ; }
js :: jit :: DeallocateExecutableMemory ( void * addr , size_t bytes , size_t pageSize ) { MOZ_ASSERT ( bytes % pageSize == 0 ) ; mozilla :: DebugOnly < int > result = munmap ( addr , bytes ) ; MOZ_ASSERT ( ! result || errno == ENOMEM ) ; }
static void my_free ( void * ptr ) { free_called += 1 ; free ( ptr ) ; }
void BytecodeGraphBuilder :: VisitCreateFunctionContext ( ) { Handle < ScopeInfo > scope_info ( ScopeInfo :: cast ( bytecode_iterator ( ) . GetConstantForIndexOperand ( 0 ) ) , isolate ( ) ) ; uint32_t slots = bytecode_iterator ( ) . GetUnsignedImmediateOperand ( 1 ) ; const Operator * op = javascript ( ) -> CreateFunctionContext ( scope_info , slots , FUNCTION_SCOPE ) ; Node * context = NewNode ( op ) ; environment ( ) -> BindAccumulator ( context ) ; }
JNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompressHeader ( JNIEnv * env , jobject obj , jbyteArray src , jint jpegSize ) { tjhandle handle = 0 ; unsigned char * jpegBuf = NULL ; int width = 0 , height = 0 , jpegSubsamp = - 1 , jpegColorspace = - 1 ; gethandle ( ) ; if ( ( * env ) -> GetArrayLength ( env , src ) < jpegSize ) _throwarg ( "Source buffer is not large enough" ) ; bailif0 ( jpegBuf = ( * env ) -> GetPrimitiveArrayCritical ( env , src , 0 ) ) ; if ( tjDecompressHeader3 ( handle , jpegBuf , ( unsigned long ) jpegSize , & width , & height , & jpegSubsamp , & jpegColorspace ) == - 1 ) _throwtj ( ) ; ( * env ) -> ReleasePrimitiveArrayCritical ( env , src , jpegBuf , 0 ) ; jpegBuf = NULL ; bailif0 ( _fid = ( * env ) -> GetFieldID ( env , _cls , "jpegSubsamp" , "I" ) ) ; ( * env ) -> SetIntField ( env , obj , _fid , jpegSubsamp ) ; if ( ( _fid = ( * env ) -> GetFieldID ( env , _cls , "jpegColorspace" , "I" ) ) == 0 ) ( * env ) -> ExceptionClear ( env ) ; else ( * env ) -> SetIntField ( env , obj , _fid , jpegColorspace ) ; bailif0 ( _fid = ( * env ) -> GetFieldID ( env , _cls , "jpegWidth" , "I" ) ) ; ( * env ) -> SetIntField ( env , obj , _fid , width ) ; bailif0 ( _fid = ( * env ) -> GetFieldID ( env , _cls , "jpegHeight" , "I" ) ) ; ( * env ) -> SetIntField ( env , obj , _fid , height ) ; bailout : if ( jpegBuf ) ( * env ) -> ReleasePrimitiveArrayCritical ( env , src , jpegBuf , 0 ) ; }
gfxFontStyle :: gfxFontStyle ( uint8_t aStyle , uint16_t aWeight , int16_t aStretch , gfxFloat aSize , nsIAtom * aLanguage , float aSizeAdjust , bool aSystemFont , bool aPrinterFont , const nsString & aLanguageOverride ) : language ( aLanguage ) , size ( aSize ) , sizeAdjust ( aSizeAdjust ) , languageOverride ( ParseFontLanguageOverride ( aLanguageOverride ) ) , weight ( aWeight ) , stretch ( aStretch ) , systemFont ( aSystemFont ) , printerFont ( aPrinterFont ) , style ( aStyle ) { if ( weight > 900 ) weight = 900 ; if ( weight < 100 ) weight = 100 ; if ( size >= FONT_MAX_SIZE ) { size = FONT_MAX_SIZE ; sizeAdjust = 0.0 ; } else if ( size < 0.0 ) { NS_WARNING ( "negative font size" ) ; size = 0.0 ; } if ( ! language ) { NS_WARNING ( "null language" ) ; language = nsGkAtoms :: x_western ; } }
void NetworkUtils :: preTetherInterfaceList ( CommandChain * aChain , CommandCallback aCallback , NetworkResultOptions & aResult ) { char command [ MAX_COMMAND_SIZE ] ; if ( SDK_VERSION >= 16 ) { snprintf ( command , MAX_COMMAND_SIZE - 1 , "tether interface list" ) ; } else { snprintf ( command , MAX_COMMAND_SIZE - 1 , "tether interface list 0" ) ; } doCommand ( command , aChain , aCallback ) ; }
} return ( status ) ; } static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { #define CheckNumberCompactPixels \   if (packets == 0) \     return(i); \   packets-- #define CheckNumberPixels(count) \   if (((ssize_t) i + count) > (ssize_t) number_pixels) \     return(i); \   i+=count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel > > 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel > > 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel > > 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel > > 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel > > 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel > > 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel > > 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel > > 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel > > 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel > > 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel > > 2 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x03 ) & 0x03 ) ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( unsigned char ) ( ( pixel > > 4 ) & 0xff ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x0f ) & 0xff ) ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( unsigned char ) pixel ; break ; } } } continue ; } length ++ ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( * compact_pixels > > 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels > > 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels > > 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels > > 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels > > 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels > > 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels > > 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels > > 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( * compact_pixels > > 6 ) & 0x03 ; * pixels ++ = ( * compact_pixels > > 4 ) & 0x03 ; * pixels ++ = ( * compact_pixels > > 2 ) & 0x03 ; * pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( * compact_pixels > > 4 ) & 0xff ; * pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( * compact_pixels ) ; break ; } } CheckNumberCompactPixels ;
static void update_scheduling_stats ( alarm_stats_t * stats , period_ms_t now_ms , period_ms_t deadline_ms , period_ms_t execution_delta_ms ) { stats -> total_updates ++ ; stats -> last_update_ms = now_ms ; update_stat ( & stats -> callback_execution , execution_delta_ms ) ; if ( deadline_ms < now_ms ) { period_ms_t delta_ms = now_ms - deadline_ms ; update_stat ( & stats -> overdue_scheduling , delta_ms ) ; } else if ( deadline_ms > now_ms ) { period_ms_t delta_ms = deadline_ms - now_ms ; update_stat ( & stats -> premature_scheduling , delta_ms ) ; } }
void F32Const ( FullDecoder * decoder , Value * result , float value ) { LiftoffRegister reg = __ GetUnusedRegister ( kFpReg ) ; __ LoadConstant ( reg , WasmValue ( value ) ) ; __ PushRegister ( kWasmF32 , reg ) ; }
std :: ostream & operator < < ( std :: ostream & os , NumberOperationHint hint ) { switch ( hint ) { case NumberOperationHint :: kSignedSmall : return os < < "SignedSmall" ; case NumberOperationHint :: kSignedSmallInputs : return os < < "SignedSmallInputs" ; case NumberOperationHint :: kSigned32 : return os < < "Signed32" ; case NumberOperationHint :: kNumber : return os < < "Number" ; case NumberOperationHint :: kNumberOrOddball : return os < < "NumberOrOddball" ; } UNREACHABLE ( ) ; }
const CuePoint * Cues :: GetLast ( ) const { if ( m_cue_points == NULL ) return NULL ; if ( m_count <= 0 ) return NULL ; #if 0 LoadCuePoint ( ) ; const size_t count = m_count + m_preload_count ; if ( count == 0 ) return NULL ; const size_t index = count - 1 ; CuePoint * const * const pp = m_cue_points ; assert ( pp ) ; CuePoint * const pCP = pp [ index ] ; assert ( pCP ) ; pCP -> Load ( m_pSegment -> m_pReader ) ; assert ( pCP -> GetTimeCode ( ) >= 0 ) ; #else const long index = m_count - 1 ; CuePoint * const * const pp = m_cue_points ; assert ( pp ) ; CuePoint * const pCP = pp [ index ] ; assert ( pCP ) ; assert ( pCP -> GetTimeCode ( ) >= 0 ) ; #endif return pCP ; }
QuotaManager :: EnsureOriginIsInitialized ( const nsACString & aOrigin , bool aTrackQuota , nsIFile * * aDirectory ) { #ifdef DEBUG { bool correctThread ; NS_ASSERTION ( NS_SUCCEEDED ( mIOThread -> IsOnCurrentThread ( & correctThread ) ) && correctThread , "Running on the wrong thread!" ) ; } #endif nsCOMPtr < nsIFile > directory ; nsresult rv = GetDirectoryForOrigin ( aOrigin , getter_AddRefs ( directory ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; bool exists ; rv = directory -> Exists ( & exists ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( exists ) { bool isDirectory ; rv = directory -> IsDirectory ( & isDirectory ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; NS_ENSURE_TRUE ( isDirectory , NS_ERROR_UNEXPECTED ) ; } else { rv = directory -> Create ( nsIFile :: DIRECTORY_TYPE , 0755 ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIFile > metadataFile ; rv = directory -> Clone ( getter_AddRefs ( metadataFile ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = metadataFile -> Append ( NS_LITERAL_STRING ( METADATA_FILE_NAME ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = metadataFile -> Create ( nsIFile :: NORMAL_FILE_TYPE , 0644 ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } if ( mInitializedOrigins . Contains ( aOrigin ) ) { NS_ADDREF ( * aDirectory = directory ) ; return NS_OK ; } rv = MaybeUpgradeOriginDirectory ( directory ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsAutoPtr < UsageRunnable > runnable ; if ( aTrackQuota ) { runnable = new UsageRunnable ( ) ; } nsCOMPtr < nsISimpleEnumerator > entries ; rv = directory -> GetDirectoryEntries ( getter_AddRefs ( entries ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; bool hasMore ; while ( NS_SUCCEEDED ( ( rv = entries -> HasMoreElements ( & hasMore ) ) ) && hasMore ) { nsCOMPtr < nsISupports > entry ; rv = entries -> GetNext ( getter_AddRefs ( entry ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIFile > file = do_QueryInterface ( entry ) ; NS_ENSURE_TRUE ( file , NS_NOINTERFACE ) ; nsString leafName ; rv = file -> GetLeafName ( leafName ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( leafName . EqualsLiteral ( METADATA_FILE_NAME ) ) { continue ; } bool isDirectory ; rv = file -> IsDirectory ( & isDirectory ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! isDirectory ) { NS_WARNING ( "Unknown file found!" ) ; return NS_ERROR_UNEXPECTED ; } Client :: Type clientType ; rv = Client :: TypeFromText ( leafName , clientType ) ; if ( NS_FAILED ( rv ) ) { NS_WARNING ( "Unknown directory found!" ) ; return NS_ERROR_UNEXPECTED ; } rv = mClients [ clientType ] -> InitOrigin ( aOrigin , runnable ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } if ( aTrackQuota ) { uint64_t quotaMaxBytes = GetStorageQuotaMB ( ) * 1024 * 1024 ; uint64_t totalUsageBytes = runnable -> TotalUsage ( ) ; if ( totalUsageBytes > quotaMaxBytes ) { NS_WARNING ( "Origin is already using more storage than allowed by quota!" ) ; return NS_ERROR_UNEXPECTED ; } int64_t limit = quotaMaxBytes >= uint64_t ( INT64_MAX ) ? INT64_MAX : int64_t ( quotaMaxBytes ) ; int64_t usage = totalUsageBytes >= uint64_t ( INT64_MAX ) ? INT64_MAX : int64_t ( totalUsageBytes ) ; InitQuotaForOrigin ( aOrigin , limit , usage ) ; } mInitializedOrigins . AppendElement ( aOrigin ) ; NS_ADDREF ( * aDirectory = directory ) ; return NS_OK ; }
const Operator * CommonOperatorBuilder :: TailCall ( const CallDescriptor * call_descriptor ) { class TailCallOperator final : public Operator1 < const CallDescriptor * > { public : explicit TailCallOperator ( const CallDescriptor * call_descriptor ) : Operator1 < const CallDescriptor * > ( IrOpcode :: kTailCall , call_descriptor -> properties ( ) | Operator :: kNoThrow , "TailCall" , call_descriptor -> InputCount ( ) + call_descriptor -> FrameStateCount ( ) , 1 , 1 , 0 , 0 , 1 , call_descriptor ) { } void PrintParameter ( std :: ostream & os , PrintVerbosity verbose ) const { os < < "[" < < * parameter ( ) < < "]" ; } } ; return new ( zone ( ) ) TailCallOperator ( call_descriptor ) ; }
IonBuilder :: InliningResult IonBuilder :: inlineArraySlice ( CallInfo & callInfo ) { if ( callInfo . constructing ( ) ) { trackOptimizationOutcome ( TrackedOutcome :: CantInlineNativeBadForm ) ; return InliningStatus_NotInlined ; } MDefinition * obj = callInfo . thisArg ( ) ; if ( getInlineReturnType ( ) != MIRType :: Object ) { return InliningStatus_NotInlined ; } if ( obj -> type ( ) != MIRType :: Object ) { return InliningStatus_NotInlined ; } if ( callInfo . argc ( ) > 0 ) { if ( callInfo . getArg ( 0 ) -> type ( ) != MIRType :: Int32 ) { return InliningStatus_NotInlined ; } if ( callInfo . argc ( ) > 1 ) { if ( callInfo . getArg ( 1 ) -> type ( ) != MIRType :: Int32 ) { return InliningStatus_NotInlined ; } } } TemporaryTypeSet * thisTypes = obj -> resultTypeSet ( ) ; if ( ! thisTypes ) { return InliningStatus_NotInlined ; } const Class * clasp = thisTypes -> getKnownClass ( constraints ( ) ) ; if ( clasp != & ArrayObject :: class_ ) { return InliningStatus_NotInlined ; } if ( thisTypes -> hasObjectFlags ( constraints ( ) , OBJECT_FLAG_SPARSE_INDEXES | OBJECT_FLAG_LENGTH_OVERFLOW ) ) { trackOptimizationOutcome ( TrackedOutcome :: ArrayBadFlags ) ; return InliningStatus_NotInlined ; } bool hasIndexedProperty ; MOZ_TRY_VAR ( hasIndexedProperty , ArrayPrototypeHasIndexedProperty ( this , script ( ) ) ) ; if ( hasIndexedProperty ) { trackOptimizationOutcome ( TrackedOutcome :: ProtoIndexedProps ) ; return InliningStatus_NotInlined ; } for ( unsigned i = 0 ; i < thisTypes -> getObjectCount ( ) ; i ++ ) { TypeSet :: ObjectKey * key = thisTypes -> getObject ( i ) ; if ( key && key -> isSingleton ( ) ) { return InliningStatus_NotInlined ; } } JSObject * templateObj = inspector -> getTemplateObjectForNative ( pc , js :: array_slice ) ; if ( ! templateObj ) { return InliningStatus_NotInlined ; } if ( ! templateObj -> is < ArrayObject > ( ) ) { return InliningStatus_NotInlined ; } callInfo . setImplicitlyUsedUnchecked ( ) ; MDefinition * begin ; if ( callInfo . argc ( ) > 0 ) { begin = callInfo . getArg ( 0 ) ; } else { begin = constant ( Int32Value ( 0 ) ) ; } MDefinition * end ; if ( callInfo . argc ( ) > 1 ) { end = callInfo . getArg ( 1 ) ; } else if ( clasp == & ArrayObject :: class_ ) { MElements * elements = MElements :: New ( alloc ( ) , obj ) ; current -> add ( elements ) ; end = MArrayLength :: New ( alloc ( ) , elements ) ; current -> add ( end -> toInstruction ( ) ) ; } MArraySlice * ins = MArraySlice :: New ( alloc ( ) , obj , begin , end , templateObj , templateObj -> group ( ) -> initialHeap ( constraints ( ) ) ) ; current -> add ( ins ) ; current -> push ( ins ) ; MOZ_TRY ( resumeAfter ( ins ) ) ; MOZ_TRY ( pushTypeBarrier ( ins , getInlineReturnTypeSet ( ) , BarrierKind :: TypeSet ) ) ; return InliningStatus_Inlined ; }
nsCxPusher :: Push ( nsIDOMEventTarget * aCurrentTarget ) { if ( mPushedSomething ) { NS_ERROR ( "Whaaa! No double pushing with nsCxPusher::Push()!" ) ; return false ; } NS_ENSURE_TRUE ( aCurrentTarget , false ) ; nsresult rv ; nsIScriptContext * scx = aCurrentTarget -> GetContextForEventHandlers ( & rv ) ; NS_ENSURE_SUCCESS ( rv , false ) ; if ( ! scx ) { JSContext * cx = aCurrentTarget -> GetJSContextForEventHandlers ( ) ; if ( cx ) { DoPush ( cx ) ; } return true ; } JSContext * cx = scx ? scx -> GetNativeContext ( ) : nullptr ; return Push ( cx ) ; }
static OPJ_BOOL opj_dwt_decode_tile ( const opj_tcd_tilecomp_t * tilec , OPJ_UINT32 numres , DWT1DFN dwt_1D ) { opj_dwt_t h ; opj_dwt_t v ; opj_tcd_resolution_t * tr = tilec -> resolutions ; OPJ_UINT32 rw = ( OPJ_UINT32 ) ( tr -> x1 - tr -> x0 ) ; OPJ_UINT32 rh = ( OPJ_UINT32 ) ( tr -> y1 - tr -> y0 ) ; OPJ_UINT32 w = ( OPJ_UINT32 ) ( tilec -> x1 - tilec -> x0 ) ; h . mem_count = opj_dwt_max_resolution ( tr , numres ) ; if ( ( ( OPJ_UINT32 ) - 1 ) / ( OPJ_UINT32 ) sizeof ( OPJ_INT32 ) < ( OPJ_UINT32 ) h . mem_count ) { return OPJ_FALSE ; } h . mem = ( OPJ_INT32 * ) opj_aligned_malloc ( h . mem_count * sizeof ( OPJ_INT32 ) ) ; if ( ! h . mem ) { return OPJ_FALSE ; } v . mem_count = h . mem_count ; v . mem = h . mem ; while ( -- numres ) { OPJ_INT32 * restrict tiledp = tilec -> data ; OPJ_UINT32 j ; ++ tr ; h . sn = ( OPJ_INT32 ) rw ; v . sn = ( OPJ_INT32 ) rh ; rw = ( OPJ_UINT32 ) ( tr -> x1 - tr -> x0 ) ; rh = ( OPJ_UINT32 ) ( tr -> y1 - tr -> y0 ) ; h . dn = ( OPJ_INT32 ) ( rw - ( OPJ_UINT32 ) h . sn ) ; h . cas = tr -> x0 % 2 ; for ( j = 0 ; j < rh ; ++ j ) { opj_dwt_interleave_h ( & h , & tiledp [ j * w ] ) ; ( dwt_1D ) ( & h ) ; memcpy ( & tiledp [ j * w ] , h . mem , rw * sizeof ( OPJ_INT32 ) ) ; } v . dn = ( OPJ_INT32 ) ( rh - ( OPJ_UINT32 ) v . sn ) ; v . cas = tr -> y0 % 2 ; for ( j = 0 ; j < rw ; ++ j ) { OPJ_UINT32 k ; opj_dwt_interleave_v ( & v , & tiledp [ j ] , ( OPJ_INT32 ) w ) ; ( dwt_1D ) ( & v ) ; for ( k = 0 ; k < rh ; ++ k ) { tiledp [ k * w + j ] = v . mem [ k ] ; } } } opj_aligned_free ( h . mem ) ; return OPJ_TRUE ; }
WORD32 ih264d_parse_nal_unit ( iv_obj_t * dec_hdl , ivd_video_decode_op_t * ps_dec_op , UWORD8 * pu1_buf , UWORD32 u4_length ) { dec_bit_stream_t * ps_bitstrm ; dec_struct_t * ps_dec = ( dec_struct_t * ) dec_hdl -> pv_codec_handle ; ivd_video_decode_ip_t * ps_dec_in = ( ivd_video_decode_ip_t * ) ps_dec -> pv_dec_in ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; UWORD8 u1_first_byte , u1_nal_ref_idc ; UWORD8 u1_nal_unit_type ; WORD32 i_status = OK ; ps_bitstrm = ps_dec -> ps_bitstrm ; if ( pu1_buf ) { if ( u4_length ) { ps_dec_op -> u4_frame_decoded_flag = 0 ; ih264d_process_nal_unit ( ps_dec -> ps_bitstrm , pu1_buf , u4_length ) ; SWITCHOFFTRACE ; u1_first_byte = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; if ( NAL_FORBIDDEN_BIT ( u1_first_byte ) ) { H264_DEC_DEBUG_PRINT ( "\nForbidden bit set in Nal Unit, Let's try\n" ) ; } u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ps_dec -> u1_pic_decode_done != 1 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; } ps_dec -> u1_nal_unit_type = u1_nal_unit_type ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_first_byte ) ) ; switch ( u1_nal_unit_type ) { case SLICE_DATA_PARTITION_A_NAL : case SLICE_DATA_PARTITION_B_NAL : case SLICE_DATA_PARTITION_C_NAL : if ( ! ps_dec -> i4_decode_header ) ih264d_parse_slice_partition ( ps_dec , ps_bitstrm ) ; break ; case IDR_SLICE_NAL : case SLICE_NAL : DEBUG_THREADS_PRINTF ( "Decoding  a slice NAL\n" ) ; if ( ! ps_dec -> i4_decode_header ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u4_slice_start_code_found = 1 ; ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_decode_slice ( ( UWORD8 ) ( u1_nal_unit_type == IDR_SLICE_NAL ) , u1_nal_ref_idc , ps_dec ) ; if ( i_status != OK ) { return i_status ; } } else { H264_DEC_DEBUG_PRINT ( "\nSlice NAL Supplied but no header has been supplied\n" ) ; } } break ; case SEI_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sei_message ( ps_dec , ps_bitstrm ) ; if ( i_status != OK ) return i_status ; ih264d_parse_sei ( ps_dec , ps_bitstrm ) ; } break ; case SEQ_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x1 ; break ; case PIC_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_pps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x2 ; break ; case ACCESS_UNIT_DELIMITER_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_access_unit_delimiter_rbsp ( ps_dec ) ; } break ; case END_OF_STREAM_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_end_of_stream ( ps_dec ) ; } break ; case FILLER_DATA_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_filler_data ( ps_dec , ps_bitstrm ) ; } break ; default : H264_DEC_DEBUG_PRINT ( "\nUnknown NAL type %d\n" , u1_nal_unit_type ) ; break ; } } } return i_status ; }
static int unmap_ref_private ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * page , unsigned long address ) { struct hstate * h = hstate_vma ( vma ) ; struct vm_area_struct * iter_vma ; struct address_space * mapping ; struct prio_tree_iter iter ; pgoff_t pgoff ; address = address & huge_page_mask ( h ) ; pgoff = vma_hugecache_offset ( h , vma , address ) ; mapping = ( struct address_space * ) page_private ( page ) ; mutex_lock ( & mapping -> i_mmap_mutex ) ; vma_prio_tree_foreach ( iter_vma , & iter , & mapping -> i_mmap , pgoff , pgoff ) { if ( iter_vma == vma ) continue ; if ( ! is_vma_resv_set ( iter_vma , HPAGE_RESV_OWNER ) ) __unmap_hugepage_range ( iter_vma , address , address + huge_page_size ( h ) , page ) ; } mutex_unlock ( & mapping -> i_mmap_mutex ) ; return 1 ; }
uint32_t StringTableInsertionKey :: ComputeHashField ( String * string ) { string -> Hash ( ) ; return string -> hash_field ( ) ; }
OMX_ERRORTYPE omx_video :: allocate_output_buffer ( OMX_IN OMX_HANDLETYPE hComp , OMX_INOUT OMX_BUFFERHEADERTYPE * * bufferHdr , OMX_IN OMX_U32 port , OMX_IN OMX_PTR appData , OMX_IN OMX_U32 bytes ) { ( void ) hComp , ( void ) port ; OMX_ERRORTYPE eRet = OMX_ErrorNone ; OMX_BUFFERHEADERTYPE * bufHdr = NULL ; unsigned i = 0 ; #ifdef _MSM8974_ int align_size ; #endif DEBUG_PRINT_HIGH ( "allocate_output_buffer()for %u bytes" , ( unsigned int ) bytes ) ; if ( ! m_out_mem_ptr ) { int nBufHdrSize = 0 ; DEBUG_PRINT_HIGH ( "%s: size = %u, actual cnt %u" , __FUNCTION__ , ( unsigned int ) m_sOutPortDef . nBufferSize , ( unsigned int ) m_sOutPortDef . nBufferCountActual ) ; nBufHdrSize = m_sOutPortDef . nBufferCountActual * sizeof ( OMX_BUFFERHEADERTYPE ) ; m_out_mem_ptr = ( OMX_BUFFERHEADERTYPE * ) calloc ( nBufHdrSize , 1 ) ; #ifdef USE_ION m_pOutput_ion = ( struct venc_ion * ) calloc ( sizeof ( struct venc_ion ) , m_sOutPortDef . nBufferCountActual ) ; if ( m_pOutput_ion == NULL ) { DEBUG_PRINT_ERROR ( "ERROR: calloc() Failed for m_pOutput_ion" ) ; return OMX_ErrorInsufficientResources ; } #endif m_pOutput_pmem = ( struct pmem * ) calloc ( sizeof ( struct pmem ) , m_sOutPortDef . nBufferCountActual ) ; if ( m_pOutput_pmem == NULL ) { DEBUG_PRINT_ERROR ( "ERROR: calloc() Failed for m_pOutput_pmem" ) ; return OMX_ErrorInsufficientResources ; } if ( m_out_mem_ptr && m_pOutput_pmem ) { bufHdr = m_out_mem_ptr ; for ( i = 0 ; i < m_sOutPortDef . nBufferCountActual ; i ++ ) { bufHdr -> nSize = sizeof ( OMX_BUFFERHEADERTYPE ) ; bufHdr -> nVersion . nVersion = OMX_SPEC_VERSION ; bufHdr -> nAllocLen = bytes ; bufHdr -> nFilledLen = 0 ; bufHdr -> pAppPrivate = appData ; bufHdr -> nOutputPortIndex = PORT_INDEX_OUT ; bufHdr -> pOutputPortPrivate = ( OMX_PTR ) & m_pOutput_pmem [ i ] ; bufHdr -> pBuffer = NULL ; bufHdr ++ ; m_pOutput_pmem [ i ] . fd = - 1 ; #ifdef USE_ION m_pOutput_ion [ i ] . ion_device_fd = - 1 ; m_pOutput_ion [ i ] . fd_ion_data . fd = - 1 ; m_pOutput_ion [ i ] . ion_alloc_data . handle = 0 ; #endif } } else { DEBUG_PRINT_ERROR ( "ERROR: calloc() failed for m_out_mem_ptr/m_pOutput_pmem" ) ; eRet = OMX_ErrorInsufficientResources ; } } DEBUG_PRINT_HIGH ( "actual cnt = %u" , ( unsigned int ) m_sOutPortDef . nBufferCountActual ) ; for ( i = 0 ; i < m_sOutPortDef . nBufferCountActual ; i ++ ) { if ( BITMASK_ABSENT ( & m_out_bm_count , i ) ) { DEBUG_PRINT_LOW ( "Found a Free Output Buffer %d" , i ) ; break ; } } if ( eRet == OMX_ErrorNone ) { if ( i < m_sOutPortDef . nBufferCountActual ) { #ifdef USE_ION #ifdef _MSM8974_ align_size = ( ( m_sOutPortDef . nBufferSize + 4095 ) / 4096 ) * 4096 ; m_pOutput_ion [ i ] . ion_device_fd = alloc_map_ion_memory ( align_size , & m_pOutput_ion [ i ] . ion_alloc_data , & m_pOutput_ion [ i ] . fd_ion_data , ION_FLAG_CACHED ) ; #else m_pOutput_ion [ i ] . ion_device_fd = alloc_map_ion_memory ( m_sOutPortDef . nBufferSize , & m_pOutput_ion [ i ] . ion_alloc_data , & m_pOutput_ion [ i ] . fd_ion_data , ION_FLAG_CACHED ) ; #endif if ( m_pOutput_ion [ i ] . ion_device_fd < 0 ) { DEBUG_PRINT_ERROR ( "ERROR:ION device open() Failed" ) ; return OMX_ErrorInsufficientResources ; } m_pOutput_pmem [ i ] . fd = m_pOutput_ion [ i ] . fd_ion_data . fd ; #else m_pOutput_pmem [ i ] . fd = open ( MEM_DEVICE , O_RDWR ) ; if ( m_pOutput_pmem [ i ] . fd == 0 ) { m_pOutput_pmem [ i ] . fd = open ( MEM_DEVICE , O_RDWR ) ; } if ( m_pOutput_pmem [ i ] . fd < 0 ) { DEBUG_PRINT_ERROR ( "ERROR: /dev/pmem_adsp open() failed" ) ; return OMX_ErrorInsufficientResources ; } #endif m_pOutput_pmem [ i ] . size = m_sOutPortDef . nBufferSize ; m_pOutput_pmem [ i ] . offset = 0 ; m_pOutput_pmem [ i ] . buffer = ( OMX_U8 * ) SECURE_BUFPTR ; if ( ! secure_session ) { #ifdef _MSM8974_ m_pOutput_pmem [ i ] . buffer = ( unsigned char * ) mmap ( NULL , align_size , PROT_READ | PROT_WRITE , MAP_SHARED , m_pOutput_pmem [ i ] . fd , 0 ) ; #else m_pOutput_pmem [ i ] . buffer = ( unsigned char * ) mmap ( NULL , m_pOutput_pmem [ i ] . size , PROT_READ | PROT_WRITE , MAP_SHARED , m_pOutput_pmem [ i ] . fd , 0 ) ; #endif if ( m_pOutput_pmem [ i ] . buffer == MAP_FAILED ) { DEBUG_PRINT_ERROR ( "ERROR: MMAP_FAILED in o/p alloc buffer" ) ; close ( m_pOutput_pmem [ i ] . fd ) ; #ifdef USE_ION free_ion_memory ( & m_pOutput_ion [ i ] ) ; #endif return OMX_ErrorInsufficientResources ; } } else { m_pOutput_pmem [ i ] . buffer = malloc ( sizeof ( OMX_U32 ) + sizeof ( native_handle_t * ) ) ; ( * bufferHdr ) -> nAllocLen = sizeof ( OMX_U32 ) + sizeof ( native_handle_t * ) ; native_handle_t * handle = native_handle_create ( 1 , 0 ) ; handle -> data [ 0 ] = m_pOutput_pmem [ i ] . fd ; char * data = ( char * ) m_pOutput_pmem [ i ] . buffer ; OMX_U32 type = 1 ; memcpy ( data , & type , sizeof ( OMX_U32 ) ) ; memcpy ( data + sizeof ( OMX_U32 ) , & handle , sizeof ( native_handle_t * ) ) ; } * bufferHdr = ( m_out_mem_ptr + i ) ; ( * bufferHdr ) -> pBuffer = ( OMX_U8 * ) m_pOutput_pmem [ i ] . buffer ; ( * bufferHdr ) -> pAppPrivate = appData ; BITMASK_SET ( & m_out_bm_count , i ) ; if ( dev_use_buf ( & m_pOutput_pmem [ i ] , PORT_INDEX_OUT , i ) != true ) { DEBUG_PRINT_ERROR ( "ERROR: dev_use_buf FAILED for o/p buf" ) ; return OMX_ErrorInsufficientResources ; } } else { DEBUG_PRINT_ERROR ( "ERROR: All o/p buffers are allocated, invalid allocate buf call" "for index [%d] actual: %u" , i , ( unsigned int ) m_sOutPortDef . nBufferCountActual ) ; } } return eRet ; }
ModuleDecoderImpl ( const WasmFeatures & enabled , const byte * module_start , const byte * module_end , ModuleOrigin origin ) : Decoder ( module_start , module_end ) , enabled_features_ ( enabled ) , origin_ ( FLAG_assume_asmjs_origin ? kAsmJsOrigin : origin ) { if ( end_ < start_ ) { error ( start_ , "end is less than start" ) ; end_ = start_ ; } }
JNIEXPORT void JNICALL TJCompressor_encodeYUV_12 ( JNIEnv * env , jobject obj , jarray src , jint srcElementSize , jint width , jint pitch , jint height , jint pf , jbyteArray dst , jint subsamp , jint flags ) { tjhandle handle = 0 ; jsize arraySize = 0 ; unsigned char * srcBuf = NULL , * dstBuf = NULL ; gethandle ( ) ; if ( pf < 0 || pf >= org_libjpegturbo_turbojpeg_TJ_NUMPF || width < 1 || height < 1 || pitch < 0 ) _throwarg ( "Invalid argument in encodeYUV()" ) ; if ( org_libjpegturbo_turbojpeg_TJ_NUMPF != TJ_NUMPF ) _throwarg ( "Mismatch between Java and C API" ) ; arraySize = ( pitch == 0 ) ? width * tjPixelSize [ pf ] * height : pitch * height ; if ( ( * env ) -> GetArrayLength ( env , src ) * srcElementSize < arraySize ) _throwarg ( "Source buffer is not large enough" ) ; if ( ( * env ) -> GetArrayLength ( env , dst ) < ( jsize ) tjBufSizeYUV ( width , height , subsamp ) ) _throwarg ( "Destination buffer is not large enough" ) ; bailif0 ( srcBuf = ( * env ) -> GetPrimitiveArrayCritical ( env , src , 0 ) ) ; bailif0 ( dstBuf = ( * env ) -> GetPrimitiveArrayCritical ( env , dst , 0 ) ) ; if ( tjEncodeYUV2 ( handle , srcBuf , width , pitch , height , pf , dstBuf , subsamp , flags ) == - 1 ) _throwtj ( ) ; bailout : if ( dstBuf ) ( * env ) -> ReleasePrimitiveArrayCritical ( env , dst , dstBuf , 0 ) ; if ( srcBuf ) ( * env ) -> ReleasePrimitiveArrayCritical ( env , src , srcBuf , 0 ) ; }
R_API bool r_io_bank_map_add_top ( RIO * io , const ut32 bankid , const ut32 mapid ) { RIOBank * bank = r_io_bank_get ( io , bankid ) ; RIOMap * map = r_io_map_get ( io , mapid ) ; r_return_val_if_fail ( io && bank && map , false ) ; RIOMapRef * mapref = _mapref_from_map ( map ) ; if ( ! mapref ) { return false ; } RIOSubMap * sm = r_io_submap_new ( io , mapref ) ; if ( ! sm ) { free ( mapref ) ; return false ; } RRBNode * entry = _find_entry_submap_node ( bank , sm ) ; if ( ! entry ) { if ( ! r_crbtree_insert ( bank -> submaps , sm , _find_sm_by_from_vaddr_cb , NULL ) ) { free ( sm ) ; free ( mapref ) ; return false ; } r_list_append ( bank -> maprefs , mapref ) ; return true ; } bank -> last_used = NULL ; RIOSubMap * bd = ( RIOSubMap * ) entry -> data ; if ( r_io_submap_to ( bd ) == r_io_submap_to ( sm ) && r_io_submap_from ( bd ) >= r_io_submap_from ( sm ) ) { memcpy ( bd , sm , sizeof ( RIOSubMap ) ) ; free ( sm ) ; r_list_append ( bank -> maprefs , mapref ) ; return true ; } if ( r_io_submap_from ( bd ) < r_io_submap_from ( sm ) && r_io_submap_to ( sm ) < r_io_submap_to ( bd ) ) { RIOSubMap * bdsm = R_NEWCOPY ( RIOSubMap , bd ) ; if ( ! bdsm ) { free ( sm ) ; free ( mapref ) ; return false ; } r_io_submap_set_from ( bdsm , r_io_submap_to ( sm ) + 1 ) ; r_io_submap_set_to ( bd , r_io_submap_from ( sm ) - 1 ) ; if ( ! r_crbtree_insert ( bank -> submaps , sm , _find_sm_by_from_vaddr_cb , NULL ) ) { free ( sm ) ; free ( bdsm ) ; free ( mapref ) ; return false ; } if ( ! r_crbtree_insert ( bank -> submaps , bdsm , _find_sm_by_from_vaddr_cb , NULL ) ) { r_crbtree_delete ( bank -> submaps , sm , _find_sm_by_from_vaddr_cb , NULL ) ; free ( sm ) ; free ( bdsm ) ; free ( mapref ) ; return false ; } r_list_append ( bank -> maprefs , mapref ) ; return true ; } if ( r_io_submap_from ( bd ) < r_io_submap_from ( sm ) ) { r_io_submap_set_to ( bd , r_io_submap_from ( sm ) - 1 ) ; entry = r_rbnode_next ( entry ) ; } while ( entry && r_io_submap_to ( ( ( RIOSubMap * ) entry -> data ) ) <= r_io_submap_to ( sm ) ) { RRBNode * next = r_rbnode_next ( entry ) ; r_crbtree_delete ( bank -> submaps , entry -> data , _find_sm_by_from_vaddr_cb , NULL ) ; entry = next ; } if ( entry && r_io_submap_from ( ( ( RIOSubMap * ) entry -> data ) ) <= r_io_submap_to ( sm ) ) { bd = ( RIOSubMap * ) entry -> data ; r_io_submap_set_from ( bd , r_io_submap_to ( sm ) + 1 ) ; } if ( ! r_crbtree_insert ( bank -> submaps , sm , _find_sm_by_from_vaddr_cb , NULL ) ) { free ( sm ) ; free ( mapref ) ; return false ; } r_list_append ( bank -> maprefs , mapref ) ; return true ; }
png_read_push_finish_row ( png_structrp png_ptr ) { #ifdef PNG_READ_INTERLACING_SUPPORTED static PNG_CONST png_byte png_pass_start [ ] = { 0 , 4 , 0 , 2 , 0 , 1 , 0 } ; static PNG_CONST png_byte png_pass_inc [ ] = { 8 , 8 , 4 , 4 , 2 , 2 , 1 } ; static PNG_CONST png_byte png_pass_ystart [ ] = { 0 , 0 , 4 , 0 , 2 , 0 , 1 } ; static PNG_CONST png_byte png_pass_yinc [ ] = { 8 , 8 , 8 , 4 , 4 , 2 , 2 } ; #endif png_ptr -> row_number ++ ; if ( png_ptr -> row_number < png_ptr -> num_rows ) return ; #ifdef PNG_READ_INTERLACING_SUPPORTED if ( png_ptr -> interlaced ) { png_ptr -> row_number = 0 ; memset ( png_ptr -> prev_row , 0 , png_ptr -> rowbytes + 1 ) ; do { png_ptr -> pass ++ ; if ( ( png_ptr -> pass == 1 && png_ptr -> width < 5 ) || ( png_ptr -> pass == 3 && png_ptr -> width < 3 ) || ( png_ptr -> pass == 5 && png_ptr -> width < 2 ) ) png_ptr -> pass ++ ; if ( png_ptr -> pass > 7 ) png_ptr -> pass -- ; if ( png_ptr -> pass >= 7 ) break ; png_ptr -> iwidth = ( png_ptr -> width + png_pass_inc [ png_ptr -> pass ] - 1 - png_pass_start [ png_ptr -> pass ] ) / png_pass_inc [ png_ptr -> pass ] ; if ( png_ptr -> transformations & PNG_INTERLACE ) break ; png_ptr -> num_rows = ( png_ptr -> height + png_pass_yinc [ png_ptr -> pass ] - 1 - png_pass_ystart [ png_ptr -> pass ] ) / png_pass_yinc [ png_ptr -> pass ] ; } while ( png_ptr -> iwidth == 0 || png_ptr -> num_rows == 0 ) ; } #endif /* PNG_READ_INTERLACING_SUPPORTED */ }
int vp8dx_receive_compressed_data ( VP8D_COMP * pbi , size_t size , const uint8_t * source , int64_t time_stamp ) { #if HAVE_NEON int64_t dx_store_reg [ 8 ] ; #endif VP8_COMMON * cm = & pbi -> common ; int retcode = - 1 ; pbi -> common . error . error_code = VPX_CODEC_OK ; retcode = check_fragments_for_errors ( pbi ) ; if ( retcode <= 0 ) return retcode ; #if HAVE_NEON #if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) #endif { vp8_push_neon ( dx_store_reg ) ; } #endif cm -> new_fb_idx = get_free_fb ( cm ) ; pbi -> dec_fb_ref [ INTRA_FRAME ] = & cm -> yv12_fb [ cm -> new_fb_idx ] ; pbi -> dec_fb_ref [ LAST_FRAME ] = & cm -> yv12_fb [ cm -> lst_fb_idx ] ; pbi -> dec_fb_ref [ GOLDEN_FRAME ] = & cm -> yv12_fb [ cm -> gld_fb_idx ] ; pbi -> dec_fb_ref [ ALTREF_FRAME ] = & cm -> yv12_fb [ cm -> alt_fb_idx ] ; if ( setjmp ( pbi -> common . error . jmp ) ) { cm -> yv12_fb [ cm -> lst_fb_idx ] . corrupted = 1 ; if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; goto decode_exit ; } pbi -> common . error . setjmp = 1 ; retcode = vp8_decode_frame ( pbi ) ; if ( retcode < 0 ) { if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; pbi -> common . error . error_code = VPX_CODEC_ERROR ; goto decode_exit ; } if ( swap_frame_buffers ( cm ) ) { pbi -> common . error . error_code = VPX_CODEC_ERROR ; goto decode_exit ; } vp8_clear_system_state ( ) ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; cm -> show_frame_mi = cm -> mi ; } #if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_enabled && pbi -> common . prev_mi ) { MODE_INFO * tmp = pbi -> common . prev_mi ; int row , col ; pbi -> common . prev_mi = pbi -> common . mi ; pbi -> common . mi = tmp ; for ( row = 0 ; row < pbi -> common . mb_rows ; ++ row ) { for ( col = 0 ; col < pbi -> common . mb_cols ; ++ col ) { const int i = row * pbi -> common . mode_info_stride + col ; pbi -> common . mi [ i ] . mbmi . segment_id = pbi -> common . prev_mi [ i ] . mbmi . segment_id ; } } } #endif pbi -> ready_for_new_data = 0 ; pbi -> last_time_stamp = time_stamp ; decode_exit : #if HAVE_NEON #if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) #endif { vp8_pop_neon ( dx_store_reg ) ; } #endif pbi -> common . error . setjmp = 0 ; return retcode ; }
static inline void process_get_command ( conn * c , token_t * tokens , size_t ntokens , bool return_cas ) { char * key ; size_t nkey ; int i = 0 ; item * it ; token_t * key_token = & tokens [ KEY_TOKEN ] ; char * suffix ; assert ( c != NULL ) ; do { while ( key_token -> length != 0 ) { key = key_token -> value ; nkey = key_token -> length ; if ( nkey > KEY_MAX_LENGTH ) { out_string ( c , "CLIENT_ERROR bad command line format" ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } it = item_get ( key , nkey , c , DO_UPDATE ) ; if ( settings . detail_enabled ) { stats_prefix_record_get ( key , nkey , NULL != it ) ; } if ( it ) { if ( i >= c -> isize ) { item * * new_list = realloc ( c -> ilist , sizeof ( item * ) * c -> isize * 2 ) ; if ( new_list ) { c -> isize *= 2 ; c -> ilist = new_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } if ( return_cas || ! settings . inline_ascii_response ) { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( i >= c -> suffixsize ) { char * * new_suffix_list = realloc ( c -> suffixlist , sizeof ( char * ) * c -> suffixsize * 2 ) ; if ( new_suffix_list ) { c -> suffixsize *= 2 ; c -> suffixlist = new_suffix_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } suffix = do_cache_alloc ( c -> thread -> suffix_cache ) ; if ( suffix == NULL ) { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; out_of_memory ( c , "SERVER_ERROR out of memory making CAS suffix" ) ; item_remove ( it ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } * ( c -> suffixlist + i ) = suffix ; int suffix_len = make_ascii_get_suffix ( suffix , it , return_cas ) ; if ( add_iov ( c , "VALUE " , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 || ( settings . inline_ascii_response && add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix - 2 ) != 0 ) || add_iov ( c , suffix , suffix_len ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { add_iov ( c , ITEM_data ( it ) , it -> nbytes ) ; } else if ( add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( add_iov ( c , "VALUE " , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix + it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix ) != 0 || add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ">%d sending key " , c -> sfd ) ; for ( ii = 0 ; ii < it -> nkey ; ++ ii ) { fprintf ( stderr , "%c" , key [ ii ] ) ; } fprintf ( stderr , "\n" ) ; } pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . slab_stats [ ITEM_clsid ( it ) ] . get_hits ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; * ( c -> ilist + i ) = it ; i ++ ; } else { pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . get_misses ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; MEMCACHED_COMMAND_GET ( c -> sfd , key , nkey , - 1 , 0 ) ; } key_token ++ ; } if ( key_token -> value != NULL ) { ntokens = tokenize_command ( key_token -> value , tokens , MAX_TOKENS ) ; key_token = tokens ; } } while ( key_token -> value != NULL ) ; c -> icurr = c -> ilist ; c -> ileft = i ; if ( return_cas || ! settings . inline_ascii_response ) { c -> suffixcurr = c -> suffixlist ; c -> suffixleft = i ; } if ( settings . verbose > 1 ) fprintf ( stderr , ">%d END\n" , c -> sfd ) ; if ( key_token -> value != NULL || add_iov ( c , "END\r\n" , 5 ) != 0 || ( IS_UDP ( c -> transport ) && build_udp_headers ( c ) != 0 ) ) { out_of_memory ( c , "SERVER_ERROR out of memory writing get response" ) ; } else { conn_set_state ( c , conn_mwrite ) ; c -> msgcurr = 0 ; } }
MaybeHandle < JSListFormat > JSListFormat :: InitializeListFormat ( Isolate * isolate , Handle < JSListFormat > list_format_holder , Handle < Object > input_locales , Handle < Object > input_options ) { Factory * factory = isolate -> factory ( ) ; list_format_holder -> set_flags ( 0 ) ; Handle < JSReceiver > options ; if ( input_options -> IsUndefined ( isolate ) ) { options = isolate -> factory ( ) -> NewJSObjectWithNullProto ( ) ; } else { ASSIGN_RETURN_ON_EXCEPTION ( isolate , options , Object :: ToObject ( isolate , input_options ) , JSListFormat ) ; } std :: unique_ptr < char [ ] > type_str = nullptr ; std :: vector < const char * > type_values = { "conjunction" , "disjunction" , "unit" } ; Maybe < bool > maybe_found_type = Intl :: GetStringOption ( isolate , options , "type" , type_values , "Intl.ListFormat" , & type_str ) ; Type type_enum = Type :: CONJUNCTION ; MAYBE_RETURN ( maybe_found_type , MaybeHandle < JSListFormat > ( ) ) ; if ( maybe_found_type . FromJust ( ) ) { DCHECK_NOT_NULL ( type_str . get ( ) ) ; type_enum = get_type ( type_str . get ( ) ) ; } list_format_holder -> set_type ( type_enum ) ; std :: unique_ptr < char [ ] > style_str = nullptr ; std :: vector < const char * > style_values = { "long" , "short" , "narrow" } ; Maybe < bool > maybe_found_style = Intl :: GetStringOption ( isolate , options , "style" , style_values , "Intl.ListFormat" , & style_str ) ; Style style_enum = Style :: LONG ; MAYBE_RETURN ( maybe_found_style , MaybeHandle < JSListFormat > ( ) ) ; if ( maybe_found_style . FromJust ( ) ) { DCHECK_NOT_NULL ( style_str . get ( ) ) ; style_enum = get_style ( style_str . get ( ) ) ; } list_format_holder -> set_style ( style_enum ) ; Handle < JSObject > r ; ASSIGN_RETURN_ON_EXCEPTION ( isolate , r , Intl :: ResolveLocale ( isolate , "listformat" , input_locales , options ) , JSListFormat ) ; Handle < Object > locale_obj = JSObject :: GetDataProperty ( r , factory -> locale_string ( ) ) ; Handle < String > locale ; ASSIGN_RETURN_ON_EXCEPTION ( isolate , locale , Object :: ToString ( isolate , locale_obj ) , JSListFormat ) ; list_format_holder -> set_locale ( * locale ) ; std :: unique_ptr < char [ ] > locale_name = locale -> ToCString ( ) ; icu :: Locale icu_locale ( locale_name . get ( ) ) ; UErrorCode status = U_ZERO_ERROR ; icu :: ListFormatter * formatter = icu :: ListFormatter :: createInstance ( icu_locale , GetIcuStyleString ( style_enum , type_enum ) , status ) ; if ( U_FAILURE ( status ) ) { delete formatter ; FATAL ( "Failed to create ICU list formatter, are ICU data files missing?" ) ; } CHECK_NOT_NULL ( formatter ) ; Handle < Managed < icu :: ListFormatter > > managed_formatter = Managed < icu :: ListFormatter > :: FromRawPtr ( isolate , 0 , formatter ) ; list_format_holder -> set_formatter ( * managed_formatter ) ; return list_format_holder ; }
u32 GetHintFormat ( GF_TrackBox * trak ) { GF_HintMediaHeaderBox * hmhd = ( GF_HintMediaHeaderBox * ) trak -> Media -> information -> InfoHeader ; if ( hmhd -> type != GF_ISOM_BOX_TYPE_HMHD ) return 0 ; if ( ! hmhd || ! hmhd -> subType ) { GF_Box * a = ( GF_Box * ) gf_list_get ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes , 0 ) ; if ( ! hmhd ) return a ? a -> type : 0 ; if ( a ) hmhd -> subType = a -> type ; return hmhd -> subType ; } return hmhd -> subType ; }
rtadv_read ( struct thread * thread ) { int sock ; int len ; u_char buf [ RTADV_MSG_SIZE ] ; struct sockaddr_in6 from ; ifindex_t ifindex = 0 ; int hoplimit = - 1 ; struct zebra_vrf * zvrf = THREAD_ARG ( thread ) ; sock = THREAD_FD ( thread ) ; zvrf -> rtadv . ra_read = NULL ; rtadv_event ( zvrf , RTADV_READ , sock ) ; len = rtadv_recv_packet ( sock , buf , BUFSIZ , & from , & ifindex , & hoplimit ) ; if ( len < 0 ) { zlog_warn ( "router solicitation recv failed: %s." , safe_strerror ( errno ) ) ; return len ; } rtadv_process_packet ( buf , ( unsigned ) len , ifindex , hoplimit , zvrf -> vrf_id ) ; return 0 ; }
nsXMLHttpRequest :: AppendToResponseText ( const char * aSrcBuffer , uint32_t aSrcBufferLen ) { NS_ENSURE_STATE ( mDecoder ) ; int32_t destBufferLen ; nsresult rv = mDecoder -> GetMaxLength ( aSrcBuffer , aSrcBufferLen , & destBufferLen ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! mResponseText . SetCapacity ( mResponseText . Length ( ) + destBufferLen , fallible ) ) { return NS_ERROR_OUT_OF_MEMORY ; } char16_t * destBuffer = mResponseText . BeginWriting ( ) + mResponseText . Length ( ) ; int32_t totalChars = mResponseText . Length ( ) ; int32_t srclen = ( int32_t ) aSrcBufferLen ; int32_t destlen = ( int32_t ) destBufferLen ; rv = mDecoder -> Convert ( aSrcBuffer , & srclen , destBuffer , & destlen ) ; MOZ_ASSERT ( NS_SUCCEEDED ( rv ) ) ; totalChars += destlen ; mResponseText . SetLength ( totalChars ) ; return NS_OK ; }
Node * EffectControlLinearizer :: LowerObjectIsNonCallable ( Node * node ) { Node * value = node -> InputAt ( 0 ) ; auto if_primitive = __ MakeDeferredLabel ( ) ; auto done = __ MakeLabel ( MachineRepresentation :: kBit ) ; Node * check0 = ObjectIsSmi ( value ) ; __ GotoIf ( check0 , & if_primitive ) ; Node * value_map = __ LoadField ( AccessBuilder :: ForMap ( ) , value ) ; Node * value_instance_type = __ LoadField ( AccessBuilder :: ForMapInstanceType ( ) , value_map ) ; STATIC_ASSERT ( LAST_TYPE == LAST_JS_RECEIVER_TYPE ) ; Node * check1 = __ Uint32LessThanOrEqual ( __ Uint32Constant ( FIRST_JS_RECEIVER_TYPE ) , value_instance_type ) ; __ GotoIfNot ( check1 , & if_primitive ) ; Node * value_bit_field = __ LoadField ( AccessBuilder :: ForMapBitField ( ) , value_map ) ; Node * check2 = __ Word32Equal ( __ Int32Constant ( 0 ) , __ Word32And ( value_bit_field , __ Int32Constant ( Map :: IsCallableBit :: kMask ) ) ) ; __ Goto ( & done , check2 ) ; __ Bind ( & if_primitive ) ; __ Goto ( & done , __ Int32Constant ( 0 ) ) ; __ Bind ( & done ) ; return done . PhiAt ( 0 ) ; }
NFCSTATUS phFriNfc_ExtnsTransceive ( phNfc_sTransceiveInfo_t * pTransceiveInfo , phNfc_uCmdList_t Cmd , uint8_t * SendRecvBuf , uint16_t SendLength , uint16_t * SendRecvLength ) { ( void ) SendRecvLength ; NFCSTATUS status = NFCSTATUS_FAILED ; uint8_t * buff = NULL ; uint16_t buffSz = 0 ; uint8_t i = 0 ; uint32_t length = SendLength ; uint8_t restore_payload [ ] = { 0x00 , 0x00 , 0x00 , 0x00 , } ; buff = ( uint8_t * ) malloc ( ( uint32_t ) MAX_BUFF_SIZE ) ; if ( NULL == buff ) { return status ; } pTransceiveInfo -> cmd = Cmd ; if ( ( Cmd . MfCmd == phNfc_eMifareAuthentA ) || ( Cmd . MfCmd == phNfc_eMifareAuthentB ) ) { pTransceiveInfo -> addr = SendRecvBuf [ i ++ ] ; pTransceiveInfo -> sSendData . buffer [ 4 ] = SendRecvBuf [ i ++ ] ; pTransceiveInfo -> sSendData . buffer [ 5 ] = SendRecvBuf [ i ++ ] ; pTransceiveInfo -> sSendData . buffer [ 6 ] = SendRecvBuf [ i ++ ] ; pTransceiveInfo -> sSendData . buffer [ 7 ] = SendRecvBuf [ i ++ ] ; pTransceiveInfo -> sSendData . buffer [ 8 ] = SendRecvBuf [ i ++ ] ; pTransceiveInfo -> sSendData . buffer [ 9 ] = SendRecvBuf [ i ++ ] ; pTransceiveInfo -> cmd . MfCmd = Cmd . MfCmd ; pTransceiveInfo -> sSendData . length = length ; pTransceiveInfo -> sRecvData . length = MAX_BUFF_SIZE ; status = phLibNfc_MifareMap ( pTransceiveInfo , & tNciTranscvInfo ) ; } else if ( Cmd . MfCmd == phNfc_eMifareWrite16 ) { pTransceiveInfo -> addr = SendRecvBuf [ i ++ ] ; length = SendLength - i ; memcpy ( pTransceiveInfo -> sSendData . buffer , & SendRecvBuf [ i ] , length ) ; pTransceiveInfo -> sSendData . length = length ; pTransceiveInfo -> sRecvData . length = MAX_BUFF_SIZE ; gphNxpExtns_Context . writecmdFlag = true ; status = phLibNfc_SendWrt16Cmd ( pTransceiveInfo , & tNciTranscvInfo ) ; } else if ( ( Cmd . MfCmd == phNfc_eMifareInc ) || ( Cmd . MfCmd == phNfc_eMifareDec ) ) { pTransceiveInfo -> addr = SendRecvBuf [ i ++ ] ; length = SendLength - i ; memcpy ( pTransceiveInfo -> sSendData . buffer , & SendRecvBuf [ i ] , length ) ; pTransceiveInfo -> sSendData . length = length ; pTransceiveInfo -> sRecvData . length = MAX_BUFF_SIZE ; gphNxpExtns_Context . incrdecflag = true ; status = phLibNfc_SendIncDecCmd ( pTransceiveInfo , & tNciTranscvInfo , Cmd . MfCmd ) ; } else if ( Cmd . MfCmd == phNfc_eMifareRestore ) { pTransceiveInfo -> addr = SendRecvBuf [ i ++ ] ; length = SendLength - i ; memcpy ( pTransceiveInfo -> sSendData . buffer , & restore_payload [ 0 ] , sizeof ( restore_payload ) ) ; pTransceiveInfo -> sSendData . length = length + sizeof ( restore_payload ) ; pTransceiveInfo -> sRecvData . length = MAX_BUFF_SIZE ; gphNxpExtns_Context . incrdecflag = true ; status = phLibNfc_SendIncDecCmd ( pTransceiveInfo , & tNciTranscvInfo , Cmd . MfCmd ) ; } else if ( ( Cmd . MfCmd == phNfc_eMifareRaw ) || ( Cmd . MfCmd == phNfc_eMifareTransfer ) ) { pTransceiveInfo -> cmd . MfCmd = ( phNfc_eMifareCmdList_t ) phNciNfc_eT2TRaw ; memcpy ( pTransceiveInfo -> sSendData . buffer , SendRecvBuf , length ) ; pTransceiveInfo -> sSendData . length = length ; pTransceiveInfo -> sRecvData . length = MAX_BUFF_SIZE ; status = phLibNfc_SendRawCmd ( pTransceiveInfo , & tNciTranscvInfo ) ; } else { pTransceiveInfo -> addr = SendRecvBuf [ i ++ ] ; length = SendLength - i ; memcpy ( pTransceiveInfo -> sSendData . buffer , & SendRecvBuf [ i ] , length ) ; pTransceiveInfo -> sSendData . length = length ; pTransceiveInfo -> sRecvData . length = MAX_BUFF_SIZE ; status = phLibNfc_MifareMap ( pTransceiveInfo , & tNciTranscvInfo ) ; } if ( NFCSTATUS_SUCCESS == status ) { status = phNciNfc_SendMfReq ( tNciTranscvInfo , buff , & buffSz ) ; if ( NFCSTATUS_PENDING != status ) { LOG ( ERROR ) < < StringPrintf ( "ERROR : phNciNfc_SendMfReq()" ) ; } } else { LOG ( ERROR ) < < StringPrintf ( " ERROR : Sending phNciNfc_SendMfReq" ) ; } if ( buff != NULL ) { free ( buff ) ; buff = NULL ; } return status ; }
JS_TransplantObject ( JSContext * cx , HandleObject origobj , HandleObject target ) { AssertHeapIsIdle ( cx ) ; JS_ASSERT ( origobj != target ) ; JS_ASSERT ( ! origobj -> is < CrossCompartmentWrapperObject > ( ) ) ; JS_ASSERT ( ! target -> is < CrossCompartmentWrapperObject > ( ) ) ; AutoMaybeTouchDeadZones agc ( cx ) ; AutoDisableProxyCheck adpc ( cx -> runtime ( ) ) ; JSCompartment * destination = target -> compartment ( ) ; RootedValue origv ( cx , ObjectValue ( * origobj ) ) ; RootedObject newIdentity ( cx ) ; if ( origobj -> compartment ( ) == destination ) { if ( ! JSObject :: swap ( cx , origobj , target ) ) MOZ_CRASH ( ) ; newIdentity = origobj ; } else if ( WrapperMap :: Ptr p = destination -> lookupWrapper ( origv ) ) { newIdentity = & p -> value ( ) . get ( ) . toObject ( ) ; destination -> removeWrapper ( p ) ; NukeCrossCompartmentWrapper ( cx , newIdentity ) ; if ( ! JSObject :: swap ( cx , newIdentity , target ) ) MOZ_CRASH ( ) ; } else { newIdentity = target ; } if ( ! RemapAllWrappersForObject ( cx , origobj , newIdentity ) ) MOZ_CRASH ( ) ; if ( origobj -> compartment ( ) != destination ) { RootedObject newIdentityWrapper ( cx , newIdentity ) ; AutoCompartment ac ( cx , origobj ) ; if ( ! JS_WrapObject ( cx , & newIdentityWrapper ) ) MOZ_CRASH ( ) ; JS_ASSERT ( Wrapper :: wrappedObject ( newIdentityWrapper ) == newIdentity ) ; if ( ! JSObject :: swap ( cx , origobj , newIdentityWrapper ) ) MOZ_CRASH ( ) ; origobj -> compartment ( ) -> putWrapper ( cx , CrossCompartmentKey ( newIdentity ) , origv ) ; } return newIdentity ; }
static int binder_open ( struct inode * nodp , struct file * filp ) { struct binder_proc * proc , * itr ; struct binder_device * binder_dev ; struct binderfs_info * info ; struct dentry * binder_binderfs_dir_entry_proc = NULL ; bool existing_pid = false ; binder_debug ( BINDER_DEBUG_OPEN_CLOSE , "%s: %d:%d\n" , __func__ , current -> group_leader -> pid , current -> pid ) ; proc = kzalloc ( sizeof ( * proc ) , GFP_KERNEL ) ; if ( proc == NULL ) return - ENOMEM ; spin_lock_init ( & proc -> inner_lock ) ; spin_lock_init ( & proc -> outer_lock ) ; get_task_struct ( current -> group_leader ) ; proc -> tsk = current -> group_leader ; INIT_LIST_HEAD ( & proc -> todo ) ; init_waitqueue_head ( & proc -> freeze_wait ) ; if ( binder_supported_policy ( current -> policy ) ) { proc -> default_priority . sched_policy = current -> policy ; proc -> default_priority . prio = current -> normal_prio ; } else { proc -> default_priority . sched_policy = SCHED_NORMAL ; proc -> default_priority . prio = NICE_TO_PRIO ( 0 ) ; } if ( is_binderfs_device ( nodp ) ) { binder_dev = nodp -> i_private ; info = nodp -> i_sb -> s_fs_info ; binder_binderfs_dir_entry_proc = info -> proc_log_dir ; } else { binder_dev = container_of ( filp -> private_data , struct binder_device , miscdev ) ; } refcount_inc ( & binder_dev -> ref ) ; proc -> context = & binder_dev -> context ; binder_alloc_init ( & proc -> alloc ) ; binder_stats_created ( BINDER_STAT_PROC ) ; proc -> pid = current -> group_leader -> pid ; INIT_LIST_HEAD ( & proc -> delivered_death ) ; INIT_LIST_HEAD ( & proc -> waiting_threads ) ; filp -> private_data = proc ; mutex_lock ( & binder_procs_lock ) ; hlist_for_each_entry ( itr , & binder_procs , proc_node ) { if ( itr -> pid == proc -> pid ) { existing_pid = true ; break ; } } hlist_add_head ( & proc -> proc_node , & binder_procs ) ; mutex_unlock ( & binder_procs_lock ) ; trace_android_vh_binder_preset ( & binder_procs , & binder_procs_lock ) ; if ( binder_debugfs_dir_entry_proc && ! existing_pid ) { char strbuf [ 11 ] ; snprintf ( strbuf , sizeof ( strbuf ) , "%u" , proc -> pid ) ; proc -> debugfs_entry = debugfs_create_file ( strbuf , 0444 , binder_debugfs_dir_entry_proc , ( void * ) ( unsigned long ) proc -> pid , & proc_fops ) ; } if ( binder_binderfs_dir_entry_proc && ! existing_pid ) { char strbuf [ 11 ] ; struct dentry * binderfs_entry ; snprintf ( strbuf , sizeof ( strbuf ) , "%u" , proc -> pid ) ; binderfs_entry = binderfs_create_file ( binder_binderfs_dir_entry_proc , strbuf , & proc_fops , ( void * ) ( unsigned long ) proc -> pid ) ; if ( ! IS_ERR ( binderfs_entry ) ) { proc -> binderfs_entry = binderfs_entry ; } else { int error ; error = PTR_ERR ( binderfs_entry ) ; pr_warn ( "Unable to create file %s in binderfs (error %d)\n" , strbuf , error ) ; } } return 0 ; }
void Builtins :: Generate_InterpreterPushArgsThenConstructImpl ( MacroAssembler * masm , InterpreterPushArgsMode mode ) { Label stack_overflow ; __ push ( zero_reg ) ; Generate_StackOverflowCheck ( masm , a0 , t1 , t0 , & stack_overflow ) ; Generate_InterpreterPushArgs ( masm , a0 , t4 , t1 , t0 ) ; if ( mode == InterpreterPushArgsMode :: kWithFinalSpread ) { __ Pop ( a2 ) ; __ Subu ( a0 , a0 , Operand ( 1 ) ) ; } else { __ AssertUndefinedOrAllocationSite ( a2 , t0 ) ; } if ( mode == InterpreterPushArgsMode :: kArrayFunction ) { __ AssertFunction ( a1 ) ; __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , ArrayConstructorImpl ) , RelocInfo :: CODE_TARGET ) ; } else if ( mode == InterpreterPushArgsMode :: kWithFinalSpread ) { __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , ConstructWithSpread ) , RelocInfo :: CODE_TARGET ) ; } else { DCHECK_EQ ( InterpreterPushArgsMode :: kOther , mode ) ; __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , Construct ) , RelocInfo :: CODE_TARGET ) ; } __ bind ( & stack_overflow ) ; { __ TailCallRuntime ( Runtime :: kThrowStackOverflow ) ; __ break_ ( 0xCC ) ; } }
const uint8_t * nsZipArchive :: GetData ( nsZipItem * aItem ) { PR_ASSERT ( aItem ) ; MOZ_WIN_MEM_TRY_BEGIN uint32_t offset = GetDataOffset ( aItem ) ; if ( ! offset || mFd -> mLen < aItem -> Size ( ) || offset > mFd -> mLen - aItem -> Size ( ) ) return nullptr ; return mFd -> mFileData + offset ; MOZ_WIN_MEM_TRY_CATCH ( return nullptr ) }
MaybeHandle < Map > GetInternalizedStringMap ( Factory * f , Handle < String > string ) { switch ( string -> map ( ) -> instance_type ( ) ) { case STRING_TYPE : return f -> internalized_string_map ( ) ; case ONE_BYTE_STRING_TYPE : return f -> one_byte_internalized_string_map ( ) ; case EXTERNAL_STRING_TYPE : return f -> external_internalized_string_map ( ) ; case EXTERNAL_ONE_BYTE_STRING_TYPE : return f -> external_one_byte_internalized_string_map ( ) ; case EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE : return f -> external_internalized_string_with_one_byte_data_map ( ) ; case SHORT_EXTERNAL_STRING_TYPE : return f -> short_external_internalized_string_map ( ) ; case SHORT_EXTERNAL_ONE_BYTE_STRING_TYPE : return f -> short_external_one_byte_internalized_string_map ( ) ; case SHORT_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE : return f -> short_external_internalized_string_with_one_byte_data_map ( ) ; default : return MaybeHandle < Map > ( ) ; } }
static int snd_ctl_elem_read ( struct snd_card * card , struct snd_ctl_elem_value * control ) { struct snd_kcontrol * kctl ; struct snd_kcontrol_volatile * vd ; unsigned int index_offset ; struct snd_ctl_elem_info info ; const u32 pattern = 0xdeadbeef ; int ret ; kctl = snd_ctl_find_id ( card , & control -> id ) ; if ( kctl == NULL ) return - ENOENT ; index_offset = snd_ctl_get_ioff ( kctl , & control -> id ) ; vd = & kctl -> vd [ index_offset ] ; if ( ! ( vd -> access & SNDRV_CTL_ELEM_ACCESS_READ ) || kctl -> get == NULL ) return - EPERM ; snd_ctl_build_ioff ( & control -> id , kctl , index_offset ) ; #ifdef CONFIG_SND_CTL_DEBUG memset ( & info , 0 , sizeof ( info ) ) ; info . id = control -> id ; ret = __snd_ctl_elem_info ( card , kctl , & info , NULL ) ; if ( ret < 0 ) return ret ; #endif if ( ! snd_ctl_skip_validation ( & info ) ) fill_remaining_elem_value ( control , & info , pattern ) ; ret = snd_power_ref_and_wait ( card ) ; if ( ! ret ) ret = kctl -> get ( kctl , control ) ; snd_power_unref ( card ) ; if ( ret < 0 ) return ret ; if ( ! snd_ctl_skip_validation ( & info ) && sanity_check_elem_value ( card , control , & info , pattern ) < 0 ) { dev_err ( card -> dev , "control %i:%i:%i:%s:%i: access overflow\n" , control -> id . iface , control -> id . device , control -> id . subdevice , control -> id . name , control -> id . index ) ; return - EINVAL ; } return ret ; }
RemoveInFlows ( nsTextFrame * aFrame , nsTextFrame * aFirstToNotRemove ) { NS_PRECONDITION ( aFrame != aFirstToNotRemove , "This will go very badly" ) ; NS_ASSERTION ( aFirstToNotRemove -> GetPrevContinuation ( ) == aFirstToNotRemove -> GetPrevInFlow ( ) && aFirstToNotRemove -> GetPrevInFlow ( ) != nullptr , "aFirstToNotRemove should have a fluid prev continuation" ) ; NS_ASSERTION ( aFrame -> GetPrevContinuation ( ) == aFrame -> GetPrevInFlow ( ) && aFrame -> GetPrevInFlow ( ) != nullptr , "aFrame should have a fluid prev continuation" ) ; nsIFrame * prevContinuation = aFrame -> GetPrevContinuation ( ) ; nsIFrame * lastRemoved = aFirstToNotRemove -> GetPrevContinuation ( ) ; nsIFrame * parent = aFrame -> GetParent ( ) ; nsBlockFrame * parentBlock = nsLayoutUtils :: GetAsBlock ( parent ) ; if ( ! parentBlock ) { aFrame -> ClearTextRuns ( ) ; if ( aFrame != lastRemoved ) { static_cast < nsTextFrame * > ( lastRemoved ) -> ClearTextRuns ( ) ; } } prevContinuation -> SetNextInFlow ( aFirstToNotRemove ) ; aFirstToNotRemove -> SetPrevInFlow ( prevContinuation ) ; aFrame -> SetPrevInFlow ( nullptr ) ; lastRemoved -> SetNextInFlow ( nullptr ) ; if ( parentBlock ) { parentBlock -> DoRemoveFrame ( aFrame , nsBlockFrame :: FRAMES_ARE_EMPTY ) ; } else { parent -> RemoveFrame ( nsIFrame :: kNoReflowPrincipalList , aFrame ) ; } }
nsFieldSetFrame :: AppendFrames ( ChildListID aListID , nsFrameList & aFrameList ) { ReparentFrameList ( aFrameList ) ; return mContentFrame -> AppendFrames ( aListID , aFrameList ) ; }
static int catc_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct device * dev = & intf -> dev ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct net_device * netdev ; struct catc * catc ; u8 broadcast [ ETH_ALEN ] ; int i , pktsz , ret ; if ( usb_set_interface ( usbdev , intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) { dev_err ( dev , "Can't set altsetting 1.\n" ) ; return - EIO ; } netdev = alloc_etherdev ( sizeof ( struct catc ) ) ; if ( ! netdev ) return - ENOMEM ; catc = netdev_priv ( netdev ) ; netdev -> netdev_ops = & catc_netdev_ops ; netdev -> watchdog_timeo = TX_TIMEOUT ; netdev -> ethtool_ops = & ops ; catc -> usbdev = usbdev ; catc -> netdev = netdev ; spin_lock_init ( & catc -> tx_lock ) ; spin_lock_init ( & catc -> ctrl_lock ) ; init_timer ( & catc -> timer ) ; catc -> timer . data = ( long ) catc ; catc -> timer . function = catc_stats_timer ; catc -> ctrl_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> tx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> rx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> irq_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ( ! catc -> ctrl_urb ) || ( ! catc -> tx_urb ) || ( ! catc -> rx_urb ) || ( ! catc -> irq_urb ) ) { dev_err ( & intf -> dev , "No free urbs available.\n" ) ; ret = - ENOMEM ; goto fail_free ; } if ( le16_to_cpu ( usbdev -> descriptor . idVendor ) == 0x0423 && le16_to_cpu ( usbdev -> descriptor . idProduct ) == 0xa && le16_to_cpu ( catc -> usbdev -> descriptor . bcdDevice ) == 0x0130 ) { dev_dbg ( dev , "Testing for f5u011\n" ) ; catc -> is_f5u011 = 1 ; atomic_set ( & catc -> recq_sz , 0 ) ; pktsz = RX_PKT_SZ ; } else { pktsz = RX_MAX_BURST * ( PKT_SZ + 2 ) ; } usb_fill_control_urb ( catc -> ctrl_urb , usbdev , usb_sndctrlpipe ( usbdev , 0 ) , NULL , NULL , 0 , catc_ctrl_done , catc ) ; usb_fill_bulk_urb ( catc -> tx_urb , usbdev , usb_sndbulkpipe ( usbdev , 1 ) , NULL , 0 , catc_tx_done , catc ) ; usb_fill_bulk_urb ( catc -> rx_urb , usbdev , usb_rcvbulkpipe ( usbdev , 1 ) , catc -> rx_buf , pktsz , catc_rx_done , catc ) ; usb_fill_int_urb ( catc -> irq_urb , usbdev , usb_rcvintpipe ( usbdev , 2 ) , catc -> irq_buf , 2 , catc_irq_done , catc , 1 ) ; if ( ! catc -> is_f5u011 ) { dev_dbg ( dev , "Checking memory size\n" ) ; i = 0x12345678 ; catc_write_mem ( catc , 0x7a80 , & i , 4 ) ; i = 0x87654321 ; catc_write_mem ( catc , 0xfa80 , & i , 4 ) ; catc_read_mem ( catc , 0x7a80 , & i , 4 ) ; switch ( i ) { case 0x12345678 : catc_set_reg ( catc , TxBufCount , 8 ) ; catc_set_reg ( catc , RxBufCount , 32 ) ; dev_dbg ( dev , "64k Memory\n" ) ; break ; default : dev_warn ( & intf -> dev , "Couldn't detect memory size, assuming 32k\n" ) ; case 0x87654321 : catc_set_reg ( catc , TxBufCount , 4 ) ; catc_set_reg ( catc , RxBufCount , 16 ) ; dev_dbg ( dev , "32k Memory\n" ) ; break ; } dev_dbg ( dev , "Getting MAC from SEEROM.\n" ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , "Setting MAC into registers.\n" ) ; for ( i = 0 ; i < 6 ; i ++ ) catc_set_reg ( catc , StationAddr0 - i , netdev -> dev_addr [ i ] ) ; dev_dbg ( dev , "Filling the multicast list.\n" ) ; eth_broadcast_addr ( broadcast ) ; catc_multicast ( broadcast , catc -> multicast ) ; catc_multicast ( netdev -> dev_addr , catc -> multicast ) ; catc_write_mem ( catc , 0xfa80 , catc -> multicast , 64 ) ; dev_dbg ( dev , "Clearing error counters.\n" ) ; for ( i = 0 ; i < 8 ; i ++ ) catc_set_reg ( catc , EthStats + i , 0 ) ; catc -> last_stats = jiffies ; dev_dbg ( dev , "Enabling.\n" ) ; catc_set_reg ( catc , MaxBurst , RX_MAX_BURST ) ; catc_set_reg ( catc , OpModes , OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits ) ; catc_set_reg ( catc , LEDCtrl , LEDLink ) ; catc_set_reg ( catc , RxUnit , RxEnable | RxPolarity | RxMultiCast ) ; } else { dev_dbg ( dev , "Performing reset\n" ) ; catc_reset ( catc ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , "Setting RX Mode\n" ) ; catc -> rxmode [ 0 ] = RxEnable | RxPolarity | RxMultiCast ; catc -> rxmode [ 1 ] = 0 ; f5u011_rxmode ( catc , catc -> rxmode ) ; } dev_dbg ( dev , "Init done.\n" ) ; printk ( KERN_INFO "%s: %s USB Ethernet at usb-%s-%s, %pM.\n" , netdev -> name , ( catc -> is_f5u011 ) ? "Belkin F5U011" : "CATC EL1210A NetMate" , usbdev -> bus -> bus_name , usbdev -> devpath , netdev -> dev_addr ) ; usb_set_intfdata ( intf , catc ) ; SET_NETDEV_DEV ( netdev , & intf -> dev ) ; ret = register_netdev ( netdev ) ; if ( ret ) goto fail_clear_intfdata ; return 0 ; fail_clear_intfdata : usb_set_intfdata ( intf , NULL ) ; fail_free : usb_free_urb ( catc -> ctrl_urb ) ; usb_free_urb ( catc -> tx_urb ) ; usb_free_urb ( catc -> rx_urb ) ; usb_free_urb ( catc -> irq_urb ) ; free_netdev ( netdev ) ; return ret ; }
sp < AMessage > AMessage :: FromParcel ( const Parcel & parcel ) { int32_t what = parcel . readInt32 ( ) ; sp < AMessage > msg = new AMessage ( what ) ; msg -> mNumItems = static_cast < size_t > ( parcel . readInt32 ( ) ) ; for ( size_t i = 0 ; i < msg -> mNumItems ; ++ i ) { Item * item = & msg -> mItems [ i ] ; const char * name = parcel . readCString ( ) ; item -> setName ( name , strlen ( name ) ) ; item -> mType = static_cast < Type > ( parcel . readInt32 ( ) ) ; switch ( item -> mType ) { case kTypeInt32 : { item -> u . int32Value = parcel . readInt32 ( ) ; break ; } case kTypeInt64 : { item -> u . int64Value = parcel . readInt64 ( ) ; break ; } case kTypeSize : { item -> u . sizeValue = static_cast < size_t > ( parcel . readInt32 ( ) ) ; break ; } case kTypeFloat : { item -> u . floatValue = parcel . readFloat ( ) ; break ; } case kTypeDouble : { item -> u . doubleValue = parcel . readDouble ( ) ; break ; } case kTypeString : { item -> u . stringValue = new AString ( parcel . readCString ( ) ) ; break ; } case kTypeMessage : { sp < AMessage > subMsg = AMessage :: FromParcel ( parcel ) ; subMsg -> incStrong ( msg . get ( ) ) ; item -> u . refValue = subMsg . get ( ) ; break ; } default : { ALOGE ( "This type of object cannot cross process boundaries." ) ; TRESPASS ( ) ; } } } return msg ; }
TfLiteStatus TanhEval ( TfLiteContext * context , TfLiteNode * node ) { OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; const TfLiteTensor * input = GetInput ( context , node , 0 ) ; TfLiteTensor * output = GetOutput ( context , node , 0 ) ; switch ( input -> type ) { case kTfLiteFloat32 : { if ( kernel_type == kReference ) { reference_ops :: Tanh ( GetTensorShape ( input ) , GetTensorData < float > ( input ) , GetTensorShape ( output ) , GetTensorData < float > ( output ) ) ; } else { optimized_ops :: Tanh ( GetTensorShape ( input ) , GetTensorData < float > ( input ) , GetTensorShape ( output ) , GetTensorData < float > ( output ) ) ; } return kTfLiteOk ; } break ; case kTfLiteInt16 : { TanhParams params ; params . input_left_shift = data -> input_left_shift ; if ( kernel_type == kReference || ( data -> input_multiplier > 0 ) ) { reference_integer_ops :: Tanh ( data -> input_multiplier , data -> input_left_shift , GetTensorShape ( input ) , GetTensorData < int16_t > ( input ) , GetTensorShape ( output ) , GetTensorData < int16_t > ( output ) ) ; } else { optimized_ops :: Tanh ( params , GetTensorShape ( input ) , GetTensorData < int16_t > ( input ) , GetTensorShape ( output ) , GetTensorData < int16_t > ( output ) ) ; } return kTfLiteOk ; } break ; case kTfLiteUInt8 : { if ( kernel_type == kFixedPointOptimized ) { TanhParams params ; params . input_zero_point = input -> params . zero_point ; params . input_range_radius = data -> input_range_radius ; params . input_multiplier = data -> input_multiplier ; params . input_left_shift = data -> input_left_shift ; optimized_ops :: Tanh16bitPrecision ( params , GetTensorShape ( input ) , GetTensorData < uint8_t > ( input ) , GetTensorShape ( output ) , GetTensorData < uint8_t > ( output ) ) ; } else { EvalUsingLookupTable ( data , input , output ) ; } return kTfLiteOk ; } break ; case kTfLiteInt8 : { if ( kernel_type == kFixedPointOptimized ) { TanhParams params ; params . input_zero_point = input -> params . zero_point ; params . input_range_radius = data -> input_range_radius ; params . input_multiplier = data -> input_multiplier ; params . input_left_shift = data -> input_left_shift ; optimized_ops :: Tanh16bitPrecision ( params , GetTensorShape ( input ) , GetTensorData < int8_t > ( input ) , GetTensorShape ( output ) , GetTensorData < int8_t > ( output ) ) ; } else { EvalUsingLookupTable ( data , input , output ) ; } return kTfLiteOk ; } break ; default : TF_LITE_KERNEL_LOG ( context , "Only float32, uint8, int16 and int8 are supported " "currently, got %s." , TfLiteTypeGetName ( input -> type ) ) ; return kTfLiteError ; } }
nsNumberControlFrame :: HandleFocusEvent ( WidgetEvent * aEvent ) { if ( aEvent -> mOriginalTarget != mTextField ) { IgnoredErrorResult ignored ; HTMLInputElement :: FromContent ( mTextField ) -> Focus ( ignored ) ; } }
explicit TestFifoBuffer ( fifo_frames_t capacity , fifo_frames_t threshold = 0 ) : mFifoBuffer ( sizeof ( int16_t ) , capacity ) { mData = new int16_t [ capacity ] ; if ( threshold <= 0 ) { threshold = capacity ; } mFifoBuffer . setThreshold ( threshold ) ; mThreshold = threshold ; }
xmlPushInput ( xmlParserCtxtPtr ctxt , xmlParserInputPtr input ) { int ret ; if ( input == NULL ) return ( - 1 ) ; if ( xmlParserDebugEntities ) { if ( ( ctxt -> input != NULL ) && ( ctxt -> input -> filename ) ) xmlGenericError ( xmlGenericErrorContext , "%s(%d): " , ctxt -> input -> filename , ctxt -> input -> line ) ; xmlGenericError ( xmlGenericErrorContext , "Pushing input %d : %.30s\n" , ctxt -> inputNr + 1 , input -> cur ) ; } ret = inputPush ( ctxt , input ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( - 1 ) ; GROW ; return ( ret ) ; }
static void pdf_handle_enc ( struct pdf_struct * pdf ) { struct pdf_obj * obj ; uint32_t len , required_flags , n , R , P , length , EM , i , oulen ; char * O , * U ; const char * q , * q2 ; if ( pdf -> enc_objid == ~ 0u ) return ; if ( ! pdf -> fileID ) { cli_dbgmsg ( "cli_pdf: pdf_handle_enc no file ID\n" ) ; return ; } obj = find_obj ( pdf , pdf -> objs , pdf -> enc_objid ) ; if ( ! obj ) { cli_dbgmsg ( "cli_pdf: can't find encrypted object %d %d\n" , pdf -> enc_objid > > 8 , pdf -> enc_objid & 0xff ) ; return ; } len = obj_size ( pdf , obj , 1 ) ; q = pdf -> map + obj -> start ; O = U = NULL ; do { EM = pdf_readbool ( q , len , "/EncryptMetadata" , 1 ) ; P = pdf_readint ( q , len , "/P" ) ; if ( P == ~ 0u ) { cli_dbgmsg ( "cli_pdf: invalid P\n" ) ; break ; } q2 = cli_memstr ( q , len , "/Standard" , 9 ) ; if ( ! q2 ) { cli_dbgmsg ( "cli_pdf: /Standard not found\n" ) ; break ; } length = pdf_readint ( q2 , len - ( q2 - q ) , "/Length" ) ; if ( length == ~ 0u ) length = pdf_readint ( q , len , "/Length" ) ; if ( length == ~ 0u ) length = 40 ; if ( length < 40 ) { cli_dbgmsg ( "cli_pdf: invalid length: %d\n" , length ) ; length = 40 ; } R = pdf_readint ( q , len , "/R" ) ; if ( R == ~ 0u ) { cli_dbgmsg ( "cli_pdf: invalid R\n" ) ; break ; } if ( R < 5 ) oulen = 32 ; else oulen = 48 ; n = 0 ; O = pdf_readstring ( q , len , "/O" , & n ) ; if ( ! O || n < oulen ) { cli_dbgmsg ( "cli_pdf: invalid O: %d\n" , n ) ; if ( O ) dbg_printhex ( "invalid O" , O , n ) ; break ; } if ( n > oulen ) { for ( i = oulen ; i < n ; i ++ ) if ( O [ i ] ) break ; if ( i != n ) { dbg_printhex ( "too long O" , O , n ) ; break ; } } n = 0 ; U = pdf_readstring ( q , len , "/U" , & n ) ; if ( ! U || n < oulen ) { cli_dbgmsg ( "cli_pdf: invalid U: %d\n" , n ) ; if ( U ) dbg_printhex ( "invalid U" , U , n ) ; break ; } if ( n > oulen ) { for ( i = oulen ; i < n ; i ++ ) if ( U [ i ] ) break ; if ( i != n ) { dbg_printhex ( "too long U" , U , n ) ; break ; } } cli_dbgmsg ( "cli_pdf: Encrypt R: %d, P %x, length: %d\n" , R , P , length ) ; if ( length % 8 ) { cli_dbgmsg ( "cli_pdf: wrong key length, not multiple of 8\n" ) ; break ; } check_user_password ( pdf , R , O , U , P , EM , length , oulen ) ; } while ( 0 ) ; free ( O ) ; free ( U ) ; }
IGNITION_HANDLER ( IncBlockCounter , InterpreterAssembler ) { Node * closure = LoadRegister ( Register :: function_closure ( ) ) ; Node * coverage_array_slot = BytecodeOperandIdxSmi ( 0 ) ; Node * context = GetContext ( ) ; CallRuntime ( Runtime :: kIncBlockCounter , context , closure , coverage_array_slot ) ; Dispatch ( ) ; }
FstringParser_Finish ( FstringParser * state , struct compiling * c , const node * n ) { asdl_seq * seq ; FstringParser_check_invariants ( state ) ; if ( state -> expr_list . size == 0 ) { if ( ! state -> last_str ) { state -> last_str = PyUnicode_FromStringAndSize ( NULL , 0 ) ; if ( ! state -> last_str ) goto error ; } return make_str_node_and_del ( & state -> last_str , c , n ) ; } if ( state -> last_str ) { expr_ty str = make_str_node_and_del ( & state -> last_str , c , n ) ; if ( ! str || ExprList_Append ( & state -> expr_list , str ) < 0 ) goto error ; } assert ( state -> last_str == NULL ) ; seq = ExprList_Finish ( & state -> expr_list , c -> c_arena ) ; if ( ! seq ) goto error ; if ( seq -> size == 1 ) return seq -> elements [ 0 ] ; return JoinedStr ( seq , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; error : FstringParser_Dealloc ( state ) ; return NULL ; }
PluginModuleParent :: LoadModule ( const char * aFilePath ) { PLUGIN_LOG_DEBUG_FUNCTION ; int32_t prefSecs = Preferences :: GetInt ( kLaunchTimeoutPref , 0 ) ; nsAutoPtr < PluginModuleParent > parent ( new PluginModuleParent ( aFilePath ) ) ; bool launched = parent -> mSubprocess -> Launch ( prefSecs * 1000 ) ; if ( ! launched ) { parent -> mShutdown = true ; return nullptr ; } parent -> Open ( parent -> mSubprocess -> GetChannel ( ) , parent -> mSubprocess -> GetChildProcessHandle ( ) ) ; TimeoutChanged ( CHILD_TIMEOUT_PREF , parent ) ; #ifdef MOZ_CRASHREPORTER if ( ! CrashReporterParent :: CreateCrashReporter ( parent . get ( ) ) ) { parent -> mShutdown = true ; return nullptr ; } #ifdef XP_WIN mozilla :: MutexAutoLock lock ( parent -> mCrashReporterMutex ) ; parent -> mCrashReporter = parent -> CrashReporter ( ) ; #endif #endif return parent . forget ( ) ; }
std :: set < std :: string > Intl :: GetAvailableLocales ( const IcuService & service ) { const icu :: Locale * icu_available_locales = nullptr ; int32_t count = 0 ; std :: set < std :: string > locales ; switch ( service ) { case IcuService :: kBreakIterator : icu_available_locales = icu :: BreakIterator :: getAvailableLocales ( count ) ; break ; case IcuService :: kCollator : icu_available_locales = icu :: Collator :: getAvailableLocales ( count ) ; break ; case IcuService :: kDateFormat : icu_available_locales = icu :: DateFormat :: getAvailableLocales ( count ) ; break ; case IcuService :: kNumberFormat : icu_available_locales = icu :: NumberFormat :: getAvailableLocales ( count ) ; break ; case IcuService :: kPluralRules : icu_available_locales = icu :: Locale :: getAvailableLocales ( count ) ; break ; case IcuService :: kResourceBundle : { UErrorCode status = U_ZERO_ERROR ; UEnumeration * en = ures_openAvailableLocales ( nullptr , & status ) ; int32_t length = 0 ; const char * locale_str = uenum_next ( en , & length , & status ) ; while ( U_SUCCESS ( status ) && ( locale_str != nullptr ) ) { std :: string locale ( locale_str , length ) ; std :: replace ( locale . begin ( ) , locale . end ( ) , '_' , '-' ) ; locales . insert ( locale ) ; std :: string shortened_locale ; if ( Intl :: RemoveLocaleScriptTag ( locale_str , & shortened_locale ) ) { std :: replace ( shortened_locale . begin ( ) , shortened_locale . end ( ) , '_' , '-' ) ; locales . insert ( shortened_locale ) ; } locale_str = uenum_next ( en , & length , & status ) ; } uenum_close ( en ) ; return locales ; } case IcuService :: kRelativeDateTimeFormatter : { std :: set < std :: string > number_format_set ( Intl :: GetAvailableLocales ( IcuService :: kNumberFormat ) ) ; std :: set < std :: string > resource_bundle_set ( Intl :: GetAvailableLocales ( IcuService :: kResourceBundle ) ) ; set_intersection ( resource_bundle_set . begin ( ) , resource_bundle_set . end ( ) , number_format_set . begin ( ) , number_format_set . end ( ) , std :: inserter ( locales , locales . begin ( ) ) ) ; return locales ; } case IcuService :: kListFormatter : { icu_available_locales = icu :: Locale :: getAvailableLocales ( count ) ; break ; } } UErrorCode error = U_ZERO_ERROR ; char result [ ULOC_FULLNAME_CAPACITY ] ; for ( int32_t i = 0 ; i < count ; ++ i ) { const char * icu_name = icu_available_locales [ i ] . getName ( ) ; error = U_ZERO_ERROR ; uloc_toLanguageTag ( icu_name , result , ULOC_FULLNAME_CAPACITY , FALSE , & error ) ; if ( U_FAILURE ( error ) || error == U_STRING_NOT_TERMINATED_WARNING ) { continue ; } std :: string locale ( result ) ; locales . insert ( locale ) ; std :: string shortened_locale ; if ( Intl :: RemoveLocaleScriptTag ( icu_name , & shortened_locale ) ) { std :: replace ( shortened_locale . begin ( ) , shortened_locale . end ( ) , '_' , '-' ) ; locales . insert ( shortened_locale ) ; } } return locales ; }
nsWindow :: UpdateOverscrollVelocity ( const float aX , const float aY ) { if ( mNPZCSupport ) { mNPZCSupport -> UpdateOverscrollVelocity ( aX , aY ) ; } }
const Operator * JSOperatorBuilder :: CallWithArrayLike ( CallFrequency frequency ) { return new ( zone ( ) ) Operator1 < CallFrequency > ( IrOpcode :: kJSCallWithArrayLike , Operator :: kNoProperties , "JSCallWithArrayLike" , 3 , 1 , 1 , 1 , 1 , 2 , frequency ) ; }
Node * ToJS ( Node * node , wasm :: ValueType type ) { switch ( type ) { case wasm :: kWasmI32 : return BuildChangeInt32ToTagged ( node ) ; case wasm :: kWasmS128 : case wasm :: kWasmI64 : UNREACHABLE ( ) ; case wasm :: kWasmF32 : node = graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> ChangeFloat32ToFloat64 ( ) , node ) ; return BuildChangeFloat64ToTagged ( node ) ; case wasm :: kWasmF64 : return BuildChangeFloat64ToTagged ( node ) ; case wasm :: kWasmAnyRef : return node ; default : UNREACHABLE ( ) ; } }
static int xfrm6_tunnel_rcv ( struct sk_buff * skb ) { struct ipv6hdr * iph = ipv6_hdr ( skb ) ; __be32 spi ; spi = xfrm6_tunnel_spi_lookup ( ( xfrm_address_t * ) & iph -> saddr ) ; return xfrm6_rcv_spi ( skb , spi ) ; }
static EAS_RESULT XMF_ReadNode ( EAS_HW_DATA_HANDLE hwInstData , S_XMF_DATA * pXMFData , EAS_I32 nodeOffset , EAS_I32 * pLength ) { EAS_RESULT result ; EAS_I32 refType ; EAS_I32 numItems ; EAS_I32 offset ; EAS_I32 length ; EAS_I32 headerLength ; EAS_U32 chunkType ; if ( ( result = EAS_HWFileSeek ( hwInstData , pXMFData -> fileHandle , nodeOffset ) ) != EAS_SUCCESS ) return result ; if ( ( result = XMF_ReadVLQ ( hwInstData , pXMFData -> fileHandle , pLength ) ) != EAS_SUCCESS ) return result ; if ( ( result = XMF_ReadVLQ ( hwInstData , pXMFData -> fileHandle , & numItems ) ) != EAS_SUCCESS ) return result ; if ( ( result = XMF_ReadVLQ ( hwInstData , pXMFData -> fileHandle , & headerLength ) ) != EAS_SUCCESS ) return result ; if ( ( result = XMF_ReadVLQ ( hwInstData , pXMFData -> fileHandle , & length ) ) != EAS_SUCCESS ) return result ; if ( ( result = EAS_HWFilePos ( hwInstData , pXMFData -> fileHandle , & offset ) ) != EAS_SUCCESS ) return result ; if ( offset - nodeOffset > headerLength ) return EAS_FAILURE ; if ( ( result = EAS_HWFileSeek ( hwInstData , pXMFData -> fileHandle , nodeOffset + headerLength ) ) != EAS_SUCCESS ) return result ; if ( ( result = XMF_ReadVLQ ( hwInstData , pXMFData -> fileHandle , & refType ) ) != EAS_SUCCESS ) return result ; if ( ( result = EAS_HWFilePos ( hwInstData , pXMFData -> fileHandle , & offset ) ) != EAS_SUCCESS ) return result ; if ( numItems == 0 ) { if ( refType == 2 ) { if ( ( result = XMF_ReadVLQ ( hwInstData , pXMFData -> fileHandle , & offset ) ) != EAS_SUCCESS ) return result ; offset += pXMFData -> fileOffset ; if ( ( result = EAS_HWFileSeek ( hwInstData , pXMFData -> fileHandle , offset ) ) != EAS_SUCCESS ) return result ; } else if ( refType != 1 ) { { } return EAS_ERROR_FILE_FORMAT ; } if ( ( result = EAS_HWGetDWord ( hwInstData , pXMFData -> fileHandle , & chunkType , EAS_TRUE ) ) != EAS_SUCCESS ) return result ; if ( chunkType == XMF_RIFF_CHUNK ) { if ( ( result = EAS_HWFileSeekOfs ( hwInstData , pXMFData -> fileHandle , sizeof ( EAS_I32 ) ) ) != EAS_SUCCESS ) return result ; if ( ( result = EAS_HWGetDWord ( hwInstData , pXMFData -> fileHandle , & chunkType , EAS_TRUE ) ) != EAS_SUCCESS ) return result ; if ( chunkType == XMF_RIFF_DLS ) pXMFData -> dlsOffset = offset ; } else if ( chunkType == XMF_SMF_CHUNK ) pXMFData -> midiOffset = offset ; } else { for ( ; numItems > 0 ; numItems -- ) { if ( ( result = XMF_ReadNode ( hwInstData , pXMFData , offset , & length ) ) != EAS_SUCCESS ) return result ; offset += length ; if ( ( result = EAS_HWFileSeek ( hwInstData , pXMFData -> fileHandle , offset ) ) != EAS_SUCCESS ) return result ; } } return EAS_SUCCESS ; }
static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) { struct desc_struct * desc ; unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ; if ( ! sel ) return 0 ; desc = get_desc ( sel ) ; if ( ! desc ) return 0 ; limit = get_desc_limit ( desc ) ; if ( desc -> g ) limit = ( limit < < 12 ) + 0xfff ; return limit ; }
int TNEFParse ( TNEFStruct * TNEF ) { WORD key ; DWORD type ; DWORD size ; DWORD signature ; BYTE * data ; WORD checksum , header_checksum ; int i ; if ( TNEF -> IO . ReadProc == NULL ) { printf ( "ERROR: Setup incorrectly: No ReadProc\n" ) ; return YTNEF_INCORRECT_SETUP ; } if ( TNEF -> IO . InitProc != NULL ) { DEBUG ( TNEF -> Debug , 2 , "About to initialize" ) ; if ( TNEF -> IO . InitProc ( & TNEF -> IO ) != 0 ) { return YTNEF_CANNOT_INIT_DATA ; } DEBUG ( TNEF -> Debug , 2 , "Initialization finished" ) ; } DEBUG ( TNEF -> Debug , 2 , "Reading Signature" ) ; if ( TNEF -> IO . ReadProc ( & TNEF -> IO , sizeof ( DWORD ) , 1 , & signature ) < 1 ) { printf ( "ERROR: Error reading signature\n" ) ; if ( TNEF -> IO . CloseProc != NULL ) { TNEF -> IO . CloseProc ( & TNEF -> IO ) ; } return YTNEF_ERROR_READING_DATA ; } DEBUG ( TNEF -> Debug , 2 , "Checking Signature" ) ; if ( TNEFCheckForSignature ( signature ) < 0 ) { printf ( "ERROR: Signature does not match. Not TNEF.\n" ) ; if ( TNEF -> IO . CloseProc != NULL ) { TNEF -> IO . CloseProc ( & TNEF -> IO ) ; } return YTNEF_NOT_TNEF_STREAM ; } DEBUG ( TNEF -> Debug , 2 , "Reading Key." ) ; if ( TNEFGetKey ( TNEF , & key ) < 0 ) { printf ( "ERROR: Unable to retrieve key.\n" ) ; if ( TNEF -> IO . CloseProc != NULL ) { TNEF -> IO . CloseProc ( & TNEF -> IO ) ; } return YTNEF_NO_KEY ; } DEBUG ( TNEF -> Debug , 2 , "Starting Full Processing." ) ; while ( TNEFGetHeader ( TNEF , & type , & size ) == 0 ) { DEBUG2 ( TNEF -> Debug , 2 , "Header says type=0x%X, size=%u" , type , size ) ; DEBUG2 ( TNEF -> Debug , 2 , "Header says type=%u, size=%u" , type , size ) ; data = calloc ( size , sizeof ( BYTE ) ) ; ALLOCCHECK ( data ) ; if ( TNEFRawRead ( TNEF , data , size , & header_checksum ) < 0 ) { printf ( "ERROR: Unable to read data.\n" ) ; if ( TNEF -> IO . CloseProc != NULL ) { TNEF -> IO . CloseProc ( & TNEF -> IO ) ; } free ( data ) ; return YTNEF_ERROR_READING_DATA ; } if ( TNEFRawRead ( TNEF , ( BYTE * ) & checksum , 2 , NULL ) < 0 ) { printf ( "ERROR: Unable to read checksum.\n" ) ; if ( TNEF -> IO . CloseProc != NULL ) { TNEF -> IO . CloseProc ( & TNEF -> IO ) ; } free ( data ) ; return YTNEF_ERROR_READING_DATA ; } checksum = SwapWord ( ( BYTE * ) & checksum , sizeof ( WORD ) ) ; if ( checksum != header_checksum ) { printf ( "ERROR: Checksum mismatch. Data corruption?:\n" ) ; if ( TNEF -> IO . CloseProc != NULL ) { TNEF -> IO . CloseProc ( & TNEF -> IO ) ; } free ( data ) ; return YTNEF_BAD_CHECKSUM ; } for ( i = 0 ; i < ( sizeof ( TNEFList ) / sizeof ( TNEFHandler ) ) ; i ++ ) { if ( TNEFList [ i ] . id == type ) { if ( TNEFList [ i ] . handler != NULL ) { if ( TNEFList [ i ] . handler ( TNEF , i , ( char * ) data , size ) < 0 ) { free ( data ) ; if ( TNEF -> IO . CloseProc != NULL ) { TNEF -> IO . CloseProc ( & TNEF -> IO ) ; } return YTNEF_ERROR_IN_HANDLER ; } else { break ; } } else { DEBUG2 ( TNEF -> Debug , 1 , "No handler for %s: %u bytes" , TNEFList [ i ] . name , size ) ; } } } free ( data ) ; } if ( TNEF -> IO . CloseProc != NULL ) { TNEF -> IO . CloseProc ( & TNEF -> IO ) ; } return 0 ; }
static char * print_array ( cJSON * item , int depth , int fmt ) { char * * entries ; char * out = 0 , * ptr , * ret ; int len = 5 ; cJSON * child = item -> child ; int numentries = 0 , i = 0 , fail = 0 ; while ( child ) { ++ numentries ; child = child -> next ; } if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) return 0 ; memset ( entries , 0 , numentries * sizeof ( char * ) ) ; child = item -> child ; while ( child && ! fail ) { ret = print_value ( child , depth + 1 , fmt ) ; entries [ i ++ ] = ret ; if ( ret ) len += strlen ( ret ) + 2 + ( fmt ? 1 : 0 ) ; else fail = 1 ; child = child -> next ; } if ( ! fail ) { out = ( char * ) cJSON_malloc ( len ) ; if ( ! out ) fail = 1 ; } if ( fail ) { for ( i = 0 ; i < numentries ; ++ i ) if ( entries [ i ] ) cJSON_free ( entries [ i ] ) ; cJSON_free ( entries ) ; return 0 ; } * out = '[' ; ptr = out + 1 ; * ptr = 0 ; for ( i = 0 ; i < numentries ; ++ i ) { strcpy ( ptr , entries [ i ] ) ; ptr += strlen ( entries [ i ] ) ; if ( i != numentries - 1 ) { * ptr ++ = ',' ; if ( fmt ) * ptr ++ = ' ' ; * ptr = 0 ; } cJSON_free ( entries [ i ] ) ; } cJSON_free ( entries ) ; * ptr ++ = ']' ; * ptr ++ = 0 ; return out ; }
nsCxPusher :: Push ( JSContext * cx ) { if ( mPushedSomething ) { NS_ERROR ( "Whaaa! No double pushing with nsCxPusher::Push()!" ) ; return false ; } if ( ! cx ) { return false ; } mScx = GetScriptContextFromJSContext ( cx ) ; return DoPush ( cx ) ; }
void RunInBackground ( ) override { ModuleResult result ; { DisallowHandleAllocation no_handle ; DisallowHeapAllocation no_allocation ; TRACE_COMPILE ( "(1) Decoding module...\n" ) ; result = DecodeWasmModule ( job_ -> enabled_features_ , job_ -> wire_bytes_ . start ( ) , job_ -> wire_bytes_ . end ( ) , false , kWasmOrigin , job_ -> async_counters ( ) . get ( ) , job_ -> isolate ( ) -> wasm_engine ( ) -> allocator ( ) ) ; } if ( result . failed ( ) ) { job_ -> DoSync < DecodeFail > ( std :: move ( result ) ) ; } else { job_ -> DoSync < PrepareAndStartCompile > ( std :: move ( result . val ) , true ) ; } }
ALGnew ( PyObject * self , PyObject * args , PyObject * kwdict ) { unsigned char * key , * IV ; ALGobject * new = NULL ; int keylen , IVlen = 0 , mode = MODE_ECB , segment_size = 0 ; PyObject * counter = NULL ; int counter_shortcut = 0 ; #ifdef PCT_ARC2_MODULE int effective_keylen = 1024 ; #endif if ( ! PyArg_ParseTupleAndKeywords ( args , kwdict , "s#|is#Oi" #ifdef PCT_ARC2_MODULE "i" #endif , kwlist , & key , & keylen , & mode , & IV , & IVlen , & counter , & segment_size #ifdef PCT_ARC2_MODULE , & effective_keylen #endif ) ) { return NULL ; } if ( mode < MODE_ECB || mode > MODE_CTR ) { PyErr_Format ( PyExc_ValueError , "Unknown cipher feedback mode %i" , mode ) ; return NULL ; } if ( mode == MODE_PGP ) { PyErr_Format ( PyExc_ValueError , "MODE_PGP is not supported anymore" ) ; return NULL ; } if ( KEY_SIZE != 0 && keylen != KEY_SIZE ) { PyErr_Format ( PyExc_ValueError , "Key must be %i bytes long, not %i" , KEY_SIZE , keylen ) ; return NULL ; } if ( KEY_SIZE == 0 && keylen == 0 ) { PyErr_SetString ( PyExc_ValueError , "Key cannot be the null string" ) ; return NULL ; } if ( IVlen != BLOCK_SIZE && mode != MODE_ECB && mode != MODE_CTR ) { PyErr_Format ( PyExc_ValueError , "IV must be %i bytes long" , BLOCK_SIZE ) ; return NULL ; } if ( mode == MODE_CFB ) { if ( segment_size == 0 ) segment_size = 8 ; if ( segment_size < 1 || segment_size > BLOCK_SIZE * 8 || ( ( segment_size & 7 ) != 0 ) ) { PyErr_Format ( PyExc_ValueError , "segment_size must be multiple of 8 (bits) " "between 1 and %i" , BLOCK_SIZE * 8 ) ; return NULL ; } } if ( mode == MODE_CTR ) { if ( counter == NULL ) { PyErr_SetString ( PyExc_TypeError , "'counter' keyword parameter is required with CTR mode" ) ; return NULL ; } else if ( Py_TYPE ( counter ) == PCT_CounterBEType || Py_TYPE ( counter ) == PCT_CounterLEType ) { counter_shortcut = 1 ; } else if ( ! PyCallable_Check ( counter ) ) { PyErr_SetString ( PyExc_ValueError , "'counter' parameter must be a callable object" ) ; return NULL ; } } else { if ( counter != NULL ) { PyErr_SetString ( PyExc_ValueError , "'counter' parameter only useful with CTR mode" ) ; return NULL ; } } #ifdef PCT_ARC2_MODULE if ( effective_keylen < 0 || effective_keylen > 1024 ) { PyErr_Format ( PyExc_ValueError , "RC2: effective_keylen must be between 0 and 1024, not %i" , effective_keylen ) ; return NULL ; } #endif new = newALGobject ( ) ; new -> segment_size = segment_size ; new -> counter = counter ; Py_XINCREF ( counter ) ; new -> counter_shortcut = counter_shortcut ; #ifdef PCT_ARC2_MODULE new -> st . effective_keylen = effective_keylen ; #endif block_init ( & ( new -> st ) , key , keylen ) ; if ( PyErr_Occurred ( ) ) { Py_DECREF ( new ) ; return NULL ; } memset ( new -> IV , 0 , BLOCK_SIZE ) ; memset ( new -> oldCipher , 0 , BLOCK_SIZE ) ; memcpy ( new -> IV , IV , IVlen ) ; new -> mode = mode ; new -> count = BLOCK_SIZE ; return new ; }
IGNITION_HANDLER ( DeletePropertyStrict , InterpreterAssembler ) { Node * object = LoadRegisterAtOperandIndex ( 0 ) ; Node * key = GetAccumulator ( ) ; Node * context = GetContext ( ) ; Node * result = CallBuiltin ( Builtins :: kDeleteProperty , context , object , key , SmiConstant ( Smi :: FromEnum ( LanguageMode :: kStrict ) ) ) ; SetAccumulator ( result ) ; Dispatch ( ) ; }
xmlXPathDivValues ( xmlXPathParserContextPtr ctxt ) { xmlXPathObjectPtr arg ; double val ; arg = valuePop ( ctxt ) ; if ( arg == NULL ) XP_ERROR ( XPATH_INVALID_OPERAND ) ; val = xmlXPathCastToNumber ( arg ) ; xmlXPathReleaseObject ( ctxt -> context , arg ) ; CAST_TO_NUMBER ; CHECK_TYPE ( XPATH_NUMBER ) ; if ( xmlXPathIsNaN ( val ) || xmlXPathIsNaN ( ctxt -> value -> floatval ) ) ctxt -> value -> floatval = xmlXPathNAN ; else if ( val == 0 && xmlXPathGetSign ( val ) != 0 ) { if ( ctxt -> value -> floatval == 0 ) ctxt -> value -> floatval = xmlXPathNAN ; else if ( ctxt -> value -> floatval > 0 ) ctxt -> value -> floatval = xmlXPathNINF ; else if ( ctxt -> value -> floatval < 0 ) ctxt -> value -> floatval = xmlXPathPINF ; } else if ( val == 0 ) { if ( ctxt -> value -> floatval == 0 ) ctxt -> value -> floatval = xmlXPathNAN ; else if ( ctxt -> value -> floatval > 0 ) ctxt -> value -> floatval = xmlXPathPINF ; else if ( ctxt -> value -> floatval < 0 ) ctxt -> value -> floatval = xmlXPathNINF ; } else ctxt -> value -> floatval /= val ; }
void * sk_malloc_flags ( size_t size , unsigned flags ) { void * p = malloc ( size ) ; if ( flags & SK_MALLOC_THROW ) { return throw_on_failure ( size , p ) ; } else { return p ; } }
void Parser :: ParseAndRewriteAsyncGeneratorFunctionBody ( int pos , FunctionKind kind , ZonePtrList < Statement > * body , bool * ok ) { DCHECK ( IsAsyncGeneratorFunction ( kind ) ) ; Block * try_block = factory ( ) -> NewBlock ( 3 , false ) ; Expression * initial_yield = BuildInitialYield ( pos , kind ) ; try_block -> statements ( ) -> Add ( factory ( ) -> NewExpressionStatement ( initial_yield , kNoSourcePosition ) , zone ( ) ) ; ParseStatementList ( try_block -> statements ( ) , Token :: RBRACE , ok ) ; if ( ! * ok ) return ; Statement * final_return = BuildReturnStatement ( factory ( ) -> NewUndefinedLiteral ( kNoSourcePosition ) , kNoSourcePosition ) ; try_block -> statements ( ) -> Add ( final_return , zone ( ) ) ; Scope * catch_scope = NewHiddenCatchScope ( ) ; ZonePtrList < Expression > * reject_args = new ( zone ( ) ) ZonePtrList < Expression > ( 2 , zone ( ) ) ; reject_args -> Add ( factory ( ) -> NewVariableProxy ( function_state_ -> scope ( ) -> generator_object_var ( ) ) , zone ( ) ) ; reject_args -> Add ( factory ( ) -> NewVariableProxy ( catch_scope -> catch_variable ( ) ) , zone ( ) ) ; Expression * reject_call = factory ( ) -> NewCallRuntime ( Runtime :: kInlineAsyncGeneratorReject , reject_args , kNoSourcePosition ) ; Block * catch_block = IgnoreCompletion ( factory ( ) -> NewReturnStatement ( reject_call , kNoSourcePosition ) ) ; TryStatement * try_catch = factory ( ) -> NewTryCatchStatementForAsyncAwait ( try_block , catch_scope , catch_block , kNoSourcePosition ) ; try_block = factory ( ) -> NewBlock ( 1 , false ) ; try_block -> statements ( ) -> Add ( try_catch , zone ( ) ) ; Block * finally_block = factory ( ) -> NewBlock ( 1 , false ) ; ZonePtrList < Expression > * close_args = new ( zone ( ) ) ZonePtrList < Expression > ( 1 , zone ( ) ) ; VariableProxy * call_proxy = factory ( ) -> NewVariableProxy ( function_state_ -> scope ( ) -> generator_object_var ( ) ) ; close_args -> Add ( call_proxy , zone ( ) ) ; Expression * close_call = factory ( ) -> NewCallRuntime ( Runtime :: kInlineGeneratorClose , close_args , kNoSourcePosition ) ; finally_block -> statements ( ) -> Add ( factory ( ) -> NewExpressionStatement ( close_call , kNoSourcePosition ) , zone ( ) ) ; body -> Add ( factory ( ) -> NewTryFinallyStatement ( try_block , finally_block , kNoSourcePosition ) , zone ( ) ) ; }
uint8_t ethereum_extractThorchainData ( const EthereumSignTx * msg , char * buffer ) { uint16_t offset = 4 + ( 5 * 32 ) ; int16_t len = msg -> data_length - offset ; if ( msg -> has_data_length && len > 0 ) { memcpy ( buffer , msg -> data_initial_chunk . bytes + offset , len ) ; return len < 256 ? ( uint8_t ) len : 0 ; } return 0 ; }
static void bigben_worker ( struct work_struct * work ) { struct bigben_device * bigben = container_of ( work , struct bigben_device , worker ) ; struct hid_field * report_field = bigben -> report -> field [ 0 ] ; if ( bigben -> removed ) return ; if ( bigben -> work_led ) { bigben -> work_led = false ; report_field -> value [ 0 ] = 0x01 ; report_field -> value [ 1 ] = 0x08 ; report_field -> value [ 2 ] = bigben -> led_state ; report_field -> value [ 3 ] = 0x00 ; report_field -> value [ 4 ] = 0x00 ; report_field -> value [ 5 ] = 0x00 ; report_field -> value [ 6 ] = 0x00 ; report_field -> value [ 7 ] = 0x00 ; hid_hw_request ( bigben -> hid , bigben -> report , HID_REQ_SET_REPORT ) ; } if ( bigben -> work_ff ) { bigben -> work_ff = false ; report_field -> value [ 0 ] = 0x02 ; report_field -> value [ 1 ] = 0x08 ; report_field -> value [ 2 ] = bigben -> right_motor_on ; report_field -> value [ 3 ] = bigben -> left_motor_force ; report_field -> value [ 4 ] = 0xff ; report_field -> value [ 5 ] = 0x00 ; report_field -> value [ 6 ] = 0x00 ; report_field -> value [ 7 ] = 0x00 ; hid_hw_request ( bigben -> hid , bigben -> report , HID_REQ_SET_REPORT ) ; } }
RemoveDir :: Prepare ( ) { int rv = NS_taccess ( mDir , F_OK ) ; if ( rv ) { mSkip = 1 ; mProgressCost = 0 ; return OK ; } LOG ( ( "PREPARE REMOVEDIR " LOG_S "/" , mDir ) ) ; struct NS_tstat_t dirInfo ; rv = NS_tstat ( mDir , & dirInfo ) ; if ( rv ) { LOG ( ( "failed to read directory status info: " LOG_S ", err: %d" , mDir , errno ) ) ; return READ_ERROR ; } if ( ! S_ISDIR ( dirInfo . st_mode ) ) { LOG ( ( "path present, but not a directory: " LOG_S , mDir ) ) ; return DELETE_ERROR_EXPECTED_DIR ; } rv = NS_taccess ( mDir , W_OK ) ; if ( rv ) { LOG ( ( "access failed: %d, %d" , rv , errno ) ) ; return WRITE_ERROR_DIR_ACCESS_DENIED ; } return OK ; }
Node * WasmGraphBuilder :: TraceMemoryOperation ( bool is_store , MachineRepresentation rep , Node * index , uint32_t offset , wasm :: WasmCodePosition position ) { int kAlign = 4 ; Node * info = graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> StackSlot ( sizeof ( wasm :: MemoryTracingInfo ) , kAlign ) ) ; Node * address = graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Int32Add ( ) , Int32Constant ( offset ) , index ) ; auto store = [ & ] ( int offset , MachineRepresentation rep , Node * data ) { SetEffect ( graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Store ( StoreRepresentation ( rep , kNoWriteBarrier ) ) , info , mcgraph ( ) -> Int32Constant ( offset ) , data , Effect ( ) , Control ( ) ) ) ; } ; store ( offsetof ( wasm :: MemoryTracingInfo , address ) , MachineRepresentation :: kWord32 , address ) ; store ( offsetof ( wasm :: MemoryTracingInfo , is_store ) , MachineRepresentation :: kWord8 , mcgraph ( ) -> Int32Constant ( is_store ? 1 : 0 ) ) ; store ( offsetof ( wasm :: MemoryTracingInfo , mem_rep ) , MachineRepresentation :: kWord8 , mcgraph ( ) -> Int32Constant ( static_cast < int > ( rep ) ) ) ; Node * call = BuildCallToRuntime ( Runtime :: kWasmTraceMemory , & info , 1 ) ; SetSourcePosition ( call , position ) ; return call ; }
void MemoryOptimizer :: VisitNode ( Node * node , AllocationState const * state ) { DCHECK ( ! node -> IsDead ( ) ) ; DCHECK_LT ( 0 , node -> op ( ) -> EffectInputCount ( ) ) ; switch ( node -> opcode ( ) ) { case IrOpcode :: kAllocate : UNREACHABLE ( ) ; case IrOpcode :: kAllocateRaw : return VisitAllocateRaw ( node , state ) ; case IrOpcode :: kCall : return VisitCall ( node , state ) ; case IrOpcode :: kCallWithCallerSavedRegisters : return VisitCallWithCallerSavedRegisters ( node , state ) ; case IrOpcode :: kLoadElement : return VisitLoadElement ( node , state ) ; case IrOpcode :: kLoadField : return VisitLoadField ( node , state ) ; case IrOpcode :: kStoreElement : return VisitStoreElement ( node , state ) ; case IrOpcode :: kStoreField : return VisitStoreField ( node , state ) ; case IrOpcode :: kDeoptimizeIf : case IrOpcode :: kDeoptimizeUnless : case IrOpcode :: kIfException : case IrOpcode :: kLoad : case IrOpcode :: kProtectedLoad : case IrOpcode :: kUnalignedLoad : case IrOpcode :: kStore : case IrOpcode :: kProtectedStore : case IrOpcode :: kUnalignedStore : case IrOpcode :: kRetain : case IrOpcode :: kUnsafePointerAdd : case IrOpcode :: kDebugBreak : case IrOpcode :: kUnreachable : case IrOpcode :: kWord32PoisonOnSpeculation : case IrOpcode :: kWord64PoisonOnSpeculation : return VisitOtherEffect ( node , state ) ; default : break ; } DCHECK_EQ ( 0 , node -> op ( ) -> EffectOutputCount ( ) ) ; }
static int mincore_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , struct mm_walk * walk ) { spinlock_t * ptl ; struct vm_area_struct * vma = walk -> vma ; pte_t * ptep ; unsigned char * vec = walk -> private ; int nr = ( end - addr ) > > PAGE_SHIFT ; ptl = pmd_trans_huge_lock ( pmd , vma ) ; if ( ptl ) { memset ( vec , 1 , nr ) ; spin_unlock ( ptl ) ; goto out ; } if ( pmd_trans_unstable ( pmd ) ) { __mincore_unmapped_range ( addr , end , vma , vec ) ; goto out ; } ptep = pte_offset_map_lock ( walk -> mm , pmd , addr , & ptl ) ; for ( ; addr != end ; ptep ++ , addr += PAGE_SIZE ) { pte_t pte = * ptep ; if ( pte_none ( pte ) ) __mincore_unmapped_range ( addr , addr + PAGE_SIZE , vma , vec ) ; else if ( pte_present ( pte ) ) * vec = 1 ; else { swp_entry_t entry = pte_to_swp_entry ( pte ) ; if ( non_swap_entry ( entry ) ) { * vec = 1 ; } else { #ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ; #else WARN_ON ( 1 ) ; * vec = 1 ; #endif } } vec ++ ; } pte_unmap_unlock ( ptep - 1 , ptl ) ; out : walk -> private += nr ; cond_resched ( ) ; return 0 ; }
nsHTTPIndex :: OnStartRequest ( nsIRequest * request , nsISupports * aContext ) { nsresult rv ; mParser = do_CreateInstance ( NS_DIRINDEXPARSER_CONTRACTID , & rv ) ; if ( NS_FAILED ( rv ) ) return rv ; rv = mParser -> SetEncoding ( mEncoding . get ( ) ) ; if ( NS_FAILED ( rv ) ) return rv ; rv = mParser -> SetListener ( this ) ; if ( NS_FAILED ( rv ) ) return rv ; rv = mParser -> OnStartRequest ( request , aContext ) ; if ( NS_FAILED ( rv ) ) return rv ; if ( mBindToGlobalObject && mRequestor ) { mBindToGlobalObject = false ; nsCOMPtr < nsIScriptGlobalObject > scriptGlobal ( do_GetInterface ( mRequestor ) ) ; NS_ENSURE_TRUE ( scriptGlobal , NS_ERROR_FAILURE ) ; nsIScriptContext * context = scriptGlobal -> GetContext ( ) ; NS_ENSURE_TRUE ( context , NS_ERROR_FAILURE ) ; JSContext * cx = context -> GetNativeContext ( ) ; JSObject * global = JS_GetGlobalObject ( cx ) ; static NS_DEFINE_CID ( kXPConnectCID , NS_XPCONNECT_CID ) ; nsCOMPtr < nsIXPConnect > xpc ( do_GetService ( kXPConnectCID , & rv ) ) ; if ( NS_FAILED ( rv ) ) return rv ; nsCOMPtr < nsIXPConnectJSObjectHolder > wrapper ; rv = xpc -> WrapNative ( cx , global , static_cast < nsIHTTPIndex * > ( this ) , NS_GET_IID ( nsIHTTPIndex ) , getter_AddRefs ( wrapper ) ) ; NS_ASSERTION ( NS_SUCCEEDED ( rv ) , "unable to xpconnect-wrap http-index" ) ; if ( NS_FAILED ( rv ) ) return rv ; JSObject * jsobj ; rv = wrapper -> GetJSObject ( & jsobj ) ; NS_ASSERTION ( NS_SUCCEEDED ( rv ) , "unable to get jsobj from xpconnect wrapper" ) ; if ( NS_FAILED ( rv ) ) return rv ; jsval jslistener = OBJECT_TO_JSVAL ( jsobj ) ; JSAutoRequest ar ( cx ) ; bool ok = JS_SetProperty ( cx , global , "HTTPIndex" , & jslistener ) ; NS_ASSERTION ( ok , "unable to set Listener property" ) ; if ( ! ok ) return NS_ERROR_FAILURE ; } if ( ! aContext ) { nsCOMPtr < nsIChannel > channel ( do_QueryInterface ( request ) ) ; NS_ASSERTION ( channel , "request should be a channel" ) ; channel -> SetNotificationCallbacks ( this ) ; nsCOMPtr < nsIURI > uri ; channel -> GetURI ( getter_AddRefs ( uri ) ) ; nsAutoCString entryuriC ; uri -> GetSpec ( entryuriC ) ; nsCOMPtr < nsIRDFResource > entry ; rv = mDirRDF -> GetResource ( entryuriC , getter_AddRefs ( entry ) ) ; NS_ConvertUTF8toUTF16 uriUnicode ( entryuriC ) ; nsCOMPtr < nsIRDFLiteral > URLVal ; rv = mDirRDF -> GetLiteral ( uriUnicode . get ( ) , getter_AddRefs ( URLVal ) ) ; Assert ( entry , kNC_URL , URLVal , true ) ; mDirectory = do_QueryInterface ( entry ) ; } else { mDirectory = do_QueryInterface ( aContext ) ; } if ( ! mDirectory ) { request -> Cancel ( NS_BINDING_ABORTED ) ; return NS_BINDING_ABORTED ; } rv = Assert ( mDirectory , kNC_Loading , kTrueLiteral , true ) ; if ( NS_FAILED ( rv ) ) return rv ; return NS_OK ; }
file_trycdf ( struct magic_set * ms , int fd , const unsigned char * buf , size_t nbytes ) { cdf_info_t info ; cdf_header_t h ; cdf_sat_t sat , ssat ; cdf_stream_t sst , scn ; cdf_dir_t dir ; int i ; const char * expn = "" ; const char * corrupt = "corrupt: " ; info . i_fd = fd ; info . i_buf = buf ; info . i_len = nbytes ; if ( ms -> flags & MAGIC_APPLE ) return 0 ; if ( cdf_read_header ( & info , & h ) == - 1 ) return 0 ; #ifdef CDF_DEBUG cdf_dump_header ( & h ) ; #endif if ( ( i = cdf_read_sat ( & info , & h , & sat ) ) == - 1 ) { expn = "Can't read SAT" ; goto out0 ; } #ifdef CDF_DEBUG cdf_dump_sat ( "SAT" , & sat , CDF_SEC_SIZE ( & h ) ) ; #endif if ( ( i = cdf_read_ssat ( & info , & h , & sat , & ssat ) ) == - 1 ) { expn = "Can't read SSAT" ; goto out1 ; } #ifdef CDF_DEBUG cdf_dump_sat ( "SSAT" , & ssat , CDF_SHORT_SEC_SIZE ( & h ) ) ; #endif if ( ( i = cdf_read_dir ( & info , & h , & sat , & dir ) ) == - 1 ) { expn = "Can't read directory" ; goto out2 ; } const cdf_directory_t * root_storage ; if ( ( i = cdf_read_short_stream ( & info , & h , & sat , & dir , & sst , & root_storage ) ) == - 1 ) { expn = "Cannot read short stream" ; goto out3 ; } #ifdef CDF_DEBUG cdf_dump_dir ( & info , & h , & sat , & ssat , & sst , & dir ) ; #endif #ifdef notdef if ( root_storage ) { if ( NOTMIME ( ms ) ) { char clsbuf [ 128 ] ; if ( file_printf ( ms , "CLSID %s, " , format_clsid ( clsbuf , sizeof ( clsbuf ) , root_storage -> d_storage_uuid ) ) == - 1 ) return - 1 ; } } #endif if ( ( i = cdf_read_summary_info ( & info , & h , & sat , & ssat , & sst , & dir , & scn ) ) == - 1 ) { if ( errno == ESRCH ) { corrupt = expn ; expn = "No summary info" ; } else { expn = "Cannot read summary info" ; } goto out4 ; } #ifdef CDF_DEBUG cdf_dump_summary_info ( & h , & scn ) ; #endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn , root_storage -> d_storage_uuid ) ) < 0 ) expn = "Can't expand summary_info" ; if ( i == 0 ) { const char * str = NULL ; cdf_directory_t * d ; char name [ __arraycount ( d -> d_name ) ] ; size_t j , k ; for ( j = 0 ; str == NULL && j < dir . dir_len ; j ++ ) { d = & dir . dir_tab [ j ] ; for ( k = 0 ; k < sizeof ( name ) ; k ++ ) name [ k ] = ( char ) cdf_tole2 ( d -> d_name [ k ] ) ; str = cdf_app_to_mime ( name , NOTMIME ( ms ) ? name2desc : name2mime ) ; } if ( NOTMIME ( ms ) ) { if ( str != NULL ) { if ( file_printf ( ms , "%s" , str ) == - 1 ) return - 1 ; i = 1 ; } } else { if ( str == NULL ) str = "vnd.ms-office" ; if ( file_printf ( ms , "application/%s" , str ) == - 1 ) return - 1 ; i = 1 ; } } free ( scn . sst_tab ) ; out4 : free ( sst . sst_tab ) ; out3 : free ( dir . dir_tab ) ; out2 : free ( ssat . sat_tab ) ; out1 : free ( sat . sat_tab ) ; out0 : if ( i == - 1 ) { if ( NOTMIME ( ms ) ) { if ( file_printf ( ms , "Composite Document File V2 Document" ) == - 1 ) return - 1 ; if ( * expn ) if ( file_printf ( ms , ", %s%s" , corrupt , expn ) == - 1 ) return - 1 ; } else { if ( file_printf ( ms , "application/CDFV2-corrupt" ) == - 1 ) return - 1 ; } i = 1 ; } return i ; }
BYTE * DecompressRTF ( variableLength * p , int * size ) { BYTE * dst ; BYTE * src ; unsigned int in ; unsigned int out ; variableLength comp_Prebuf ; ULONG compressedSize , uncompressedSize , magic ; comp_Prebuf . size = strlen ( RTF_PREBUF ) ; comp_Prebuf . data = calloc ( comp_Prebuf . size + 1 , 1 ) ; ALLOCCHECK_CHAR ( comp_Prebuf . data ) ; memcpy ( comp_Prebuf . data , RTF_PREBUF , comp_Prebuf . size ) ; src = p -> data ; in = 0 ; if ( p -> size < 20 ) { printf ( "File too small\n" ) ; return ( NULL ) ; } compressedSize = ( ULONG ) SwapDWord ( ( BYTE * ) src + in , 4 ) ; in += 4 ; uncompressedSize = ( ULONG ) SwapDWord ( ( BYTE * ) src + in , 4 ) ; in += 4 ; magic = SwapDWord ( ( BYTE * ) src + in , 4 ) ; in += 4 ; in += 4 ; if ( compressedSize != p -> size - 4 ) { printf ( " Size Mismatch: %u != %i\n" , compressedSize , p -> size - 4 ) ; free ( comp_Prebuf . data ) ; return NULL ; } if ( magic == 0x414c454d ) { dst = calloc ( uncompressedSize , 1 ) ; ALLOCCHECK_CHAR ( dst ) ; memcpy ( dst , src + 4 , uncompressedSize ) ; } else if ( magic == 0x75465a4c ) { int flagCount = 0 ; int flags = 0 ; if ( comp_Prebuf . size >= INT_MAX - uncompressedSize ) { printf ( "Corrupted file\n" ) ; exit ( - 1 ) ; } dst = calloc ( comp_Prebuf . size + uncompressedSize , 1 ) ; ALLOCCHECK_CHAR ( dst ) ; memcpy ( dst , comp_Prebuf . data , comp_Prebuf . size ) ; out = comp_Prebuf . size ; while ( out < ( comp_Prebuf . size + uncompressedSize ) ) { flags = ( flagCount ++ % 8 == 0 ) ? src [ in ++ ] : flags > > 1 ; if ( ( flags & 1 ) == 1 ) { unsigned int offset = src [ in ++ ] ; unsigned int length = src [ in ++ ] ; unsigned int end ; offset = ( offset < < 4 ) | ( length > > 4 ) ; length = ( length & 0xF ) + 2 ; offset = ( out / 4096 ) * 4096 + offset ; if ( offset >= out ) offset -= 4096 ; end = offset + length ; while ( ( offset < end ) && ( out < ( comp_Prebuf . size + uncompressedSize ) ) && ( offset < ( comp_Prebuf . size + uncompressedSize ) ) ) dst [ out ++ ] = dst [ offset ++ ] ; } else { if ( ( out >= ( comp_Prebuf . size + uncompressedSize ) ) || ( in >= p -> size ) ) { printf ( "Corrupted stream\n" ) ; exit ( - 1 ) ; } dst [ out ++ ] = src [ in ++ ] ; } } src = dst ; dst = calloc ( uncompressedSize , 1 ) ; ALLOCCHECK_CHAR ( dst ) ; memcpy ( dst , src + comp_Prebuf . size , uncompressedSize ) ; free ( src ) ; * size = uncompressedSize ; free ( comp_Prebuf . data ) ; return dst ; } else { printf ( "Unknown compression type (magic number %x)\n" , magic ) ; } free ( comp_Prebuf . data ) ; return NULL ; }
nsXMLHttpRequest :: InitParameters ( bool aAnon , bool aSystem ) { if ( ! aAnon && ! aSystem ) { return ; } nsCOMPtr < nsPIDOMWindow > window = do_QueryInterface ( GetOwner ( ) ) ; if ( ! window || ! window -> GetDocShell ( ) ) { return ; } if ( ! nsContentUtils :: IsCallerChrome ( ) ) { nsCOMPtr < nsIDocument > doc = window -> GetExtantDoc ( ) ; if ( ! doc ) { return ; } nsCOMPtr < nsIPrincipal > principal = doc -> NodePrincipal ( ) ; nsCOMPtr < nsIPermissionManager > permMgr = do_GetService ( NS_PERMISSIONMANAGER_CONTRACTID ) ; if ( ! permMgr ) return ; uint32_t permission ; nsresult rv = permMgr -> TestPermissionFromPrincipal ( principal , "systemXHR" , & permission ) ; if ( NS_FAILED ( rv ) || permission != nsIPermissionManager :: ALLOW_ACTION ) { return ; } } SetParameters ( aAnon , aSystem ) ; }
bool OrderedHashTable < Derived , entrysize > :: Delete ( Isolate * isolate , Derived * table , Object * key ) { DisallowHeapAllocation no_gc ; int entry = table -> FindEntry ( isolate , key ) ; if ( entry == kNotFound ) return false ; int nof = table -> NumberOfElements ( ) ; int nod = table -> NumberOfDeletedElements ( ) ; int index = table -> EntryToIndex ( entry ) ; Object * hole = ReadOnlyRoots ( isolate ) . the_hole_value ( ) ; for ( int i = 0 ; i < entrysize ; ++ i ) { table -> set ( index + i , hole ) ; } table -> SetNumberOfElements ( nof - 1 ) ; table -> SetNumberOfDeletedElements ( nod + 1 ) ; return true ; }
Load ( JSContext * cx , unsigned argc , jsval * vp ) { CallArgs args = CallArgsFromVp ( argc , vp ) ; JS :: Rooted < JSObject * > obj ( cx , JS_THIS_OBJECT ( cx , vp ) ) ; if ( ! obj ) return false ; RootedString str ( cx ) ; for ( unsigned i = 0 ; i < args . length ( ) ; i ++ ) { str = ToString ( cx , args [ i ] ) ; if ( ! str ) return false ; JSAutoByteString filename ( cx , str ) ; if ( ! filename ) return false ; FILE * file = fopen ( filename . ptr ( ) , "r" ) ; if ( ! file ) { JS_ReportError ( cx , "cannot open file '%s' for reading" , filename . ptr ( ) ) ; return false ; } JS :: CompileOptions options ( cx ) ; options . setUTF8 ( true ) . setFileAndLine ( filename . ptr ( ) , 1 ) ; JS :: Rooted < JSScript * > script ( cx , JS :: Compile ( cx , obj , options , file ) ) ; fclose ( file ) ; if ( ! script ) return false ; if ( ! compileOnly && ! JS_ExecuteScript ( cx , obj , script ) ) return false ; } args . rval ( ) . setUndefined ( ) ; return true ; }
void RegExpMacroAssemblerX64 :: WriteCurrentPositionToRegister ( int reg , int cp_offset ) { if ( cp_offset == 0 ) { __ movp ( register_location ( reg ) , rdi ) ; } else { __ leap ( rax , Operand ( rdi , cp_offset * char_size ( ) ) ) ; __ movp ( register_location ( reg ) , rax ) ; } }
request_rec * h2_request_create_rec ( const h2_request * req , conn_rec * c ) { int access_status ; #if AP_MODULE_MAGIC_AT_LEAST(20150222, 13) request_rec * r = ap_create_request ( c ) ; #else request_rec * r = my_ap_create_request ( c ) ; #endif #if AP_MODULE_MAGIC_AT_LEAST(20200331, 3) ap_run_pre_read_request ( r , c ) ; r -> request_time = req -> request_time ; r -> the_request = apr_psprintf ( r -> pool , "%s %s HTTP/2.0" , req -> method , req -> path ? req -> path : "" ) ; r -> headers_in = apr_table_clone ( r -> pool , req -> headers ) ; r -> hostname = NULL ; if ( ! ap_parse_request_line ( r ) || ! ap_check_request_header ( r ) ) { r -> per_dir_config = r -> server -> lookup_defaults ; if ( req -> http_status != H2_HTTP_STATUS_UNSET ) { access_status = req -> http_status ; c -> keepalive = AP_CONN_CLOSE ; } else { access_status = r -> status ; } r -> status = HTTP_OK ; goto die ; } #else { const char * s ; r -> headers_in = apr_table_clone ( r -> pool , req -> headers ) ; ap_run_pre_read_request ( r , c ) ; r -> request_time = req -> request_time ; r -> method = apr_pstrdup ( r -> pool , req -> method ) ; r -> method_number = ap_method_number_of ( r -> method ) ; if ( r -> method_number == M_GET && r -> method [ 0 ] == 'H' ) { r -> header_only = 1 ; } ap_parse_uri ( r , req -> path ? req -> path : "" ) ; r -> protocol = ( char * ) "HTTP/2.0" ; r -> proto_num = HTTP_VERSION ( 2 , 0 ) ; r -> the_request = apr_psprintf ( r -> pool , "%s %s HTTP/2.0" , r -> method , req -> path ? req -> path : "" ) ; r -> hostname = NULL ; ap_update_vhost_from_headers ( r ) ; r -> per_dir_config = r -> server -> lookup_defaults ; s = apr_table_get ( r -> headers_in , "Expect" ) ; if ( s && s [ 0 ] ) { if ( ap_cstr_casecmp ( s , "100-continue" ) == 0 ) { r -> expecting_100 = 1 ; } else { r -> status = HTTP_EXPECTATION_FAILED ; access_status = r -> status ; goto die ; } } } #endif r -> per_dir_config = r -> server -> lookup_defaults ; if ( req -> http_status != H2_HTTP_STATUS_UNSET ) { access_status = req -> http_status ; r -> status = HTTP_OK ; c -> keepalive = AP_CONN_CLOSE ; goto die ; } ap_add_input_filter_handle ( ap_http_input_filter_handle , NULL , r , r -> connection ) ; if ( ( access_status = ap_run_post_read_request ( r ) ) ) { ap_log_cerror ( APLOG_MARK , APLOG_DEBUG , 0 , c , APLOGNO ( 03367 ) "h2_request: access_status=%d, request_create failed" , access_status ) ; goto die ; } AP_READ_REQUEST_SUCCESS ( ( uintptr_t ) r , ( char * ) r -> method , ( char * ) r -> uri , ( char * ) r -> server -> defn_name , r -> status ) ; return r ; die : ap_die ( access_status , r ) ; { apr_bucket_brigade * eor_bb ; #if AP_MODULE_MAGIC_AT_LEAST(20180905, 1) eor_bb = ap_acquire_brigade ( c ) ; APR_BRIGADE_INSERT_TAIL ( eor_bb , ap_bucket_eor_create ( c -> bucket_alloc , r ) ) ; ap_pass_brigade ( c -> output_filters , eor_bb ) ; ap_release_brigade ( c , eor_bb ) ; #else eor_bb = apr_brigade_create ( c -> pool , c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( eor_bb , ap_bucket_eor_create ( c -> bucket_alloc , r ) ) ; ap_pass_brigade ( c -> output_filters , eor_bb ) ; apr_brigade_destroy ( eor_bb ) ; #endif } r = NULL ; AP_READ_REQUEST_FAILURE ( ( uintptr_t ) r ) ; return NULL ; }
static struct nlattr * reserve_sfa_size ( struct sw_flow_actions * * sfa , int attr_len , bool log ) { struct sw_flow_actions * acts ; int new_acts_size ; size_t req_size = NLA_ALIGN ( attr_len ) ; int next_offset = offsetof ( struct sw_flow_actions , actions ) + ( * sfa ) -> actions_len ; if ( req_size <= ( ksize ( * sfa ) - next_offset ) ) goto out ; new_acts_size = max ( next_offset + req_size , ksize ( * sfa ) * 2 ) ; if ( new_acts_size > MAX_ACTIONS_BUFSIZE ) { if ( ( MAX_ACTIONS_BUFSIZE - next_offset ) < req_size ) { OVS_NLERR ( log , "Flow action size exceeds max %u" , MAX_ACTIONS_BUFSIZE ) ; return ERR_PTR ( - EMSGSIZE ) ; } new_acts_size = MAX_ACTIONS_BUFSIZE ; } acts = nla_alloc_flow_actions ( new_acts_size ) ; if ( IS_ERR ( acts ) ) return ( void * ) acts ; memcpy ( acts -> actions , ( * sfa ) -> actions , ( * sfa ) -> actions_len ) ; acts -> actions_len = ( * sfa ) -> actions_len ; acts -> orig_len = ( * sfa ) -> orig_len ; kfree ( * sfa ) ; * sfa = acts ; out : ( * sfa ) -> actions_len += req_size ; return ( struct nlattr * ) ( ( unsigned char * ) ( * sfa ) + next_offset ) ; }
void MemoryReducer :: NotifyTimer ( const Event & event ) { DCHECK_EQ ( kTimer , event . type ) ; DCHECK_EQ ( kWait , state_ . action ) ; state_ = Step ( state_ , event ) ; if ( state_ . action == kRun ) { DCHECK ( heap ( ) -> incremental_marking ( ) -> IsStopped ( ) ) ; DCHECK ( FLAG_incremental_marking ) ; if ( FLAG_trace_gc_verbose ) { heap ( ) -> isolate ( ) -> PrintWithTimestamp ( "Memory reducer: started GC #%d\n" , state_ . started_gcs ) ; } heap ( ) -> StartIdleIncrementalMarking ( GarbageCollectionReason :: kMemoryReducer , kGCCallbackFlagCollectAllExternalMemory ) ; } else if ( state_ . action == kWait ) { if ( ! heap ( ) -> incremental_marking ( ) -> IsStopped ( ) && heap ( ) -> ShouldOptimizeForMemoryUsage ( ) ) { const int kIncrementalMarkingDelayMs = 500 ; double deadline = heap ( ) -> MonotonicallyIncreasingTimeInMs ( ) + kIncrementalMarkingDelayMs ; heap ( ) -> incremental_marking ( ) -> AdvanceIncrementalMarking ( deadline , IncrementalMarking :: NO_GC_VIA_STACK_GUARD , StepOrigin :: kTask ) ; heap ( ) -> FinalizeIncrementalMarkingIfComplete ( GarbageCollectionReason :: kFinalizeMarkingViaTask ) ; } ScheduleTimer ( state_ . next_gc_start_ms - event . time_ms ) ; if ( FLAG_trace_gc_verbose ) { heap ( ) -> isolate ( ) -> PrintWithTimestamp ( "Memory reducer: waiting for %.f ms\n" , state_ . next_gc_start_ms - event . time_ms ) ; } } }
static int read_tfra ( MOVContext * mov , AVIOContext * f ) { MOVFragmentIndex * index = NULL ; int version , fieldlength , i , j ; int64_t pos = avio_tell ( f ) ; uint32_t size = avio_rb32 ( f ) ; void * tmp ; if ( avio_rb32 ( f ) != MKBETAG ( 't' , 'f' , 'r' , 'a' ) ) { return 1 ; } av_log ( mov -> fc , AV_LOG_VERBOSE , "found tfra\n" ) ; index = av_mallocz ( sizeof ( MOVFragmentIndex ) ) ; if ( ! index ) { return AVERROR ( ENOMEM ) ; } tmp = av_realloc_array ( mov -> fragment_index_data , mov -> fragment_index_count + 1 , sizeof ( MOVFragmentIndex * ) ) ; if ( ! tmp ) { av_freep ( & index ) ; return AVERROR ( ENOMEM ) ; } mov -> fragment_index_data = tmp ; mov -> fragment_index_data [ mov -> fragment_index_count ++ ] = index ; version = avio_r8 ( f ) ; avio_rb24 ( f ) ; index -> track_id = avio_rb32 ( f ) ; fieldlength = avio_rb32 ( f ) ; index -> item_count = avio_rb32 ( f ) ; index -> items = av_mallocz_array ( index -> item_count , sizeof ( MOVFragmentIndexItem ) ) ; if ( ! index -> items ) { index -> item_count = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < index -> item_count ; i ++ ) { int64_t time , offset ; if ( version == 1 ) { time = avio_rb64 ( f ) ; offset = avio_rb64 ( f ) ; } else { time = avio_rb32 ( f ) ; offset = avio_rb32 ( f ) ; } index -> items [ i ] . time = time ; index -> items [ i ] . moof_offset = offset ; for ( j = 0 ; j < ( ( fieldlength > > 4 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength > > 2 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength > > 0 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; } avio_seek ( f , pos + size , SEEK_SET ) ; return 0 ; }
static vpx_codec_err_t get_param ( vpx_codec_alg_priv_t * ctx , int ctrl_id , va_list args ) { void * arg = va_arg ( args , void * ) ; #define MAP(id, var) case id: *(RECAST(id, arg)) = var; break if ( ! arg ) return VPX_CODEC_INVALID_PARAM ; switch ( ctrl_id ) { MAP ( VP8E_GET_LAST_QUANTIZER , vp8_get_quantizer ( ctx -> cpi ) ) ; MAP ( VP8E_GET_LAST_QUANTIZER_64 , vp8_reverse_trans ( vp8_get_quantizer ( ctx -> cpi ) ) ) ; } return VPX_CODEC_OK ; #undef MAP }
max3421_select_and_start_urb ( struct usb_hcd * hcd ) { struct spi_device * spi = to_spi_device ( hcd -> self . controller ) ; struct max3421_hcd * max3421_hcd = hcd_to_max3421 ( hcd ) ; struct urb * urb , * curr_urb = NULL ; struct max3421_ep * max3421_ep ; int epnum , force_toggles = 0 ; struct usb_host_endpoint * ep ; struct list_head * pos ; unsigned long flags ; spin_lock_irqsave ( & max3421_hcd -> lock , flags ) ; for ( ; max3421_hcd -> sched_pass < SCHED_PASS_DONE ; ++ max3421_hcd -> sched_pass ) list_for_each ( pos , & max3421_hcd -> ep_list ) { urb = NULL ; max3421_ep = container_of ( pos , struct max3421_ep , ep_list ) ; ep = max3421_ep -> ep ; switch ( usb_endpoint_type ( & ep -> desc ) ) { case USB_ENDPOINT_XFER_ISOC : case USB_ENDPOINT_XFER_INT : if ( max3421_hcd -> sched_pass != SCHED_PASS_PERIODIC ) continue ; break ; case USB_ENDPOINT_XFER_CONTROL : case USB_ENDPOINT_XFER_BULK : if ( max3421_hcd -> sched_pass != SCHED_PASS_NON_PERIODIC ) continue ; break ; } if ( list_empty ( & ep -> urb_list ) ) continue ; urb = list_first_entry ( & ep -> urb_list , struct urb , urb_list ) ; if ( urb -> unlinked ) { dev_dbg ( & spi -> dev , "%s: URB %p unlinked=%d" , __func__ , urb , urb -> unlinked ) ; max3421_hcd -> curr_urb = urb ; max3421_hcd -> urb_done = 1 ; spin_unlock_irqrestore ( & max3421_hcd -> lock , flags ) ; return 1 ; } switch ( usb_endpoint_type ( & ep -> desc ) ) { case USB_ENDPOINT_XFER_CONTROL : if ( frame_diff ( max3421_ep -> last_active , max3421_hcd -> frame_number ) == 0 ) continue ; break ; case USB_ENDPOINT_XFER_BULK : if ( max3421_ep -> retransmit && ( frame_diff ( max3421_ep -> last_active , max3421_hcd -> frame_number ) == 0 ) ) continue ; break ; case USB_ENDPOINT_XFER_ISOC : case USB_ENDPOINT_XFER_INT : if ( frame_diff ( max3421_hcd -> frame_number , max3421_ep -> last_active ) < urb -> interval ) continue ; break ; } list_move_tail ( pos , & max3421_hcd -> ep_list ) ; curr_urb = urb ; goto done ; } done : if ( ! curr_urb ) { spin_unlock_irqrestore ( & max3421_hcd -> lock , flags ) ; return 0 ; } urb = max3421_hcd -> curr_urb = curr_urb ; epnum = usb_endpoint_num ( & urb -> ep -> desc ) ; if ( max3421_ep -> retransmit ) max3421_ep -> retransmit = 0 ; else { if ( usb_endpoint_xfer_control ( & ep -> desc ) ) { usb_settoggle ( urb -> dev , epnum , 0 , 1 ) ; usb_settoggle ( urb -> dev , epnum , 1 , 1 ) ; max3421_ep -> pkt_state = PKT_STATE_SETUP ; force_toggles = 1 ; } else max3421_ep -> pkt_state = PKT_STATE_TRANSFER ; } spin_unlock_irqrestore ( & max3421_hcd -> lock , flags ) ; max3421_ep -> last_active = max3421_hcd -> frame_number ; max3421_set_address ( hcd , urb -> dev , epnum , force_toggles ) ; max3421_set_speed ( hcd , urb -> dev ) ; max3421_next_transfer ( hcd , 0 ) ; return 1 ; }
uint32_t virtio_config_readl ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint32_t val ; k -> get_config ( vdev , vdev -> config ) ; if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = ldl_p ( vdev -> config + addr ) ; return val ; }
static TfLiteRegistration DynamicCopyOpRegistration ( ) { TfLiteRegistration reg = { nullptr , nullptr , nullptr , nullptr } ; reg . prepare = [ ] ( TfLiteContext * context , TfLiteNode * node ) { TfLiteTensor * output0 = GetOutput ( context , node , 0 ) ; SetTensorToDynamic ( output0 ) ; const TfLiteTensor * input = GetInput ( context , node , 0 ) ; TfLiteTensor * output1 = GetOutput ( context , node , 1 ) ; TF_LITE_ENSURE_STATUS ( context -> ResizeTensor ( context , output1 , TfLiteIntArrayCopy ( input -> dims ) ) ) ; return kTfLiteOk ; } ; reg . invoke = [ ] ( TfLiteContext * context , TfLiteNode * node ) { return kTfLiteOk ; } ; return reg ; }
parse_netscreen_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { int sec ; int dsec ; char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; char direction [ 2 ] ; guint pkt_len ; char cap_src [ 13 ] ; char cap_dst [ 13 ] ; guint8 * pd ; gchar * p ; int n , i = 0 ; guint offset = 0 ; gchar dststr [ 13 ] ; phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; if ( sscanf ( line , "%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/" , & sec , & dsec , cap_int , direction , & pkt_len , cap_src , cap_dst ) < 5 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen: Can't parse packet-header" ) ; return - 1 ; } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "netscreen: File has %u-byte packet, bigger than maximum of %u" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> ts . secs = sec ; phdr -> ts . nsecs = dsec * 100000000 ; phdr -> len = pkt_len ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; while ( 1 ) { if ( file_gets ( line , NETSCREEN_LINE_LENGTH , fh ) == NULL ) { break ; } for ( p = & line [ 0 ] ; g_ascii_isspace ( * p ) ; p ++ ) ; if ( * p == '\0' ) { break ; } n = parse_single_hex_dump_line ( p , pd , offset ) ; if ( offset == 0 && n < 6 ) { if ( info_line ( line ) ) { if ( ++ i <= NETSCREEN_MAX_INFOLINES ) { continue ; } } else { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen: cannot parse hex-data" ) ; return FALSE ; } } if ( n == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen: cannot parse hex-data" ) ; return FALSE ; } offset += n ; if ( offset > pkt_len ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen: too much hex-data" ) ; return FALSE ; } } if ( strncmp ( cap_int , "adsl" , 4 ) == 0 ) { g_snprintf ( dststr , 13 , "%02x%02x%02x%02x%02x%02x" , pd [ 0 ] , pd [ 1 ] , pd [ 2 ] , pd [ 3 ] , pd [ 4 ] , pd [ 5 ] ) ; if ( strncmp ( dststr , cap_dst , 12 ) == 0 ) phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; else phdr -> pkt_encap = WTAP_ENCAP_PPP ; } else if ( strncmp ( cap_int , "seri" , 4 ) == 0 ) phdr -> pkt_encap = WTAP_ENCAP_PPP ; else phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; phdr -> caplen = offset ; return TRUE ; }
Handle < JSModuleNamespace > Factory :: NewJSModuleNamespace ( ) { Handle < Map > map = isolate ( ) -> js_module_namespace_map ( ) ; Handle < JSModuleNamespace > module_namespace ( Handle < JSModuleNamespace > :: cast ( NewJSObjectFromMap ( map ) ) ) ; FieldIndex index = FieldIndex :: ForDescriptor ( * map , JSModuleNamespace :: kToStringTagFieldIndex ) ; module_namespace -> FastPropertyAtPut ( index , ReadOnlyRoots ( isolate ( ) ) . Module_string ( ) ) ; return module_namespace ; }
htcp_alpha_update ( struct htcp * ca ) { uint32_t minRTT = ca -> minRTT ; uint32_t factor = 1 ; uint32_t diff = htcp_cong_time ( ca ) ; if ( diff > ( uint32_t ) hz ) { diff -= hz ; factor = 1 + ( 10 * diff + ( ( diff / 2 ) * ( diff / 2 ) / hz ) ) / hz ; } if ( use_rtt_scaling && minRTT ) { uint32_t scale = ( hz < < 3 ) / ( 10 * minRTT ) ; scale = min ( max ( scale , 1U < < 2 ) , 10U < < 3 ) ; factor = ( factor < < 3 ) / scale ; if ( ! factor ) factor = 1 ; } ca -> alpha = 2 * factor * ( ( 1 < < 7 ) - ca -> beta ) ; if ( ! ca -> alpha ) ca -> alpha = ALPHA_BASE ; }
} } if ( resource != ( char * ) NULL ) resource = DestroyString ( resource ) ; return ( status ) ; } static inline signed int ReadPropertySignedLong ( const EndianType endian , const unsigned char * buffer ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; unsigned int value ; if ( endian == LSBEndian ) { value = ( unsigned int ) ( ( buffer [ 3 ] < < 24 ) | ( buffer [ 2 ] < < 16 ) | ( buffer [ 1 ] < < 8 ) | ( buffer [ 0 ] ) ) ; quantum . unsigned_value = ( value & 0xffffffff ) ;
status_t BufferQueueLayer :: setDefaultBufferProperties ( uint32_t w , uint32_t h , PixelFormat format ) { uint32_t const maxSurfaceDims = std :: min ( mFlinger -> getMaxTextureSize ( ) , mFlinger -> getMaxViewportDims ( ) ) ; if ( ( uint32_t ( w ) > maxSurfaceDims ) || ( uint32_t ( h ) > maxSurfaceDims ) ) { ALOGE ( "dimensions too large %u x %u" , uint32_t ( w ) , uint32_t ( h ) ) ; return BAD_VALUE ; } setDefaultBufferSize ( w , h ) ; mConsumer -> setDefaultBufferFormat ( format ) ; mConsumer -> setConsumerUsageBits ( getEffectiveUsage ( 0 ) ) ; return NO_ERROR ; }
ISurfaceAllocator :: AllocSurfaceDescriptorWithCaps ( const gfx :: IntSize & aSize , gfxContentType aContent , uint32_t aCaps , SurfaceDescriptor * aBuffer ) { gfx :: SurfaceFormat format = gfxPlatform :: GetPlatform ( ) -> Optimal2DFormatForContent ( aContent ) ; size_t size = ImageDataSerializer :: ComputeMinBufferSize ( aSize , format ) ; if ( ! size ) { return false ; } if ( IsSameProcess ( ) ) { uint8_t * data = new ( std :: nothrow ) uint8_t [ size ] ; if ( ! data ) { return false ; } GfxMemoryImageReporter :: DidAlloc ( data ) ; #ifdef XP_MACOSX if ( format == gfx :: SurfaceFormat :: A8 ) { memset ( data , 0 , size ) ; } #endif * aBuffer = SurfaceDescriptorMemory ( ( uintptr_t ) data , format ) ; } else { mozilla :: ipc :: SharedMemory :: SharedMemoryType shmemType = OptimalShmemType ( ) ; mozilla :: ipc :: Shmem shmem ; if ( ! AllocUnsafeShmem ( size , shmemType , & shmem ) ) { return false ; } * aBuffer = SurfaceDescriptorShmem ( shmem , format ) ; } uint8_t * data = GetAddressFromDescriptor ( * aBuffer , size ) ; ImageDataSerializer serializer ( data , size ) ; serializer . InitializeBufferInfo ( aSize , format ) ; return true ; }
void V8Debugger :: collectOldAsyncStacksIfNeeded ( ) { if ( m_asyncStacksCount <= m_maxAsyncCallStacks ) return ; int halfOfLimitRoundedUp = m_maxAsyncCallStacks / 2 + m_maxAsyncCallStacks % 2 ; while ( m_asyncStacksCount > halfOfLimitRoundedUp ) { m_allAsyncStacks . pop_front ( ) ; -- m_asyncStacksCount ; } cleanupExpiredWeakPointers ( m_asyncTaskStacks ) ; cleanupExpiredWeakPointers ( m_storedStackTraces ) ; for ( auto it = m_recurringTasks . begin ( ) ; it != m_recurringTasks . end ( ) ; ) { if ( m_asyncTaskStacks . find ( * it ) == m_asyncTaskStacks . end ( ) ) { it = m_recurringTasks . erase ( it ) ; } else { ++ it ; } } cleanupExpiredWeakPointers ( m_framesCache ) ; }
static int gup_huge_pmd ( pmd_t orig , pmd_t * pmdp , unsigned long addr , unsigned long end , int write , struct page * * pages , int * nr ) { struct page * head , * page ; int refs ; if ( ! pmd_access_permitted ( orig , write ) ) return 0 ; if ( pmd_devmap ( orig ) ) return __gup_device_huge_pmd ( orig , pmdp , addr , end , pages , nr ) ; refs = 0 ; page = pmd_page ( orig ) + ( ( addr & ~ PMD_MASK ) > > PAGE_SHIFT ) ; do { pages [ * nr ] = page ; ( * nr ) ++ ; page ++ ; refs ++ ; } while ( addr += PAGE_SIZE , addr != end ) ; head = compound_head ( pmd_page ( orig ) ) ; if ( ! page_cache_add_speculative ( head , refs ) ) { * nr -= refs ; return 0 ; } if ( unlikely ( pmd_val ( orig ) != pmd_val ( * pmdp ) ) ) { * nr -= refs ; while ( refs -- ) put_page ( head ) ; return 0 ; } SetPageReferenced ( head ) ; return 1 ; }
static void initialize_typed_array_from_array_buffer ( GlobalObject & global_object , TypedArrayBase & typed_array , ArrayBuffer & array_buffer , Value byte_offset , Value length ) { auto & vm = global_object . vm ( ) ; auto element_size = typed_array . element_size ( ) ; auto offset = byte_offset . to_index ( global_object ) ; if ( vm . exception ( ) ) return ; if ( offset % element_size != 0 ) { vm . throw_exception < RangeError > ( global_object , ErrorType :: TypedArrayInvalidByteOffset , typed_array . class_name ( ) , element_size , offset ) ; return ; } size_t new_length { 0 } ; if ( ! length . is_undefined ( ) ) { new_length = length . to_index ( global_object ) ; if ( vm . exception ( ) ) return ; } auto buffer_byte_length = array_buffer . byte_length ( ) ; size_t new_byte_length ; if ( length . is_undefined ( ) ) { if ( buffer_byte_length % element_size != 0 ) { vm . throw_exception < RangeError > ( global_object , ErrorType :: TypedArrayInvalidBufferLength , typed_array . class_name ( ) , element_size , buffer_byte_length ) ; return ; } if ( offset > buffer_byte_length ) { vm . throw_exception < RangeError > ( global_object , ErrorType :: TypedArrayOutOfRangeByteOffset , offset , buffer_byte_length ) ; return ; } new_byte_length = buffer_byte_length - offset ; } else { new_byte_length = new_length * element_size ; if ( offset + new_byte_length > buffer_byte_length ) { vm . throw_exception < RangeError > ( global_object , ErrorType :: TypedArrayOutOfRangeByteOffsetOrLength , offset , offset + new_byte_length , buffer_byte_length ) ; return ; } } typed_array . set_viewed_array_buffer ( & array_buffer ) ; typed_array . set_byte_length ( new_byte_length ) ; typed_array . set_byte_offset ( offset ) ; typed_array . set_array_length ( new_byte_length / element_size ) ; }
nsDocShell :: LoadErrorPage ( nsIURI * aURI , const char16_t * aURL , const char * aErrorPage , const char16_t * aErrorType , const char16_t * aDescription , const char * aCSSClass , nsIChannel * aFailedChannel ) { #if defined(DEBUG) if ( MOZ_LOG_TEST ( gDocShellLog , LogLevel :: Debug ) ) { nsAutoCString spec ; aURI -> GetSpec ( spec ) ; nsAutoCString chanName ; if ( aFailedChannel ) { aFailedChannel -> GetName ( chanName ) ; } else { chanName . AssignLiteral ( "<no channel>" ) ; } MOZ_LOG ( gDocShellLog , LogLevel :: Debug , ( "nsDocShell[%p]::LoadErrorPage(\"%s\", \"%s\", {...}, [%s])\n" , this , spec . get ( ) , NS_ConvertUTF16toUTF8 ( aURL ) . get ( ) , chanName . get ( ) ) ) ; } #endif mFailedChannel = aFailedChannel ; mFailedURI = aURI ; mFailedLoadType = mLoadType ; if ( mLSHE ) { mLSHE -> AbandonBFCacheEntry ( ) ; } nsAutoCString url ; nsAutoCString charset ; if ( aURI ) { nsresult rv = aURI -> GetSpec ( url ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aURI -> GetOriginCharset ( charset ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } else if ( aURL ) { CopyUTF16toUTF8 ( aURL , url ) ; } else { return NS_ERROR_INVALID_POINTER ; } #undef SAFE_ESCAPE #define SAFE_ESCAPE(cstring, escArg1, escArg2)                                 \   {                                                                            \     char* s = nsEscape(escArg1, escArg2);                                      \     if (!s)                                                                    \       return NS_ERROR_OUT_OF_MEMORY;                                           \     cstring.Adopt(s);                                                          \   } nsCString escapedUrl , escapedCharset , escapedError , escapedDescription , escapedCSSClass ; SAFE_ESCAPE ( escapedUrl , url . get ( ) , url_Path ) ; SAFE_ESCAPE ( escapedCharset , charset . get ( ) , url_Path ) ; SAFE_ESCAPE ( escapedError , NS_ConvertUTF16toUTF8 ( aErrorType ) . get ( ) , url_Path ) ; SAFE_ESCAPE ( escapedDescription , NS_ConvertUTF16toUTF8 ( aDescription ) . get ( ) , url_Path ) ; if ( aCSSClass ) { SAFE_ESCAPE ( escapedCSSClass , aCSSClass , url_Path ) ; } nsCString errorPageUrl ( "about:" ) ; errorPageUrl . AppendASCII ( aErrorPage ) ; errorPageUrl . AppendLiteral ( "?e=" ) ; errorPageUrl . AppendASCII ( escapedError . get ( ) ) ; errorPageUrl . AppendLiteral ( "&u=" ) ; errorPageUrl . AppendASCII ( escapedUrl . get ( ) ) ; if ( ! escapedCSSClass . IsEmpty ( ) ) { errorPageUrl . AppendLiteral ( "&s=" ) ; errorPageUrl . AppendASCII ( escapedCSSClass . get ( ) ) ; } errorPageUrl . AppendLiteral ( "&c=" ) ; errorPageUrl . AppendASCII ( escapedCharset . get ( ) ) ; nsAutoCString frameType ( FrameTypeToString ( mFrameType ) ) ; errorPageUrl . AppendLiteral ( "&f=" ) ; errorPageUrl . AppendASCII ( frameType . get ( ) ) ; nsString manifestURL ; nsresult rv = GetAppManifestURL ( manifestURL ) ; if ( manifestURL . Length ( ) > 0 ) { nsCString manifestParam ; SAFE_ESCAPE ( manifestParam , NS_ConvertUTF16toUTF8 ( manifestURL ) . get ( ) , url_Path ) ; errorPageUrl . AppendLiteral ( "&m=" ) ; errorPageUrl . AppendASCII ( manifestParam . get ( ) ) ; } errorPageUrl . AppendLiteral ( "&d=" ) ; errorPageUrl . AppendASCII ( escapedDescription . get ( ) ) ; nsCOMPtr < nsIURI > errorPageURI ; rv = NS_NewURI ( getter_AddRefs ( errorPageURI ) , errorPageUrl ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; return InternalLoad ( errorPageURI , nullptr , mozilla :: net :: RP_Default , nullptr , INTERNAL_LOAD_FLAGS_INHERIT_OWNER , nullptr , nullptr , NullString ( ) , nullptr , nullptr , LOAD_ERROR_PAGE , nullptr , true , NullString ( ) , this , nullptr , nullptr , nullptr ) ; }
static long ec_device_ioctl_xcmd ( struct cros_ec_dev * ec , void __user * arg ) { long ret ; struct cros_ec_command u_cmd ; struct cros_ec_command * s_cmd ; if ( copy_from_user ( & u_cmd , arg , sizeof ( u_cmd ) ) ) return - EFAULT ; if ( ( u_cmd . outsize > EC_MAX_MSG_BYTES ) || ( u_cmd . insize > EC_MAX_MSG_BYTES ) ) return - EINVAL ; s_cmd = kmalloc ( sizeof ( * s_cmd ) + max ( u_cmd . outsize , u_cmd . insize ) , GFP_KERNEL ) ; if ( ! s_cmd ) return - ENOMEM ; if ( copy_from_user ( s_cmd , arg , sizeof ( * s_cmd ) + u_cmd . outsize ) ) { ret = - EFAULT ; goto exit ; } s_cmd -> command += ec -> cmd_offset ; ret = cros_ec_cmd_xfer ( ec -> ec_dev , s_cmd ) ; if ( ret < 0 ) goto exit ; if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + u_cmd . insize ) ) ret = - EFAULT ; exit : kfree ( s_cmd ) ; return ret ; }
xfs_attr_shortform_list ( xfs_attr_list_context_t * context ) { attrlist_cursor_kern_t * cursor ; xfs_attr_sf_sort_t * sbuf , * sbp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_inode_t * dp ; int sbsize , nsbuf , count , i ; int error ; ASSERT ( context != NULL ) ; dp = context -> dp ; ASSERT ( dp != NULL ) ; ASSERT ( dp -> i_afp != NULL ) ; sf = ( xfs_attr_shortform_t * ) dp -> i_afp -> if_u1 . if_data ; ASSERT ( sf != NULL ) ; if ( ! sf -> hdr . count ) return 0 ; cursor = context -> cursor ; ASSERT ( cursor != NULL ) ; trace_xfs_attr_list_sf ( context ) ; if ( context -> bufsize == 0 || ( XFS_ISRESET_CURSOR ( cursor ) && ( dp -> i_afp -> if_bytes + sf -> hdr . count * 16 ) < context -> bufsize ) ) { for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { error = context -> put_listent ( context , sfe -> flags , sfe -> nameval , ( int ) sfe -> namelen , ( int ) sfe -> valuelen , & sfe -> nameval [ sfe -> namelen ] ) ; if ( context -> seen_enough ) break ; if ( error ) return error ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } trace_xfs_attr_list_sf_all ( context ) ; return 0 ; } if ( context -> bufsize == 0 ) return 0 ; sbsize = sf -> hdr . count * sizeof ( * sbuf ) ; sbp = sbuf = kmem_alloc ( sbsize , KM_SLEEP | KM_NOFS ) ; nsbuf = 0 ; for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { if ( unlikely ( ( ( char * ) sfe < ( char * ) sf ) || ( ( char * ) sfe >= ( ( char * ) sf + dp -> i_afp -> if_bytes ) ) ) ) { XFS_CORRUPTION_ERROR ( "xfs_attr_shortform_list" , XFS_ERRLEVEL_LOW , context -> dp -> i_mount , sfe ) ; kmem_free ( sbuf ) ; return - EFSCORRUPTED ; } sbp -> entno = i ; sbp -> hash = xfs_da_hashname ( sfe -> nameval , sfe -> namelen ) ; sbp -> name = sfe -> nameval ; sbp -> namelen = sfe -> namelen ; sbp -> valuelen = sfe -> valuelen ; sbp -> flags = sfe -> flags ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; sbp ++ ; nsbuf ++ ; } xfs_sort ( sbuf , nsbuf , sizeof ( * sbuf ) , xfs_attr_shortform_compare ) ; count = 0 ; cursor -> initted = 1 ; cursor -> blkno = 0 ; for ( sbp = sbuf , i = 0 ; i < nsbuf ; i ++ , sbp ++ ) { if ( sbp -> hash == cursor -> hashval ) { if ( cursor -> offset == count ) { break ; } count ++ ; } else if ( sbp -> hash > cursor -> hashval ) { break ; } } if ( i == nsbuf ) { kmem_free ( sbuf ) ; return 0 ; } for ( ; i < nsbuf ; i ++ , sbp ++ ) { if ( cursor -> hashval != sbp -> hash ) { cursor -> hashval = sbp -> hash ; cursor -> offset = 0 ; } error = context -> put_listent ( context , sbp -> flags , sbp -> name , sbp -> namelen , sbp -> valuelen , & sbp -> name [ sbp -> namelen ] ) ; if ( error ) return error ; if ( context -> seen_enough ) break ; cursor -> offset ++ ; } kmem_free ( sbuf ) ; return 0 ; }
static int inotify_cb ( int fd , __unused uint32_t epevents ) { if ( g_saved_input_cb == nullptr ) return - 1 ; int event_len_int ; int ret = ioctl ( fd , FIONREAD , & event_len_int ) ; if ( ret != 0 ) return - 1 ; if ( event_len_int < 0 ) return - 1 ; size_t event_len = event_len_int ; std :: unique_ptr < DIR , decltype ( & closedir ) > dir ( opendir ( INPUT_DEV_DIR ) , closedir ) ; if ( ! dir ) { return - 1 ; } std :: vector < int8_t > buf ( event_len ) ; ssize_t r = TEMP_FAILURE_RETRY ( read ( fd , buf . data ( ) , event_len ) ) ; if ( r != event_len ) { return - 1 ; } size_t offset = 0 ; while ( offset < event_len ) { struct inotify_event * pevent = reinterpret_cast < struct inotify_event * > ( buf . data ( ) + offset ) ; if ( offset + sizeof ( inotify_event ) + pevent -> len > event_len ) { return - 1 ; } offset += sizeof ( inotify_event ) + pevent -> len ; pevent -> name [ pevent -> len ] = '\0' ; if ( strncmp ( pevent -> name , "event" , 5 ) ) { continue ; } android :: base :: unique_fd dfd ( openat ( dirfd ( dir . get ( ) ) , pevent -> name , O_RDONLY ) ) ; if ( dfd == - 1 ) { break ; } if ( ! should_add_input_device ( dfd , g_allow_touch_inputs ) ) { continue ; } ev_add_fd ( std :: move ( dfd ) , g_saved_input_cb ) ; } return 0 ; }
void DeleteDictionaryProperty ( TNode < Object > receiver , TNode < NameDictionary > properties , TNode < Name > name , TNode < Context > context , Label * dont_delete , Label * notfound ) { TVARIABLE ( IntPtrT , var_name_index ) ; Label dictionary_found ( this , & var_name_index ) ; NameDictionaryLookup < NameDictionary > ( properties , name , & dictionary_found , & var_name_index , notfound ) ; BIND ( & dictionary_found ) ; TNode < IntPtrT > key_index = var_name_index . value ( ) ; TNode < Uint32T > details = LoadDetailsByKeyIndex < NameDictionary > ( properties , key_index ) ; GotoIf ( IsSetWord32 ( details , PropertyDetails :: kAttributesDontDeleteMask ) , dont_delete ) ; TNode < HeapObject > filler = TheHoleConstant ( ) ; DCHECK ( Heap :: RootIsImmortalImmovable ( Heap :: kTheHoleValueRootIndex ) ) ; StoreFixedArrayElement ( properties , key_index , filler , SKIP_WRITE_BARRIER ) ; StoreValueByKeyIndex < NameDictionary > ( properties , key_index , filler , SKIP_WRITE_BARRIER ) ; StoreDetailsByKeyIndex < NameDictionary > ( properties , key_index , SmiConstant ( 0 ) ) ; TNode < Smi > nof = GetNumberOfElements < NameDictionary > ( properties ) ; TNode < Smi > new_nof = SmiSub ( nof , SmiConstant ( 1 ) ) ; SetNumberOfElements < NameDictionary > ( properties , new_nof ) ; TNode < Smi > num_deleted = GetNumberOfDeletedElements < NameDictionary > ( properties ) ; TNode < Smi > new_deleted = SmiAdd ( num_deleted , SmiConstant ( 1 ) ) ; SetNumberOfDeletedElements < NameDictionary > ( properties , new_deleted ) ; Label shrinking_done ( this ) ; TNode < Smi > capacity = GetCapacity < NameDictionary > ( properties ) ; GotoIf ( SmiGreaterThan ( new_nof , SmiShr ( capacity , 2 ) ) , & shrinking_done ) ; GotoIf ( SmiLessThan ( new_nof , SmiConstant ( 16 ) ) , & shrinking_done ) ; CallRuntime ( Runtime :: kShrinkPropertyDictionary , context , receiver ) ; Goto ( & shrinking_done ) ; BIND ( & shrinking_done ) ; Return ( TrueConstant ( ) ) ; }
static void yuvconfig2image ( vpx_image_t * img , const YV12_BUFFER_CONFIG * yv12 , void * user_priv ) { img -> fmt = VPX_IMG_FMT_I420 ; img -> w = yv12 -> y_stride ; img -> h = ( yv12 -> y_height + 2 * VP8BORDERINPIXELS + 15 ) & ~ 15 ; img -> d_w = yv12 -> y_width ; img -> d_h = yv12 -> y_height ; img -> x_chroma_shift = 1 ; img -> y_chroma_shift = 1 ; img -> planes [ VPX_PLANE_Y ] = yv12 -> y_buffer ; img -> planes [ VPX_PLANE_U ] = yv12 -> u_buffer ; img -> planes [ VPX_PLANE_V ] = yv12 -> v_buffer ; img -> planes [ VPX_PLANE_ALPHA ] = NULL ; img -> stride [ VPX_PLANE_Y ] = yv12 -> y_stride ; img -> stride [ VPX_PLANE_U ] = yv12 -> uv_stride ; img -> stride [ VPX_PLANE_V ] = yv12 -> uv_stride ; img -> stride [ VPX_PLANE_ALPHA ] = yv12 -> y_stride ; img -> bps = 12 ; img -> user_priv = user_priv ; img -> img_data = yv12 -> buffer_alloc ; img -> img_data_owner = 0 ; img -> self_allocd = 0 ; }
Reduction JSCallReducer :: ReduceSoftDeoptimize ( Node * node , DeoptimizeReason reason ) { Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; Node * frame_state = NodeProperties :: FindFrameStateBefore ( node ) ; Node * deoptimize = graph ( ) -> NewNode ( common ( ) -> Deoptimize ( DeoptimizeKind :: kSoft , reason , VectorSlotPair ( ) ) , frame_state , effect , control ) ; NodeProperties :: MergeControlToEnd ( graph ( ) , common ( ) , deoptimize ) ; Revisit ( graph ( ) -> end ( ) ) ; node -> TrimInputCount ( 0 ) ; NodeProperties :: ChangeOp ( node , common ( ) -> Dead ( ) ) ; return Changed ( node ) ; }
spnego_gss_delete_sec_context ( OM_uint32 * minor_status , gss_ctx_id_t * context_handle , gss_buffer_t output_token ) { OM_uint32 ret = GSS_S_COMPLETE ; spnego_gss_ctx_id_t * ctx = ( spnego_gss_ctx_id_t * ) context_handle ; * minor_status = 0 ; if ( context_handle == NULL ) return ( GSS_S_FAILURE ) ; if ( * ctx == NULL ) return ( GSS_S_COMPLETE ) ; if ( ( * ctx ) -> magic_num == SPNEGO_MAGIC_ID ) { ( void ) gss_delete_sec_context ( minor_status , & ( * ctx ) -> ctx_handle , output_token ) ; ( void ) release_spnego_ctx ( ctx ) ; } else { ret = gss_delete_sec_context ( minor_status , context_handle , output_token ) ; } return ( ret ) ; }
bool FramingChecker :: CheckFrameOptions ( nsIChannel * aChannel , nsIContentSecurityPolicy * aCsp ) { MOZ_ASSERT ( XRE_IsParentProcess ( ) , "check frame options only in parent" ) ; if ( ! aChannel ) { return true ; } nsCOMPtr < nsILoadInfo > loadInfo = aChannel -> LoadInfo ( ) ; nsContentPolicyType contentType = loadInfo -> GetExternalContentPolicyType ( ) ; if ( contentType != nsIContentPolicy :: TYPE_SUBDOCUMENT && contentType != nsIContentPolicy :: TYPE_OBJECT ) { return true ; } if ( ShouldIgnoreFrameOptions ( aChannel , aCsp ) ) { return true ; } nsCOMPtr < nsIHttpChannel > httpChannel ; nsresult rv = nsContentSecurityUtils :: GetHttpChannelFromPotentialMultiPart ( aChannel , getter_AddRefs ( httpChannel ) ) ; if ( NS_WARN_IF ( NS_FAILED ( rv ) ) ) { return true ; } if ( ! httpChannel ) { return true ; } uint32_t responseStatus ; rv = httpChannel -> GetResponseStatus ( & responseStatus ) ; if ( NS_WARN_IF ( NS_FAILED ( rv ) ) ) { return true ; } if ( mozilla :: net :: nsHttpChannel :: IsRedirectStatus ( responseStatus ) ) { return true ; } nsAutoCString xfoHeaderCValue ; Unused < < httpChannel -> GetResponseHeader ( NS_LITERAL_CSTRING ( "X-Frame-Options" ) , xfoHeaderCValue ) ; NS_ConvertUTF8toUTF16 xfoHeaderValue ( xfoHeaderCValue ) ; if ( xfoHeaderValue . IsEmpty ( ) ) { return true ; } nsCharSeparatedTokenizer tokenizer ( xfoHeaderValue , ',' ) ; while ( tokenizer . hasMoreTokens ( ) ) { const nsAString & tok = tokenizer . nextToken ( ) ; if ( ! CheckOneFrameOptionsPolicy ( httpChannel , tok ) ) { nsCOMPtr < nsIURI > uri ; httpChannel -> GetURI ( getter_AddRefs ( uri ) ) ; nsCOMPtr < nsIObserverService > observerService = mozilla :: services :: GetObserverService ( ) ; nsAutoString policy ( tok ) ; observerService -> NotifyObservers ( uri , "xfo-on-violate-policy" , policy . get ( ) ) ; return false ; } } return true ; }
static MarFile * mar_fpopen ( FILE * fp ) { MarFile * mar ; mar = ( MarFile * ) malloc ( sizeof ( * mar ) ) ; if ( ! mar ) { fclose ( fp ) ; return NULL ; } mar -> fp = fp ; memset ( mar -> item_table , 0 , sizeof ( mar -> item_table ) ) ; if ( mar_read_index ( mar ) ) { mar_close ( mar ) ; return NULL ; } return mar ; }
Reduction JSCreateLowering :: Reduce ( Node * node ) { DisallowHeapAccess disallow_heap_access ; switch ( node -> opcode ( ) ) { case IrOpcode :: kJSCreate : return ReduceJSCreate ( node ) ; case IrOpcode :: kJSCreateArguments : return ReduceJSCreateArguments ( node ) ; case IrOpcode :: kJSCreateArray : return ReduceJSCreateArray ( node ) ; case IrOpcode :: kJSCreateArrayIterator : return ReduceJSCreateArrayIterator ( node ) ; case IrOpcode :: kJSCreateBoundFunction : return ReduceJSCreateBoundFunction ( node ) ; case IrOpcode :: kJSCreateClosure : return ReduceJSCreateClosure ( node ) ; case IrOpcode :: kJSCreateCollectionIterator : return ReduceJSCreateCollectionIterator ( node ) ; case IrOpcode :: kJSCreateIterResultObject : return ReduceJSCreateIterResultObject ( node ) ; case IrOpcode :: kJSCreateStringIterator : return ReduceJSCreateStringIterator ( node ) ; case IrOpcode :: kJSCreateKeyValueArray : return ReduceJSCreateKeyValueArray ( node ) ; case IrOpcode :: kJSCreatePromise : return ReduceJSCreatePromise ( node ) ; case IrOpcode :: kJSCreateLiteralArray : case IrOpcode :: kJSCreateLiteralObject : return ReduceJSCreateLiteralArrayOrObject ( node ) ; case IrOpcode :: kJSCreateLiteralRegExp : return ReduceJSCreateLiteralRegExp ( node ) ; case IrOpcode :: kJSCreateEmptyLiteralArray : return ReduceJSCreateEmptyLiteralArray ( node ) ; case IrOpcode :: kJSCreateEmptyLiteralObject : return ReduceJSCreateEmptyLiteralObject ( node ) ; case IrOpcode :: kJSCreateFunctionContext : return ReduceJSCreateFunctionContext ( node ) ; case IrOpcode :: kJSCreateWithContext : return ReduceJSCreateWithContext ( node ) ; case IrOpcode :: kJSCreateCatchContext : return ReduceJSCreateCatchContext ( node ) ; case IrOpcode :: kJSCreateBlockContext : return ReduceJSCreateBlockContext ( node ) ; case IrOpcode :: kJSCreateGeneratorObject : return ReduceJSCreateGeneratorObject ( node ) ; case IrOpcode :: kJSCreateObject : return ReduceJSCreateObject ( node ) ; default : break ; } return NoChange ( ) ; }
void WebGLTexture :: CopyTexImage ( GLenum imageTarget , uint32_t level , GLenum respecFormat , const uvec3 & dstOffset , const ivec2 & srcOffset , const uvec2 & size2 ) { const webgl :: FormatUsageInfo * srcUsage ; uint32_t srcTotalWidth ; uint32_t srcTotalHeight ; if ( ! mContext -> BindCurFBForColorRead ( & srcUsage , & srcTotalWidth , & srcTotalHeight ) ) { return ; } const auto & srcFormat = srcUsage -> format ; if ( ! ValidateCopyTexImageForFeedback ( * mContext , * this , level , dstOffset . z ) ) return ; const auto size = uvec3 { size2 . x , size2 . y , 1 } ; webgl :: ImageInfo * imageInfo ; const webgl :: FormatUsageInfo * dstUsage ; if ( respecFormat ) { if ( ! ValidateTexImageSpecification ( imageTarget , level , size , & imageInfo ) ) return ; MOZ_ASSERT ( imageInfo ) ; dstUsage = ValidateCopyDestUsage ( mContext , srcFormat , respecFormat ) ; if ( ! dstUsage ) return ; if ( ! ValidateTargetForFormat ( mContext , imageTarget , dstUsage -> format ) ) return ; } else { if ( ! ValidateTexImageSelection ( imageTarget , level , dstOffset , size , & imageInfo ) ) { return ; } MOZ_ASSERT ( imageInfo ) ; dstUsage = imageInfo -> mFormat ; MOZ_ASSERT ( dstUsage ) ; } const auto & dstFormat = dstUsage -> format ; if ( ! mContext -> IsWebGL2 ( ) && dstFormat -> d ) { mContext -> ErrorInvalidOperation ( "Function may not be called with format %s." , dstFormat -> name ) ; return ; } if ( ! ValidateCopyTexImageFormats ( mContext , srcFormat , dstFormat ) ) return ; if ( ! respecFormat ) { if ( ! EnsureImageDataInitializedForUpload ( this , imageTarget , level , dstOffset , size , imageInfo ) ) { return ; } } const bool isSubImage = ! respecFormat ; if ( ! DoCopyTexOrSubImage ( mContext , isSubImage , this , imageTarget , level , srcOffset . x , srcOffset . y , srcTotalWidth , srcTotalHeight , srcUsage , dstOffset . x , dstOffset . y , dstOffset . z , size . x , size . y , dstUsage ) ) { return ; } mContext -> OnDataAllocCall ( ) ; if ( respecFormat ) { const auto uninitializedSlices = Nothing ( ) ; const webgl :: ImageInfo newImageInfo { dstUsage , size . x , size . y , size . z , uninitializedSlices } ; * imageInfo = newImageInfo ; InvalidateCaches ( ) ; } }
void traverse_commit_list ( struct rev_info * revs , show_commit_fn show_commit , show_object_fn show_object , void * data ) { int i ; struct commit * commit ; struct strbuf base ; strbuf_init ( & base , PATH_MAX ) ; while ( ( commit = get_revision ( revs ) ) != NULL ) { if ( commit -> tree ) add_pending_tree ( revs , commit -> tree ) ; show_commit ( commit , data ) ; } for ( i = 0 ; i < revs -> pending . nr ; i ++ ) { struct object_array_entry * pending = revs -> pending . objects + i ; struct object * obj = pending -> item ; const char * name = pending -> name ; const char * path = pending -> path ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ; if ( obj -> type == OBJ_TAG ) { obj -> flags |= SEEN ; show_object ( obj , NULL , name , data ) ; continue ; } if ( ! path ) path = "" ; if ( obj -> type == OBJ_TREE ) { process_tree ( revs , ( struct tree * ) obj , show_object , & base , path , data ) ; continue ; } if ( obj -> type == OBJ_BLOB ) { process_blob ( revs , ( struct blob * ) obj , show_object , NULL , path , data ) ; continue ; } die ( "unknown pending object %s (%s)" , oid_to_hex ( & obj -> oid ) , name ) ; } object_array_clear ( & revs -> pending ) ; strbuf_release ( & base ) ; }
nsHTMLEditRules :: RemoveEmptyNodes ( ) { nsCOMPtr < nsIContentIterator > iter = do_CreateInstance ( "@mozilla.org/content/post-content-iterator;1" ) ; NS_ENSURE_TRUE ( iter , NS_ERROR_NULL_POINTER ) ; nsresult res = iter -> Init ( mDocChangeRange ) ; NS_ENSURE_SUCCESS ( res , res ) ; nsCOMArray < nsINode > arrayOfEmptyNodes , arrayOfEmptyCites ; nsTArray < nsINode * > skipList ; while ( ! iter -> IsDone ( ) ) { nsINode * node = iter -> GetCurrentNode ( ) ; NS_ENSURE_TRUE ( node , NS_ERROR_FAILURE ) ; nsINode * parent = node -> GetNodeParent ( ) ; PRUint32 idx = skipList . IndexOf ( node ) ; if ( idx != skipList . NoIndex ) { skipList [ idx ] = parent ; } else { bool bIsCandidate = false ; bool bIsEmptyNode = false ; bool bIsMailCite = false ; if ( node -> IsElement ( ) ) { dom :: Element * element = node -> AsElement ( ) ; if ( element -> IsHTML ( nsGkAtoms :: body ) ) { } else if ( ( bIsMailCite = nsHTMLEditUtils :: IsMailCite ( element ) ) || element -> IsHTML ( nsGkAtoms :: a ) || nsHTMLEditUtils :: IsInlineStyle ( element ) || nsHTMLEditUtils :: IsList ( element ) || element -> IsHTML ( nsGkAtoms :: div ) ) { bIsCandidate = true ; } else if ( nsHTMLEditUtils :: IsFormatNode ( element ) || nsHTMLEditUtils :: IsListItem ( element ) || element -> IsHTML ( nsGkAtoms :: blockquote ) ) { bool bIsSelInNode ; res = SelectionEndpointInNode ( node , & bIsSelInNode ) ; NS_ENSURE_SUCCESS ( res , res ) ; if ( ! bIsSelInNode ) { bIsCandidate = true ; } } } if ( bIsCandidate ) { res = mHTMLEditor -> IsEmptyNode ( node -> AsDOMNode ( ) , & bIsEmptyNode , bIsMailCite , true ) ; NS_ENSURE_SUCCESS ( res , res ) ; if ( bIsEmptyNode ) { if ( bIsMailCite ) { arrayOfEmptyCites . AppendObject ( node ) ; } else { arrayOfEmptyNodes . AppendObject ( node ) ; } } } if ( ! bIsEmptyNode ) { skipList . AppendElement ( parent ) ; } } iter -> Next ( ) ; } PRInt32 nodeCount = arrayOfEmptyNodes . Count ( ) ; for ( PRInt32 j = 0 ; j < nodeCount ; j ++ ) { nsCOMPtr < nsIDOMNode > delNode = arrayOfEmptyNodes [ 0 ] -> AsDOMNode ( ) ; arrayOfEmptyNodes . RemoveObjectAt ( 0 ) ; if ( mHTMLEditor -> IsModifiableNode ( delNode ) ) { res = mHTMLEditor -> DeleteNode ( delNode ) ; NS_ENSURE_SUCCESS ( res , res ) ; } } nodeCount = arrayOfEmptyCites . Count ( ) ; for ( PRInt32 j = 0 ; j < nodeCount ; j ++ ) { nsCOMPtr < nsIDOMNode > delNode = arrayOfEmptyCites [ 0 ] -> AsDOMNode ( ) ; arrayOfEmptyCites . RemoveObjectAt ( 0 ) ; bool bIsEmptyNode ; res = mHTMLEditor -> IsEmptyNode ( delNode , & bIsEmptyNode , false , true ) ; NS_ENSURE_SUCCESS ( res , res ) ; if ( ! bIsEmptyNode ) { nsCOMPtr < nsIDOMNode > parent , brNode ; PRInt32 offset ; parent = nsEditor :: GetNodeLocation ( delNode , & offset ) ; res = mHTMLEditor -> CreateBR ( parent , offset , address_of ( brNode ) ) ; NS_ENSURE_SUCCESS ( res , res ) ; } res = mHTMLEditor -> DeleteNode ( delNode ) ; NS_ENSURE_SUCCESS ( res , res ) ; } return res ; }
nsresult nsPluginInstanceOwner :: Init ( nsIContent * aContent ) { mLastEventloopNestingLevel = GetEventloopNestingLevel ( ) ; mContent = aContent ; nsIFrame * frame = aContent -> GetPrimaryFrame ( ) ; nsIObjectFrame * iObjFrame = do_QueryFrame ( frame ) ; nsPluginFrame * objFrame = static_cast < nsPluginFrame * > ( iObjFrame ) ; if ( objFrame ) { SetFrame ( objFrame ) ; objFrame -> PresContext ( ) -> EnsureVisible ( ) ; } else { NS_NOTREACHED ( "Should not be initializing plugin without a frame" ) ; return NS_ERROR_FAILURE ; } mCXMenuListener = new nsPluginDOMContextMenuListener ( aContent ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "focus" ) , this , false , false ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "blur" ) , this , false , false ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "mouseup" ) , this , false , false ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "mousedown" ) , this , false , false ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "mousemove" ) , this , false , false ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "click" ) , this , false , false ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "dblclick" ) , this , false , false ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "mouseover" ) , this , false , false ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "mouseout" ) , this , false , false ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "keypress" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "keydown" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "keyup" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "drop" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "dragdrop" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "drag" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "dragenter" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "dragover" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "dragleave" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "dragexit" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "dragstart" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "draggesture" ) , this , true ) ; mContent -> AddEventListener ( NS_LITERAL_STRING ( "dragend" ) , this , true ) ; return NS_OK ; }
void Font :: Builder :: InterRelateBuilders ( TableBuilderMap * builder_map ) { Table :: Builder * raw_head_builder = GetBuilder ( builder_map , Tag :: head ) ; FontHeaderTableBuilderPtr header_table_builder ; if ( raw_head_builder != NULL ) { header_table_builder = down_cast < FontHeaderTable :: Builder * > ( raw_head_builder ) ; } Table :: Builder * raw_hhea_builder = GetBuilder ( builder_map , Tag :: hhea ) ; HorizontalHeaderTableBuilderPtr horizontal_header_builder ; if ( raw_head_builder != NULL ) { horizontal_header_builder = down_cast < HorizontalHeaderTable :: Builder * > ( raw_hhea_builder ) ; } Table :: Builder * raw_maxp_builder = GetBuilder ( builder_map , Tag :: maxp ) ; MaximumProfileTableBuilderPtr max_profile_builder ; if ( raw_maxp_builder != NULL ) { max_profile_builder = down_cast < MaximumProfileTable :: Builder * > ( raw_maxp_builder ) ; } Table :: Builder * raw_loca_builder = GetBuilder ( builder_map , Tag :: loca ) ; LocaTableBuilderPtr loca_table_builder ; if ( raw_loca_builder != NULL ) { loca_table_builder = down_cast < LocaTable :: Builder * > ( raw_loca_builder ) ; } Table :: Builder * raw_hmtx_builder = GetBuilder ( builder_map , Tag :: hmtx ) ; HorizontalMetricsTableBuilderPtr horizontal_metrics_builder ; if ( raw_hmtx_builder != NULL ) { horizontal_metrics_builder = down_cast < HorizontalMetricsTable :: Builder * > ( raw_hmtx_builder ) ; } #if defined (SFNTLY_EXPERIMENTAL) Table :: Builder * raw_hdmx_builder = GetBuilder ( builder_map , Tag :: hdmx ) ; HorizontalDeviceMetricsTableBuilderPtr hdmx_table_builder ; if ( raw_hdmx_builder != NULL ) { hdmx_table_builder = down_cast < HorizontalDeviceMetricsTable :: Builder * > ( raw_hdmx_builder ) ; } #endif if ( horizontal_metrics_builder != NULL ) { if ( max_profile_builder != NULL ) { horizontal_metrics_builder -> SetNumGlyphs ( max_profile_builder -> NumGlyphs ( ) ) ; } if ( horizontal_header_builder != NULL ) { horizontal_metrics_builder -> SetNumberOfHMetrics ( horizontal_header_builder -> NumberOfHMetrics ( ) ) ; } } if ( loca_table_builder != NULL ) { if ( max_profile_builder != NULL ) { loca_table_builder -> SetNumGlyphs ( max_profile_builder -> NumGlyphs ( ) ) ; } if ( header_table_builder != NULL ) { loca_table_builder -> set_format_version ( header_table_builder -> IndexToLocFormat ( ) ) ; } } #if defined (SFNTLY_EXPERIMENTAL) if ( max_profile_builder != NULL && hdmx_table_builder != NULL ) { hdmx_table_builder -> SetNumGlyphs ( max_profile_builder -> NumGlyphs ( ) ) ; } #endif }
nfsd_cross_mnt ( struct svc_rqst * rqstp , struct dentry * * dpp , struct svc_export * * expp ) { struct svc_export * exp = * expp , * exp2 = NULL ; struct dentry * dentry = * dpp ; struct path path = { . mnt = mntget ( exp -> ex_path . mnt ) , . dentry = dget ( dentry ) } ; int err = 0 ; err = follow_down ( & path ) ; if ( err < 0 ) goto out ; exp2 = rqst_exp_get_by_name ( rqstp , & path ) ; if ( IS_ERR ( exp2 ) ) { err = PTR_ERR ( exp2 ) ; if ( err == - ENOENT && ! ( exp -> ex_flags & NFSEXP_V4ROOT ) ) err = 0 ; path_put ( & path ) ; goto out ; } if ( nfsd_v4client ( rqstp ) || ( exp -> ex_flags & NFSEXP_CROSSMOUNT ) || EX_NOHIDE ( exp2 ) ) { * dpp = path . dentry ; path . dentry = dentry ; * expp = exp2 ; exp2 = exp ; } path_put ( & path ) ; exp_put ( exp2 ) ; out : return err ; }
int hfsplus_set_posix_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int err ; char * xattr_name ; size_t size = 0 ; char * value = NULL ; hfs_dbg ( ACL_MOD , "[%s]: ino %lu\n" , __func__ , inode -> i_ino ) ; switch ( type ) { case ACL_TYPE_ACCESS : xattr_name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; if ( err < 0 ) return err ; } err = 0 ; break ; case ACL_TYPE_DEFAULT : xattr_name = XATTR_NAME_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; if ( unlikely ( size > HFSPLUS_MAX_INLINE_DATA_SIZE ) ) return - ENOMEM ; value = ( char * ) hfsplus_alloc_attr_entry ( ) ; if ( unlikely ( ! value ) ) return - ENOMEM ; err = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( unlikely ( err < 0 ) ) goto end_set_acl ; } err = __hfsplus_setxattr ( inode , xattr_name , value , size , 0 ) ; end_set_acl : hfsplus_destroy_attr_entry ( ( hfsplus_attr_entry * ) value ) ; if ( ! err ) set_cached_acl ( inode , type , acl ) ; return err ; }
void FinishCompilationUnits ( CompilationState * compilation_state , ErrorThrower * thrower ) { TRACE_EVENT0 ( TRACE_DISABLED_BY_DEFAULT ( "v8.wasm" ) , "FinishCompilationUnits" ) ; while ( true ) { if ( compilation_state -> failed ( ) ) break ; std :: unique_ptr < WasmCompilationUnit > unit = compilation_state -> GetNextExecutedUnit ( ) ; if ( unit == nullptr ) break ; WasmCode * result = unit -> FinishCompilation ( thrower ) ; if ( thrower -> error ( ) ) { compilation_state -> Abort ( ) ; break ; } compilation_state -> OnFinishedUnit ( ) ; DCHECK_IMPLIES ( result == nullptr , thrower -> error ( ) ) ; if ( result == nullptr ) break ; } if ( ! compilation_state -> failed ( ) ) { compilation_state -> RestartBackgroundTasks ( ) ; } }
int handle_popc ( u32 insn , struct pt_regs * regs ) { u64 value ; int ret , i , rd = ( ( insn > > 25 ) & 0x1f ) ; int from_kernel = ( regs -> tstate & TSTATE_PRIV ) != 0 ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; if ( insn & 0x2000 ) { maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; value = sign_extend_imm13 ( insn ) ; } else { maybe_flush_windows ( 0 , insn & 0x1f , rd , from_kernel ) ; value = fetch_reg ( insn & 0x1f , regs ) ; } for ( ret = 0 , i = 0 ; i < 16 ; i ++ ) { ret += popc_helper [ value & 0xf ] ; value >>= 4 ; } if ( rd < 16 ) { if ( rd ) regs -> u_regs [ rd ] = ret ; } else { if ( test_thread_flag ( TIF_32BIT ) ) { struct reg_window32 __user * win32 ; win32 = ( struct reg_window32 __user * ) ( ( unsigned long ) ( ( u32 ) regs -> u_regs [ UREG_FP ] ) ) ; put_user ( ret , & win32 -> locals [ rd - 16 ] ) ; } else { struct reg_window __user * win ; win = ( struct reg_window __user * ) ( regs -> u_regs [ UREG_FP ] + STACK_BIAS ) ; put_user ( ret , & win -> locals [ rd - 16 ] ) ; } } advance ( regs ) ; return 1 ; }
void V8HeapExplorer :: SetGcSubrootReference ( Root root , const char * description , bool is_weak , Object * child_obj ) { HeapEntry * child_entry = GetEntry ( child_obj ) ; if ( child_entry == nullptr ) return ; const char * name = GetStrongGcSubrootName ( child_obj ) ; HeapGraphEdge :: Type edge_type = is_weak ? HeapGraphEdge :: kWeak : HeapGraphEdge :: kInternal ; if ( name != nullptr ) { filler_ -> SetNamedReference ( edge_type , snapshot_ -> gc_subroot ( root ) -> index ( ) , name , child_entry ) ; } else { filler_ -> SetNamedAutoIndexReference ( edge_type , snapshot_ -> gc_subroot ( root ) -> index ( ) , description , child_entry ) ; } if ( is_weak || ! child_obj -> IsNativeContext ( ) ) return ; JSGlobalObject * global = Context :: cast ( child_obj ) -> global_object ( ) ; if ( ! global -> IsJSGlobalObject ( ) ) return ; if ( user_roots_ . Contains ( global ) ) return ; user_roots_ . Insert ( global ) ; SetUserGlobalReference ( global ) ; }
UnixSocketImpl :: Close ( ) { mReadWatcher . StopWatchingFileDescriptor ( ) ; mWriteWatcher . StopWatchingFileDescriptor ( ) ; nsRefPtr < nsIRunnable > t ( new DeleteInstanceRunnable < UnixSocketImpl > ( this ) ) ; NS_ENSURE_TRUE_VOID ( t ) ; nsresult rv = NS_DispatchToMainThread ( t ) ; NS_ENSURE_SUCCESS_VOID ( rv ) ; }
newkeys_from_blob ( struct sshbuf * m , struct ssh * ssh , int mode ) { struct sshbuf * b = NULL ; struct sshcomp * comp ; struct sshenc * enc ; struct sshmac * mac ; struct newkeys * newkey = NULL ; size_t keylen , ivlen , maclen ; int r ; if ( ( newkey = calloc ( 1 , sizeof ( * newkey ) ) ) == NULL ) { r = SSH_ERR_ALLOC_FAIL ; goto out ; } if ( ( r = sshbuf_froms ( m , & b ) ) != 0 ) goto out ; #ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; #endif enc = & newkey -> enc ; mac = & newkey -> mac ; comp = & newkey -> comp ; if ( ( r = sshbuf_get_cstring ( b , & enc -> name , NULL ) ) != 0 || ( r = sshbuf_get ( b , & enc -> cipher , sizeof ( enc -> cipher ) ) ) != 0 || ( r = sshbuf_get_u32 ( b , ( u_int * ) & enc -> enabled ) ) != 0 || ( r = sshbuf_get_u32 ( b , & enc -> block_size ) ) != 0 || ( r = sshbuf_get_string ( b , & enc -> key , & keylen ) ) != 0 || ( r = sshbuf_get_string ( b , & enc -> iv , & ivlen ) ) != 0 ) goto out ; if ( cipher_authlen ( enc -> cipher ) == 0 ) { if ( ( r = sshbuf_get_cstring ( b , & mac -> name , NULL ) ) != 0 ) goto out ; if ( ( r = mac_setup ( mac , mac -> name ) ) != 0 ) goto out ; if ( ( r = sshbuf_get_u32 ( b , ( u_int * ) & mac -> enabled ) ) != 0 || ( r = sshbuf_get_string ( b , & mac -> key , & maclen ) ) != 0 ) goto out ; if ( maclen > mac -> key_len ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } mac -> key_len = maclen ; } if ( ( r = sshbuf_get_u32 ( b , & comp -> type ) ) != 0 || ( r = sshbuf_get_u32 ( b , ( u_int * ) & comp -> enabled ) ) != 0 || ( r = sshbuf_get_cstring ( b , & comp -> name , NULL ) ) != 0 ) goto out ; if ( enc -> name == NULL || cipher_by_name ( enc -> name ) != enc -> cipher ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } if ( sshbuf_len ( b ) != 0 ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } enc -> key_len = keylen ; enc -> iv_len = ivlen ; ssh -> kex -> newkeys [ mode ] = newkey ; newkey = NULL ; r = 0 ; out : free ( newkey ) ; sshbuf_free ( b ) ; return r ; }
void SoftVPX :: onQueueFilled ( OMX_U32 ) { if ( mOutputPortSettingsChange != NONE ) { return ; } List < BufferInfo * > & inQueue = getPortQueue ( 0 ) ; List < BufferInfo * > & outQueue = getPortQueue ( 1 ) ; bool EOSseen = false ; while ( ! inQueue . empty ( ) && ! outQueue . empty ( ) ) { BufferInfo * inInfo = * inQueue . begin ( ) ; OMX_BUFFERHEADERTYPE * inHeader = inInfo -> mHeader ; BufferInfo * outInfo = * outQueue . begin ( ) ; OMX_BUFFERHEADERTYPE * outHeader = outInfo -> mHeader ; if ( inHeader -> nFlags & OMX_BUFFERFLAG_EOS ) { EOSseen = true ; if ( inHeader -> nFilledLen == 0 ) { inQueue . erase ( inQueue . begin ( ) ) ; inInfo -> mOwnedByUs = false ; notifyEmptyBufferDone ( inHeader ) ; outHeader -> nFilledLen = 0 ; outHeader -> nFlags = OMX_BUFFERFLAG_EOS ; outQueue . erase ( outQueue . begin ( ) ) ; outInfo -> mOwnedByUs = false ; notifyFillBufferDone ( outHeader ) ; return ; } } if ( mImg == NULL ) { if ( vpx_codec_decode ( ( vpx_codec_ctx_t * ) mCtx , inHeader -> pBuffer + inHeader -> nOffset , inHeader -> nFilledLen , NULL , 0 ) ) { ALOGE ( "on2 decoder failed to decode frame." ) ; notify ( OMX_EventError , OMX_ErrorUndefined , 0 , NULL ) ; return ; } vpx_codec_iter_t iter = NULL ; mImg = vpx_codec_get_frame ( ( vpx_codec_ctx_t * ) mCtx , & iter ) ; } if ( mImg != NULL ) { CHECK_EQ ( mImg -> fmt , IMG_FMT_I420 ) ; uint32_t width = mImg -> d_w ; uint32_t height = mImg -> d_h ; bool portWillReset = false ; handlePortSettingsChange ( & portWillReset , width , height ) ; if ( portWillReset ) { return ; } outHeader -> nOffset = 0 ; outHeader -> nFilledLen = ( outputBufferWidth ( ) * outputBufferHeight ( ) * 3 ) / 2 ; outHeader -> nFlags = EOSseen ? OMX_BUFFERFLAG_EOS : 0 ; outHeader -> nTimeStamp = inHeader -> nTimeStamp ; uint8_t * dst = outHeader -> pBuffer ; const uint8_t * srcY = ( const uint8_t * ) mImg -> planes [ PLANE_Y ] ; const uint8_t * srcU = ( const uint8_t * ) mImg -> planes [ PLANE_U ] ; const uint8_t * srcV = ( const uint8_t * ) mImg -> planes [ PLANE_V ] ; size_t srcYStride = mImg -> stride [ PLANE_Y ] ; size_t srcUStride = mImg -> stride [ PLANE_U ] ; size_t srcVStride = mImg -> stride [ PLANE_V ] ; copyYV12FrameToOutputBuffer ( dst , srcY , srcU , srcV , srcYStride , srcUStride , srcVStride ) ; mImg = NULL ; outInfo -> mOwnedByUs = false ; outQueue . erase ( outQueue . begin ( ) ) ; outInfo = NULL ; notifyFillBufferDone ( outHeader ) ; outHeader = NULL ; } inInfo -> mOwnedByUs = false ; inQueue . erase ( inQueue . begin ( ) ) ; inInfo = NULL ; notifyEmptyBufferDone ( inHeader ) ; inHeader = NULL ; } }
int ScopeInfo :: ReceiverContextSlotIndex ( ) const { if ( length ( ) > 0 && ReceiverVariableField :: decode ( Flags ( ) ) == CONTEXT ) { return Smi :: ToInt ( get ( ReceiverInfoIndex ( ) ) ) ; } return - 1 ; }
SnapshotObjectId HeapObjectsMap :: FindEntry ( Address addr ) { base :: HashMap :: Entry * entry = entries_map_ . Lookup ( reinterpret_cast < void * > ( addr ) , ComputeAddressHash ( addr ) ) ; if ( entry == nullptr ) return 0 ; int entry_index = static_cast < int > ( reinterpret_cast < intptr_t > ( entry -> value ) ) ; EntryInfo & entry_info = entries_ . at ( entry_index ) ; DCHECK ( static_cast < uint32_t > ( entries_ . size ( ) ) > entries_map_ . occupancy ( ) ) ; return entry_info . id ; }
sctp_get_mbuf_for_msg ( unsigned int space_needed , int want_header , int how , int allonebuf , int type ) { struct mbuf * m = NULL ; #if defined(__FreeBSD__) || defined(__Userspace__) #if defined(__Userspace__) m = m_getm2 ( NULL , space_needed , how , type , want_header ? M_PKTHDR : 0 , allonebuf ) ; #else m = m_getm2 ( NULL , space_needed , how , type , want_header ? M_PKTHDR : 0 ) ; #endif if ( m == NULL ) { return ( m ) ; } #if !defined(__Userspace__) if ( allonebuf ) { if ( SCTP_BUF_SIZE ( m ) < space_needed ) { m_freem ( m ) ; return ( NULL ) ; } KASSERT ( SCTP_BUF_NEXT ( m ) == NULL , ( "%s: no chain allowed" , __FUNCTION__ ) ) ; } #endif #ifdef SCTP_MBUF_LOGGING if ( SCTP_BASE_SYSCTL ( sctp_logging_level ) & SCTP_MBUF_LOGGING_ENABLE ) { sctp_log_mb ( m , SCTP_MBUF_IALLOC ) ; } #endif #else int mbuf_threshold ; unsigned int size ; if ( want_header ) { MGETHDR ( m , how , type ) ; size = MHLEN ; } else { MGET ( m , how , type ) ; size = MLEN ; } if ( m == NULL ) { return ( NULL ) ; } if ( allonebuf == 0 ) { mbuf_threshold = SCTP_BASE_SYSCTL ( sctp_mbuf_threshold_count ) ; } else { mbuf_threshold = 1 ; } if ( space_needed > ( unsigned int ) ( ( ( mbuf_threshold - 1 ) * MLEN ) + MHLEN ) ) { MCLGET ( m , how ) ; if ( m == NULL ) { return ( NULL ) ; } if ( SCTP_BUF_IS_EXTENDED ( m ) == 0 ) { sctp_m_freem ( m ) ; return ( NULL ) ; } size = SCTP_BUF_EXTEND_SIZE ( m ) ; } if ( allonebuf != 0 && size < space_needed ) { m_freem ( m ) ; return ( NULL ) ; } SCTP_BUF_LEN ( m ) = 0 ; SCTP_BUF_NEXT ( m ) = SCTP_BUF_NEXT_PKT ( m ) = NULL ; #ifdef SCTP_MBUF_LOGGING if ( SCTP_BASE_SYSCTL ( sctp_logging_level ) & SCTP_MBUF_LOGGING_ENABLE ) { sctp_log_mb ( m , SCTP_MBUF_IALLOC ) ; } #endif #endif return ( m ) ; }
int vp9_rc_drop_frame ( VP9_COMP * cpi ) { const VP9_CONFIG * oxcf = & cpi -> oxcf ; RATE_CONTROL * const rc = & cpi -> rc ; if ( ! oxcf -> drop_frames_water_mark ) { return 0 ; } else { if ( rc -> buffer_level < 0 ) { return 1 ; } else { int drop_mark = ( int ) ( oxcf -> drop_frames_water_mark * oxcf -> optimal_buffer_level / 100 ) ; if ( ( rc -> buffer_level > drop_mark ) && ( rc -> decimation_factor > 0 ) ) { -- rc -> decimation_factor ; } else if ( rc -> buffer_level <= drop_mark && rc -> decimation_factor == 0 ) { rc -> decimation_factor = 1 ; } if ( rc -> decimation_factor > 0 ) { if ( rc -> decimation_count > 0 ) { -- rc -> decimation_count ; return 1 ; } else { rc -> decimation_count = rc -> decimation_factor ; return 0 ; } } else { rc -> decimation_count = 0 ; return 0 ; } } } }
void Schedule :: AddDeoptimize ( BasicBlock * block , Node * input ) { DCHECK_EQ ( BasicBlock :: kNone , block -> control ( ) ) ; block -> set_control ( BasicBlock :: kDeoptimize ) ; SetControlInput ( block , input ) ; if ( block != end ( ) ) AddSuccessor ( block , end ( ) ) ; }
RUNTIME_FUNCTION ( Runtime_AsyncGeneratorHasCatchHandlerForPC ) { DisallowHeapAllocation no_allocation_scope ; DCHECK_EQ ( 1 , args . length ( ) ) ; DCHECK ( args [ 0 ] -> IsJSAsyncGeneratorObject ( ) ) ; JSAsyncGeneratorObject * generator = JSAsyncGeneratorObject :: cast ( args [ 0 ] ) ; int state = generator -> continuation ( ) ; DCHECK_NE ( state , JSAsyncGeneratorObject :: kGeneratorExecuting ) ; if ( state < 1 ) return ReadOnlyRoots ( isolate ) . false_value ( ) ; SharedFunctionInfo * shared = generator -> function ( ) -> shared ( ) ; DCHECK ( shared -> HasBytecodeArray ( ) ) ; HandlerTable handler_table ( shared -> GetBytecodeArray ( ) ) ; int pc = Smi :: cast ( generator -> input_or_debug_pos ( ) ) -> value ( ) ; HandlerTable :: CatchPrediction catch_prediction = HandlerTable :: ASYNC_AWAIT ; handler_table . LookupRange ( pc , nullptr , & catch_prediction ) ; return isolate -> heap ( ) -> ToBoolean ( catch_prediction == HandlerTable :: CAUGHT ) ; }
void AstNumberingVisitor :: VisitStatements ( ZoneList < Statement * > * statements ) { if ( statements == NULL ) return ; for ( int i = 0 ; i < statements -> length ( ) ; i ++ ) { Visit ( statements -> at ( i ) ) ; } }
int yr_re_match ( RE * re , const char * target ) { return yr_re_exec ( re -> code , ( uint8_t * ) target , strlen ( target ) , re -> flags | RE_FLAGS_SCAN , NULL , NULL ) ; }
long ContentEncoding :: ParseEncryptionEntry ( long long start , long long size , IMkvReader * pReader , ContentEncryption * encryption ) { assert ( pReader ) ; assert ( encryption ) ; long long pos = start ; const long long stop = start + size ; while ( pos < stop ) { long long id , size ; const long status = ParseElementHeader ( pReader , pos , stop , id , size ) ; if ( status < 0 ) return status ; if ( id == 0x7E1 ) { encryption -> algo = UnserializeUInt ( pReader , pos , size ) ; if ( encryption -> algo != 5 ) return E_FILE_FORMAT_INVALID ; } else if ( id == 0x7E2 ) { delete [ ] encryption -> key_id ; encryption -> key_id = NULL ; encryption -> key_id_len = 0 ; if ( size <= 0 ) return E_FILE_FORMAT_INVALID ; const size_t buflen = static_cast < size_t > ( size ) ; typedef unsigned char * buf_t ; const buf_t buf = new ( std :: nothrow ) unsigned char [ buflen ] ; if ( buf == NULL ) return - 1 ; const int read_status = pReader -> Read ( pos , buflen , buf ) ; if ( read_status ) { delete [ ] buf ; return status ; } encryption -> key_id = buf ; encryption -> key_id_len = buflen ; } else if ( id == 0x7E3 ) { delete [ ] encryption -> signature ; encryption -> signature = NULL ; encryption -> signature_len = 0 ; if ( size <= 0 ) return E_FILE_FORMAT_INVALID ; const size_t buflen = static_cast < size_t > ( size ) ; typedef unsigned char * buf_t ; const buf_t buf = new ( std :: nothrow ) unsigned char [ buflen ] ; if ( buf == NULL ) return - 1 ; const int read_status = pReader -> Read ( pos , buflen , buf ) ; if ( read_status ) { delete [ ] buf ; return status ; } encryption -> signature = buf ; encryption -> signature_len = buflen ; } else if ( id == 0x7E4 ) { delete [ ] encryption -> sig_key_id ; encryption -> sig_key_id = NULL ; encryption -> sig_key_id_len = 0 ; if ( size <= 0 ) return E_FILE_FORMAT_INVALID ; const size_t buflen = static_cast < size_t > ( size ) ; typedef unsigned char * buf_t ; const buf_t buf = new ( std :: nothrow ) unsigned char [ buflen ] ; if ( buf == NULL ) return - 1 ; const int read_status = pReader -> Read ( pos , buflen , buf ) ; if ( read_status ) { delete [ ] buf ; return status ; } encryption -> sig_key_id = buf ; encryption -> sig_key_id_len = buflen ; } else if ( id == 0x7E5 ) { encryption -> sig_algo = UnserializeUInt ( pReader , pos , size ) ; } else if ( id == 0x7E6 ) { encryption -> sig_hash_algo = UnserializeUInt ( pReader , pos , size ) ; } else if ( id == 0x7E7 ) { const long status = ParseContentEncAESSettingsEntry ( pos , size , pReader , & encryption -> aes_settings ) ; if ( status ) return status ; } pos += size ; assert ( pos <= stop ) ; } return 0 ; }
int32_t DownmixLib_Create ( const effect_uuid_t * uuid , int32_t sessionId , int32_t ioId , effect_handle_t * pHandle ) { int ret ; int i ; downmix_module_t * module ; const effect_descriptor_t * desc ; ALOGV ( "DownmixLib_Create()" ) ; #ifdef DOWNMIX_TEST_CHANNEL_INDEX ALOGI ( "DOWNMIX_TEST_CHANNEL_INDEX: should work:" ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; Downmix_testIndexComputation ( CHANNEL_MASK_QUAD_SIDE | CHANNEL_MASK_QUAD_BACK ) ; Downmix_testIndexComputation ( CHANNEL_MASK_5POINT1_SIDE | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; Downmix_testIndexComputation ( CHANNEL_MASK_5POINT1_BACK | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; ALOGI ( "DOWNMIX_TEST_CHANNEL_INDEX: should NOT work:" ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_LEFT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_SIDE_LEFT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_SIDE_LEFT | AUDIO_CHANNEL_OUT_SIDE_RIGHT ) ; #endif if ( pHandle == NULL || uuid == NULL ) { return - EINVAL ; } for ( i = 0 ; i < kNbEffects ; i ++ ) { desc = gDescriptors [ i ] ; if ( memcmp ( uuid , & desc -> uuid , sizeof ( effect_uuid_t ) ) == 0 ) { break ; } } if ( i == kNbEffects ) { return - ENOENT ; } module = malloc ( sizeof ( downmix_module_t ) ) ; module -> itfe = & gDownmixInterface ; module -> context . state = DOWNMIX_STATE_UNINITIALIZED ; ret = Downmix_Init ( module ) ; if ( ret < 0 ) { ALOGW ( "DownmixLib_Create() init failed" ) ; free ( module ) ; return ret ; } * pHandle = ( effect_handle_t ) module ; ALOGV ( "DownmixLib_Create() %p , size %zu" , module , sizeof ( downmix_module_t ) ) ; return 0 ; }
Node * SimplifiedLowering :: Int32Mod ( Node * const node ) { Int32BinopMatcher m ( node ) ; Node * const zero = jsgraph ( ) -> Int32Constant ( 0 ) ; Node * const minus_one = jsgraph ( ) -> Int32Constant ( - 1 ) ; Node * const lhs = m . left ( ) . node ( ) ; Node * const rhs = m . right ( ) . node ( ) ; if ( m . right ( ) . Is ( - 1 ) || m . right ( ) . Is ( 0 ) ) { return zero ; } else if ( m . right ( ) . HasValue ( ) ) { return graph ( ) -> NewNode ( machine ( ) -> Int32Mod ( ) , lhs , rhs , graph ( ) -> start ( ) ) ; } const Operator * const merge_op = common ( ) -> Merge ( 2 ) ; const Operator * const phi_op = common ( ) -> Phi ( MachineRepresentation :: kWord32 , 2 ) ; Node * check0 = graph ( ) -> NewNode ( machine ( ) -> Int32LessThan ( ) , zero , rhs ) ; Node * branch0 = graph ( ) -> NewNode ( common ( ) -> Branch ( BranchHint :: kTrue ) , check0 , graph ( ) -> start ( ) ) ; Node * if_true0 = graph ( ) -> NewNode ( common ( ) -> IfTrue ( ) , branch0 ) ; Node * true0 ; { Node * msk = graph ( ) -> NewNode ( machine ( ) -> Int32Add ( ) , rhs , minus_one ) ; Node * check1 = graph ( ) -> NewNode ( machine ( ) -> Word32And ( ) , rhs , msk ) ; Node * branch1 = graph ( ) -> NewNode ( common ( ) -> Branch ( ) , check1 , if_true0 ) ; Node * if_true1 = graph ( ) -> NewNode ( common ( ) -> IfTrue ( ) , branch1 ) ; Node * true1 = graph ( ) -> NewNode ( machine ( ) -> Int32Mod ( ) , lhs , rhs , if_true1 ) ; Node * if_false1 = graph ( ) -> NewNode ( common ( ) -> IfFalse ( ) , branch1 ) ; Node * false1 ; { Node * check2 = graph ( ) -> NewNode ( machine ( ) -> Int32LessThan ( ) , lhs , zero ) ; Node * branch2 = graph ( ) -> NewNode ( common ( ) -> Branch ( BranchHint :: kFalse ) , check2 , if_false1 ) ; Node * if_true2 = graph ( ) -> NewNode ( common ( ) -> IfTrue ( ) , branch2 ) ; Node * true2 = graph ( ) -> NewNode ( machine ( ) -> Int32Sub ( ) , zero , graph ( ) -> NewNode ( machine ( ) -> Word32And ( ) , graph ( ) -> NewNode ( machine ( ) -> Int32Sub ( ) , zero , lhs ) , msk ) ) ; Node * if_false2 = graph ( ) -> NewNode ( common ( ) -> IfFalse ( ) , branch2 ) ; Node * false2 = graph ( ) -> NewNode ( machine ( ) -> Word32And ( ) , lhs , msk ) ; if_false1 = graph ( ) -> NewNode ( merge_op , if_true2 , if_false2 ) ; false1 = graph ( ) -> NewNode ( phi_op , true2 , false2 , if_false1 ) ; } if_true0 = graph ( ) -> NewNode ( merge_op , if_true1 , if_false1 ) ; true0 = graph ( ) -> NewNode ( phi_op , true1 , false1 , if_true0 ) ; } Node * if_false0 = graph ( ) -> NewNode ( common ( ) -> IfFalse ( ) , branch0 ) ; Node * false0 ; { Node * check1 = graph ( ) -> NewNode ( machine ( ) -> Int32LessThan ( ) , rhs , minus_one ) ; Node * branch1 = graph ( ) -> NewNode ( common ( ) -> Branch ( BranchHint :: kTrue ) , check1 , if_false0 ) ; Node * if_true1 = graph ( ) -> NewNode ( common ( ) -> IfTrue ( ) , branch1 ) ; Node * true1 = graph ( ) -> NewNode ( machine ( ) -> Int32Mod ( ) , lhs , rhs , if_true1 ) ; Node * if_false1 = graph ( ) -> NewNode ( common ( ) -> IfFalse ( ) , branch1 ) ; Node * false1 = zero ; if_false0 = graph ( ) -> NewNode ( merge_op , if_true1 , if_false1 ) ; false0 = graph ( ) -> NewNode ( phi_op , true1 , false1 , if_false0 ) ; } Node * merge0 = graph ( ) -> NewNode ( merge_op , if_true0 , if_false0 ) ; return graph ( ) -> NewNode ( phi_op , true0 , false0 , merge0 ) ; }
nsINode :: ReplaceWith ( const Sequence < OwningNodeOrString > & aNodes , ErrorResult & aRv ) { nsCOMPtr < nsINode > parent = GetParentNode ( ) ; if ( ! parent ) { return ; } nsCOMPtr < nsINode > viableNextSibling = FindViableNextSibling ( * this , aNodes ) ; nsCOMPtr < nsINode > node = ConvertNodesOrStringsIntoNode ( aNodes , OwnerDoc ( ) , aRv ) ; if ( aRv . Failed ( ) ) { return ; } if ( parent == GetParentNode ( ) ) { parent -> ReplaceChild ( * node , * this , aRv ) ; } else { parent -> InsertBefore ( * node , viableNextSibling , aRv ) ; } }
RegExpMacroAssemblerMIPS :: RegExpMacroAssemblerMIPS ( Isolate * isolate , Zone * zone , Mode mode , int registers_to_save ) : NativeRegExpMacroAssembler ( isolate , zone ) , masm_ ( new MacroAssembler ( isolate , nullptr , kRegExpCodeSize , CodeObjectRequired :: kYes ) ) , mode_ ( mode ) , num_registers_ ( registers_to_save ) , num_saved_registers_ ( registers_to_save ) , entry_label_ ( ) , start_label_ ( ) , success_label_ ( ) , backtrack_label_ ( ) , exit_label_ ( ) , internal_failure_label_ ( ) { DCHECK_EQ ( 0 , registers_to_save % 2 ) ; __ jmp ( & entry_label_ ) ; __ bind ( & internal_failure_label_ ) ; __ li ( v0 , Operand ( FAILURE ) ) ; __ Ret ( ) ; __ bind ( & start_label_ ) ; }
void TreeScope :: adoptIfNeeded ( Node & node ) { ASSERT ( this ) ; ASSERT ( ! node . isDocumentNode ( ) ) ; #if !ENABLE(OILPAN) ASSERT_WITH_SECURITY_IMPLICATION ( ! node . m_deletionHasBegun ) ; #endif TreeScopeAdopter adopter ( node , * this ) ; if ( adopter . needsScopeChange ( ) ) { ScriptForbiddenScope forbidScript ; adopter . execute ( ) ; } }
void put_ucounts ( struct ucounts * ucounts ) { unsigned long flags ; if ( atomic_dec_and_lock_irqsave ( & ucounts -> count , & ucounts_lock , flags ) ) { hlist_del_init ( & ucounts -> node ) ; spin_unlock_irqrestore ( & ucounts_lock , flags ) ; kfree ( ucounts ) ; } }
HEAP_BROKER_OBJECT_LIST ( DEFINE_IS_AND_AS ) #undef DEFINE_IS_AND_AS ObjectData * ObjectData :: Serialize ( JSHeapBroker * broker , Handle < Object > object ) { CHECK ( broker -> SerializingAllowed ( ) ) ; return object -> IsSmi ( ) ? new ( broker -> zone ( ) ) ObjectData ( broker , object , true ) : HeapObjectData :: Serialize ( broker , Handle < HeapObject > :: cast ( object ) ) ; }
cups_write ( cups_file_t * fp , const char * buf , size_t bytes ) { size_t total ; ssize_t count ; DEBUG_printf ( ( "7cups_write(fp=%p, buf=%p, bytes=" CUPS_LLFMT ")" , ( void * ) fp , ( void * ) buf , CUPS_LLCAST bytes ) ) ; total = 0 ; while ( bytes > 0 ) { #ifdef WIN32 if ( fp -> mode == 's' ) count = ( ssize_t ) send ( fp -> fd , buf , ( unsigned ) bytes , 0 ) ; else count = ( ssize_t ) write ( fp -> fd , buf , ( unsigned ) bytes ) ; #else if ( fp -> mode == 's' ) count = send ( fp -> fd , buf , bytes , 0 ) ; else count = write ( fp -> fd , buf , bytes ) ; #endif /* WIN32 */ DEBUG_printf ( ( "9cups_write: count=" CUPS_LLFMT , CUPS_LLCAST count ) ) ; if ( count < 0 ) { if ( errno == EAGAIN || errno == EINTR ) continue ; else return ( - 1 ) ; } bytes -= ( size_t ) count ; total += ( size_t ) count ; buf += count ; } return ( ( ssize_t ) total ) ; }
Reduction MachineOperatorReducer :: ReduceInt32Mod ( Node * node ) { Int32BinopMatcher m ( node ) ; if ( m . left ( ) . Is ( 0 ) ) return Replace ( m . left ( ) . node ( ) ) ; if ( m . right ( ) . Is ( 0 ) ) return Replace ( m . right ( ) . node ( ) ) ; if ( m . right ( ) . Is ( 1 ) ) return ReplaceInt32 ( 0 ) ; if ( m . right ( ) . Is ( - 1 ) ) return ReplaceInt32 ( 0 ) ; if ( m . LeftEqualsRight ( ) ) return ReplaceInt32 ( 0 ) ; if ( m . IsFoldable ( ) ) { return ReplaceInt32 ( base :: bits :: SignedMod32 ( m . left ( ) . Value ( ) , m . right ( ) . Value ( ) ) ) ; } if ( m . right ( ) . HasValue ( ) ) { Node * const dividend = m . left ( ) . node ( ) ; uint32_t const divisor = Abs ( m . right ( ) . Value ( ) ) ; if ( base :: bits :: IsPowerOfTwo ( divisor ) ) { uint32_t const mask = divisor - 1 ; Node * const zero = Int32Constant ( 0 ) ; Diamond d ( graph ( ) , common ( ) , graph ( ) -> NewNode ( machine ( ) -> Int32LessThan ( ) , dividend , zero ) , BranchHint :: kFalse ) ; return Replace ( d . Phi ( MachineRepresentation :: kWord32 , Int32Sub ( zero , Word32And ( Int32Sub ( zero , dividend ) , mask ) ) , Word32And ( dividend , mask ) ) ) ; } else { Node * quotient = Int32Div ( dividend , divisor ) ; DCHECK_EQ ( dividend , node -> InputAt ( 0 ) ) ; node -> ReplaceInput ( 1 , Int32Mul ( quotient , Int32Constant ( divisor ) ) ) ; node -> TrimInputCount ( 2 ) ; NodeProperties :: ChangeOp ( node , machine ( ) -> Int32Sub ( ) ) ; } return Changed ( node ) ; } return NoChange ( ) ; }
void Zone :: DeleteAll ( ) { for ( Segment * current = segment_head_ ; current ; ) { Segment * next = current -> next ( ) ; size_t size = current -> size ( ) ; ASAN_UNPOISON_MEMORY_REGION ( reinterpret_cast < void * > ( current -> start ( ) ) , current -> capacity ( ) ) ; segment_bytes_allocated_ -= size ; allocator_ -> ReturnSegment ( current ) ; current = next ; } position_ = limit_ = 0 ; allocation_size_ = 0 ; segment_head_ = nullptr ; }
void VisitPointers ( HeapObject * host , MaybeObject * * start , MaybeObject * * end ) override { int next_index = 0 ; for ( MaybeObject * * p = start ; p < end ; p ++ ) { int index = static_cast < int > ( reinterpret_cast < Object * * > ( p ) - HeapObject :: RawField ( parent_obj_ , 0 ) ) ; ++ next_index ; if ( reinterpret_cast < Object * * > ( p ) >= parent_start_ && reinterpret_cast < Object * * > ( p ) < parent_end_ && generator_ -> visited_fields_ [ index ] ) { generator_ -> visited_fields_ [ index ] = false ; continue ; } HeapObject * heap_object ; if ( ( * p ) -> ToWeakHeapObject ( & heap_object ) || ( * p ) -> ToStrongHeapObject ( & heap_object ) ) { generator_ -> SetHiddenReference ( parent_obj_ , parent_ , next_index , heap_object , index * kPointerSize ) ; } } }
WebGLContext :: CopyTexSubImage2D_base ( WebGLenum target , WebGLint level , WebGLenum internalformat , WebGLint xoffset , WebGLint yoffset , WebGLint x , WebGLint y , WebGLsizei width , WebGLsizei height , bool sub ) { const WebGLRectangleObject * framebufferRect = FramebufferRectangleObject ( ) ; WebGLsizei framebufferWidth = framebufferRect ? framebufferRect -> Width ( ) : 0 ; WebGLsizei framebufferHeight = framebufferRect ? framebufferRect -> Height ( ) : 0 ; const char * info = sub ? "copyTexSubImage2D" : "copyTexImage2D" ; MakeContextCurrent ( ) ; WebGLTexture * tex = activeBoundTextureForTarget ( target ) ; if ( ! tex ) return ErrorInvalidOperation ( "%s: no texture is bound to this target" ) ; #ifdef MOZ_X11 if ( gl -> WorkAroundDriverBugs ( ) && mIsMesa && level > 0 && ! sub ) { size_t face = WebGLTexture :: FaceForTarget ( target ) ; if ( ! tex -> HasImageInfoAt ( 0 , face ) || tex -> ImageInfoAt ( 0 , face ) . Width ( ) <= width ) { return ErrorInvalidOperation ( "%s: rejecting valid call to avoid Mesa driver crash. " "See Mozilla bug 785734" , info ) ; } } #endif if ( CanvasUtils :: CheckSaneSubrectSize ( x , y , width , height , framebufferWidth , framebufferHeight ) ) { if ( sub ) gl -> fCopyTexSubImage2D ( target , level , xoffset , yoffset , x , y , width , height ) ; else gl -> fCopyTexImage2D ( target , level , internalformat , x , y , width , height , 0 ) ; } else { uint32_t texelSize = 0 ; if ( ! ValidateTexFormatAndType ( internalformat , LOCAL_GL_UNSIGNED_BYTE , - 1 , & texelSize , info ) ) return ; CheckedUint32 checked_neededByteLength = GetImageSize ( height , width , texelSize , mPixelStoreUnpackAlignment ) ; if ( ! checked_neededByteLength . isValid ( ) ) return ErrorInvalidOperation ( "%s: integer overflow computing the needed buffer size" , info ) ; uint32_t bytesNeeded = checked_neededByteLength . value ( ) ; void * tempZeroData = calloc ( 1 , bytesNeeded ) ; if ( ! tempZeroData ) return ErrorOutOfMemory ( "%s: could not allocate %d bytes (for zero fill)" , info , bytesNeeded ) ; if ( sub ) gl -> fTexSubImage2D ( target , level , 0 , 0 , width , height , internalformat , LOCAL_GL_UNSIGNED_BYTE , tempZeroData ) ; else gl -> fTexImage2D ( target , level , internalformat , width , height , 0 , internalformat , LOCAL_GL_UNSIGNED_BYTE , tempZeroData ) ; free ( tempZeroData ) ; if ( x >= framebufferWidth || x + width <= 0 || y >= framebufferHeight || y + height <= 0 ) { return DummyFramebufferOperation ( info ) ; } GLint actual_x = clamped ( x , 0 , framebufferWidth ) ; GLint actual_x_plus_width = clamped ( x + width , 0 , framebufferWidth ) ; GLsizei actual_width = actual_x_plus_width - actual_x ; GLint actual_xoffset = xoffset + actual_x - x ; GLint actual_y = clamped ( y , 0 , framebufferHeight ) ; GLint actual_y_plus_height = clamped ( y + height , 0 , framebufferHeight ) ; GLsizei actual_height = actual_y_plus_height - actual_y ; GLint actual_yoffset = yoffset + actual_y - y ; gl -> fCopyTexSubImage2D ( target , level , actual_xoffset , actual_yoffset , actual_x , actual_y , actual_width , actual_height ) ; } }
Node * WasmGraphBuilder :: MaskShiftCount64 ( Node * node ) { static const int64_t kMask64 = 0x3F ; if ( ! mcgraph ( ) -> machine ( ) -> Word32ShiftIsSafe ( ) ) { Int64Matcher match ( node ) ; if ( match . HasValue ( ) ) { int64_t masked = ( match . Value ( ) & kMask64 ) ; if ( match . Value ( ) != masked ) node = mcgraph ( ) -> Int64Constant ( masked ) ; } else { node = graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Word64And ( ) , node , mcgraph ( ) -> Int64Constant ( kMask64 ) ) ; } } return node ; }
WatchpointMap :: triggerWatchpoint ( JSContext * cx , HandleObject obj , HandleId id , MutableHandleValue vp ) { Map :: Ptr p = map . lookup ( WatchKey ( obj , id ) ) ; if ( ! p || p -> value . held ) return true ; AutoEntryHolder holder ( cx , map , p ) ; JSWatchPointHandler handler = p -> value . handler ; RootedObject closure ( cx , p -> value . closure ) ; Value old ; old . setUndefined ( ) ; if ( obj -> isNative ( ) ) { if ( UnrootedShape shape = obj -> nativeLookup ( cx , id ) ) { if ( shape -> hasSlot ( ) ) old = obj -> nativeGetSlot ( shape -> slot ( ) ) ; } } return handler ( cx , obj , id , old , vp . address ( ) , closure ) ; }
ALWAYS_INLINE String serialize_impl ( const Variant & value , const SerializeOptions & opts ) { switch ( value . getType ( ) ) { case KindOfClass : case KindOfLazyClass : case KindOfPersistentString : case KindOfString : { auto const str = isStringType ( value . getType ( ) ) ? value . getStringData ( ) : isClassType ( value . getType ( ) ) ? classToStringHelper ( value . toClassVal ( ) ) : lazyClassToStringHelper ( value . toLazyClassVal ( ) ) ; auto const size = str -> size ( ) ; if ( size >= RuntimeOption :: MaxSerializedStringSize ) { throw Exception ( "Size of serialized string (%d) exceeds max" , size ) ; } StringBuffer sb ; sb . append ( "s:" ) ; sb . append ( size ) ; sb . append ( ":\"" ) ; sb . append ( str -> data ( ) , size ) ; sb . append ( "\";" ) ; return sb . detach ( ) ; } case KindOfResource : return s_Res ; case KindOfUninit : case KindOfNull : case KindOfBoolean : case KindOfInt64 : case KindOfFunc : case KindOfPersistentVec : case KindOfVec : case KindOfPersistentDict : case KindOfDict : case KindOfPersistentKeyset : case KindOfKeyset : case KindOfPersistentDArray : case KindOfDArray : case KindOfPersistentVArray : case KindOfVArray : case KindOfDouble : case KindOfObject : case KindOfClsMeth : case KindOfRClsMeth : case KindOfRFunc : case KindOfRecord : break ; } VariableSerializer vs ( VariableSerializer :: Type :: Serialize ) ; if ( opts . keepDVArrays ) vs . keepDVArrays ( ) ; if ( opts . forcePHPArrays ) vs . setForcePHPArrays ( ) ; if ( opts . warnOnHackArrays ) vs . setHackWarn ( ) ; if ( opts . warnOnPHPArrays ) vs . setPHPWarn ( ) ; if ( opts . ignoreLateInit ) vs . setIgnoreLateInit ( ) ; if ( opts . serializeProvenanceAndLegacy ) vs . setSerializeProvenanceAndLegacy ( ) ; return vs . serialize ( value , true , true ) ; }
static int l2tp_ip_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB ) goto out ; if ( addr_len ) * addr_len = sizeof ( * sin ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; } if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : return err ? err : copied ; }
TEST ( stagefright_MPEG4Metadata , test_case_mp4 ) { nsRefPtr < MediaByteBuffer > buffer = ReadTestFile ( "test_case_1187067.mp4" ) ; ASSERT_TRUE ( buffer ) ; nsRefPtr < BufferStream > stream = new BufferStream ( buffer ) ; EXPECT_TRUE ( MP4Metadata :: HasCompleteMetadata ( stream ) ) ; nsRefPtr < MediaByteBuffer > metadataBuffer = MP4Metadata :: Metadata ( stream ) ; EXPECT_TRUE ( metadataBuffer ) ; MP4Metadata metadata ( stream ) ; EXPECT_EQ ( 0u , metadata . GetNumberTracks ( TrackInfo :: kUndefinedTrack ) ) ; EXPECT_EQ ( 0u , metadata . GetNumberTracks ( TrackInfo :: kAudioTrack ) ) ; EXPECT_EQ ( 1u , metadata . GetNumberTracks ( TrackInfo :: kVideoTrack ) ) ; EXPECT_EQ ( 0u , metadata . GetNumberTracks ( TrackInfo :: kTextTrack ) ) ; EXPECT_EQ ( 0u , metadata . GetNumberTracks ( static_cast < TrackInfo :: TrackType > ( - 1 ) ) ) ; EXPECT_FALSE ( metadata . GetTrackInfo ( TrackInfo :: kUndefinedTrack , 0 ) ) ; EXPECT_FALSE ( metadata . GetTrackInfo ( TrackInfo :: kAudioTrack , 0 ) ) ; UniquePtr < TrackInfo > track = metadata . GetTrackInfo ( TrackInfo :: kVideoTrack , 0 ) ; EXPECT_TRUE ( ! ! track ) ; EXPECT_FALSE ( metadata . GetTrackInfo ( TrackInfo :: kTextTrack , 0 ) ) ; EXPECT_FALSE ( metadata . GetTrackInfo ( static_cast < TrackInfo :: TrackType > ( - 1 ) , 0 ) ) ; EXPECT_TRUE ( metadata . CanSeek ( ) ) ; EXPECT_FALSE ( metadata . Crypto ( ) . valid ) ; }
void RegExpMacroAssemblerARM64 :: ReadCurrentPositionFromRegister ( int reg ) { RegisterState register_state = GetRegisterState ( reg ) ; switch ( register_state ) { case STACKED : __ Ldr ( current_input_offset ( ) , register_location ( reg ) ) ; break ; case CACHED_LSW : __ Mov ( current_input_offset ( ) , GetCachedRegister ( reg ) . W ( ) ) ; break ; case CACHED_MSW : __ Lsr ( current_input_offset ( ) . X ( ) , GetCachedRegister ( reg ) , kWRegSizeInBits ) ; break ; default : UNREACHABLE ( ) ; break ; } }
struct sock * dccp_v4_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet_request_sock * ireq ; struct inet_sock * newinet ; struct sock * newsk ; if ( sk_acceptq_is_full ( sk ) ) goto exit_overflow ; if ( dst == NULL && ( dst = inet_csk_route_req ( sk , req ) ) == NULL ) goto exit ; newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto exit_nonewsk ; sk_setup_caps ( newsk , dst ) ; newinet = inet_sk ( newsk ) ; ireq = inet_rsk ( req ) ; newinet -> inet_daddr = ireq -> rmt_addr ; newinet -> inet_rcv_saddr = ireq -> loc_addr ; newinet -> inet_saddr = ireq -> loc_addr ; newinet -> opt = ireq -> opt ; ireq -> opt = NULL ; newinet -> mc_index = inet_iif ( skb ) ; newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ; newinet -> inet_id = jiffies ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto exit ; } __inet_hash_nolisten ( newsk , NULL ) ; return newsk ; exit_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; exit_nonewsk : dst_release ( dst ) ; exit : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
g_NPN_GetValue ( NPP instance , NPNVariable variable , void * value ) { D ( bug ( "NPN_GetValue instance=%p, variable=%d [%s]\n" , instance , variable , string_of_NPNVariable ( variable ) ) ) ; if ( ! thread_check ( ) ) { npw_printf ( "WARNING: NPN_GetValue not called from the main thread\n" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } PluginInstance * plugin = NULL ; if ( instance ) plugin = PLUGIN_INSTANCE ( instance ) ; switch ( variable ) { case NPNVxDisplay : * ( void * * ) value = x_display ; break ; case NPNVxtAppContext : * ( void * * ) value = XtDisplayToApplicationContext ( x_display ) ; break ; case NPNVToolkit : * ( NPNToolkitType * ) value = NPW_TOOLKIT ; break ; #if USE_XPCOM case NPNVserviceManager : { nsIServiceManager * sm ; int ret = NS_GetServiceManager ( & sm ) ; if ( NS_FAILED ( ret ) ) { npw_printf ( "WARNING: NS_GetServiceManager failed\n" ) ; return NPERR_GENERIC_ERROR ; } * ( nsIServiceManager * * ) value = sm ; break ; } case NPNVDOMWindow : case NPNVDOMElement : npw_printf ( "WARNING: %s is not supported by NPN_GetValue()\n" , string_of_NPNVariable ( variable ) ) ; return NPERR_INVALID_PARAM ; #endif case NPNVnetscapeWindow : if ( plugin == NULL ) { npw_printf ( "ERROR: NPNVnetscapeWindow requires a non NULL instance\n" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } if ( plugin -> browser_toplevel == NULL ) { GdkNativeWindow netscape_xid = None ; NPError error = g_NPN_GetValue_real ( instance , variable , & netscape_xid ) ; if ( error != NPERR_NO_ERROR ) return error ; if ( netscape_xid == None ) return NPERR_GENERIC_ERROR ; plugin -> browser_toplevel = gdk_window_foreign_new ( netscape_xid ) ; if ( plugin -> browser_toplevel == NULL ) return NPERR_GENERIC_ERROR ; } * ( ( GdkNativeWindow * ) value ) = GDK_WINDOW_XWINDOW ( plugin -> browser_toplevel ) ; break ; #if ALLOW_WINDOWLESS_PLUGINS case NPNVSupportsWindowless : #endif case NPNVSupportsXEmbedBool : case NPNVWindowNPObject : case NPNVPluginElementNPObject : return g_NPN_GetValue_real ( instance , variable , value ) ; default : switch ( variable & 0xff ) { case 13 : if ( NPW_TOOLKIT == NPNVGtk2 ) { * ( NPNToolkitType * ) value = NPW_TOOLKIT ; return NPERR_NO_ERROR ; } break ; } D ( bug ( "WARNING: unhandled variable %d (%s) in NPN_GetValue()\n" , variable , string_of_NPNVariable ( variable ) ) ) ; return NPERR_INVALID_PARAM ; } return NPERR_NO_ERROR ; }
FeedbackParameter const & FeedbackParameterOf ( const Operator * op ) { DCHECK ( op -> opcode ( ) == IrOpcode :: kJSCreateEmptyLiteralArray || op -> opcode ( ) == IrOpcode :: kJSInstanceOf || op -> opcode ( ) == IrOpcode :: kJSStoreDataPropertyInLiteral || op -> opcode ( ) == IrOpcode :: kJSStoreInArrayLiteral ) ; return OpParameter < FeedbackParameter > ( op ) ; }
void V8Debugger :: allAsyncTasksCanceled ( ) { m_asyncTaskStacks . clear ( ) ; m_recurringTasks . clear ( ) ; m_currentAsyncParent . clear ( ) ; m_currentExternalParent . clear ( ) ; m_currentTasks . clear ( ) ; m_framesCache . clear ( ) ; m_allAsyncStacks . clear ( ) ; m_asyncStacksCount = 0 ; }
static struct block_device * ext3_blkdev_get ( dev_t dev , struct super_block * sb ) { struct block_device * bdev ; char b [ BDEVNAME_SIZE ] ; bdev = blkdev_get_by_dev ( dev , FMODE_READ | FMODE_WRITE | FMODE_EXCL , sb ) ; if ( IS_ERR ( bdev ) ) goto fail ; return bdev ; fail : ext3_msg ( sb , "error: failed to open journal device %s: %ld" , __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ; return NULL ; }
static void _out_result ( conn_t out , nad_t nad ) { int attr ; jid_t from , to ; char * rkey ; int rkeylen ; attr = nad_find_attr ( nad , 0 , - 1 , "from" , NULL ) ; if ( attr < 0 || ( from = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , "missing or invalid from on db result packet" ) ; nad_free ( nad ) ; return ; } attr = nad_find_attr ( nad , 0 , - 1 , "to" , NULL ) ; if ( attr < 0 || ( to = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , "missing or invalid to on db result packet" ) ; jid_free ( from ) ; nad_free ( nad ) ; return ; } rkey = s2s_route_key ( NULL , to -> domain , from -> domain ) ; rkeylen = strlen ( rkey ) ; if ( nad_find_attr ( nad , 0 , - 1 , "type" , "valid" ) >= 0 ) { log_write ( out -> s2s -> log , LOG_NOTICE , "[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? ", TLS negotiated" : "" , out -> s -> compressed ? ", ZLIB compression enabled" : "" ) ; xhash_put ( out -> states , pstrdup ( xhash_pool ( out -> states ) , rkey ) , ( void * ) conn_VALID ) ; log_debug ( ZONE , "%s valid, flushing queue" , rkey ) ; out_flush_route_queue ( out -> s2s , rkey , rkeylen ) ; free ( rkey ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; return ; } log_write ( out -> s2s -> log , LOG_NOTICE , "[%d] [%s, port=%d] outgoing route '%s' is now invalid" , out -> fd -> fd , out -> ip , out -> port , rkey ) ; log_write ( out -> s2s -> log , LOG_NOTICE , "[%d] [%s, port=%d] closing connection" , out -> fd -> fd , out -> ip , out -> port ) ; sx_error ( out -> s , stream_err_INVALID_ID , "dialback negotiation failed" ) ; sx_close ( out -> s ) ; out_bounce_route_queue ( out -> s2s , rkey , rkeylen , stanza_err_SERVICE_UNAVAILABLE ) ; free ( rkey ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; }
static void opj_j2k_set_cinema_parameters ( opj_cparameters_t * parameters , opj_image_t * image , opj_event_mgr_t * p_manager ) { int i ; parameters -> tile_size_on = OPJ_FALSE ; parameters -> cp_tdx = 1 ; parameters -> cp_tdy = 1 ; parameters -> tp_flag = 'C' ; parameters -> tp_on = 1 ; parameters -> cp_tx0 = 0 ; parameters -> cp_ty0 = 0 ; parameters -> image_offset_x0 = 0 ; parameters -> image_offset_y0 = 0 ; parameters -> cblockw_init = 32 ; parameters -> cblockh_init = 32 ; parameters -> mode = 0 ; parameters -> roi_compno = - 1 ; parameters -> subsampling_dx = 1 ; parameters -> subsampling_dy = 1 ; parameters -> irreversible = 1 ; if ( parameters -> tcp_numlayers > 1 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n" "1 single quality layer" "-> Number of layers forced to 1 (rather than %d)\n" "-> Rate of the last layer (%3.1f) will be used" , parameters -> tcp_numlayers , parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ) ; parameters -> tcp_rates [ 0 ] = parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ; parameters -> tcp_numlayers = 1 ; } switch ( parameters -> rsiz ) { case OPJ_PROFILE_CINEMA_2K : if ( parameters -> numresolution > 6 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-3 (2k dc profile) requires:\n" "Number of decomposition levels <= 5\n" "-> Number of decomposition levels forced to 5 (rather than %d)\n" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 6 ; } break ; case OPJ_PROFILE_CINEMA_4K : if ( parameters -> numresolution < 2 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-4 (4k dc profile) requires:\n" "Number of decomposition levels >= 1 && <= 6\n" "-> Number of decomposition levels forced to 1 (rather than %d)\n" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 1 ; } else if ( parameters -> numresolution > 7 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-4 (4k dc profile) requires:\n" "Number of decomposition levels >= 1 && <= 6\n" "-> Number of decomposition levels forced to 6 (rather than %d)\n" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 7 ; } break ; default : break ; } parameters -> csty |= 0x01 ; parameters -> res_spec = parameters -> numresolution - 1 ; for ( i = 0 ; i < parameters -> res_spec ; i ++ ) { parameters -> prcw_init [ i ] = 256 ; parameters -> prch_init [ i ] = 256 ; } parameters -> prog_order = OPJ_CPRL ; if ( parameters -> rsiz == OPJ_PROFILE_CINEMA_4K ) { parameters -> numpocs = ( OPJ_UINT32 ) opj_j2k_initialise_4K_poc ( parameters -> POC , parameters -> numresolution ) ; } else { parameters -> numpocs = 0 ; } parameters -> cp_disto_alloc = 1 ; if ( parameters -> max_cs_size <= 0 ) { parameters -> max_cs_size = OPJ_CINEMA_24_CS ; opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n" "Maximum 1302083 compressed bytes @ 24fps\n" "As no rate has been given, this limit will be used.\n" ) ; } else if ( parameters -> max_cs_size > OPJ_CINEMA_24_CS ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n" "Maximum 1302083 compressed bytes @ 24fps\n" "-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n" ) ; parameters -> max_cs_size = OPJ_CINEMA_24_CS ; } if ( parameters -> max_comp_size <= 0 ) { parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n" "Maximum 1041666 compressed bytes @ 24fps\n" "As no rate has been given, this limit will be used.\n" ) ; } else if ( parameters -> max_comp_size > OPJ_CINEMA_24_COMP ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n" "Maximum 1041666 compressed bytes @ 24fps\n" "-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n" ) ; parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; } parameters -> tcp_rates [ 0 ] = ( OPJ_FLOAT32 ) ( image -> numcomps * image -> comps [ 0 ] . w * image -> comps [ 0 ] . h * image -> comps [ 0 ] . prec ) / ( OPJ_FLOAT32 ) ( ( ( OPJ_UINT32 ) parameters -> max_cs_size ) * 8 * image -> comps [ 0 ] . dx * image -> comps [ 0 ] . dy ) ; }
nsDocShellLoadInfo :: nsDocShellLoadInfo ( ) : mResultPrincipalURIIsSome ( false ) , mLoadReplace ( false ) , mInheritPrincipal ( false ) , mPrincipalIsExplicit ( false ) , mForceAllowDataURI ( false ) , mSendReferrer ( true ) , mReferrerPolicy ( mozilla :: net :: RP_Unset ) , mLoadType ( nsIDocShellLoadInfo :: loadNormal ) , mIsSrcdocLoad ( false ) { }
JNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJ_bufSize ( JNIEnv * env , jclass cls , jint width , jint height , jint jpegSubsamp ) { jint retval = ( jint ) tjBufSize ( width , height , jpegSubsamp ) ; if ( retval == - 1 ) _throwarg ( tjGetErrorStr ( ) ) ; bailout : return retval ; }
rndr_quote ( struct buf * ob , const struct buf * text , void * opaque ) { if ( ! text || ! text -> size ) return 0 ; BUFPUTSL ( ob , "<q>" ) ; bufput ( ob , text -> data , text -> size ) ; BUFPUTSL ( ob , "</q>" ) ; return 1 ; }
xmlModulePlatformSymbol ( void * handle , const char * name , void * * symbol ) { #ifdef _WIN32_WCE * symbol = GetProcAddressA ( handle , name ) ; #else * symbol = GetProcAddress ( handle , name ) ; #endif return ( NULL == * symbol ) ? - 1 : 0 ; }
void nfcmrvl_nci_unregister_dev ( struct nfcmrvl_private * priv ) { struct nci_dev * ndev = priv -> ndev ; if ( priv -> ndev -> nfc_dev -> fw_download_in_progress ) nfcmrvl_fw_dnld_abort ( priv ) ; nfcmrvl_fw_dnld_deinit ( priv ) ; if ( gpio_is_valid ( priv -> config . reset_n_io ) ) gpio_free ( priv -> config . reset_n_io ) ; nci_unregister_device ( ndev ) ; nci_free_device ( ndev ) ; kfree ( priv ) ; }
static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , "BPF_NEG uses reserved fields\n" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , "BPF_END uses reserved fields\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , "R%d pointer arithmetic prohibited\n" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , "BPF_MOV uses reserved fields\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , "BPF_MOV uses reserved fields\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ; } else { if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , "R%d partial copy of pointer\n" , insn -> src_reg ) ; return - EACCES ; } mark_reg_unknown ( env , regs , insn -> dst_reg ) ; regs [ insn -> dst_reg ] . var_off = tnum_cast ( regs [ insn -> dst_reg ] . var_off , 4 ) ; __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; } } else { regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } } } else if ( opcode > BPF_END ) { verbose ( env , "invalid BPF_ALU opcode %x\n" , opcode ) ; return - EINVAL ; } else { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , "BPF_ALU uses reserved fields\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , "BPF_ALU uses reserved fields\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( ( opcode == BPF_MOD || opcode == BPF_DIV ) && BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 ) { verbose ( env , "div by zero\n" ) ; return - EINVAL ; } if ( ( opcode == BPF_LSH || opcode == BPF_RSH || opcode == BPF_ARSH ) && BPF_SRC ( insn -> code ) == BPF_K ) { int size = BPF_CLASS ( insn -> code ) == BPF_ALU64 ? 64 : 32 ; if ( insn -> imm < 0 || insn -> imm >= size ) { verbose ( env , "invalid shift %d\n" , insn -> imm ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; return adjust_reg_min_max_vals ( env , insn ) ; } return 0 ; }
void JumpTableTargetOffsets :: iterator :: UpdateAndAdvanceToValid ( ) { if ( table_offset_ >= table_end_ ) return ; Object * current = accessor_ -> GetConstantAtIndex ( table_offset_ ) ; while ( ! current -> IsSmi ( ) ) { DCHECK ( current -> IsTheHole ( ) ) ; ++ table_offset_ ; ++ index_ ; if ( table_offset_ >= table_end_ ) break ; current = accessor_ -> GetConstantAtIndex ( table_offset_ ) ; } if ( current -> IsSmi ( ) ) { current_ = Smi :: cast ( current ) ; } }
static GF_Err xviddec_configure_pid ( GF_Filter * filter , GF_FilterPid * pid , Bool is_remove ) { const GF_PropertyValue * p ; GF_M4VDecSpecInfo dsi ; GF_Err e ; Bool is_first = GF_FALSE ; #ifdef XVID_USE_OLD_API XVID_DEC_FRAME frame ; XVID_DEC_PARAM par ; #else xvid_dec_frame_t frame ; xvid_dec_create_t par ; #endif GF_XVIDCtx * ctx = gf_filter_get_udta ( filter ) ; if ( is_remove ) { if ( ctx -> opid ) { gf_filter_pid_remove ( ctx -> opid ) ; ctx -> opid = NULL ; } ctx -> ipid = NULL ; return GF_OK ; } if ( ! gf_filter_pid_check_caps ( pid ) ) return GF_NOT_SUPPORTED ; ctx -> ipid = pid ; if ( ! ctx -> opid ) { ctx -> opid = gf_filter_pid_new ( filter ) ; gf_filter_pid_set_framing_mode ( ctx -> ipid , GF_TRUE ) ; is_first = GF_TRUE ; } gf_filter_pid_copy_properties ( ctx -> opid , ctx -> ipid ) ; gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_CODECID , & PROP_UINT ( GF_CODECID_RAW ) ) ; p = gf_filter_pid_get_property ( pid , GF_PROP_PID_DECODER_CONFIG ) ; if ( p && p -> value . data . ptr && p -> value . data . size ) { u32 ex_crc = gf_crc_32 ( p -> value . data . ptr , p -> value . data . size ) ; if ( ctx -> cfg_crc == ex_crc ) return GF_OK ; if ( ctx -> codec ) xvid_decore ( ctx -> codec , XVID_DEC_DESTROY , NULL , NULL ) ; ctx -> codec = NULL ; ctx -> cfg_crc = ex_crc ; } else if ( ! is_first ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODEC , ( "[XVID] Reconfiguring without DSI not yet supported\n" ) ) ; return GF_NOT_SUPPORTED ; } else { return GF_OK ; } e = gf_m4v_get_config ( p -> value . data . ptr , p -> value . data . size , & dsi ) ; if ( e ) return e ; if ( ! dsi . width || ! dsi . height ) return GF_NON_COMPLIANT_BITSTREAM ; memset ( & par , 0 , sizeof ( par ) ) ; par . width = dsi . width ; par . height = dsi . height ; ctx -> FPS = dsi . clock_rate ; ctx -> FPS /= 1000 ; if ( ! ctx -> FPS ) ctx -> FPS = 30.0f ; ctx -> pixel_ar . num = dsi . par_num ; ctx -> pixel_ar . den = dsi . par_den ; #ifndef XVID_USE_OLD_API par . version = XVID_VERSION ; #endif if ( xvid_decore ( NULL , XVID_DEC_CREATE , & par , NULL ) < 0 ) return GF_NON_COMPLIANT_BITSTREAM ; ctx -> width = par . width ; ctx -> height = par . height ; ctx -> codec = par . handle ; memset ( & frame , 0 , sizeof ( frame ) ) ; frame . bitstream = ( void * ) p -> value . data . ptr ; frame . length = p -> value . data . size ; #ifndef XVID_USE_OLD_API frame . version = XVID_VERSION ; xvid_decore ( ctx -> codec , XVID_DEC_DECODE , & frame , NULL ) ; #else xvid_decore ( ctx -> codec , XVID_DEC_DECODE , & frame , NULL ) ; #endif ctx -> first_frame = GF_TRUE ; ctx -> out_size = ctx -> width * ctx -> height * 3 / 2 ; gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_WIDTH , & PROP_UINT ( ctx -> width ) ) ; gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_HEIGHT , & PROP_UINT ( ctx -> height ) ) ; gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_STRIDE , & PROP_UINT ( ctx -> width ) ) ; gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_PAR , & PROP_FRAC ( ctx -> pixel_ar ) ) ; gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_PIXFMT , & PROP_UINT ( GF_PIXEL_YUV ) ) ; return GF_OK ; }
static VALUE from_document ( VALUE klass , VALUE document ) { xmlDocPtr doc ; xmlSchemaParserCtxtPtr ctx ; xmlSchemaPtr schema ; VALUE errors ; VALUE rb_schema ; Data_Get_Struct ( document , xmlDoc , doc ) ; doc = doc -> doc ; if ( has_blank_nodes_p ( DOC_NODE_CACHE ( doc ) ) ) { rb_raise ( rb_eArgError , "Creating a schema from a document that has blank nodes exposed to Ruby is dangerous" ) ; } ctx = xmlSchemaNewDocParserCtxt ( doc ) ; errors = rb_ary_new ( ) ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; #ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; #endif schema = xmlSchemaParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlSchemaFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , "Could not parse document" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , "@errors" , errors ) ; return rb_schema ; return Qnil ; }
static void Sp_split_regexp ( js_State * J ) { js_Regexp * re ; const char * text ; int limit , len , k ; const char * p , * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; limit = js_isdefined ( J , 2 ) ? js_tointeger ( J , 2 ) : 1 < < 30 ; js_newarray ( J ) ; len = 0 ; e = text + strlen ( text ) ; if ( e == text ) { if ( js_regexec ( re -> prog , text , & m , 0 ) ) { if ( len == limit ) return ; js_pushliteral ( J , "" ) ; js_setindex ( J , - 2 , 0 ) ; } return ; } p = a = text ; while ( a < e ) { if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; if ( b == p ) { ++ a ; continue ; } if ( len == limit ) return ; js_pushlstring ( J , p , b - p ) ; js_setindex ( J , - 2 , len ++ ) ; for ( k = 1 ; k < m . nsub ; ++ k ) { if ( len == limit ) return ; js_pushlstring ( J , m . sub [ k ] . sp , m . sub [ k ] . ep - m . sub [ k ] . sp ) ; js_setindex ( J , - 2 , len ++ ) ; } a = p = c ; } if ( len == limit ) return ; js_pushstring ( J , p ) ; js_setindex ( J , - 2 , len ) ; }
already_AddRefed < MediaResource > FileMediaResource :: CloneData ( MediaDecoder * aDecoder ) { NS_ASSERTION ( NS_IsMainThread ( ) , "Only call on main thread" ) ; MediaDecoderOwner * owner = mDecoder -> GetMediaOwner ( ) ; if ( ! owner ) { return nullptr ; } HTMLMediaElement * element = owner -> GetMediaElement ( ) ; if ( ! element ) { return nullptr ; } nsCOMPtr < nsILoadGroup > loadGroup = element -> GetDocumentLoadGroup ( ) ; NS_ENSURE_TRUE ( loadGroup , nullptr ) ; nsCOMPtr < nsIChannel > channel ; nsresult rv = NS_NewChannel ( getter_AddRefs ( channel ) , mURI , nullptr , loadGroup , nullptr , 0 ) ; if ( NS_FAILED ( rv ) ) return nullptr ; nsRefPtr < MediaResource > resource ( new FileMediaResource ( aDecoder , channel , mURI , GetContentType ( ) ) ) ; return resource . forget ( ) ; }
png_get_x_offset_pixels ( png_const_structrp png_ptr , png_const_inforp info_ptr ) { #ifdef PNG_oFFs_SUPPORTED if ( png_ptr != NULL && info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_oFFs ) ) { png_debug1 ( 1 , "in %s retrieval function" , "png_get_x_offset_pixels" ) ; if ( info_ptr -> offset_unit_type == PNG_OFFSET_PIXEL ) return ( info_ptr -> x_offset ) ; } #endif return ( 0 ) ; }
static int netlink_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; struct sockaddr_nl * addr = msg -> msg_name ; u32 dst_pid ; u32 dst_group ; struct sk_buff * skb ; int err ; struct scm_cookie scm ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; if ( NULL == siocb -> scm ) siocb -> scm = & scm ; err = scm_send ( sock , msg , siocb -> scm , true ) ; if ( err < 0 ) return err ; if ( msg -> msg_namelen ) { err = - EINVAL ; if ( addr -> nl_family != AF_NETLINK ) goto out ; dst_pid = addr -> nl_pid ; dst_group = ffs ( addr -> nl_groups ) ; err = - EPERM ; if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) goto out ; } else { dst_pid = nlk -> dst_pid ; dst_group = nlk -> dst_group ; } if ( ! nlk -> pid ) { err = netlink_autobind ( sock ) ; if ( err ) goto out ; } err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; err = - ENOBUFS ; skb = alloc_skb ( len , GFP_KERNEL ) ; if ( skb == NULL ) goto out ; NETLINK_CB ( skb ) . pid = nlk -> pid ; NETLINK_CB ( skb ) . dst_group = dst_group ; memcpy ( NETLINK_CREDS ( skb ) , & siocb -> scm -> creds , sizeof ( struct ucred ) ) ; err = - EFAULT ; if ( memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ) ) { kfree_skb ( skb ) ; goto out ; } err = security_netlink_send ( sk , skb ) ; if ( err ) { kfree_skb ( skb ) ; goto out ; } if ( dst_group ) { atomic_inc ( & skb -> users ) ; netlink_broadcast ( sk , skb , dst_pid , dst_group , GFP_KERNEL ) ; } err = netlink_unicast ( sk , skb , dst_pid , msg -> msg_flags & MSG_DONTWAIT ) ; out : scm_destroy ( siocb -> scm ) ; return err ; }
static int snd_ctl_elem_user_get ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { struct user_element * ue = kcontrol -> private_data ; memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ; return 0 ; }
sctp_asconf_timer ( struct sctp_inpcb * inp , struct sctp_tcb * stcb , struct sctp_nets * net ) { struct sctp_nets * alt ; struct sctp_tmit_chunk * asconf , * chk ; if ( TAILQ_EMPTY ( & stcb -> asoc . asconf_send_queue ) ) { sctp_send_asconf ( stcb , net , SCTP_ADDR_NOT_LOCKED ) ; } else { asconf = TAILQ_FIRST ( & stcb -> asoc . asconf_send_queue ) ; if ( asconf == NULL ) { return ( 0 ) ; } net = asconf -> whoTo ; if ( sctp_threshold_management ( inp , stcb , net , stcb -> asoc . max_send_times ) ) { return ( 1 ) ; } if ( asconf -> snd_count > stcb -> asoc . max_send_times ) { SCTPDBG ( SCTP_DEBUG_TIMER1 , "asconf_timer: Peer has not responded to our repeated ASCONFs\n" ) ; sctp_asconf_cleanup ( stcb ) ; return ( 0 ) ; } sctp_backoff_on_timeout ( stcb , net , 1 , 0 , 0 ) ; alt = sctp_find_alternate_net ( stcb , net , 0 ) ; if ( asconf -> whoTo != alt ) { asconf -> whoTo = alt ; atomic_add_int ( & alt -> ref_count , 1 ) ; } TAILQ_FOREACH ( chk , & stcb -> asoc . control_send_queue , sctp_next ) { if ( ( chk -> whoTo == net ) && ( chk -> rec . chunk_id . id == SCTP_ECN_ECHO ) ) { sctp_free_remote_addr ( chk -> whoTo ) ; chk -> whoTo = alt ; if ( chk -> sent != SCTP_DATAGRAM_RESEND ) { chk -> sent = SCTP_DATAGRAM_RESEND ; chk -> flags |= CHUNK_FLAGS_FRAGMENT_OK ; sctp_ucount_incr ( stcb -> asoc . sent_queue_retran_cnt ) ; } atomic_add_int ( & alt -> ref_count , 1 ) ; } } TAILQ_FOREACH ( chk , & stcb -> asoc . asconf_send_queue , sctp_next ) { if ( chk -> whoTo != alt ) { sctp_free_remote_addr ( chk -> whoTo ) ; chk -> whoTo = alt ; atomic_add_int ( & alt -> ref_count , 1 ) ; } if ( asconf -> sent != SCTP_DATAGRAM_RESEND && chk -> sent != SCTP_DATAGRAM_UNSENT ) sctp_ucount_incr ( stcb -> asoc . sent_queue_retran_cnt ) ; chk -> sent = SCTP_DATAGRAM_RESEND ; chk -> flags |= CHUNK_FLAGS_FRAGMENT_OK ; } if ( ! ( net -> dest_state & SCTP_ADDR_REACHABLE ) ) { sctp_move_chunks_from_net ( stcb , net ) ; } sctp_free_remote_addr ( net ) ; if ( asconf -> sent != SCTP_DATAGRAM_RESEND ) sctp_ucount_incr ( stcb -> asoc . sent_queue_retran_cnt ) ; asconf -> sent = SCTP_DATAGRAM_RESEND ; asconf -> flags |= CHUNK_FLAGS_FRAGMENT_OK ; sctp_send_asconf ( stcb , alt , SCTP_ADDR_NOT_LOCKED ) ; } return ( 0 ) ; }
TestHeapPostBarriers ( T initalObj ) { CHECK ( initalObj != nullptr ) ; CHECK ( js :: gc :: IsInsideNursery ( initalObj ) ) ; JS :: Heap < T > * heapData = new JS :: Heap < T > ( ) ; CHECK ( heapData ) ; CHECK ( heapData -> get ( ) == nullptr ) ; heapData -> set ( initalObj ) ; js :: MinorGC ( cx , JS :: gcreason :: API ) ; CHECK ( heapData -> get ( ) != initalObj ) ; CHECK ( ! js :: gc :: IsInsideNursery ( heapData -> get ( ) ) ) ; JS :: Rooted < T > obj ( cx , heapData -> get ( ) ) ; JS :: RootedValue value ( cx ) ; CHECK ( JS_GetProperty ( cx , obj , "x" , & value ) ) ; CHECK ( value . isInt32 ( ) ) ; CHECK ( value . toInt32 ( ) == 42 ) ; delete heapData ; return true ; }
Track :: Track ( unsigned int * seed ) : codec_id_ ( NULL ) , codec_private_ ( NULL ) , language_ ( NULL ) , max_block_additional_id_ ( 0 ) , name_ ( NULL ) , number_ ( 0 ) , type_ ( 0 ) , uid_ ( MakeUID ( seed ) ) , codec_delay_ ( 0 ) , seek_pre_roll_ ( 0 ) , codec_private_length_ ( 0 ) , content_encoding_entries_ ( NULL ) , content_encoding_entries_size_ ( 0 ) { }
v3d_submit_cl_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct v3d_dev * v3d = to_v3d_dev ( dev ) ; struct v3d_file_priv * v3d_priv = file_priv -> driver_priv ; struct drm_v3d_submit_cl * args = data ; struct v3d_bin_job * bin = NULL ; struct v3d_render_job * render ; struct ww_acquire_ctx acquire_ctx ; int ret = 0 ; trace_v3d_submit_cl_ioctl ( & v3d -> drm , args -> rcl_start , args -> rcl_end ) ; if ( args -> pad != 0 ) { DRM_INFO ( "pad must be zero: %d\n" , args -> pad ) ; return - EINVAL ; } render = kcalloc ( 1 , sizeof ( * render ) , GFP_KERNEL ) ; if ( ! render ) return - ENOMEM ; render -> start = args -> rcl_start ; render -> end = args -> rcl_end ; INIT_LIST_HEAD ( & render -> unref_list ) ; ret = v3d_job_init ( v3d , file_priv , & render -> base , v3d_render_job_free , args -> in_sync_rcl ) ; if ( ret ) { kfree ( render ) ; return ret ; } if ( args -> bcl_start != args -> bcl_end ) { bin = kcalloc ( 1 , sizeof ( * bin ) , GFP_KERNEL ) ; if ( ! bin ) return - ENOMEM ; ret = v3d_job_init ( v3d , file_priv , & bin -> base , v3d_job_free , args -> in_sync_bcl ) ; if ( ret ) { v3d_job_put ( & render -> base ) ; return ret ; } bin -> start = args -> bcl_start ; bin -> end = args -> bcl_end ; bin -> qma = args -> qma ; bin -> qms = args -> qms ; bin -> qts = args -> qts ; bin -> render = render ; } ret = v3d_lookup_bos ( dev , file_priv , & render -> base , args -> bo_handles , args -> bo_handle_count ) ; if ( ret ) goto fail ; ret = v3d_lock_bo_reservations ( & render -> base , & acquire_ctx ) ; if ( ret ) goto fail ; mutex_lock ( & v3d -> sched_lock ) ; if ( bin ) { ret = v3d_push_job ( v3d_priv , & bin -> base , V3D_BIN ) ; if ( ret ) goto fail_unreserve ; ret = drm_gem_fence_array_add ( & render -> base . deps , dma_fence_get ( bin -> base . done_fence ) ) ; if ( ret ) goto fail_unreserve ; } ret = v3d_push_job ( v3d_priv , & render -> base , V3D_RENDER ) ; if ( ret ) goto fail_unreserve ; mutex_unlock ( & v3d -> sched_lock ) ; v3d_attach_fences_and_unlock_reservation ( file_priv , & render -> base , & acquire_ctx , args -> out_sync , render -> base . done_fence ) ; if ( bin ) v3d_job_put ( & bin -> base ) ; v3d_job_put ( & render -> base ) ; return 0 ; fail_unreserve : mutex_unlock ( & v3d -> sched_lock ) ; drm_gem_unlock_reservations ( render -> base . bo , render -> base . bo_count , & acquire_ctx ) ; fail : if ( bin ) v3d_job_put ( & bin -> base ) ; v3d_job_put ( & render -> base ) ; return ret ; }
nsDocShell :: IsNavigationAllowed ( bool aDisplayPrintErrorDialog , bool aCheckIfUnloadFired ) { bool isAllowed = ! IsPrintingOrPP ( aDisplayPrintErrorDialog ) && ( ! aCheckIfUnloadFired || ! mFiredUnloadEvent ) && ! mBlockNavigation ; if ( ! isAllowed ) { return false ; } if ( ! mContentViewer ) { return true ; } bool firingBeforeUnload ; mContentViewer -> GetBeforeUnloadFiring ( & firingBeforeUnload ) ; return ! firingBeforeUnload ; }
TF_BUILTIN ( ArrayIncludesPackedDoubles , ArrayIncludesIndexofAssembler ) { Node * elements = Parameter ( Descriptor :: kElements ) ; Node * search_element = Parameter ( Descriptor :: kSearchElement ) ; Node * array_length = Parameter ( Descriptor :: kLength ) ; Node * from_index = Parameter ( Descriptor :: kFromIndex ) ; GeneratePackedDoubles ( kIncludes , elements , search_element , array_length , from_index ) ; }
nsDragService :: InvokeDragSession ( nsIDOMNode * aDOMNode , nsIArray * aArrayTransferables , nsIScriptableRegion * aRegion , uint32_t aActionType , nsContentPolicyType aContentPolicyType = nsIContentPolicy :: TYPE_OTHER ) { MOZ_LOG ( sDragLm , LogLevel :: Debug , ( "nsDragService::InvokeDragSession" ) ) ; if ( mSourceNode ) return NS_ERROR_NOT_AVAILABLE ; return nsBaseDragService :: InvokeDragSession ( aDOMNode , aArrayTransferables , aRegion , aActionType , aContentPolicyType ) ; }
stop_insert ( pos_T * end_insert_pos , int esc , int nomove ) { int cc ; char_u * ptr ; stop_redo_ins ( ) ; replace_flush ( ) ; ptr = get_inserted ( ) ; if ( did_restart_edit == 0 || ( ptr != NULL && ( int ) STRLEN ( ptr ) > new_insert_skip ) ) { vim_free ( last_insert ) ; last_insert = ptr ; last_insert_skip = new_insert_skip ; } else vim_free ( ptr ) ; if ( ! arrow_used && end_insert_pos != NULL ) { if ( ! ins_need_undo && has_format_option ( FO_AUTO ) ) { pos_T tpos = curwin -> w_cursor ; cc = 'x' ; if ( curwin -> w_cursor . col > 0 && gchar_cursor ( ) == NUL ) { dec_cursor ( ) ; cc = gchar_cursor ( ) ; if ( ! VIM_ISWHITE ( cc ) ) curwin -> w_cursor = tpos ; } auto_format ( TRUE , FALSE ) ; if ( VIM_ISWHITE ( cc ) ) { if ( gchar_cursor ( ) != NUL ) inc_cursor ( ) ; if ( gchar_cursor ( ) == NUL && curwin -> w_cursor . lnum == tpos . lnum && curwin -> w_cursor . col == tpos . col ) curwin -> w_cursor . coladd = tpos . coladd ; } } check_auto_format ( TRUE ) ; if ( ! nomove && did_ai && ( esc || ( vim_strchr ( p_cpo , CPO_INDENT ) == NULL && curwin -> w_cursor . lnum != end_insert_pos -> lnum ) ) && end_insert_pos -> lnum <= curbuf -> b_ml . ml_line_count ) { pos_T tpos = curwin -> w_cursor ; curwin -> w_cursor = * end_insert_pos ; check_cursor_col ( ) ; for ( ; ; ) { if ( gchar_cursor ( ) == NUL && curwin -> w_cursor . col > 0 ) -- curwin -> w_cursor . col ; cc = gchar_cursor ( ) ; if ( ! VIM_ISWHITE ( cc ) ) break ; if ( del_char ( TRUE ) == FAIL ) break ; } if ( curwin -> w_cursor . lnum != tpos . lnum ) curwin -> w_cursor = tpos ; else { tpos = curwin -> w_cursor ; tpos . col ++ ; if ( cc != NUL && gchar_pos ( & tpos ) == NUL ) ++ curwin -> w_cursor . col ; } if ( VIsual_active && VIsual . lnum == curwin -> w_cursor . lnum ) { int len = ( int ) STRLEN ( ml_get_curline ( ) ) ; if ( VIsual . col > len ) { VIsual . col = len ; VIsual . coladd = 0 ; } } } } did_ai = FALSE ; #ifdef FEAT_SMARTINDENT did_si = FALSE ; can_si = FALSE ; can_si_back = FALSE ; #endif if ( end_insert_pos != NULL ) { curbuf -> b_op_start = Insstart ; curbuf -> b_op_start_orig = Insstart_orig ; curbuf -> b_op_end = * end_insert_pos ; } }
void FallThruTo ( FullDecoder * decoder , Control * c ) { if ( c -> end_merge . reached ) { __ MergeFullStackWith ( c -> label_state ) ; } else if ( c -> is_onearmed_if ( ) ) { c -> label_state . InitMerge ( * __ cache_state ( ) , __ num_locals ( ) , c -> br_merge ( ) -> arity ) ; __ MergeFullStackWith ( c -> label_state ) ; } else { c -> label_state . Split ( * __ cache_state ( ) ) ; } TraceCacheState ( decoder ) ; }
static void opj_jp2_apply_pclr ( opj_image_t * image , opj_jp2_color_t * color ) { opj_image_comp_t * old_comps , * new_comps ; OPJ_BYTE * channel_size , * channel_sign ; OPJ_UINT32 * entries ; opj_jp2_cmap_comp_t * cmap ; OPJ_INT32 * src , * dst ; OPJ_UINT32 j , max ; OPJ_UINT16 i , nr_channels , cmp , pcol ; OPJ_INT32 k , top_k ; channel_size = color -> jp2_pclr -> channel_size ; channel_sign = color -> jp2_pclr -> channel_sign ; entries = color -> jp2_pclr -> entries ; cmap = color -> jp2_pclr -> cmap ; nr_channels = color -> jp2_pclr -> nr_channels ; old_comps = image -> comps ; new_comps = ( opj_image_comp_t * ) opj_malloc ( nr_channels * sizeof ( opj_image_comp_t ) ) ; if ( ! new_comps ) { return ; } for ( i = 0 ; i < nr_channels ; ++ i ) { pcol = cmap [ i ] . pcol ; cmp = cmap [ i ] . cmp ; if ( cmap [ i ] . mtyp == 0 ) { assert ( pcol == 0 ) ; new_comps [ i ] = old_comps [ cmp ] ; } else { assert ( i == pcol ) ; new_comps [ pcol ] = old_comps [ cmp ] ; } new_comps [ i ] . data = ( OPJ_INT32 * ) opj_malloc ( old_comps [ cmp ] . w * old_comps [ cmp ] . h * sizeof ( OPJ_INT32 ) ) ; if ( ! new_comps [ i ] . data ) { opj_free ( new_comps ) ; new_comps = NULL ; return ; } new_comps [ i ] . prec = channel_size [ i ] ; new_comps [ i ] . sgnd = channel_sign [ i ] ; } top_k = color -> jp2_pclr -> nr_entries - 1 ; for ( i = 0 ; i < nr_channels ; ++ i ) { cmp = cmap [ i ] . cmp ; pcol = cmap [ i ] . pcol ; src = old_comps [ cmp ] . data ; assert ( src ) ; max = new_comps [ pcol ] . w * new_comps [ pcol ] . h ; if ( cmap [ i ] . mtyp == 0 ) { assert ( cmp == 0 ) ; dst = new_comps [ i ] . data ; assert ( dst ) ; for ( j = 0 ; j < max ; ++ j ) { dst [ j ] = src [ j ] ; } } else { assert ( i == pcol ) ; dst = new_comps [ pcol ] . data ; assert ( dst ) ; for ( j = 0 ; j < max ; ++ j ) { if ( ( k = src [ j ] ) < 0 ) k = 0 ; else if ( k > top_k ) k = top_k ; dst [ j ] = ( OPJ_INT32 ) entries [ k * nr_channels + pcol ] ; } } } max = image -> numcomps ; for ( i = 0 ; i < max ; ++ i ) { if ( old_comps [ i ] . data ) opj_free ( old_comps [ i ] . data ) ; } opj_free ( old_comps ) ; image -> comps = new_comps ; image -> numcomps = nr_channels ; opj_jp2_free_pclr ( color ) ; }
static int em_sysenter ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data ; u16 cs_sel , ss_sel ; u64 efer = 0 ; ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) return emulate_gp ( ctxt , 0 ) ; if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA ) && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) return X86EMUL_UNHANDLEABLE ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; switch ( ctxt -> mode ) { case X86EMUL_MODE_PROT32 : if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; break ; case X86EMUL_MODE_PROT64 : if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; break ; default : break ; } ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF ) ; cs_sel = ( u16 ) msr_data ; cs_sel &= ~ SELECTOR_RPL_MASK ; ss_sel = cs_sel + 8 ; ss_sel &= ~ SELECTOR_RPL_MASK ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) { cs . d = 0 ; cs . l = 1 ; } ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_EIP , & msr_data ) ; ctxt -> _eip = msr_data ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_ESP , & msr_data ) ; * reg_write ( ctxt , VCPU_REGS_RSP ) = msr_data ; return X86EMUL_CONTINUE ; }
reg . prepare = [ ] ( TfLiteContext * context , TfLiteNode * node ) { - const TfLiteTensor * tensor0 = GetInput ( context , node , 0 ) ; - TfLiteTensor * tensor1 = GetOutput ( context , node , 0 ) ; + const TfLiteTensor * tensor0 ; + TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , 0 , & tensor0 ) ) ; + TfLiteTensor * tensor1 ; + TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , 0 , & tensor1 ) ) ; TfLiteIntArray * newSize = TfLiteIntArrayCopy ( tensor0 -> dims ) ; return context -> ResizeTensor ( context , tensor1 , newSize ) ; } ;
TF_BUILTIN ( ToNumber , CodeStubAssembler ) { Node * context = Parameter ( Descriptor :: kContext ) ; Node * input = Parameter ( Descriptor :: kArgument ) ; Return ( ToNumber ( context , input ) ) ; }
static int mpage_da_map_blocks ( struct mpage_da_data * mpd ) { int err , blks , get_blocks_flags ; struct buffer_head new ; sector_t next = mpd -> b_blocknr ; unsigned max_blocks = mpd -> b_size > > mpd -> inode -> i_blkbits ; loff_t disksize = EXT4_I ( mpd -> inode ) -> i_disksize ; handle_t * handle = NULL ; if ( ( mpd -> b_state & ( 1 < < BH_Mapped ) ) && ! ( mpd -> b_state & ( 1 < < BH_Delay ) ) && ! ( mpd -> b_state & ( 1 < < BH_Unwritten ) ) ) return 0 ; if ( ! mpd -> b_size ) return 0 ; handle = ext4_journal_current_handle ( ) ; BUG_ON ( ! handle ) ; new . b_state = 0 ; get_blocks_flags = EXT4_GET_BLOCKS_CREATE ; if ( mpd -> b_state & ( 1 < < BH_Delay ) ) get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE ; blks = ext4_get_blocks ( handle , mpd -> inode , next , max_blocks , & new , get_blocks_flags ) ; if ( blks < 0 ) { err = blks ; if ( err == - EAGAIN ) return 0 ; if ( err == - ENOSPC && ext4_count_free_blocks ( mpd -> inode -> i_sb ) ) { mpd -> retval = err ; return 0 ; } ext4_msg ( mpd -> inode -> i_sb , KERN_CRIT , "delayed block allocation failed for inode %lu at " "logical offset %llu with max blocks %zd with " "error %d\n" , mpd -> inode -> i_ino , ( unsigned long long ) next , mpd -> b_size > > mpd -> inode -> i_blkbits , err ) ; printk ( KERN_CRIT "This should not happen!!  " "Data will be lost\n" ) ; if ( err == - ENOSPC ) { ext4_print_free_blocks ( mpd -> inode ) ; } ext4_da_block_invalidatepages ( mpd , next , mpd -> b_size > > mpd -> inode -> i_blkbits ) ; return err ; } BUG_ON ( blks == 0 ) ; new . b_size = ( blks < < mpd -> inode -> i_blkbits ) ; if ( buffer_new ( & new ) ) __unmap_underlying_blocks ( mpd -> inode , & new ) ; if ( ( mpd -> b_state & ( 1 < < BH_Delay ) ) || ( mpd -> b_state & ( 1 < < BH_Unwritten ) ) ) mpage_put_bnr_to_bhs ( mpd , next , & new ) ; if ( ext4_should_order_data ( mpd -> inode ) ) { err = ext4_jbd2_file_inode ( handle , mpd -> inode ) ; if ( err ) return err ; } disksize = ( ( loff_t ) next + blks ) < < mpd -> inode -> i_blkbits ; if ( disksize > i_size_read ( mpd -> inode ) ) disksize = i_size_read ( mpd -> inode ) ; if ( disksize > EXT4_I ( mpd -> inode ) -> i_disksize ) { ext4_update_i_disksize ( mpd -> inode , disksize ) ; return ext4_mark_inode_dirty ( handle , mpd -> inode ) ; } return 0 ; }
nsDocShell :: OnLinkClickSync ( nsIContent * aContent , nsIURI * aURI , const char16_t * aTargetSpec , const nsAString & aFileName , nsIInputStream * aPostDataStream , nsIInputStream * aHeadersDataStream , nsIDocShell * * aDocShell , nsIRequest * * aRequest ) { if ( aDocShell ) { * aDocShell = nullptr ; } if ( aRequest ) { * aRequest = nullptr ; } if ( ! IsNavigationAllowed ( ) || ! IsOKToLoadURI ( aURI ) ) { return NS_OK ; } if ( aContent -> IsHTMLElement ( nsGkAtoms :: form ) && ShouldBlockLoadingForBackButton ( ) ) { return NS_OK ; } if ( aContent -> IsEditable ( ) ) { return NS_OK ; } { nsCOMPtr < nsIExternalProtocolService > extProtService = do_GetService ( NS_EXTERNALPROTOCOLSERVICE_CONTRACTID ) ; if ( extProtService ) { nsAutoCString scheme ; aURI -> GetScheme ( scheme ) ; if ( ! scheme . IsEmpty ( ) ) { bool isExposed ; nsresult rv = extProtService -> IsExposedProtocol ( scheme . get ( ) , & isExposed ) ; if ( NS_SUCCEEDED ( rv ) && ! isExposed ) { return extProtService -> LoadURI ( aURI , this ) ; } } } } uint32_t flags = INTERNAL_LOAD_FLAGS_NONE ; if ( IsElementAnchor ( aContent ) ) { MOZ_ASSERT ( aContent -> IsHTMLElement ( ) ) ; nsAutoString referrer ; aContent -> GetAttr ( kNameSpaceID_None , nsGkAtoms :: rel , referrer ) ; nsWhitespaceTokenizerTemplate < nsContentUtils :: IsHTMLWhitespace > tok ( referrer ) ; while ( tok . hasMoreTokens ( ) ) { if ( tok . nextToken ( ) . LowerCaseEqualsLiteral ( "noreferrer" ) ) { flags |= INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER | INTERNAL_LOAD_FLAGS_NO_OPENER ; break ; } } } nsCOMPtr < nsIDocument > refererDoc = aContent -> OwnerDoc ( ) ; NS_ENSURE_TRUE ( refererDoc , NS_ERROR_UNEXPECTED ) ; nsPIDOMWindow * refererInner = refererDoc -> GetInnerWindow ( ) ; NS_ENSURE_TRUE ( refererInner , NS_ERROR_UNEXPECTED ) ; if ( ! mScriptGlobal || mScriptGlobal -> GetCurrentInnerWindow ( ) != refererInner ) { return NS_OK ; } nsCOMPtr < nsIURI > referer = refererDoc -> GetDocumentURI ( ) ; uint32_t refererPolicy = refererDoc -> GetReferrerPolicy ( ) ; if ( IsElementAnchor ( aContent ) ) { net :: ReferrerPolicy refPolEnum = aContent -> AsElement ( ) -> GetReferrerPolicy ( ) ; if ( refPolEnum != net :: RP_Unset ) { refererPolicy = refPolEnum ; } } nsAutoString target ( aTargetSpec ) ; nsAutoString typeHint ; nsCOMPtr < nsIDOMHTMLAnchorElement > anchor ( do_QueryInterface ( aContent ) ) ; if ( anchor ) { anchor -> GetType ( typeHint ) ; NS_ConvertUTF16toUTF8 utf8Hint ( typeHint ) ; nsAutoCString type , dummy ; NS_ParseContentType ( utf8Hint , type , dummy ) ; CopyUTF8toUTF16 ( type , typeHint ) ; } nsCOMPtr < nsIURI > clonedURI ; aURI -> Clone ( getter_AddRefs ( clonedURI ) ) ; if ( ! clonedURI ) { return NS_ERROR_OUT_OF_MEMORY ; } nsresult rv = InternalLoad ( clonedURI , nullptr , false , referer , refererPolicy , aContent -> NodePrincipal ( ) , flags , target . get ( ) , NS_LossyConvertUTF16toASCII ( typeHint ) . get ( ) , aFileName , aPostDataStream , aHeadersDataStream , LOAD_LINK , nullptr , true , NullString ( ) , this , nullptr , aDocShell , aRequest ) ; if ( NS_SUCCEEDED ( rv ) ) { DispatchPings ( this , aContent , aURI , referer , refererPolicy ) ; } return rv ; }
FieldAccess AccessBuilder :: ForArgumentsCallee ( ) { FieldAccess access = { kTaggedBase , JSSloppyArgumentsObject :: kCalleeOffset , Handle < Name > ( ) , MaybeHandle < Map > ( ) , Type :: NonInternal ( ) , MachineType :: AnyTagged ( ) , kPointerWriteBarrier } ; return access ; }
ChannelWrapper :: RegisterTraceableChannel ( const WebExtensionPolicy & aAddon , nsITabParent * aTabParent ) { if ( mResponseStarted ) { return ; } mAddonEntries . Put ( aAddon . Id ( ) , aTabParent ) ; if ( ! mChannelEntry ) { mChannelEntry = WebRequestService :: GetSingleton ( ) . RegisterChannel ( this ) ; CheckEventListeners ( ) ; } }
bool ScopeIterator :: SetModuleVariableValue ( Handle < String > variable_name , Handle < Object > new_value ) { int cell_index ; VariableMode mode ; InitializationFlag init_flag ; MaybeAssignedFlag maybe_assigned_flag ; cell_index = context_ -> scope_info ( ) -> ModuleIndex ( variable_name , & mode , & init_flag , & maybe_assigned_flag ) ; if ( ModuleDescriptor :: GetCellIndexKind ( cell_index ) != ModuleDescriptor :: kExport ) { return false ; } Handle < Module > module ( context_ -> module ( ) , isolate_ ) ; Module :: StoreVariable ( module , cell_index , new_value ) ; return true ; }
void ReduceBuiltin ( JSGraph * jsgraph , Node * node , int builtin_index , int arity , CallDescriptor :: Flags flags ) { const bool is_construct = ( node -> opcode ( ) == IrOpcode :: kJSConstruct ) ; DCHECK ( Builtins :: HasCppImplementation ( builtin_index ) ) ; Node * target = NodeProperties :: GetValueInput ( node , 0 ) ; Node * new_target = is_construct ? NodeProperties :: GetValueInput ( node , arity + 1 ) : jsgraph -> UndefinedConstant ( ) ; const bool has_builtin_exit_frame = Builtins :: IsCpp ( builtin_index ) ; Node * stub = jsgraph -> CEntryStubConstant ( 1 , kDontSaveFPRegs , kArgvOnStack , has_builtin_exit_frame ) ; node -> ReplaceInput ( 0 , stub ) ; Zone * zone = jsgraph -> zone ( ) ; if ( is_construct ) { Node * receiver = jsgraph -> UndefinedConstant ( ) ; node -> RemoveInput ( arity + 1 ) ; node -> InsertInput ( zone , 1 , receiver ) ; } const int argc = arity + BuiltinArguments :: kNumExtraArgsWithReceiver ; Node * argc_node = jsgraph -> Constant ( argc ) ; static const int kStubAndReceiver = 2 ; int cursor = arity + kStubAndReceiver ; node -> InsertInput ( zone , cursor ++ , jsgraph -> PaddingConstant ( ) ) ; node -> InsertInput ( zone , cursor ++ , argc_node ) ; node -> InsertInput ( zone , cursor ++ , target ) ; node -> InsertInput ( zone , cursor ++ , new_target ) ; Address entry = Builtins :: CppEntryOf ( builtin_index ) ; ExternalReference entry_ref = ExternalReference :: Create ( entry ) ; Node * entry_node = jsgraph -> ExternalConstant ( entry_ref ) ; node -> InsertInput ( zone , cursor ++ , entry_node ) ; node -> InsertInput ( zone , cursor ++ , argc_node ) ; static const int kReturnCount = 1 ; const char * debug_name = Builtins :: name ( builtin_index ) ; Operator :: Properties properties = node -> op ( ) -> properties ( ) ; auto call_descriptor = Linkage :: GetCEntryStubCallDescriptor ( zone , kReturnCount , argc , debug_name , properties , flags ) ; NodeProperties :: ChangeOp ( node , jsgraph -> common ( ) -> Call ( call_descriptor ) ) ; }
MessageEvent :: GetData ( JSContext * aCx , ErrorResult & aRv ) { JS :: Rooted < JS :: Value > data ( aCx , mData ) ; if ( ! JS_WrapValue ( aCx , & data ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; } return data ; }
njs_promise_resolve ( njs_vm_t * vm , njs_value_t * constructor , njs_value_t * x ) { njs_int_t ret ; njs_value_t value ; njs_object_t * object ; njs_promise_capability_t * capability ; static const njs_value_t string_constructor = njs_string ( "constructor" ) ; if ( njs_is_object ( x ) ) { object = njs_object_proto_lookup ( njs_object ( x ) , NJS_PROMISE , njs_object_t ) ; if ( object != NULL ) { ret = njs_value_property ( vm , x , njs_value_arg ( & string_constructor ) , & value ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return NULL ; } if ( njs_values_same ( & value , constructor ) ) { return njs_promise ( x ) ; } } } capability = njs_promise_new_capability ( vm , constructor ) ; if ( njs_slow_path ( capability == NULL ) ) { return NULL ; } ret = njs_function_call ( vm , njs_function ( & capability -> resolve ) , & njs_value_undefined , x , 1 , & value ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return NULL ; } return njs_promise ( & capability -> promise ) ; }
nsBaseChannel :: BeginPumpingData ( ) { nsCOMPtr < nsIInputStream > stream ; nsresult rv = OpenContentStream ( PR_TRUE , getter_AddRefs ( stream ) ) ; if ( NS_FAILED ( rv ) ) return rv ; rv = nsInputStreamPump :: Create ( getter_AddRefs ( mPump ) , stream , - 1 , - 1 , 0 , 0 , PR_TRUE ) ; if ( NS_SUCCEEDED ( rv ) ) rv = mPump -> AsyncRead ( this , nsnull ) ; return rv ; }
find_extend_vma ( struct mm_struct * mm , unsigned long addr ) { struct vm_area_struct * vma ; unsigned long start ; addr &= PAGE_MASK ; vma = find_vma ( mm , addr ) ; if ( ! vma ) return NULL ; if ( vma -> vm_start <= addr ) return vma ; if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) return NULL ; start = vma -> vm_start ; if ( expand_stack ( vma , addr ) ) return NULL ; if ( vma -> vm_flags & VM_LOCKED ) populate_vma_page_range ( vma , addr , start , NULL ) ; return vma ; }
nsGIFDecoder2 :: DoLzw ( const uint8_t * q ) { if ( ! mGIFStruct . rows_remaining ) return true ; int avail = mGIFStruct . avail ; int bits = mGIFStruct . bits ; int codesize = mGIFStruct . codesize ; int codemask = mGIFStruct . codemask ; int count = mGIFStruct . count ; int oldcode = mGIFStruct . oldcode ; const int clear_code = ClearCode ( ) ; uint8_t firstchar = mGIFStruct . firstchar ; int32_t datum = mGIFStruct . datum ; uint16_t * prefix = mGIFStruct . prefix ; uint8_t * stackp = mGIFStruct . stackp ; uint8_t * suffix = mGIFStruct . suffix ; uint8_t * stack = mGIFStruct . stack ; uint8_t * rowp = mGIFStruct . rowp ; uint32_t bpr = mGIFStruct . width ; if ( ! mGIFStruct . images_decoded ) bpr *= sizeof ( uint32_t ) ; uint8_t * rowend = mImageData + ( bpr * mGIFStruct . irow ) + mGIFStruct . width ; #define OUTPUT_ROW()                                        \   PR_BEGIN_MACRO                                            \     if (!OutputRow())                                       \       goto END;                                             \     rowp = mImageData + mGIFStruct.irow * bpr;              \     rowend = rowp + mGIFStruct.width;                       \   PR_END_MACRO for ( const uint8_t * ch = q ; count -- > 0 ; ch ++ ) { datum += ( ( int32_t ) * ch ) < < bits ; bits += 8 ; while ( bits >= codesize ) { int code = datum & codemask ; datum >>= codesize ; bits -= codesize ; if ( code == clear_code ) { codesize = mGIFStruct . datasize + 1 ; codemask = ( 1 < < codesize ) - 1 ; avail = clear_code + 2 ; oldcode = - 1 ; continue ; } if ( code == ( clear_code + 1 ) ) { return ( mGIFStruct . rows_remaining == 0 ) ; } if ( oldcode == - 1 ) { if ( code >= MAX_BITS ) return false ; * rowp ++ = suffix [ code ] ; if ( rowp == rowend ) OUTPUT_ROW ( ) ; firstchar = oldcode = code ; continue ; } int incode = code ; if ( code >= avail ) { * stackp ++ = firstchar ; code = oldcode ; if ( stackp >= stack + MAX_BITS ) return false ; } while ( code >= clear_code ) { if ( ( code >= MAX_BITS ) || ( code == prefix [ code ] ) ) return false ; * stackp ++ = suffix [ code ] ; code = prefix [ code ] ; if ( stackp == stack + MAX_BITS ) return false ; } * stackp ++ = firstchar = suffix [ code ] ; if ( avail < 4096 ) { prefix [ avail ] = oldcode ; suffix [ avail ] = firstchar ; avail ++ ; if ( ( ( avail & codemask ) == 0 ) && ( avail < 4096 ) ) { codesize ++ ; codemask += avail ; } } oldcode = incode ; do { * rowp ++ = * -- stackp ; if ( rowp == rowend ) OUTPUT_ROW ( ) ; } while ( stackp > stack ) ; } } END : mGIFStruct . avail = avail ; mGIFStruct . bits = bits ; mGIFStruct . codesize = codesize ; mGIFStruct . codemask = codemask ; mGIFStruct . count = count ; mGIFStruct . oldcode = oldcode ; mGIFStruct . firstchar = firstchar ; mGIFStruct . datum = datum ; mGIFStruct . stackp = stackp ; mGIFStruct . rowp = rowp ; return true ; }
Parser :: LazyParsingResult Parser :: SkipFunction ( const AstRawString * function_name , FunctionKind kind , FunctionLiteral :: FunctionType function_type , DeclarationScope * function_scope , int * num_parameters , ProducedPreParsedScopeData * * produced_preparsed_scope_data , bool is_inner_function , bool may_abort , bool * ok ) { FunctionState function_state ( & function_state_ , & scope_ , function_scope ) ; DCHECK_NE ( kNoSourcePosition , function_scope -> start_position ( ) ) ; DCHECK_EQ ( kNoSourcePosition , parameters_end_pos_ ) ; DCHECK_IMPLIES ( IsArrowFunction ( kind ) , scanner ( ) -> current_token ( ) == Token :: ARROW ) ; DCHECK_NOT_NULL ( consumed_preparsed_scope_data_ ) ; if ( consumed_preparsed_scope_data_ -> HasData ( ) ) { DCHECK ( FLAG_preparser_scope_analysis ) ; int end_position ; LanguageMode language_mode ; int num_inner_functions ; bool uses_super_property ; * produced_preparsed_scope_data = consumed_preparsed_scope_data_ -> GetDataForSkippableFunction ( main_zone ( ) , function_scope -> start_position ( ) , & end_position , num_parameters , & num_inner_functions , & uses_super_property , & language_mode ) ; function_scope -> outer_scope ( ) -> SetMustUsePreParsedScopeData ( ) ; function_scope -> set_is_skipped_function ( true ) ; function_scope -> set_end_position ( end_position ) ; scanner ( ) -> SeekForward ( end_position - 1 ) ; Expect ( Token :: RBRACE , CHECK_OK_VALUE ( kLazyParsingComplete ) ) ; SetLanguageMode ( function_scope , language_mode ) ; if ( uses_super_property ) { function_scope -> RecordSuperPropertyUsage ( ) ; } SkipFunctionLiterals ( num_inner_functions ) ; return kLazyParsingComplete ; } TRACE_EVENT0 ( TRACE_DISABLED_BY_DEFAULT ( "v8.compile" ) , "V8.PreParse" ) ; DCHECK ( ! is_inner_function || ! may_abort ) ; PreParser :: PreParseResult result = reusable_preparser ( ) -> PreParseFunction ( function_name , kind , function_type , function_scope , is_inner_function , may_abort , use_counts_ , produced_preparsed_scope_data , this -> script_id ( ) ) ; if ( result == PreParser :: kPreParseAbort ) return kLazyParsingAborted ; if ( result == PreParser :: kPreParseStackOverflow ) { set_stack_overflow ( ) ; * ok = false ; return kLazyParsingComplete ; } if ( pending_error_handler ( ) -> has_pending_error ( ) ) { * ok = false ; return kLazyParsingComplete ; } set_allow_eval_cache ( reusable_preparser ( ) -> allow_eval_cache ( ) ) ; PreParserLogger * logger = reusable_preparser ( ) -> logger ( ) ; function_scope -> set_end_position ( logger -> end ( ) ) ; Expect ( Token :: RBRACE , CHECK_OK_VALUE ( kLazyParsingComplete ) ) ; total_preparse_skipped_ += function_scope -> end_position ( ) - function_scope -> start_position ( ) ; * num_parameters = logger -> num_parameters ( ) ; SkipFunctionLiterals ( logger -> num_inner_functions ( ) ) ; return kLazyParsingComplete ; }
static PARTITION_TYPE read_partition ( VP9_COMMON * cm , MACROBLOCKD * xd , int hbs , int mi_row , int mi_col , BLOCK_SIZE bsize , vp9_reader * r ) { const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ; const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ; const int has_cols = ( mi_col + hbs ) < cm -> mi_cols ; PARTITION_TYPE p ; if ( has_rows && has_cols ) p = ( PARTITION_TYPE ) vp9_read_tree ( r , vp9_partition_tree , probs ) ; else if ( ! has_rows && has_cols ) p = vp9_read ( r , probs [ 1 ] ) ? PARTITION_SPLIT : PARTITION_HORZ ; else if ( has_rows && ! has_cols ) p = vp9_read ( r , probs [ 2 ] ) ? PARTITION_SPLIT : PARTITION_VERT ; else p = PARTITION_SPLIT ; if ( ! cm -> frame_parallel_decoding_mode ) ++ cm -> counts . partition [ ctx ] [ p ] ; return p ; }
already_AddRefed < Promise > FetchRequest ( nsIGlobalObject * aGlobal , const RequestOrUSVString & aInput , const RequestInit & aInit , CallerType aCallerType , ErrorResult & aRv ) { RefPtr < Promise > p = Promise :: Create ( aGlobal , aRv ) ; if ( NS_WARN_IF ( aRv . Failed ( ) ) ) { return nullptr ; } MOZ_ASSERT ( aGlobal ) ; MOZ_ASSERT_IF ( aInput . IsRequest ( ) && aInput . GetAsRequest ( ) . IsContentPolicyTypeOverridden ( ) , aCallerType == CallerType :: System ) ; AutoJSAPI jsapi ; if ( ! jsapi . Init ( aGlobal ) ) { aRv . Throw ( NS_ERROR_NOT_AVAILABLE ) ; return nullptr ; } JSContext * cx = jsapi . cx ( ) ; JS :: Rooted < JSObject * > jsGlobal ( cx , aGlobal -> GetGlobalJSObject ( ) ) ; GlobalObject global ( cx , jsGlobal ) ; SafeRefPtr < Request > request = Request :: Constructor ( global , aInput , aInit , aRv ) ; if ( aRv . Failed ( ) ) { return nullptr ; } SafeRefPtr < InternalRequest > r = request -> GetInternalRequest ( ) ; RefPtr < AbortSignalImpl > signalImpl = request -> GetSignalImpl ( ) ; if ( signalImpl && signalImpl -> Aborted ( ) ) { aRv . Throw ( NS_ERROR_DOM_ABORT_ERR ) ; return nullptr ; } JS :: Realm * realm = JS :: GetCurrentRealmOrNull ( cx ) ; if ( realm && JS :: GetDebuggerObservesWasm ( realm ) ) { r -> SetSkipWasmCaching ( ) ; } RefPtr < FetchObserver > observer ; if ( aInit . mObserve . WasPassed ( ) ) { observer = new FetchObserver ( aGlobal , signalImpl ) ; aInit . mObserve . Value ( ) . HandleEvent ( * observer ) ; } if ( NS_IsMainThread ( ) ) { nsCOMPtr < nsPIDOMWindowInner > window = do_QueryInterface ( aGlobal ) ; nsCOMPtr < Document > doc ; nsCOMPtr < nsILoadGroup > loadGroup ; nsCOMPtr < nsICookieJarSettings > cookieJarSettings ; nsIPrincipal * principal ; bool isTrackingFetch = false ; if ( window ) { doc = window -> GetExtantDoc ( ) ; if ( ! doc ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return nullptr ; } principal = doc -> NodePrincipal ( ) ; loadGroup = doc -> GetDocumentLoadGroup ( ) ; cookieJarSettings = doc -> CookieJarSettings ( ) ; isTrackingFetch = doc -> IsScriptTracking ( cx ) ; } else { principal = aGlobal -> PrincipalOrNull ( ) ; if ( NS_WARN_IF ( ! principal ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return nullptr ; } cookieJarSettings = mozilla :: net :: CookieJarSettings :: Create ( principal ) ; } if ( ! loadGroup ) { nsresult rv = NS_NewLoadGroup ( getter_AddRefs ( loadGroup ) , principal ) ; if ( NS_WARN_IF ( NS_FAILED ( rv ) ) ) { aRv . Throw ( rv ) ; return nullptr ; } } RefPtr < MainThreadFetchResolver > resolver = new MainThreadFetchResolver ( p , observer , signalImpl , request -> MozErrors ( ) ) ; RefPtr < FetchDriver > fetch = new FetchDriver ( std :: move ( r ) , principal , loadGroup , aGlobal -> EventTargetFor ( TaskCategory :: Other ) , cookieJarSettings , nullptr , isTrackingFetch ) ; fetch -> SetDocument ( doc ) ; resolver -> SetLoadGroup ( loadGroup ) ; aRv = fetch -> Fetch ( signalImpl , resolver ) ; if ( NS_WARN_IF ( aRv . Failed ( ) ) ) { return nullptr ; } } else { WorkerPrivate * worker = GetCurrentThreadWorkerPrivate ( ) ; MOZ_ASSERT ( worker ) ; if ( worker -> IsServiceWorker ( ) ) { r -> SetSkipServiceWorker ( ) ; } RefPtr < WorkerFetchResolver > resolver = WorkerFetchResolver :: Create ( worker , p , signalImpl , observer ) ; if ( ! resolver ) { NS_WARNING ( "Could not keep the worker alive." ) ; aRv . Throw ( NS_ERROR_DOM_ABORT_ERR ) ; return nullptr ; } Maybe < ClientInfo > clientInfo ( worker -> GlobalScope ( ) -> GetClientInfo ( ) ) ; if ( clientInfo . isNothing ( ) ) { aRv . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return nullptr ; } UniquePtr < SerializedStackHolder > stack ; if ( worker -> IsWatchedByDevTools ( ) ) { stack = GetCurrentStackForNetMonitor ( cx ) ; } RefPtr < MainThreadFetchRunnable > run = new MainThreadFetchRunnable ( resolver , clientInfo . ref ( ) , worker -> GlobalScope ( ) -> GetController ( ) , worker -> CSPEventListener ( ) , std :: move ( r ) , std :: move ( stack ) ) ; worker -> DispatchToMainThread ( run . forget ( ) ) ; } return p . forget ( ) ; }
RUNTIME_FUNCTION ( Runtime_HaveSameMap ) { SealHandleScope shs ( isolate ) ; DCHECK_EQ ( 2 , args . length ( ) ) ; CONVERT_ARG_CHECKED ( JSObject , obj1 , 0 ) ; CONVERT_ARG_CHECKED ( JSObject , obj2 , 1 ) ; return isolate -> heap ( ) -> ToBoolean ( obj1 -> map ( ) == obj2 -> map ( ) ) ; }
void Run ( PipelineData * data , Zone * temp_zone ) { GraphReducer graph_reducer ( temp_zone , data -> graph ( ) , data -> jsgraph ( ) -> Dead ( ) ) ; BranchElimination branch_condition_elimination ( & graph_reducer , data -> jsgraph ( ) , temp_zone ) ; DeadCodeElimination dead_code_elimination ( & graph_reducer , data -> graph ( ) , data -> common ( ) , temp_zone ) ; ValueNumberingReducer value_numbering ( temp_zone , data -> graph ( ) -> zone ( ) ) ; MachineOperatorReducer machine_reducer ( data -> jsgraph ( ) ) ; CommonOperatorReducer common_reducer ( & graph_reducer , data -> graph ( ) , data -> js_heap_broker ( ) , data -> common ( ) , data -> machine ( ) , temp_zone ) ; SelectLowering select_lowering ( data -> jsgraph ( ) -> graph ( ) , data -> jsgraph ( ) -> common ( ) ) ; AddReducer ( data , & graph_reducer , & branch_condition_elimination ) ; AddReducer ( data , & graph_reducer , & dead_code_elimination ) ; AddReducer ( data , & graph_reducer , & machine_reducer ) ; AddReducer ( data , & graph_reducer , & common_reducer ) ; AddReducer ( data , & graph_reducer , & select_lowering ) ; AddReducer ( data , & graph_reducer , & value_numbering ) ; graph_reducer . ReduceGraph ( ) ; }
void CompilerDispatcher :: WaitForJobIfRunningOnBackground ( CompilerDispatcherJob * job ) { TRACE_EVENT0 ( TRACE_DISABLED_BY_DEFAULT ( "v8.compile" ) , "V8.CompilerDispatcherWaitForBackgroundJob" ) ; RuntimeCallTimerScope runtimeTimer ( isolate_ , RuntimeCallCounterId :: kCompileWaitForDispatcher ) ; base :: LockGuard < base :: Mutex > lock ( & mutex_ ) ; if ( running_background_jobs_ . find ( job ) == running_background_jobs_ . end ( ) ) { pending_background_jobs_ . erase ( job ) ; return ; } DCHECK_NULL ( main_thread_blocking_on_job_ ) ; main_thread_blocking_on_job_ = job ; while ( main_thread_blocking_on_job_ != nullptr ) { main_thread_blocking_signal_ . Wait ( & mutex_ ) ; } DCHECK ( pending_background_jobs_ . find ( job ) == pending_background_jobs_ . end ( ) ) ; DCHECK ( running_background_jobs_ . find ( job ) == running_background_jobs_ . end ( ) ) ; }
Node * EffectControlLinearizer :: LowerPlainPrimitiveToFloat64 ( Node * node ) { Node * value = node -> InputAt ( 0 ) ; auto if_not_smi = __ MakeDeferredLabel ( ) ; auto if_to_number_smi = __ MakeLabel ( ) ; auto done = __ MakeLabel ( MachineRepresentation :: kFloat64 ) ; Node * check0 = ObjectIsSmi ( value ) ; __ GotoIfNot ( check0 , & if_not_smi ) ; Node * from_smi = ChangeSmiToInt32 ( value ) ; __ Goto ( & done , __ ChangeInt32ToFloat64 ( from_smi ) ) ; __ Bind ( & if_not_smi ) ; Node * to_number = __ ToNumber ( value ) ; Node * check1 = ObjectIsSmi ( to_number ) ; __ GotoIf ( check1 , & if_to_number_smi ) ; Node * number = __ LoadField ( AccessBuilder :: ForHeapNumberValue ( ) , to_number ) ; __ Goto ( & done , number ) ; __ Bind ( & if_to_number_smi ) ; Node * number_from_smi = ChangeSmiToInt32 ( to_number ) ; number_from_smi = __ ChangeInt32ToFloat64 ( number_from_smi ) ; __ Goto ( & done , number_from_smi ) ; __ Bind ( & done ) ; return done . PhiAt ( 0 ) ; }
void SourceListener :: SetMutedFor ( LocalTrackSource * aTrackSource , bool aMute ) { MOZ_ASSERT ( NS_IsMainThread ( ) , "Only call on main thread" ) ; MOZ_ASSERT ( Activated ( ) , "No device to set muted state for" ) ; MediaTrack * track = aTrackSource -> mTrack ; DeviceState & state = GetDeviceStateFor ( track ) ; LOG ( "SourceListener %p %s %s track for track %p" , this , aMute ? "muting" : "unmuting" , & state == mAudioDeviceState . get ( ) ? "audio" : "video" , track ) ; if ( state . mStopped ) { return ; } if ( state . mDeviceMuted == aMute ) { return ; } LOG ( "SourceListener %p %s %s track for track %p - starting device operation" , this , aMute ? "muting" : "unmuting" , & state == mAudioDeviceState . get ( ) ? "audio" : "video" , track ) ; state . mDeviceMuted = aMute ; if ( mWindowListener ) { mWindowListener -> ChromeAffectingStateChanged ( ) ; } if ( aMute ) { aTrackSource -> Mute ( ) ; } else { aTrackSource -> Unmute ( ) ; } if ( ! state . mOffWhileDisabled || ! state . mDeviceEnabled ) { return ; } UpdateDevice ( track , ! aMute ) ; }
exif_mnote_data_canon_load ( ExifMnoteData * ne , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataCanon * n = ( ExifMnoteDataCanon * ) ne ; ExifShort c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , "ExifMnoteCanon" , "Short MakerNote" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , "ExifMnoteCanon" , "Short MakerNote" ) ; return ; } c = exif_get_short ( buf + datao , n -> order ) ; datao += 2 ; exif_mnote_data_canon_clear ( n ) ; n -> entries = exif_mem_alloc ( ne -> mem , sizeof ( MnoteCanonEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( ne -> log , "ExifMnoteCanon" , sizeof ( MnoteCanonEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , "ExifMnoteCanon" , "Short MakerNote" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , "ExifMnoteCanon" , "Loading entry 0x%x ('%s')..." , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , "ExifMnoteCanon" , "Tag size overflow detected (%u * %lu)" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components ) ; continue ; } s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( ! s ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , "ExifMnoteCanon" , "Invalid zero-length tag size" ) ; continue ; } else { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , "ExifMnoteCanon" , "Tag data past end of buffer (%u > %u)" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , "ExifMnoteCanon" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }
void ihevcd_parse_sei_payload ( codec_t * ps_codec , UWORD32 u4_payload_type , UWORD32 u4_payload_size , WORD8 i1_nal_type ) { parse_ctxt_t * ps_parse = & ps_codec -> s_parse ; bitstrm_t * ps_bitstrm = & ps_parse -> s_bitstrm ; WORD32 payload_bits_remaining = 0 ; sps_t * ps_sps ; UWORD32 i ; for ( i = 0 ; i < MAX_SPS_CNT ; i ++ ) { ps_sps = ps_codec -> ps_sps_base + i ; if ( ps_sps -> i1_sps_valid ) { break ; } } if ( NULL == ps_sps ) { return ; } if ( NAL_PREFIX_SEI == i1_nal_type ) { switch ( u4_payload_type ) { case SEI_BUFFERING_PERIOD : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_buffering_period_sei ( ps_codec , ps_sps ) ; break ; case SEI_PICTURE_TIMING : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_pic_timing_sei ( ps_codec , ps_sps ) ; break ; case SEI_TIME_CODE : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_time_code_sei ( ps_codec ) ; break ; case SEI_MASTERING_DISPLAY_COLOUR_VOLUME : ps_parse -> s_sei_params . i4_sei_mastering_disp_colour_vol_params_present_flags = 1 ; ihevcd_parse_mastering_disp_params_sei ( ps_codec ) ; break ; case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , u4_payload_size ) ; break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } else { switch ( u4_payload_type ) { case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , u4_payload_size ) ; break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } payload_bits_remaining = ihevcd_bits_num_bits_remaining ( ps_bitstrm ) ; if ( payload_bits_remaining ) { WORD32 final_bits ; WORD32 final_payload_bits = 0 ; WORD32 mask = 0xFF ; UWORD32 u4_dummy ; UWORD32 u4_reserved_payload_extension_data ; UNUSED ( u4_dummy ) ; UNUSED ( u4_reserved_payload_extension_data ) ; while ( payload_bits_remaining > 9 ) { BITS_PARSE ( "reserved_payload_extension_data" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } final_bits = ihevcd_bits_nxt ( ps_bitstrm , payload_bits_remaining ) ; while ( final_bits & ( mask > > final_payload_bits ) ) { final_payload_bits ++ ; continue ; } while ( payload_bits_remaining > ( 9 - final_payload_bits ) ) { BITS_PARSE ( "reserved_payload_extension_data" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } BITS_PARSE ( "payload_bit_equal_to_one" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; while ( payload_bits_remaining ) { BITS_PARSE ( "payload_bit_equal_to_zero" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } } return ; }
void MDnsSdListener :: Monitor :: run ( ) { int pollCount = 1 ; mPollFds = ( struct pollfd * ) calloc ( sizeof ( struct pollfd ) , mPollSize ) ; mPollRefs = ( DNSServiceRef * * ) calloc ( sizeof ( DNSServiceRef * ) , mPollSize ) ; LOG_ALWAYS_FATAL_IF ( ( mPollFds == NULL ) , "initial calloc failed on mPollFds with a size of %d" , ( ( int ) sizeof ( struct pollfd ) ) * mPollSize ) ; LOG_ALWAYS_FATAL_IF ( ( mPollRefs == NULL ) , "initial calloc failed on mPollRefs with a size of %d" , ( ( int ) sizeof ( DNSServiceRef * ) ) * mPollSize ) ; mPollFds [ 0 ] . fd = mCtrlSocketPair [ 0 ] ; mPollFds [ 0 ] . events = POLLIN ; if ( VDBG ) ALOGD ( "MDnsSdListener starting to monitor" ) ; while ( 1 ) { if ( VDBG ) ALOGD ( "Going to poll with pollCount %d" , pollCount ) ; int pollResults = poll ( mPollFds , pollCount , 10000000 ) ; if ( pollResults < 0 ) { ALOGE ( "Error in poll - got %d" , errno ) ; } else if ( pollResults > 0 ) { if ( VDBG ) ALOGD ( "Monitor poll got data pollCount = %d, %d" , pollCount , pollResults ) ; for ( int i = 1 ; i < pollCount ; i ++ ) { if ( mPollFds [ i ] . revents != 0 ) { if ( VDBG ) { ALOGD ( "Monitor found [%d].revents = %d - calling ProcessResults" , i , mPollFds [ i ] . revents ) ; } DNSServiceProcessResult ( * ( mPollRefs [ i ] ) ) ; mPollFds [ i ] . revents = 0 ; } } if ( VDBG ) ALOGD ( "controlSocket shows revent= %d" , mPollFds [ 0 ] . revents ) ; switch ( mPollFds [ 0 ] . revents ) { case POLLIN : { char readBuf [ 2 ] ; read ( mCtrlSocketPair [ 0 ] , & readBuf , 1 ) ; if ( DBG ) ALOGD ( "MDnsSdListener::Monitor got %c" , readBuf [ 0 ] ) ; if ( memcmp ( RESCAN , readBuf , 1 ) == 0 ) { pollCount = rescan ( ) ; } } } mPollFds [ 0 ] . revents = 0 ; } else { if ( VDBG ) ALOGD ( "MDnsSdListener::Monitor poll timed out" ) ; } } free ( mPollFds ) ; free ( mPollRefs ) ; }
void OptimizingCompileDispatcher :: Stop ( ) { base :: Release_Store ( & mode_ , static_cast < base :: AtomicWord > ( FLUSH ) ) ; if ( FLAG_block_concurrent_recompilation ) Unblock ( ) ; { base :: LockGuard < base :: Mutex > lock_guard ( & ref_count_mutex_ ) ; while ( ref_count_ > 0 ) ref_count_zero_ . Wait ( & ref_count_mutex_ ) ; base :: Release_Store ( & mode_ , static_cast < base :: AtomicWord > ( COMPILE ) ) ; } if ( recompilation_delay_ != 0 ) { while ( input_queue_length_ > 0 ) CompileNext ( NextInput ( ) ) ; InstallOptimizedFunctions ( ) ; } else { FlushOutputQueue ( false ) ; } }
void Compute ( OpKernelContext * context ) override { const Tensor & input = context -> input ( 0 ) ; OP_REQUIRES ( context , input . dims ( ) == 4 , errors :: InvalidArgument ( "input must be 4-dimensional" , input . shape ( ) . DebugString ( ) ) ) ; const Tensor & shape_t = context -> input ( 1 ) ; OP_REQUIRES ( context , shape_t . dims ( ) == 1 , errors :: InvalidArgument ( "shape_t must be 1-dimensional" , shape_t . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , shape_t . NumElements ( ) == 2 , errors :: InvalidArgument ( "shape_t must have two elements" , shape_t . shape ( ) . DebugString ( ) ) ) ; auto sizes = shape_t . vec < int32 > ( ) ; OP_REQUIRES ( context , sizes ( 0 ) > 0 && sizes ( 1 ) > 0 , errors :: InvalidArgument ( "shape_t's elements must be positive" ) ) ; if ( std :: is_same < Device , GPUDevice > :: value ) { OP_REQUIRES ( context , ! OpDeterminismRequired ( ) , errors :: Unimplemented ( "A deterministic GPU implementation of ResizeNearestNeighborGrad" " is not currently available." ) ) ; } const int64_t batch_size = input . dim_size ( 0 ) ; const int64_t in_height = input . dim_size ( 1 ) ; const int64_t in_width = input . dim_size ( 2 ) ; const int64_t channels = input . dim_size ( 3 ) ; const int64_t out_height = sizes ( 0 ) ; const int64_t out_width = sizes ( 1 ) ; Tensor * output = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { batch_size , out_height , out_width , channels } ) , & output ) ) ; if ( output -> NumElements ( ) == 0 ) return ; typename TTypes < T , 4 > :: ConstTensor input_data ( input . tensor < T , 4 > ( ) ) ; typename TTypes < T , 4 > :: Tensor output_data ( output -> tensor < T , 4 > ( ) ) ; const float height_scale = CalculateResizeScale ( out_height , in_height , align_corners_ ) ; const float width_scale = CalculateResizeScale ( out_width , in_width , align_corners_ ) ; bool status ; if ( half_pixel_centers_ ) { if ( align_corners_ ) { status = functor :: ResizeNearestNeighborGrad < Device , T , true , true > ( ) ( context -> eigen_device < Device > ( ) , input_data , height_scale , width_scale , output_data ) ; } else { status = functor :: ResizeNearestNeighborGrad < Device , T , true , false > ( ) ( context -> eigen_device < Device > ( ) , input_data , height_scale , width_scale , output_data ) ; } } else { if ( align_corners_ ) { status = functor :: ResizeNearestNeighborGrad < Device , T , false , true > ( ) ( context -> eigen_device < Device > ( ) , input_data , height_scale , width_scale , output_data ) ; } else { status = functor :: ResizeNearestNeighborGrad < Device , T , false , false > ( ) ( context -> eigen_device < Device > ( ) , input_data , height_scale , width_scale , output_data ) ; } } if ( ! status ) { context -> SetStatus ( errors :: Internal ( "Failed launching ResizeNearestNeighborGrad" ) ) ; } }
Node * EffectControlLinearizer :: LowerNewDoubleElements ( Node * node ) { PretenureFlag const pretenure = PretenureFlagOf ( node -> op ( ) ) ; Node * length = node -> InputAt ( 0 ) ; auto done = __ MakeLabel ( MachineRepresentation :: kTaggedPointer ) ; Node * zero_length = __ Word32Equal ( length , __ Int32Constant ( 0 ) ) ; __ GotoIf ( zero_length , & done , jsgraph ( ) -> HeapConstant ( factory ( ) -> empty_fixed_array ( ) ) ) ; Node * size = __ Int32Add ( __ Word32Shl ( length , __ Int32Constant ( kDoubleSizeLog2 ) ) , __ Int32Constant ( FixedDoubleArray :: kHeaderSize ) ) ; Node * result = __ Allocate ( pretenure , size ) ; __ StoreField ( AccessBuilder :: ForMap ( ) , result , __ FixedDoubleArrayMapConstant ( ) ) ; __ StoreField ( AccessBuilder :: ForFixedArrayLength ( ) , result , ChangeInt32ToSmi ( length ) ) ; STATIC_ASSERT ( HeapNumber :: kValueOffset == Oddball :: kToNumberRawOffset ) ; Node * limit = ChangeUint32ToUintPtr ( length ) ; Node * the_hole = __ LoadField ( AccessBuilder :: ForHeapNumberValue ( ) , __ TheHoleConstant ( ) ) ; auto loop = __ MakeLoopLabel ( MachineType :: PointerRepresentation ( ) ) ; __ Goto ( & loop , __ IntPtrConstant ( 0 ) ) ; __ Bind ( & loop ) ; { Node * index = loop . PhiAt ( 0 ) ; Node * check = __ UintLessThan ( index , limit ) ; __ GotoIfNot ( check , & done , result ) ; StoreRepresentation rep ( MachineRepresentation :: kFloat64 , kNoWriteBarrier ) ; Node * offset = __ IntAdd ( __ WordShl ( index , __ IntPtrConstant ( kDoubleSizeLog2 ) ) , __ IntPtrConstant ( FixedDoubleArray :: kHeaderSize - kHeapObjectTag ) ) ; __ Store ( rep , result , offset , the_hole ) ; index = __ IntAdd ( index , __ IntPtrConstant ( 1 ) ) ; __ Goto ( & loop , index ) ; } __ Bind ( & done ) ; return done . PhiAt ( 0 ) ; }
mozilla :: ipc :: IPCResult BrowserChild :: RecvNavigateByKey ( const bool & aForward , const bool & aForDocumentNavigation ) { nsIFocusManager * fm = nsFocusManager :: GetFocusManager ( ) ; if ( fm ) { RefPtr < Element > result ; nsCOMPtr < nsPIDOMWindowOuter > window = do_GetInterface ( WebNavigation ( ) ) ; uint32_t type = aForward ? ( aForDocumentNavigation ? static_cast < uint32_t > ( nsIFocusManager :: MOVEFOCUS_FIRSTDOC ) : static_cast < uint32_t > ( nsIFocusManager :: MOVEFOCUS_ROOT ) ) : ( aForDocumentNavigation ? static_cast < uint32_t > ( nsIFocusManager :: MOVEFOCUS_LASTDOC ) : static_cast < uint32_t > ( nsIFocusManager :: MOVEFOCUS_LAST ) ) ; fm -> MoveFocus ( window , nullptr , type , nsIFocusManager :: FLAG_BYKEY , getter_AddRefs ( result ) ) ; if ( ! result && aForward && ! aForDocumentNavigation ) { fm -> MoveFocus ( window , nullptr , nsIFocusManager :: MOVEFOCUS_FIRST , nsIFocusManager :: FLAG_BYKEY , getter_AddRefs ( result ) ) ; } SendRequestFocus ( false ) ; } return IPC_OK ( ) ; }
Handle < WasmExportedFunction > WasmExportedFunction :: New ( Isolate * isolate , Handle < WasmInstanceObject > instance , MaybeHandle < String > maybe_name , int func_index , int arity , Handle < Code > export_wrapper ) { DCHECK_EQ ( Code :: JS_TO_WASM_FUNCTION , export_wrapper -> kind ( ) ) ; int num_imported_functions = instance -> module ( ) -> num_imported_functions ; int jump_table_offset = - 1 ; if ( func_index >= num_imported_functions ) { ptrdiff_t jump_table_diff = instance -> module_object ( ) -> native_module ( ) -> jump_table_offset ( func_index ) ; DCHECK ( jump_table_diff >= 0 && jump_table_diff <= INT_MAX ) ; jump_table_offset = static_cast < int > ( jump_table_diff ) ; } Handle < WasmExportedFunctionData > function_data = Handle < WasmExportedFunctionData > :: cast ( isolate -> factory ( ) -> NewStruct ( WASM_EXPORTED_FUNCTION_DATA_TYPE , TENURED ) ) ; function_data -> set_wrapper_code ( * export_wrapper ) ; function_data -> set_instance ( * instance ) ; function_data -> set_jump_table_offset ( jump_table_offset ) ; function_data -> set_function_index ( func_index ) ; Handle < String > name ; if ( ! maybe_name . ToHandle ( & name ) ) { EmbeddedVector < char , 16 > buffer ; int length = SNPrintF ( buffer , "%d" , func_index ) ; name = isolate -> factory ( ) -> NewStringFromOneByte ( Vector < uint8_t > :: cast ( buffer . SubVector ( 0 , length ) ) ) . ToHandleChecked ( ) ; } NewFunctionArgs args = NewFunctionArgs :: ForWasm ( name , function_data , isolate -> sloppy_function_without_prototype_map ( ) ) ; Handle < JSFunction > js_function = isolate -> factory ( ) -> NewFunction ( args ) ; DCHECK ( ! js_function -> IsConstructor ( ) ) ; js_function -> shared ( ) -> set_length ( arity ) ; js_function -> shared ( ) -> set_internal_formal_parameter_count ( arity ) ; return Handle < WasmExportedFunction > :: cast ( js_function ) ; }
void ObjectStatsCollectorImpl :: RecordVirtualCodeDetails ( Code * code ) { RecordSimpleVirtualObjectStats ( nullptr , code , CodeKindToVirtualInstanceType ( code -> kind ( ) ) ) ; RecordSimpleVirtualObjectStats ( code , code -> deoptimization_data ( ) , ObjectStats :: DEOPTIMIZATION_DATA_TYPE ) ; RecordSimpleVirtualObjectStats ( code , code -> relocation_info ( ) , ObjectStats :: RELOC_INFO_TYPE ) ; Object * source_position_table = code -> source_position_table ( ) ; if ( source_position_table -> IsSourcePositionTableWithFrameCache ( ) ) { RecordSimpleVirtualObjectStats ( code , SourcePositionTableWithFrameCache :: cast ( source_position_table ) -> source_position_table ( ) , ObjectStats :: SOURCE_POSITION_TABLE_TYPE ) ; } else if ( source_position_table -> IsHeapObject ( ) ) { RecordSimpleVirtualObjectStats ( code , HeapObject :: cast ( source_position_table ) , ObjectStats :: SOURCE_POSITION_TABLE_TYPE ) ; } if ( code -> kind ( ) == Code :: Kind :: OPTIMIZED_FUNCTION ) { DeoptimizationData * input_data = DeoptimizationData :: cast ( code -> deoptimization_data ( ) ) ; if ( input_data -> length ( ) > 0 ) { RecordSimpleVirtualObjectStats ( code -> deoptimization_data ( ) , input_data -> LiteralArray ( ) , ObjectStats :: OPTIMIZED_CODE_LITERALS_TYPE ) ; } } int const mode_mask = RelocInfo :: ModeMask ( RelocInfo :: EMBEDDED_OBJECT ) ; for ( RelocIterator it ( code , mode_mask ) ; ! it . done ( ) ; it . next ( ) ) { RelocInfo :: Mode mode = it . rinfo ( ) -> rmode ( ) ; if ( mode == RelocInfo :: EMBEDDED_OBJECT ) { Object * target = it . rinfo ( ) -> target_object ( ) ; if ( target -> IsFixedArrayExact ( ) ) { RecordVirtualObjectsForConstantPoolOrEmbeddedObjects ( code , HeapObject :: cast ( target ) , ObjectStats :: EMBEDDED_OBJECT_TYPE ) ; } } } }
void DeclarationScope :: AllocateScopeInfos ( ParseInfo * info , Isolate * isolate ) { DeclarationScope * scope = info -> literal ( ) -> scope ( ) ; if ( ! scope -> scope_info_ . is_null ( ) ) return ; MaybeHandle < ScopeInfo > outer_scope ; if ( scope -> outer_scope_ != nullptr ) { outer_scope = scope -> outer_scope_ -> scope_info_ ; } scope -> AllocateScopeInfosRecursively ( isolate , outer_scope ) ; if ( scope -> scope_info_ . is_null ( ) ) { scope -> scope_info_ = ScopeInfo :: Create ( isolate , scope -> zone ( ) , scope , outer_scope ) ; } if ( info -> script_scope ( ) && info -> script_scope ( ) -> scope_info_ . is_null ( ) ) { info -> script_scope ( ) -> scope_info_ = handle ( ScopeInfo :: Empty ( isolate ) , isolate ) ; } }
CodeGenerator :: addGetElementCache ( LInstruction * ins , Register obj , ConstantOrRegister index , TypedOrValueRegister output , bool monitoredResult ) { switch ( gen -> info ( ) . executionMode ( ) ) { case SequentialExecution : { RegisterSet liveRegs = ins -> safepoint ( ) -> liveRegs ( ) ; GetElementIC cache ( liveRegs , obj , index , output , monitoredResult ) ; return addCache ( ins , allocateCache ( cache ) ) ; } case ParallelExecution : { GetElementParIC cache ( obj , index , output , monitoredResult ) ; return addCache ( ins , allocateCache ( cache ) ) ; } default : MOZ_ASSUME_UNREACHABLE ( "No such execution mode" ) ; } }
void Sweeper :: StartSweeperTasks ( ) { DCHECK_EQ ( 0 , num_tasks_ ) ; DCHECK_EQ ( 0 , num_sweeping_tasks_ ) ; if ( FLAG_concurrent_sweeping && sweeping_in_progress_ && ! heap_ -> delay_sweeper_tasks_for_testing_ ) { ForAllSweepingSpaces ( [ this ] ( AllocationSpace space ) { DCHECK ( IsValidSweepingSpace ( space ) ) ; num_sweeping_tasks_ ++ ; auto task = base :: make_unique < SweeperTask > ( heap_ -> isolate ( ) , this , & pending_sweeper_tasks_semaphore_ , & num_sweeping_tasks_ , space ) ; DCHECK_LT ( num_tasks_ , kMaxSweeperTasks ) ; task_ids_ [ num_tasks_ ++ ] = task -> id ( ) ; V8 :: GetCurrentPlatform ( ) -> CallOnWorkerThread ( std :: move ( task ) ) ; } ) ; ScheduleIncrementalSweepingTask ( ) ; } }
static void choose_largest_txfm_size ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int64_t * distortion , int * skip , int64_t * sse , int64_t ref_best_rd , BLOCK_SIZE bs ) { const TX_SIZE max_tx_size = max_txsize_lookup [ bs ] ; VP9_COMMON * const cm = & cpi -> common ; const TX_SIZE largest_tx_size = tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; mbmi -> tx_size = MIN ( max_tx_size , largest_tx_size ) ; txfm_rd_in_plane ( x , rate , distortion , skip , & sse [ mbmi -> tx_size ] , ref_best_rd , 0 , bs , mbmi -> tx_size , cpi -> sf . use_fast_coef_costing ) ; cpi -> tx_stepdown_count [ 0 ] ++ ; }
static Image * ReadMATImageV4 ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { typedef struct { unsigned char Type [ 4 ] ; unsigned int nRows ; unsigned int nCols ; unsigned int imagf ; unsigned int nameLen ; } MAT4_HDR ; long ldblk ; EndianType endian ; Image * rotate_image ; MagickBooleanType status ; MAT4_HDR HDR ; QuantumInfo * quantum_info ; QuantumFormatType format_type ; register ssize_t i ; ssize_t count , y ; unsigned char * pixels ; unsigned int depth ; ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; ldblk = ReadBlobLSBLong ( image ) ; if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) return ( ( Image * ) NULL ) ; HDR . Type [ 3 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 2 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 1 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 0 ] = ldblk ; if ( HDR . Type [ 3 ] != 0 ) return ( ( Image * ) NULL ) ; if ( HDR . Type [ 2 ] != 0 ) return ( ( Image * ) NULL ) ; if ( HDR . Type [ 0 ] == 0 ) { HDR . nRows = ReadBlobLSBLong ( image ) ; HDR . nCols = ReadBlobLSBLong ( image ) ; HDR . imagf = ReadBlobLSBLong ( image ) ; HDR . nameLen = ReadBlobLSBLong ( image ) ; endian = LSBEndian ; } else { HDR . nRows = ReadBlobMSBLong ( image ) ; HDR . nCols = ReadBlobMSBLong ( image ) ; HDR . imagf = ReadBlobMSBLong ( image ) ; HDR . nameLen = ReadBlobMSBLong ( image ) ; endian = MSBEndian ; } if ( HDR . nameLen > 0xFFFF ) return ( ( Image * ) NULL ) ; for ( i = 0 ; i < ( ssize_t ) HDR . nameLen ; i ++ ) { int byte ; byte = ReadBlobByte ( image ) ; if ( byte == EOF ) return ( ( Image * ) NULL ) ; } image -> columns = ( size_t ) HDR . nRows ; image -> rows = ( size_t ) HDR . nCols ; SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( image_info -> ping != MagickFalse ) { Swap ( image -> columns , image -> rows ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) return ( ( Image * ) NULL ) ; switch ( HDR . Type [ 1 ] ) { case 0 : format_type = FloatingPointQuantumFormat ; depth = 64 ; break ; case 1 : format_type = FloatingPointQuantumFormat ; depth = 32 ; break ; case 2 : format_type = UnsignedQuantumFormat ; depth = 16 ; break ; case 3 : format_type = SignedQuantumFormat ; depth = 16 ; case 4 : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; default : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; } image -> depth = depth ; if ( HDR . Type [ 0 ] != 0 ) SetQuantumEndian ( image , quantum_info , MSBEndian ) ; status = SetQuantumFormat ( image , quantum_info , format_type ) ; status = SetQuantumDepth ( image , quantum_info , depth ) ; status = SetQuantumEndian ( image , quantum_info , endian ) ; SetQuantumScale ( quantum_info , 1.0 ) ; pixels = ( unsigned char * ) GetQuantumPixels ( quantum_info ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { int status ; register Quantum * magick_restrict q ; count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; q = QueueAuthenticPixels ( image , 0 , image -> rows - y - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ; if ( ( HDR . Type [ 1 ] == 2 ) || ( HDR . Type [ 1 ] == 3 ) ) FixSignedValues ( image , q , image -> columns ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( HDR . imagf == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; if ( HDR . Type [ 1 ] == 0 ) InsertComplexDoubleRow ( image , ( double * ) pixels , y , 0 , 0 , exception ) ; else InsertComplexFloatRow ( image , ( float * ) pixels , y , 0 , 0 , exception ) ; } quantum_info = DestroyQuantumInfo ( quantum_info ) ; rotate_image = RotateImage ( image , 90.0 , exception ) ; if ( rotate_image != ( Image * ) NULL ) { image = DestroyImage ( image ) ; image = rotate_image ; } return ( image ) ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { OpData * data = static_cast < OpData * > ( node -> user_data ) ; const TfLiteTensor * input = GetInput ( context , node , 0 ) ; TfLiteTensor * output = GetOutput ( context , node , 0 ) ; const RuntimeShape input_shape = GetTensorShape ( input ) ; const RuntimeShape output_shape = GetTensorShape ( output ) ; switch ( input -> type ) { case kTfLiteFloat32 : { tflite :: QuantizationParams op_params ; op_params . zero_point = output -> params . zero_point ; op_params . scale = output -> params . scale ; const float * input_data = GetTensorData < float > ( input ) ; switch ( output -> type ) { case kTfLiteInt8 : AffineQuantize < kernel_type > ( op_params , input_shape , input_data , output_shape , GetTensorData < int8_t > ( output ) ) ; return kTfLiteOk ; case kTfLiteUInt8 : AffineQuantize < kernel_type > ( op_params , input_shape , input_data , output_shape , GetTensorData < uint8_t > ( output ) ) ; return kTfLiteOk ; case kTfLiteInt16 : AffineQuantize < kernel_type > ( op_params , input_shape , input_data , output_shape , GetTensorData < int16_t > ( output ) ) ; return kTfLiteOk ; default : ReportError ( context , input -> type , output -> type ) ; return kTfLiteError ; } } case kTfLiteInt16 : { switch ( output -> type ) { case kTfLiteInt8 : Requantize < kernel_type > ( GetTensorData < int16_t > ( input ) , MatchingFlatSize ( input_shape , output_shape ) , data -> output_multiplier , data -> output_shift , input -> params . zero_point , output -> params . zero_point , GetTensorData < int8_t > ( output ) ) ; return kTfLiteOk ; case kTfLiteInt16 : Requantize < kernel_type > ( GetTensorData < int16_t > ( input ) , MatchingFlatSize ( input_shape , output_shape ) , data -> output_multiplier , data -> output_shift , input -> params . zero_point , output -> params . zero_point , GetTensorData < int16_t > ( output ) ) ; return kTfLiteOk ; default : ReportError ( context , input -> type , output -> type ) ; return kTfLiteError ; } } case kTfLiteInt8 : { const int32_t size = MatchingFlatSize ( input_shape , output_shape ) ; const int8_t * input_data = GetTensorData < int8_t > ( input ) ; switch ( output -> type ) { case kTfLiteInt8 : Requantize < kernel_type > ( input_data , size , data -> output_multiplier , data -> output_shift , input -> params . zero_point , output -> params . zero_point , GetTensorData < int8_t > ( output ) ) ; return kTfLiteOk ; case kTfLiteUInt8 : Requantize < kernel_type > ( input_data , size , data -> output_multiplier , data -> output_shift , input -> params . zero_point , output -> params . zero_point , GetTensorData < uint8_t > ( output ) ) ; return kTfLiteOk ; default : ReportError ( context , input -> type , output -> type ) ; return kTfLiteError ; } } case kTfLiteUInt8 : { const int32_t size = MatchingFlatSize ( input_shape , output_shape ) ; const uint8_t * input_data = GetTensorData < uint8_t > ( input ) ; switch ( output -> type ) { case kTfLiteInt8 : Requantize < kernel_type > ( input_data , size , data -> output_multiplier , data -> output_shift , input -> params . zero_point , output -> params . zero_point , GetTensorData < int8_t > ( output ) ) ; return kTfLiteOk ; case kTfLiteUInt8 : Requantize < kernel_type > ( input_data , size , data -> output_multiplier , data -> output_shift , input -> params . zero_point , output -> params . zero_point , GetTensorData < uint8_t > ( output ) ) ; return kTfLiteOk ; default : ReportError ( context , input -> type , output -> type ) ; return kTfLiteError ; } } default : ReportError ( context , input -> type , output -> type ) ; return kTfLiteError ; } }
nsXBLProtoImplProperty :: CompileMember ( nsIScriptContext * aContext , const nsCString & aClassStr , JSObject * aClassObject ) { NS_PRECONDITION ( ! mIsCompiled , "Trying to compile an already-compiled property" ) ; NS_PRECONDITION ( aClassObject , "Must have class object to compile" ) ; if ( ! mName ) return NS_ERROR_FAILURE ; nsresult rv = NS_OK ; nsAutoCString functionUri ; if ( mGetterText || mSetterText ) { functionUri = aClassStr ; int32_t hash = functionUri . RFindChar ( '#' ) ; if ( hash != kNotFound ) { functionUri . Truncate ( hash ) ; } } bool deletedGetter = false ; if ( mGetterText && mGetterText -> GetText ( ) ) { nsDependentString getter ( mGetterText -> GetText ( ) ) ; if ( ! getter . IsEmpty ( ) ) { JSObject * getterObject = nullptr ; JSContext * cx = aContext -> GetNativeContext ( ) ; JSAutoRequest ar ( cx ) ; JSAutoCompartment ac ( cx , aClassObject ) ; JS :: CompileOptions options ( cx ) ; options . setFileAndLine ( functionUri . get ( ) , mGetterText -> GetLineNumber ( ) ) . setVersion ( JSVERSION_LATEST ) . setUserBit ( true ) ; nsCString name = NS_LITERAL_CSTRING ( "get_" ) + NS_ConvertUTF16toUTF8 ( mName ) ; js :: RootedObject rootedNull ( cx , nullptr ) ; rv = nsJSUtils :: CompileFunction ( cx , rootedNull , options , name , 0 , nullptr , getter , & getterObject ) ; delete mGetterText ; deletedGetter = true ; mJSGetterObject = getterObject ; if ( mJSGetterObject && NS_SUCCEEDED ( rv ) ) { mJSAttributes |= JSPROP_GETTER | JSPROP_SHARED ; } if ( NS_FAILED ( rv ) ) { mJSGetterObject = nullptr ; mJSAttributes &= ~ JSPROP_GETTER ; } } } if ( ! deletedGetter ) { delete mGetterText ; mJSGetterObject = nullptr ; } if ( NS_FAILED ( rv ) ) { return rv ; } bool deletedSetter = false ; if ( mSetterText && mSetterText -> GetText ( ) ) { nsDependentString setter ( mSetterText -> GetText ( ) ) ; if ( ! setter . IsEmpty ( ) ) { JSObject * setterObject = nullptr ; JSContext * cx = aContext -> GetNativeContext ( ) ; JSAutoRequest ar ( cx ) ; JSAutoCompartment ac ( cx , aClassObject ) ; JS :: CompileOptions options ( cx ) ; options . setFileAndLine ( functionUri . get ( ) , mSetterText -> GetLineNumber ( ) ) . setVersion ( JSVERSION_LATEST ) . setUserBit ( true ) ; nsCString name = NS_LITERAL_CSTRING ( "set_" ) + NS_ConvertUTF16toUTF8 ( mName ) ; js :: RootedObject rootedNull ( cx , nullptr ) ; rv = nsJSUtils :: CompileFunction ( cx , rootedNull , options , name , 1 , gPropertyArgs , setter , & setterObject ) ; delete mSetterText ; deletedSetter = true ; mJSSetterObject = setterObject ; if ( mJSSetterObject && NS_SUCCEEDED ( rv ) ) { mJSAttributes |= JSPROP_SETTER | JSPROP_SHARED ; } if ( NS_FAILED ( rv ) ) { mJSSetterObject = nullptr ; mJSAttributes &= ~ JSPROP_SETTER ; } } } if ( ! deletedSetter ) { delete mSetterText ; mJSSetterObject = nullptr ; } #ifdef DEBUG mIsCompiled = NS_SUCCEEDED ( rv ) ; #endif return rv ; }
TokenStream :: SourceCoords :: lineIndexOf ( uint32_t offset ) const { uint32_t iMin , iMax , iMid ; if ( lineStartOffsets_ [ lastLineIndex_ ] <= offset ) { if ( offset < lineStartOffsets_ [ lastLineIndex_ + 1 ] ) return lastLineIndex_ ; lastLineIndex_ ++ ; if ( offset < lineStartOffsets_ [ lastLineIndex_ + 1 ] ) return lastLineIndex_ ; lastLineIndex_ ++ ; if ( offset < lineStartOffsets_ [ lastLineIndex_ + 1 ] ) { return lastLineIndex_ ; } iMin = lastLineIndex_ + 1 ; JS_ASSERT ( iMin < lineStartOffsets_ . length ( ) - 1 ) ; } else { iMin = 0 ; } iMax = lineStartOffsets_ . length ( ) - 2 ; while ( iMax > iMin ) { iMid = ( iMin + iMax ) / 2 ; if ( offset >= lineStartOffsets_ [ iMid + 1 ] ) iMin = iMid + 1 ; else iMax = iMid ; } JS_ASSERT ( iMax == iMin ) ; JS_ASSERT ( lineStartOffsets_ [ iMin ] <= offset && offset < lineStartOffsets_ [ iMin + 1 ] ) ; lastLineIndex_ = iMin ; return iMin ; }
Node * const * BytecodeGraphBuilder :: GetConstructArgumentsFromRegister ( Node * target , Node * new_target , interpreter :: Register first_arg , int arg_count ) { int arity = arg_count + 2 ; Node * * all = local_zone ( ) -> NewArray < Node * > ( static_cast < size_t > ( arity ) ) ; all [ 0 ] = target ; int first_arg_index = first_arg . index ( ) ; for ( int i = 0 ; i < arg_count ; ++ i ) { all [ 1 + i ] = environment ( ) -> LookupRegister ( interpreter :: Register ( first_arg_index + i ) ) ; } all [ arity - 1 ] = new_target ; return all ; }
void ObjectStatsCollectorImpl :: RecordVirtualContext ( Context * context ) { if ( context -> IsNativeContext ( ) ) { RecordObjectStats ( context , NATIVE_CONTEXT_TYPE , context -> Size ( ) ) ; } else if ( context -> IsFunctionContext ( ) ) { RecordObjectStats ( context , FUNCTION_CONTEXT_TYPE , context -> Size ( ) ) ; } else { RecordSimpleVirtualObjectStats ( nullptr , context , ObjectStats :: OTHER_CONTEXT_TYPE ) ; } }
id3_skip ( SF_PRIVATE * psf ) { unsigned char buf [ 10 ] ; memset ( buf , 0 , sizeof ( buf ) ) ; psf_binheader_readf ( psf , "pb" , 0 , buf , 10 ) ; if ( buf [ 0 ] == 'I' && buf [ 1 ] == 'D' && buf [ 2 ] == '3' ) { int offset = buf [ 6 ] & 0x7f ; offset = ( offset < < 7 ) | ( buf [ 7 ] & 0x7f ) ; offset = ( offset < < 7 ) | ( buf [ 8 ] & 0x7f ) ; offset = ( offset < < 7 ) | ( buf [ 9 ] & 0x7f ) ; psf_log_printf ( psf , "ID3 length : %d\n--------------------\n" , offset ) ; if ( offset < 0 ) return 0 ; psf -> fileoffset += offset + 10 ; psf_binheader_readf ( psf , "p" , psf -> fileoffset ) ; return 1 ; } ; return 0 ; }
Node * InterpreterAssembler :: BytecodeUnsignedOperand ( int operand_index , OperandSize operand_size , LoadSensitivity needs_poisoning ) { DCHECK ( Bytecodes :: IsUnsignedOperandType ( Bytecodes :: GetOperandType ( bytecode_ , operand_index ) ) ) ; switch ( operand_size ) { case OperandSize :: kByte : return BytecodeOperandUnsignedByte ( operand_index , needs_poisoning ) ; case OperandSize :: kShort : return BytecodeOperandUnsignedShort ( operand_index , needs_poisoning ) ; case OperandSize :: kQuad : return BytecodeOperandUnsignedQuad ( operand_index , needs_poisoning ) ; case OperandSize :: kNone : UNREACHABLE ( ) ; } return nullptr ; }
bool Commit ( ) { if ( baseline_units_ . empty ( ) && tiering_units_ . empty ( ) ) return false ; compilation_state_ -> AddCompilationUnits ( baseline_units_ , tiering_units_ ) ; Clear ( ) ; return true ; }
bool Parser :: CollapseNaryExpression ( Expression * * x , Expression * y , Token :: Value op , int pos , const SourceRange & range ) { if ( ! Token :: IsBinaryOp ( op ) || op == Token :: EXP ) return false ; NaryOperation * nary = nullptr ; if ( ( * x ) -> IsBinaryOperation ( ) ) { BinaryOperation * binop = ( * x ) -> AsBinaryOperation ( ) ; if ( binop -> op ( ) != op ) return false ; nary = factory ( ) -> NewNaryOperation ( op , binop -> left ( ) , 2 ) ; nary -> AddSubsequent ( binop -> right ( ) , binop -> position ( ) ) ; ConvertBinaryToNaryOperationSourceRange ( binop , nary ) ; * x = nary ; } else if ( ( * x ) -> IsNaryOperation ( ) ) { nary = ( * x ) -> AsNaryOperation ( ) ; if ( nary -> op ( ) != op ) return false ; } else { return false ; } nary -> AddSubsequent ( y , pos ) ; AppendNaryOperationSourceRange ( nary , range ) ; return true ; }
bool Segment :: Finalize ( ) { if ( WriteFramesAll ( ) < 0 ) return false ; if ( mode_ == kFile ) { if ( cluster_list_size_ > 0 ) { Cluster * const old_cluster = cluster_list_ [ cluster_list_size_ - 1 ] ; if ( ! old_cluster || ! old_cluster -> Finalize ( ) ) return false ; } if ( chunking_ && chunk_writer_cluster_ ) { chunk_writer_cluster_ -> Close ( ) ; chunk_count_ ++ ; } const double duration = ( static_cast < double > ( last_timestamp_ ) + last_block_duration_ ) / segment_info_ . timecode_scale ( ) ; segment_info_ . set_duration ( duration ) ; if ( ! segment_info_ . Finalize ( writer_header_ ) ) return false ; if ( output_cues_ ) if ( ! seek_head_ . AddSeekEntry ( kMkvCues , MaxOffset ( ) ) ) return false ; if ( chunking_ ) { if ( ! chunk_writer_cues_ ) return false ; char * name = NULL ; if ( ! UpdateChunkName ( "cues" , & name ) ) return false ; const bool cues_open = chunk_writer_cues_ -> Open ( name ) ; delete [ ] name ; if ( ! cues_open ) return false ; } cluster_end_offset_ = writer_cluster_ -> Position ( ) ; if ( output_cues_ ) if ( ! cues_ . Write ( writer_cues_ ) ) return false ; if ( ! seek_head_ . Finalize ( writer_header_ ) ) return false ; if ( writer_header_ -> Seekable ( ) ) { if ( size_position_ == - 1 ) return false ; const int64 pos = writer_header_ -> Position ( ) ; const int64 segment_size = MaxOffset ( ) ; if ( segment_size < 1 ) return false ; if ( writer_header_ -> Position ( size_position_ ) ) return false ; if ( WriteUIntSize ( writer_header_ , segment_size , 8 ) ) return false ; if ( writer_header_ -> Position ( pos ) ) return false ; } if ( chunking_ ) { if ( ! chunk_writer_cues_ || ! chunk_writer_header_ ) return false ; chunk_writer_cues_ -> Close ( ) ; chunk_writer_header_ -> Close ( ) ; } } return true ; }
void checkWrappingWriteRead ( ) { constexpr int frames1 = 43 ; constexpr int frames2 = 15 ; writeData ( frames1 ) ; checkWrappingBuffer ( ) ; verifyData ( frames1 ) ; checkWrappingBuffer ( ) ; writeData ( frames2 ) ; checkWrappingBuffer ( ) ; verifyData ( frames2 ) ; checkWrappingBuffer ( ) ; }
GetInterfaceImpl ( JSContext * aCx , nsIInterfaceRequestor * aRequestor , nsWrapperCache * aCache , nsIJSID * aIID , ErrorResult & aError ) { const nsID * iid = aIID -> GetID ( ) ; nsRefPtr < nsISupports > result ; aError = aRequestor -> GetInterface ( * iid , getter_AddRefs ( result ) ) ; if ( aError . Failed ( ) ) { return JS :: NullValue ( ) ; } JS :: Rooted < JS :: Value > v ( aCx , JSVAL_NULL ) ; if ( ! WrapObject ( aCx , result , iid , & v ) ) { aError . Throw ( NS_ERROR_FAILURE ) ; return JS :: NullValue ( ) ; } return v ; }
TEST_P ( Trans32x32Test , InverseAccuracy ) { ACMRandom rnd ( ACMRandom :: DeterministicSeed ( ) ) ; const int count_test_block = 1000 ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , in , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , coeff , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , dst , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , src , kNumCoeffs ) ; for ( int i = 0 ; i < count_test_block ; ++ i ) { double out_r [ kNumCoeffs ] ; for ( int j = 0 ; j < kNumCoeffs ; ++ j ) { src [ j ] = rnd . Rand8 ( ) ; dst [ j ] = rnd . Rand8 ( ) ; in [ j ] = src [ j ] - dst [ j ] ; } reference_32x32_dct_2d ( in , out_r ) ; for ( int j = 0 ; j < kNumCoeffs ; ++ j ) coeff [ j ] = round ( out_r [ j ] ) ; REGISTER_STATE_CHECK ( inv_txfm_ ( coeff , dst , 32 ) ) ; for ( int j = 0 ; j < kNumCoeffs ; ++ j ) { const int diff = dst [ j ] - src [ j ] ; const int error = diff * diff ; EXPECT_GE ( 1 , error ) < < "Error: 32x32 IDCT has error " < < error < < " at index " < < j ; } } }
IGNITION_HANDLER ( TestUndetectable , InterpreterAssembler ) { Label return_false ( this ) , end ( this ) ; Node * object = GetAccumulator ( ) ; SetAccumulator ( FalseConstant ( ) ) ; GotoIf ( TaggedIsSmi ( object ) , & end ) ; Node * result = SelectBooleanConstant ( IsUndetectableMap ( LoadMap ( object ) ) ) ; SetAccumulator ( result ) ; Goto ( & end ) ; BIND ( & end ) ; Dispatch ( ) ; }
long Segment :: Load ( ) { assert ( m_clusters == NULL ) ; assert ( m_clusterSize == 0 ) ; assert ( m_clusterCount == 0 ) ; const long long header_status = ParseHeaders ( ) ; if ( header_status < 0 ) return static_cast < long > ( header_status ) ; if ( header_status > 0 ) return E_BUFFER_NOT_FULL ; assert ( m_pInfo ) ; assert ( m_pTracks ) ; for ( ; ; ) { const int status = LoadCluster ( ) ; if ( status < 0 ) return status ; if ( status >= 1 ) return 0 ; } }
http_dissect_hdrs ( struct worker * w , struct http * hp , int fd , char * p , const struct http_conn * htc ) { char * q , * r ; txt t = htc -> rxbuf ; if ( * p == '\r' ) p ++ ; hp -> nhd = HTTP_HDR_FIRST ; hp -> conds = 0 ; r = NULL ; for ( ; p < t . e ; p = r ) { q = r = p ; while ( r < t . e ) { if ( ! vct_iscrlf ( * r ) ) { r ++ ; continue ; } q = r ; assert ( r < t . e ) ; r += vct_skipcrlf ( r ) ; if ( r >= t . e ) break ; if ( ! vct_issp ( * r ) ) break ; while ( vct_islws ( * q ) ) * q ++ = ' ' ; } if ( q - p > htc -> maxhdr ) { VSC_C_main -> losthdr ++ ; WSL ( w , SLT_LostHeader , fd , "%.*s" , q - p > 20 ? 20 : q - p , p ) ; return ( 413 ) ; } if ( p == q ) break ; if ( ( p [ 0 ] == 'i' || p [ 0 ] == 'I' ) && ( p [ 1 ] == 'f' || p [ 1 ] == 'F' ) && p [ 2 ] == '-' ) hp -> conds = 1 ; while ( q > p && vct_issp ( q [ - 1 ] ) ) q -- ; * q = '\0' ; if ( hp -> nhd < hp -> shd ) { hp -> hdf [ hp -> nhd ] = 0 ; hp -> hd [ hp -> nhd ] . b = p ; hp -> hd [ hp -> nhd ] . e = q ; WSLH ( w , fd , hp , hp -> nhd ) ; hp -> nhd ++ ; } else { VSC_C_main -> losthdr ++ ; WSL ( w , SLT_LostHeader , fd , "%.*s" , q - p > 20 ? 20 : q - p , p ) ; return ( 413 ) ; } } return ( 0 ) ; }
static int assign_cfs_rq_runtime ( struct cfs_rq * cfs_rq ) { struct task_group * tg = cfs_rq -> tg ; struct cfs_bandwidth * cfs_b = tg_cfs_bandwidth ( tg ) ; u64 amount = 0 , min_amount , expires ; int expires_seq ; min_amount = sched_cfs_bandwidth_slice ( ) - cfs_rq -> runtime_remaining ; raw_spin_lock ( & cfs_b -> lock ) ; if ( cfs_b -> quota == RUNTIME_INF ) amount = min_amount ; else { start_cfs_bandwidth ( cfs_b ) ; if ( cfs_b -> runtime > 0 ) { amount = min ( cfs_b -> runtime , min_amount ) ; cfs_b -> runtime -= amount ; cfs_b -> idle = 0 ; } } expires_seq = cfs_b -> expires_seq ; expires = cfs_b -> runtime_expires ; raw_spin_unlock ( & cfs_b -> lock ) ; cfs_rq -> runtime_remaining += amount ; if ( cfs_rq -> expires_seq != expires_seq ) { cfs_rq -> expires_seq = expires_seq ; cfs_rq -> runtime_expires = expires ; } return cfs_rq -> runtime_remaining > 0 ; }
create_policy_2_svc ( cpol_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; gss_buffer_desc client_name , service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> rec . policy ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_ADD , NULL , NULL ) ) { ret . code = KADM5_AUTH_ADD ; log_unauth ( "kadm5_create_policy" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_create_policy ( ( void * ) handle , & arg -> rec , arg -> mask ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( "kadm5_create_policy" , ( ( prime_arg == NULL ) ? "(null)" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
nsPasswordManager :: WriteSignonEntryEnumerator ( const nsACString & aKey , SignonHashEntry * aEntry , void * aUserData ) { nsIOutputStream * stream = NS_STATIC_CAST ( nsIOutputStream * , aUserData ) ; PRUint32 bytesWritten ; nsCAutoString buffer ( aKey ) ; buffer . Append ( NS_LINEBREAK ) ; stream -> Write ( buffer . get ( ) , buffer . Length ( ) , & bytesWritten ) ; for ( SignonDataEntry * e = aEntry -> head ; e ; e = e -> next ) { NS_ConvertUTF16toUTF8 userField ( e -> userField ) ; userField . Append ( NS_LINEBREAK ) ; stream -> Write ( userField . get ( ) , userField . Length ( ) , & bytesWritten ) ; buffer . Assign ( NS_ConvertUTF16toUTF8 ( e -> userValue ) ) ; buffer . Append ( NS_LINEBREAK ) ; stream -> Write ( buffer . get ( ) , buffer . Length ( ) , & bytesWritten ) ; buffer . Assign ( "*" ) ; buffer . Append ( NS_ConvertUTF16toUTF8 ( e -> passField ) ) ; buffer . Append ( NS_LINEBREAK ) ; stream -> Write ( buffer . get ( ) , buffer . Length ( ) , & bytesWritten ) ; buffer . Assign ( NS_ConvertUTF16toUTF8 ( e -> passValue ) ) ; buffer . Append ( NS_LINEBREAK ) ; stream -> Write ( buffer . get ( ) , buffer . Length ( ) , & bytesWritten ) ; } buffer . Assign ( "." NS_LINEBREAK ) ; stream -> Write ( buffer . get ( ) , buffer . Length ( ) , & bytesWritten ) ; return PL_DHASH_NEXT ; }
MaybeHandle < Object > StoreIC :: Store ( Handle < Object > object , Handle < Name > name , Handle < Object > value , JSReceiver :: StoreFromKeyed store_mode ) { if ( MigrateDeprecated ( object ) ) { Handle < Object > result ; ASSIGN_RETURN_ON_EXCEPTION ( isolate ( ) , result , Object :: SetProperty ( isolate ( ) , object , name , value , language_mode ( ) ) , Object ) ; return result ; } if ( object -> IsNullOrUndefined ( isolate ( ) ) ) { if ( FLAG_use_ic && state ( ) != PREMONOMORPHIC ) { TRACE_HANDLER_STATS ( isolate ( ) , StoreIC_NonReceiver ) ; update_receiver_map ( object ) ; PatchCache ( name , slow_stub ( ) ) ; TraceIC ( "StoreIC" , name ) ; } return TypeError ( MessageTemplate :: kNonObjectPropertyStore , object , name ) ; } if ( state ( ) != UNINITIALIZED ) { JSObject :: MakePrototypesFast ( object , kStartAtPrototype , isolate ( ) ) ; } LookupIterator it ( isolate ( ) , object , name ) ; bool use_ic = FLAG_use_ic ; if ( name -> IsPrivate ( ) ) { if ( name -> IsPrivateField ( ) && ! it . IsFound ( ) ) { return TypeError ( MessageTemplate :: kInvalidPrivateFieldAccess , object , name ) ; } if ( object -> IsJSProxy ( ) ) { use_ic = false ; } } if ( use_ic ) UpdateCaches ( & it , value , store_mode ) ; MAYBE_RETURN_NULL ( Object :: SetProperty ( & it , value , language_mode ( ) , store_mode ) ) ; return value ; }
int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { int do_rf64 = 0 , write_junk = 1 ; ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; DS64Chunk ds64_chunk ; JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( "can't create valid RIFF wav header for non-normalized floating data!" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( "total_data_bytes = %lld, so rf64" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( "total_data_bytes = %lld, so riff" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? "RF64" : "RIFF" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , "WAVE" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ; if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; strncpy ( fmthdr . ckID , "fmt " , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , "data" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , "junk" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , "ds64" , sizeof ( ds64hdr . ckID ) ) ; ds64hdr . ckSize = sizeof ( ds64_chunk ) ; CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ; ds64_chunk . sampleCount64 = total_samples ; riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; } WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( "can't write .WAV data, disk probably full!" ) ; return FALSE ; } return TRUE ; }
void * sspi_SecureHandleGetLowerPointer ( SecHandle * handle ) { void * pointer ; if ( ! handle ) return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwLower ) ; return pointer ; }
const Operator * SimplifiedOperatorBuilder :: NewDoubleElements ( PretenureFlag pretenure ) { return new ( zone ( ) ) Operator1 < PretenureFlag > ( IrOpcode :: kNewDoubleElements , Operator :: kEliminatable , "NewDoubleElements" , 1 , 1 , 1 , 1 , 1 , 0 , pretenure ) ; }
ParseInfo :: ParseInfo ( Isolate * isolate , Handle < SharedFunctionInfo > shared ) : ParseInfo ( isolate , isolate -> allocator ( ) ) { DCHECK_IMPLIES ( is_toplevel ( ) , ! Script :: cast ( shared -> script ( ) ) -> is_wrapped ( ) ) ; set_toplevel ( shared -> is_toplevel ( ) ) ; set_wrapped_as_function ( shared -> is_wrapped ( ) ) ; set_allow_lazy_parsing ( FLAG_lazy_inner_functions ) ; set_is_named_expression ( shared -> is_named_expression ( ) ) ; set_start_position ( shared -> StartPosition ( ) ) ; set_end_position ( shared -> EndPosition ( ) ) ; function_literal_id_ = shared -> FunctionLiteralId ( isolate ) ; set_language_mode ( shared -> language_mode ( ) ) ; set_function_kind ( shared -> kind ( ) ) ; set_declaration ( shared -> is_declaration ( ) ) ; set_requires_instance_fields_initializer ( shared -> requires_instance_fields_initializer ( ) ) ; set_asm_wasm_broken ( shared -> is_asm_wasm_broken ( ) ) ; Handle < Script > script ( Script :: cast ( shared -> script ( ) ) , isolate ) ; set_script ( script ) ; if ( shared -> HasOuterScopeInfo ( ) ) { set_outer_scope_info ( handle ( shared -> GetOuterScopeInfo ( ) , isolate ) ) ; } set_collect_type_profile ( isolate -> is_collecting_type_profile ( ) && ( shared -> HasFeedbackMetadata ( ) ? shared -> feedback_metadata ( ) -> HasTypeProfileSlot ( ) : script -> IsUserJavaScript ( ) ) ) ; }
chunk_grow ( chunk_t * chunk , size_t sz ) { off_t offset ; size_t memlen_orig = chunk -> memlen ; tor_assert ( sz > chunk -> memlen ) ; offset = chunk -> data - chunk -> mem ; chunk = tor_realloc ( chunk , CHUNK_ALLOC_SIZE ( sz ) ) ; chunk -> memlen = sz ; chunk -> data = chunk -> mem + offset ; #ifdef DEBUG_CHUNK_ALLOC tor_assert ( chunk -> DBG_alloc == CHUNK_ALLOC_SIZE ( memlen_orig ) ) ; chunk -> DBG_alloc = CHUNK_ALLOC_SIZE ( sz ) ; #endif total_bytes_allocated_in_chunks += CHUNK_ALLOC_SIZE ( sz ) - CHUNK_ALLOC_SIZE ( memlen_orig ) ; return chunk ; }
nsStandardURL :: SetPort ( int32_t port ) { ENSURE_MUTABLE ( ) ; LOG ( ( "nsStandardURL::SetPort [port=%d]\n" , port ) ) ; if ( ( port == mPort ) || ( mPort == - 1 && port == mDefaultPort ) ) return NS_OK ; if ( port < - 1 ) return NS_ERROR_MALFORMED_URI ; if ( mURLType == URLTYPE_NO_AUTHORITY ) { NS_WARNING ( "cannot set port on no-auth url" ) ; return NS_ERROR_UNEXPECTED ; } InvalidateCache ( ) ; if ( mPort == - 1 ) { nsAutoCString buf ; buf . Assign ( ':' ) ; buf . AppendInt ( port ) ; mSpec . Insert ( buf , mHost . mPos + mHost . mLen ) ; mAuthority . mLen += buf . Length ( ) ; ShiftFromPath ( buf . Length ( ) ) ; } else if ( port == - 1 || port == mDefaultPort ) { port = - 1 ; uint32_t start = mHost . mPos + mHost . mLen ; int32_t lengthToCut = mPath . mPos - start ; mSpec . Cut ( start , lengthToCut ) ; mAuthority . mLen -= lengthToCut ; ShiftFromPath ( - lengthToCut ) ; } else { nsAutoCString buf ; buf . AppendInt ( port ) ; uint32_t start = mHost . mPos + mHost . mLen + 1 ; uint32_t length = mPath . mPos - start ; mSpec . Replace ( start , length , buf ) ; if ( buf . Length ( ) != length ) { mAuthority . mLen += buf . Length ( ) - length ; ShiftFromPath ( buf . Length ( ) - length ) ; } } mPort = port ; return NS_OK ; }
TryAddTypeBarrierForWrite ( TempAllocator & alloc , types :: CompilerConstraintList * constraints , MBasicBlock * current , types :: TemporaryTypeSet * objTypes , PropertyName * name , MDefinition * * pvalue ) { Maybe < types :: HeapTypeSetKey > aggregateProperty ; for ( size_t i = 0 ; i < objTypes -> getObjectCount ( ) ; i ++ ) { types :: TypeObjectKey * object = objTypes -> getObject ( i ) ; if ( ! object ) continue ; if ( object -> unknownProperties ( ) ) return false ; jsid id = name ? NameToId ( name ) : JSID_VOID ; types :: HeapTypeSetKey property = object -> property ( id ) ; if ( ! property . maybeTypes ( ) ) return false ; if ( TypeSetIncludes ( property . maybeTypes ( ) , ( * pvalue ) -> type ( ) , ( * pvalue ) -> resultTypeSet ( ) ) ) return false ; property . freeze ( constraints ) ; if ( aggregateProperty . empty ( ) ) { aggregateProperty . construct ( property ) ; } else { if ( ! aggregateProperty . ref ( ) . maybeTypes ( ) -> isSubset ( property . maybeTypes ( ) ) || ! property . maybeTypes ( ) -> isSubset ( aggregateProperty . ref ( ) . maybeTypes ( ) ) ) { return false ; } } } JS_ASSERT ( ! aggregateProperty . empty ( ) ) ; MIRType propertyType = MIRTypeFromValueType ( aggregateProperty . ref ( ) . knownTypeTag ( constraints ) ) ; switch ( propertyType ) { case MIRType_Boolean : case MIRType_Int32 : case MIRType_Double : case MIRType_String : { if ( ( * pvalue ) -> type ( ) != MIRType_Value ) { JS_ASSERT ( ( * pvalue ) -> type ( ) != propertyType ) ; return false ; } MInstruction * ins = MUnbox :: New ( alloc , * pvalue , propertyType , MUnbox :: Fallible ) ; current -> add ( ins ) ; * pvalue = ins ; return true ; } default : ; } if ( ( * pvalue ) -> type ( ) != MIRType_Value ) return false ; types :: TemporaryTypeSet * types = aggregateProperty . ref ( ) . maybeTypes ( ) -> clone ( alloc . lifoAlloc ( ) ) ; if ( ! types ) return false ; MInstruction * ins = MMonitorTypes :: New ( alloc , * pvalue , types ) ; current -> add ( ins ) ; return true ; }
TPMI_SM4_KEY_BITS_Unmarshal ( TPMI_SM4_KEY_BITS * target , BYTE * * buffer , INT32 * size ) { TPM_RC rc = TPM_RC_SUCCESS ; if ( rc == TPM_RC_SUCCESS ) { rc = TPM_KEY_BITS_Unmarshal ( target , buffer , size ) ; } if ( rc == TPM_RC_SUCCESS ) { switch ( * target ) { case 128 : break ; default : rc = TPM_RC_VALUE ; } } return rc ; }
static void parse_sec_attr_44 ( sc_file_t * file , const u8 * buf , size_t len ) { const int df_idx [ 8 ] = { SC_AC_OP_DELETE , SC_AC_OP_CREATE , SC_AC_OP_CREATE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , SC_AC_OP_LOCK , SC_AC_OP_DELETE , - 1 } ; const int ef_idx [ 8 ] = { SC_AC_OP_READ , SC_AC_OP_UPDATE , SC_AC_OP_WRITE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , - 1 , SC_AC_OP_ERASE , - 1 } ; const int efi_idx [ 8 ] = { SC_AC_OP_READ , SC_AC_OP_ERASE , SC_AC_OP_UPDATE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , - 1 , SC_AC_OP_ERASE , - 1 } ; u8 bValue ; int i ; int iKeyRef = 0 ; int iMethod ; int iPinCount ; int iOffset = 0 ; int iOperation ; const int * p_idx ; while ( len > 1 ) { size_t iACLen = buf [ iOffset ] & 0x0F ; if ( iACLen > len ) break ; iMethod = SC_AC_NONE ; if ( buf [ iOffset ] & 0X80 ) { size_t iParmLen = 1 ; size_t iKeyLen = 0 ; if ( buf [ iOffset ] & 0x20 ) iKeyLen ++ ; if ( buf [ iOffset + 1 ] & 0x40 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x20 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x10 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x08 ) iParmLen ++ ; if ( iKeyLen ) { int iSC ; if ( len < 1 + ( size_t ) iACLen ) break ; iSC = buf [ iOffset + iACLen ] ; switch ( ( iSC > > 5 ) & 0x03 ) { case 0 : iMethod = SC_AC_TERM ; break ; case 1 : iMethod = SC_AC_AUT ; break ; case 2 : case 3 : iMethod = SC_AC_PRO ; break ; } iKeyRef = iSC & 0x1F ; } if ( iACLen > ( 1 + iParmLen + iKeyLen ) ) { if ( len < 1 + 1 + 1 + ( size_t ) iParmLen ) break ; iKeyRef = buf [ iOffset + 1 + 1 + iParmLen ] ; iMethod = SC_AC_CHV ; } if ( len < 1 + 2 ) break ; switch ( buf [ iOffset + 2 ] ) { case 0x2A : iOperation = SC_AC_OP_CRYPTO ; break ; case 0x46 : iOperation = SC_AC_OP_UPDATE ; break ; default : iOperation = SC_AC_OP_SELECT ; break ; } sc_file_add_acl_entry ( file , iOperation , iMethod , iKeyRef ) ; } else { switch ( file -> type ) { case SC_FILE_TYPE_DF : p_idx = df_idx ; break ; case SC_FILE_TYPE_INTERNAL_EF : p_idx = efi_idx ; break ; default : p_idx = ef_idx ; break ; } iPinCount = iACLen - 1 ; if ( buf [ iOffset ] & 0x20 ) { int iSC ; if ( len < 1 + ( size_t ) iACLen ) break ; iSC = buf [ iOffset + iACLen ] ; switch ( ( iSC > > 5 ) & 0x03 ) { case 0 : iMethod = SC_AC_TERM ; break ; case 1 : iMethod = SC_AC_AUT ; break ; case 2 : case 3 : iMethod = SC_AC_PRO ; break ; } iKeyRef = iSC & 0x1F ; iPinCount -- ; } if ( iPinCount > 0 ) { if ( len < 1 + 2 ) break ; iKeyRef = buf [ iOffset + 2 ] ; iMethod = SC_AC_CHV ; } bValue = buf [ iOffset + 1 ] ; for ( i = 0 ; i < 8 ; i ++ ) { if ( ( bValue & 1 ) && ( p_idx [ i ] >= 0 ) ) sc_file_add_acl_entry ( file , p_idx [ i ] , iMethod , iKeyRef ) ; bValue >>= 1 ; } } iOffset += iACLen + 1 ; len -= iACLen + 1 ; } }
nsresult nsContentUtils :: IPCTransferableToTransferable ( const IPCDataTransfer & aDataTransfer , const bool & aIsPrivateData , nsIPrincipal * aRequestingPrincipal , const nsContentPolicyType & aContentPolicyType , bool aAddDataFlavor , nsITransferable * aTransferable ) { aTransferable -> SetIsPrivateData ( aIsPrivateData ) ; nsresult rv = IPCTransferableToTransferable ( aDataTransfer , aAddDataFlavor , aTransferable ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; aTransferable -> SetRequestingPrincipal ( aRequestingPrincipal ) ; aTransferable -> SetContentPolicyType ( aContentPolicyType ) ; return NS_OK ; }
bool Linkage :: NeedsFrameStateInput ( Runtime :: FunctionId function ) { switch ( function ) { case Runtime :: kAbort : case Runtime :: kAllocateInTargetSpace : case Runtime :: kCreateIterResultObject : case Runtime :: kIncBlockCounter : case Runtime :: kIsFunction : case Runtime :: kNewClosure : case Runtime :: kNewClosure_Tenured : case Runtime :: kNewFunctionContext : case Runtime :: kPushBlockContext : case Runtime :: kPushCatchContext : case Runtime :: kReThrow : case Runtime :: kStringEqual : case Runtime :: kStringNotEqual : case Runtime :: kStringLessThan : case Runtime :: kStringLessThanOrEqual : case Runtime :: kStringGreaterThan : case Runtime :: kStringGreaterThanOrEqual : case Runtime :: kToFastProperties : case Runtime :: kTraceEnter : case Runtime :: kTraceExit : return false ; case Runtime :: kInlineCreateIterResultObject : case Runtime :: kInlineGeneratorClose : case Runtime :: kInlineGeneratorGetInputOrDebugPos : case Runtime :: kInlineGeneratorGetResumeMode : case Runtime :: kInlineCreateJSGeneratorObject : case Runtime :: kInlineIsArray : case Runtime :: kInlineIsJSReceiver : case Runtime :: kInlineIsRegExp : case Runtime :: kInlineIsSmi : case Runtime :: kInlineIsTypedArray : return false ; default : break ; } return true ; }
image_transform_png_set_strip_alpha_mod ( PNG_CONST image_transform * this , image_pixel * that , png_const_structp pp , PNG_CONST transform_display * display ) { if ( that -> colour_type == PNG_COLOR_TYPE_GRAY_ALPHA ) that -> colour_type = PNG_COLOR_TYPE_GRAY ; else if ( that -> colour_type == PNG_COLOR_TYPE_RGB_ALPHA ) that -> colour_type = PNG_COLOR_TYPE_RGB ; that -> have_tRNS = 0 ; that -> alphaf = 1 ; this -> next -> mod ( this -> next , that , pp , display ) ; }
void impeg2d_flush_ext_and_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }
static int command_read ( struct pci_dev * dev , int offset , u16 * value , void * data ) { int i ; int ret ; ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; if ( ! pci_is_enabled ( dev ) ) return ret ; for ( i = 0 ; i < PCI_ROM_RESOURCE ; i ++ ) { if ( dev -> resource [ i ] . flags & IORESOURCE_IO ) * value |= PCI_COMMAND_IO ; if ( dev -> resource [ i ] . flags & IORESOURCE_MEM ) * value |= PCI_COMMAND_MEMORY ; } return ret ; }
static int pit_ioport_read ( struct kvm_io_device * this , gpa_t addr , int len , void * data ) { struct kvm_pit * pit = dev_to_pit ( this ) ; struct kvm_kpit_state * pit_state = & pit -> pit_state ; struct kvm * kvm = pit -> kvm ; int ret , count ; struct kvm_kpit_channel_state * s ; if ( ! pit_in_range ( addr ) ) return - EOPNOTSUPP ; addr &= KVM_PIT_CHANNEL_MASK ; s = & pit_state -> channels [ addr ] ; mutex_lock ( & pit_state -> lock ) ; if ( s -> status_latched ) { s -> status_latched = 0 ; ret = s -> status ; } else if ( s -> count_latched ) { switch ( s -> count_latched ) { default : case RW_STATE_LSB : ret = s -> latched_count & 0xff ; s -> count_latched = 0 ; break ; case RW_STATE_MSB : ret = s -> latched_count > > 8 ; s -> count_latched = 0 ; break ; case RW_STATE_WORD0 : ret = s -> latched_count & 0xff ; s -> count_latched = RW_STATE_MSB ; break ; } } else { switch ( s -> read_state ) { default : case RW_STATE_LSB : count = pit_get_count ( kvm , addr ) ; ret = count & 0xff ; break ; case RW_STATE_MSB : count = pit_get_count ( kvm , addr ) ; ret = ( count > > 8 ) & 0xff ; break ; case RW_STATE_WORD0 : count = pit_get_count ( kvm , addr ) ; ret = count & 0xff ; s -> read_state = RW_STATE_WORD1 ; break ; case RW_STATE_WORD1 : count = pit_get_count ( kvm , addr ) ; ret = ( count > > 8 ) & 0xff ; s -> read_state = RW_STATE_WORD0 ; break ; } } if ( len > sizeof ( ret ) ) len = sizeof ( ret ) ; memcpy ( data , ( char * ) & ret , len ) ; mutex_unlock ( & pit_state -> lock ) ; return 0 ; }
nsObjectLoadingContent :: InstantiatePluginInstance ( const char * aMimeType , nsIURI * aURI ) { if ( ! mShouldPlay ) { return NS_ERROR_PLUGIN_CLICKTOPLAY ; } if ( mInstanceOwner ) { return NS_OK ; } if ( mInstantiating ) { return NS_OK ; } mInstantiating = true ; AutoSetInstantiatingToFalse autoInstantiating ( this ) ; nsCOMPtr < nsIObjectLoadingContent > kungFuDeathGrip = this ; nsCOMPtr < nsIContent > thisContent = do_QueryInterface ( static_cast < nsIImageLoadingContent * > ( this ) ) ; nsCOMPtr < nsIURI > baseURI ; if ( ! aURI ) { GetObjectBaseURI ( thisContent , getter_AddRefs ( baseURI ) ) ; aURI = baseURI ; } nsIDocument * doc = thisContent -> GetCurrentDoc ( ) ; if ( ! doc ) { return NS_ERROR_FAILURE ; } doc -> FlushPendingNotifications ( Flush_Layout ) ; nsresult rv = NS_ERROR_FAILURE ; nsCOMPtr < nsIPluginHost > pluginHostCOM ( do_GetService ( MOZ_PLUGIN_HOST_CONTRACTID , & rv ) ) ; nsPluginHost * pluginHost = static_cast < nsPluginHost * > ( pluginHostCOM . get ( ) ) ; if ( NS_FAILED ( rv ) ) { return rv ; } nsCOMPtr < nsIAppShell > appShell = do_GetService ( kAppShellCID ) ; if ( appShell ) { appShell -> SuspendNative ( ) ; } nsCOMPtr < nsIPluginDocument > pDoc ( do_QueryInterface ( doc ) ) ; bool fullPageMode = false ; if ( pDoc ) { pDoc -> GetWillHandleInstantiation ( & fullPageMode ) ; } if ( fullPageMode ) { nsCOMPtr < nsIStreamListener > stream ; rv = pluginHost -> InstantiateFullPagePlugin ( aMimeType , aURI , this , getter_AddRefs ( mInstanceOwner ) , getter_AddRefs ( stream ) ) ; if ( NS_SUCCEEDED ( rv ) ) { pDoc -> SetStreamListener ( stream ) ; } } else { rv = pluginHost -> InstantiateEmbeddedPlugin ( aMimeType , aURI , this , getter_AddRefs ( mInstanceOwner ) ) ; } if ( appShell ) { appShell -> ResumeNative ( ) ; } if ( NS_FAILED ( rv ) ) { return rv ; } NotifyContentObjectWrapper ( ) ; nsRefPtr < nsNPAPIPluginInstance > pluginInstance ; GetPluginInstance ( getter_AddRefs ( pluginInstance ) ) ; if ( pluginInstance ) { nsCOMPtr < nsIPluginTag > pluginTag ; pluginHost -> GetPluginTagForInstance ( pluginInstance , getter_AddRefs ( pluginTag ) ) ; nsCOMPtr < nsIBlocklistService > blocklist = do_GetService ( "@mozilla.org/extensions/blocklist;1" ) ; if ( blocklist ) { PRUint32 blockState = nsIBlocklistService :: STATE_NOT_BLOCKED ; blocklist -> GetPluginBlocklistState ( pluginTag , EmptyString ( ) , EmptyString ( ) , & blockState ) ; if ( blockState == nsIBlocklistService :: STATE_OUTDATED ) FirePluginError ( thisContent , ePluginOutdated ) ; } } return NS_OK ; }
static int v4l2_loopback_add ( struct v4l2_loopback_config * conf , int * ret_nr ) { struct v4l2_loopback_device * dev ; struct v4l2_ctrl_handler * hdl ; struct v4l2loopback_private * vdev_priv = NULL ; int err = - ENOMEM ; int _max_width = DEFAULT_FROM_CONF ( max_width , < V4L2LOOPBACK_SIZE_MIN_WIDTH , max_width ) ; int _max_height = DEFAULT_FROM_CONF ( max_height , < V4L2LOOPBACK_SIZE_MIN_HEIGHT , max_height ) ; bool _announce_all_caps = ( conf && conf -> announce_all_caps >= 0 ) ? ( conf -> announce_all_caps ) : V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS ; int _max_buffers = DEFAULT_FROM_CONF ( max_buffers , <= 0 , max_buffers ) ; int _max_openers = DEFAULT_FROM_CONF ( max_openers , <= 0 , max_openers ) ; int nr = - 1 ; _announce_all_caps = ( ! ! _announce_all_caps ) ; if ( conf ) { if ( conf -> capture_nr >= 0 && conf -> output_nr == conf -> capture_nr ) { nr = conf -> capture_nr ; } else if ( conf -> capture_nr < 0 && conf -> output_nr < 0 ) { nr = - 1 ; } else if ( conf -> capture_nr < 0 ) { nr = conf -> output_nr ; } else if ( conf -> output_nr < 0 ) { nr = conf -> capture_nr ; } else { printk ( KERN_ERR "split OUTPUT and CAPTURE devices not yet supported." ) ; printk ( KERN_INFO "both devices must have the same number (%d != %d)." , conf -> output_nr , conf -> capture_nr ) ; return - EINVAL ; } } if ( idr_find ( & v4l2loopback_index_idr , nr ) ) return - EEXIST ; dprintk ( "creating v4l2loopback-device #%d\n" , nr ) ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; if ( nr >= 0 ) { err = idr_alloc ( & v4l2loopback_index_idr , dev , nr , nr + 1 , GFP_KERNEL ) ; if ( err == - ENOSPC ) err = - EEXIST ; } else { err = idr_alloc ( & v4l2loopback_index_idr , dev , 0 , 0 , GFP_KERNEL ) ; } if ( err < 0 ) goto out_free_dev ; nr = err ; err = - ENOMEM ; if ( conf && conf -> card_label && * ( conf -> card_label ) ) { snprintf ( dev -> card_label , sizeof ( dev -> card_label ) , "%s" , conf -> card_label ) ; } else { snprintf ( dev -> card_label , sizeof ( dev -> card_label ) , "Dummy video device (0x%04X)" , nr ) ; } snprintf ( dev -> v4l2_dev . name , sizeof ( dev -> v4l2_dev . name ) , "v4l2loopback-%03d" , nr ) ; err = v4l2_device_register ( NULL , & dev -> v4l2_dev ) ; if ( err ) goto out_free_idr ; MARK ( ) ; dev -> vdev = video_device_alloc ( ) ; if ( dev -> vdev == NULL ) { err = - ENOMEM ; goto out_unregister ; } vdev_priv = kzalloc ( sizeof ( struct v4l2loopback_private ) , GFP_KERNEL ) ; if ( vdev_priv == NULL ) { err = - ENOMEM ; goto out_unregister ; } video_set_drvdata ( dev -> vdev , vdev_priv ) ; if ( video_get_drvdata ( dev -> vdev ) == NULL ) { err = - ENOMEM ; goto out_unregister ; } MARK ( ) ; snprintf ( dev -> vdev -> name , sizeof ( dev -> vdev -> name ) , dev -> card_label ) ; vdev_priv -> device_nr = nr ; init_vdev ( dev -> vdev , nr ) ; dev -> vdev -> v4l2_dev = & dev -> v4l2_dev ; init_capture_param ( & dev -> capture_param ) ; err = set_timeperframe ( dev , & dev -> capture_param . timeperframe ) ; if ( err ) goto out_unregister ; dev -> keep_format = 0 ; dev -> sustain_framerate = 0 ; dev -> announce_all_caps = _announce_all_caps ; dev -> max_width = _max_width ; dev -> max_height = _max_height ; dev -> max_openers = _max_openers ; dev -> buffers_number = dev -> used_buffers = _max_buffers ; dev -> write_position = 0 ; MARK ( ) ; spin_lock_init ( & dev -> lock ) ; INIT_LIST_HEAD ( & dev -> outbufs_list ) ; if ( list_empty ( & dev -> outbufs_list ) ) { int i ; for ( i = 0 ; i < dev -> used_buffers ; ++ i ) list_add_tail ( & dev -> buffers [ i ] . list_head , & dev -> outbufs_list ) ; } memset ( dev -> bufpos2index , 0 , sizeof ( dev -> bufpos2index ) ) ; atomic_set ( & dev -> open_count , 0 ) ; dev -> ready_for_capture = 0 ; dev -> ready_for_output = 1 ; dev -> buffer_size = 0 ; dev -> image = NULL ; dev -> imagesize = 0 ; #ifdef HAVE_TIMER_SETUP timer_setup ( & dev -> sustain_timer , sustain_timer_clb , 0 ) ; timer_setup ( & dev -> timeout_timer , timeout_timer_clb , 0 ) ; #else setup_timer ( & dev -> sustain_timer , sustain_timer_clb , nr ) ; setup_timer ( & dev -> timeout_timer , timeout_timer_clb , nr ) ; #endif dev -> reread_count = 0 ; dev -> timeout_jiffies = 0 ; dev -> timeout_image = NULL ; dev -> timeout_happened = 0 ; hdl = & dev -> ctrl_handler ; err = v4l2_ctrl_handler_init ( hdl , 4 ) ; if ( err ) goto out_unregister ; v4l2_ctrl_new_custom ( hdl , & v4l2loopback_ctrl_keepformat , NULL ) ; v4l2_ctrl_new_custom ( hdl , & v4l2loopback_ctrl_sustainframerate , NULL ) ; v4l2_ctrl_new_custom ( hdl , & v4l2loopback_ctrl_timeout , NULL ) ; v4l2_ctrl_new_custom ( hdl , & v4l2loopback_ctrl_timeoutimageio , NULL ) ; if ( hdl -> error ) { err = hdl -> error ; goto out_free_handler ; } dev -> v4l2_dev . ctrl_handler = hdl ; err = v4l2_ctrl_handler_setup ( hdl ) ; if ( err ) goto out_free_handler ; dev -> pix_format . width = 0 ; dev -> pix_format . height = 0 ; dev -> pix_format . pixelformat = formats [ 0 ] . fourcc ; dev -> pix_format . colorspace = V4L2_COLORSPACE_SRGB ; dev -> pix_format . field = V4L2_FIELD_NONE ; dev -> buffer_size = PAGE_ALIGN ( dev -> pix_format . sizeimage ) ; dprintk ( "buffer_size = %ld (=%d)\n" , dev -> buffer_size , dev -> pix_format . sizeimage ) ; if ( dev -> buffer_size && ( ( err = allocate_buffers ( dev ) ) < 0 ) ) goto out_free_handler ; init_waitqueue_head ( & dev -> read_event ) ; if ( video_register_device ( dev -> vdev , VFL_TYPE_VIDEO , nr ) < 0 ) { printk ( KERN_ERR "v4l2loopback: failed video_register_device()\n" ) ; err = - EFAULT ; goto out_free_device ; } v4l2loopback_create_sysfs ( dev -> vdev ) ; MARK ( ) ; if ( ret_nr ) * ret_nr = dev -> vdev -> num ; return 0 ; out_free_device : video_device_release ( dev -> vdev ) ; out_free_handler : v4l2_ctrl_handler_free ( & dev -> ctrl_handler ) ; out_unregister : video_set_drvdata ( dev -> vdev , NULL ) ; if ( vdev_priv != NULL ) kfree ( vdev_priv ) ; v4l2_device_unregister ( & dev -> v4l2_dev ) ; out_free_idr : idr_remove ( & v4l2loopback_index_idr , nr ) ; out_free_dev : kfree ( dev ) ; return err ; }
Network :: FilterStatus Context :: onNetworkNewConnection ( ) { onCreate ( root_context_id_ ) ; if ( ! wasm_ -> onNewConnection_ ) { return Network :: FilterStatus :: Continue ; } if ( wasm_ -> onNewConnection_ ( this , id_ ) . u64_ == 0 ) { return Network :: FilterStatus :: Continue ; } return Network :: FilterStatus :: StopIteration ; }
bool LazyStubTier :: createTier2 ( const Uint32Vector & funcExportIndices , const CodeTier & codeTier , Maybe < size_t > * outStubSegmentIndex ) { if ( ! funcExportIndices . length ( ) ) { return true ; } bool flushAllThreadIcaches = true ; size_t stubSegmentIndex ; if ( ! createManyEntryStubs ( funcExportIndices , codeTier , flushAllThreadIcaches , & stubSegmentIndex ) ) { return false ; } outStubSegmentIndex -> emplace ( stubSegmentIndex ) ; return true ; }
static pjmedia_sdp_attr * parse_attr ( pj_pool_t * pool , pj_scanner * scanner , volatile parse_context * ctx ) { pjmedia_sdp_attr * attr ; ctx -> last_error = PJMEDIA_SDP_EINATTR ; attr = PJ_POOL_ALLOC_T ( pool , pjmedia_sdp_attr ) ; if ( * ( scanner -> curptr + 1 ) != '=' ) { on_scanner_error ( scanner ) ; return NULL ; } pj_scan_advance_n ( scanner , 2 , SKIP_WS ) ; pj_scan_get ( scanner , & cs_token , & attr -> name ) ; if ( * scanner -> curptr && * scanner -> curptr != '\r' && * scanner -> curptr != '\n' ) { if ( * scanner -> curptr == ':' ) pj_scan_get_char ( scanner ) ; if ( * scanner -> curptr != '\r' && * scanner -> curptr != '\n' ) { pj_scan_get_until_chr ( scanner , "\r\n" , & attr -> value ) ; } else { attr -> value . ptr = NULL ; attr -> value . slen = 0 ; } } else { attr -> value . ptr = NULL ; attr -> value . slen = 0 ; } pj_scan_skip_line ( scanner ) ; return attr ; }
mconvert ( struct magic_set * ms , struct magic * m , int flip ) { union VALUETYPE * p = & ms -> ms_value ; uint8_t type ; switch ( type = cvt_flip ( m -> type , flip ) ) { case FILE_BYTE : cvt_8 ( p , m ) ; return 1 ; case FILE_SHORT : cvt_16 ( p , m ) ; return 1 ; case FILE_LONG : case FILE_DATE : case FILE_LDATE : cvt_32 ( p , m ) ; return 1 ; case FILE_QUAD : case FILE_QDATE : case FILE_QLDATE : case FILE_QWDATE : cvt_64 ( p , m ) ; return 1 ; case FILE_STRING : case FILE_BESTRING16 : case FILE_LESTRING16 : { p -> s [ sizeof ( p -> s ) - 1 ] = '\0' ; return 1 ; } case FILE_PSTRING : { size_t sz = file_pstring_length_size ( m ) ; char * ptr1 = p -> s , * ptr2 = ptr1 + sz ; size_t len = file_pstring_get_length ( m , ptr1 ) ; if ( len >= sizeof ( p -> s ) ) { len = sizeof ( p -> s ) - sz ; } while ( len -- ) * ptr1 ++ = * ptr2 ++ ; * ptr1 = '\0' ; return 1 ; } case FILE_BESHORT : p -> h = ( short ) ( ( p -> hs [ 0 ] < < 8 ) | ( p -> hs [ 1 ] ) ) ; cvt_16 ( p , m ) ; return 1 ; case FILE_BELONG : case FILE_BEDATE : case FILE_BELDATE : p -> l = ( int32_t ) ( ( p -> hl [ 0 ] < < 24 ) | ( p -> hl [ 1 ] < < 16 ) | ( p -> hl [ 2 ] < < 8 ) | ( p -> hl [ 3 ] ) ) ; if ( type == FILE_BELONG ) cvt_32 ( p , m ) ; return 1 ; case FILE_BEQUAD : case FILE_BEQDATE : case FILE_BEQLDATE : case FILE_BEQWDATE : p -> q = ( uint64_t ) ( ( ( uint64_t ) p -> hq [ 0 ] < < 56 ) | ( ( uint64_t ) p -> hq [ 1 ] < < 48 ) | ( ( uint64_t ) p -> hq [ 2 ] < < 40 ) | ( ( uint64_t ) p -> hq [ 3 ] < < 32 ) | ( ( uint64_t ) p -> hq [ 4 ] < < 24 ) | ( ( uint64_t ) p -> hq [ 5 ] < < 16 ) | ( ( uint64_t ) p -> hq [ 6 ] < < 8 ) | ( ( uint64_t ) p -> hq [ 7 ] ) ) ; if ( type == FILE_BEQUAD ) cvt_64 ( p , m ) ; return 1 ; case FILE_LESHORT : p -> h = ( short ) ( ( p -> hs [ 1 ] < < 8 ) | ( p -> hs [ 0 ] ) ) ; cvt_16 ( p , m ) ; return 1 ; case FILE_LELONG : case FILE_LEDATE : case FILE_LELDATE : p -> l = ( int32_t ) ( ( p -> hl [ 3 ] < < 24 ) | ( p -> hl [ 2 ] < < 16 ) | ( p -> hl [ 1 ] < < 8 ) | ( p -> hl [ 0 ] ) ) ; if ( type == FILE_LELONG ) cvt_32 ( p , m ) ; return 1 ; case FILE_LEQUAD : case FILE_LEQDATE : case FILE_LEQLDATE : case FILE_LEQWDATE : p -> q = ( uint64_t ) ( ( ( uint64_t ) p -> hq [ 7 ] < < 56 ) | ( ( uint64_t ) p -> hq [ 6 ] < < 48 ) | ( ( uint64_t ) p -> hq [ 5 ] < < 40 ) | ( ( uint64_t ) p -> hq [ 4 ] < < 32 ) | ( ( uint64_t ) p -> hq [ 3 ] < < 24 ) | ( ( uint64_t ) p -> hq [ 2 ] < < 16 ) | ( ( uint64_t ) p -> hq [ 1 ] < < 8 ) | ( ( uint64_t ) p -> hq [ 0 ] ) ) ; if ( type == FILE_LEQUAD ) cvt_64 ( p , m ) ; return 1 ; case FILE_MELONG : case FILE_MEDATE : case FILE_MELDATE : p -> l = ( int32_t ) ( ( p -> hl [ 1 ] < < 24 ) | ( p -> hl [ 0 ] < < 16 ) | ( p -> hl [ 3 ] < < 8 ) | ( p -> hl [ 2 ] ) ) ; if ( type == FILE_MELONG ) cvt_32 ( p , m ) ; return 1 ; case FILE_FLOAT : cvt_float ( p , m ) ; return 1 ; case FILE_BEFLOAT : p -> l = ( ( uint32_t ) p -> hl [ 0 ] < < 24 ) | ( ( uint32_t ) p -> hl [ 1 ] < < 16 ) | ( ( uint32_t ) p -> hl [ 2 ] < < 8 ) | ( ( uint32_t ) p -> hl [ 3 ] ) ; cvt_float ( p , m ) ; return 1 ; case FILE_LEFLOAT : p -> l = ( ( uint32_t ) p -> hl [ 3 ] < < 24 ) | ( ( uint32_t ) p -> hl [ 2 ] < < 16 ) | ( ( uint32_t ) p -> hl [ 1 ] < < 8 ) | ( ( uint32_t ) p -> hl [ 0 ] ) ; cvt_float ( p , m ) ; return 1 ; case FILE_DOUBLE : cvt_double ( p , m ) ; return 1 ; case FILE_BEDOUBLE : p -> q = ( ( uint64_t ) p -> hq [ 0 ] < < 56 ) | ( ( uint64_t ) p -> hq [ 1 ] < < 48 ) | ( ( uint64_t ) p -> hq [ 2 ] < < 40 ) | ( ( uint64_t ) p -> hq [ 3 ] < < 32 ) | ( ( uint64_t ) p -> hq [ 4 ] < < 24 ) | ( ( uint64_t ) p -> hq [ 5 ] < < 16 ) | ( ( uint64_t ) p -> hq [ 6 ] < < 8 ) | ( ( uint64_t ) p -> hq [ 7 ] ) ; cvt_double ( p , m ) ; return 1 ; case FILE_LEDOUBLE : p -> q = ( ( uint64_t ) p -> hq [ 7 ] < < 56 ) | ( ( uint64_t ) p -> hq [ 6 ] < < 48 ) | ( ( uint64_t ) p -> hq [ 5 ] < < 40 ) | ( ( uint64_t ) p -> hq [ 4 ] < < 32 ) | ( ( uint64_t ) p -> hq [ 3 ] < < 24 ) | ( ( uint64_t ) p -> hq [ 2 ] < < 16 ) | ( ( uint64_t ) p -> hq [ 1 ] < < 8 ) | ( ( uint64_t ) p -> hq [ 0 ] ) ; cvt_double ( p , m ) ; return 1 ; case FILE_REGEX : case FILE_SEARCH : case FILE_DEFAULT : case FILE_CLEAR : case FILE_NAME : case FILE_USE : return 1 ; default : file_magerror ( ms , "invalid type %d in mconvert()" , m -> type ) ; return 0 ; } }
void RegExpMacroAssemblerX64 :: WriteStackPointerToRegister ( int reg ) { __ movp ( rax , backtrack_stackpointer ( ) ) ; __ subp ( rax , Operand ( rbp , kStackHighEnd ) ) ; __ movp ( register_location ( reg ) , rax ) ; }
nsScriptLoader :: StartLoad ( nsScriptLoadRequest * aRequest , const nsAString & aType , bool aScriptFromHead ) { MOZ_ASSERT ( aRequest -> IsLoading ( ) ) ; if ( mDocument -> GetSandboxFlags ( ) & SANDBOXED_SCRIPTS ) { return NS_OK ; } if ( aRequest -> IsModuleRequest ( ) ) { nsModuleLoadRequest * request = aRequest -> AsModuleRequest ( ) ; if ( ModuleMapContainsModule ( request ) ) { WaitForModuleFetch ( request ) -> Then ( AbstractThread :: GetCurrent ( ) , __func__ , request , & nsModuleLoadRequest :: ModuleLoaded , & nsModuleLoadRequest :: LoadFailed ) ; return NS_OK ; } SetModuleFetchStarted ( request ) ; } nsContentPolicyType contentPolicyType = aRequest -> IsPreload ( ) ? nsIContentPolicy :: TYPE_INTERNAL_SCRIPT_PRELOAD : nsIContentPolicy :: TYPE_INTERNAL_SCRIPT ; nsCOMPtr < nsINode > context ; if ( aRequest -> mElement ) { context = do_QueryInterface ( aRequest -> mElement ) ; } else { context = mDocument ; } nsCOMPtr < nsILoadGroup > loadGroup = mDocument -> GetDocumentLoadGroup ( ) ; nsCOMPtr < nsPIDOMWindowOuter > window = mDocument -> MasterDocument ( ) -> GetWindow ( ) ; NS_ENSURE_TRUE ( window , NS_ERROR_NULL_POINTER ) ; nsIDocShell * docshell = window -> GetDocShell ( ) ; nsCOMPtr < nsIInterfaceRequestor > prompter ( do_QueryInterface ( docshell ) ) ; nsSecurityFlags securityFlags ; securityFlags = aRequest -> mCORSMode == CORS_NONE ? nsILoadInfo :: SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL : nsILoadInfo :: SEC_REQUIRE_CORS_DATA_INHERITS ; if ( aRequest -> mCORSMode == CORS_ANONYMOUS ) { securityFlags |= nsILoadInfo :: SEC_COOKIES_SAME_ORIGIN ; } else if ( aRequest -> mCORSMode == CORS_USE_CREDENTIALS ) { securityFlags |= nsILoadInfo :: SEC_COOKIES_INCLUDE ; } securityFlags |= nsILoadInfo :: SEC_ALLOW_CHROME ; nsCOMPtr < nsIChannel > channel ; nsresult rv = NS_NewChannel ( getter_AddRefs ( channel ) , aRequest -> mURI , context , securityFlags , contentPolicyType , loadGroup , prompter , nsIRequest :: LOAD_NORMAL | nsIChannel :: LOAD_CLASSIFY_URI ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsIScriptElement * script = aRequest -> mElement ; nsCOMPtr < nsIClassOfService > cos ( do_QueryInterface ( channel ) ) ; if ( cos ) { if ( aScriptFromHead && ! ( script && ( script -> GetScriptAsync ( ) || script -> GetScriptDeferred ( ) ) ) ) { cos -> AddClassFlags ( nsIClassOfService :: Leader ) ; } else if ( ! ( script && script -> GetScriptDeferred ( ) ) ) { cos -> AddClassFlags ( nsIClassOfService :: Unblocked ) ; } } nsCOMPtr < nsIHttpChannel > httpChannel ( do_QueryInterface ( channel ) ) ; if ( httpChannel ) { httpChannel -> SetRequestHeader ( NS_LITERAL_CSTRING ( "Accept" ) , NS_LITERAL_CSTRING ( "*/*" ) , false ) ; httpChannel -> SetReferrerWithPolicy ( mDocument -> GetDocumentURI ( ) , aRequest -> mReferrerPolicy ) ; } nsCOMPtr < nsILoadContext > loadContext ( do_QueryInterface ( docshell ) ) ; mozilla :: net :: PredictorLearn ( aRequest -> mURI , mDocument -> GetDocumentURI ( ) , nsINetworkPredictor :: LEARN_LOAD_SUBRESOURCE , loadContext ) ; nsCOMPtr < nsITimedChannel > timedChannel ( do_QueryInterface ( httpChannel ) ) ; if ( timedChannel ) { timedChannel -> SetInitiatorType ( NS_LITERAL_STRING ( "script" ) ) ; } nsAutoPtr < mozilla :: dom :: SRICheckDataVerifier > sriDataVerifier ; if ( ! aRequest -> mIntegrity . IsEmpty ( ) ) { sriDataVerifier = new SRICheckDataVerifier ( aRequest -> mIntegrity , mDocument ) ; } RefPtr < nsScriptLoadHandler > handler = new nsScriptLoadHandler ( this , aRequest , sriDataVerifier . forget ( ) ) ; nsCOMPtr < nsIIncrementalStreamLoader > loader ; rv = NS_NewIncrementalStreamLoader ( getter_AddRefs ( loader ) , handler ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; return channel -> AsyncOpen2 ( loader ) ; }
Response V8HeapProfilerAgentImpl :: startTrackingHeapObjects ( Maybe < bool > trackAllocations ) { m_state -> setBoolean ( HeapProfilerAgentState :: heapObjectsTrackingEnabled , true ) ; bool allocationTrackingEnabled = trackAllocations . fromMaybe ( false ) ; m_state -> setBoolean ( HeapProfilerAgentState :: allocationTrackingEnabled , allocationTrackingEnabled ) ; startTrackingHeapObjectsInternal ( allocationTrackingEnabled ) ; return Response :: OK ( ) ; }
JSFunction * GetTypedArrayFun ( ExternalArrayType type , Isolate * isolate ) { NativeContext * native_context = isolate -> context ( ) -> native_context ( ) ; switch ( type ) { #define TYPED_ARRAY_FUN(Type, type, TYPE, ctype) \  case kExternal##Type##Array:                   \  return native_context->type##_array_fun(); TYPED_ARRAYS ( TYPED_ARRAY_FUN ) #undef TYPED_ARRAY_FUN } UNREACHABLE ( ) ; }
int ZEXPORT deflateInit2_ ( strm , level , method , windowBits , memLevel , strategy , version , stream_size ) z_streamp strm ; int level ; int method ; int windowBits ; int memLevel ; int strategy ; const char * version ; int stream_size ; { deflate_state * s ; int wrap = 1 ; static const char my_version [ ] = ZLIB_VERSION ; ushf * overlay ; if ( version == Z_NULL || version [ 0 ] != my_version [ 0 ] || stream_size != sizeof ( z_stream ) ) { return Z_VERSION_ERROR ; } if ( strm == Z_NULL ) return Z_STREAM_ERROR ; strm -> msg = Z_NULL ; if ( strm -> zalloc == ( alloc_func ) 0 ) { #ifdef Z_SOLO return Z_STREAM_ERROR ; #else strm -> zalloc = zcalloc ; strm -> opaque = ( voidpf ) 0 ; #endif } if ( strm -> zfree == ( free_func ) 0 ) #ifdef Z_SOLO return Z_STREAM_ERROR ; #else strm -> zfree = zcfree ; #endif #ifdef FASTEST if ( level != 0 ) level = 1 ; #else if ( level == Z_DEFAULT_COMPRESSION ) level = 6 ; #endif if ( windowBits < 0 ) { wrap = 0 ; windowBits = - windowBits ; } #ifdef GZIP else if ( windowBits > 15 ) { wrap = 2 ; windowBits -= 16 ; } #endif if ( memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || ( windowBits == 8 && wrap != 1 ) ) { return Z_STREAM_ERROR ; } if ( windowBits == 8 ) windowBits = 9 ; s = ( deflate_state * ) ZALLOC ( strm , 1 , sizeof ( deflate_state ) ) ; if ( s == Z_NULL ) return Z_MEM_ERROR ; strm -> state = ( struct internal_state FAR * ) s ; s -> strm = strm ; s -> status = INIT_STATE ; s -> wrap = wrap ; s -> gzhead = Z_NULL ; s -> w_bits = ( uInt ) windowBits ; s -> w_size = 1 < < s -> w_bits ; s -> w_mask = s -> w_size - 1 ; s -> hash_bits = ( uInt ) memLevel + 7 ; s -> hash_size = 1 < < s -> hash_bits ; s -> hash_mask = s -> hash_size - 1 ; s -> hash_shift = ( ( s -> hash_bits + MIN_MATCH - 1 ) / MIN_MATCH ) ; s -> window = ( Bytef * ) ZALLOC ( strm , s -> w_size , 2 * sizeof ( Byte ) ) ; s -> prev = ( Posf * ) ZALLOC ( strm , s -> w_size , sizeof ( Pos ) ) ; s -> head = ( Posf * ) ZALLOC ( strm , s -> hash_size , sizeof ( Pos ) ) ; s -> high_water = 0 ; s -> lit_bufsize = 1 < < ( memLevel + 6 ) ; overlay = ( ushf * ) ZALLOC ( strm , s -> lit_bufsize , sizeof ( ush ) + 2 ) ; s -> pending_buf = ( uchf * ) overlay ; s -> pending_buf_size = ( ulg ) s -> lit_bufsize * ( sizeof ( ush ) + 2L ) ; if ( s -> window == Z_NULL || s -> prev == Z_NULL || s -> head == Z_NULL || s -> pending_buf == Z_NULL ) { s -> status = FINISH_STATE ; strm -> msg = ERR_MSG ( Z_MEM_ERROR ) ; deflateEnd ( strm ) ; return Z_MEM_ERROR ; } s -> d_buf = overlay + s -> lit_bufsize / sizeof ( ush ) ; s -> l_buf = s -> pending_buf + ( 1 + sizeof ( ush ) ) * s -> lit_bufsize ; s -> level = level ; s -> strategy = strategy ; s -> method = ( Byte ) method ; return deflateReset ( strm ) ; }
c2_status_t map ( size_t offset , size_t size , C2MemoryUsage usage , C2Fence * fence , void * * addr ) { ( void ) fence ; * addr = nullptr ; if ( ! mMappings . empty ( ) ) { ALOGV ( "multiple map" ) ; } if ( size == 0 ) { return C2_BAD_VALUE ; } int prot = PROT_NONE ; int flags = MAP_SHARED ; if ( usage . expected & C2MemoryUsage :: CPU_READ ) { prot |= PROT_READ ; } if ( usage . expected & C2MemoryUsage :: CPU_WRITE ) { prot |= PROT_WRITE ; } size_t alignmentBytes = offset % PAGE_SIZE ; size_t mapOffset = offset - alignmentBytes ; size_t mapSize = size + alignmentBytes ; Mapping map = { nullptr , alignmentBytes , mapSize } ; c2_status_t err = mapInternal ( mapSize , mapOffset , alignmentBytes , prot , flags , & ( map . addr ) , addr ) ; if ( map . addr ) { std :: lock_guard < std :: mutex > guard ( mMutexMappings ) ; mMappings . push_back ( map ) ; } return err ; }
int main ( int argc , char * argv [ ] ) { QCoreApplication * a ; if ( isTUIMode ( argc , argv ) ) { Global :: isTUIMode = true ; a = new QCoreApplication ( argc , argv ) ; } #ifdef ENABLE_GUI else { ConsoleAppender * consoleAppender = new ConsoleAppender ; consoleAppender -> setFormat ( logFormat ) ; RollingFileAppender * rollingFileAppender = new RollingFileAppender ( "/tmp/.deepin-clone.log" ) ; rollingFileAppender -> setFormat ( logFormat ) ; rollingFileAppender -> setLogFilesLimit ( 5 ) ; rollingFileAppender -> setDatePattern ( RollingFileAppender :: DailyRollover ) ; logger -> registerAppender ( consoleAppender ) ; logger -> registerAppender ( rollingFileAppender ) ; if ( qEnvironmentVariableIsSet ( "PKEXEC_UID" ) ) { const quint32 pkexec_uid = qgetenv ( "PKEXEC_UID" ) . toUInt ( ) ; const QDir user_home ( getpwuid ( pkexec_uid ) -> pw_dir ) ; QFile pam_file ( user_home . absoluteFilePath ( ".pam_environment" ) ) ; if ( pam_file . open ( QIODevice :: ReadOnly ) ) { while ( ! pam_file . atEnd ( ) ) { const QByteArray & line = pam_file . readLine ( ) . simplified ( ) ; if ( line . startsWith ( "QT_SCALE_FACTOR" ) ) { const QByteArrayList & list = line . split ( '=' ) ; if ( list . count ( ) == 2 ) { qputenv ( "QT_SCALE_FACTOR" , list . last ( ) ) ; break ; } } } pam_file . close ( ) ; } } DApplication :: loadDXcbPlugin ( ) ; DApplication * app = new DApplication ( argc , argv ) ; app -> setAttribute ( Qt :: AA_UseHighDpiPixmaps ) ; if ( ! qApp -> setSingleInstance ( "_deepin_clone_" ) ) { qCritical ( ) < < "As well as the process is running" ; return - 1 ; } if ( ! app -> loadTranslator ( ) ) { dError ( "Load translator failed" ) ; } app -> setApplicationDisplayName ( QObject :: tr ( "Deepin Clone" ) ) ; app -> setApplicationDescription ( QObject :: tr ( "Deepin Clone is a backup and restore tool in deepin. " "It supports disk or partition clone, backup and restore, and other functions." ) ) ; app -> setApplicationAcknowledgementPage ( "https://www.deepin.org/acknowledgments/deepin-clone/" ) ; app -> setTheme ( "light" ) ; a = app ; } #endif a -> setApplicationName ( "deepin-clone" ) ; #ifdef ENABLE_GUI a -> setApplicationVersion ( DApplication :: buildVersion ( "1.0.0.1" ) ) ; #else a -> setApplicationVersion ( "1.0.0.1" ) ; #endif a -> setOrganizationName ( "deepin" ) ; CommandLineParser parser ; QFile arguments_file ( "/lib/live/mount/medium/.tmp/deepin-clone.arguments" ) ; QStringList arguments ; bool load_arg_from_file = arguments_file . exists ( ) && ! Global :: isTUIMode && ! a -> arguments ( ) . contains ( "--tui" ) ; if ( load_arg_from_file ) { arguments . append ( a -> arguments ( ) . first ( ) ) ; if ( ! arguments_file . open ( QIODevice :: ReadOnly ) ) { qCritical ( ) < < "Open \"/lib/live/mount/medium/.tmp/deepin-clone.arguments\" failed, error:" < < arguments_file . errorString ( ) ; } else { while ( ! arguments_file . atEnd ( ) ) { const QString & arg = QString :: fromUtf8 ( arguments_file . readLine ( ) . trimmed ( ) ) ; if ( ! arg . isEmpty ( ) ) arguments . append ( arg ) ; } arguments_file . close ( ) ; arguments_file . remove ( ) ; } qDebug ( ) < < arguments ; } else { arguments = a -> arguments ( ) ; } parser . process ( arguments ) ; ConsoleAppender * consoleAppender = new ConsoleAppender ; consoleAppender -> setFormat ( logFormat ) ; RollingFileAppender * rollingFileAppender = new RollingFileAppender ( parser . logFile ( ) ) ; rollingFileAppender -> setFormat ( logFormat ) ; rollingFileAppender -> setLogFilesLimit ( 5 ) ; rollingFileAppender -> setDatePattern ( RollingFileAppender :: DailyRollover ) ; logger -> registerCategoryAppender ( "deepin.ghost" , consoleAppender ) ; logger -> registerCategoryAppender ( "deepin.ghost" , rollingFileAppender ) ; parser . parse ( ) ; if ( load_arg_from_file ) { dCDebug ( "Load arguments from \"%s\"" , qPrintable ( arguments_file . fileName ( ) ) ) ; } dCInfo ( "Application command line: %s" , qPrintable ( arguments . join ( ' ' ) ) ) ; if ( Global :: debugLevel == 0 ) { QLoggingCategory :: setFilterRules ( "deepin.ghost.debug=false" ) ; } if ( Global :: isTUIMode ) { if ( ! parser . target ( ) . isEmpty ( ) ) { CloneJob * job = new CloneJob ; QObject :: connect ( job , & QThread :: finished , a , & QCoreApplication :: quit ) ; job -> start ( parser . source ( ) , parser . target ( ) ) ; } } #ifdef ENABLE_GUI else { if ( ! parser . isSetOverride ( ) ) Global :: isOverride = true ; if ( ! parser . isSetDebug ( ) ) Global :: debugLevel = 2 ; MainWindow * window = new MainWindow ; window -> setFixedSize ( 860 , 660 ) ; window -> setStyleSheet ( DThemeManager :: instance ( ) -> getQssForWidget ( "main" , window ) ) ; window -> setWindowIcon ( QIcon :: fromTheme ( "deepin-clone" ) ) ; window -> setWindowFlags ( Qt :: WindowCloseButtonHint | Qt :: WindowMinimizeButtonHint | Qt :: WindowSystemMenuHint ) ; window -> titlebar ( ) -> setIcon ( window -> windowIcon ( ) ) ; window -> titlebar ( ) -> setTitle ( QString ( ) ) ; #if DTK_VERSION > DTK_VERSION_CHECK(2, 0, 6, 0) window -> titlebar ( ) -> setBackgroundTransparent ( true ) ; #endif window -> show ( ) ; qApp -> setProductIcon ( window -> windowIcon ( ) ) ; if ( ! parser . source ( ) . isEmpty ( ) ) { window -> startWithFile ( parser . source ( ) , parser . target ( ) ) ; } QObject :: connect ( a , & QCoreApplication :: aboutToQuit , window , & MainWindow :: deleteLater ) ; QDesktopServices :: setUrlHandler ( "https" , window , "openUrl" ) ; } #endif int exitCode = Global :: isTUIMode ? a -> exec ( ) : qApp -> exec ( ) ; QString log_backup_file = parser . logBackupFile ( ) ; if ( log_backup_file . startsWith ( "serial://" ) ) { log_backup_file = Helper :: parseSerialUrl ( log_backup_file ) ; } if ( log_backup_file . isEmpty ( ) ) { return exitCode ; } if ( ! QFile :: copy ( parser . logFile ( ) , log_backup_file ) ) { dCWarning ( "failed to copy log file to \"%s\"" , qPrintable ( log_backup_file ) ) ; } return exitCode ; }
void ZydisFormatterBufferInitTokenized ( ZydisFormatterBuffer * buffer , ZydisFormatterToken * * first_token , void * user_buffer , ZyanUSize length ) { ZYAN_ASSERT ( buffer ) ; ZYAN_ASSERT ( first_token ) ; ZYAN_ASSERT ( user_buffer ) ; ZYAN_ASSERT ( length ) ; * first_token = user_buffer ; ( * first_token ) -> type = ZYDIS_TOKEN_INVALID ; ( * first_token ) -> next = 0 ; user_buffer = ( ZyanU8 * ) user_buffer + sizeof ( ZydisFormatterToken ) ; length -= sizeof ( ZydisFormatterToken ) ; buffer -> is_token_list = ZYAN_TRUE ; buffer -> capacity = length ; buffer -> string . flags = ZYAN_STRING_HAS_FIXED_CAPACITY ; buffer -> string . vector . allocator = ZYAN_NULL ; buffer -> string . vector . element_size = sizeof ( char ) ; buffer -> string . vector . size = 1 ; buffer -> string . vector . capacity = length ; buffer -> string . vector . data = user_buffer ; * ( char * ) user_buffer = '\0' ; }
MaybeHandle < JSObject > CreateReadOnlyArray ( Isolate * isolate , std :: vector < std :: string > elements ) { Factory * factory = isolate -> factory ( ) ; if ( elements . size ( ) >= kMaxUInt32 ) { THROW_NEW_ERROR ( isolate , NewRangeError ( MessageTemplate :: kInvalidArrayLength ) , JSObject ) ; } PropertyAttributes attr = static_cast < PropertyAttributes > ( READ_ONLY | DONT_DELETE ) ; Handle < JSArray > subset = factory -> NewJSArray ( 0 ) ; uint32_t length = static_cast < uint32_t > ( elements . size ( ) ) ; for ( uint32_t i = 0 ; i < length ; i ++ ) { const std :: string & part = elements [ i ] ; Handle < String > value = factory -> NewStringFromUtf8 ( CStrVector ( part . c_str ( ) ) ) . ToHandleChecked ( ) ; JSObject :: AddDataElement ( subset , i , value , attr ) ; } PropertyDescriptor desc ; desc . set_writable ( false ) ; desc . set_configurable ( false ) ; JSArray :: ArraySetLength ( isolate , subset , & desc , kThrowOnError ) . ToChecked ( ) ; return subset ; }
IGNITION_HANDLER ( Ldar , InterpreterAssembler ) { Node * value = LoadRegisterAtOperandIndex ( 0 ) ; SetAccumulator ( value ) ; Dispatch ( ) ; }
int equalizer_set_parameter ( effect_context_t * context , effect_param_t * p , uint32_t size __unused ) { equalizer_context_t * eq_ctxt = ( equalizer_context_t * ) context ; int voffset = ( ( p -> psize - 1 ) / sizeof ( int32_t ) + 1 ) * sizeof ( int32_t ) ; void * value = p -> data + voffset ; int32_t * param_tmp = ( int32_t * ) p -> data ; int32_t param = * param_tmp ++ ; int32_t preset ; int32_t band ; int32_t level ; int i ; ALOGV ( "%s" , __func__ ) ; p -> status = 0 ; switch ( param ) { case EQ_PARAM_CUR_PRESET : ALOGV ( "EQ_PARAM_CUR_PRESET" ) ; preset = ( int32_t ) ( * ( uint16_t * ) value ) ; if ( ( preset >= equalizer_get_num_presets ( eq_ctxt ) ) || ( preset < 0 ) ) { p -> status = - EINVAL ; break ; } equalizer_set_preset ( eq_ctxt , preset ) ; break ; case EQ_PARAM_BAND_LEVEL : ALOGV ( "EQ_PARAM_BAND_LEVEL" ) ; band = * param_tmp ; level = ( int32_t ) ( * ( int16_t * ) value ) ; if ( band < 0 || band >= NUM_EQ_BANDS ) { p -> status = - EINVAL ; if ( band < 0 ) { android_errorWriteLog ( 0x534e4554 , "32585400" ) ; ALOGW ( "\tERROR EQ_PARAM_BAND_LEVEL band %d" , band ) ; } break ; } equalizer_set_band_level ( eq_ctxt , band , level ) ; break ; case EQ_PARAM_PROPERTIES : { ALOGV ( "EQ_PARAM_PROPERTIES" ) ; int16_t * prop = ( int16_t * ) value ; if ( ( int ) prop [ 0 ] >= equalizer_get_num_presets ( eq_ctxt ) ) { p -> status = - EINVAL ; break ; } if ( prop [ 0 ] >= 0 ) { equalizer_set_preset ( eq_ctxt , ( int ) prop [ 0 ] ) ; } else { if ( ( int ) prop [ 1 ] != NUM_EQ_BANDS ) { p -> status = - EINVAL ; break ; } for ( i = 0 ; i < NUM_EQ_BANDS ; i ++ ) { equalizer_set_band_level ( eq_ctxt , i , ( int ) prop [ 2 + i ] ) ; } } } break ; default : p -> status = - EINVAL ; break ; } return 0 ; }
void * SoftMP3 :: memsetSafe ( OMX_BUFFERHEADERTYPE * outHeader , int c , size_t len ) { if ( len > outHeader -> nAllocLen ) { ALOGE ( "memset buffer too small: got %lu, expected %zu" , ( unsigned long ) outHeader -> nAllocLen , len ) ; android_errorWriteLog ( 0x534e4554 , "29422022" ) ; notify ( OMX_EventError , OMX_ErrorUndefined , OUTPUT_BUFFER_TOO_SMALL , NULL ) ; mSignalledError = true ; return NULL ; } return memset ( outHeader -> pBuffer , c , len ) ; }
void WasmCode :: Print ( const char * name ) const { StdoutStream os ; os < < "--- WebAssembly code ---\n" ; Disassemble ( name , os ) ; os < < "--- End code ---\n" ; }
void btrfs_trans_release_chunk_metadata ( struct btrfs_trans_handle * trans ) { struct btrfs_fs_info * fs_info = trans -> fs_info ; struct btrfs_transaction * cur_trans = trans -> transaction ; if ( ! trans -> chunk_bytes_reserved ) return ; WARN_ON_ONCE ( ! list_empty ( & trans -> new_bgs ) ) ; btrfs_block_rsv_release ( fs_info , & fs_info -> chunk_block_rsv , trans -> chunk_bytes_reserved , NULL ) ; atomic64_sub ( trans -> chunk_bytes_reserved , & cur_trans -> chunk_bytes_reserved ) ; cond_wake_up ( & cur_trans -> chunk_reserve_wait ) ; trans -> chunk_bytes_reserved = 0 ; }
void bta_dm_remove_device ( const RawAddress & bd_addr ) { bool is_bd_addr_connected = BTM_IsAclConnectionUp ( bd_addr , BT_TRANSPORT_LE ) || BTM_IsAclConnectionUp ( bd_addr , BT_TRANSPORT_BR_EDR ) ; tBT_TRANSPORT other_transport = BT_TRANSPORT_AUTO ; if ( is_bd_addr_connected ) { APPL_TRACE_DEBUG ( "%s: ACL Up count: %d" , __func__ , bta_dm_cb . device_list . count ) ; for ( int i = 0 ; i < bta_dm_cb . device_list . count ; i ++ ) { auto & peer_device = bta_dm_cb . device_list . peer_device [ i ] ; if ( peer_device . peer_bdaddr == bd_addr ) { peer_device . conn_state = BTA_DM_UNPAIRING ; GATT_CancelConnect ( 0 , bd_addr , false ) ; btm_remove_acl ( bd_addr , peer_device . transport ) ; APPL_TRACE_DEBUG ( "%s: transport: %d" , __func__ , peer_device . transport ) ; if ( peer_device . transport == BT_TRANSPORT_LE ) other_transport = BT_TRANSPORT_BR_EDR ; else other_transport = BT_TRANSPORT_LE ; break ; } } } RawAddress other_address = bd_addr ; RawAddress other_address2 = bd_addr ; bool other_address_connected = ( other_transport ) ? BTM_ReadConnectedTransportAddress ( & other_address , other_transport ) : ( BTM_ReadConnectedTransportAddress ( & other_address , BT_TRANSPORT_BR_EDR ) || BTM_ReadConnectedTransportAddress ( & other_address2 , BT_TRANSPORT_LE ) ) ; if ( other_address == bd_addr ) other_address = other_address2 ; if ( other_address_connected ) { for ( int i = 0 ; i < bta_dm_cb . device_list . count ; i ++ ) { auto & peer_device = bta_dm_cb . device_list . peer_device [ i ] ; if ( peer_device . peer_bdaddr == other_address && peer_device . transport == other_transport ) { peer_device . conn_state = BTA_DM_UNPAIRING ; GATT_CancelConnect ( 0 , bd_addr , false ) ; btm_remove_acl ( other_address , peer_device . transport ) ; break ; } } } if ( ! is_bd_addr_connected ) { bta_dm_process_remove_device ( bd_addr ) ; } if ( ! other_address_connected && ! other_address . IsEmpty ( ) ) { bta_dm_process_remove_device ( other_address ) ; } auto paired_devices = btif_config_get_paired_devices ( ) ; if ( paired_devices . empty ( ) ) { LOG_INFO ( "Last paired device removed, resetting IRK" ) ; btm_ble_reset_id ( ) ; } }
static void jas_stream_initbuf ( jas_stream_t * stream , int bufmode , char * buf , int bufsize ) { assert ( ! stream -> bufbase_ ) ; if ( bufmode != JAS_STREAM_UNBUF ) { if ( ! buf ) { if ( ( stream -> bufbase_ = jas_malloc ( JAS_STREAM_BUFSIZE + JAS_STREAM_MAXPUTBACK ) ) ) { stream -> bufmode_ |= JAS_STREAM_FREEBUF ; stream -> bufsize_ = JAS_STREAM_BUFSIZE ; } else { stream -> bufbase_ = stream -> tinybuf_ ; stream -> bufsize_ = 1 ; } } else { assert ( bufsize > JAS_STREAM_MAXPUTBACK ) ; stream -> bufbase_ = JAS_CAST ( uchar * , buf ) ; stream -> bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK ; } } else { assert ( ! buf ) ; stream -> bufbase_ = stream -> tinybuf_ ; stream -> bufsize_ = 1 ; } stream -> bufstart_ = & stream -> bufbase_ [ JAS_STREAM_MAXPUTBACK ] ; stream -> ptr_ = stream -> bufstart_ ; stream -> cnt_ = 0 ; stream -> bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK ; }
int RegExpMacroAssemblerS390 :: CheckStackGuardState ( Address * return_address , Code * re_code , Address re_frame ) { return NativeRegExpMacroAssembler :: CheckStackGuardState ( frame_entry < Isolate * > ( re_frame , kIsolate ) , frame_entry < intptr_t > ( re_frame , kStartIndex ) , frame_entry < intptr_t > ( re_frame , kDirectCall ) == 1 , return_address , re_code , frame_entry_address < String * > ( re_frame , kInputString ) , frame_entry_address < const byte * > ( re_frame , kInputStart ) , frame_entry_address < const byte * > ( re_frame , kInputEnd ) ) ; }
mrb_io_initialize_copy ( mrb_state * mrb , mrb_value copy ) { mrb_value orig ; mrb_value buf ; struct mrb_io * fptr_copy ; struct mrb_io * fptr_orig ; mrb_bool failed = TRUE ; mrb_get_args ( mrb , "o" , & orig ) ; fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; if ( fptr_copy != NULL ) { fptr_finalize ( mrb , fptr_copy , FALSE ) ; mrb_free ( mrb , fptr_copy ) ; } fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; fptr_orig = io_get_open_fptr ( mrb , orig ) ; DATA_TYPE ( copy ) = & mrb_io_type ; DATA_PTR ( copy ) = fptr_copy ; buf = mrb_iv_get ( mrb , orig , mrb_intern_cstr ( mrb , "@buf" ) ) ; mrb_iv_set ( mrb , copy , mrb_intern_cstr ( mrb , "@buf" ) , buf ) ; fptr_copy -> fd = mrb_dup ( mrb , fptr_orig -> fd , & failed ) ; if ( failed ) { mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd ) ; if ( fptr_orig -> fd2 != - 1 ) { fptr_copy -> fd2 = mrb_dup ( mrb , fptr_orig -> fd2 , & failed ) ; if ( failed ) { close ( fptr_copy -> fd ) ; mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd2 ) ; } fptr_copy -> pid = fptr_orig -> pid ; fptr_copy -> readable = fptr_orig -> readable ; fptr_copy -> writable = fptr_orig -> writable ; fptr_copy -> sync = fptr_orig -> sync ; fptr_copy -> is_socket = fptr_orig -> is_socket ; return copy ; }
IonBuilder :: inlineCalls ( CallInfo & callInfo , AutoObjectVector & targets , AutoObjectVector & originals , Vector < bool > & choiceSet , MGetPropertyCache * maybeCache ) { JS_ASSERT ( types :: IsInlinableCall ( pc ) ) ; JS_ASSERT ( choiceSet . length ( ) == targets . length ( ) ) ; JS_ASSERT_IF ( ! maybeCache , targets . length ( ) >= 2 ) ; JS_ASSERT_IF ( maybeCache , targets . length ( ) >= 1 ) ; MBasicBlock * dispatchBlock = current ; JS_ASSERT ( callInfo . isWrapped ( ) ) ; callInfo . unwrapArgs ( ) ; callInfo . pushFormals ( dispatchBlock ) ; if ( maybeCache ) { InlinePropertyTable * propTable = maybeCache -> propTable ( ) ; propTable -> trimToAndMaybePatchTargets ( targets , originals ) ; if ( propTable -> numEntries ( ) == 0 ) maybeCache = NULL ; } MDispatchInstruction * dispatch ; if ( maybeCache ) { dispatch = MTypeObjectDispatch :: New ( maybeCache -> object ( ) , maybeCache -> propTable ( ) ) ; callInfo . fun ( ) -> setFoldedUnchecked ( ) ; } else { dispatch = MFunctionDispatch :: New ( callInfo . fun ( ) ) ; } jsbytecode * postCall = GetNextPc ( pc ) ; MBasicBlock * returnBlock = newBlock ( NULL , postCall ) ; if ( ! returnBlock ) return false ; returnBlock -> setCallerResumePoint ( callerResumePoint_ ) ; returnBlock -> inheritSlots ( dispatchBlock ) ; callInfo . popFormals ( returnBlock ) ; MPhi * retPhi = MPhi :: New ( returnBlock -> stackDepth ( ) ) ; returnBlock -> addPhi ( retPhi ) ; returnBlock -> push ( retPhi ) ; returnBlock -> initEntrySlots ( ) ; uint32_t count = 1 ; for ( uint32_t i = 0 ; i < targets . length ( ) ; i ++ ) { if ( choiceSet [ i ] ) count ++ ; } retPhi -> reserveLength ( count ) ; types :: StackTypeSet * cacheObjectTypeSet = maybeCache ? maybeCache -> object ( ) -> resultTypeSet ( ) : NULL ; JS_ASSERT ( targets . length ( ) == originals . length ( ) ) ; for ( uint32_t i = 0 ; i < targets . length ( ) ; i ++ ) { JSFunction * target = targets [ i ] -> toFunction ( ) ; if ( ! choiceSet [ i ] ) continue ; if ( maybeCache && ! maybeCache -> propTable ( ) -> hasFunction ( target ) ) { choiceSet [ i ] = false ; continue ; } MBasicBlock * inlineBlock = newBlock ( dispatchBlock , pc ) ; if ( ! inlineBlock ) return false ; JSFunction * original = originals [ i ] -> toFunction ( ) ; MConstant * funcDef = MConstant :: New ( ObjectValue ( * original ) ) ; funcDef -> setFoldedUnchecked ( ) ; dispatchBlock -> add ( funcDef ) ; int funIndex = inlineBlock -> entryResumePoint ( ) -> numOperands ( ) - callInfo . numFormals ( ) ; inlineBlock -> entryResumePoint ( ) -> replaceOperand ( funIndex , funcDef ) ; inlineBlock -> rewriteSlot ( funIndex , funcDef ) ; CallInfo inlineInfo ( cx , callInfo . constructing ( ) ) ; if ( ! inlineInfo . init ( callInfo ) ) return false ; inlineInfo . popFormals ( inlineBlock ) ; inlineInfo . setFun ( funcDef ) ; inlineInfo . wrapArgs ( inlineBlock ) ; if ( maybeCache ) { JS_ASSERT ( callInfo . thisArg ( ) == maybeCache -> object ( ) ) ; types :: StackTypeSet * targetThisTypes = maybeCache -> propTable ( ) -> buildTypeSetForFunction ( target ) ; if ( ! targetThisTypes ) return false ; maybeCache -> object ( ) -> setResultTypeSet ( targetThisTypes ) ; } setCurrentAndSpecializePhis ( inlineBlock ) ; InliningStatus status = inlineSingleCall ( inlineInfo , target ) ; if ( status == InliningStatus_Error ) return false ; if ( status == InliningStatus_NotInlined ) { JS_ASSERT ( target -> isNative ( ) ) ; JS_ASSERT ( current == inlineBlock ) ; inlineInfo . unwrapArgs ( ) ; inlineBlock -> entryResumePoint ( ) -> discardOperand ( funIndex ) ; inlineBlock -> rewriteSlot ( funIndex , callInfo . fun ( ) ) ; inlineBlock -> discard ( funcDef ) ; graph ( ) . removeBlock ( inlineBlock ) ; choiceSet [ i ] = false ; continue ; } MBasicBlock * inlineReturnBlock = current ; setCurrent ( dispatchBlock ) ; dispatch -> addCase ( original , inlineBlock ) ; MDefinition * retVal = inlineReturnBlock -> peek ( - 1 ) ; retPhi -> addInput ( retVal ) ; inlineReturnBlock -> end ( MGoto :: New ( returnBlock ) ) ; if ( ! returnBlock -> addPredecessorWithoutPhis ( inlineReturnBlock ) ) return false ; } if ( maybeCache ) { maybeCache -> object ( ) -> setResultTypeSet ( cacheObjectTypeSet ) ; InlinePropertyTable * propTable = maybeCache -> propTable ( ) ; propTable -> trimTo ( targets , choiceSet ) ; if ( propTable -> numEntries ( ) == 0 ) { JS_ASSERT ( dispatch -> numCases ( ) == 0 ) ; maybeCache = NULL ; } } if ( maybeCache || dispatch -> numCases ( ) < targets . length ( ) ) { if ( maybeCache ) { MBasicBlock * fallbackTarget ; if ( ! inlineTypeObjectFallback ( callInfo , dispatchBlock , ( MTypeObjectDispatch * ) dispatch , maybeCache , & fallbackTarget ) ) { return false ; } dispatch -> addFallback ( fallbackTarget ) ; } else { JSFunction * remaining = NULL ; bool clonedAtCallsite = false ; if ( dispatch -> numCases ( ) + 1 == originals . length ( ) ) { for ( uint32_t i = 0 ; i < originals . length ( ) ; i ++ ) { if ( choiceSet [ i ] ) continue ; remaining = targets [ i ] -> toFunction ( ) ; clonedAtCallsite = targets [ i ] != originals [ i ] ; break ; } } if ( ! inlineGenericFallback ( remaining , callInfo , dispatchBlock , clonedAtCallsite ) ) return false ; dispatch -> addFallback ( current ) ; } MBasicBlock * fallbackReturnBlock = current ; MDefinition * retVal = fallbackReturnBlock -> peek ( - 1 ) ; retPhi -> addInput ( retVal ) ; fallbackReturnBlock -> end ( MGoto :: New ( returnBlock ) ) ; if ( ! returnBlock -> addPredecessorWithoutPhis ( fallbackReturnBlock ) ) return false ; } dispatchBlock -> end ( dispatch ) ; JS_ASSERT ( returnBlock -> stackDepth ( ) == dispatchBlock -> stackDepth ( ) - callInfo . numFormals ( ) + 1 ) ; graph ( ) . moveBlockToEnd ( returnBlock ) ; setCurrentAndSpecializePhis ( returnBlock ) ; return true ; }
RemoveFile :: Execute ( ) { if ( mSkip ) return OK ; LOG ( ( "EXECUTE REMOVEFILE " LOG_S , mFile ) ) ; int rv = NS_taccess ( mFile , F_OK ) ; if ( rv ) { LOG ( ( "file cannot be removed because it does not exist; skipping" ) ) ; mSkip = 1 ; return OK ; } rv = backup_create ( mFile ) ; if ( rv ) { LOG ( ( "backup_create failed: %d" , rv ) ) ; return rv ; } return OK ; }
TF_BUILTIN ( MapPrototypeKeys , CollectionsBuiltinsAssembler ) { Node * const receiver = Parameter ( Descriptor :: kReceiver ) ; Node * const context = Parameter ( Descriptor :: kContext ) ; ThrowIfNotInstanceType ( context , receiver , JS_MAP_TYPE , "Map.prototype.keys" ) ; Return ( AllocateJSCollectionIterator < JSMapIterator > ( context , Context :: MAP_KEY_ITERATOR_MAP_INDEX , receiver ) ) ; }
static RList * symbols ( RBinFile * bf ) { RList * res = r_list_newf ( ( RListFree ) r_bin_symbol_free ) ; r_return_val_if_fail ( res && bf -> o && bf -> o -> bin_obj , res ) ; RCoreSymCacheElement * element = bf -> o -> bin_obj ; size_t i ; HtUU * hash = ht_uu_new0 ( ) ; if ( ! hash ) { return res ; } bool found = false ; for ( i = 0 ; i < element -> hdr -> n_lined_symbols ; i ++ ) { RCoreSymCacheElementSymbol * sym = ( RCoreSymCacheElementSymbol * ) & element -> lined_symbols [ i ] ; ht_uu_find ( hash , sym -> paddr , & found ) ; if ( found ) { continue ; } RBinSymbol * s = bin_symbol_from_symbol ( element , sym ) ; if ( s ) { r_list_append ( res , s ) ; ht_uu_insert ( hash , sym -> paddr , 1 ) ; } } if ( element -> symbols ) { for ( i = 0 ; i < element -> hdr -> n_symbols ; i ++ ) { RCoreSymCacheElementSymbol * sym = & element -> symbols [ i ] ; ht_uu_find ( hash , sym -> paddr , & found ) ; if ( found ) { continue ; } RBinSymbol * s = bin_symbol_from_symbol ( element , sym ) ; if ( s ) { r_list_append ( res , s ) ; } } } ht_uu_free ( hash ) ; return res ; }
static int cbor2json ( OSCTXT * pCborCtxt , OSCTXT * pJsonCtxt ) { int ret = 0 ; OSOCTET tag , ub ; ret = rtxReadBytes ( pCborCtxt , & ub , 1 ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; tag = ub > > 5 ; switch ( tag ) { case OSRTCBOR_UINT : { OSUINTTYPE value ; ret = rtCborDecUInt ( pCborCtxt , ub , & value ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; #ifndef _NO_INT64_SUPPORT ret = rtJsonEncUInt64Value ( pJsonCtxt , value ) ; #else ret = rtJsonEncUIntValue ( pJsonCtxt , value ) ; #endif if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_NEGINT : { OSINTTYPE value ; ret = rtCborDecInt ( pCborCtxt , ub , & value ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; #ifndef _NO_INT64_SUPPORT ret = rtJsonEncInt64Value ( pJsonCtxt , value ) ; #else ret = rtJsonEncIntValue ( pJsonCtxt , value ) ; #endif if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_BYTESTR : { OSDynOctStr64 byteStr ; ret = rtCborDecDynByteStr ( pCborCtxt , ub , & byteStr ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; ret = rtJsonEncHexStr ( pJsonCtxt , byteStr . numocts , byteStr . data ) ; rtxMemFreePtr ( pCborCtxt , byteStr . data ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_UTF8STR : { OSUTF8CHAR * utf8str ; ret = rtCborDecDynUTF8Str ( pCborCtxt , ub , ( char * * ) & utf8str ) ; ret = rtJsonEncStringValue ( pJsonCtxt , utf8str ) ; rtxMemFreePtr ( pCborCtxt , utf8str ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_ARRAY : case OSRTCBOR_MAP : { OSOCTET len = ub & 0x1F ; char startChar = ( tag == OSRTCBOR_ARRAY ) ? '[' : '{' ; char endChar = ( tag == OSRTCBOR_ARRAY ) ? ']' : '}' ; OSRTSAFEPUTCHAR ( pJsonCtxt , startChar ) ; if ( len == OSRTCBOR_INDEF ) { OSBOOL first = TRUE ; for ( ; ; ) { if ( OSRTCBOR_MATCHEOC ( pCborCtxt ) ) { pCborCtxt -> buffer . byteIndex ++ ; break ; } if ( ! first ) OSRTSAFEPUTCHAR ( pJsonCtxt , ',' ) ; else first = FALSE ; if ( tag == OSRTCBOR_MAP ) { ret = cborElemNameToJson ( pCborCtxt , pJsonCtxt ) ; } if ( 0 == ret ) ret = cbor2json ( pCborCtxt , pJsonCtxt ) ; if ( 0 != ret ) { OSCTXT * pctxt = ( rtxErrGetErrorCnt ( pJsonCtxt ) > 0 ) ? pJsonCtxt : pCborCtxt ; return LOG_RTERR ( pctxt , ret ) ; } } } else { OSSIZE nitems ; ret = rtCborDecSize ( pCborCtxt , len , & nitems ) ; if ( 0 == ret ) { OSSIZE i ; for ( i = 0 ; i < nitems ; i ++ ) { if ( 0 != i ) OSRTSAFEPUTCHAR ( pJsonCtxt , ',' ) ; if ( tag == OSRTCBOR_MAP ) { ret = cborElemNameToJson ( pCborCtxt , pJsonCtxt ) ; } if ( 0 == ret ) ret = cbor2json ( pCborCtxt , pJsonCtxt ) ; if ( 0 != ret ) { OSCTXT * pctxt = ( rtxErrGetErrorCnt ( pJsonCtxt ) > 0 ) ? pJsonCtxt : pCborCtxt ; return LOG_RTERR ( pctxt , ret ) ; } } } } OSRTSAFEPUTCHAR ( pJsonCtxt , endChar ) ; break ; } case OSRTCBOR_FLOAT : if ( tag == OSRTCBOR_FALSEENC || tag == OSRTCBOR_TRUEENC ) { OSBOOL boolval = ( ub == OSRTCBOR_TRUEENC ) ? TRUE : FALSE ; ret = rtJsonEncBoolValue ( pJsonCtxt , boolval ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; } else if ( tag == OSRTCBOR_FLT16ENC || tag == OSRTCBOR_FLT32ENC || tag == OSRTCBOR_FLT64ENC ) { OSDOUBLE fltval ; ret = rtCborDecFloat ( pCborCtxt , ub , & fltval ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; ret = rtJsonEncDoubleValue ( pJsonCtxt , fltval , 0 ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; } else { ret = cborTagNotSupp ( pCborCtxt , tag ) ; } break ; default : ret = cborTagNotSupp ( pCborCtxt , tag ) ; } return ret ; }
lex ( struct scanner * s , union lvalue * val ) { skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) ) ) if ( next ( s ) == '\n' ) return TOK_END_OF_LINE ; if ( chr ( s , '#' ) ) { skip_to_eol ( s ) ; goto skip_more_whitespace_and_comments ; } if ( eof ( s ) ) return TOK_END_OF_FILE ; s -> token_line = s -> line ; s -> token_column = s -> column ; s -> buf_pos = 0 ; if ( chr ( s , '<' ) ) { while ( peek ( s ) != '>' && ! eol ( s ) ) buf_append ( s , next ( s ) ) ; if ( ! chr ( s , '>' ) ) { scanner_err ( s , "unterminated keysym literal" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\0' ) ) { scanner_err ( s , "keysym literal is too long" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_LHS_KEYSYM ; } if ( chr ( s , ':' ) ) return TOK_COLON ; if ( chr ( s , '!' ) ) return TOK_BANG ; if ( chr ( s , '~' ) ) return TOK_TILDE ; if ( chr ( s , '\"' ) ) { while ( ! eof ( s ) && ! eol ( s ) && peek ( s ) != '\"' ) { if ( chr ( s , '\\' ) ) { uint8_t o ; if ( chr ( s , '\\' ) ) { buf_append ( s , '\\' ) ; } else if ( chr ( s , '"' ) ) { buf_append ( s , '"' ) ; } else if ( chr ( s , 'x' ) || chr ( s , 'X' ) ) { if ( hex ( s , & o ) ) buf_append ( s , ( char ) o ) ; else scanner_warn ( s , "illegal hexadecimal escape sequence in string literal" ) ; } else if ( oct ( s , & o ) ) { buf_append ( s , ( char ) o ) ; } else { scanner_warn ( s , "unknown escape sequence (%c) in string literal" , peek ( s ) ) ; } } else { buf_append ( s , next ( s ) ) ; } } if ( ! chr ( s , '\"' ) ) { scanner_err ( s , "unterminated string literal" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\0' ) ) { scanner_err ( s , "string literal is too long" ) ; return TOK_ERROR ; } if ( ! is_valid_utf8 ( s -> buf , s -> buf_pos - 1 ) ) { scanner_err ( s , "string literal is not a valid UTF-8 string" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_STRING ; } if ( is_alpha ( peek ( s ) ) || peek ( s ) == '_' ) { s -> buf_pos = 0 ; while ( is_alnum ( peek ( s ) ) || peek ( s ) == '_' ) buf_append ( s , next ( s ) ) ; if ( ! buf_append ( s , '\0' ) ) { scanner_err ( s , "identifier is too long" ) ; return TOK_ERROR ; } if ( streq ( s -> buf , "include" ) ) return TOK_INCLUDE ; val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_IDENT ; } skip_to_eol ( s ) ; scanner_err ( s , "unrecognized token" ) ; return TOK_ERROR ; }
void RegExpMacroAssemblerS390 :: CheckPreemption ( ) { ExternalReference stack_limit = ExternalReference :: address_of_stack_limit ( isolate ( ) ) ; __ mov ( r2 , Operand ( stack_limit ) ) ; __ CmpLogicalP ( sp , MemOperand ( r2 ) ) ; SafeCall ( & check_preempt_label_ , le ) ; }
BEGIN_TEST ( testTrap_gc ) { static const char source [ ] = "var i = 0;\n" "var sum = 0;\n" "while (i < 10) {\n" "    sum += i;\n" "    ++i;\n" "}\n" "({ result: sum });\n" ; JS :: CompileOptions options ( cx ) ; options . setFileAndLine ( __FILE__ , 1 ) ; JS :: RootedScript script ( cx , JS_CompileScript ( cx , global , source , strlen ( source ) , options ) ) ; CHECK ( script ) ; JS :: RootedValue v2 ( cx ) ; CHECK ( JS_ExecuteScript ( cx , global , script , & v2 ) ) ; CHECK ( v2 . isObject ( ) ) ; CHECK_EQUAL ( emptyTrapCallCount , 0 ) ; CHECK ( JS_SetDebugMode ( cx , true ) ) ; static const char trapClosureText [ ] = "some trap closure" ; JS :: RootedString trapClosure ( cx ) ; { jsbytecode * line2 = JS_LineNumberToPC ( cx , script , 1 ) ; CHECK ( line2 ) ; jsbytecode * line6 = JS_LineNumberToPC ( cx , script , 5 ) ; CHECK ( line2 ) ; trapClosure = JS_NewStringCopyZ ( cx , trapClosureText ) ; CHECK ( trapClosure ) ; JS :: RootedValue closureValue ( cx , JS :: StringValue ( trapClosure ) ) ; JS_SetTrap ( cx , script , line2 , EmptyTrapHandler , closureValue ) ; JS_SetTrap ( cx , script , line6 , EmptyTrapHandler , closureValue ) ; JS_GC ( rt ) ; CHECK ( JS_FlatStringEqualsAscii ( JS_ASSERT_STRING_IS_FLAT ( trapClosure ) , trapClosureText ) ) ; } CHECK ( JS_ExecuteScript ( cx , global , script , & v2 ) ) ; CHECK_EQUAL ( emptyTrapCallCount , 11 ) ; JS_GC ( rt ) ; CHECK ( JS_FlatStringEqualsAscii ( JS_ASSERT_STRING_IS_FLAT ( trapClosure ) , trapClosureText ) ) ; return true ; }
CookieServiceParent :: AddCookie ( nsICookie * aCookie ) { auto cookie = static_cast < nsCookie * > ( aCookie ) ; OriginAttributes attrs = cookie -> OriginAttributesRef ( ) ; CookieStruct cookieStruct ; GetInfoFromCookie ( cookie , cookieStruct ) ; if ( ! cookie -> IsHttpOnly ( ) ) { Unused < < SendAddCookie ( cookieStruct , attrs ) ; } }
SerializedCodeData SerializedCodeData :: FromCachedData ( Isolate * isolate , ScriptData * cached_data , uint32_t expected_source_hash , SanityCheckResult * rejection_result ) { DisallowHeapAllocation no_gc ; SerializedCodeData scd ( cached_data ) ; * rejection_result = scd . SanityCheck ( isolate , expected_source_hash ) ; if ( * rejection_result != CHECK_SUCCESS ) { cached_data -> Reject ( ) ; return SerializedCodeData ( nullptr , 0 ) ; } return scd ; }
LoadInfo :: LoadInfo ( nsIPrincipal * aLoadingPrincipal , nsIPrincipal * aTriggeringPrincipal , nsIPrincipal * aPrincipalToInherit , nsIPrincipal * aSandboxedLoadingPrincipal , nsIURI * aResultPrincipalURI , const Maybe < ClientInfo > & aClientInfo , const Maybe < ClientInfo > & aReservedClientInfo , const Maybe < ClientInfo > & aInitialClientInfo , const Maybe < ServiceWorkerDescriptor > & aController , nsSecurityFlags aSecurityFlags , nsContentPolicyType aContentPolicyType , LoadTainting aTainting , bool aUpgradeInsecureRequests , bool aVerifySignedContent , bool aEnforceSRI , bool aForceAllowDataURI , bool aForceInheritPrincipalDropped , uint64_t aInnerWindowID , uint64_t aOuterWindowID , uint64_t aParentOuterWindowID , uint64_t aTopOuterWindowID , uint64_t aFrameOuterWindowID , bool aEnforceSecurity , bool aInitialSecurityCheckDone , bool aIsThirdPartyContext , bool aIsDocshellReload , const OriginAttributes & aOriginAttributes , RedirectHistoryArray & aRedirectChainIncludingInternalRedirects , RedirectHistoryArray & aRedirectChain , nsTArray < nsCOMPtr < nsIPrincipal > > && aAncestorPrincipals , const nsTArray < uint64_t > & aAncestorOuterWindowIDs , const nsTArray < nsCString > & aCorsUnsafeHeaders , bool aForcePreflight , bool aIsPreflight , bool aLoadTriggeredFromExternal , bool aServiceWorkerTaintingSynthesized ) : mLoadingPrincipal ( aLoadingPrincipal ) , mTriggeringPrincipal ( aTriggeringPrincipal ) , mPrincipalToInherit ( aPrincipalToInherit ) , mResultPrincipalURI ( aResultPrincipalURI ) , mClientInfo ( aClientInfo ) , mReservedClientInfo ( aReservedClientInfo ) , mInitialClientInfo ( aInitialClientInfo ) , mController ( aController ) , mSecurityFlags ( aSecurityFlags ) , mInternalContentPolicyType ( aContentPolicyType ) , mTainting ( aTainting ) , mUpgradeInsecureRequests ( aUpgradeInsecureRequests ) , mVerifySignedContent ( aVerifySignedContent ) , mEnforceSRI ( aEnforceSRI ) , mForceAllowDataURI ( aForceAllowDataURI ) , mOriginalFrameSrcLoad ( false ) , mForceInheritPrincipalDropped ( aForceInheritPrincipalDropped ) , mInnerWindowID ( aInnerWindowID ) , mOuterWindowID ( aOuterWindowID ) , mParentOuterWindowID ( aParentOuterWindowID ) , mTopOuterWindowID ( aTopOuterWindowID ) , mFrameOuterWindowID ( aFrameOuterWindowID ) , mEnforceSecurity ( aEnforceSecurity ) , mInitialSecurityCheckDone ( aInitialSecurityCheckDone ) , mIsThirdPartyContext ( aIsThirdPartyContext ) , mIsDocshellReload ( aIsDocshellReload ) , mOriginAttributes ( aOriginAttributes ) , mAncestorPrincipals ( Move ( aAncestorPrincipals ) ) , mAncestorOuterWindowIDs ( aAncestorOuterWindowIDs ) , mCorsUnsafeHeaders ( aCorsUnsafeHeaders ) , mForcePreflight ( aForcePreflight ) , mIsPreflight ( aIsPreflight ) , mLoadTriggeredFromExternal ( aLoadTriggeredFromExternal ) , mServiceWorkerTaintingSynthesized ( aServiceWorkerTaintingSynthesized ) { MOZ_ASSERT ( mLoadingPrincipal || aContentPolicyType == nsIContentPolicy :: TYPE_DOCUMENT ) ; MOZ_ASSERT ( mTriggeringPrincipal ) ; mRedirectChainIncludingInternalRedirects . SwapElements ( aRedirectChainIncludingInternalRedirects ) ; mRedirectChain . SwapElements ( aRedirectChain ) ; }
void CIRCNetwork :: SetEncoding ( const CString & s ) { m_sEncoding = s ; if ( GetIRCSock ( ) ) { GetIRCSock ( ) -> SetEncoding ( s ) ; } }
nsContainerFrame :: DrainSelfOverflowList ( ) { AutoFrameListPtr overflowFrames ( PresContext ( ) , StealOverflowFrames ( ) ) ; if ( overflowFrames ) { NS_ASSERTION ( mFrames . NotEmpty ( ) , "overflow list w/o frames" ) ; mFrames . AppendFrames ( nullptr , * overflowFrames ) ; return true ; } return false ; }
PeerConnectionImpl :: EnsureDataConnection ( uint16_t aNumstreams ) { PC_AUTO_ENTER_API_CALL_NO_CHECK ( ) ; #if !defined(MOZILLA_EXTERNAL_LINKAGE) if ( mDataConnection ) { CSFLogDebug ( logTag , "%s DataConnection already connected" , __FUNCTION__ ) ; return NS_OK ; } mDataConnection = new DataChannelConnection ( this ) ; if ( ! mDataConnection -> Init ( 5000 , aNumstreams , true ) ) { CSFLogError ( logTag , "%s DataConnection Init Failed" , __FUNCTION__ ) ; return NS_ERROR_FAILURE ; } CSFLogDebug ( logTag , "%s DataChannelConnection %p attached to %s" , __FUNCTION__ , ( void * ) mDataConnection . get ( ) , mHandle . c_str ( ) ) ; #endif return NS_OK ; }
PJ_DEF ( void ) pj_scan_get_until ( pj_scanner * scanner , const pj_cis_t * spec , pj_str_t * out ) { register char * s = scanner -> curptr ; if ( s >= scanner -> end ) { pj_scan_syntax_err ( scanner ) ; return ; } while ( PJ_SCAN_CHECK_EOF ( s ) && ! pj_cis_match ( spec , * s ) ) { ++ s ; } pj_strset3 ( out , scanner -> curptr , s ) ; scanner -> curptr = s ; if ( PJ_SCAN_IS_PROBABLY_SPACE ( * s ) && scanner -> skip_ws ) { pj_scan_skip_whitespace ( scanner ) ; } }
png_write_end ( png_structrp png_ptr , png_inforp info_ptr ) { png_debug ( 1 , "in png_write_end" ) ; if ( png_ptr == NULL ) return ; if ( ! ( png_ptr -> mode & PNG_HAVE_IDAT ) ) png_error ( png_ptr , "No IDATs written into file" ) ; #ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED if ( png_ptr -> num_palette_max > png_ptr -> num_palette ) png_benign_error ( png_ptr , "Wrote palette index exceeding num_palette" ) ; #endif if ( info_ptr != NULL ) { #ifdef PNG_WRITE_TEXT_SUPPORTED int i ; #endif #ifdef PNG_WRITE_tIME_SUPPORTED if ( ( info_ptr -> valid & PNG_INFO_tIME ) && ! ( png_ptr -> mode & PNG_WROTE_tIME ) ) png_write_tIME ( png_ptr , & ( info_ptr -> mod_time ) ) ; #endif #ifdef PNG_WRITE_TEXT_SUPPORTED for ( i = 0 ; i < info_ptr -> num_text ; i ++ ) { png_debug2 ( 2 , "Writing trailer text chunk %d, type %d" , i , info_ptr -> text [ i ] . compression ) ; if ( info_ptr -> text [ i ] . compression > 0 ) { #ifdef PNG_WRITE_iTXt_SUPPORTED png_write_iTXt ( png_ptr , info_ptr -> text [ i ] . compression , info_ptr -> text [ i ] . key , info_ptr -> text [ i ] . lang , info_ptr -> text [ i ] . lang_key , info_ptr -> text [ i ] . text ) ; #else png_warning ( png_ptr , "Unable to write international text" ) ; #endif info_ptr -> text [ i ] . compression = PNG_TEXT_COMPRESSION_NONE_WR ; } else if ( info_ptr -> text [ i ] . compression >= PNG_TEXT_COMPRESSION_zTXt ) { #ifdef PNG_WRITE_zTXt_SUPPORTED png_write_zTXt ( png_ptr , info_ptr -> text [ i ] . key , info_ptr -> text [ i ] . text , 0 , info_ptr -> text [ i ] . compression ) ; #else png_warning ( png_ptr , "Unable to write compressed text" ) ; #endif info_ptr -> text [ i ] . compression = PNG_TEXT_COMPRESSION_zTXt_WR ; } else if ( info_ptr -> text [ i ] . compression == PNG_TEXT_COMPRESSION_NONE ) { #ifdef PNG_WRITE_tEXt_SUPPORTED png_write_tEXt ( png_ptr , info_ptr -> text [ i ] . key , info_ptr -> text [ i ] . text , 0 ) ; #else png_warning ( png_ptr , "Unable to write uncompressed text" ) ; #endif info_ptr -> text [ i ] . compression = PNG_TEXT_COMPRESSION_NONE_WR ; } } #endif #ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED write_unknown_chunks ( png_ptr , info_ptr , PNG_AFTER_IDAT ) ; #endif } png_ptr -> mode |= PNG_AFTER_IDAT ; png_write_IEND ( png_ptr ) ; #ifdef PNG_WRITE_FLUSH_SUPPORTED #  ifdef PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED png_flush ( png_ptr ) ; #  endif #endif }
nsTableRowFrame :: AppendFrames ( ChildListID aListID , nsFrameList & aFrameList ) { NS_ASSERTION ( aListID == kPrincipalList , "unexpected child list" ) ; const nsFrameList :: Slice & newCells = mFrames . AppendFrames ( nullptr , aFrameList ) ; nsTableFrame * tableFrame = nsTableFrame :: GetTableFrame ( this ) ; for ( nsFrameList :: Enumerator e ( newCells ) ; ! e . AtEnd ( ) ; e . Next ( ) ) { nsIFrame * childFrame = e . get ( ) ; NS_ASSERTION ( IS_TABLE_CELL ( childFrame -> GetType ( ) ) , "Not a table cell frame/pseudo frame construction failure" ) ; tableFrame -> AppendCell ( static_cast < nsTableCellFrame & > ( * childFrame ) , GetRowIndex ( ) ) ; } PresContext ( ) -> PresShell ( ) -> FrameNeedsReflow ( this , nsIPresShell :: eTreeChange , NS_FRAME_HAS_DIRTY_CHILDREN ) ; tableFrame -> SetGeometryDirty ( ) ; }
static void php_array_replace_recursive ( PointerSet & seen , bool check , Array & arr1 , const Array & arr2 ) { if ( check ) { if ( seen . find ( ( void * ) arr1 . get ( ) ) != seen . end ( ) ) { raise_warning ( "array_replace_recursive(): recursion detected" ) ; return ; } seen . insert ( ( void * ) arr1 . get ( ) ) ; } for ( ArrayIter iter ( arr2 ) ; iter ; ++ iter ) { Variant key = iter . first ( ) ; const Variant & value = iter . secondRef ( ) ; if ( arr1 . exists ( key , true ) && value . isArray ( ) ) { Variant & v = arr1 . lvalAt ( key , AccessFlags :: Key ) ; if ( v . isArray ( ) ) { Array subarr1 = v . toArray ( ) ; const ArrNR & arr_value = value . toArrNR ( ) ; php_array_replace_recursive ( seen , v . isReferenced ( ) , subarr1 , arr_value ) ; v = subarr1 ; } else { arr1 . set ( key , value , true ) ; } } else { arr1 . setWithRef ( key , value , true ) ; } } if ( check ) { seen . erase ( ( void * ) arr1 . get ( ) ) ; } }
BOOL StartServiceUpdate ( LPCWSTR installDir ) { SC_HANDLE manager = OpenSCManager ( nullptr , nullptr , SC_MANAGER_ALL_ACCESS ) ; if ( ! manager ) { return FALSE ; } SC_HANDLE svc = OpenServiceW ( manager , SVC_NAME , SERVICE_ALL_ACCESS ) ; if ( ! svc ) { CloseServiceHandle ( manager ) ; return FALSE ; } CloseServiceHandle ( manager ) ; DWORD bytesNeeded ; if ( ! QueryServiceConfigW ( svc , nullptr , 0 , & bytesNeeded ) && GetLastError ( ) != ERROR_INSUFFICIENT_BUFFER ) { CloseServiceHandle ( svc ) ; return FALSE ; } UniquePtr < char [ ] > serviceConfigBuffer = MakeUnique < char [ ] > ( bytesNeeded ) ; if ( ! QueryServiceConfigW ( svc , reinterpret_cast < QUERY_SERVICE_CONFIGW * > ( serviceConfigBuffer . get ( ) ) , bytesNeeded , & bytesNeeded ) ) { CloseServiceHandle ( svc ) ; return FALSE ; } CloseServiceHandle ( svc ) ; QUERY_SERVICE_CONFIGW & serviceConfig = * reinterpret_cast < QUERY_SERVICE_CONFIGW * > ( serviceConfigBuffer . get ( ) ) ; PathUnquoteSpacesW ( serviceConfig . lpBinaryPathName ) ; WCHAR tmpService [ MAX_PATH + 1 ] = { L'\0' } ; if ( ! PathGetSiblingFilePath ( tmpService , serviceConfig . lpBinaryPathName , L"maintenanceservice_tmp.exe" ) ) { return FALSE ; } WCHAR newMaintServicePath [ MAX_PATH + 1 ] = { L'\0' } ; wcsncpy ( newMaintServicePath , installDir , MAX_PATH ) ; PathAppendSafe ( newMaintServicePath , L"maintenanceservice.exe" ) ; if ( ! CopyFileW ( newMaintServicePath , tmpService , FALSE ) ) { return FALSE ; } if ( ! DoesBinaryMatchAllowedCertificates ( installDir , tmpService ) ) { DeleteFileW ( tmpService ) ; return FALSE ; } STARTUPINFOW si = { 0 } ; si . cb = sizeof ( STARTUPINFOW ) ; si . lpDesktop = const_cast < LPWSTR > ( L"" ) ; PROCESS_INFORMATION pi = { 0 } ; WCHAR cmdLine [ 64 ] = { '\0' } ; wcsncpy ( cmdLine , L"dummyparam.exe upgrade" , sizeof ( cmdLine ) / sizeof ( cmdLine [ 0 ] ) - 1 ) ; BOOL svcUpdateProcessStarted = CreateProcessW ( tmpService , cmdLine , nullptr , nullptr , FALSE , 0 , nullptr , installDir , & si , & pi ) ; if ( svcUpdateProcessStarted ) { CloseHandle ( pi . hProcess ) ; CloseHandle ( pi . hThread ) ; } return svcUpdateProcessStarted ; }
JSStructuredCloneWriter :: transferOwnership ( ) { if ( transferableObjects . empty ( ) ) return true ; uint64_t * point = out . rawBuffer ( ) ; JS_ASSERT ( uint32_t ( LittleEndian :: readUint64 ( point ) > > 32 ) == SCTAG_TRANSFER_MAP_HEADER ) ; point ++ ; JS_ASSERT ( LittleEndian :: readUint64 ( point ) == transferableObjects . length ( ) ) ; point ++ ; for ( JS :: AutoObjectVector :: Range tr = transferableObjects . all ( ) ; ! tr . empty ( ) ; tr . popFront ( ) ) { RootedObject obj ( context ( ) , tr . front ( ) ) ; uint32_t tag ; JS :: TransferableOwnership ownership ; void * content ; uint64_t extraData ; #if DEBUG SCInput :: getPair ( point , & tag , ( uint32_t * ) & ownership ) ; MOZ_ASSERT ( tag == SCTAG_TRANSFER_MAP_PENDING_ENTRY ) ; MOZ_ASSERT ( ownership == JS :: SCTAG_TMO_UNFILLED ) ; #endif if ( obj -> is < ArrayBufferObject > ( ) ) { bool isMapped = obj -> as < ArrayBufferObject > ( ) . isMappedArrayBuffer ( ) ; size_t nbytes = obj -> as < ArrayBufferObject > ( ) . byteLength ( ) ; content = JS_StealArrayBufferContents ( context ( ) , obj ) ; if ( ! content ) return false ; tag = SCTAG_TRANSFER_MAP_ARRAY_BUFFER ; if ( isMapped ) ownership = JS :: SCTAG_TMO_MAPPED_DATA ; else ownership = JS :: SCTAG_TMO_ALLOC_DATA ; extraData = nbytes ; } else if ( obj -> is < SharedArrayBufferObject > ( ) ) { SharedArrayRawBuffer * rawbuf = obj -> as < SharedArrayBufferObject > ( ) . rawBufferObject ( ) ; rawbuf -> addReference ( ) ; tag = SCTAG_TRANSFER_MAP_SHARED_BUFFER ; ownership = JS :: SCTAG_TMO_SHARED_BUFFER ; content = rawbuf ; extraData = 0 ; } else { if ( ! callbacks || ! callbacks -> writeTransfer ) return reportErrorTransferable ( ) ; if ( ! callbacks -> writeTransfer ( context ( ) , obj , closure , & tag , & ownership , & content , & extraData ) ) return false ; JS_ASSERT ( tag > SCTAG_TRANSFER_MAP_PENDING_ENTRY ) ; } LittleEndian :: writeUint64 ( point ++ , PairToUInt64 ( tag , ownership ) ) ; LittleEndian :: writeUint64 ( point ++ , reinterpret_cast < uint64_t > ( content ) ) ; LittleEndian :: writeUint64 ( point ++ , extraData ) ; } JS_ASSERT ( point <= out . rawBuffer ( ) + out . count ( ) ) ; JS_ASSERT_IF ( point < out . rawBuffer ( ) + out . count ( ) , uint32_t ( LittleEndian :: readUint64 ( point ) > > 32 ) < SCTAG_TRANSFER_MAP_HEADER ) ; return true ; }
static int mpeg4video_probe ( AVProbeData * probe_packet ) { uint32_t temp_buffer = - 1 ; int VO = 0 , VOL = 0 , VOP = 0 , VISO = 0 , res = 0 ; int i ; for ( i = 0 ; i < probe_packet -> buf_size ; i ++ ) { temp_buffer = ( temp_buffer < < 8 ) + probe_packet -> buf [ i ] ; if ( ( temp_buffer & 0xffffff00 ) != 0x100 ) continue ; if ( temp_buffer == VOP_START_CODE ) VOP ++ ; else if ( temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ; else if ( temp_buffer < 0x120 ) VO ++ ; else if ( temp_buffer < 0x130 ) VOL ++ ; else if ( ! ( 0x1AF < temp_buffer && temp_buffer < 0x1B7 ) && ! ( 0x1B9 < temp_buffer && temp_buffer < 0x1C4 ) ) res ++ ; } if ( VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0 ) return AVPROBE_SCORE_EXTENSION ; return 0 ; }
static int __init pcd_init ( void ) { struct pcd_unit * cd ; int unit ; if ( disable ) return - EINVAL ; pcd_init_units ( ) ; if ( pcd_detect ( ) ) return - ENODEV ; pcd_probe_capabilities ( ) ; if ( register_blkdev ( major , name ) ) { for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) put_disk ( cd -> disk ) ; return - EBUSY ; } for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { if ( cd -> present ) { register_cdrom ( & cd -> info ) ; cd -> disk -> private_data = cd ; add_disk ( cd -> disk ) ; } } return 0 ; }
void DependOnStablePrototypeChain ( JSHeapBroker * broker , CompilationDependencies * deps , Handle < Map > map , MaybeHandle < JSReceiver > last_prototype ) { for ( PrototypeIterator i ( broker -> isolate ( ) , map ) ; ! i . IsAtEnd ( ) ; i . Advance ( ) ) { Handle < JSReceiver > const current = PrototypeIterator :: GetCurrent < JSReceiver > ( i ) ; deps -> DependOnStableMap ( MapRef ( broker , handle ( current -> map ( ) , broker -> isolate ( ) ) ) ) ; Handle < JSReceiver > last ; if ( last_prototype . ToHandle ( & last ) && last . is_identical_to ( current ) ) { break ; } } }
status_t Parcel :: readNullableNativeHandleNoDup ( const native_handle_t * * handle , bool embedded , size_t parent_buffer_handle , size_t parent_offset ) const { status_t status ; uint64_t nativeHandleSize ; size_t fdaParent ; status = readUint64 ( & nativeHandleSize ) ; if ( status != OK || nativeHandleSize == 0 ) { * handle = nullptr ; return status ; } if ( nativeHandleSize < sizeof ( native_handle_t ) ) { ALOGE ( "Received a native_handle_t size that was too small." ) ; return BAD_VALUE ; } if ( embedded ) { status = readNullableEmbeddedBuffer ( nativeHandleSize , & fdaParent , parent_buffer_handle , parent_offset , reinterpret_cast < const void * * > ( handle ) ) ; } else { status = readNullableBuffer ( nativeHandleSize , & fdaParent , reinterpret_cast < const void * * > ( handle ) ) ; } if ( status != OK ) { return status ; } const binder_fd_array_object * fd_array_obj = readObject < binder_fd_array_object > ( ) ; if ( fd_array_obj == nullptr || fd_array_obj -> hdr . type != BINDER_TYPE_FDA ) { ALOGE ( "Can't find file-descriptor array object." ) ; return BAD_VALUE ; } if ( static_cast < int > ( fd_array_obj -> num_fds ) != ( * handle ) -> numFds ) { ALOGE ( "Number of native handles does not match." ) ; return BAD_VALUE ; } if ( fd_array_obj -> parent != fdaParent ) { ALOGE ( "Parent handle of file-descriptor array not correct." ) ; return BAD_VALUE ; } if ( fd_array_obj -> parent_offset != offsetof ( native_handle_t , data ) ) { ALOGE ( "FD array object not properly offset in parent." ) ; return BAD_VALUE ; } return OK ; }
Handle < String > Scanner :: SourceMappingUrl ( Isolate * isolate ) const { Handle < String > tmp ; if ( source_mapping_url_ . length ( ) > 0 ) { DCHECK ( source_mapping_url_ . is_used ( ) ) ; tmp = source_mapping_url_ . Internalize ( isolate ) ; } return tmp ; }
void nsPluginInstanceOwner :: SetFrame ( nsPluginFrame * aFrame ) { if ( mPluginFrame == aFrame ) { return ; } if ( mPluginFrame ) { if ( mContent && mContent -> OwnerDoc ( ) && mContent -> OwnerDoc ( ) -> GetWindow ( ) ) { nsCOMPtr < EventTarget > windowRoot = mContent -> OwnerDoc ( ) -> GetWindow ( ) -> GetTopWindowRoot ( ) ; if ( windowRoot ) { windowRoot -> RemoveEventListener ( NS_LITERAL_STRING ( "activate" ) , this , false ) ; windowRoot -> RemoveEventListener ( NS_LITERAL_STRING ( "deactivate" ) , this , false ) ; windowRoot -> RemoveEventListener ( NS_LITERAL_STRING ( "MozPerformDelayedBlur" ) , this , false ) ; } } mPluginFrame -> SetInstanceOwner ( nullptr ) ; } mPluginFrame = aFrame ; if ( mPluginFrame ) { mPluginFrame -> SetInstanceOwner ( this ) ; if ( mWidgetCreationComplete ) { mPluginFrame -> PrepForDrawing ( mWidget ) ; } mPluginFrame -> FixupWindow ( mPluginFrame -> GetContentRectRelativeToSelf ( ) . Size ( ) ) ; mPluginFrame -> InvalidateFrame ( ) ; nsFocusManager * fm = nsFocusManager :: GetFocusManager ( ) ; const nsIContent * content = aFrame -> GetContent ( ) ; if ( fm && content ) { mContentFocused = ( content == fm -> GetFocusedContent ( ) ) ; } if ( mContent && mContent -> OwnerDoc ( ) && mContent -> OwnerDoc ( ) -> GetWindow ( ) ) { nsCOMPtr < EventTarget > windowRoot = mContent -> OwnerDoc ( ) -> GetWindow ( ) -> GetTopWindowRoot ( ) ; if ( windowRoot ) { windowRoot -> AddEventListener ( NS_LITERAL_STRING ( "activate" ) , this , false , false ) ; windowRoot -> AddEventListener ( NS_LITERAL_STRING ( "deactivate" ) , this , false , false ) ; windowRoot -> AddEventListener ( NS_LITERAL_STRING ( "MozPerformDelayedBlur" ) , this , false , false ) ; } } } }
void RegExpMacroAssemblerMIPS :: CheckNotBackReferenceIgnoreCase ( int start_reg , bool read_backward , bool unicode , Label * on_no_match ) { Label fallthrough ; __ Ld ( a0 , register_location ( start_reg ) ) ; __ Ld ( a1 , register_location ( start_reg + 1 ) ) ; __ Dsubu ( a1 , a1 , a0 ) ; __ Branch ( & fallthrough , eq , a1 , Operand ( zero_reg ) ) ; if ( read_backward ) { __ Ld ( t1 , MemOperand ( frame_pointer ( ) , kStringStartMinusOne ) ) ; __ Daddu ( t1 , t1 , a1 ) ; BranchOrBacktrack ( on_no_match , le , current_input_offset ( ) , Operand ( t1 ) ) ; } else { __ Daddu ( t1 , a1 , current_input_offset ( ) ) ; BranchOrBacktrack ( on_no_match , gt , t1 , Operand ( zero_reg ) ) ; } if ( mode_ == LATIN1 ) { Label success ; Label fail ; Label loop_check ; __ Daddu ( a0 , a0 , Operand ( end_of_input_address ( ) ) ) ; __ Daddu ( a2 , end_of_input_address ( ) , Operand ( current_input_offset ( ) ) ) ; if ( read_backward ) { __ Dsubu ( a2 , a2 , Operand ( a1 ) ) ; } __ Daddu ( a1 , a0 , Operand ( a1 ) ) ; Label loop ; __ bind ( & loop ) ; __ Lbu ( a3 , MemOperand ( a0 , 0 ) ) ; __ daddiu ( a0 , a0 , char_size ( ) ) ; __ Lbu ( a4 , MemOperand ( a2 , 0 ) ) ; __ daddiu ( a2 , a2 , char_size ( ) ) ; __ Branch ( & loop_check , eq , a4 , Operand ( a3 ) ) ; __ Or ( a3 , a3 , Operand ( 0x20 ) ) ; __ Or ( a4 , a4 , Operand ( 0x20 ) ) ; __ Branch ( & fail , ne , a4 , Operand ( a3 ) ) ; __ Dsubu ( a3 , a3 , Operand ( 'a' ) ) ; __ Branch ( & loop_check , ls , a3 , Operand ( 'z' - 'a' ) ) ; __ Dsubu ( a3 , a3 , Operand ( 224 - 'a' ) ) ; __ Branch ( & fail , hi , a3 , Operand ( 254 - 224 ) ) ; __ Branch ( & fail , eq , a3 , Operand ( 247 - 224 ) ) ; __ bind ( & loop_check ) ; __ Branch ( & loop , lt , a0 , Operand ( a1 ) ) ; __ jmp ( & success ) ; __ bind ( & fail ) ; GoTo ( on_no_match ) ; __ bind ( & success ) ; __ Dsubu ( current_input_offset ( ) , a2 , end_of_input_address ( ) ) ; if ( read_backward ) { __ Ld ( t1 , register_location ( start_reg ) ) ; __ Ld ( a2 , register_location ( start_reg + 1 ) ) ; __ Daddu ( current_input_offset ( ) , current_input_offset ( ) , Operand ( t1 ) ) ; __ Dsubu ( current_input_offset ( ) , current_input_offset ( ) , Operand ( a2 ) ) ; } } else { DCHECK ( mode_ == UC16 ) ; RegList regexp_registers_to_retain = current_input_offset ( ) . bit ( ) | current_character ( ) . bit ( ) | backtrack_stackpointer ( ) . bit ( ) ; __ MultiPush ( regexp_registers_to_retain ) ; int argument_count = 4 ; __ PrepareCallCFunction ( argument_count , a2 ) ; __ Daddu ( a0 , a0 , Operand ( end_of_input_address ( ) ) ) ; __ mov ( a2 , a1 ) ; __ mov ( s3 , a1 ) ; __ Daddu ( a1 , current_input_offset ( ) , Operand ( end_of_input_address ( ) ) ) ; if ( read_backward ) { __ Dsubu ( a1 , a1 , Operand ( s3 ) ) ; } #ifdef V8_INTL_SUPPORT if ( unicode ) { __ mov ( a3 , zero_reg ) ; } else #endif // V8_INTL_SUPPORT { __ li ( a3 , Operand ( ExternalReference :: isolate_address ( masm_ -> isolate ( ) ) ) ) ; } { AllowExternalCallThatCantCauseGC scope ( masm_ ) ; ExternalReference function = ExternalReference :: re_case_insensitive_compare_uc16 ( masm_ -> isolate ( ) ) ; __ CallCFunction ( function , argument_count ) ; } __ MultiPop ( regexp_registers_to_retain ) ; __ li ( code_pointer ( ) , Operand ( masm_ -> CodeObject ( ) ) , CONSTANT_SIZE ) ; __ Ld ( end_of_input_address ( ) , MemOperand ( frame_pointer ( ) , kInputEnd ) ) ; BranchOrBacktrack ( on_no_match , eq , v0 , Operand ( zero_reg ) ) ; if ( read_backward ) { __ Dsubu ( current_input_offset ( ) , current_input_offset ( ) , Operand ( s3 ) ) ; } else { __ Daddu ( current_input_offset ( ) , current_input_offset ( ) , Operand ( s3 ) ) ; } } __ bind ( & fallthrough ) ; }
status_t AudioFlinger :: setMasterVolume ( float value ) { status_t ret = initCheck ( ) ; if ( ret != NO_ERROR ) { return ret ; } if ( ! settingsAllowed ( ) ) { return PERMISSION_DENIED ; } Mutex :: Autolock _l ( mLock ) ; mMasterVolume = value ; for ( size_t i = 0 ; i < mAudioHwDevs . size ( ) ; i ++ ) { AutoMutex lock ( mHardwareLock ) ; AudioHwDevice * dev = mAudioHwDevs . valueAt ( i ) ; mHardwareStatus = AUDIO_HW_SET_MASTER_VOLUME ; if ( dev -> canSetMasterVolume ( ) ) { dev -> hwDevice ( ) -> set_master_volume ( dev -> hwDevice ( ) , value ) ; } mHardwareStatus = AUDIO_HW_IDLE ; } for ( size_t i = 0 ; i < mPlaybackThreads . size ( ) ; i ++ ) mPlaybackThreads . valueAt ( i ) -> setMasterVolume ( value ) ; return NO_ERROR ; }
static void do_change_user ( FILE * fin , FILE * fout ) { std :: string uname ; lwp_read ( fin , uname ) ; if ( uname . length ( ) > 0 ) { struct passwd * pw = getpwnam ( uname . c_str ( ) ) ; if ( pw ) { if ( pw -> pw_gid ) { setgid ( pw -> pw_gid ) ; } if ( pw -> pw_uid ) { setuid ( pw -> pw_uid ) ; } } } }
TEST ( stagefright_MoofParser , test_case_mp4_skimming ) { const size_t step = 4u ; nsRefPtr < MediaByteBuffer > buffer = new MediaByteBuffer ( test_case_mp4_len ) ; buffer -> AppendElements ( test_case_mp4 , test_case_mp4_len ) ; Monitor monitor ( "MP4Metadata::HasCompleteMetadata" ) ; MonitorAutoLock mon ( monitor ) ; for ( size_t offset = 0 ; offset < test_case_mp4_len - step ; offset += step ) { nsRefPtr < BufferStream > stream = new BufferStream ( buffer ) ; MoofParser parser ( stream , 0 , false , & monitor ) ; nsTArray < MediaByteRange > byteRanges ; byteRanges . AppendElement ( MediaByteRange ( 0 , 0 ) ) ; EXPECT_FALSE ( parser . RebuildFragmentedIndex ( byteRanges ) ) ; parser . GetCompositionRange ( byteRanges ) ; parser . HasMetadata ( ) ; nsRefPtr < MediaByteBuffer > metadataBuffer = parser . Metadata ( ) ; parser . FirstCompleteMediaSegment ( ) ; parser . FirstCompleteMediaHeader ( ) ; buffer -> RemoveElementsAt ( 0 , step ) ; } }
int ras_validate ( jas_stream_t * in ) { uchar buf [ RAS_MAGICLEN ] ; int i ; int n ; uint_fast32_t magic ; assert ( JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN ) ; if ( ( n = jas_stream_read ( in , buf , RAS_MAGICLEN ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < RAS_MAGICLEN ) { return - 1 ; } magic = ( JAS_CAST ( uint_fast32_t , buf [ 0 ] ) < < 24 ) | ( JAS_CAST ( uint_fast32_t , buf [ 1 ] ) < < 16 ) | ( JAS_CAST ( uint_fast32_t , buf [ 2 ] ) < < 8 ) | buf [ 3 ] ; if ( magic != RAS_MAGIC ) { return - 1 ; } return 0 ; }
BEGIN_TEST ( test_cloneScript ) { JS :: RootedObject A ( cx , createGlobal ( ) ) ; JS :: RootedObject B ( cx , createGlobal ( ) ) ; CHECK ( A ) ; CHECK ( B ) ; const char * source = "var i = 0;\n" "var sum = 0;\n" "while (i < 10) {\n" "    sum += i;\n" "    ++i;\n" "}\n" "(sum);\n" ; JS :: RootedObject obj ( cx ) ; { JSAutoCompartment a ( cx , A ) ; JSFunction * fun ; JS :: CompileOptions options ( cx ) ; options . setFileAndLine ( __FILE__ , 1 ) ; CHECK ( fun = JS_CompileFunction ( cx , A , "f" , 0 , nullptr , source , strlen ( source ) , options ) ) ; CHECK ( obj = JS_GetFunctionObject ( fun ) ) ; } { JSAutoCompartment b ( cx , B ) ; CHECK ( JS_CloneFunctionObject ( cx , obj , B ) ) ; } return true ; }
WebGLContext :: InitAndValidateGL ( ) { if ( ! gl ) return PR_FALSE ; GLenum error = gl -> fGetError ( ) ; if ( error != LOCAL_GL_NO_ERROR ) { LogMessage ( "GL error 0x%x occurred during OpenGL context initialization, before WebGL initialization!" , error ) ; return PR_FALSE ; } mActiveTexture = 0 ; mSynthesizedGLError = LOCAL_GL_NO_ERROR ; mAttribBuffers . Clear ( ) ; mUniformTextures . Clear ( ) ; mBound2DTextures . Clear ( ) ; mBoundCubeMapTextures . Clear ( ) ; mBoundArrayBuffer = nsnull ; mBoundElementArrayBuffer = nsnull ; mCurrentProgram = nsnull ; mBoundFramebuffer = nsnull ; mBoundRenderbuffer = nsnull ; mMapTextures . Clear ( ) ; mMapBuffers . Clear ( ) ; mMapPrograms . Clear ( ) ; mMapShaders . Clear ( ) ; mMapFramebuffers . Clear ( ) ; mMapRenderbuffers . Clear ( ) ; MakeContextCurrent ( ) ; if ( ! gl -> IsGLES2 ( ) ) { gl -> fEnableVertexAttribArray ( 0 ) ; } gl -> fGetIntegerv ( LOCAL_GL_MAX_VERTEX_ATTRIBS , & mGLMaxVertexAttribs ) ; if ( mGLMaxVertexAttribs < 8 ) { LogMessage ( "GL_MAX_VERTEX_ATTRIBS: %d is < 8!" , mGLMaxVertexAttribs ) ; return PR_FALSE ; } mAttribBuffers . SetLength ( mGLMaxVertexAttribs ) ; gl -> fGetIntegerv ( LOCAL_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS , & mGLMaxTextureUnits ) ; if ( mGLMaxTextureUnits < 8 ) { LogMessage ( "GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: %d is < 8!" , mGLMaxTextureUnits ) ; return PR_FALSE ; } mBound2DTextures . SetLength ( mGLMaxTextureUnits ) ; mBoundCubeMapTextures . SetLength ( mGLMaxTextureUnits ) ; gl -> fGetIntegerv ( LOCAL_GL_MAX_TEXTURE_SIZE , & mGLMaxTextureSize ) ; gl -> fGetIntegerv ( LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE , & mGLMaxCubeMapTextureSize ) ; gl -> fGetIntegerv ( LOCAL_GL_MAX_TEXTURE_IMAGE_UNITS , & mGLMaxTextureImageUnits ) ; gl -> fGetIntegerv ( LOCAL_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS , & mGLMaxVertexTextureImageUnits ) ; if ( gl -> HasES2Compatibility ( ) ) { gl -> fGetIntegerv ( LOCAL_GL_MAX_FRAGMENT_UNIFORM_VECTORS , & mGLMaxFragmentUniformVectors ) ; gl -> fGetIntegerv ( LOCAL_GL_MAX_VERTEX_UNIFORM_VECTORS , & mGLMaxVertexUniformVectors ) ; gl -> fGetIntegerv ( LOCAL_GL_MAX_VARYING_VECTORS , & mGLMaxVaryingVectors ) ; } else { gl -> fGetIntegerv ( LOCAL_GL_MAX_FRAGMENT_UNIFORM_COMPONENTS , & mGLMaxFragmentUniformVectors ) ; mGLMaxFragmentUniformVectors /= 4 ; gl -> fGetIntegerv ( LOCAL_GL_MAX_VERTEX_UNIFORM_COMPONENTS , & mGLMaxVertexUniformVectors ) ; mGLMaxVertexUniformVectors /= 4 ; error = gl -> GetAndClearError ( ) ; if ( error != LOCAL_GL_NO_ERROR ) { LogMessage ( "GL error 0x%x occurred during WebGL context initialization!" , error ) ; return PR_FALSE ; } GLint maxVertexOutputComponents , minFragmentInputComponents ; gl -> fGetIntegerv ( LOCAL_GL_MAX_VERTEX_OUTPUT_COMPONENTS , & maxVertexOutputComponents ) ; gl -> fGetIntegerv ( LOCAL_GL_MAX_FRAGMENT_INPUT_COMPONENTS , & minFragmentInputComponents ) ; error = gl -> fGetError ( ) ; switch ( error ) { case LOCAL_GL_NO_ERROR : mGLMaxVaryingVectors = NS_MIN ( maxVertexOutputComponents , minFragmentInputComponents ) / 4 ; break ; case LOCAL_GL_INVALID_ENUM : mGLMaxVaryingVectors = 16 ; break ; default : LogMessage ( "GL error 0x%x occurred during WebGL context initialization!" , error ) ; return PR_FALSE ; } } mMaxFramebufferColorAttachments = 1 ; if ( ! gl -> IsGLES2 ( ) ) { gl -> fEnable ( LOCAL_GL_VERTEX_PROGRAM_POINT_SIZE ) ; #ifdef XP_WIN if ( gl -> Vendor ( ) != gl :: GLContext :: VendorATI ) #else if ( true ) #endif { gl -> fEnable ( LOCAL_GL_POINT_SPRITE ) ; } } NS_ENSURE_TRUE ( Preferences :: GetRootBranch ( ) , NS_ERROR_FAILURE ) ; mShaderValidation = Preferences :: GetBool ( "webgl.shader_validator" , mShaderValidation ) ; #if defined(USE_ANGLE) if ( mShaderValidation ) { if ( ! ShInitialize ( ) ) { LogMessage ( "GLSL translator initialization failed!" ) ; return PR_FALSE ; } } #endif error = gl -> GetAndClearError ( ) ; if ( error != LOCAL_GL_NO_ERROR ) { LogMessage ( "GL error 0x%x occurred during WebGL context initialization!" , error ) ; return PR_FALSE ; } return PR_TRUE ; }
void fmtutil_macbitmap_read_pixmap_only_fields ( deark * c , dbuf * f , struct fmtutil_macbitmap_info * bi , i64 pos ) { i64 pixmap_version ; i64 pack_size ; i64 plane_bytes ; i64 n ; de_dbg ( c , "additional PixMap header fields, at %d" , ( int ) pos ) ; de_dbg_indent ( c , 1 ) ; pixmap_version = dbuf_getu16be ( f , pos + 0 ) ; de_dbg ( c , "pixmap version: %d" , ( int ) pixmap_version ) ; bi -> packing_type = dbuf_getu16be ( f , pos + 2 ) ; de_dbg ( c , "packing type: %d" , ( int ) bi -> packing_type ) ; pack_size = dbuf_getu32be ( f , pos + 4 ) ; de_dbg ( c , "pixel data length: %d" , ( int ) pack_size ) ; bi -> hdpi = pict_read_fixed ( f , pos + 8 ) ; bi -> vdpi = pict_read_fixed ( f , pos + 12 ) ; de_dbg ( c , "dpi: %.2f"DE_CHAR_TIMES "%.2f" , bi -> hdpi , bi -> vdpi ) ; bi -> pixeltype = dbuf_getu16be ( f , pos + 16 ) ; bi -> pixelsize = dbuf_getu16be ( f , pos + 18 ) ; bi -> cmpcount = dbuf_getu16be ( f , pos + 20 ) ; bi -> cmpsize = dbuf_getu16be ( f , pos + 22 ) ; de_dbg ( c , "pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d" , ( int ) bi -> pixeltype , ( int ) bi -> pixelsize , ( int ) bi -> cmpcount , ( int ) bi -> cmpsize ) ; bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ; if ( bi -> pdwidth < bi -> npwidth ) { bi -> pdwidth = bi -> npwidth ; } plane_bytes = dbuf_getu32be ( f , pos + 24 ) ; de_dbg ( c , "plane bytes: %d" , ( int ) plane_bytes ) ; bi -> pmTable = ( u32 ) dbuf_getu32be ( f , pos + 28 ) ; de_dbg ( c , "pmTable: 0x%08x" , ( unsigned int ) bi -> pmTable ) ; n = dbuf_getu32be ( f , pos + 32 ) ; de_dbg ( c , "pmReserved: 0x%08x" , ( unsigned int ) n ) ; de_dbg_indent ( c , - 1 ) ; }
status_t AudioFlinger :: EffectModule :: command ( uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { Mutex :: Autolock _l ( mLock ) ; ALOGVV ( "command(), cmdCode: %d, mEffectInterface: %p" , cmdCode , mEffectInterface ) ; if ( mState == DESTROYED || mEffectInterface == NULL ) { return NO_INIT ; } if ( mStatus != NO_ERROR ) { return mStatus ; } if ( cmdCode == EFFECT_CMD_GET_PARAM && ( * replySize < sizeof ( effect_param_t ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t ) ) ) { android_errorWriteLog ( 0x534e4554 , "29251553" ) ; return - EINVAL ; } if ( cmdCode == EFFECT_CMD_GET_PARAM && ( sizeof ( effect_param_t ) > cmdSize || ( ( effect_param_t * ) pCmdData ) -> psize > cmdSize - sizeof ( effect_param_t ) ) ) { android_errorWriteLog ( 0x534e4554 , "32438594" ) ; return - EINVAL ; } if ( ( cmdCode == EFFECT_CMD_SET_PARAM || cmdCode == EFFECT_CMD_SET_PARAM_DEFERRED ) && ( sizeof ( effect_param_t ) > cmdSize || ( ( effect_param_t * ) pCmdData ) -> psize > cmdSize - sizeof ( effect_param_t ) || ( ( effect_param_t * ) pCmdData ) -> vsize > cmdSize - sizeof ( effect_param_t ) - ( ( effect_param_t * ) pCmdData ) -> psize || roundUpDelta ( ( ( effect_param_t * ) pCmdData ) -> psize , ( uint32_t ) sizeof ( int ) ) > cmdSize - sizeof ( effect_param_t ) - ( ( effect_param_t * ) pCmdData ) -> psize - ( ( effect_param_t * ) pCmdData ) -> vsize ) ) { android_errorWriteLog ( 0x534e4554 , "30204301" ) ; return - EINVAL ; } status_t status = ( * mEffectInterface ) -> command ( mEffectInterface , cmdCode , cmdSize , pCmdData , replySize , pReplyData ) ; if ( cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR ) { uint32_t size = ( replySize == NULL ) ? 0 : * replySize ; for ( size_t i = 1 ; i < mHandles . size ( ) ; i ++ ) { EffectHandle * h = mHandles [ i ] ; if ( h != NULL && ! h -> destroyed_l ( ) ) { h -> commandExecuted ( cmdCode , cmdSize , pCmdData , size , pReplyData ) ; } } } return status ; }
void Scanner :: LiteralBuffer :: ExpandBuffer ( ) { Vector < byte > new_store = Vector < byte > :: New ( NewCapacity ( kInitialCapacity ) ) ; MemCopy ( new_store . start ( ) , backing_store_ . start ( ) , position_ ) ; backing_store_ . Dispose ( ) ; backing_store_ = new_store ; }
static void ext4_put_super ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_super_block * es = sbi -> s_es ; int i , err ; ext4_unregister_li_request ( sb ) ; dquot_disable ( sb , - 1 , DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED ) ; flush_workqueue ( sbi -> rsv_conversion_wq ) ; destroy_workqueue ( sbi -> rsv_conversion_wq ) ; if ( sbi -> s_journal ) { err = jbd2_journal_destroy ( sbi -> s_journal ) ; sbi -> s_journal = NULL ; if ( err < 0 ) ext4_abort ( sb , "Couldn't clean up the journal" ) ; } ext4_unregister_sysfs ( sb ) ; ext4_es_unregister_shrinker ( sbi ) ; del_timer_sync ( & sbi -> s_err_report ) ; ext4_release_system_zone ( sb ) ; ext4_mb_release ( sb ) ; ext4_ext_release ( sb ) ; ext4_xattr_put_super ( sb ) ; if ( ! ( sb -> s_flags & MS_RDONLY ) ) { ext4_clear_feature_journal_needs_recovery ( sb ) ; es -> s_state = cpu_to_le16 ( sbi -> s_mount_state ) ; } if ( ! ( sb -> s_flags & MS_RDONLY ) ) ext4_commit_super ( sb , 1 ) ; for ( i = 0 ; i < sbi -> s_gdb_count ; i ++ ) brelse ( sbi -> s_group_desc [ i ] ) ; kvfree ( sbi -> s_group_desc ) ; kvfree ( sbi -> s_flex_groups ) ; percpu_counter_destroy ( & sbi -> s_freeclusters_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; percpu_counter_destroy ( & sbi -> s_dirtyclusters_counter ) ; brelse ( sbi -> s_sbh ) ; #ifdef CONFIG_QUOTA for ( i = 0 ; i < EXT4_MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; #endif if ( ! list_empty ( & sbi -> s_orphan ) ) dump_orphan_list ( sb , sbi ) ; J_ASSERT ( list_empty ( & sbi -> s_orphan ) ) ; sync_blockdev ( sb -> s_bdev ) ; invalidate_bdev ( sb -> s_bdev ) ; if ( sbi -> journal_bdev && sbi -> journal_bdev != sb -> s_bdev ) { sync_blockdev ( sbi -> journal_bdev ) ; invalidate_bdev ( sbi -> journal_bdev ) ; ext4_blkdev_remove ( sbi ) ; } if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } if ( sbi -> s_mmp_tsk ) kthread_stop ( sbi -> s_mmp_tsk ) ; sb -> s_fs_info = NULL ; kobject_put ( & sbi -> s_kobj ) ; wait_for_completion ( & sbi -> s_kobj_unregister ) ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; }
js :: CreateRegExpPrototype ( JSContext * cx , JSProtoKey key ) { MOZ_ASSERT ( key == JSProto_RegExp ) ; Rooted < RegExpObject * > proto ( cx , cx -> global ( ) -> createBlankPrototype < RegExpObject > ( cx ) ) ; if ( ! proto ) return nullptr ; proto -> NativeObject :: setPrivate ( nullptr ) ; RootedAtom source ( cx , cx -> names ( ) . empty ) ; if ( ! RegExpObject :: initFromAtom ( cx , proto , source , RegExpFlag ( 0 ) ) ) return nullptr ; return proto ; }
void Coverage :: SelectMode ( Isolate * isolate , debug :: Coverage :: Mode mode ) { switch ( mode ) { case debug :: Coverage :: kBestEffort : isolate -> debug ( ) -> RemoveAllCoverageInfos ( ) ; if ( ! isolate -> is_collecting_type_profile ( ) ) { isolate -> SetFeedbackVectorsForProfilingTools ( ReadOnlyRoots ( isolate ) . undefined_value ( ) ) ; } break ; case debug :: Coverage :: kBlockBinary : case debug :: Coverage :: kBlockCount : case debug :: Coverage :: kPreciseBinary : case debug :: Coverage :: kPreciseCount : { HandleScope scope ( isolate ) ; Deoptimizer :: DeoptimizeAll ( isolate ) ; isolate -> MaybeInitializeVectorListFromHeap ( ) ; HeapIterator heap_iterator ( isolate -> heap ( ) ) ; while ( HeapObject * o = heap_iterator . next ( ) ) { if ( IsBinaryMode ( mode ) && o -> IsSharedFunctionInfo ( ) ) { SharedFunctionInfo * shared = SharedFunctionInfo :: cast ( o ) ; shared -> set_has_reported_binary_coverage ( false ) ; } else if ( o -> IsFeedbackVector ( ) ) { FeedbackVector * vector = FeedbackVector :: cast ( o ) ; vector -> clear_invocation_count ( ) ; } } break ; } } isolate -> set_code_coverage_mode ( mode ) ; }
static int oidc_cache_crypto_decrypt_impl ( request_rec * r , unsigned char * ciphertext , int ciphertext_len , const unsigned char * aad , int aad_len , const unsigned char * tag , int tag_len , unsigned char * key , const unsigned char * iv , int iv_len , unsigned char * plaintext ) { EVP_CIPHER_CTX * ctx ; int len ; int plaintext_len ; int ret ; if ( ! ( ctx = EVP_CIPHER_CTX_new ( ) ) ) { oidc_cache_crypto_openssl_error ( r , "EVP_CIPHER_CTX_new" ) ; return - 1 ; } if ( ! EVP_DecryptInit_ex ( ctx , OIDC_CACHE_CIPHER , NULL , NULL , NULL ) ) { oidc_cache_crypto_openssl_error ( r , "EVP_DecryptInit_ex" ) ; return - 1 ; } if ( ! EVP_CIPHER_CTX_ctrl ( ctx , OIDC_CACHE_CRYPTO_SET_IVLEN , iv_len , NULL ) ) { oidc_cache_crypto_openssl_error ( r , "EVP_CIPHER_CTX_ctrl" ) ; return - 1 ; } if ( ! EVP_DecryptInit_ex ( ctx , NULL , NULL , key , iv ) ) { oidc_cache_crypto_openssl_error ( r , "EVP_DecryptInit_ex" ) ; return - 1 ; } if ( ! EVP_DecryptUpdate ( ctx , NULL , & len , aad , aad_len ) ) { oidc_cache_crypto_openssl_error ( r , "EVP_DecryptUpdate aad: aad_len=%d" , aad_len ) ; return - 1 ; } if ( ! EVP_DecryptUpdate ( ctx , plaintext , & len , ciphertext , ciphertext_len ) ) { oidc_cache_crypto_openssl_error ( r , "EVP_DecryptUpdate ciphertext" ) ; return - 1 ; } plaintext_len = len ; if ( ! EVP_CIPHER_CTX_ctrl ( ctx , OIDC_CACHE_CRYPTO_SET_TAG , tag_len , ( void * ) tag ) ) { oidc_cache_crypto_openssl_error ( r , "EVP_CIPHER_CTX_ctrl" ) ; return - 1 ; } ret = EVP_DecryptFinal_ex ( ctx , plaintext + len , & len ) ; EVP_CIPHER_CTX_free ( ctx ) ; if ( ret > 0 ) { plaintext_len += len ; return plaintext_len ; } else { oidc_cache_crypto_openssl_error ( r , "EVP_DecryptFinal_ex" ) ; return - 1 ; } }
static Jsi_RC jsi_BitfieldToValue ( Jsi_Interp * interp , Jsi_OptionSpec * spec , Jsi_Value * * outValue , Jsi_DString * outStr , void * record , Jsi_Wide flags ) { Jsi_csgset * bsget = spec -> init . OPT_BITS ; Jsi_Interp * d = interp ; int idx = spec -> idx ; uchar * data = ( uchar * ) record ; int64_t inum ; Jsi_OptionSpec * enumSpec = ( typeof ( enumSpec ) ) spec -> data ; if ( ! d || ! bsget || idx < 0 ) return Jsi_LogBug ( "invalid bitfield" ) ; Jsi_RC rc = ( * bsget ) ( interp , data , & inum , spec , idx , 0 ) ; if ( rc != JSI_OK ) return JSI_ERROR ; if ( enumSpec ) { struct numStruct { int64_t numVal ; } nval = { inum } ; Jsi_OptionSpec eSpec [ ] = { JSI_OPT ( CUSTOM , struct numStruct , numVal , . help = spec -> help , . flags = JSI_OPT_ENUM_SPEC , . custom = Jsi_Opt_SwitchEnum , . data = ( void * ) enumSpec , . info = 0 , . tname = spec -> tname , . value = 0 , . bits = 0 , . boffset = 8 * sizeof ( int64_t ) ) , JSI_OPT_END ( struct numStruct ) } ; if ( JSI_OK != jsi_EnumToValue ( interp , eSpec , outValue , outStr , ( void * ) & nval , flags ) ) return JSI_ERROR ; } else if ( outStr ) { char obuf [ 100 ] ; snprintf ( obuf , sizeof ( obuf ) , "%" PRId64 , inum ) ; Jsi_DSAppend ( outStr , obuf , NULL ) ; } else { Jsi_Number num = ( Jsi_Number ) inum ; Jsi_ValueMakeNumber ( interp , outValue , num ) ; } return JSI_OK ; }
nsXMLPrettyPrinter :: PrettyPrint ( nsIDocument * aDocument , bool * aDidPrettyPrint ) { * aDidPrettyPrint = false ; if ( ! aDocument -> GetShell ( ) ) { return NS_OK ; } nsPIDOMWindow * internalWin = aDocument -> GetWindow ( ) ; nsCOMPtr < nsIDOMElement > frameElem ; if ( internalWin ) { internalWin -> GetFrameElement ( getter_AddRefs ( frameElem ) ) ; } if ( frameElem ) { nsCOMPtr < nsIDOMCSSStyleDeclaration > computedStyle ; nsCOMPtr < nsIDOMDocument > frameOwnerDoc ; frameElem -> GetOwnerDocument ( getter_AddRefs ( frameOwnerDoc ) ) ; if ( frameOwnerDoc ) { nsCOMPtr < nsIDOMWindow > window ; frameOwnerDoc -> GetDefaultView ( getter_AddRefs ( window ) ) ; if ( window ) { window -> GetComputedStyle ( frameElem , EmptyString ( ) , getter_AddRefs ( computedStyle ) ) ; } } if ( computedStyle ) { nsAutoString visibility ; computedStyle -> GetPropertyValue ( NS_LITERAL_STRING ( "visibility" ) , visibility ) ; if ( ! visibility . EqualsLiteral ( "visible" ) ) { return NS_OK ; } } } if ( ! Preferences :: GetBool ( "layout.xml.prettyprint" , true ) ) { return NS_OK ; } * aDidPrettyPrint = true ; nsresult rv = NS_OK ; nsCOMPtr < nsIURI > xslUri ; rv = NS_NewURI ( getter_AddRefs ( xslUri ) , NS_LITERAL_CSTRING ( "chrome://global/content/xml/XMLPrettyPrint.xsl" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIDOMDocument > xslDocument ; rv = nsSyncLoadService :: LoadDocument ( xslUri , nullptr , nullptr , true , getter_AddRefs ( xslDocument ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIXSLTProcessor > transformer = do_CreateInstance ( "@mozilla.org/document-transformer;1?type=xslt" , & rv ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = transformer -> ImportStylesheet ( xslDocument ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIDOMDocumentFragment > resultFragment ; nsCOMPtr < nsIDOMDocument > sourceDocument = do_QueryInterface ( aDocument ) ; rv = transformer -> TransformToFragment ( sourceDocument , sourceDocument , getter_AddRefs ( resultFragment ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsXBLService * xblService = nsXBLService :: GetInstance ( ) ; NS_ENSURE_TRUE ( xblService , NS_ERROR_NOT_AVAILABLE ) ; nsCOMPtr < nsIURI > bindingUri ; rv = NS_NewURI ( getter_AddRefs ( bindingUri ) , NS_LITERAL_STRING ( "chrome://global/content/xml/XMLPrettyPrint.xml#prettyprint" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIContent > rootCont = aDocument -> GetRootElement ( ) ; NS_ENSURE_TRUE ( rootCont , NS_ERROR_UNEXPECTED ) ; nsCOMPtr < nsIPrincipal > sysPrincipal ; nsContentUtils :: GetSecurityManager ( ) -> GetSystemPrincipal ( getter_AddRefs ( sysPrincipal ) ) ; nsRefPtr < nsXBLBinding > unused ; bool ignored ; rv = xblService -> LoadBindings ( rootCont , bindingUri , sysPrincipal , getter_AddRefs ( unused ) , & ignored ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIObserver > binding ; aDocument -> BindingManager ( ) -> GetBindingImplementation ( rootCont , NS_GET_IID ( nsIObserver ) , ( void * * ) getter_AddRefs ( binding ) ) ; NS_ASSERTION ( binding , "Prettyprint binding doesn't implement nsIObserver" ) ; NS_ENSURE_TRUE ( binding , NS_ERROR_UNEXPECTED ) ; rv = binding -> Observe ( resultFragment , "prettyprint-dom-created" , EmptyString ( ) . get ( ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; aDocument -> AddObserver ( this ) ; mDocument = aDocument ; NS_ADDREF_THIS ( ) ; return NS_OK ; }
ast2obj_arg ( void * _o ) { arg_ty o = ( arg_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } result = PyType_GenericNew ( arg_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
void emitDisjunction ( PatternDisjunction * disjunction , unsigned inputCountAlreadyChecked = 0 , unsigned parenthesesInputCountAlreadyChecked = 0 ) { for ( unsigned alt = 0 ; alt < disjunction -> m_alternatives . size ( ) ; ++ alt ) { unsigned currentCountAlreadyChecked = inputCountAlreadyChecked ; PatternAlternative * alternative = disjunction -> m_alternatives [ alt ] ; if ( alt ) { if ( disjunction == m_pattern . m_body ) alternativeBodyDisjunction ( alternative -> onceThrough ( ) ) ; else alternativeDisjunction ( ) ; } unsigned minimumSize = alternative -> m_minimumSize ; int countToCheck = minimumSize - parenthesesInputCountAlreadyChecked ; ASSERT ( countToCheck >= 0 ) ; if ( countToCheck ) { checkInput ( countToCheck ) ; currentCountAlreadyChecked += countToCheck ; } for ( unsigned i = 0 ; i < alternative -> m_terms . size ( ) ; ++ i ) { PatternTerm & term = alternative -> m_terms [ i ] ; switch ( term . type ) { case PatternTerm :: TypeAssertionBOL : assertionBOL ( term . inputPosition - currentCountAlreadyChecked ) ; break ; case PatternTerm :: TypeAssertionEOL : assertionEOL ( term . inputPosition - currentCountAlreadyChecked ) ; break ; case PatternTerm :: TypeAssertionWordBoundary : assertionWordBoundary ( term . invert ( ) , term . inputPosition - currentCountAlreadyChecked ) ; break ; case PatternTerm :: TypePatternCharacter : atomPatternCharacter ( term . patternCharacter , term . inputPosition - currentCountAlreadyChecked , term . frameLocation , term . quantityCount , term . quantityType ) ; break ; case PatternTerm :: TypeCharacterClass : atomCharacterClass ( term . characterClass , term . invert ( ) , term . inputPosition - currentCountAlreadyChecked , term . frameLocation , term . quantityCount , term . quantityType ) ; break ; case PatternTerm :: TypeBackReference : atomBackReference ( term . backReferenceSubpatternId , term . inputPosition - currentCountAlreadyChecked , term . frameLocation , term . quantityCount , term . quantityType ) ; break ; case PatternTerm :: TypeForwardReference : break ; case PatternTerm :: TypeParenthesesSubpattern : { unsigned disjunctionAlreadyCheckedCount = 0 ; if ( term . quantityCount == 1 && ! term . parentheses . isCopy ) { unsigned alternativeFrameLocation = term . frameLocation ; if ( term . quantityType == QuantifierFixedCount ) disjunctionAlreadyCheckedCount = term . parentheses . disjunction -> m_minimumSize ; else alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParenthesesOnce ; unsigned delegateEndInputOffset = term . inputPosition - currentCountAlreadyChecked ; atomParenthesesOnceBegin ( term . parentheses . subpatternId , term . capture ( ) , delegateEndInputOffset - disjunctionAlreadyCheckedCount , term . frameLocation , alternativeFrameLocation ) ; emitDisjunction ( term . parentheses . disjunction , currentCountAlreadyChecked , disjunctionAlreadyCheckedCount ) ; atomParenthesesOnceEnd ( delegateEndInputOffset , term . frameLocation , term . quantityCount , term . quantityType ) ; } else if ( term . parentheses . isTerminal ) { unsigned delegateEndInputOffset = term . inputPosition - currentCountAlreadyChecked ; atomParenthesesTerminalBegin ( term . parentheses . subpatternId , term . capture ( ) , delegateEndInputOffset - disjunctionAlreadyCheckedCount , term . frameLocation , term . frameLocation + YarrStackSpaceForBackTrackInfoParenthesesOnce ) ; emitDisjunction ( term . parentheses . disjunction , currentCountAlreadyChecked , disjunctionAlreadyCheckedCount ) ; atomParenthesesTerminalEnd ( delegateEndInputOffset , term . frameLocation , term . quantityCount , term . quantityType ) ; } else { unsigned delegateEndInputOffset = term . inputPosition - currentCountAlreadyChecked ; atomParenthesesSubpatternBegin ( term . parentheses . subpatternId , term . capture ( ) , delegateEndInputOffset - disjunctionAlreadyCheckedCount , term . frameLocation , 0 ) ; emitDisjunction ( term . parentheses . disjunction , currentCountAlreadyChecked , 0 ) ; atomParenthesesSubpatternEnd ( term . parentheses . lastSubpatternId , delegateEndInputOffset , term . frameLocation , term . quantityCount , term . quantityType , term . parentheses . disjunction -> m_callFrameSize ) ; } break ; } case PatternTerm :: TypeParentheticalAssertion : { unsigned alternativeFrameLocation = term . frameLocation + YarrStackSpaceForBackTrackInfoParentheticalAssertion ; ASSERT ( currentCountAlreadyChecked >= static_cast < unsigned > ( term . inputPosition ) ) ; int positiveInputOffset = currentCountAlreadyChecked - term . inputPosition ; int uncheckAmount = positiveInputOffset - term . parentheses . disjunction -> m_minimumSize ; if ( uncheckAmount > 0 ) { uncheckInput ( uncheckAmount ) ; currentCountAlreadyChecked -= uncheckAmount ; } else uncheckAmount = 0 ; atomParentheticalAssertionBegin ( term . parentheses . subpatternId , term . invert ( ) , term . frameLocation , alternativeFrameLocation ) ; emitDisjunction ( term . parentheses . disjunction , currentCountAlreadyChecked , positiveInputOffset - uncheckAmount ) ; atomParentheticalAssertionEnd ( 0 , term . frameLocation , term . quantityCount , term . quantityType ) ; if ( uncheckAmount ) { checkInput ( uncheckAmount ) ; currentCountAlreadyChecked += uncheckAmount ; } break ; } } } } }
NS_IMPL_ISUPPORTS ( ServiceWorkerInterceptController , nsINetworkInterceptController ) NS_IMETHODIMP ServiceWorkerInterceptController :: ShouldPrepareForIntercept ( nsIURI * aURI , nsIChannel * aChannel , bool * aShouldIntercept ) { * aShouldIntercept = false ; nsCOMPtr < nsILoadInfo > loadInfo = aChannel -> LoadInfo ( ) ; RefPtr < ServiceWorkerManager > swm = ServiceWorkerManager :: GetInstance ( ) ; if ( ! nsContentUtils :: IsNonSubresourceRequest ( aChannel ) ) { const Maybe < ServiceWorkerDescriptor > & controller = loadInfo -> GetController ( ) ; if ( ! ServiceWorkerParentInterceptEnabled ( ) ) { * aShouldIntercept = controller . isSome ( ) ; return NS_OK ; } if ( controller . isSome ( ) ) { * aShouldIntercept = controller . ref ( ) . HandlesFetch ( ) ; if ( ! * aShouldIntercept && swm ) { nsCOMPtr < nsIPrincipal > principal = controller . ref ( ) . GetPrincipal ( ) . unwrap ( ) ; RefPtr < ServiceWorkerRegistrationInfo > registration = swm -> GetRegistration ( principal , controller . ref ( ) . Scope ( ) ) ; if ( NS_WARN_IF ( ! registration ) ) { return NS_OK ; } registration -> MaybeScheduleTimeCheckAndUpdate ( ) ; } } else { * aShouldIntercept = false ; } return NS_OK ; } nsCOMPtr < nsIPrincipal > principal = BasePrincipal :: CreateContentPrincipal ( aURI , loadInfo -> GetOriginAttributes ( ) ) ; if ( ! swm || ! swm -> IsAvailable ( principal , aURI , aChannel ) ) { return NS_OK ; } if ( StorageAllowedForChannel ( aChannel ) != StorageAccess :: eAllow ) { return NS_OK ; } * aShouldIntercept = true ; return NS_OK ; }
cups_read ( cups_file_t * fp , char * buf , size_t bytes ) { ssize_t total ; DEBUG_printf ( ( "7cups_read(fp=%p, buf=%p, bytes=" CUPS_LLFMT ")" , ( void * ) fp , ( void * ) buf , CUPS_LLCAST bytes ) ) ; for ( ; ; ) { #ifdef WIN32 if ( fp -> mode == 's' ) total = ( ssize_t ) recv ( fp -> fd , buf , ( unsigned ) bytes , 0 ) ; else total = ( ssize_t ) read ( fp -> fd , buf , ( unsigned ) bytes ) ; #else if ( fp -> mode == 's' ) total = recv ( fp -> fd , buf , bytes , 0 ) ; else total = read ( fp -> fd , buf , bytes ) ; #endif /* WIN32 */ DEBUG_printf ( ( "9cups_read: total=" CUPS_LLFMT , CUPS_LLCAST total ) ) ; if ( total >= 0 ) break ; if ( errno == EAGAIN || errno == EINTR ) continue ; else return ( - 1 ) ; } return ( total ) ; }
GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ; char * tmp_str ; GF_Err e ; ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ; tmp_strsize = ( u32 ) ptr -> size ; tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ; } } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> quality_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ; } } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> drm_data = gf_strdup ( tmp_str ) ; } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> meta_data = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> segment_run_table_count ; i ++ ) { GF_AdobeSegmentRunTableBox * asrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & asrt , bs ) ; if ( e ) { if ( asrt ) gf_isom_box_del ( ( GF_Box * ) asrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> segment_run_table_entries , asrt ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> fragment_run_table_count ; i ++ ) { GF_AdobeFragmentRunTableBox * afrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & afrt , bs ) ; if ( e ) { if ( afrt ) gf_isom_box_del ( ( GF_Box * ) afrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; } gf_free ( tmp_str ) ; return GF_OK ; }
png_handle_bKGD ( png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) { unsigned int truelen ; png_byte buf [ 6 ] ; png_color_16 background ; png_debug ( 1 , "in png_handle_bKGD" ) ; if ( ! ( png_ptr -> mode & PNG_HAVE_IHDR ) ) png_chunk_error ( png_ptr , "missing IHDR" ) ; else if ( ( png_ptr -> mode & PNG_HAVE_IDAT ) || ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE && ! ( png_ptr -> mode & PNG_HAVE_PLTE ) ) ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "out of place" ) ; return ; } else if ( info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_bKGD ) ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "duplicate" ) ; return ; } if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE ) truelen = 1 ; else if ( png_ptr -> color_type & PNG_COLOR_MASK_COLOR ) truelen = 6 ; else truelen = 2 ; if ( length != truelen ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "invalid" ) ; return ; } png_crc_read ( png_ptr , buf , truelen ) ; if ( png_crc_finish ( png_ptr , 0 ) ) return ; if ( png_ptr -> color_type == PNG_COLOR_TYPE_PALETTE ) { background . index = buf [ 0 ] ; if ( info_ptr && info_ptr -> num_palette ) { if ( buf [ 0 ] >= info_ptr -> num_palette ) { png_chunk_benign_error ( png_ptr , "invalid index" ) ; return ; } background . red = ( png_uint_16 ) png_ptr -> palette [ buf [ 0 ] ] . red ; background . green = ( png_uint_16 ) png_ptr -> palette [ buf [ 0 ] ] . green ; background . blue = ( png_uint_16 ) png_ptr -> palette [ buf [ 0 ] ] . blue ; } else background . red = background . green = background . blue = 0 ; background . gray = 0 ; } else if ( ! ( png_ptr -> color_type & PNG_COLOR_MASK_COLOR ) ) { background . index = 0 ; background . red = background . green = background . blue = background . gray = png_get_uint_16 ( buf ) ; } else { background . index = 0 ; background . red = png_get_uint_16 ( buf ) ; background . green = png_get_uint_16 ( buf + 2 ) ; background . blue = png_get_uint_16 ( buf + 4 ) ; background . gray = 0 ; } png_set_bKGD ( png_ptr , info_ptr , & background ) ; }
static int rename_in_ns ( int pid , char * oldname , char * * newnamep ) { int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ; bool grab_newname = false ; ofd = lxc_preserve_ns ( getpid ( ) , "net" ) ; if ( ofd < 0 ) { fprintf ( stderr , "Failed opening network namespace path for '%d'." , getpid ( ) ) ; return - 1 ; } fd = lxc_preserve_ns ( pid , "net" ) ; if ( fd < 0 ) { fprintf ( stderr , "Failed opening network namespace path for '%d'." , pid ) ; return - 1 ; } if ( setns ( fd , 0 ) < 0 ) { fprintf ( stderr , "setns to container network namespace\n" ) ; goto out_err ; } close ( fd ) ; fd = - 1 ; if ( ! * newnamep ) { grab_newname = true ; * newnamep = VETH_DEF_NAME ; if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) { fprintf ( stderr , "failed to get netdev index\n" ) ; goto out_err ; } } if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) { fprintf ( stderr , "Error %d renaming netdev %s to %s in container\n" , ret , oldname , * newnamep ) ; goto out_err ; } if ( grab_newname ) { char ifname [ IFNAMSIZ ] , * namep = ifname ; if ( ! if_indextoname ( ifindex , namep ) ) { fprintf ( stderr , "Failed to get new netdev name\n" ) ; goto out_err ; } * newnamep = strdup ( namep ) ; if ( ! * newnamep ) goto out_err ; } if ( setns ( ofd , 0 ) < 0 ) { fprintf ( stderr , "Error returning to original netns\n" ) ; close ( ofd ) ; return - 1 ; } close ( ofd ) ; return 0 ; out_err : if ( ofd >= 0 ) close ( ofd ) ; if ( setns ( ofd , 0 ) < 0 ) fprintf ( stderr , "Error returning to original network namespace\n" ) ; if ( fd >= 0 ) close ( fd ) ; return - 1 ; }
void SFS_ArrayDeref ( ScriptParser * parser ) { if ( parser -> codec -> LastError ) return ; SFS_Expression ( parser ) ; SFS_AddString ( parser , "[" ) ; SFS_CompoundExpression ( parser ) ; SFS_AddString ( parser , "]" ) ; }
bool wasm :: EnsureBuiltinThunksInitialized ( ) { LockGuard < Mutex > guard ( initBuiltinThunks ) ; if ( builtinThunks ) { return true ; } auto thunks = MakeUnique < BuiltinThunks > ( ) ; if ( ! thunks ) { return false ; } LifoAlloc lifo ( BUILTIN_THUNK_LIFO_SIZE ) ; TempAllocator tempAlloc ( & lifo ) ; WasmMacroAssembler masm ( tempAlloc ) ; AutoCreatedBy acb ( masm , "wasm::EnsureBuiltinThunksInitialized" ) ; for ( auto sym : MakeEnumeratedRange ( SymbolicAddress :: Limit ) ) { if ( ! NeedsBuiltinThunk ( sym ) ) { thunks -> symbolicAddressToCodeRange [ sym ] = UINT32_MAX ; continue ; } uint32_t codeRangeIndex = thunks -> codeRanges . length ( ) ; thunks -> symbolicAddressToCodeRange [ sym ] = codeRangeIndex ; ABIFunctionType abiType ; void * funcPtr = AddressOf ( sym , & abiType ) ; ExitReason exitReason ( sym ) ; CallableOffsets offsets ; if ( ! GenerateBuiltinThunk ( masm , abiType , exitReason , funcPtr , & offsets ) ) { return false ; } if ( ! thunks -> codeRanges . emplaceBack ( CodeRange :: BuiltinThunk , offsets ) ) { return false ; } } TypedNativeToFuncPtrMap typedNatives ; if ( ! PopulateTypedNatives ( & typedNatives ) ) { return false ; } for ( TypedNativeToFuncPtrMap :: Range r = typedNatives . all ( ) ; ! r . empty ( ) ; r . popFront ( ) ) { TypedNative typedNative = r . front ( ) . key ( ) ; uint32_t codeRangeIndex = thunks -> codeRanges . length ( ) ; if ( ! thunks -> typedNativeToCodeRange . putNew ( typedNative , codeRangeIndex ) ) { return false ; } ABIFunctionType abiType = typedNative . abiType ; void * funcPtr = r . front ( ) . value ( ) ; ExitReason exitReason = ExitReason :: Fixed :: BuiltinNative ; CallableOffsets offsets ; if ( ! GenerateBuiltinThunk ( masm , abiType , exitReason , funcPtr , & offsets ) ) { return false ; } if ( ! thunks -> codeRanges . emplaceBack ( CodeRange :: BuiltinThunk , offsets ) ) { return false ; } } #ifdef DEBUG JitContext jitContext ; bool oldFlag = jitContext . setIsCompilingWasm ( false ) ; #endif Offsets provisionalLazyJitEntryOffsets ; if ( ! GenerateProvisionalLazyJitEntryStub ( masm , & provisionalLazyJitEntryOffsets ) ) { return false ; } thunks -> provisionalLazyJitEntryOffset = provisionalLazyJitEntryOffsets . begin ; #ifdef DEBUG jitContext . setIsCompilingWasm ( oldFlag ) ; #endif masm . finish ( ) ; if ( masm . oom ( ) ) { return false ; } size_t allocSize = AlignBytes ( masm . bytesNeeded ( ) , ExecutableCodePageSize ) ; thunks -> codeSize = allocSize ; thunks -> codeBase = ( uint8_t * ) AllocateExecutableMemory ( allocSize , ProtectionSetting :: Writable , MemCheckKind :: MakeUndefined ) ; if ( ! thunks -> codeBase ) { return false ; } masm . executableCopy ( thunks -> codeBase ) ; memset ( thunks -> codeBase + masm . bytesNeeded ( ) , 0 , allocSize - masm . bytesNeeded ( ) ) ; masm . processCodeLabels ( thunks -> codeBase ) ; PatchDebugSymbolicAccesses ( thunks -> codeBase , masm ) ; MOZ_ASSERT ( masm . callSites ( ) . empty ( ) ) ; MOZ_ASSERT ( masm . callSiteTargets ( ) . empty ( ) ) ; MOZ_ASSERT ( masm . trapSites ( ) . empty ( ) ) ; MOZ_ASSERT ( masm . tryNotes ( ) . empty ( ) ) ; if ( ! ExecutableAllocator :: makeExecutableAndFlushICache ( FlushICacheSpec :: LocalThreadOnly , thunks -> codeBase , thunks -> codeSize ) ) { return false ; } builtinThunks = thunks . release ( ) ; return true ; }
% o image_info : the image info . % % o exception : return any errors or warnings in this structure . % * / static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MagickPathExtent ] , text [ MagickPathExtent ] ; Image * image ; long x_offset , y_offset ; PixelInfo pixel ; MagickBooleanType status ; QuantumAny range ; register ssize_t i , x ; register Quantum * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\0' ; count = ( ssize_t ) sscanf ( text + 32 , "%lu,%lu,%lu,%s" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; image -> columns = width ; image -> rows = height ; for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> alpha_trait = UndefinedPixelTrait ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\0' ; image -> alpha_trait = BlendPixelTrait ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , ( ColorspaceType ) type , exception ) ; GetPixelInfo ( image , & pixel ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double alpha , black , blue , green , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; black = 0.0 ; alpha = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , "%ld,%ld: (%lf%*[%,]%lf%*[%,]" , & x_offset , & y_offset , & red , & alpha ) ; green = red ; blue = red ; break ; } count = ( ssize_t ) sscanf ( text , "%ld,%ld: (%lf%*[%,]" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , "%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]" , & x_offset , & y_offset , & red , & green , & blue , & black , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , "%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]" , & x_offset , & y_offset , & red , & green , & blue , & black ) ; break ; } default : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , "%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]" , & x_offset , & y_offset , & red , & green , & blue , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , "%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; black *= 0.01 * range ; alpha *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . black = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( black + 0.5 ) , range ) ; pixel . alpha = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( alpha + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) continue ; SetPixelViaPixelInfo ( image , & pixel , q ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ;
TransactionDatabaseOperationBase :: SendPreprocessInfoOrResults ( bool aSendPreprocessInfo ) { AssertIsOnOwningThread ( ) ; MOZ_ASSERT ( mInternalState == InternalState :: SendingPreprocess || mInternalState == InternalState :: SendingResults ) ; MOZ_ASSERT ( mTransaction ) ; RefPtr < TransactionDatabaseOperationBase > kungFuDeathGrip ; if ( NS_WARN_IF ( IsActorDestroyed ( ) ) ) { if ( NS_SUCCEEDED ( mResultCode ) ) { IDB_REPORT_INTERNAL_ERR ( ) ; mResultCode = NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ; } } else { if ( ! aSendPreprocessInfo ) { kungFuDeathGrip = this ; } if ( mTransaction -> IsInvalidated ( ) || mTransaction -> IsAborted ( ) ) { mResultCode = NS_ERROR_DOM_INDEXEDDB_ABORT_ERR ; } else if ( NS_SUCCEEDED ( mResultCode ) ) { if ( aSendPreprocessInfo ) { mResultCode = SendPreprocessInfo ( ) ; } else { mResultCode = SendSuccessResult ( ) ; } } if ( NS_FAILED ( mResultCode ) ) { if ( ! SendFailureResult ( mResultCode ) ) { mTransaction -> Abort ( mResultCode , false ) ; } } } if ( aSendPreprocessInfo && NS_SUCCEEDED ( mResultCode ) ) { mInternalState = InternalState :: WaitingForContinue ; } else { if ( mLoggingSerialNumber ) { mTransaction -> NoteFinishedRequest ( ) ; } Cleanup ( ) ; mInternalState = InternalState :: Completed ; } }
Node * AsyncGeneratorBuiltinsAssembler :: TakeFirstAsyncGeneratorRequestFromQueue ( Node * generator ) { CSA_ASSERT ( this , TaggedIsAsyncGenerator ( generator ) ) ; Node * request = LoadObjectField ( generator , JSAsyncGeneratorObject :: kQueueOffset ) ; CSA_ASSERT ( this , IsNotUndefined ( request ) ) ; Node * next = LoadObjectField ( request , AsyncGeneratorRequest :: kNextOffset ) ; StoreObjectField ( generator , JSAsyncGeneratorObject :: kQueueOffset , next ) ; return request ; }
CallbackObject :: CallSetup :: ~ CallSetup ( ) { mAc . reset ( ) ; if ( mCx ) { bool needToDealWithException = JS_IsExceptionPending ( mCx ) ; if ( ( mCompartment && mExceptionHandling == eRethrowContentExceptions ) || mExceptionHandling == eRethrowExceptions ) { JS :: ContextOptionsRef ( mCx ) = mSavedJSContextOptions ; mErrorResult . MightThrowJSException ( ) ; if ( needToDealWithException ) { JS :: Rooted < JS :: Value > exn ( mCx ) ; if ( JS_GetPendingException ( mCx , & exn ) && ShouldRethrowException ( exn ) ) { mErrorResult . ThrowJSException ( mCx , exn ) ; JS_ClearPendingException ( mCx ) ; needToDealWithException = false ; } } } if ( needToDealWithException ) { JS :: Rooted < JSObject * > oldGlobal ( mCx , JS :: CurrentGlobalOrNull ( mCx ) ) ; MOZ_ASSERT ( oldGlobal , "How can we not have a global here??" ) ; bool saved = JS_SaveFrameChain ( mCx ) ; { JSAutoCompartment ac ( mCx , oldGlobal ) ; MOZ_ASSERT ( ! JS :: DescribeScriptedCaller ( mCx ) , "Our comment above about JS_SaveFrameChain having been " "called is a lie?" ) ; JS_ReportPendingException ( mCx ) ; } if ( saved ) { JS_RestoreFrameChain ( mCx ) ; } } } mAutoIncumbentScript . reset ( ) ; mAutoEntryScript . reset ( ) ; }
Node * RegExpBuiltinsAssembler :: SlowFlagGetter ( Node * const context , Node * const regexp , JSRegExp :: Flag flag ) { Factory * factory = isolate ( ) -> factory ( ) ; Label out ( this ) ; VARIABLE ( var_result , MachineRepresentation :: kWord32 ) ; Handle < String > name ; switch ( flag ) { case JSRegExp :: kGlobal : name = factory -> global_string ( ) ; break ; case JSRegExp :: kIgnoreCase : name = factory -> ignoreCase_string ( ) ; break ; case JSRegExp :: kMultiline : name = factory -> multiline_string ( ) ; break ; case JSRegExp :: kDotAll : UNREACHABLE ( ) ; break ; case JSRegExp :: kSticky : name = factory -> sticky_string ( ) ; break ; case JSRegExp :: kUnicode : name = factory -> unicode_string ( ) ; break ; default : UNREACHABLE ( ) ; } Node * const value = GetProperty ( context , regexp , name ) ; Label if_true ( this ) , if_false ( this ) ; BranchIfToBooleanIsTrue ( value , & if_true , & if_false ) ; BIND ( & if_true ) ; { var_result . Bind ( Int32Constant ( 1 ) ) ; Goto ( & out ) ; } BIND ( & if_false ) ; { var_result . Bind ( Int32Constant ( 0 ) ) ; Goto ( & out ) ; } BIND ( & out ) ; return var_result . value ( ) ; }
sctp_iterator_worker ( void ) { struct sctp_iterator * it , * nit ; sctp_it_ctl . iterator_running = 1 ; TAILQ_FOREACH_SAFE ( it , & sctp_it_ctl . iteratorhead , sctp_nxt_itr , nit ) { sctp_it_ctl . cur_it = it ; TAILQ_REMOVE ( & sctp_it_ctl . iteratorhead , it , sctp_nxt_itr ) ; SCTP_IPI_ITERATOR_WQ_UNLOCK ( ) ; #if defined(__FreeBSD__) && __FreeBSD_version >= 801000 CURVNET_SET ( it -> vn ) ; #endif sctp_iterator_work ( it ) ; sctp_it_ctl . cur_it = NULL ; #if defined(__FreeBSD__) && __FreeBSD_version >= 801000 CURVNET_RESTORE ( ) ; #endif SCTP_IPI_ITERATOR_WQ_LOCK ( ) ; #if !defined(__FreeBSD__) if ( sctp_it_ctl . iterator_flags & SCTP_ITERATOR_MUST_EXIT ) { break ; } #endif } sctp_it_ctl . iterator_running = 0 ; return ; }
dev_config ( struct file * fd , const char __user * buf , size_t len , loff_t * ptr ) { struct dev_data * dev = fd -> private_data ; ssize_t value , length = len ; unsigned total ; u32 tag ; char * kbuf ; spin_lock_irq ( & dev -> lock ) ; if ( dev -> state > STATE_DEV_OPENED ) { value = ep0_write ( fd , buf , len , ptr ) ; spin_unlock_irq ( & dev -> lock ) ; return value ; } spin_unlock_irq ( & dev -> lock ) ; if ( ( len < ( USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4 ) ) || ( len > PAGE_SIZE * 4 ) ) return - EINVAL ; if ( copy_from_user ( & tag , buf , 4 ) ) return - EFAULT ; if ( tag != 0 ) return - EINVAL ; buf += 4 ; length -= 4 ; kbuf = memdup_user ( buf , length ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; spin_lock_irq ( & dev -> lock ) ; value = - EINVAL ; if ( dev -> buf ) { kfree ( kbuf ) ; goto fail ; } dev -> buf = kbuf ; dev -> config = ( void * ) kbuf ; total = le16_to_cpu ( dev -> config -> wTotalLength ) ; if ( ! is_valid_config ( dev -> config , total ) || total > length - USB_DT_DEVICE_SIZE ) goto fail ; kbuf += total ; length -= total ; if ( kbuf [ 1 ] == USB_DT_CONFIG ) { dev -> hs_config = ( void * ) kbuf ; total = le16_to_cpu ( dev -> hs_config -> wTotalLength ) ; if ( ! is_valid_config ( dev -> hs_config , total ) || total > length - USB_DT_DEVICE_SIZE ) goto fail ; kbuf += total ; length -= total ; } else { dev -> hs_config = NULL ; } if ( length != USB_DT_DEVICE_SIZE ) goto fail ; dev -> dev = ( void * ) kbuf ; if ( dev -> dev -> bLength != USB_DT_DEVICE_SIZE || dev -> dev -> bDescriptorType != USB_DT_DEVICE || dev -> dev -> bNumConfigurations != 1 ) goto fail ; dev -> dev -> bcdUSB = cpu_to_le16 ( 0x0200 ) ; spin_unlock_irq ( & dev -> lock ) ; if ( dev -> hs_config ) gadgetfs_driver . max_speed = USB_SPEED_HIGH ; else gadgetfs_driver . max_speed = USB_SPEED_FULL ; value = usb_gadget_probe_driver ( & gadgetfs_driver ) ; if ( value != 0 ) { spin_lock_irq ( & dev -> lock ) ; goto fail ; } else { value = len ; dev -> gadget_registered = true ; } return value ; fail : dev -> config = NULL ; dev -> hs_config = NULL ; dev -> dev = NULL ; spin_unlock_irq ( & dev -> lock ) ; pr_debug ( "%s: %s fail %zd, %p\n" , shortname , __func__ , value , dev ) ; kfree ( dev -> buf ) ; dev -> buf = NULL ; return value ; }
OMXNodeInstance :: OMXNodeInstance ( OMX * owner , const sp < IOMXObserver > & observer , const char * name ) : mOwner ( owner ) , mNodeID ( 0 ) , mHandle ( NULL ) , mObserver ( observer ) , mDying ( false ) , mBufferIDCount ( 0 ) { mName = ADebug :: GetDebugName ( name ) ; DEBUG = ADebug :: GetDebugLevelFromProperty ( name , "debug.stagefright.omx-debug" ) ; ALOGV ( "debug level for %s is %d" , name , DEBUG ) ; DEBUG_BUMP = DEBUG ; mNumPortBuffers [ 0 ] = 0 ; mNumPortBuffers [ 1 ] = 0 ; mDebugLevelBumpPendingBuffers [ 0 ] = 0 ; mDebugLevelBumpPendingBuffers [ 1 ] = 0 ; mMetadataType [ 0 ] = kMetadataBufferTypeInvalid ; mMetadataType [ 1 ] = kMetadataBufferTypeInvalid ; mSecureBufferType [ 0 ] = kSecureBufferTypeUnknown ; mSecureBufferType [ 1 ] = kSecureBufferTypeUnknown ; mIsSecure = AString ( name ) . endsWith ( ".secure" ) ; }
long Chapters :: Parse ( ) { IMkvReader * const pReader = m_pSegment -> m_pReader ; long long pos = m_start ; const long long stop = pos + m_size ; while ( pos < stop ) { long long id , size ; long status = ParseElementHeader ( pReader , pos , stop , id , size ) ; if ( status < 0 ) return status ; if ( size == 0 ) continue ; if ( id == 0x05B9 ) { status = ParseEdition ( pos , size ) ; if ( status < 0 ) return status ; } pos += size ; assert ( pos <= stop ) ; } assert ( pos == stop ) ; return 0 ; }
nsHttpChannel :: OpenCacheInputStream ( nsICacheEntry * cacheEntry , bool startBuffering , bool checkingAppCacheEntry ) { nsresult rv ; bool isHttps = false ; rv = mURI -> SchemeIs ( "https" , & isHttps ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( isHttps ) { rv = cacheEntry -> GetSecurityInfo ( getter_AddRefs ( mCachedSecurityInfo ) ) ; if ( NS_FAILED ( rv ) ) { LOG ( ( "failed to parse security-info [channel=%p, entry=%p]" , this , cacheEntry ) ) ; NS_WARNING ( "failed to parse security-info" ) ; cacheEntry -> AsyncDoom ( nullptr ) ; return rv ; } bool mustHaveSecurityInfo = ! mLoadedFromApplicationCache && ! checkingAppCacheEntry ; MOZ_ASSERT ( mCachedSecurityInfo || ! mustHaveSecurityInfo ) ; if ( ! mCachedSecurityInfo && mustHaveSecurityInfo ) { LOG ( ( "mCacheEntry->GetSecurityInfo returned success but did not " "return the security info [channel=%p, entry=%p]" , this , cacheEntry ) ) ; cacheEntry -> AsyncDoom ( nullptr ) ; return NS_ERROR_UNEXPECTED ; } } rv = NS_OK ; if ( WillRedirect ( mCachedResponseHead ) ) { LOG ( ( "Will skip read of cached redirect entity\n" ) ) ; return NS_OK ; } if ( ( mLoadFlags & nsICachingChannel :: LOAD_ONLY_IF_MODIFIED ) && ! mCachedContentIsPartial ) { if ( ! mApplicationCacheForWrite ) { LOG ( ( "Will skip read from cache based on LOAD_ONLY_IF_MODIFIED " "load flag\n" ) ) ; return NS_OK ; } LOG ( ( "May skip read from cache based on LOAD_ONLY_IF_MODIFIED " "load flag\n" ) ) ; } nsCOMPtr < nsIInputStream > stream ; if ( ! mPreferredCachedAltDataType . IsEmpty ( ) ) { rv = cacheEntry -> OpenAlternativeInputStream ( mPreferredCachedAltDataType , getter_AddRefs ( stream ) ) ; if ( NS_SUCCEEDED ( rv ) ) { mAvailableCachedAltDataType = mPreferredCachedAltDataType ; int64_t altDataSize ; if ( NS_SUCCEEDED ( cacheEntry -> GetAltDataSize ( & altDataSize ) ) ) { mAltDataLength = altDataSize ; } } } if ( ! stream ) { rv = cacheEntry -> OpenInputStream ( 0 , getter_AddRefs ( stream ) ) ; } if ( NS_FAILED ( rv ) ) { LOG ( ( "Failed to open cache input stream [channel=%p, " "mCacheEntry=%p]" , this , cacheEntry ) ) ; return rv ; } if ( startBuffering ) { bool nonBlocking ; rv = stream -> IsNonBlocking ( & nonBlocking ) ; if ( NS_SUCCEEDED ( rv ) && nonBlocking ) startBuffering = false ; } if ( ! startBuffering ) { LOG ( ( "Opened cache input stream without buffering [channel=%p, " "mCacheEntry=%p, stream=%p]" , this , cacheEntry , stream . get ( ) ) ) ; mCacheInputStream . takeOver ( stream ) ; return rv ; } nsCOMPtr < nsITransport > transport ; nsCOMPtr < nsIInputStream > wrapper ; nsCOMPtr < nsIStreamTransportService > sts ( services :: GetStreamTransportService ( ) ) ; rv = sts ? NS_OK : NS_ERROR_NOT_AVAILABLE ; if ( NS_SUCCEEDED ( rv ) ) { rv = sts -> CreateInputTransport ( stream , true , getter_AddRefs ( transport ) ) ; } if ( NS_SUCCEEDED ( rv ) ) { rv = transport -> OpenInputStream ( 0 , 0 , 0 , getter_AddRefs ( wrapper ) ) ; } if ( NS_SUCCEEDED ( rv ) ) { LOG ( ( "Opened cache input stream [channel=%p, wrapper=%p, " "transport=%p, stream=%p]" , this , wrapper . get ( ) , transport . get ( ) , stream . get ( ) ) ) ; } else { LOG ( ( "Failed to open cache input stream [channel=%p, " "wrapper=%p, transport=%p, stream=%p]" , this , wrapper . get ( ) , transport . get ( ) , stream . get ( ) ) ) ; stream -> Close ( ) ; return rv ; } mCacheInputStream . takeOver ( wrapper ) ; return NS_OK ; }
- aOn ] ( nsresult aResult ) { + [ self , this , & state , aOn ] ( nsresult aResult ) { if ( state . mStopped ) { return DeviceOperationPromise :: CreateAndResolve ( aResult , __func__ ) ; } - LOG ( "SourceListener %p turning %s %s input device for track %p %s" , - this , aOn ? "on" : "off" , - & state == mAudioDeviceState . get ( ) ? "audio" : "video" , - track . get ( ) , NS_SUCCEEDED ( aResult ) ? "succeeded" : "failed" ) ; + LOG ( "DeviceListener %p turning %s %s input device %s" , this , + aOn ? "on" : "off" , + nsCString ( + dom :: MediaDeviceKindValues :: GetString ( GetDevice ( ) -> mKind ) ) + . get ( ) , + NS_SUCCEEDED ( aResult ) ? "succeeded" : "failed" ) ; if ( NS_FAILED ( aResult ) && aResult != NS_ERROR_ABORT ) { - - - + + + if ( aOn ) { - - + + - StopTrack ( track ) ; + Stop ( ) ; } else { MOZ_ASSERT_UNREACHABLE ( "The device should be stoppable" ) ; } } return DeviceOperationPromise :: CreateAndResolve ( aResult , __func__ ) ; } ,
nsDeque :: GrowCapacity ( ) { int32_t theNewSize = mCapacity < < 2 ; NS_ASSERTION ( theNewSize > mCapacity , "Overflow" ) ; if ( theNewSize <= mCapacity ) { return false ; } void * * temp = ( void * * ) malloc ( theNewSize * sizeof ( void * ) ) ; if ( ! temp ) { return false ; } memcpy ( temp , mData + mOrigin , sizeof ( void * ) * ( mCapacity - mOrigin ) ) ; memcpy ( temp + ( mCapacity - mOrigin ) , mData , sizeof ( void * ) * mOrigin ) ; if ( mData != mBuffer ) { free ( mData ) ; } mCapacity = theNewSize ; mOrigin = 0 ; mData = temp ; return true ; }
nsXBLProtoImpl :: CompilePrototypeMembers ( nsXBLPrototypeBinding * aBinding ) { nsCOMPtr < nsIScriptGlobalObjectOwner > globalOwner ( do_QueryObject ( aBinding -> XBLDocumentInfo ( ) ) ) ; nsIScriptGlobalObject * globalObject = globalOwner -> GetScriptGlobalObject ( ) ; NS_ENSURE_TRUE ( globalObject , NS_ERROR_UNEXPECTED ) ; nsIScriptContext * context = globalObject -> GetContext ( ) ; NS_ENSURE_TRUE ( context , NS_ERROR_OUT_OF_MEMORY ) ; JSContext * cx = context -> GetNativeContext ( ) ; JSObject * global = globalObject -> GetGlobalJSObject ( ) ; JSObject * classObject ; bool classObjectIsNew = false ; nsresult rv = aBinding -> InitClass ( mClassName , cx , global , global , & classObject , & classObjectIsNew ) ; if ( NS_FAILED ( rv ) ) return rv ; MOZ_ASSERT ( classObjectIsNew ) ; MOZ_ASSERT ( classObject ) ; mClassObject = classObject ; AutoVersionChecker avc ( cx ) ; for ( nsXBLProtoImplMember * curr = mMembers ; curr ; curr = curr -> GetNext ( ) ) { nsresult rv = curr -> CompileMember ( context , mClassName , mClassObject ) ; if ( NS_FAILED ( rv ) ) { DestroyMembers ( ) ; return rv ; } } return NS_OK ; }
bool AccessInfoFactory :: ComputeElementAccessInfo ( Handle < Map > map , AccessMode access_mode , ElementAccessInfo * access_info ) { if ( ! CanInlineElementAccess ( map ) ) return false ; ElementsKind const elements_kind = map -> elements_kind ( ) ; * access_info = ElementAccessInfo ( MapHandles { map } , elements_kind ) ; return true ; }
Skip the mipmap images for compressed ( DXTn ) dds files * / static MagickBooleanType SkipDXTMipmaps ( Image * image , DDSInfo * dds_info , int texel_size , ExceptionInfo * exception ) { register ssize_t i ; MagickOffsetType offset ; size_t h , w ; if ( dds_info -> ddscaps1 & DDSCAPS_MIPMAP && ( dds_info -> ddscaps1 & DDSCAPS_TEXTURE || dds_info -> ddscaps2 & DDSCAPS2_CUBEMAP ) ) { if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; return ( MagickFalse ) ; } w = DIV2 ( dds_info -> width ) ; h = DIV2 ( dds_info -> height ) ; for ( i = 1 ; ( i < ( ssize_t ) dds_info -> mipmapcount ) && w && h ; i ++ ) { offset = ( MagickOffsetType ) ( ( w + 3 ) / 4 ) * ( ( h + 3 ) / 4 ) * texel_size ; ( void ) SeekBlob ( image , offset , SEEK_CUR ) ; w = DIV2 ( w ) ; h = DIV2 ( h ) ; } }
void OneHotComputeImpl ( const OneHotContext & op_context ) { int prefix_dim_size = 1 ; for ( int i = 0 ; i < op_context . axis ; ++ i ) { prefix_dim_size *= op_context . indices -> dims -> data [ i ] ; } const int suffix_dim_size = NumElements ( op_context . indices ) / prefix_dim_size ; const int depth = * op_context . depth -> data . i32 ; const T on_value = * GetTensorData < T > ( op_context . on_value ) ; const T off_value = * GetTensorData < T > ( op_context . off_value ) ; T * output = GetTensorData < T > ( op_context . output ) ; const TI * indices = GetTensorData < TI > ( op_context . indices ) ; for ( int i = 0 ; i < prefix_dim_size ; ++ i ) { for ( int j = 0 ; j < depth ; ++ j ) { for ( int k = 0 ; k < suffix_dim_size ; ++ k , ++ output ) { * output = static_cast < int > ( indices [ i * suffix_dim_size + k ] ) == j ? on_value : off_value ; } } } }
static PyObject * __Pyx_CyFunction_descr_get ( PyObject * func , PyObject * obj , PyObject * type ) { __pyx_CyFunctionObject * m = ( __pyx_CyFunctionObject * ) func ; if ( m -> flags & __Pyx_CYFUNCTION_STATICMETHOD ) { Py_INCREF ( func ) ; return func ; } if ( m -> flags & __Pyx_CYFUNCTION_CLASSMETHOD ) { if ( type == NULL ) type = ( PyObject * ) ( Py_TYPE ( obj ) ) ; return __Pyx_PyMethod_New ( func , type , ( PyObject * ) ( Py_TYPE ( type ) ) ) ; } if ( obj == Py_None ) obj = NULL ; return __Pyx_PyMethod_New ( func , obj , type ) ; }
void update_metadata_ ( const FLAC__StreamEncoder * encoder ) { FLAC__byte b [ max ( 6 , FLAC__STREAM_METADATA_SEEKPOINT_LENGTH ) ] ; const FLAC__StreamMetadata * metadata = & encoder -> private_ -> streaminfo ; const FLAC__uint64 samples = metadata -> data . stream_info . total_samples ; const unsigned min_framesize = metadata -> data . stream_info . min_framesize ; const unsigned max_framesize = metadata -> data . stream_info . max_framesize ; const unsigned bps = metadata -> data . stream_info . bits_per_sample ; FLAC__StreamEncoderSeekStatus seek_status ; FLAC__ASSERT ( metadata -> type == FLAC__METADATA_TYPE_STREAMINFO ) ; { const unsigned md5_offset = FLAC__STREAM_METADATA_HEADER_LENGTH + ( FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN + FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN + FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN + FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN + FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN + FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN + FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN + FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN ) / 8 ; if ( ( seek_status = encoder -> private_ -> seek_callback ( encoder , encoder -> protected_ -> streaminfo_offset + md5_offset , encoder -> private_ -> client_data ) ) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK ) { if ( seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR ) encoder -> protected_ -> state = FLAC__STREAM_ENCODER_CLIENT_ERROR ; return ; } if ( encoder -> private_ -> write_callback ( encoder , metadata -> data . stream_info . md5sum , 16 , 0 , 0 , encoder -> private_ -> client_data ) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK ) { encoder -> protected_ -> state = FLAC__STREAM_ENCODER_CLIENT_ERROR ; return ; } } { const unsigned total_samples_byte_offset = FLAC__STREAM_METADATA_HEADER_LENGTH + ( FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN + FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN + FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN + FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN + FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN + FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN + FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN - 4 ) / 8 ; b [ 0 ] = ( ( FLAC__byte ) ( bps - 1 ) < < 4 ) | ( FLAC__byte ) ( ( samples > > 32 ) & 0x0F ) ; b [ 1 ] = ( FLAC__byte ) ( ( samples > > 24 ) & 0xFF ) ; b [ 2 ] = ( FLAC__byte ) ( ( samples > > 16 ) & 0xFF ) ; b [ 3 ] = ( FLAC__byte ) ( ( samples > > 8 ) & 0xFF ) ; b [ 4 ] = ( FLAC__byte ) ( samples & 0xFF ) ; if ( ( seek_status = encoder -> private_ -> seek_callback ( encoder , encoder -> protected_ -> streaminfo_offset + total_samples_byte_offset , encoder -> private_ -> client_data ) ) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK ) { if ( seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR ) encoder -> protected_ -> state = FLAC__STREAM_ENCODER_CLIENT_ERROR ; return ; } if ( encoder -> private_ -> write_callback ( encoder , b , 5 , 0 , 0 , encoder -> private_ -> client_data ) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK ) { encoder -> protected_ -> state = FLAC__STREAM_ENCODER_CLIENT_ERROR ; return ; } } { const unsigned min_framesize_offset = FLAC__STREAM_METADATA_HEADER_LENGTH + ( FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN + FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN ) / 8 ; b [ 0 ] = ( FLAC__byte ) ( ( min_framesize > > 16 ) & 0xFF ) ; b [ 1 ] = ( FLAC__byte ) ( ( min_framesize > > 8 ) & 0xFF ) ; b [ 2 ] = ( FLAC__byte ) ( min_framesize & 0xFF ) ; b [ 3 ] = ( FLAC__byte ) ( ( max_framesize > > 16 ) & 0xFF ) ; b [ 4 ] = ( FLAC__byte ) ( ( max_framesize > > 8 ) & 0xFF ) ; b [ 5 ] = ( FLAC__byte ) ( max_framesize & 0xFF ) ; if ( ( seek_status = encoder -> private_ -> seek_callback ( encoder , encoder -> protected_ -> streaminfo_offset + min_framesize_offset , encoder -> private_ -> client_data ) ) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK ) { if ( seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR ) encoder -> protected_ -> state = FLAC__STREAM_ENCODER_CLIENT_ERROR ; return ; } if ( encoder -> private_ -> write_callback ( encoder , b , 6 , 0 , 0 , encoder -> private_ -> client_data ) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK ) { encoder -> protected_ -> state = FLAC__STREAM_ENCODER_CLIENT_ERROR ; return ; } } if ( 0 != encoder -> private_ -> seek_table && encoder -> private_ -> seek_table -> num_points > 0 && encoder -> protected_ -> seektable_offset > 0 ) { unsigned i ; FLAC__format_seektable_sort ( encoder -> private_ -> seek_table ) ; FLAC__ASSERT ( FLAC__format_seektable_is_legal ( encoder -> private_ -> seek_table ) ) ; if ( ( seek_status = encoder -> private_ -> seek_callback ( encoder , encoder -> protected_ -> seektable_offset + FLAC__STREAM_METADATA_HEADER_LENGTH , encoder -> private_ -> client_data ) ) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK ) { if ( seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR ) encoder -> protected_ -> state = FLAC__STREAM_ENCODER_CLIENT_ERROR ; return ; } for ( i = 0 ; i < encoder -> private_ -> seek_table -> num_points ; i ++ ) { FLAC__uint64 xx ; unsigned x ; xx = encoder -> private_ -> seek_table -> points [ i ] . sample_number ; b [ 7 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 6 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 5 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 4 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 3 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 2 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 1 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 0 ] = ( FLAC__byte ) xx ; xx >>= 8 ; xx = encoder -> private_ -> seek_table -> points [ i ] . stream_offset ; b [ 15 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 14 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 13 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 12 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 11 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 10 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 9 ] = ( FLAC__byte ) xx ; xx >>= 8 ; b [ 8 ] = ( FLAC__byte ) xx ; xx >>= 8 ; x = encoder -> private_ -> seek_table -> points [ i ] . frame_samples ; b [ 17 ] = ( FLAC__byte ) x ; x >>= 8 ; b [ 16 ] = ( FLAC__byte ) x ; x >>= 8 ; if ( encoder -> private_ -> write_callback ( encoder , b , 18 , 0 , 0 , encoder -> private_ -> client_data ) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK ) { encoder -> protected_ -> state = FLAC__STREAM_ENCODER_CLIENT_ERROR ; return ; } } } }
void impeg2d_mc_fullx_fully ( void * pv_dec , UWORD8 * pu1_ref , UWORD32 u4_ref_wid , UWORD8 * pu1_out , UWORD32 u4_out_wid , UWORD32 u4_blk_width , UWORD32 u4_blk_height ) { UWORD8 * pu1_out_ptr , * pu1_ref_ptr ; dec_state_t * ps_dec = ( dec_state_t * ) pv_dec ; pu1_out_ptr = pu1_out ; pu1_ref_ptr = pu1_ref ; if ( ( u4_blk_width == MB_SIZE ) && ( u4_blk_height == MB_SIZE ) ) { ps_dec -> pf_fullx_fully_8x8 ( pu1_out_ptr , pu1_ref_ptr , u4_ref_wid , u4_out_wid ) ; pu1_out_ptr = ( pu1_out + BLK_SIZE ) ; pu1_ref_ptr = ( pu1_ref + BLK_SIZE ) ; ps_dec -> pf_fullx_fully_8x8 ( pu1_out_ptr , pu1_ref_ptr , u4_ref_wid , u4_out_wid ) ; pu1_out_ptr = pu1_out + BLK_SIZE * u4_out_wid ; pu1_ref_ptr = pu1_ref + BLK_SIZE * u4_ref_wid ; ps_dec -> pf_fullx_fully_8x8 ( pu1_out_ptr , pu1_ref_ptr , u4_ref_wid , u4_out_wid ) ; pu1_out_ptr = pu1_out + BLK_SIZE * u4_out_wid + BLK_SIZE ; pu1_ref_ptr = pu1_ref + BLK_SIZE * u4_ref_wid + BLK_SIZE ; ps_dec -> pf_fullx_fully_8x8 ( pu1_out_ptr , pu1_ref_ptr , u4_ref_wid , u4_out_wid ) ; } else if ( ( u4_blk_width == BLK_SIZE ) && ( u4_blk_height == BLK_SIZE ) ) { ps_dec -> pf_fullx_fully_8x8 ( pu1_out_ptr , pu1_ref_ptr , u4_ref_wid , u4_out_wid ) ; } else if ( ( u4_blk_width == MB_SIZE ) && ( u4_blk_height == BLK_SIZE ) ) { ps_dec -> pf_fullx_fully_8x8 ( pu1_out_ptr , pu1_ref_ptr , u4_ref_wid , u4_out_wid ) ; pu1_out_ptr = ( pu1_out + BLK_SIZE ) ; pu1_ref_ptr = ( pu1_ref + BLK_SIZE ) ; ps_dec -> pf_fullx_fully_8x8 ( pu1_out_ptr , pu1_ref_ptr , u4_ref_wid , u4_out_wid ) ; } else { UWORD32 i ; for ( i = 0 ; i < u4_blk_height ; i ++ ) { memcpy ( pu1_out , pu1_ref , u4_blk_width ) ; pu1_ref += u4_ref_wid ; pu1_out += u4_out_wid ; } } return ; }
Code * BuildWithCodeStubAssemblerCS ( Isolate * isolate , int32_t builtin_index , CodeAssemblerGenerator generator , CallDescriptors :: Key interface_descriptor , const char * name , int result_size ) { HandleScope scope ( isolate ) ; CanonicalHandleScope canonical ( isolate ) ; SegmentSize segment_size = isolate -> serializer_enabled ( ) ? SegmentSize :: kLarge : SegmentSize :: kDefault ; Zone zone ( isolate -> allocator ( ) , ZONE_NAME , segment_size ) ; CallInterfaceDescriptor descriptor ( interface_descriptor ) ; DCHECK_EQ ( result_size , descriptor . GetReturnCount ( ) ) ; DCHECK_LE ( 0 , descriptor . GetRegisterParameterCount ( ) ) ; compiler :: CodeAssemblerState state ( isolate , & zone , descriptor , Code :: BUILTIN , name , PoisoningMitigationLevel :: kDontPoison , 0 , builtin_index ) ; generator ( & state ) ; Handle < Code > code = compiler :: CodeAssembler :: GenerateCode ( & state , BuiltinAssemblerOptions ( isolate , builtin_index ) ) ; PostBuildProfileAndTracing ( isolate , * code , name ) ; return * code ; }
SampleTable :: getSampleCencInfo ( uint32_t sample_index , Vector < uint16_t > & clear_sizes , Vector < uint32_t > & cipher_sizes , uint8_t iv [ ] ) { CHECK ( clear_sizes . isEmpty ( ) && cipher_sizes . isEmpty ( ) ) ; if ( sample_index >= mCencInfoCount ) { ALOGE ( "cenc info requested for out of range sample index" ) ; return ERROR_MALFORMED ; } auto & info = mCencInfo [ sample_index ] ; if ( clear_sizes . setCapacity ( info . mSubsampleCount ) < 0 ) { return ERROR_MALFORMED ; } if ( cipher_sizes . setCapacity ( info . mSubsampleCount ) < 0 ) { return ERROR_MALFORMED ; } for ( uint32_t i = 0 ; i < info . mSubsampleCount ; i ++ ) { clear_sizes . push ( info . mSubsamples [ i ] . mClearBytes ) ; cipher_sizes . push ( info . mSubsamples [ i ] . mCipherBytes ) ; } memcpy ( iv , info . mIV , IV_BYTES ) ; return OK ; }
struct sk_buff * sock_alloc_send_pskb ( struct sock * sk , unsigned long header_len , unsigned long data_len , int noblock , int * errcode ) { struct sk_buff * skb ; gfp_t gfp_mask ; long timeo ; int err ; gfp_mask = sk -> sk_allocation ; if ( gfp_mask & __GFP_WAIT ) gfp_mask |= __GFP_REPEAT ; timeo = sock_sndtimeo ( sk , noblock ) ; while ( 1 ) { err = sock_error ( sk ) ; if ( err != 0 ) goto failure ; err = - EPIPE ; if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto failure ; if ( atomic_read ( & sk -> sk_wmem_alloc ) < sk -> sk_sndbuf ) { skb = alloc_skb ( header_len , gfp_mask ) ; if ( skb ) { int npages ; int i ; if ( ! data_len ) break ; npages = ( data_len + ( PAGE_SIZE - 1 ) ) > > PAGE_SHIFT ; skb -> truesize += data_len ; skb_shinfo ( skb ) -> nr_frags = npages ; for ( i = 0 ; i < npages ; i ++ ) { struct page * page ; page = alloc_pages ( sk -> sk_allocation , 0 ) ; if ( ! page ) { err = - ENOBUFS ; skb_shinfo ( skb ) -> nr_frags = i ; kfree_skb ( skb ) ; goto failure ; } __skb_fill_page_desc ( skb , i , page , 0 , ( data_len >= PAGE_SIZE ? PAGE_SIZE : data_len ) ) ; data_len -= PAGE_SIZE ; } break ; } err = - ENOBUFS ; goto failure ; } set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; set_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ; err = - EAGAIN ; if ( ! timeo ) goto failure ; if ( signal_pending ( current ) ) goto interrupted ; timeo = sock_wait_for_wmem ( sk , timeo ) ; } skb_set_owner_w ( skb , sk ) ; return skb ; interrupted : err = sock_intr_errno ( timeo ) ; failure : * errcode = err ; return NULL ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 2 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; const TfLiteTensor * size = GetInput ( context , node , kSizeTensor ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( input ) , 4 ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( size ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , size -> type , kTfLiteInt32 ) ; output -> type = input -> type ; if ( ! IsConstantTensor ( size ) ) { SetTensorToDynamic ( output ) ; return kTfLiteOk ; } auto * params = reinterpret_cast < TfLiteResizeBilinearParams * > ( node -> builtin_data ) ; if ( params -> half_pixel_centers && params -> align_corners ) { context -> ReportError ( context , "If half_pixel_centers is True, align_corners must be False." ) ; return kTfLiteError ; } return ResizeOutputTensor ( context , input , size , output ) ; }
Shutdown ( WorkerPrivate * aWorkerPrivate ) { MOZ_ASSERT ( aWorkerPrivate ) ; aWorkerPrivate -> AssertIsOnWorkerThread ( ) ; mPromiseProxy -> CleanUp ( ) ; mFetchObserver = nullptr ; if ( mSignalProxy ) { mSignalProxy -> Shutdown ( ) ; mSignalProxy = nullptr ; } }
% % A description of each parameter follows : % % o exception : the exception info . % * / MagickExport void CatchException ( ExceptionInfo * exception ) { register const ExceptionInfo * p ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; if ( exception -> exceptions == ( void * ) NULL ) return ; LockSemaphoreInfo ( exception -> semaphore ) ; ResetLinkedListIterator ( ( LinkedListInfo * ) exception -> exceptions ) ; p = ( const ExceptionInfo * ) GetNextValueInLinkedList ( ( LinkedListInfo * ) exception -> exceptions ) ; while ( p != ( const ExceptionInfo * ) NULL ) { if ( ( p -> severity >= WarningException ) && ( p -> severity < ErrorException ) ) MagickWarning ( p -> severity , p -> reason , p -> description ) ; if ( ( p -> severity >= ErrorException ) && ( p -> severity < FatalErrorException ) ) MagickError ( p -> severity , p -> reason , p -> description ) ; if ( p -> severity >= FatalErrorException ) MagickFatalError ( p -> severity , p -> reason , p -> description ) ;
SkCodec * SkIcoCodec :: NewFromStream ( SkStream * stream , Result * result ) { std :: unique_ptr < SkStream > inputStream ( stream ) ; static const uint32_t kIcoDirectoryBytes = 6 ; static const uint32_t kIcoDirEntryBytes = 16 ; std :: unique_ptr < uint8_t [ ] > dirBuffer ( new uint8_t [ kIcoDirectoryBytes ] ) ; if ( inputStream . get ( ) -> read ( dirBuffer . get ( ) , kIcoDirectoryBytes ) != kIcoDirectoryBytes ) { SkCodecPrintf ( "Error: unable to read ico directory header.\n" ) ; * result = kIncompleteInput ; return nullptr ; } const uint16_t numImages = get_short ( dirBuffer . get ( ) , 4 ) ; if ( 0 == numImages ) { SkCodecPrintf ( "Error: No images embedded in ico.\n" ) ; * result = kInvalidInput ; return nullptr ; } struct Entry { uint32_t offset ; uint32_t size ; } ; SkAutoFree dirEntryBuffer ( sk_malloc_flags ( sizeof ( Entry ) * numImages , SK_MALLOC_TEMP ) ) ; if ( ! dirEntryBuffer ) { SkCodecPrintf ( "Error: OOM allocating ICO directory for %i images.\n" , numImages ) ; * result = kInternalError ; return nullptr ; } auto * directoryEntries = reinterpret_cast < Entry * > ( dirEntryBuffer . get ( ) ) ; for ( uint32_t i = 0 ; i < numImages ; i ++ ) { uint8_t entryBuffer [ kIcoDirEntryBytes ] ; if ( inputStream -> read ( entryBuffer , kIcoDirEntryBytes ) != kIcoDirEntryBytes ) { SkCodecPrintf ( "Error: Dir entries truncated in ico.\n" ) ; * result = kIncompleteInput ; return nullptr ; } uint32_t size = get_int ( entryBuffer , 8 ) ; uint32_t offset = get_int ( entryBuffer , 12 ) ; directoryEntries [ i ] . offset = offset ; directoryEntries [ i ] . size = size ; } * result = kInvalidInput ; struct EntryLessThan { bool operator ( ) ( Entry a , Entry b ) const { return a . offset < b . offset ; } } ; EntryLessThan lessThan ; SkTQSort ( directoryEntries , & directoryEntries [ numImages - 1 ] , lessThan ) ; uint32_t bytesRead = kIcoDirectoryBytes + numImages * kIcoDirEntryBytes ; std :: unique_ptr < SkTArray < std :: unique_ptr < SkCodec > , true > > codecs ( new ( SkTArray < std :: unique_ptr < SkCodec > , true > ) ( numImages ) ) ; for ( uint32_t i = 0 ; i < numImages ; i ++ ) { uint32_t offset = directoryEntries [ i ] . offset ; uint32_t size = directoryEntries [ i ] . size ; if ( offset < bytesRead ) { SkCodecPrintf ( "Warning: invalid ico offset.\n" ) ; continue ; } if ( inputStream . get ( ) -> skip ( offset - bytesRead ) != offset - bytesRead ) { SkCodecPrintf ( "Warning: could not skip to ico offset.\n" ) ; break ; } bytesRead = offset ; SkAutoFree buffer ( sk_malloc_flags ( size , 0 ) ) ; if ( ! buffer ) { SkCodecPrintf ( "Warning: OOM trying to create embedded stream.\n" ) ; break ; } if ( inputStream -> read ( buffer . get ( ) , size ) != size ) { SkCodecPrintf ( "Warning: could not create embedded stream.\n" ) ; * result = kIncompleteInput ; break ; } sk_sp < SkData > data ( SkData :: MakeFromMalloc ( buffer . release ( ) , size ) ) ; std :: unique_ptr < SkMemoryStream > embeddedStream ( new SkMemoryStream ( data ) ) ; bytesRead += size ; SkCodec * codec = nullptr ; Result dummyResult ; if ( SkPngCodec :: IsPng ( ( const char * ) data -> bytes ( ) , data -> size ( ) ) ) { codec = SkPngCodec :: NewFromStream ( embeddedStream . release ( ) , & dummyResult ) ; } else { codec = SkBmpCodec :: NewFromIco ( embeddedStream . release ( ) , & dummyResult ) ; } if ( nullptr != codec ) { codecs -> push_back ( ) . reset ( codec ) ; } } if ( 0 == codecs -> count ( ) ) { SkCodecPrintf ( "Error: could not find any valid embedded ico codecs.\n" ) ; return nullptr ; } size_t maxSize = 0 ; int maxIndex = 0 ; for ( int i = 0 ; i < codecs -> count ( ) ; i ++ ) { SkImageInfo info = codecs -> operator [ ] ( i ) -> getInfo ( ) ; size_t size = info . getSafeSize ( info . minRowBytes ( ) ) ; if ( size > maxSize ) { maxSize = size ; maxIndex = i ; } } int width = codecs -> operator [ ] ( maxIndex ) -> getInfo ( ) . width ( ) ; int height = codecs -> operator [ ] ( maxIndex ) -> getInfo ( ) . height ( ) ; SkEncodedInfo info = codecs -> operator [ ] ( maxIndex ) -> getEncodedInfo ( ) ; SkColorSpace * colorSpace = codecs -> operator [ ] ( maxIndex ) -> getInfo ( ) . colorSpace ( ) ; * result = kSuccess ; return new SkIcoCodec ( width , height , info , codecs . release ( ) , sk_ref_sp ( colorSpace ) ) ; }
nsPresContext :: PreferenceChanged ( const char * aPrefName ) { nsDependentCString prefName ( aPrefName ) ; if ( prefName . EqualsLiteral ( "layout.css.dpi" ) || prefName . EqualsLiteral ( "layout.css.devPixelsPerPx" ) ) { int32_t oldAppUnitsPerDevPixel = AppUnitsPerDevPixel ( ) ; if ( mDeviceContext -> CheckDPIChange ( ) && mShell ) { nscoord oldWidthAppUnits , oldHeightAppUnits ; nsViewManager * vm = mShell -> GetViewManager ( ) ; vm -> GetWindowDimensions ( & oldWidthAppUnits , & oldHeightAppUnits ) ; float oldWidthDevPixels = oldWidthAppUnits / oldAppUnitsPerDevPixel ; float oldHeightDevPixels = oldHeightAppUnits / oldAppUnitsPerDevPixel ; nscoord width = NSToCoordRound ( oldWidthDevPixels * AppUnitsPerDevPixel ( ) ) ; nscoord height = NSToCoordRound ( oldHeightDevPixels * AppUnitsPerDevPixel ( ) ) ; vm -> SetWindowDimensions ( width , height ) ; AppUnitsPerDevPixelChanged ( ) ; } return ; } if ( StringBeginsWith ( prefName , NS_LITERAL_CSTRING ( "font." ) ) ) { mPrefChangePendingNeedsReflow = true ; } if ( StringBeginsWith ( prefName , NS_LITERAL_CSTRING ( "bidi." ) ) ) { mPrefChangePendingNeedsReflow = true ; } if ( StringBeginsWith ( prefName , NS_LITERAL_CSTRING ( "gfx.font_rendering." ) ) ) { mPrefChangePendingNeedsReflow = true ; } if ( ! mPrefChangedTimer ) { mPrefChangedTimer = do_CreateInstance ( "@mozilla.org/timer;1" ) ; if ( ! mPrefChangedTimer ) return ; mPrefChangedTimer -> InitWithFuncCallback ( nsPresContext :: PrefChangedUpdateTimerCallback , ( void * ) this , 0 , nsITimer :: TYPE_ONE_SHOT ) ; } if ( prefName . EqualsLiteral ( "nglayout.debug.paint_flashing" ) || prefName . EqualsLiteral ( "nglayout.debug.paint_flashing_chrome" ) ) { mPaintFlashingInitialized = false ; return ; } }
WORD32 impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) { stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_mb_addr_incr ; UWORD16 u2_total_len ; UWORD16 u2_len ; UWORD16 u2_mb_type ; UWORD32 u4_next_word ; const dec_mb_params_t * ps_dec_mb_params ; if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) { impeg2d_bit_stream_flush ( ps_stream , 1 ) ; } else { u2_mb_addr_incr = impeg2d_get_mb_addr_incr ( ps_stream ) ; if ( ps_dec -> u2_first_mb ) { ps_dec -> u2_mb_x = u2_mb_addr_incr - 1 ; ps_dec -> u2_mb_x = MIN ( ps_dec -> u2_mb_x , ( ps_dec -> u2_num_horiz_mb - 1 ) ) ; ps_dec -> u2_num_mbs_left = ( ( ps_dec -> u2_num_vert_mb - ps_dec -> u2_mb_y ) * ps_dec -> u2_num_horiz_mb ) - ps_dec -> u2_mb_x ; u2_mb_addr_incr = 1 ; ps_dec -> u2_first_mb = 0 ; } else { if ( ps_dec -> u2_is_mpeg2 && ( ( ps_dec -> u2_mb_x + u2_mb_addr_incr ) > ps_dec -> u2_num_horiz_mb ) ) { u2_mb_addr_incr = ps_dec -> u2_num_horiz_mb - ps_dec -> u2_mb_x ; } if ( ( u2_mb_addr_incr - 1 ) > ps_dec -> u2_num_mbs_left ) { return IV_FAIL ; } impeg2d_dec_skip_mbs ( ps_dec , ( UWORD16 ) ( u2_mb_addr_incr - 1 ) ) ; } } u4_next_word = ( UWORD16 ) impeg2d_bit_stream_nxt ( ps_stream , 16 ) ; { u2_mb_type = ps_dec -> pu2_mb_type [ BITS ( ( UWORD16 ) u4_next_word , 15 , 10 ) ] ; u2_len = BITS ( u2_mb_type , 15 , 8 ) ; u2_total_len = u2_len ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word < < u2_len ) ; } { WORD32 i4_motion_type = ps_dec -> u2_motion_type ; if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ps_dec -> u2_read_motion_type ) { ps_dec -> u2_motion_type = BITS ( ( UWORD16 ) u4_next_word , 15 , 14 ) ; u2_total_len += MB_MOTION_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word < < MB_MOTION_TYPE_LEN ) ; i4_motion_type = ps_dec -> u2_motion_type ; } if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ( ( i4_motion_type == 0 ) || ( i4_motion_type == 3 ) || ( i4_motion_type == 4 ) || ( i4_motion_type >= 7 ) ) ) { i4_motion_type = 1 ; } } { if ( ( u2_mb_type & MB_CODED ) && ps_dec -> u2_read_dct_type ) { ps_dec -> u2_field_dct = BIT ( ( UWORD16 ) u4_next_word , 15 ) ; u2_total_len += MB_DCT_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word < < MB_DCT_TYPE_LEN ) ; } } if ( u2_mb_type & MB_QUANT ) { UWORD16 u2_quant_scale_code ; u2_quant_scale_code = BITS ( ( UWORD16 ) u4_next_word , 15 , 11 ) ; ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code < < 1 ) ; u2_total_len += MB_QUANT_SCALE_CODE_LEN ; } impeg2d_bit_stream_flush ( ps_stream , u2_total_len ) ; ps_dec -> u2_coded_mb = ( UWORD16 ) ( u2_mb_type & MB_CODED ) ; if ( u2_mb_type & MB_BIDRECT ) { UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = BIDIRECT ; ps_dec_mb_params = & ps_dec -> ps_func_bi_direct [ u2_index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; } else if ( u2_mb_type & MB_FORW_OR_BACK ) { UWORD16 u2_refPic = ! ( u2_mb_type & MB_MV_FORW ) ; UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = ( e_pred_direction_t ) u2_refPic ; ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ u2_index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; } else if ( u2_mb_type & MB_TYPE_INTRA ) { ps_dec -> u2_prev_intra_mb = 1 ; impeg2d_dec_intra_mb ( ps_dec ) ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = FORW ; ps_dec -> u2_motion_type = 0 ; impeg2d_dec_0mv_coded_mb ( ps_dec ) ; } if ( ( u2_mb_type & MB_TYPE_INTRA ) ) { ps_dec -> u2_cbp = 0x3f ; ps_dec -> u2_prev_intra_mb = 1 ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 < < ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 < < ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 < < ps_dec -> u2_intra_dc_precision ; if ( ( ps_dec -> u2_coded_mb ) ) { UWORD16 cbpValue ; cbpValue = gau2_impeg2d_cbp_code [ impeg2d_bit_stream_nxt ( ps_stream , MB_CBP_LEN ) ] ; ps_dec -> u2_cbp = cbpValue & 0xFF ; impeg2d_bit_stream_flush ( ps_stream , ( cbpValue > > 8 ) & 0x0FF ) ; } else { ps_dec -> u2_cbp = 0 ; } } return 0 ; }
AllocationResult Heap :: Allocate ( Map * map , AllocationSpace space ) { DCHECK ( map -> instance_type ( ) != MAP_TYPE ) ; int size = map -> instance_size ( ) ; HeapObject * result = nullptr ; AllocationResult allocation = AllocateRaw ( size , space ) ; if ( ! allocation . To ( & result ) ) return allocation ; WriteBarrierMode write_barrier_mode = space == NEW_SPACE ? SKIP_WRITE_BARRIER : UPDATE_WRITE_BARRIER ; result -> set_map_after_allocation ( map , write_barrier_mode ) ; return result ; }
void EventStateManager :: UpdateCursor ( nsPresContext * aPresContext , WidgetEvent * aEvent , nsIFrame * aTargetFrame , nsEventStatus * aStatus ) { if ( aTargetFrame && IsRemoteTarget ( aTargetFrame -> GetContent ( ) ) ) { return ; } auto cursor = StyleCursorKind :: Default ; imgIContainer * container = nullptr ; bool haveHotspot = false ; float hotspotX = 0.0f , hotspotY = 0.0f ; if ( mLockCursor != kInvalidCursorKind ) { cursor = mLockCursor ; } else if ( aTargetFrame ) { nsIFrame :: Cursor framecursor ; nsPoint pt = nsLayoutUtils :: GetEventCoordinatesRelativeTo ( aEvent , aTargetFrame ) ; if ( NS_FAILED ( aTargetFrame -> GetCursor ( pt , framecursor ) ) ) { if ( XRE_IsContentProcess ( ) ) { mLastFrameConsumedSetCursor = true ; } return ; } if ( mLastFrameConsumedSetCursor ) { ClearCachedWidgetCursor ( aTargetFrame ) ; mLastFrameConsumedSetCursor = false ; } if ( framecursor . mLoading && gLastCursorSourceFrame == aTargetFrame && TimeStamp :: NowLoRes ( ) - gLastCursorUpdateTime < TimeDuration :: FromMilliseconds ( kCursorLoadingTimeout ) ) { return ; } cursor = framecursor . mCursor ; container = framecursor . mContainer ; haveHotspot = framecursor . mHaveHotspot ; hotspotX = framecursor . mHotspotX ; hotspotY = framecursor . mHotspotY ; } if ( nsContentUtils :: UseActivityCursor ( ) ) { nsCOMPtr < nsIDocShell > docShell ( aPresContext -> GetDocShell ( ) ) ; if ( ! docShell ) return ; auto busyFlags = docShell -> GetBusyFlags ( ) ; if ( busyFlags & nsIDocShell :: BUSY_FLAGS_BUSY && ( cursor == StyleCursorKind :: Auto || cursor == StyleCursorKind :: Default ) ) { cursor = StyleCursorKind :: Progress ; container = nullptr ; } } if ( aTargetFrame ) { SetCursor ( cursor , container , haveHotspot , hotspotX , hotspotY , aTargetFrame -> GetNearestWidget ( ) , false ) ; gLastCursorSourceFrame = aTargetFrame ; gLastCursorUpdateTime = TimeStamp :: NowLoRes ( ) ; } if ( mLockCursor != kInvalidCursorKind || StyleCursorKind :: Auto != cursor ) { * aStatus = nsEventStatus_eConsumeDoDefault ; } }
TF_BUILTIN ( DatePrototypeGetDay , DateBuiltinsAssembler ) { Node * context = Parameter ( Descriptor :: kContext ) ; Node * receiver = Parameter ( Descriptor :: kReceiver ) ; Generate_DatePrototype_GetField ( context , receiver , JSDate :: kWeekday ) ; }
int tls1_setup_key_block ( SSL * s ) { unsigned char * p ; const EVP_CIPHER * c ; const EVP_MD * hash ; int num ; SSL_COMP * comp ; int mac_type = NID_undef , mac_secret_size = 0 ; int ret = 0 ; if ( s -> s3 -> tmp . key_block_length != 0 ) return ( 1 ) ; if ( ! ssl_cipher_get_evp ( s -> session , & c , & hash , & mac_type , & mac_secret_size , & comp , SSL_USE_ETM ( s ) ) ) { SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , SSL_R_CIPHER_OR_HASH_UNAVAILABLE ) ; return ( 0 ) ; } s -> s3 -> tmp . new_sym_enc = c ; s -> s3 -> tmp . new_hash = hash ; s -> s3 -> tmp . new_mac_pkey_type = mac_type ; s -> s3 -> tmp . new_mac_secret_size = mac_secret_size ; num = EVP_CIPHER_key_length ( c ) + mac_secret_size + EVP_CIPHER_iv_length ( c ) ; num *= 2 ; ssl3_cleanup_key_block ( s ) ; if ( ( p = OPENSSL_malloc ( num ) ) == NULL ) { SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , ERR_R_MALLOC_FAILURE ) ; goto err ; } s -> s3 -> tmp . key_block_length = num ; s -> s3 -> tmp . key_block = p ; #ifdef SSL_DEBUG printf ( "client random\n" ) ; { int z ; for ( z = 0 ; z < SSL3_RANDOM_SIZE ; z ++ ) printf ( "%02X%c" , s -> s3 -> client_random [ z ] , ( ( z + 1 ) % 16 ) ? ' ' : '\n' ) ; } printf ( "server random\n" ) ; { int z ; for ( z = 0 ; z < SSL3_RANDOM_SIZE ; z ++ ) printf ( "%02X%c" , s -> s3 -> server_random [ z ] , ( ( z + 1 ) % 16 ) ? ' ' : '\n' ) ; } printf ( "master key\n" ) ; { int z ; for ( z = 0 ; z < s -> session -> master_key_length ; z ++ ) printf ( "%02X%c" , s -> session -> master_key [ z ] , ( ( z + 1 ) % 16 ) ? ' ' : '\n' ) ; } #endif if ( ! tls1_generate_key_block ( s , p , num ) ) goto err ; #ifdef SSL_DEBUG printf ( "\nkey block\n" ) ; { int z ; for ( z = 0 ; z < num ; z ++ ) printf ( "%02X%c" , p [ z ] , ( ( z + 1 ) % 16 ) ? ' ' : '\n' ) ; } #endif if ( ! ( s -> options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS ) && s -> method -> version <= TLS1_VERSION ) { s -> s3 -> need_empty_fragments = 1 ; if ( s -> session -> cipher != NULL ) { if ( s -> session -> cipher -> algorithm_enc == SSL_eNULL ) s -> s3 -> need_empty_fragments = 0 ; #ifndef OPENSSL_NO_RC4 if ( s -> session -> cipher -> algorithm_enc == SSL_RC4 ) s -> s3 -> need_empty_fragments = 0 ; #endif } } ret = 1 ; err : return ( ret ) ; }
void inet6_destroy_sock ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct ipv6_txoptions * opt ; skb = xchg ( & np -> pktoptions , NULL ) ; if ( skb ) kfree_skb ( skb ) ; skb = xchg ( & np -> rxpmtu , NULL ) ; if ( skb ) kfree_skb ( skb ) ; fl6_free_socklist ( sk ) ; opt = xchg ( & np -> opt , NULL ) ; if ( opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; }
bool Serializer < AllocatorT > :: SerializeBuiltinReference ( HeapObject * obj , HowToCode how_to_code , WhereToPoint where_to_point , int skip ) { if ( ! obj -> IsCode ( ) ) return false ; Code * code = Code :: cast ( obj ) ; int builtin_index = code -> builtin_index ( ) ; if ( builtin_index < 0 ) return false ; DCHECK ( ( how_to_code == kPlain && where_to_point == kStartOfObject ) || ( how_to_code == kFromCode ) ) ; DCHECK_LT ( builtin_index , Builtins :: builtin_count ) ; DCHECK_LE ( 0 , builtin_index ) ; if ( FLAG_trace_serializer ) { PrintF ( " Encoding builtin reference: %s\n" , isolate ( ) -> builtins ( ) -> name ( builtin_index ) ) ; } FlushSkip ( skip ) ; sink_ . Put ( kBuiltin + how_to_code + where_to_point , "Builtin" ) ; sink_ . PutInt ( builtin_index , "builtin_index" ) ; return true ; }
bool IsSupportedBinaryProperty ( UProperty property ) { switch ( property ) { case UCHAR_ALPHABETIC : case UCHAR_ASCII_HEX_DIGIT : case UCHAR_BIDI_CONTROL : case UCHAR_BIDI_MIRRORED : case UCHAR_CASE_IGNORABLE : case UCHAR_CASED : case UCHAR_CHANGES_WHEN_CASEFOLDED : case UCHAR_CHANGES_WHEN_CASEMAPPED : case UCHAR_CHANGES_WHEN_LOWERCASED : case UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED : case UCHAR_CHANGES_WHEN_TITLECASED : case UCHAR_CHANGES_WHEN_UPPERCASED : case UCHAR_DASH : case UCHAR_DEFAULT_IGNORABLE_CODE_POINT : case UCHAR_DEPRECATED : case UCHAR_DIACRITIC : case UCHAR_EMOJI : #if U_ICU_VERSION_MAJOR_NUM >= 60 case UCHAR_EMOJI_COMPONENT : #endif case UCHAR_EMOJI_MODIFIER_BASE : case UCHAR_EMOJI_MODIFIER : case UCHAR_EMOJI_PRESENTATION : #if U_ICU_VERSION_MAJOR_NUM >= 62 case UCHAR_EXTENDED_PICTOGRAPHIC : #endif case UCHAR_EXTENDER : case UCHAR_GRAPHEME_BASE : case UCHAR_GRAPHEME_EXTEND : case UCHAR_HEX_DIGIT : case UCHAR_ID_CONTINUE : case UCHAR_ID_START : case UCHAR_IDEOGRAPHIC : case UCHAR_IDS_BINARY_OPERATOR : case UCHAR_IDS_TRINARY_OPERATOR : case UCHAR_JOIN_CONTROL : case UCHAR_LOGICAL_ORDER_EXCEPTION : case UCHAR_LOWERCASE : case UCHAR_MATH : case UCHAR_NONCHARACTER_CODE_POINT : case UCHAR_PATTERN_SYNTAX : case UCHAR_PATTERN_WHITE_SPACE : case UCHAR_QUOTATION_MARK : case UCHAR_RADICAL : #if U_ICU_VERSION_MAJOR_NUM >= 60 case UCHAR_REGIONAL_INDICATOR : #endif case UCHAR_S_TERM : case UCHAR_SOFT_DOTTED : case UCHAR_TERMINAL_PUNCTUATION : case UCHAR_UNIFIED_IDEOGRAPH : case UCHAR_UPPERCASE : case UCHAR_VARIATION_SELECTOR : case UCHAR_WHITE_SPACE : case UCHAR_XID_CONTINUE : case UCHAR_XID_START : return true ; default : break ; } return false ; }
tt_loader_init ( TT_Loader loader , TT_Size size , TT_GlyphSlot glyph , FT_Int32 load_flags , FT_Bool glyf_table_only ) { FT_Error error ; TT_Face face ; FT_Stream stream ; #ifdef TT_USE_BYTECODE_INTERPRETER FT_Bool pedantic = FT_BOOL ( load_flags & FT_LOAD_PEDANTIC ) ; #endif face = ( TT_Face ) glyph -> face ; stream = face -> root . stream ; FT_MEM_ZERO ( loader , sizeof ( TT_LoaderRec ) ) ; #ifdef TT_USE_BYTECODE_INTERPRETER if ( IS_HINTED ( load_flags ) && ! glyf_table_only ) { TT_ExecContext exec ; FT_Bool grayscale ; #ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING TT_Driver driver = ( TT_Driver ) FT_FACE_DRIVER ( face ) ; FT_Bool subpixel_hinting = FALSE ; #if 0 FT_Bool compatible_widths ; FT_Bool symmetrical_smoothing ; FT_Bool bgr ; FT_Bool vertical_lcd ; FT_Bool subpixel_positioned ; FT_Bool gray_cleartype ; #endif #endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */ FT_Bool reexecute = FALSE ; if ( size -> bytecode_ready < 0 || size -> cvt_ready < 0 ) { error = tt_size_ready_bytecode ( size , pedantic ) ; if ( error ) return error ; } else if ( size -> bytecode_ready ) return size -> bytecode_ready ; else if ( size -> cvt_ready ) return size -> cvt_ready ; exec = size -> context ; if ( ! exec ) return FT_THROW ( Could_Not_Find_Context ) ; #ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING if ( driver -> interpreter_version == TT_INTERPRETER_VERSION_38 ) { subpixel_hinting = FT_BOOL ( ( FT_LOAD_TARGET_MODE ( load_flags ) != FT_RENDER_MODE_MONO ) && SPH_OPTION_SET_SUBPIXEL ) ; if ( subpixel_hinting ) grayscale = FALSE ; else if ( SPH_OPTION_SET_GRAYSCALE ) { grayscale = TRUE ; subpixel_hinting = FALSE ; } else grayscale = FALSE ; if ( FT_IS_TRICKY ( glyph -> face ) ) subpixel_hinting = FALSE ; exec -> ignore_x_mode = subpixel_hinting || grayscale ; exec -> rasterizer_version = SPH_OPTION_SET_RASTERIZER_VERSION ; if ( exec -> sph_tweak_flags & SPH_TWEAK_RASTERIZER_35 ) exec -> rasterizer_version = TT_INTERPRETER_VERSION_35 ; #if 1 exec -> compatible_widths = SPH_OPTION_SET_COMPATIBLE_WIDTHS ; exec -> symmetrical_smoothing = TRUE ; exec -> bgr = FALSE ; exec -> vertical_lcd = FALSE ; exec -> subpixel_positioned = TRUE ; exec -> gray_cleartype = FALSE ; #else /* 0 */ exec -> compatible_widths = FT_BOOL ( FT_LOAD_TARGET_MODE ( load_flags ) != TT_LOAD_COMPATIBLE_WIDTHS ) ; exec -> symmetrical_smoothing = FT_BOOL ( FT_LOAD_TARGET_MODE ( load_flags ) != TT_LOAD_SYMMETRICAL_SMOOTHING ) ; exec -> bgr = FT_BOOL ( FT_LOAD_TARGET_MODE ( load_flags ) != TT_LOAD_BGR ) ; exec -> vertical_lcd = FT_BOOL ( FT_LOAD_TARGET_MODE ( load_flags ) != TT_LOAD_VERTICAL_LCD ) ; exec -> subpixel_positioned = FT_BOOL ( FT_LOAD_TARGET_MODE ( load_flags ) != TT_LOAD_SUBPIXEL_POSITIONED ) ; exec -> gray_cleartype = FT_BOOL ( FT_LOAD_TARGET_MODE ( load_flags ) != TT_LOAD_GRAY_CLEARTYPE ) ; #endif /* 0 */ } else #endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */ { grayscale = FT_BOOL ( FT_LOAD_TARGET_MODE ( load_flags ) != FT_RENDER_MODE_MONO ) ; } error = TT_Load_Context ( exec , face , size ) ; if ( error ) return error ; #ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING if ( driver -> interpreter_version == TT_INTERPRETER_VERSION_38 ) { if ( subpixel_hinting != exec -> subpixel_hinting ) { FT_TRACE4 ( ( "tt_loader_init: subpixel hinting change," " re-executing `prep' table\n" ) ) ; exec -> subpixel_hinting = subpixel_hinting ; reexecute = TRUE ; } if ( grayscale != exec -> grayscale ) { FT_TRACE4 ( ( "tt_loader_init: grayscale hinting change," " re-executing `prep' table\n" ) ) ; exec -> grayscale = grayscale ; reexecute = TRUE ; } } else #endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */ { if ( grayscale != exec -> grayscale ) { FT_TRACE4 ( ( "tt_loader_init: grayscale hinting change," " re-executing `prep' table\n" ) ) ; exec -> grayscale = grayscale ; reexecute = TRUE ; } } if ( reexecute ) { FT_UInt i ; for ( i = 0 ; i < size -> cvt_size ; i ++ ) size -> cvt [ i ] = FT_MulFix ( face -> cvt [ i ] , size -> ttmetrics . scale ) ; error = tt_size_run_prep ( size , pedantic ) ; if ( error ) return error ; } if ( exec -> GS . instruct_control & 1 ) load_flags |= FT_LOAD_NO_HINTING ; if ( exec -> GS . instruct_control & 2 ) exec -> GS = tt_default_graphics_state ; #ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING if ( exec -> GS . instruct_control & 4 ) exec -> ignore_x_mode = 0 ; #endif exec -> pedantic_hinting = FT_BOOL ( load_flags & FT_LOAD_PEDANTIC ) ; loader -> exec = exec ; loader -> instructions = exec -> glyphIns ; } #endif /* TT_USE_BYTECODE_INTERPRETER */ #ifdef FT_CONFIG_OPTION_INCREMENTAL if ( face -> root . internal -> incremental_interface ) loader -> glyf_offset = 0 ; else #endif { error = face -> goto_table ( face , TTAG_glyf , stream , 0 ) ; if ( FT_ERR_EQ ( error , Table_Missing ) ) loader -> glyf_offset = 0 ; else if ( error ) { FT_ERROR ( ( "tt_loader_init: could not access glyph table\n" ) ) ; return error ; } else loader -> glyf_offset = FT_STREAM_POS ( ) ; } if ( ! glyf_table_only ) { FT_GlyphLoader gloader = glyph -> internal -> loader ; FT_GlyphLoader_Rewind ( gloader ) ; loader -> gloader = gloader ; } loader -> load_flags = ( FT_ULong ) load_flags ; loader -> face = ( FT_Face ) face ; loader -> size = ( FT_Size ) size ; loader -> glyph = ( FT_GlyphSlot ) glyph ; loader -> stream = stream ; return FT_Err_Ok ; }
nsXBLBinding :: DoInitJSClass ( JSContext * cx , JS :: Handle < JSObject * > obj , const nsAFlatCString & aClassName , nsXBLPrototypeBinding * aProtoBinding , JS :: MutableHandle < JSObject * > aClassObject , bool * aNew ) { nsAutoCString className ( aClassName ) ; nsAutoCString xblKey ( aClassName ) ; JS :: RootedObject global ( cx , js :: GetGlobalForObjectCrossCompartment ( obj ) ) ; JSAutoCompartment ac ( cx , global ) ; JS :: Rooted < JSObject * > parent_proto ( cx , nullptr ) ; nsXBLJSClass * c = nullptr ; if ( obj ) { if ( ! JS_GetPrototype ( cx , obj , & parent_proto ) ) { return NS_ERROR_FAILURE ; } if ( parent_proto ) { JS :: Rooted < jsid > parent_proto_id ( cx ) ; if ( ! :: JS_GetObjectId ( cx , parent_proto , & parent_proto_id ) ) { return NS_ERROR_OUT_OF_MEMORY ; } char buf [ 20 ] ; if ( sizeof ( jsid ) == 4 ) { PR_snprintf ( buf , sizeof ( buf ) , " %lx" , parent_proto_id . get ( ) ) ; } else { MOZ_ASSERT ( sizeof ( jsid ) == 8 ) ; PR_snprintf ( buf , sizeof ( buf ) , " %llx" , parent_proto_id . get ( ) ) ; } xblKey . Append ( buf ) ; c = nsXBLService :: getClass ( xblKey ) ; if ( c ) { className . Assign ( c -> name ) ; } else { char buf [ 20 ] ; PR_snprintf ( buf , sizeof ( buf ) , " %llx" , nsXBLJSClass :: NewId ( ) ) ; className . Append ( buf ) ; } } } JS :: Rooted < JSObject * > proto ( cx ) ; JS :: Rooted < JS :: Value > val ( cx ) ; if ( ! :: JS_LookupPropertyWithFlags ( cx , global , className . get ( ) , 0 , & val ) ) return NS_ERROR_OUT_OF_MEMORY ; if ( val . isObject ( ) ) { * aNew = false ; proto = & val . toObject ( ) ; } else { * aNew = true ; if ( ! c ) { c = nsXBLService :: getClass ( xblKey ) ; } if ( c ) { if ( c -> isInList ( ) ) { c -> remove ( ) ; nsXBLService :: gClassLRUListLength -- ; } } else { if ( nsXBLService :: gClassLRUList -> isEmpty ( ) ) { c = new nsXBLJSClass ( className , xblKey ) ; } else { c = nsXBLService :: gClassLRUList -> popFirst ( ) ; nsXBLService :: gClassLRUListLength -- ; nsXBLService :: gClassTable -> Remove ( c -> Key ( ) ) ; nsMemory :: Free ( ( void * ) c -> name ) ; c -> name = ToNewCString ( className ) ; c -> SetKey ( xblKey ) ; } nsXBLService :: gClassTable -> Put ( xblKey , c ) ; } c -> Hold ( ) ; proto = :: JS_InitClass ( cx , global , parent_proto , c , nullptr , 0 , nullptr , nullptr , nullptr , nullptr ) ; if ( ! proto ) { nsXBLService :: gClassTable -> Remove ( xblKey ) ; c -> Drop ( ) ; return NS_ERROR_OUT_OF_MEMORY ; } nsXBLDocumentInfo * docInfo = aProtoBinding -> XBLDocumentInfo ( ) ; :: JS_SetPrivate ( proto , docInfo ) ; NS_ADDREF ( docInfo ) ; :: JS_SetReservedSlot ( proto , 0 , PRIVATE_TO_JSVAL ( aProtoBinding ) ) ; } aClassObject . set ( proto ) ; if ( obj ) { if ( ! :: JS_SetPrototype ( cx , obj , proto ) ) { return NS_ERROR_FAILURE ; } } return NS_OK ; }
status_t AudioPolicyMixCollection :: getInputMixForAttr ( audio_attributes_t attr , AudioMix * * policyMix ) { if ( strncmp ( attr . tags , "addr=" , strlen ( "addr=" ) ) != 0 ) { return BAD_VALUE ; } String8 address ( attr . tags + strlen ( "addr=" ) ) ; #ifdef LOG_NDEBUG ALOGV ( "getInputMixForAttr looking for address %s\n  mixes available:" , address . string ( ) ) ; for ( size_t i = 0 ; i < size ( ) ; i ++ ) { sp < AudioPolicyMix > policyMix = valueAt ( i ) ; AudioMix * mix = policyMix -> getMix ( ) ; ALOGV ( "\tmix %zu address=%s" , i , mix -> mDeviceAddress . string ( ) ) ; } #endif ssize_t index = indexOfKey ( address ) ; if ( index < 0 ) { ALOGW ( "getInputMixForAttr() no policy for address %s" , address . string ( ) ) ; return BAD_VALUE ; } sp < AudioPolicyMix > audioPolicyMix = valueAt ( index ) ; AudioMix * mix = audioPolicyMix -> getMix ( ) ; if ( mix -> mMixType != MIX_TYPE_PLAYERS ) { ALOGW ( "getInputMixForAttr() bad policy mix type for address %s" , address . string ( ) ) ; return BAD_VALUE ; } * policyMix = mix ; return NO_ERROR ; }
Status GetInitOp ( const string & export_dir , const MetaGraphDef & meta_graph_def , string * init_op_name ) { const auto & sig_def_map = meta_graph_def . signature_def ( ) ; const auto & init_op_sig_it = meta_graph_def . signature_def ( ) . find ( kSavedModelInitOpSignatureKey ) ; if ( init_op_sig_it != sig_def_map . end ( ) ) { * init_op_name = init_op_sig_it -> second . outputs ( ) . find ( kSavedModelInitOpSignatureKey ) -> second . name ( ) ; return Status :: OK ( ) ; } const auto & collection_def_map = meta_graph_def . collection_def ( ) ; string init_op_collection_key ; if ( collection_def_map . find ( kSavedModelMainOpKey ) != collection_def_map . end ( ) ) { init_op_collection_key = kSavedModelMainOpKey ; } else { init_op_collection_key = kSavedModelLegacyInitOpKey ; } const auto init_op_it = collection_def_map . find ( init_op_collection_key ) ; if ( init_op_it != collection_def_map . end ( ) ) { if ( init_op_it -> second . node_list ( ) . value_size ( ) != 1 ) { return errors :: FailedPrecondition ( strings :: StrCat ( "Expected exactly one main op in : " , export_dir ) ) ; } * init_op_name = init_op_it -> second . node_list ( ) . value ( 0 ) ; } return Status :: OK ( ) ; }
void DecodeExceptionSection ( ) { uint32_t exception_count = consume_count ( "exception count" , kV8MaxWasmExceptions ) ; for ( uint32_t i = 0 ; ok ( ) && i < exception_count ; ++ i ) { TRACE ( "DecodeExceptionSignature[%d] module+%d\n" , i , static_cast < int > ( pc_ - start_ ) ) ; module_ -> exceptions . emplace_back ( consume_exception_sig ( module_ -> signature_zone . get ( ) ) ) ; } }
_XkbSetDeviceInfo ( ClientPtr client , DeviceIntPtr dev , xkbSetDeviceInfoReq * stuff ) { char * wire ; wire = ( char * ) & stuff [ 1 ] ; if ( stuff -> change & XkbXI_ButtonActionsMask ) { if ( ! dev -> button ) { client -> errorValue = _XkbErrCode2 ( XkbErr_BadClass , ButtonClass ) ; return XkbKeyboardErrorCode ; } if ( ( stuff -> firstBtn + stuff -> nBtns ) > dev -> button -> numButtons ) { client -> errorValue = _XkbErrCode4 ( 0x02 , stuff -> firstBtn , stuff -> nBtns , dev -> button -> numButtons ) ; return BadMatch ; } wire += ( stuff -> nBtns * SIZEOF ( xkbActionWireDesc ) ) ; } if ( stuff -> change & XkbXI_IndicatorsMask ) { int status = Success ; wire = CheckSetDeviceIndicators ( wire , dev , stuff -> nDeviceLedFBs , & status , client ) ; if ( status != Success ) return status ; } if ( ( ( wire - ( ( char * ) stuff ) ) / 4 ) != stuff -> length ) return BadLength ; return Success ; }
R_API ut8 * r_bin_java_get_attr_buf ( RBinJavaObj * bin , ut64 sz , const ut64 offset , const ut8 * buf , const ut64 len ) { ut8 * attr_buf = NULL ; int pending = len - offset ; const ut8 * a_buf = offset + buf ; attr_buf = ( ut8 * ) calloc ( pending + 1 , 1 ) ; if ( ! attr_buf ) { eprintf ( "Unable to allocate enough bytes (0x%04"PFMT64x ") to read in the attribute.\n" , sz ) ; return attr_buf ; } memcpy ( attr_buf , a_buf , pending ) ; return attr_buf ; }
ssize_t CryptoHal :: decrypt ( const uint8_t keyId [ 16 ] , const uint8_t iv [ 16 ] , CryptoPlugin :: Mode mode , const CryptoPlugin :: Pattern & pattern , const ICrypto :: SourceBuffer & source , size_t offset , const CryptoPlugin :: SubSample * subSamples , size_t numSubSamples , const ICrypto :: DestinationBuffer & destination , AString * errorDetailMsg ) { Mutex :: Autolock autoLock ( mLock ) ; if ( mInitCheck != OK ) { return mInitCheck ; } Mode hMode ; switch ( mode ) { case CryptoPlugin :: kMode_Unencrypted : hMode = Mode :: UNENCRYPTED ; break ; case CryptoPlugin :: kMode_AES_CTR : hMode = Mode :: AES_CTR ; break ; case CryptoPlugin :: kMode_AES_WV : hMode = Mode :: AES_CBC_CTS ; break ; case CryptoPlugin :: kMode_AES_CBC : hMode = Mode :: AES_CBC ; break ; default : return UNKNOWN_ERROR ; } Pattern hPattern ; hPattern . encryptBlocks = pattern . mEncryptBlocks ; hPattern . skipBlocks = pattern . mSkipBlocks ; std :: vector < SubSample > stdSubSamples ; for ( size_t i = 0 ; i < numSubSamples ; i ++ ) { SubSample subSample ; subSample . numBytesOfClearData = subSamples [ i ] . mNumBytesOfClearData ; subSample . numBytesOfEncryptedData = subSamples [ i ] . mNumBytesOfEncryptedData ; stdSubSamples . push_back ( subSample ) ; } auto hSubSamples = hidl_vec < SubSample > ( stdSubSamples ) ; int32_t heapSeqNum = source . mHeapSeqNum ; bool secure ; :: DestinationBuffer hDestination ; if ( destination . mType == kDestinationTypeSharedMemory ) { hDestination . type = BufferType :: SHARED_MEMORY ; status_t status = toSharedBuffer ( destination . mSharedMemory , heapSeqNum , & hDestination . nonsecureMemory ) ; if ( status != OK ) { return status ; } secure = false ; } else { hDestination . type = BufferType :: NATIVE_HANDLE ; hDestination . secureMemory = hidl_handle ( destination . mHandle ) ; secure = true ; } :: SharedBuffer hSource ; status_t status = toSharedBuffer ( source . mSharedMemory , heapSeqNum , & hSource ) ; if ( status != OK ) { return status ; } status_t err = UNKNOWN_ERROR ; uint32_t bytesWritten = 0 ; Return < void > hResult = mPlugin -> decrypt ( secure , toHidlArray16 ( keyId ) , toHidlArray16 ( iv ) , hMode , hPattern , hSubSamples , hSource , offset , hDestination , [ & ] ( Status status , uint32_t hBytesWritten , hidl_string hDetailedError ) { if ( status == Status :: OK ) { bytesWritten = hBytesWritten ; * errorDetailMsg = toString8 ( hDetailedError ) ; } err = toStatusT ( status ) ; } ) ; if ( ! hResult . isOk ( ) ) { err = DEAD_OBJECT ; } if ( err == OK ) { return bytesWritten ; } return err ; }
BUILTIN ( DatePrototypeSetUTCMinutes ) { HandleScope scope ( isolate ) ; CHECK_RECEIVER ( JSDate , date , "Date.prototype.setUTCMinutes" ) ; int const argc = args . length ( ) - 1 ; Handle < Object > min = args . atOrUndefined ( isolate , 1 ) ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , min , Object :: ToNumber ( isolate , min ) ) ; double time_val = date -> value ( ) -> Number ( ) ; if ( ! std :: isnan ( time_val ) ) { int64_t const time_ms = static_cast < int64_t > ( time_val ) ; int day = isolate -> date_cache ( ) -> DaysFromTime ( time_ms ) ; int time_within_day = isolate -> date_cache ( ) -> TimeInDay ( time_ms , day ) ; int h = time_within_day / ( 60 * 60 * 1000 ) ; double m = min -> Number ( ) ; double s = ( time_within_day / 1000 ) % 60 ; double milli = time_within_day % 1000 ; if ( argc >= 2 ) { Handle < Object > sec = args . at ( 2 ) ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , sec , Object :: ToNumber ( isolate , sec ) ) ; s = sec -> Number ( ) ; if ( argc >= 3 ) { Handle < Object > ms = args . at ( 3 ) ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , ms , Object :: ToNumber ( isolate , ms ) ) ; milli = ms -> Number ( ) ; } } time_val = MakeDate ( day , MakeTime ( h , m , s , milli ) ) ; } return * JSDate :: SetValue ( date , DateCache :: TimeClip ( time_val ) ) ; }
void l2cu_send_peer_config_rej ( tL2C_CCB * p_ccb , uint8_t * p_data , uint16_t data_len , uint16_t rej_len ) { uint16_t len , cfg_len , buf_space , len1 ; uint8_t * p , * p_hci_len , * p_data_end ; uint8_t cfg_code ; L2CAP_TRACE_DEBUG ( "l2cu_send_peer_config_rej: data_len=%d, rej_len=%d" , data_len , rej_len ) ; len = BT_HDR_SIZE + HCI_DATA_PREAMBLE_SIZE + L2CAP_PKT_OVERHEAD + L2CAP_CMD_OVERHEAD + L2CAP_CONFIG_RSP_LEN ; len1 = 0xFFFF - len ; if ( rej_len > len1 ) { L2CAP_TRACE_ERROR ( "L2CAP - cfg_rej pkt size exceeds buffer design max limit." ) ; return ; } BT_HDR * p_buf = ( BT_HDR * ) osi_malloc ( len + rej_len ) ; p_buf -> offset = L2CAP_SEND_CMD_OFFSET ; p = ( uint8_t * ) ( p_buf + 1 ) + L2CAP_SEND_CMD_OFFSET ; #if (L2CAP_NON_FLUSHABLE_PB_INCLUDED == TRUE) if ( HCI_NON_FLUSHABLE_PB_SUPPORTED ( BTM_ReadLocalFeatures ( ) ) ) { UINT16_TO_STREAM ( p , ( p_ccb -> p_lcb -> handle | ( L2CAP_PKT_START_NON_FLUSHABLE < < L2CAP_PKT_TYPE_SHIFT ) ) ) ; } else #endif { UINT16_TO_STREAM ( p , ( p_ccb -> p_lcb -> handle | ( L2CAP_PKT_START < < L2CAP_PKT_TYPE_SHIFT ) ) ) ; } p_hci_len = p ; p += 2 ; UINT16_TO_STREAM ( p , L2CAP_CMD_OVERHEAD + L2CAP_CONFIG_RSP_LEN + rej_len ) ; UINT16_TO_STREAM ( p , L2CAP_SIGNALLING_CID ) ; UINT8_TO_STREAM ( p , L2CAP_CMD_CONFIG_RSP ) ; UINT8_TO_STREAM ( p , p_ccb -> remote_id ) ; UINT16_TO_STREAM ( p , L2CAP_CONFIG_RSP_LEN + rej_len ) ; UINT16_TO_STREAM ( p , p_ccb -> remote_cid ) ; UINT16_TO_STREAM ( p , 0 ) ; UINT16_TO_STREAM ( p , L2CAP_CFG_UNKNOWN_OPTIONS ) ; buf_space = rej_len ; p_data_end = p_data + data_len ; while ( p_data < p_data_end ) { cfg_code = * p_data ; cfg_len = * ( p_data + 1 ) ; switch ( cfg_code & 0x7F ) { case L2CAP_CFG_TYPE_MTU : case L2CAP_CFG_TYPE_FLUSH_TOUT : case L2CAP_CFG_TYPE_QOS : p_data += cfg_len + L2CAP_CFG_OPTION_OVERHEAD ; break ; default : if ( ( cfg_len + L2CAP_CFG_OPTION_OVERHEAD ) <= data_len ) { if ( ( cfg_code & 0x80 ) == 0 ) { if ( buf_space >= ( cfg_len + L2CAP_CFG_OPTION_OVERHEAD ) ) { memcpy ( p , p_data , cfg_len + L2CAP_CFG_OPTION_OVERHEAD ) ; p += cfg_len + L2CAP_CFG_OPTION_OVERHEAD ; buf_space -= ( cfg_len + L2CAP_CFG_OPTION_OVERHEAD ) ; } else { L2CAP_TRACE_WARNING ( "L2CAP - cfg_rej exceeds allocated buffer" ) ; p_data = p_data_end ; break ; } } p_data += cfg_len + L2CAP_CFG_OPTION_OVERHEAD ; } else { p_data = p_data_end ; } break ; } } len = ( uint16_t ) ( p - p_hci_len - 2 ) ; UINT16_TO_STREAM ( p_hci_len , len ) ; p_buf -> len = len + 4 ; L2CAP_TRACE_DEBUG ( "L2CAP - cfg_rej pkt hci_len=%d, l2cap_len=%d" , len , ( L2CAP_CMD_OVERHEAD + L2CAP_CONFIG_RSP_LEN + rej_len ) ) ; l2c_link_check_send_pkts ( p_ccb -> p_lcb , NULL , p_buf ) ; }
void IncrementalMarking :: MarkRoots ( ) { DCHECK ( ! finalize_marking_completed_ ) ; DCHECK ( IsMarking ( ) ) ; IncrementalMarkingRootMarkingVisitor visitor ( this ) ; heap_ -> IterateStrongRoots ( & visitor , VISIT_ONLY_STRONG ) ; }
static void Generate_InterpreterPushArgs ( MacroAssembler * masm , Register num_args , Register index , Register scratch , Register scratch2 ) { __ mov ( scratch2 , num_args ) ; __ dsll ( scratch2 , scratch2 , kPointerSizeLog2 ) ; __ Dsubu ( scratch2 , index , Operand ( scratch2 ) ) ; Label loop_header , loop_check ; __ Branch ( & loop_check ) ; __ bind ( & loop_header ) ; __ Ld ( scratch , MemOperand ( index ) ) ; __ Daddu ( index , index , Operand ( - kPointerSize ) ) ; __ push ( scratch ) ; __ bind ( & loop_check ) ; __ Branch ( & loop_header , gt , index , Operand ( scratch2 ) ) ; }
IDBCursor :: GetValue ( JSContext * aCx , ErrorResult & aRv ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; MOZ_ASSERT ( mType == OBJECTSTORE || mType == INDEXOBJECT ) ; if ( ! mHaveValue ) { return JSVAL_VOID ; } if ( ! mHaveCachedValue ) { if ( ! mRooted ) { mozilla :: HoldJSObjects ( this ) ; mRooted = true ; } JS :: Rooted < JS :: Value > val ( aCx ) ; if ( ! IDBObjectStore :: DeserializeValue ( aCx , mCloneReadInfo , & val ) ) { aRv . Throw ( NS_ERROR_DOM_DATA_CLONE_ERR ) ; return JSVAL_VOID ; } mCloneReadInfo . mCloneBuffer . clear ( ) ; mCachedValue = val ; mHaveCachedValue = true ; } return mCachedValue ; }
inline TfLiteTensor * GetMutableInput ( const TfLiteContext * context , const TfLiteNode * node , int index ) { if ( context -> tensors != nullptr ) { return & context -> tensors [ node -> inputs -> data [ index ] ] ; } else { return context -> GetTensor ( context , node -> inputs -> data [ index ] ) ; } }
MediaKeyMessageEvent :: GetMessage ( JSContext * cx , ErrorResult & aRv ) { if ( ! mMessage ) { mMessage = Uint8Array :: Create ( cx , this , mRawMessage . Length ( ) , mRawMessage . Elements ( ) ) ; if ( ! mMessage ) { aRv . Throw ( NS_ERROR_OUT_OF_MEMORY ) ; return nullptr ; } mRawMessage . Clear ( ) ; } JS :: ExposeObjectToActiveJS ( mMessage ) ; return mMessage ; }
void vp9_denoise ( const YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst , int q ) { const int ppl = ( int ) ( 6.0e-05 * q * q * q - 0.0067 * q * q + 0.306 * q + 0.0065 + 0.5 ) ; int i ; const uint8_t * const srcs [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , src -> alpha_buffer } ; const int src_strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , src -> alpha_stride } ; const int src_widths [ 4 ] = { src -> y_width , src -> uv_width , src -> uv_width , src -> alpha_width } ; const int src_heights [ 4 ] = { src -> y_height , src -> uv_height , src -> uv_height , src -> alpha_height } ; uint8_t * const dsts [ 4 ] = { dst -> y_buffer , dst -> u_buffer , dst -> v_buffer , dst -> alpha_buffer } ; const int dst_strides [ 4 ] = { dst -> y_stride , dst -> uv_stride , dst -> uv_stride , dst -> alpha_stride } ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { const int src_stride = src_strides [ i ] ; const uint8_t * const src = srcs [ i ] + 2 * src_stride + 2 ; const int src_width = src_widths [ i ] - 4 ; const int src_height = src_heights [ i ] - 4 ; const int dst_stride = dst_strides [ i ] ; uint8_t * const dst = dsts [ i ] + 2 * dst_stride + 2 ; vp9_post_proc_down_and_across ( src , dst , src_stride , dst_stride , src_height , src_width , ppl ) ; } }
static void TailCallRuntimeIfMarkerEquals ( MacroAssembler * masm , Register smi_entry , OptimizationMarker marker , Runtime :: FunctionId function_id ) { Label no_match ; __ CompareAndBranch ( smi_entry , Operand ( Smi :: FromEnum ( marker ) ) , ne , & no_match ) ; GenerateTailCallToReturnedCode ( masm , function_id ) ; __ bind ( & no_match ) ; }
void TracingCpuProfilerImpl :: StartProfiling ( ) { base :: LockGuard < base :: Mutex > lock ( & mutex_ ) ; if ( ! profiling_enabled_ || profiler_ ) return ; bool enabled ; TRACE_EVENT_CATEGORY_GROUP_ENABLED ( TRACE_DISABLED_BY_DEFAULT ( "v8.cpu_profiler.hires" ) , & enabled ) ; int sampling_interval_us = enabled ? 100 : 1000 ; profiler_ . reset ( new CpuProfiler ( isolate_ ) ) ; profiler_ -> set_sampling_interval ( base :: TimeDelta :: FromMicroseconds ( sampling_interval_us ) ) ; profiler_ -> StartProfiling ( "" , true ) ; }
jp2_box_t * jp2_box_create ( int type ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { return 0 ; } memset ( box , 0 , sizeof ( jp2_box_t ) ) ; box -> type = type ; box -> len = 0 ; if ( ! ( boxinfo = jp2_boxinfolookup ( type ) ) ) { return 0 ; } box -> info = boxinfo ; box -> ops = & boxinfo -> ops ; return box ; }
void test_base64_lengths ( void ) { const char * in = "FuseMuse" ; char out1 [ 32 ] ; char out2 [ 32 ] ; size_t enclen ; int declen ; enclen = mutt_b64_encode ( out1 , in , 0 , 32 ) ; if ( ! TEST_CHECK ( enclen == 0 ) ) { TEST_MSG ( "Expected: %zu" , 0 ) ; TEST_MSG ( "Actual  : %zu" , enclen ) ; } out1 [ 0 ] = '\0' ; declen = mutt_b64_decode ( out2 , out1 ) ; if ( ! TEST_CHECK ( declen == - 1 ) ) { TEST_MSG ( "Expected: %zu" , - 1 ) ; TEST_MSG ( "Actual  : %zu" , declen ) ; } for ( size_t i = 1 ; i <= 8 ; ++ i ) { enclen = mutt_b64_encode ( out1 , in , i , 32 ) ; size_t exp = ( ( i + 2 ) / 3 ) < < 2 ; if ( ! TEST_CHECK ( enclen == exp ) ) { TEST_MSG ( "Expected: %zu" , exp ) ; TEST_MSG ( "Actual  : %zu" , enclen ) ; } declen = mutt_b64_decode ( out2 , out1 ) ; if ( ! TEST_CHECK ( declen == i ) ) { TEST_MSG ( "Expected: %zu" , i ) ; TEST_MSG ( "Actual  : %zu" , declen ) ; } out2 [ declen ] = '\0' ; if ( ! TEST_CHECK ( strncmp ( out2 , in , i ) == 0 ) ) { TEST_MSG ( "Expected: %s" , in ) ; TEST_MSG ( "Actual  : %s" , out2 ) ; } } }
DocInfo :: PrincipalURL ( ) const { if ( ! URL ( ) . InheritsPrincipal ( ) || ! ( Principal ( ) && Principal ( ) -> GetIsCodebasePrincipal ( ) ) ) { return URL ( ) ; } if ( mPrincipalURL . isNothing ( ) ) { nsIPrincipal * prin = Principal ( ) ; nsCOMPtr < nsIURI > uri ; if ( NS_SUCCEEDED ( prin -> GetURI ( getter_AddRefs ( uri ) ) ) ) { MOZ_DIAGNOSTIC_ASSERT ( uri ) ; mPrincipalURL . emplace ( uri ) ; } else { mPrincipalURL . emplace ( URL ( ) ) ; } } return mPrincipalURL . ref ( ) ; }
tt_cmap8_char_next ( TT_CMap cmap , FT_UInt32 * pchar_code ) { FT_UInt32 result = 0 ; FT_UInt32 char_code = * pchar_code + 1 ; FT_UInt gindex = 0 ; FT_Byte * table = cmap -> data ; FT_Byte * p = table + 8204 ; FT_UInt32 num_groups = TT_NEXT_ULONG ( p ) ; FT_UInt32 start , end , start_id ; p = table + 8208 ; for ( ; num_groups > 0 ; num_groups -- ) { start = TT_NEXT_ULONG ( p ) ; end = TT_NEXT_ULONG ( p ) ; start_id = TT_NEXT_ULONG ( p ) ; if ( char_code < start ) char_code = start ; if ( char_code <= end ) { gindex = ( FT_UInt ) ( char_code - start + start_id ) ; if ( gindex != 0 ) { result = char_code ; goto Exit ; } } } Exit : * pchar_code = result ; return gindex ; }
CrossProcessCompositorParent :: AllocPLayerTransactionParent ( const nsTArray < LayersBackend > & , const uint64_t & aId , TextureFactoryIdentifier * aTextureFactoryIdentifier , bool * aSuccess ) { MOZ_ASSERT ( aId != 0 ) ; CompositorParent :: LayerTreeState * state = nullptr ; LayerTreeMap :: iterator itr = sIndirectLayerTrees . find ( aId ) ; if ( sIndirectLayerTrees . end ( ) != itr ) { state = & itr -> second ; } if ( state && state -> mLayerManager ) { state -> mCrossProcessParent = this ; LayerManagerComposite * lm = state -> mLayerManager ; * aTextureFactoryIdentifier = lm -> GetCompositor ( ) -> GetTextureFactoryIdentifier ( ) ; * aSuccess = true ; LayerTransactionParent * p = new LayerTransactionParent ( lm , this , aId , mChildProcessId ) ; p -> AddIPDLReference ( ) ; sIndirectLayerTrees [ aId ] . mLayerTree = p ; return p ; } NS_WARNING ( "Created child without a matching parent?" ) ; * aSuccess = true ; LayerTransactionParent * p = new LayerTransactionParent ( nullptr , this , aId , mChildProcessId ) ; p -> AddIPDLReference ( ) ; return p ; }
Status TensorSliceReader :: GetTensor ( const string & name , std :: unique_ptr < tensorflow :: Tensor > * out_tensor ) const { DataType type ; TensorShape shape ; TensorSlice slice ; { mutex_lock l ( mu_ ) ; const TensorSliceSet * tss = gtl :: FindPtrOrNull ( tensors_ , name ) ; if ( tss == nullptr ) { return errors :: NotFound ( name , " not found in checkpoint file" ) ; } if ( tss -> Slices ( ) . size ( ) > 1 ) { return errors :: Unimplemented ( "Sliced checkpoints are not supported" ) ; } type = tss -> type ( ) ; shape = tss -> shape ( ) ; slice = tss -> Slices ( ) . begin ( ) -> second . slice ; } std :: unique_ptr < tensorflow :: Tensor > t ( new tensorflow :: Tensor ( type , shape ) ) ; bool success = false ; #define READER_COPY(dt)                                                  \   case dt:                                                               \     success = CopySliceData(name, slice,                                 \                             t->flat<EnumToDataType<dt>::Type>().data()); \     break; switch ( type ) { READER_COPY ( DT_FLOAT ) ; READER_COPY ( DT_DOUBLE ) ; READER_COPY ( DT_INT32 ) ; READER_COPY ( DT_UINT8 ) ; READER_COPY ( DT_INT16 ) ; READER_COPY ( DT_INT8 ) ; READER_COPY ( DT_INT64 ) ; READER_COPY ( DT_STRING ) ; default : return errors :: Unimplemented ( "Data type not supported" ) ; } #undef READER_COPY if ( ! success ) { return errors :: NotFound ( name , " not found in checkpoint file" ) ; } std :: swap ( * out_tensor , t ) ; return Status :: OK ( ) ; }
TfLiteStatus L2Eval ( TfLiteContext * context , TfLiteNode * node ) { auto * params = reinterpret_cast < TfLitePoolParams * > ( node -> builtin_data ) ; OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; TfLiteTensor * output = GetOutput ( context , node , 0 ) ; const TfLiteTensor * input = GetInput ( context , node , 0 ) ; switch ( input -> type ) { case kTfLiteFloat32 : L2EvalFloat < kernel_type > ( context , node , params , data , input , output ) ; break ; case kTfLiteUInt8 : default : context -> ReportError ( context , "Type %d not currently supported." , input -> type ) ; return kTfLiteError ; } return kTfLiteOk ; }
void InterpreterAssembler :: UpdateInterruptBudget ( Node * weight , bool backward ) { Comment ( "[ UpdateInterruptBudget" ) ; Node * budget_offset = IntPtrConstant ( BytecodeArray :: kInterruptBudgetOffset - kHeapObjectTag ) ; CSA_ASSERT ( this , Int32GreaterThanOrEqual ( weight , Int32Constant ( 0 ) ) ) ; Variable new_budget ( this , MachineRepresentation :: kWord32 ) ; Node * old_budget = Load ( MachineType :: Int32 ( ) , BytecodeArrayTaggedPointer ( ) , budget_offset ) ; Node * budget_after_bytecode = Int32Sub ( old_budget , Int32Constant ( CurrentBytecodeSize ( ) ) ) ; if ( backward ) { new_budget . Bind ( Int32Sub ( budget_after_bytecode , weight ) ) ; Node * condition = Int32GreaterThanOrEqual ( new_budget . value ( ) , Int32Constant ( 0 ) ) ; Label ok ( this ) , interrupt_check ( this , Label :: kDeferred ) ; Branch ( condition , & ok , & interrupt_check ) ; BIND ( & interrupt_check ) ; { CallRuntime ( Runtime :: kInterrupt , GetContext ( ) ) ; new_budget . Bind ( Int32Constant ( Interpreter :: InterruptBudget ( ) ) ) ; Goto ( & ok ) ; } BIND ( & ok ) ; } else { new_budget . Bind ( Int32Add ( budget_after_bytecode , weight ) ) ; } StoreNoWriteBarrier ( MachineRepresentation :: kWord32 , BytecodeArrayTaggedPointer ( ) , budget_offset , new_budget . value ( ) ) ; Comment ( "] UpdateInterruptBudget" ) ; }
nsHostObjectProtocolHandler :: NewChannel2 ( nsIURI * uri , nsILoadInfo * aLoadInfo , nsIChannel * * result ) { * result = nullptr ; nsCOMPtr < nsIURIWithBlobImpl > uriBlobImpl = do_QueryInterface ( uri ) ; if ( ! uriBlobImpl ) { return NS_ERROR_DOM_BAD_URI ; } nsCOMPtr < nsISupports > tmp ; MOZ_ALWAYS_SUCCEEDS ( uriBlobImpl -> GetBlobImpl ( getter_AddRefs ( tmp ) ) ) ; nsCOMPtr < BlobImpl > blobImpl = do_QueryInterface ( tmp ) ; if ( ! blobImpl ) { return NS_ERROR_DOM_BAD_URI ; } #ifdef DEBUG DataInfo * info = GetDataInfoFromURI ( uri ) ; if ( info ) { nsCOMPtr < nsIURIWithPrincipal > uriPrinc = do_QueryInterface ( uri ) ; nsCOMPtr < nsIPrincipal > principal ; uriPrinc -> GetPrincipal ( getter_AddRefs ( principal ) ) ; MOZ_ASSERT ( info -> mPrincipal == principal , "Wrong principal!" ) ; } #endif ErrorResult rv ; nsCOMPtr < nsIInputStream > stream ; blobImpl -> CreateInputStream ( getter_AddRefs ( stream ) , rv ) ; if ( NS_WARN_IF ( rv . Failed ( ) ) ) { return rv . StealNSResult ( ) ; } nsAutoString contentType ; blobImpl -> GetType ( contentType ) ; nsCOMPtr < nsIChannel > channel ; rv = NS_NewInputStreamChannelInternal ( getter_AddRefs ( channel ) , uri , stream . forget ( ) , NS_ConvertUTF16toUTF8 ( contentType ) , EmptyCString ( ) , aLoadInfo ) ; if ( NS_WARN_IF ( rv . Failed ( ) ) ) { return rv . StealNSResult ( ) ; } if ( blobImpl -> IsFile ( ) ) { nsString filename ; blobImpl -> GetName ( filename ) ; channel -> SetContentDispositionFilename ( filename ) ; } uint64_t size = blobImpl -> GetSize ( rv ) ; if ( NS_WARN_IF ( rv . Failed ( ) ) ) { return rv . StealNSResult ( ) ; } channel -> SetOriginalURI ( uri ) ; channel -> SetContentType ( NS_ConvertUTF16toUTF8 ( contentType ) ) ; channel -> SetContentLength ( size ) ; channel . forget ( result ) ; return NS_OK ; }
static void bta_pan_data_buf_ind_cback ( uint16_t handle , const RawAddress & src , const RawAddress & dst , uint16_t protocol , BT_HDR * p_buf , bool ext , bool forward ) { tBTA_PAN_SCB * p_scb ; BT_HDR * p_new_buf ; p_scb = bta_pan_scb_by_handle ( handle ) ; if ( p_scb == NULL ) { return ; } if ( sizeof ( tBTA_PAN_DATA_PARAMS ) > p_buf -> offset ) { if ( sizeof ( BT_HDR ) + sizeof ( tBTA_PAN_DATA_PARAMS ) + p_buf -> len > PAN_BUF_SIZE ) { android_errorWriteLog ( 0x534e4554 , "63146237" ) ; APPL_TRACE_ERROR ( "%s: received buffer length too large: %d" , __func__ , p_buf -> len ) ; return ; } p_new_buf = ( BT_HDR * ) osi_malloc ( PAN_BUF_SIZE ) ; memcpy ( ( uint8_t * ) ( p_new_buf + 1 ) + sizeof ( tBTA_PAN_DATA_PARAMS ) , ( uint8_t * ) ( p_buf + 1 ) + p_buf -> offset , p_buf -> len ) ; p_new_buf -> len = p_buf -> len ; p_new_buf -> offset = sizeof ( tBTA_PAN_DATA_PARAMS ) ; } else { p_new_buf = p_buf ; } ( ( tBTA_PAN_DATA_PARAMS * ) p_new_buf ) -> src = src ; ( ( tBTA_PAN_DATA_PARAMS * ) p_new_buf ) -> dst = dst ; ( ( tBTA_PAN_DATA_PARAMS * ) p_new_buf ) -> protocol = protocol ; ( ( tBTA_PAN_DATA_PARAMS * ) p_new_buf ) -> ext = ext ; ( ( tBTA_PAN_DATA_PARAMS * ) p_new_buf ) -> forward = forward ; fixed_queue_enqueue ( p_scb -> data_queue , p_new_buf ) ; BT_HDR * p_event = ( BT_HDR * ) osi_malloc ( sizeof ( BT_HDR ) ) ; p_event -> layer_specific = handle ; p_event -> event = BTA_PAN_RX_FROM_BNEP_READY_EVT ; bta_sys_sendmsg ( p_event ) ; }
static VALUE cState_object_nl_set ( VALUE self , VALUE object_nl ) { unsigned long len ; GET_STATE ( self ) ; Check_Type ( object_nl , T_STRING ) ; len = RSTRING_LEN ( object_nl ) ; if ( len == 0 ) { if ( state -> object_nl ) { ruby_xfree ( state -> object_nl ) ; state -> object_nl = NULL ; } } else { if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ; state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ; state -> object_nl_len = len ; } return Qnil ; }
Reduction CommonOperatorReducer :: ReduceSelect ( Node * node ) { DCHECK_EQ ( IrOpcode :: kSelect , node -> opcode ( ) ) ; Node * const cond = node -> InputAt ( 0 ) ; Node * const vtrue = node -> InputAt ( 1 ) ; Node * const vfalse = node -> InputAt ( 2 ) ; if ( vtrue == vfalse ) return Replace ( vtrue ) ; switch ( DecideCondition ( js_heap_broker ( ) , cond ) ) { case Decision :: kTrue : return Replace ( vtrue ) ; case Decision :: kFalse : return Replace ( vfalse ) ; case Decision :: kUnknown : break ; } switch ( cond -> opcode ( ) ) { case IrOpcode :: kFloat32LessThan : { Float32BinopMatcher mcond ( cond ) ; if ( mcond . left ( ) . Is ( 0.0 ) && mcond . right ( ) . Equals ( vtrue ) && vfalse -> opcode ( ) == IrOpcode :: kFloat32Sub ) { Float32BinopMatcher mvfalse ( vfalse ) ; if ( mvfalse . left ( ) . IsZero ( ) && mvfalse . right ( ) . Equals ( vtrue ) ) { return Change ( node , machine ( ) -> Float32Abs ( ) , vtrue ) ; } } break ; } case IrOpcode :: kFloat64LessThan : { Float64BinopMatcher mcond ( cond ) ; if ( mcond . left ( ) . Is ( 0.0 ) && mcond . right ( ) . Equals ( vtrue ) && vfalse -> opcode ( ) == IrOpcode :: kFloat64Sub ) { Float64BinopMatcher mvfalse ( vfalse ) ; if ( mvfalse . left ( ) . IsZero ( ) && mvfalse . right ( ) . Equals ( vtrue ) ) { return Change ( node , machine ( ) -> Float64Abs ( ) , vtrue ) ; } } break ; } default : break ; } return NoChange ( ) ; }
already_AddRefed < CanvasPattern > CanvasRenderingContext2D :: CreatePattern ( const CanvasImageSource & aSource , const nsAString & aRepeat , ErrorResult & aError ) { CanvasPattern :: RepeatMode repeatMode = CanvasPattern :: RepeatMode :: NOREPEAT ; if ( aRepeat . IsEmpty ( ) || aRepeat . EqualsLiteral ( "repeat" ) ) { repeatMode = CanvasPattern :: RepeatMode :: REPEAT ; } else if ( aRepeat . EqualsLiteral ( "repeat-x" ) ) { repeatMode = CanvasPattern :: RepeatMode :: REPEATX ; } else if ( aRepeat . EqualsLiteral ( "repeat-y" ) ) { repeatMode = CanvasPattern :: RepeatMode :: REPEATY ; } else if ( aRepeat . EqualsLiteral ( "no-repeat" ) ) { repeatMode = CanvasPattern :: RepeatMode :: NOREPEAT ; } else { aError . Throw ( NS_ERROR_DOM_SYNTAX_ERR ) ; return nullptr ; } Element * element ; if ( aSource . IsHTMLCanvasElement ( ) ) { HTMLCanvasElement * canvas = & aSource . GetAsHTMLCanvasElement ( ) ; element = canvas ; nsIntSize size = canvas -> GetSize ( ) ; if ( size . width == 0 || size . height == 0 ) { aError . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return nullptr ; } nsICanvasRenderingContextInternal * srcCanvas = canvas -> GetContextAtIndex ( 0 ) ; if ( srcCanvas ) { RefPtr < SourceSurface > srcSurf = srcCanvas -> GetSurfaceSnapshot ( ) ; if ( ! srcSurf ) { JSContext * context = nsContentUtils :: GetCurrentJSContext ( ) ; if ( context ) { JS :: WarnASCII ( context , "CanvasRenderingContext2D.createPattern() failed to " "snapshot source canvas." ) ; } aError . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return nullptr ; } RefPtr < CanvasPattern > pat = new CanvasPattern ( this , srcSurf , repeatMode , element -> NodePrincipal ( ) , canvas -> IsWriteOnly ( ) , false ) ; return pat . forget ( ) ; } } else if ( aSource . IsHTMLImageElement ( ) ) { HTMLImageElement * img = & aSource . GetAsHTMLImageElement ( ) ; if ( img -> IntrinsicState ( ) . HasState ( NS_EVENT_STATE_BROKEN ) ) { aError . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return nullptr ; } element = img ; } else if ( aSource . IsSVGImageElement ( ) ) { SVGImageElement * img = & aSource . GetAsSVGImageElement ( ) ; if ( img -> IntrinsicState ( ) . HasState ( NS_EVENT_STATE_BROKEN ) ) { aError . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return nullptr ; } element = img ; } else if ( aSource . IsHTMLVideoElement ( ) ) { auto & video = aSource . GetAsHTMLVideoElement ( ) ; video . MarkAsContentSource ( mozilla :: dom :: HTMLVideoElement :: CallerAPI :: CREATE_PATTERN ) ; element = & video ; } else { ImageBitmap & imgBitmap = aSource . GetAsImageBitmap ( ) ; EnsureTarget ( ) ; if ( ! IsTargetValid ( ) ) { aError . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return nullptr ; } RefPtr < SourceSurface > srcSurf = imgBitmap . PrepareForDrawTarget ( mTarget ) ; if ( ! srcSurf ) { JSContext * context = nsContentUtils :: GetCurrentJSContext ( ) ; if ( context ) { JS :: WarnASCII ( context , "CanvasRenderingContext2D.createPattern() failed to " "prepare source ImageBitmap." ) ; } aError . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return nullptr ; } RefPtr < CanvasPattern > pat = new CanvasPattern ( this , srcSurf , repeatMode , nullptr , imgBitmap . IsWriteOnly ( ) , true ) ; return pat . forget ( ) ; } EnsureTarget ( ) ; if ( ! IsTargetValid ( ) ) { aError . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return nullptr ; } nsLayoutUtils :: SurfaceFromElementResult res = nsLayoutUtils :: SurfaceFromElement ( element , nsLayoutUtils :: SFE_WANT_FIRST_FRAME_IF_IMAGE , mTarget ) ; if ( ! res . GetSourceSurface ( ) ) { return nullptr ; } RefPtr < CanvasPattern > pat = new CanvasPattern ( this , res . GetSourceSurface ( ) , repeatMode , res . mPrincipal , res . mIsWriteOnly , res . mCORSUsed ) ; return pat . forget ( ) ; }
TF_BUILTIN ( FlatMapIntoArray , ArrayFlattenAssembler ) { Node * const context = Parameter ( Descriptor :: kContext ) ; Node * const target = Parameter ( Descriptor :: kTarget ) ; Node * const source = Parameter ( Descriptor :: kSource ) ; Node * const source_length = Parameter ( Descriptor :: kSourceLength ) ; Node * const start = Parameter ( Descriptor :: kStart ) ; Node * const depth = Parameter ( Descriptor :: kDepth ) ; Node * const mapper_function = Parameter ( Descriptor :: kMapperFunction ) ; Node * const this_arg = Parameter ( Descriptor :: kThisArg ) ; Return ( FlattenIntoArray ( context , target , source , source_length , start , depth , mapper_function , this_arg ) ) ; }
BUILTIN ( LocalePrototypeToString ) { HandleScope scope ( isolate ) ; CHECK_RECEIVER ( JSLocale , locale_holder , "Intl.Locale.prototype.toString" ) ; return locale_holder -> locale ( ) ; }
void WebAssemblyGlobalGetValueCommon ( const v8 :: FunctionCallbackInfo < v8 :: Value > & args , const char * name ) { v8 :: Isolate * isolate = args . GetIsolate ( ) ; i :: Isolate * i_isolate = reinterpret_cast < i :: Isolate * > ( isolate ) ; HandleScope scope ( isolate ) ; ScheduledErrorThrower thrower ( i_isolate , name ) ; EXTRACT_THIS ( receiver , WasmGlobalObject ) ; v8 :: ReturnValue < v8 :: Value > return_value = args . GetReturnValue ( ) ; switch ( receiver -> type ( ) ) { case i :: wasm :: kWasmI32 : return_value . Set ( receiver -> GetI32 ( ) ) ; break ; case i :: wasm :: kWasmI64 : thrower . TypeError ( "Can't get the value of i64 WebAssembly.Global" ) ; break ; case i :: wasm :: kWasmF32 : return_value . Set ( receiver -> GetF32 ( ) ) ; break ; case i :: wasm :: kWasmF64 : return_value . Set ( receiver -> GetF64 ( ) ) ; break ; default : UNREACHABLE ( ) ; } }
void BytecodeGenerator :: BuildIteratorClose ( const IteratorRecord & iterator , Expression * expr ) { RegisterAllocationScope register_scope ( this ) ; BytecodeLabels done ( zone ( ) ) ; BytecodeLabel if_called ; RegisterList args = RegisterList ( iterator . object ( ) ) ; BuildCallIteratorMethod ( iterator . object ( ) , ast_string_constants ( ) -> return_string ( ) , args , & if_called , & done ) ; builder ( ) -> Bind ( & if_called ) ; if ( iterator . type ( ) == IteratorType :: kAsync ) { DCHECK_NOT_NULL ( expr ) ; BuildAwait ( expr ) ; } builder ( ) -> JumpIfJSReceiver ( done . New ( ) ) ; { RegisterAllocationScope register_scope ( this ) ; Register return_result = register_allocator ( ) -> NewRegister ( ) ; builder ( ) -> StoreAccumulatorInRegister ( return_result ) . CallRuntime ( Runtime :: kThrowIteratorResultNotAnObject , return_result ) ; } done . Bind ( builder ( ) ) ; }
std :: unique_ptr < Handle < Object > [ ] > GetCallerArguments ( Isolate * isolate , int * total_argc ) { JavaScriptFrameIterator it ( isolate ) ; JavaScriptFrame * frame = it . frame ( ) ; std :: vector < SharedFunctionInfo * > functions ; frame -> GetFunctions ( & functions ) ; if ( functions . size ( ) > 1 ) { int inlined_jsframe_index = static_cast < int > ( functions . size ( ) ) - 1 ; TranslatedState translated_values ( frame ) ; translated_values . Prepare ( frame -> fp ( ) ) ; int argument_count = 0 ; TranslatedFrame * translated_frame = translated_values . GetArgumentsInfoFromJSFrameIndex ( inlined_jsframe_index , & argument_count ) ; TranslatedFrame :: iterator iter = translated_frame -> begin ( ) ; iter ++ ; iter ++ ; argument_count -- ; * total_argc = argument_count ; std :: unique_ptr < Handle < Object > [ ] > param_data ( NewArray < Handle < Object > > ( * total_argc ) ) ; bool should_deoptimize = false ; for ( int i = 0 ; i < argument_count ; i ++ ) { should_deoptimize = should_deoptimize || iter -> IsMaterializedObject ( ) ; Handle < Object > value = iter -> GetValue ( ) ; param_data [ i ] = value ; iter ++ ; } if ( should_deoptimize ) { translated_values . StoreMaterializedValuesAndDeopt ( frame ) ; } return param_data ; } else { if ( it . frame ( ) -> has_adapted_arguments ( ) ) { it . AdvanceOneFrame ( ) ; DCHECK ( it . frame ( ) -> is_arguments_adaptor ( ) ) ; } frame = it . frame ( ) ; int args_count = frame -> ComputeParametersCount ( ) ; * total_argc = args_count ; std :: unique_ptr < Handle < Object > [ ] > param_data ( NewArray < Handle < Object > > ( * total_argc ) ) ; for ( int i = 0 ; i < args_count ; i ++ ) { Handle < Object > val = Handle < Object > ( frame -> GetParameter ( i ) , isolate ) ; param_data [ i ] = val ; } return param_data ; } }
BytecodeEmitter :: emitForOf ( StmtType type , ParseNode * pn , ptrdiff_t top ) { MOZ_ASSERT ( type == STMT_FOR_OF_LOOP || type == STMT_SPREAD ) ; MOZ_ASSERT_IF ( type == STMT_FOR_OF_LOOP , pn && pn -> pn_left -> isKind ( PNK_FOROF ) ) ; MOZ_ASSERT_IF ( type == STMT_SPREAD , ! pn ) ; ParseNode * forHead = pn ? pn -> pn_left : nullptr ; ParseNode * forHeadExpr = forHead ? forHead -> pn_kid3 : nullptr ; ParseNode * forBody = pn ? pn -> pn_right : nullptr ; ParseNode * pn1 = forHead ? forHead -> pn_kid1 : nullptr ; bool letDecl = false ; if ( pn1 && ! emitForInOrOfVariables ( pn1 , & letDecl ) ) return false ; if ( type == STMT_FOR_OF_LOOP ) { if ( ! emitTree ( forHeadExpr ) ) return false ; if ( ! emitIterator ( ) ) return false ; if ( ! emit1 ( JSOP_UNDEFINED ) ) return false ; } StmtInfoBCE letStmt ( cx ) ; if ( letDecl ) { if ( ! EnterBlockScope ( cx , this , & letStmt , pn1 -> pn_objbox , JSOP_UNDEFINED , 0 ) ) return false ; } LoopStmtInfo stmtInfo ( cx ) ; PushLoopStatement ( this , & stmtInfo , type , top ) ; int noteIndex = NewSrcNote ( cx , this , SRC_FOR_OF ) ; if ( noteIndex < 0 ) return false ; ptrdiff_t jmp = emitJump ( JSOP_GOTO , 0 ) ; if ( jmp < 0 ) return false ; top = offset ( ) ; SET_STATEMENT_TOP ( & stmtInfo , top ) ; if ( ! emitLoopHead ( nullptr ) ) return false ; if ( type == STMT_SPREAD ) this -> stackDepth ++ ; #ifdef DEBUG int loopDepth = this -> stackDepth ; #endif if ( type == STMT_FOR_OF_LOOP ) { if ( ! emit1 ( JSOP_DUP ) ) return false ; } if ( ! emitAtomOp ( cx -> names ( ) . value , JSOP_GETPROP ) ) return false ; if ( type == STMT_FOR_OF_LOOP ) { if ( ! emitAssignment ( forHead -> pn_kid2 , JSOP_NOP , nullptr ) ) return false ; if ( ! emit1 ( JSOP_POP ) ) return false ; MOZ_ASSERT ( this -> stackDepth == loopDepth ) ; if ( ! emitTree ( forBody ) ) return false ; StmtInfoBCE * stmt = & stmtInfo ; do { stmt -> update = offset ( ) ; } while ( ( stmt = stmt -> down ) != nullptr && stmt -> type == STMT_LABEL ) ; } else { if ( ! emit1 ( JSOP_INITELEM_INC ) ) return false ; MOZ_ASSERT ( this -> stackDepth == loopDepth - 1 ) ; } setJumpOffsetAt ( jmp ) ; if ( ! emitLoopEntry ( forHeadExpr ) ) return false ; if ( type == STMT_FOR_OF_LOOP ) { if ( ! emit1 ( JSOP_POP ) ) return false ; if ( ! emit1 ( JSOP_DUP ) ) return false ; } else { if ( ! emitDupAt ( this -> stackDepth - 1 - 2 ) ) return false ; } if ( ! emitIteratorNext ( forHead ) ) return false ; if ( ! emit1 ( JSOP_DUP ) ) return false ; if ( ! emitAtomOp ( cx -> names ( ) . done , JSOP_GETPROP ) ) return false ; ptrdiff_t beq = emitJump ( JSOP_IFEQ , top - offset ( ) ) ; if ( beq < 0 ) return false ; MOZ_ASSERT ( this -> stackDepth == loopDepth ) ; if ( ! setSrcNoteOffset ( unsigned ( noteIndex ) , 0 , beq - jmp ) ) return false ; popStatement ( ) ; if ( letDecl ) { if ( ! LeaveNestedScope ( cx , this , & letStmt ) ) return false ; } if ( type == STMT_SPREAD ) { if ( ! emit2 ( JSOP_PICK , ( jsbytecode ) 3 ) ) return false ; } return emitUint16Operand ( JSOP_POPN , 2 ) ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { auto * params = reinterpret_cast < TfLiteSVDFParams * > ( node -> builtin_data ) ; OpData * op_data = reinterpret_cast < OpData * > ( node -> user_data ) ; const TfLiteTensor * input ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kInputTensor , & input ) ) ; const TfLiteTensor * weights_feature ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kWeightsFeatureTensor , & weights_feature ) ) ; const TfLiteTensor * weights_time ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kWeightsTimeTensor , & weights_time ) ) ; const TfLiteTensor * bias = GetOptionalInputTensor ( context , node , kBiasTensor ) ; TfLiteTensor * scratch ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 0 , & scratch ) ) ; TfLiteTensor * state = GetVariableInput ( context , node , kStateTensor ) ; TfLiteTensor * output ; TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , kOutputTensor , & output ) ) ; switch ( weights_feature -> type ) { case kTfLiteFloat32 : { reference_ops :: EvalFloatSVDF ( params , GetTensorShape ( input ) , GetTensorData < float > ( input ) , GetTensorShape ( weights_feature ) , GetTensorData < float > ( weights_feature ) , GetTensorShape ( weights_time ) , GetTensorData < float > ( weights_time ) , GetTensorShape ( bias ) , GetTensorData < float > ( bias ) , GetTensorData < float > ( scratch ) , GetTensorData < float > ( state ) , GetTensorShape ( output ) , GetTensorData < float > ( output ) ) ; return kTfLiteOk ; } case kTfLiteUInt8 : case kTfLiteInt8 : { if ( input -> type == kTfLiteFloat32 ) { TfLiteTensor * input_quantized ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 1 , & input_quantized ) ) ; TfLiteTensor * scaling_factors ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 2 , & scaling_factors ) ) ; TfLiteTensor * float_weights_time ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 3 , & float_weights_time ) ) ; TfLiteTensor * zero_points ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 4 , & zero_points ) ) ; TfLiteTensor * row_sums ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 5 , & row_sums ) ) ; if ( ! op_data -> float_weights_time_initialized ) { const float dequantization_scale = weights_time -> params . scale ; const int8_t * weights_time_ptr = GetTensorData < int8_t > ( weights_time ) ; float * float_weights_time_ptr = GetTensorData < float > ( float_weights_time ) ; for ( int i = 0 ; i < NumElements ( float_weights_time ) ; ++ i ) { float_weights_time_ptr [ i ] = weights_time_ptr [ i ] * dequantization_scale ; } op_data -> float_weights_time_initialized = true ; } int32_t * zero_points_ptr = nullptr ; int32_t * row_sums_ptr = nullptr ; if ( params -> asymmetric_quantize_inputs && row_sums != nullptr ) { zero_points_ptr = GetTensorData < int32_t > ( zero_points ) ; row_sums_ptr = GetTensorData < int32_t > ( row_sums ) ; } reference_ops :: EvalHybridSVDF ( params , GetTensorShape ( input ) , GetTensorData < float > ( input ) , GetTensorShape ( weights_feature ) , GetTensorData < int8_t > ( weights_feature ) , weights_feature -> params . scale , GetTensorShape ( float_weights_time ) , GetTensorData < float > ( float_weights_time ) , GetTensorShape ( bias ) , GetTensorData < float > ( bias ) , GetTensorData < float > ( scratch ) , GetTensorData < float > ( scaling_factors ) , GetTensorData < int8_t > ( input_quantized ) , GetTensorData < float > ( state ) , GetTensorShape ( output ) , GetTensorData < float > ( output ) , zero_points_ptr , row_sums_ptr , & op_data -> compute_row_sums ) ; return kTfLiteOk ; } auto * input_params = reinterpret_cast < TfLiteAffineQuantization * > ( input -> quantization . params ) ; auto * output_params = reinterpret_cast < TfLiteAffineQuantization * > ( output -> quantization . params ) ; TfLiteTensor * output_temp ; TF_LITE_ENSURE_OK ( context , GetTemporarySafe ( context , node , 1 , & output_temp ) ) ; TF_LITE_ENSURE_EQ ( context , params -> activation , kTfLiteActRelu ) ; reference_ops :: EvalIntegerSVDF ( params , GetTensorShape ( input ) , GetTensorData < int8_t > ( input ) , GetTensorShape ( weights_feature ) , GetTensorData < int8_t > ( weights_feature ) , GetTensorShape ( weights_time ) , GetTensorData < int16_t > ( weights_time ) , GetTensorShape ( bias ) , GetTensorData < int32_t > ( bias ) , GetTensorData < int16_t > ( state ) , GetTensorShape ( output ) , GetTensorData < int8_t > ( output ) , GetTensorData < int32_t > ( scratch ) , GetTensorData < int32_t > ( output_temp ) , op_data -> effective_scale_1_a , op_data -> effective_scale_1_b , op_data -> effective_scale_2_a , op_data -> effective_scale_2_b , input_params -> zero_point -> data [ 0 ] , output_params -> zero_point -> data [ 0 ] ) ; return kTfLiteOk ; } default : context -> ReportError ( context , "Type %s not currently supported." , TfLiteTypeGetName ( weights_feature -> type ) ) ; return kTfLiteError ; } }
long Chapters :: Parse ( ) { IMkvReader * const pReader = m_pSegment -> m_pReader ; long long pos = m_start ; const long long stop = pos + m_size ; while ( pos < stop ) { long long id , size ; long status = ParseElementHeader ( pReader , pos , stop , id , size ) ; if ( status < 0 ) return status ; if ( size == 0 ) continue ; if ( id == 0x05B9 ) { status = ParseEdition ( pos , size ) ; if ( status < 0 ) return status ; } pos += size ; assert ( pos <= stop ) ; } assert ( pos == stop ) ; return 0 ; }
void BytecodeGraphBuilder :: VisitConstructWithSpread ( ) { PrepareEagerCheckpoint ( ) ; interpreter :: Register callee_reg = bytecode_iterator ( ) . GetRegisterOperand ( 0 ) ; interpreter :: Register first_reg = bytecode_iterator ( ) . GetRegisterOperand ( 1 ) ; size_t reg_count = bytecode_iterator ( ) . GetRegisterCountOperand ( 2 ) ; int const slot_id = bytecode_iterator ( ) . GetIndexOperand ( 3 ) ; VectorSlotPair feedback = CreateVectorSlotPair ( slot_id ) ; Node * new_target = environment ( ) -> LookupAccumulator ( ) ; Node * callee = environment ( ) -> LookupRegister ( callee_reg ) ; CallFrequency frequency = ComputeCallFrequency ( slot_id ) ; const Operator * op = javascript ( ) -> ConstructWithSpread ( static_cast < uint32_t > ( reg_count + 2 ) , frequency , feedback ) ; int arg_count = static_cast < int > ( reg_count ) ; Node * const * args = GetConstructArgumentsFromRegister ( callee , new_target , first_reg , arg_count ) ; JSTypeHintLowering :: LoweringResult lowering = TryBuildSimplifiedConstruct ( op , args , static_cast < int > ( arg_count ) , feedback . slot ( ) ) ; if ( lowering . IsExit ( ) ) return ; Node * node = nullptr ; if ( lowering . IsSideEffectFree ( ) ) { node = lowering . value ( ) ; } else { DCHECK ( ! lowering . Changed ( ) ) ; node = ProcessConstructArguments ( op , args , 2 + arg_count ) ; } environment ( ) -> BindAccumulator ( node , Environment :: kAttachFrameState ) ; }
Status KeyStoreService :: update ( const sp < IBinder > & token , const KeymasterArguments & params , const :: std :: vector < uint8_t > & data , OperationResult * result ) { if ( ! checkAllowedOperationParams ( params . getParameters ( ) ) ) { result -> resultCode = ErrorCode :: INVALID_ARGUMENT ; return Status :: ok ( ) ; } auto getOpResult = mOperationMap . getOperation ( token ) ; if ( ! getOpResult . isOk ( ) ) { result -> resultCode = ErrorCode :: INVALID_OPERATION_HANDLE ; return Status :: ok ( ) ; } const auto & op = getOpResult . value ( ) ; HardwareAuthToken authToken ; std :: tie ( result -> resultCode , authToken ) = getOperationAuthTokenIfNeeded ( token ) ; if ( ! result -> resultCode . isOk ( ) ) return Status :: ok ( ) ; AuthorizationSet key_auths ( op . characteristics . hardwareEnforced ) ; key_auths . append ( op . characteristics . softwareEnforced . begin ( ) , op . characteristics . softwareEnforced . end ( ) ) ; result -> resultCode = enforcement_policy . AuthorizeOperation ( op . purpose , op . keyid , key_auths , params . getParameters ( ) , authToken , op . handle , false ) ; if ( ! result -> resultCode . isOk ( ) ) return Status :: ok ( ) ; std :: vector < KeyParameter > inParams = params . getParameters ( ) ; auto hidlCb = [ & ] ( ErrorCode ret , uint32_t inputConsumed , const hidl_vec < KeyParameter > & outParams , const :: std :: vector < uint8_t > & output ) { result -> resultCode = ret ; if ( result -> resultCode . isOk ( ) ) { result -> inputConsumed = inputConsumed ; result -> outParams = outParams ; result -> data = output ; } } ; KeyStoreServiceReturnCode rc = KS_HANDLE_HIDL_ERROR ( op . device -> update ( op . handle , inParams , data , authToken , op . verificationToken , hidlCb ) ) ; if ( ! rc . isOk ( ) ) result -> resultCode = rc ; return Status :: ok ( ) ; }
static struct ib_ucontext * hns_roce_alloc_ucontext ( struct ib_device * ib_dev , struct ib_udata * udata ) { int ret = 0 ; struct hns_roce_ucontext * context ; struct hns_roce_ib_alloc_ucontext_resp resp ; struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ; resp . qp_tab_size = hr_dev -> caps . num_qps ; context = kmalloc ( sizeof ( * context ) , GFP_KERNEL ) ; if ( ! context ) return ERR_PTR ( - ENOMEM ) ; ret = hns_roce_uar_alloc ( hr_dev , & context -> uar ) ; if ( ret ) goto error_fail_uar_alloc ; if ( hr_dev -> caps . flags & HNS_ROCE_CAP_FLAG_RECORD_DB ) { INIT_LIST_HEAD ( & context -> page_list ) ; mutex_init ( & context -> page_mutex ) ; } ret = ib_copy_to_udata ( udata , & resp , sizeof ( resp ) ) ; if ( ret ) goto error_fail_copy_to_udata ; return & context -> ibucontext ; error_fail_copy_to_udata : hns_roce_uar_free ( hr_dev , & context -> uar ) ; error_fail_uar_alloc : kfree ( context ) ; return ERR_PTR ( ret ) ; }
void SetWasmCalleeTag ( RelocInfo * rinfo , uint32_t tag ) { #if V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_IA32 * ( reinterpret_cast < uint32_t * > ( rinfo -> target_address_address ( ) ) ) = tag ; #elif V8_TARGET_ARCH_ARM64 Instruction * instr = reinterpret_cast < Instruction * > ( rinfo -> pc ( ) ) ; if ( instr -> IsLdrLiteralX ( ) ) { Memory < Address > ( rinfo -> constant_pool_entry_address ( ) ) = static_cast < Address > ( tag ) ; } else { DCHECK ( instr -> IsBranchAndLink ( ) || instr -> IsUnconditionalBranch ( ) ) ; instr -> SetBranchImmTarget ( reinterpret_cast < Instruction * > ( rinfo -> pc ( ) + tag * kInstrSize ) ) ; } #else Address addr = static_cast < Address > ( tag ) ; if ( rinfo -> rmode ( ) == RelocInfo :: EXTERNAL_REFERENCE ) { rinfo -> set_target_external_reference ( addr , SKIP_ICACHE_FLUSH ) ; } else if ( rinfo -> rmode ( ) == RelocInfo :: WASM_STUB_CALL ) { rinfo -> set_wasm_stub_call_address ( addr , SKIP_ICACHE_FLUSH ) ; } else { rinfo -> set_target_address ( addr , SKIP_WRITE_BARRIER , SKIP_ICACHE_FLUSH ) ; } #endif }
void CompilationDependencies :: DependOnStablePrototypeChains ( JSHeapBroker * broker , Handle < Context > native_context , std :: vector < Handle < Map > > const & receiver_maps , Handle < JSObject > holder ) { Isolate * isolate = holder -> GetIsolate ( ) ; for ( auto map : receiver_maps ) { Handle < JSFunction > constructor ; if ( Map :: GetConstructorFunction ( map , native_context ) . ToHandle ( & constructor ) ) { map = handle ( constructor -> initial_map ( ) , isolate ) ; } DependOnStablePrototypeChain ( broker , this , map , holder ) ; } }
create_pty_only ( term_T * term , jobopt_T * options ) { HANDLE hPipeIn = INVALID_HANDLE_VALUE ; HANDLE hPipeOut = INVALID_HANDLE_VALUE ; char in_name [ 80 ] , out_name [ 80 ] ; channel_T * channel = NULL ; create_vterm ( term , term -> tl_rows , term -> tl_cols ) ; vim_snprintf ( in_name , sizeof ( in_name ) , "\\\\.\\pipe\\vim-%d-in-%d" , GetCurrentProcessId ( ) , curbuf -> b_fnum ) ; hPipeIn = CreateNamedPipe ( in_name , PIPE_ACCESS_OUTBOUND , PIPE_TYPE_MESSAGE | PIPE_NOWAIT , PIPE_UNLIMITED_INSTANCES , 0 , 0 , NMPWAIT_NOWAIT , NULL ) ; if ( hPipeIn == INVALID_HANDLE_VALUE ) goto failed ; vim_snprintf ( out_name , sizeof ( out_name ) , "\\\\.\\pipe\\vim-%d-out-%d" , GetCurrentProcessId ( ) , curbuf -> b_fnum ) ; hPipeOut = CreateNamedPipe ( out_name , PIPE_ACCESS_INBOUND , PIPE_TYPE_MESSAGE | PIPE_NOWAIT , PIPE_UNLIMITED_INSTANCES , 0 , 0 , 0 , NULL ) ; if ( hPipeOut == INVALID_HANDLE_VALUE ) goto failed ; ConnectNamedPipe ( hPipeIn , NULL ) ; ConnectNamedPipe ( hPipeOut , NULL ) ; term -> tl_job = job_alloc ( ) ; if ( term -> tl_job == NULL ) goto failed ; ++ term -> tl_job -> jv_refcount ; term -> tl_job -> jv_status = JOB_FINISHED ; channel = add_channel ( ) ; if ( channel == NULL ) goto failed ; term -> tl_job -> jv_channel = channel ; channel -> ch_keep_open = TRUE ; channel -> ch_named_pipe = TRUE ; channel_set_pipes ( channel , ( sock_T ) hPipeIn , ( sock_T ) hPipeOut , ( sock_T ) hPipeOut ) ; channel_set_job ( channel , term -> tl_job , options ) ; term -> tl_job -> jv_tty_in = vim_strsave ( ( char_u * ) in_name ) ; term -> tl_job -> jv_tty_out = vim_strsave ( ( char_u * ) out_name ) ; return OK ; failed : if ( hPipeIn != NULL ) CloseHandle ( hPipeIn ) ; if ( hPipeOut != NULL ) CloseHandle ( hPipeOut ) ; return FAIL ; }
Node * PropertyAccessBuilder :: BuildLoadDataField ( Handle < Name > name , PropertyAccessInfo const & access_info , Node * receiver , Node * * effect , Node * * control ) { DCHECK ( access_info . IsDataField ( ) || access_info . IsDataConstantField ( ) ) ; receiver = ResolveHolder ( access_info , receiver ) ; if ( Node * value = TryBuildLoadConstantDataField ( name , access_info , receiver ) ) { return value ; } FieldIndex const field_index = access_info . field_index ( ) ; Type const field_type = access_info . field_type ( ) ; MachineRepresentation const field_representation = access_info . field_representation ( ) ; Node * storage = receiver ; if ( ! field_index . is_inobject ( ) ) { storage = * effect = graph ( ) -> NewNode ( simplified ( ) -> LoadField ( AccessBuilder :: ForJSObjectPropertiesOrHash ( ) ) , storage , * effect , * control ) ; } FieldAccess field_access = { kTaggedBase , field_index . offset ( ) , name , MaybeHandle < Map > ( ) , field_type , MachineType :: TypeForRepresentation ( field_representation ) , kFullWriteBarrier } ; if ( field_representation == MachineRepresentation :: kFloat64 ) { if ( ! field_index . is_inobject ( ) || field_index . is_hidden_field ( ) || ! FLAG_unbox_double_fields ) { FieldAccess const storage_access = { kTaggedBase , field_index . offset ( ) , name , MaybeHandle < Map > ( ) , Type :: OtherInternal ( ) , MachineType :: TaggedPointer ( ) , kPointerWriteBarrier } ; storage = * effect = graph ( ) -> NewNode ( simplified ( ) -> LoadField ( storage_access ) , storage , * effect , * control ) ; field_access . offset = HeapNumber :: kValueOffset ; field_access . name = MaybeHandle < Name > ( ) ; } } else if ( field_representation == MachineRepresentation :: kTaggedPointer ) { Handle < Map > field_map ; if ( access_info . field_map ( ) . ToHandle ( & field_map ) ) { if ( field_map -> is_stable ( ) ) { dependencies ( ) -> DependOnStableMap ( MapRef ( js_heap_broker ( ) , field_map ) ) ; field_access . map = field_map ; } } } Node * value = * effect = graph ( ) -> NewNode ( simplified ( ) -> LoadField ( field_access ) , storage , * effect , * control ) ; return value ; }
xmlParseElementMixedContentDecl ( xmlParserCtxtPtr ctxt , int inputchk ) { xmlElementContentPtr ret = NULL , cur = NULL , n ; const xmlChar * elem = NULL ; GROW ; if ( CMP7 ( CUR_PTR , '#' , 'P' , 'C' , 'D' , 'A' , 'T' , 'A' ) ) { SKIP ( 7 ) ; SKIP_BLANKS ; SHRINK ; if ( RAW == ')' ) { if ( ( ctxt -> validate ) && ( ctxt -> input -> id != inputchk ) ) { xmlValidityError ( ctxt , XML_ERR_ENTITY_BOUNDARY , "Element content declaration doesn't start and stop in the same entity\n" , NULL , NULL ) ; } NEXT ; ret = xmlNewDocElementContent ( ctxt -> myDoc , NULL , XML_ELEMENT_CONTENT_PCDATA ) ; if ( ret == NULL ) return ( NULL ) ; if ( RAW == '*' ) { ret -> ocur = XML_ELEMENT_CONTENT_MULT ; NEXT ; } return ( ret ) ; } if ( ( RAW == '(' ) || ( RAW == '|' ) ) { ret = cur = xmlNewDocElementContent ( ctxt -> myDoc , NULL , XML_ELEMENT_CONTENT_PCDATA ) ; if ( ret == NULL ) return ( NULL ) ; } while ( ( RAW == '|' ) && ( ctxt -> instate != XML_PARSER_EOF ) ) { NEXT ; if ( elem == NULL ) { ret = xmlNewDocElementContent ( ctxt -> myDoc , NULL , XML_ELEMENT_CONTENT_OR ) ; if ( ret == NULL ) return ( NULL ) ; ret -> c1 = cur ; if ( cur != NULL ) cur -> parent = ret ; cur = ret ; } else { n = xmlNewDocElementContent ( ctxt -> myDoc , NULL , XML_ELEMENT_CONTENT_OR ) ; if ( n == NULL ) return ( NULL ) ; n -> c1 = xmlNewDocElementContent ( ctxt -> myDoc , elem , XML_ELEMENT_CONTENT_ELEMENT ) ; if ( n -> c1 != NULL ) n -> c1 -> parent = n ; cur -> c2 = n ; if ( n != NULL ) n -> parent = cur ; cur = n ; } SKIP_BLANKS ; elem = xmlParseName ( ctxt ) ; if ( elem == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "xmlParseElementMixedContentDecl : Name expected\n" ) ; xmlFreeDocElementContent ( ctxt -> myDoc , cur ) ; return ( NULL ) ; } SKIP_BLANKS ; GROW ; } if ( ( RAW == ')' ) && ( NXT ( 1 ) == '*' ) ) { if ( elem != NULL ) { cur -> c2 = xmlNewDocElementContent ( ctxt -> myDoc , elem , XML_ELEMENT_CONTENT_ELEMENT ) ; if ( cur -> c2 != NULL ) cur -> c2 -> parent = cur ; } if ( ret != NULL ) ret -> ocur = XML_ELEMENT_CONTENT_MULT ; if ( ( ctxt -> validate ) && ( ctxt -> input -> id != inputchk ) ) { xmlValidityError ( ctxt , XML_ERR_ENTITY_BOUNDARY , "Element content declaration doesn't start and stop in the same entity\n" , NULL , NULL ) ; } SKIP ( 2 ) ; } else { xmlFreeDocElementContent ( ctxt -> myDoc , ret ) ; xmlFatalErr ( ctxt , XML_ERR_MIXED_NOT_STARTED , NULL ) ; return ( NULL ) ; } } else { xmlFatalErr ( ctxt , XML_ERR_PCDATA_REQUIRED , NULL ) ; } return ( ret ) ; }
void WebGLBuffer :: BufferData ( GLenum target , uint64_t size , const void * data , GLenum usage ) { if ( ! CheckedInt < GLsizeiptr > ( size ) . isValid ( ) ) return mContext -> ErrorOutOfMemory ( "bad size" ) ; if ( ! ValidateBufferUsageEnum ( mContext , usage ) ) return ; #ifdef XP_MACOSX if ( mContext -> gl -> WorkAroundDriverBugs ( ) && size > INT32_MAX ) { mContext -> ErrorOutOfMemory ( "Allocation size too large." ) ; return ; } #endif const void * uploadData = data ; UniqueBuffer newIndexCache ; if ( target == LOCAL_GL_ELEMENT_ARRAY_BUFFER && mContext -> mNeedsIndexValidation ) { newIndexCache = malloc ( AssertedCast < size_t > ( size ) ) ; if ( ! newIndexCache ) { mContext -> ErrorOutOfMemory ( "Failed to alloc index cache." ) ; return ; } memcpy ( newIndexCache . get ( ) , data , size ) ; uploadData = newIndexCache . get ( ) ; } const auto & gl = mContext -> gl ; const ScopedLazyBind lazyBind ( gl , target , this ) ; const bool sizeChanges = ( size != ByteLength ( ) ) ; if ( sizeChanges ) { gl :: GLContext :: LocalErrorScope errorScope ( * gl ) ; gl -> fBufferData ( target , size , uploadData , usage ) ; const auto error = errorScope . GetError ( ) ; if ( error ) { MOZ_ASSERT ( error == LOCAL_GL_OUT_OF_MEMORY ) ; mContext -> ErrorOutOfMemory ( "Error from driver: 0x%04x" , error ) ; return ; } } else { gl -> fBufferData ( target , size , uploadData , usage ) ; } mContext -> OnDataAllocCall ( ) ; mUsage = usage ; mByteLength = size ; mFetchInvalidator . InvalidateCaches ( ) ; mIndexCache = std :: move ( newIndexCache ) ; if ( mIndexCache ) { if ( ! mIndexRanges . empty ( ) ) { mContext -> GeneratePerfWarning ( "[%p] Invalidating %u ranges." , this , uint32_t ( mIndexRanges . size ( ) ) ) ; mIndexRanges . clear ( ) ; } } ResetLastUpdateFenceId ( ) ; }
const Operator * JSOperatorBuilder :: CallForwardVarargs ( size_t arity , uint32_t start_index ) { CallForwardVarargsParameters parameters ( arity , start_index ) ; return new ( zone ( ) ) Operator1 < CallForwardVarargsParameters > ( IrOpcode :: kJSCallForwardVarargs , Operator :: kNoProperties , "JSCallForwardVarargs" , parameters . arity ( ) , 1 , 1 , 1 , 1 , 2 , parameters ) ; }
nsJSObjWrapper :: GetNewOrUsed ( NPP npp , JSContext * cx , JSObject * obj ) { if ( ! npp ) { NS_ERROR ( "Null NPP passed to nsJSObjWrapper::GetNewOrUsed()!" ) ; return nsnull ; } if ( ! cx ) { cx = GetJSContext ( npp ) ; if ( ! cx ) { NS_ERROR ( "Unable to find a JSContext in " "nsJSObjWrapper::GetNewOrUsed()!" ) ; return nsnull ; } } JSClass * clazz = JS_GET_CLASS ( cx , obj ) ; if ( clazz == & sNPObjectJSWrapperClass ) { NPObject * npobj = ( NPObject * ) :: JS_GetPrivate ( cx , obj ) ; return _retainobject ( npobj ) ; } if ( ! sJSObjWrappers . ops ) { static PLDHashTableOps ops = { PL_DHashAllocTable , PL_DHashFreeTable , JSObjWrapperHash , JSObjWrapperHashMatchEntry , PL_DHashMoveEntryStub , PL_DHashClearEntryStub , PL_DHashFinalizeStub } ; if ( ! PL_DHashTableInit ( & sJSObjWrappers , & ops , nsnull , sizeof ( JSObjWrapperHashEntry ) , 16 ) ) { NS_ERROR ( "Error initializing PLDHashTable!" ) ; return nsnull ; } } nsJSObjWrapperKey key ( obj , npp ) ; JSObjWrapperHashEntry * entry = static_cast < JSObjWrapperHashEntry * > ( PL_DHashTableOperate ( & sJSObjWrappers , & key , PL_DHASH_ADD ) ) ; if ( ! entry ) { return nsnull ; } if ( PL_DHASH_ENTRY_IS_BUSY ( entry ) && entry -> mJSObjWrapper ) { return _retainobject ( entry -> mJSObjWrapper ) ; } nsJSObjWrapper * wrapper = ( nsJSObjWrapper * ) _createobject ( npp , & sJSObjWrapperNPClass ) ; if ( ! wrapper ) { PL_DHashTableRawRemove ( & sJSObjWrappers , entry ) ; return nsnull ; } wrapper -> mJSObj = obj ; entry -> mJSObjWrapper = wrapper ; NS_ASSERTION ( wrapper -> mNpp == npp , "nsJSObjWrapper::mNpp not initialized!" ) ; JSAutoRequest ar ( cx ) ; if ( ! :: JS_AddNamedRoot ( cx , & wrapper -> mJSObj , "nsJSObjWrapper::mJSObject" ) ) { NS_ERROR ( "Failed to root JSObject!" ) ; _releaseobject ( wrapper ) ; PL_DHashTableRawRemove ( & sJSObjWrappers , entry ) ; return nsnull ; } return wrapper ; }
Parser :: functionBody ( ) { JSStmtInfo stmtInfo ; uintN oldflags , firstLine ; JSParseNode * pn ; JS_ASSERT ( tc -> inFunction ( ) ) ; js_PushStatement ( tc , & stmtInfo , STMT_BLOCK , - 1 ) ; stmtInfo . flags = SIF_BODY_BLOCK ; oldflags = tc -> flags ; tc -> flags &= ~ ( TCF_RETURN_EXPR | TCF_RETURN_VOID ) ; firstLine = tokenStream . getLineno ( ) ; #if JS_HAS_EXPR_CLOSURES if ( tokenStream . currentToken ( ) . type == TOK_LC ) { pn = statements ( ) ; } else { pn = UnaryNode :: create ( tc ) ; if ( pn ) { pn -> pn_kid = assignExpr ( ) ; if ( ! pn -> pn_kid ) { pn = NULL ; } else { if ( tc -> flags & TCF_FUN_IS_GENERATOR ) { ReportBadReturn ( context , tc , JSREPORT_ERROR , JSMSG_BAD_GENERATOR_RETURN , JSMSG_BAD_ANON_GENERATOR_RETURN ) ; pn = NULL ; } else { pn -> pn_type = TOK_RETURN ; pn -> pn_op = JSOP_RETURN ; pn -> pn_pos . end = pn -> pn_kid -> pn_pos . end ; } } } } #else pn = statements ( ) ; #endif if ( pn ) { JS_ASSERT ( ! ( tc -> topStmt -> flags & SIF_SCOPE ) ) ; js_PopStatement ( tc ) ; pn -> pn_pos . begin . lineno = firstLine ; if ( context -> hasStrictOption ( ) && ( tc -> flags & TCF_RETURN_EXPR ) && ! CheckFinalReturn ( context , tc , pn ) ) { pn = NULL ; } } tc -> flags = oldflags | ( tc -> flags & TCF_FUN_FLAGS ) ; return pn ; }
bool ExtractBooleanSetting ( Isolate * isolate , Handle < JSObject > options , const char * key , bool * value ) { Handle < String > str = isolate -> factory ( ) -> NewStringFromAsciiChecked ( key ) ; Handle < Object > object = JSReceiver :: GetProperty ( isolate , options , str ) . ToHandleChecked ( ) ; if ( object -> IsBoolean ( ) ) { * value = object -> BooleanValue ( isolate ) ; return true ; } return false ; }
static inline int l2cap_config_req ( struct l2cap_conn * conn , struct l2cap_cmd_hdr * cmd , u16 cmd_len , u8 * data ) { struct l2cap_conf_req * req = ( struct l2cap_conf_req * ) data ; u16 dcid , flags ; u8 rsp [ 64 ] ; struct sock * sk ; int len ; dcid = __le16_to_cpu ( req -> dcid ) ; flags = __le16_to_cpu ( req -> flags ) ; BT_DBG ( "dcid 0x%4.4x flags 0x%2.2x" , dcid , flags ) ; sk = l2cap_get_chan_by_scid ( & conn -> chan_list , dcid ) ; if ( ! sk ) return - ENOENT ; if ( sk -> sk_state == BT_DISCONN ) goto unlock ; len = cmd_len - sizeof ( * req ) ; if ( l2cap_pi ( sk ) -> conf_len + len > sizeof ( l2cap_pi ( sk ) -> conf_req ) ) { l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , l2cap_build_conf_rsp ( sk , rsp , L2CAP_CONF_REJECT , flags ) , rsp ) ; goto unlock ; } memcpy ( l2cap_pi ( sk ) -> conf_req + l2cap_pi ( sk ) -> conf_len , req -> data , len ) ; l2cap_pi ( sk ) -> conf_len += len ; if ( flags & 0x0001 ) { l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , l2cap_build_conf_rsp ( sk , rsp , L2CAP_CONF_SUCCESS , 0x0001 ) , rsp ) ; goto unlock ; } len = l2cap_parse_conf_req ( sk , rsp ) ; if ( len < 0 ) goto unlock ; l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , len , rsp ) ; l2cap_pi ( sk ) -> conf_len = 0 ; if ( ! ( l2cap_pi ( sk ) -> conf_state & L2CAP_CONF_OUTPUT_DONE ) ) goto unlock ; if ( l2cap_pi ( sk ) -> conf_state & L2CAP_CONF_INPUT_DONE ) { sk -> sk_state = BT_CONNECTED ; l2cap_chan_ready ( sk ) ; goto unlock ; } if ( ! ( l2cap_pi ( sk ) -> conf_state & L2CAP_CONF_REQ_SENT ) ) { u8 buf [ 64 ] ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , l2cap_build_conf_req ( sk , buf ) , buf ) ; } unlock : bh_unlock_sock ( sk ) ; return 0 ; }
TF_BUILTIN ( ListFormatPrototypeFormatToParts , IntlBuiltinsAssembler ) { ListFormatCommon ( CAST ( Parameter ( Descriptor :: kContext ) ) , UncheckedCast < Int32T > ( Parameter ( Descriptor :: kJSActualArgumentsCount ) ) , Runtime :: kFormatListToParts , "Intl.ListFormat.prototype.formatToParts" ) ; }
static size_t format_commit_item ( struct strbuf * sb , const char * placeholder , void * context ) { int consumed ; size_t orig_len ; enum { NO_MAGIC , ADD_LF_BEFORE_NON_EMPTY , DEL_LF_BEFORE_EMPTY , ADD_SP_BEFORE_NON_EMPTY } magic = NO_MAGIC ; switch ( placeholder [ 0 ] ) { case '-' : magic = DEL_LF_BEFORE_EMPTY ; break ; case '+' : magic = ADD_LF_BEFORE_NON_EMPTY ; break ; case ' ' : magic = ADD_SP_BEFORE_NON_EMPTY ; break ; default : break ; } if ( magic != NO_MAGIC ) placeholder ++ ; orig_len = sb -> len ; if ( ( ( struct format_commit_context * ) context ) -> flush_type != no_flush ) consumed = format_and_pad_commit ( sb , placeholder , context ) ; else consumed = format_commit_one ( sb , placeholder , context ) ; if ( magic == NO_MAGIC ) return consumed ; if ( ( orig_len == sb -> len ) && magic == DEL_LF_BEFORE_EMPTY ) { while ( sb -> len && sb -> buf [ sb -> len - 1 ] == '\n' ) strbuf_setlen ( sb , sb -> len - 1 ) ; } else if ( orig_len != sb -> len ) { if ( magic == ADD_LF_BEFORE_NON_EMPTY ) strbuf_insertstr ( sb , orig_len , "\n" ) ; else if ( magic == ADD_SP_BEFORE_NON_EMPTY ) strbuf_insertstr ( sb , orig_len , " " ) ; } return consumed + 1 ; }
static int get_default_root ( pool * p , int allow_symlinks , const char * * root ) { config_rec * c = NULL ; const char * dir = NULL ; int res ; c = find_config ( main_server -> conf , CONF_PARAM , "DefaultRoot" , FALSE ) ; while ( c != NULL ) { pr_signals_handle ( ) ; if ( c -> argc < 2 ) { dir = c -> argv [ 0 ] ; break ; } res = pr_expr_eval_group_and ( ( ( char * * ) c -> argv ) + 1 ) ; if ( res ) { dir = c -> argv [ 0 ] ; break ; } c = find_config_next ( c , c -> next , CONF_PARAM , "DefaultRoot" , FALSE ) ; } if ( dir != NULL ) { const char * new_dir ; new_dir = path_subst_uservar ( p , & dir ) ; if ( new_dir != NULL ) { dir = new_dir ; } if ( strncmp ( dir , "/" , 2 ) == 0 ) { dir = NULL ; } else { char * realdir ; int xerrno = 0 ; if ( allow_symlinks == FALSE ) { char * path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ; struct stat st ; size_t pathlen ; path = pstrdup ( p , dir ) ; if ( * path != '/' ) { if ( * path == '~' ) { if ( pr_fs_interpolate ( dir , target_path , sizeof ( target_path ) - 1 ) < 0 ) { return - 1 ; } path = target_path ; } } pathlen = strlen ( path ) ; if ( pathlen > 1 && path [ pathlen - 1 ] == '/' ) { path [ pathlen - 1 ] = '\0' ; } pr_fs_clear_cache2 ( path ) ; res = pr_fsio_lstat ( path , & st ) ; if ( res < 0 ) { xerrno = errno ; pr_log_pri ( PR_LOG_WARNING , "error: unable to check %s: %s" , path , strerror ( xerrno ) ) ; errno = xerrno ; return - 1 ; } if ( S_ISLNK ( st . st_mode ) ) { pr_log_pri ( PR_LOG_WARNING , "error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks " "config)" , path ) ; errno = EPERM ; return - 1 ; } } pr_fs_clear_cache2 ( dir ) ; PRIVS_USER realdir = dir_realpath ( p , dir ) ; xerrno = errno ; PRIVS_RELINQUISH if ( realdir ) { dir = realdir ; } else { char interp_dir [ PR_TUNABLE_PATH_MAX + 1 ] ; memset ( interp_dir , '\0' , sizeof ( interp_dir ) ) ; ( void ) pr_fs_interpolate ( dir , interp_dir , sizeof ( interp_dir ) - 1 ) ; pr_log_pri ( PR_LOG_NOTICE , "notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s" , dir , interp_dir , strerror ( xerrno ) ) ; errno = xerrno ; } } } * root = dir ; return 0 ; }
ArrayBufferBuilder :: append ( const uint8_t * aNewData , uint32_t aDataLen , uint32_t aMaxGrowth ) { MOZ_ASSERT ( ! mMapPtr ) ; if ( mLength + aDataLen > mCapacity ) { uint32_t newcap ; if ( ! aMaxGrowth || mCapacity < aMaxGrowth ) { newcap = mCapacity * 2 ; } else { newcap = mCapacity + aMaxGrowth ; } if ( newcap < mLength + aDataLen ) { newcap = mLength + aDataLen ; } if ( newcap < mCapacity ) { return false ; } if ( ! setCapacity ( newcap ) ) { return false ; } } MOZ_ASSERT ( ! areOverlappingRegions ( aNewData , aDataLen , mDataPtr + mLength , aDataLen ) ) ; memcpy ( mDataPtr + mLength , aNewData , aDataLen ) ; mLength += aDataLen ; return true ; }
Handle < Map > Factory :: CreateSloppyFunctionMap ( FunctionMode function_mode , MaybeHandle < JSFunction > maybe_empty_function ) { bool has_prototype = IsFunctionModeWithPrototype ( function_mode ) ; int header_size = has_prototype ? JSFunction :: kSizeWithPrototype : JSFunction :: kSizeWithoutPrototype ; int descriptors_count = has_prototype ? 5 : 4 ; int inobject_properties_count = 0 ; if ( IsFunctionModeWithName ( function_mode ) ) ++ inobject_properties_count ; Handle < Map > map = NewMap ( JS_FUNCTION_TYPE , header_size + inobject_properties_count * kPointerSize , TERMINAL_FAST_ELEMENTS_KIND , inobject_properties_count ) ; map -> set_has_prototype_slot ( has_prototype ) ; map -> set_is_constructor ( has_prototype ) ; map -> set_is_callable ( true ) ; Handle < JSFunction > empty_function ; if ( maybe_empty_function . ToHandle ( & empty_function ) ) { Map :: SetPrototype ( isolate ( ) , map , empty_function ) ; } Map :: EnsureDescriptorSlack ( isolate ( ) , map , descriptors_count ) ; PropertyAttributes ro_attribs = static_cast < PropertyAttributes > ( DONT_ENUM | DONT_DELETE | READ_ONLY ) ; PropertyAttributes rw_attribs = static_cast < PropertyAttributes > ( DONT_ENUM | DONT_DELETE ) ; PropertyAttributes roc_attribs = static_cast < PropertyAttributes > ( DONT_ENUM | READ_ONLY ) ; int field_index = 0 ; STATIC_ASSERT ( JSFunction :: kLengthDescriptorIndex == 0 ) ; { Descriptor d = Descriptor :: AccessorConstant ( length_string ( ) , function_length_accessor ( ) , roc_attribs ) ; map -> AppendDescriptor ( & d ) ; } STATIC_ASSERT ( JSFunction :: kNameDescriptorIndex == 1 ) ; if ( IsFunctionModeWithName ( function_mode ) ) { Handle < Name > name = isolate ( ) -> factory ( ) -> name_string ( ) ; Descriptor d = Descriptor :: DataField ( isolate ( ) , name , field_index ++ , roc_attribs , Representation :: Tagged ( ) ) ; map -> AppendDescriptor ( & d ) ; } else { Descriptor d = Descriptor :: AccessorConstant ( name_string ( ) , function_name_accessor ( ) , roc_attribs ) ; map -> AppendDescriptor ( & d ) ; } { Descriptor d = Descriptor :: AccessorConstant ( arguments_string ( ) , function_arguments_accessor ( ) , ro_attribs ) ; map -> AppendDescriptor ( & d ) ; } { Descriptor d = Descriptor :: AccessorConstant ( caller_string ( ) , function_caller_accessor ( ) , ro_attribs ) ; map -> AppendDescriptor ( & d ) ; } if ( IsFunctionModeWithPrototype ( function_mode ) ) { PropertyAttributes attribs = IsFunctionModeWithWritablePrototype ( function_mode ) ? rw_attribs : ro_attribs ; Descriptor d = Descriptor :: AccessorConstant ( prototype_string ( ) , function_prototype_accessor ( ) , attribs ) ; map -> AppendDescriptor ( & d ) ; } DCHECK_EQ ( inobject_properties_count , field_index ) ; return map ; }
LoadInfoArgsToLoadInfo ( const OptionalLoadInfoArgs & aOptionalLoadInfoArgs , nsILoadInfo * * outLoadInfo ) { if ( aOptionalLoadInfoArgs . type ( ) == OptionalLoadInfoArgs :: Tvoid_t ) { * outLoadInfo = nullptr ; return NS_OK ; } const LoadInfoArgs & loadInfoArgs = aOptionalLoadInfoArgs . get_LoadInfoArgs ( ) ; nsresult rv = NS_OK ; nsCOMPtr < nsIPrincipal > loadingPrincipal ; if ( loadInfoArgs . requestingPrincipalInfo ( ) . type ( ) != OptionalPrincipalInfo :: Tvoid_t ) { loadingPrincipal = PrincipalInfoToPrincipal ( loadInfoArgs . requestingPrincipalInfo ( ) , & rv ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIPrincipal > triggeringPrincipal = PrincipalInfoToPrincipal ( loadInfoArgs . triggeringPrincipalInfo ( ) , & rv ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIPrincipal > principalToInherit ; if ( loadInfoArgs . principalToInheritInfo ( ) . type ( ) != OptionalPrincipalInfo :: Tvoid_t ) { principalToInherit = PrincipalInfoToPrincipal ( loadInfoArgs . principalToInheritInfo ( ) , & rv ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } nsCOMPtr < nsIPrincipal > sandboxedLoadingPrincipal ; if ( loadInfoArgs . sandboxedLoadingPrincipalInfo ( ) . type ( ) != OptionalPrincipalInfo :: Tvoid_t ) { sandboxedLoadingPrincipal = PrincipalInfoToPrincipal ( loadInfoArgs . sandboxedLoadingPrincipalInfo ( ) , & rv ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } nsCOMPtr < nsIURI > resultPrincipalURI ; if ( loadInfoArgs . resultPrincipalURI ( ) . type ( ) != OptionalURIParams :: Tvoid_t ) { resultPrincipalURI = DeserializeURI ( loadInfoArgs . resultPrincipalURI ( ) ) ; NS_ENSURE_TRUE ( resultPrincipalURI , NS_ERROR_UNEXPECTED ) ; } RedirectHistoryArray redirectChainIncludingInternalRedirects ; for ( const RedirectHistoryEntryInfo & entryInfo : loadInfoArgs . redirectChainIncludingInternalRedirects ( ) ) { nsCOMPtr < nsIRedirectHistoryEntry > redirectHistoryEntry = RHEntryInfoToRHEntry ( entryInfo ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; redirectChainIncludingInternalRedirects . AppendElement ( redirectHistoryEntry . forget ( ) ) ; } RedirectHistoryArray redirectChain ; for ( const RedirectHistoryEntryInfo & entryInfo : loadInfoArgs . redirectChain ( ) ) { nsCOMPtr < nsIRedirectHistoryEntry > redirectHistoryEntry = RHEntryInfoToRHEntry ( entryInfo ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; redirectChain . AppendElement ( redirectHistoryEntry . forget ( ) ) ; } nsTArray < nsCOMPtr < nsIPrincipal > > ancestorPrincipals ; ancestorPrincipals . SetCapacity ( loadInfoArgs . ancestorPrincipals ( ) . Length ( ) ) ; for ( const PrincipalInfo & principalInfo : loadInfoArgs . ancestorPrincipals ( ) ) { nsCOMPtr < nsIPrincipal > ancestorPrincipal = PrincipalInfoToPrincipal ( principalInfo , & rv ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; ancestorPrincipals . AppendElement ( ancestorPrincipal . forget ( ) ) ; } Maybe < ClientInfo > clientInfo ; if ( loadInfoArgs . clientInfo ( ) . type ( ) != OptionalIPCClientInfo :: Tvoid_t ) { clientInfo . emplace ( ClientInfo ( loadInfoArgs . clientInfo ( ) . get_IPCClientInfo ( ) ) ) ; } Maybe < ClientInfo > reservedClientInfo ; if ( loadInfoArgs . reservedClientInfo ( ) . type ( ) != OptionalIPCClientInfo :: Tvoid_t ) { reservedClientInfo . emplace ( ClientInfo ( loadInfoArgs . reservedClientInfo ( ) . get_IPCClientInfo ( ) ) ) ; } Maybe < ClientInfo > initialClientInfo ; if ( loadInfoArgs . initialClientInfo ( ) . type ( ) != OptionalIPCClientInfo :: Tvoid_t ) { initialClientInfo . emplace ( ClientInfo ( loadInfoArgs . initialClientInfo ( ) . get_IPCClientInfo ( ) ) ) ; } MOZ_DIAGNOSTIC_ASSERT ( reservedClientInfo . isNothing ( ) || initialClientInfo . isNothing ( ) ) ; NS_ENSURE_TRUE ( reservedClientInfo . isNothing ( ) || initialClientInfo . isNothing ( ) , NS_ERROR_UNEXPECTED ) ; Maybe < ServiceWorkerDescriptor > controller ; if ( loadInfoArgs . controller ( ) . type ( ) != OptionalIPCServiceWorkerDescriptor :: Tvoid_t ) { controller . emplace ( ServiceWorkerDescriptor ( loadInfoArgs . controller ( ) . get_IPCServiceWorkerDescriptor ( ) ) ) ; } nsCOMPtr < nsILoadInfo > loadInfo = new mozilla :: LoadInfo ( loadingPrincipal , triggeringPrincipal , principalToInherit , sandboxedLoadingPrincipal , resultPrincipalURI , clientInfo , reservedClientInfo , initialClientInfo , controller , loadInfoArgs . securityFlags ( ) , loadInfoArgs . contentPolicyType ( ) , static_cast < LoadTainting > ( loadInfoArgs . tainting ( ) ) , loadInfoArgs . upgradeInsecureRequests ( ) , loadInfoArgs . verifySignedContent ( ) , loadInfoArgs . enforceSRI ( ) , loadInfoArgs . forceAllowDataURI ( ) , loadInfoArgs . forceInheritPrincipalDropped ( ) , loadInfoArgs . innerWindowID ( ) , loadInfoArgs . outerWindowID ( ) , loadInfoArgs . parentOuterWindowID ( ) , loadInfoArgs . topOuterWindowID ( ) , loadInfoArgs . frameOuterWindowID ( ) , loadInfoArgs . enforceSecurity ( ) , loadInfoArgs . initialSecurityCheckDone ( ) , loadInfoArgs . isInThirdPartyContext ( ) , loadInfoArgs . isDocshellReload ( ) , loadInfoArgs . originAttributes ( ) , redirectChainIncludingInternalRedirects , redirectChain , Move ( ancestorPrincipals ) , loadInfoArgs . ancestorOuterWindowIDs ( ) , loadInfoArgs . corsUnsafeHeaders ( ) , loadInfoArgs . forcePreflight ( ) , loadInfoArgs . isPreflight ( ) , loadInfoArgs . loadTriggeredFromExternal ( ) , loadInfoArgs . serviceWorkerTaintingSynthesized ( ) ) ; loadInfo . forget ( outLoadInfo ) ; return NS_OK ; }
explicit DataFormatDimMapOp ( OpKernelConstruction * context ) : OpKernel ( context ) { string src_format ; OP_REQUIRES_OK ( context , context -> GetAttr ( "src_format" , & src_format ) ) ; string dst_format ; OP_REQUIRES_OK ( context , context -> GetAttr ( "dst_format" , & dst_format ) ) ; OP_REQUIRES ( context , src_format . size ( ) == 4 || src_format . size ( ) == 5 , errors :: InvalidArgument ( strings :: StrCat ( "Source format must of length 4 or 5, received " "src_format = " , src_format ) ) ) ; OP_REQUIRES ( context , dst_format . size ( ) == 4 || dst_format . size ( ) == 5 , errors :: InvalidArgument ( strings :: StrCat ( "Destination format must of length 4 or 5, received dst_format = " , dst_format ) ) ) ; dst_idx_ = Tensor ( DT_INT32 , { static_cast < int64 > ( src_format . size ( ) ) } ) ; for ( int i = 0 ; i < src_format . size ( ) ; ++ i ) { for ( int j = 0 ; j < dst_format . size ( ) ; ++ j ) { if ( dst_format [ j ] == src_format [ i ] ) { dst_idx_ . vec < int > ( ) ( i ) = j ; break ; } } } }
ChannelWrapper :: GetCanModify ( ErrorResult & aRv ) const { nsCOMPtr < nsIURI > uri = FinalURI ( ) ; nsAutoCString spec ; if ( uri ) { uri -> GetSpec ( spec ) ; } if ( ! uri || AddonManagerWebAPI :: IsValidSite ( uri ) ) { return false ; } if ( nsCOMPtr < nsILoadInfo > loadInfo = GetLoadInfo ( ) ) { if ( nsIPrincipal * prin = loadInfo -> LoadingPrincipal ( ) ) { if ( IsSystemPrincipal ( prin ) ) { return false ; } if ( prin -> GetIsCodebasePrincipal ( ) && ( NS_FAILED ( prin -> GetURI ( getter_AddRefs ( uri ) ) ) || AddonManagerWebAPI :: IsValidSite ( uri ) ) ) { return false ; } } } return true ; }
TF_BUILTIN ( DatePrototypeGetUTCSeconds , DateBuiltinsAssembler ) { Node * context = Parameter ( Descriptor :: kContext ) ; Node * receiver = Parameter ( Descriptor :: kReceiver ) ; Generate_DatePrototype_GetField ( context , receiver , JSDate :: kSecondUTC ) ; }
static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , "submodule" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , "disallowed submodule name: %s" , name ) ; if ( ! strcmp ( key , "url" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , "disallowed submodule url: %s" , value ) ; free ( name ) ; return 0 ; }
UpdateFilePreviewWidget ( GtkFileChooser * file_chooser , gpointer preview_widget_voidptr ) { GtkImage * preview_widget = GTK_IMAGE ( preview_widget_voidptr ) ; char * image_filename = gtk_file_chooser_get_preview_filename ( file_chooser ) ; struct stat st_buf ; if ( ! image_filename ) { gtk_file_chooser_set_preview_widget_active ( file_chooser , FALSE ) ; return ; } gint preview_width = 0 ; gint preview_height = 0 ; if ( stat ( image_filename , & st_buf ) || ( ! S_ISREG ( st_buf . st_mode ) ) ) { g_free ( image_filename ) ; gtk_file_chooser_set_preview_widget_active ( file_chooser , FALSE ) ; return ; } GdkPixbufFormat * preview_format = gdk_pixbuf_get_file_info ( image_filename , & preview_width , & preview_height ) ; if ( ! preview_format ) { g_free ( image_filename ) ; gtk_file_chooser_set_preview_widget_active ( file_chooser , FALSE ) ; return ; } GdkPixbuf * preview_pixbuf ; if ( preview_width > MAX_PREVIEW_SIZE || preview_height > MAX_PREVIEW_SIZE ) { preview_pixbuf = gdk_pixbuf_new_from_file_at_size ( image_filename , MAX_PREVIEW_SIZE , MAX_PREVIEW_SIZE , nullptr ) ; } else { preview_pixbuf = gdk_pixbuf_new_from_file ( image_filename , nullptr ) ; } g_free ( image_filename ) ; if ( ! preview_pixbuf ) { gtk_file_chooser_set_preview_widget_active ( file_chooser , FALSE ) ; return ; } GdkPixbuf * preview_pixbuf_temp = preview_pixbuf ; preview_pixbuf = gdk_pixbuf_apply_embedded_orientation ( preview_pixbuf_temp ) ; g_object_unref ( preview_pixbuf_temp ) ; gint x_padding = ( MAX_PREVIEW_SIZE + 6 - gdk_pixbuf_get_width ( preview_pixbuf ) ) / 2 ; gtk_misc_set_padding ( GTK_MISC ( preview_widget ) , x_padding , 0 ) ; gtk_image_set_from_pixbuf ( preview_widget , preview_pixbuf ) ; g_object_unref ( preview_pixbuf ) ; gtk_file_chooser_set_preview_widget_active ( file_chooser , TRUE ) ; }
static int snd_ctl_elem_write ( struct snd_card * card , struct snd_ctl_file * file , struct snd_ctl_elem_value * control ) { struct snd_kcontrol * kctl ; struct snd_kcontrol_volatile * vd ; unsigned int index_offset ; int result ; down_read ( & card -> controls_rwsem ) ; kctl = snd_ctl_find_id ( card , & control -> id ) ; if ( kctl == NULL ) { result = - ENOENT ; } else { index_offset = snd_ctl_get_ioff ( kctl , & control -> id ) ; vd = & kctl -> vd [ index_offset ] ; if ( ! ( vd -> access & SNDRV_CTL_ELEM_ACCESS_WRITE ) || kctl -> put == NULL || ( file && vd -> owner && vd -> owner != file ) ) { result = - EPERM ; } else { snd_ctl_build_ioff ( & control -> id , kctl , index_offset ) ; result = kctl -> put ( kctl , control ) ; } if ( result > 0 ) { up_read ( & card -> controls_rwsem ) ; snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , & control -> id ) ; return 0 ; } } up_read ( & card -> controls_rwsem ) ; return result ; }
void OnBeforeURLRequestAdBlockTP ( const ResponseCallback & next_callback , std :: shared_ptr < BraveRequestInfo > ctx ) { DCHECK_CURRENTLY_ON ( content :: BrowserThread :: UI ) ; if ( ctx -> tab_origin . is_empty ( ) || ! ctx -> tab_origin . has_host ( ) || ctx -> request_url . is_empty ( ) ) { return ; } DCHECK_NE ( ctx -> request_identifier , 0UL ) ; scoped_refptr < base :: SequencedTaskRunner > task_runner = g_brave_browser_process -> ad_block_service ( ) -> GetTaskRunner ( ) ; new AdblockCnameResolveHostClient ( std :: move ( next_callback ) , task_runner , ctx ) ; }
PixarLogSetupDecode ( TIFF * tif ) { static const char module [ ] = "PixarLogSetupDecode" ; TIFFDirectory * td = & tif -> tif_dir ; PixarLogState * sp = DecoderState ( tif ) ; tmsize_t tbuf_size ; assert ( sp != NULL ) ; tif -> tif_postdecode = _TIFFNoPostDecode ; sp -> stride = ( td -> td_planarconfig == PLANARCONFIG_CONTIG ? td -> td_samplesperpixel : 1 ) ; tbuf_size = multiply_ms ( multiply_ms ( multiply_ms ( sp -> stride , td -> td_imagewidth ) , td -> td_rowsperstrip ) , sizeof ( uint16 ) ) ; tbuf_size = add_ms ( tbuf_size , sizeof ( uint16 ) * sp -> stride ) ; if ( tbuf_size == 0 ) return ( 0 ) ; sp -> tbuf = ( uint16 * ) _TIFFmalloc ( tbuf_size ) ; if ( sp -> tbuf == NULL ) return ( 0 ) ; if ( sp -> user_datafmt == PIXARLOGDATAFMT_UNKNOWN ) sp -> user_datafmt = PixarLogGuessDataFmt ( td ) ; if ( sp -> user_datafmt == PIXARLOGDATAFMT_UNKNOWN ) { TIFFErrorExt ( tif -> tif_clientdata , module , "PixarLog compression can't handle bits depth/data format combination (depth: %d)" , td -> td_bitspersample ) ; return ( 0 ) ; } if ( inflateInit ( & sp -> stream ) != Z_OK ) { TIFFErrorExt ( tif -> tif_clientdata , module , "%s" , sp -> stream . msg ? sp -> stream . msg : "(null)" ) ; return ( 0 ) ; } else { sp -> state |= PLSTATE_INIT ; return ( 1 ) ; } }
void SkHeifCodec :: initializeSwizzler ( const SkImageInfo & dstInfo , const Options & options ) { SkEncodedInfo swizzlerInfo = this -> getEncodedInfo ( ) ; SkImageInfo swizzlerDstInfo = dstInfo ; if ( this -> colorXform ( ) ) { swizzlerDstInfo = swizzlerDstInfo . makeColorType ( kRGBA_8888_SkColorType ) ; } fSwizzler . reset ( SkSwizzler :: CreateSwizzler ( swizzlerInfo , nullptr , swizzlerDstInfo , options , nullptr , true ) ) ; SkASSERT ( fSwizzler ) ; }
void vp9_vaq_frame_setup ( VP9_COMP * cpi ) { VP9_COMMON * cm = & cpi -> common ; struct segmentation * seg = & cm -> seg ; const double base_q = vp9_convert_qindex_to_q ( cm -> base_qindex ) ; const int base_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + cm -> y_dc_delta_q ) ; int i ; if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_clear_system_state ( ) ; for ( i = ENERGY_MIN ; i <= ENERGY_MAX ; i ++ ) { int qindex_delta , segment_rdmult ; if ( Q_RATIO ( i ) == 1 ) { RDMULT_RATIO ( i ) = 1 ; continue ; } qindex_delta = vp9_compute_qdelta ( & cpi -> rc , base_q , base_q * Q_RATIO ( i ) ) ; vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ; vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ; segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta + cm -> y_dc_delta_q ) ; RDMULT_RATIO ( i ) = ( double ) segment_rdmult / base_rdmult ; } } }
SkCodec :: Result SkJpegCodec :: onStartScanlineDecode ( const SkImageInfo & dstInfo , const Options & options , SkPMColor ctable [ ] , int * ctableCount ) { if ( setjmp ( fDecoderMgr -> getJmpBuf ( ) ) ) { SkCodecPrintf ( "setjmp: Error from libjpeg\n" ) ; return kInvalidInput ; } if ( ! this -> setOutputColorSpace ( dstInfo ) ) { return kInvalidConversion ; } fSwizzler . reset ( nullptr ) ; fSrcRow = nullptr ; fStorage . free ( ) ; if ( ! jpeg_start_decompress ( fDecoderMgr -> dinfo ( ) ) ) { SkCodecPrintf ( "start decompress failed\n" ) ; return kInvalidInput ; } if ( options . fSubset ) { fSwizzlerSubset = * options . fSubset ; } #ifdef TURBO_HAS_CROP if ( options . fSubset ) { uint32_t startX = options . fSubset -> x ( ) ; uint32_t width = options . fSubset -> width ( ) ; jpeg_crop_scanline ( fDecoderMgr -> dinfo ( ) , & startX , & width ) ; SkASSERT ( startX <= ( uint32_t ) options . fSubset -> x ( ) ) ; SkASSERT ( width >= ( uint32_t ) options . fSubset -> width ( ) ) ; SkASSERT ( startX + width >= ( uint32_t ) options . fSubset -> right ( ) ) ; fSwizzlerSubset . setXYWH ( options . fSubset -> x ( ) - startX , 0 , options . fSubset -> width ( ) , options . fSubset -> height ( ) ) ; if ( startX != ( uint32_t ) options . fSubset -> x ( ) || width != ( uint32_t ) options . fSubset -> width ( ) ) { this -> initializeSwizzler ( dstInfo , options ) ; } } if ( ! fSwizzler && JCS_CMYK == fDecoderMgr -> dinfo ( ) -> out_color_space ) { this -> initializeSwizzler ( dstInfo , options ) ; } #else J_COLOR_SPACE colorSpace = fDecoderMgr -> dinfo ( ) -> out_color_space ; if ( options . fSubset || JCS_CMYK == colorSpace || JCS_RGB == colorSpace ) { this -> initializeSwizzler ( dstInfo , options ) ; } #endif return kSuccess ; }
static int fsl_lpspi_probe ( struct platform_device * pdev ) { struct device_node * np = pdev -> dev . of_node ; struct fsl_lpspi_data * fsl_lpspi ; struct spi_controller * controller ; struct spi_imx_master * lpspi_platform_info = dev_get_platdata ( & pdev -> dev ) ; struct resource * res ; int i , ret , irq ; u32 temp ; bool is_slave ; is_slave = of_property_read_bool ( ( & pdev -> dev ) -> of_node , "spi-slave" ) ; if ( is_slave ) controller = spi_alloc_slave ( & pdev -> dev , sizeof ( struct fsl_lpspi_data ) ) ; else controller = spi_alloc_master ( & pdev -> dev , sizeof ( struct fsl_lpspi_data ) ) ; if ( ! controller ) return - ENOMEM ; platform_set_drvdata ( pdev , controller ) ; fsl_lpspi = spi_controller_get_devdata ( controller ) ; fsl_lpspi -> dev = & pdev -> dev ; fsl_lpspi -> is_slave = is_slave ; if ( ! fsl_lpspi -> is_slave ) { for ( i = 0 ; i < controller -> num_chipselect ; i ++ ) { int cs_gpio = of_get_named_gpio ( np , "cs-gpios" , i ) ; if ( ! gpio_is_valid ( cs_gpio ) && lpspi_platform_info ) cs_gpio = lpspi_platform_info -> chipselect [ i ] ; fsl_lpspi -> chipselect [ i ] = cs_gpio ; if ( ! gpio_is_valid ( cs_gpio ) ) continue ; ret = devm_gpio_request ( & pdev -> dev , fsl_lpspi -> chipselect [ i ] , DRIVER_NAME ) ; if ( ret ) { dev_err ( & pdev -> dev , "can't get cs gpios\n" ) ; goto out_controller_put ; } } controller -> cs_gpios = fsl_lpspi -> chipselect ; controller -> prepare_message = fsl_lpspi_prepare_message ; } controller -> bits_per_word_mask = SPI_BPW_RANGE_MASK ( 8 , 32 ) ; controller -> transfer_one = fsl_lpspi_transfer_one ; controller -> prepare_transfer_hardware = lpspi_prepare_xfer_hardware ; controller -> unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware ; controller -> mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH ; controller -> flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX ; controller -> dev . of_node = pdev -> dev . of_node ; controller -> bus_num = pdev -> id ; controller -> slave_abort = fsl_lpspi_slave_abort ; init_completion ( & fsl_lpspi -> xfer_done ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; fsl_lpspi -> base = devm_ioremap_resource ( & pdev -> dev , res ) ; if ( IS_ERR ( fsl_lpspi -> base ) ) { ret = PTR_ERR ( fsl_lpspi -> base ) ; goto out_controller_put ; } fsl_lpspi -> base_phys = res -> start ; irq = platform_get_irq ( pdev , 0 ) ; if ( irq < 0 ) { ret = irq ; goto out_controller_put ; } ret = devm_request_irq ( & pdev -> dev , irq , fsl_lpspi_isr , 0 , dev_name ( & pdev -> dev ) , fsl_lpspi ) ; if ( ret ) { dev_err ( & pdev -> dev , "can't get irq%d: %d\n" , irq , ret ) ; goto out_controller_put ; } fsl_lpspi -> clk_per = devm_clk_get ( & pdev -> dev , "per" ) ; if ( IS_ERR ( fsl_lpspi -> clk_per ) ) { ret = PTR_ERR ( fsl_lpspi -> clk_per ) ; goto out_controller_put ; } fsl_lpspi -> clk_ipg = devm_clk_get ( & pdev -> dev , "ipg" ) ; if ( IS_ERR ( fsl_lpspi -> clk_ipg ) ) { ret = PTR_ERR ( fsl_lpspi -> clk_ipg ) ; goto out_controller_put ; } ret = fsl_lpspi_init_rpm ( fsl_lpspi ) ; if ( ret ) goto out_controller_put ; ret = pm_runtime_get_sync ( fsl_lpspi -> dev ) ; if ( ret < 0 ) { dev_err ( fsl_lpspi -> dev , "failed to enable clock\n" ) ; return ret ; } temp = readl ( fsl_lpspi -> base + IMX7ULP_PARAM ) ; fsl_lpspi -> txfifosize = 1 < < ( temp & 0x0f ) ; fsl_lpspi -> rxfifosize = 1 < < ( ( temp > > 8 ) & 0x0f ) ; ret = fsl_lpspi_dma_init ( & pdev -> dev , fsl_lpspi , controller ) ; if ( ret == - EPROBE_DEFER ) goto out_controller_put ; if ( ret < 0 ) dev_err ( & pdev -> dev , "dma setup error %d, use pio\n" , ret ) ; ret = devm_spi_register_controller ( & pdev -> dev , controller ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , "spi_register_controller error.\n" ) ; goto out_controller_put ; } return 0 ; out_controller_put : spi_controller_put ( controller ) ; return ret ; }
void WasmCode :: Validate ( ) const { #ifdef DEBUG for ( RelocIterator it ( instructions ( ) , reloc_info ( ) , constant_pool ( ) ) ; ! it . done ( ) ; it . next ( ) ) { RelocInfo :: Mode mode = it . rinfo ( ) -> rmode ( ) ; switch ( mode ) { case RelocInfo :: WASM_CALL : { Address target = it . rinfo ( ) -> wasm_call_address ( ) ; WasmCode * code = native_module_ -> Lookup ( target ) ; CHECK_NOT_NULL ( code ) ; CHECK_EQ ( WasmCode :: kJumpTable , code -> kind ( ) ) ; CHECK ( code -> contains ( target ) ) ; break ; } case RelocInfo :: WASM_STUB_CALL : { Address target = it . rinfo ( ) -> wasm_stub_call_address ( ) ; WasmCode * code = native_module_ -> Lookup ( target ) ; CHECK_NOT_NULL ( code ) ; CHECK_EQ ( WasmCode :: kRuntimeStub , code -> kind ( ) ) ; CHECK_EQ ( target , code -> instruction_start ( ) ) ; break ; } case RelocInfo :: INTERNAL_REFERENCE : case RelocInfo :: INTERNAL_REFERENCE_ENCODED : { Address target = it . rinfo ( ) -> target_internal_reference ( ) ; CHECK ( contains ( target ) ) ; break ; } case RelocInfo :: JS_TO_WASM_CALL : case RelocInfo :: EXTERNAL_REFERENCE : case RelocInfo :: COMMENT : case RelocInfo :: CONST_POOL : case RelocInfo :: VENEER_POOL : break ; default : FATAL ( "Unexpected mode: %d" , mode ) ; } } #endif }
void ScopeIterator :: UnwrapEvaluationContext ( ) { if ( ! context_ -> IsDebugEvaluateContext ( ) ) return ; Context * current = * context_ ; do { Object * wrapped = current -> get ( Context :: WRAPPED_CONTEXT_INDEX ) ; if ( wrapped -> IsContext ( ) ) { current = Context :: cast ( wrapped ) ; } else { DCHECK_NOT_NULL ( current -> previous ( ) ) ; current = current -> previous ( ) ; } } while ( current -> IsDebugEvaluateContext ( ) ) ; context_ = handle ( current , isolate_ ) ; }
ossl_cipher_set_key ( VALUE self , VALUE key ) { EVP_CIPHER_CTX * ctx ; int key_len ; StringValue ( key ) ; GetCipher ( self , ctx ) ; key_len = EVP_CIPHER_CTX_key_length ( ctx ) ; if ( RSTRING_LEN ( key ) != key_len ) ossl_raise ( rb_eArgError , "key must be %d bytes" , key_len ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( key ) , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; return key ; }
JS_PUBLIC_API ( const char * ) JS :: detail :: InitWithFailureDiagnostic ( bool isDebugBuild ) { #ifdef DEBUG MOZ_RELEASE_ASSERT ( isDebugBuild ) ; #else MOZ_RELEASE_ASSERT ( ! isDebugBuild ) ; #endif MOZ_ASSERT ( libraryInitState == InitState :: Uninitialized , "must call JS_Init once before any JSAPI operation except " "JS_SetICUMemoryFunctions" ) ; MOZ_ASSERT ( ! JSRuntime :: hasLiveRuntimes ( ) , "how do we have live runtimes before JS_Init?" ) ; PRMJ_NowInit ( ) ; bool ignored ; mozilla :: TimeStamp :: ProcessCreation ( ignored ) ; #ifdef DEBUG CheckMessageParameterCounts ( ) ; #endif RETURN_IF_FAIL ( js :: TlsContext . init ( ) ) ; #if defined(DEBUG) || defined(JS_OOM_BREAKPOINT) RETURN_IF_FAIL ( js :: oom :: InitThreadType ( ) ) ; js :: oom :: SetThreadType ( js :: oom :: THREAD_TYPE_MAIN ) ; #endif RETURN_IF_FAIL ( js :: Mutex :: Init ( ) ) ; RETURN_IF_FAIL ( js :: wasm :: InitInstanceStaticData ( ) ) ; js :: jit :: ExecutableAllocator :: initStatic ( ) ; MOZ_ALWAYS_TRUE ( js :: MemoryProtectionExceptionHandler :: install ( ) ) ; RETURN_IF_FAIL ( js :: jit :: InitializeIon ( ) ) ; RETURN_IF_FAIL ( js :: InitDateTimeState ( ) ) ; #if EXPOSE_INTL_API UErrorCode err = U_ZERO_ERROR ; u_init ( & err ) ; if ( U_FAILURE ( err ) ) return "u_init() failed" ; #endif // EXPOSE_INTL_API RETURN_IF_FAIL ( js :: CreateHelperThreadsState ( ) ) ; RETURN_IF_FAIL ( FutexThread :: initialize ( ) ) ; RETURN_IF_FAIL ( js :: gcstats :: Statistics :: initialize ( ) ) ; libraryInitState = InitState :: Running ; return nullptr ; }
bool FetchAndExecuteCompilationUnit ( CompilationState * compilation_state , WasmFeatures * detected ) { DisallowHeapAccess no_heap_access ; std :: unique_ptr < WasmCompilationUnit > unit = compilation_state -> GetNextCompilationUnit ( ) ; if ( unit == nullptr ) return false ; ExecutionTier mode = unit -> mode ( ) ; unit -> ExecuteCompilation ( detected ) ; compilation_state -> ScheduleUnitForFinishing ( std :: move ( unit ) , mode ) ; return true ; }
FieldAccess AccessBuilder :: ForHeapNumberValue ( ) { FieldAccess access = { kTaggedBase , HeapNumber :: kValueOffset , MaybeHandle < Name > ( ) , MaybeHandle < Map > ( ) , TypeCache :: Get ( ) . kFloat64 , MachineType :: Float64 ( ) , kNoWriteBarrier } ; return access ; }
void Heap :: PrintShortHeapStatistics ( ) { if ( ! FLAG_trace_gc_verbose ) return ; PrintIsolate ( isolate_ , "Memory allocator,       used: %6" PRIuS " KB," " available: %6" PRIuS " KB\n" , memory_allocator ( ) -> Size ( ) / KB , memory_allocator ( ) -> Available ( ) / KB ) ; PrintIsolate ( isolate_ , "Read-only space,        used: %6" PRIuS " KB" ", available: %6" PRIuS " KB" ", committed: %6" PRIuS " KB\n" , read_only_space_ -> Size ( ) / KB , read_only_space_ -> Available ( ) / KB , read_only_space_ -> CommittedMemory ( ) / KB ) ; PrintIsolate ( isolate_ , "New space,              used: %6" PRIuS " KB" ", available: %6" PRIuS " KB" ", committed: %6" PRIuS " KB\n" , new_space_ -> Size ( ) / KB , new_space_ -> Available ( ) / KB , new_space_ -> CommittedMemory ( ) / KB ) ; PrintIsolate ( isolate_ , "New large object space, used: %6" PRIuS " KB" ", available: %6" PRIuS " KB" ", committed: %6" PRIuS " KB\n" , new_lo_space_ -> SizeOfObjects ( ) / KB , new_lo_space_ -> Available ( ) / KB , new_lo_space_ -> CommittedMemory ( ) / KB ) ; PrintIsolate ( isolate_ , "Old space,              used: %6" PRIuS " KB" ", available: %6" PRIuS " KB" ", committed: %6" PRIuS " KB\n" , old_space_ -> SizeOfObjects ( ) / KB , old_space_ -> Available ( ) / KB , old_space_ -> CommittedMemory ( ) / KB ) ; PrintIsolate ( isolate_ , "Code space,             used: %6" PRIuS " KB" ", available: %6" PRIuS " KB" ", committed: %6" PRIuS "KB\n" , code_space_ -> SizeOfObjects ( ) / KB , code_space_ -> Available ( ) / KB , code_space_ -> CommittedMemory ( ) / KB ) ; PrintIsolate ( isolate_ , "Map space,              used: %6" PRIuS " KB" ", available: %6" PRIuS " KB" ", committed: %6" PRIuS " KB\n" , map_space_ -> SizeOfObjects ( ) / KB , map_space_ -> Available ( ) / KB , map_space_ -> CommittedMemory ( ) / KB ) ; PrintIsolate ( isolate_ , "Large object space,     used: %6" PRIuS " KB" ", available: %6" PRIuS " KB" ", committed: %6" PRIuS " KB\n" , lo_space_ -> SizeOfObjects ( ) / KB , lo_space_ -> Available ( ) / KB , lo_space_ -> CommittedMemory ( ) / KB ) ; PrintIsolate ( isolate_ , "All spaces,             used: %6" PRIuS " KB" ", available: %6" PRIuS " KB" ", committed: %6" PRIuS "KB\n" , this -> SizeOfObjects ( ) / KB , this -> Available ( ) / KB , this -> CommittedMemory ( ) / KB ) ; PrintIsolate ( isolate_ , "Unmapper buffering %d chunks of committed: %6" PRIuS " KB\n" , memory_allocator ( ) -> unmapper ( ) -> NumberOfChunks ( ) , CommittedMemoryOfHeapAndUnmapper ( ) / KB ) ; PrintIsolate ( isolate_ , "External memory reported: %6" PRId64 " KB\n" , external_memory_ / KB ) ; PrintIsolate ( isolate_ , "External memory global %zu KB\n" , external_memory_callback_ ( ) / KB ) ; PrintIsolate ( isolate_ , "Total time spent in GC  : %.1f ms\n" , total_gc_time_ms_ ) ; }
sctp_ss_prio_init_stream ( struct sctp_tcb * stcb , struct sctp_stream_out * strq , struct sctp_stream_out * with_strq ) { if ( with_strq != NULL ) { if ( stcb -> asoc . ss_data . locked_on_sending == with_strq ) { stcb -> asoc . ss_data . locked_on_sending = strq ; } if ( stcb -> asoc . ss_data . last_out_stream == with_strq ) { stcb -> asoc . ss_data . last_out_stream = strq ; } } strq -> ss_params . prio . next_spoke . tqe_next = NULL ; strq -> ss_params . prio . next_spoke . tqe_prev = NULL ; if ( with_strq != NULL ) { strq -> ss_params . prio . priority = with_strq -> ss_params . prio . priority ; } else { strq -> ss_params . prio . priority = 0 ; } return ; }
CompilerDispatcher :: ~ CompilerDispatcher ( ) { AbortAll ( BlockingBehavior :: kBlock ) ; task_manager_ -> CancelAndWait ( ) ; }
WebGLContext :: TexImage2D ( GLenum target , GLint level , GLenum internalformat , GLenum format , GLenum type , ImageData * pixels , ErrorResult & rv ) { if ( IsContextLost ( ) ) return ; if ( ! pixels ) { return ErrorInvalidValue ( "texImage2D: null ImageData" ) ; } Uint8ClampedArray arr ( pixels -> GetDataObject ( ) ) ; return TexImage2D_base ( target , level , internalformat , pixels -> Width ( ) , pixels -> Height ( ) , 4 * pixels -> Width ( ) , 0 , format , type , arr . Data ( ) , arr . Length ( ) , - 1 , WebGLTexelFormat :: RGBA8 , false ) ; }
Node * EffectControlLinearizer :: LowerArgumentsLength ( Node * node ) { Node * arguments_frame = NodeProperties :: GetValueInput ( node , 0 ) ; int formal_parameter_count = FormalParameterCountOf ( node -> op ( ) ) ; bool is_rest_length = IsRestLengthOf ( node -> op ( ) ) ; DCHECK_LE ( 0 , formal_parameter_count ) ; if ( is_rest_length ) { auto if_adaptor_frame = __ MakeLabel ( ) ; auto done = __ MakeLabel ( MachineRepresentation :: kTaggedSigned ) ; Node * frame = __ LoadFramePointer ( ) ; __ GotoIf ( __ WordEqual ( arguments_frame , frame ) , & done , __ SmiConstant ( 0 ) ) ; __ Goto ( & if_adaptor_frame ) ; __ Bind ( & if_adaptor_frame ) ; Node * arguments_length = __ Load ( MachineType :: TaggedSigned ( ) , arguments_frame , __ IntPtrConstant ( ArgumentsAdaptorFrameConstants :: kLengthOffset ) ) ; Node * rest_length = __ IntSub ( arguments_length , __ SmiConstant ( formal_parameter_count ) ) ; __ GotoIf ( __ IntLessThan ( rest_length , __ SmiConstant ( 0 ) ) , & done , __ SmiConstant ( 0 ) ) ; __ Goto ( & done , rest_length ) ; __ Bind ( & done ) ; return done . PhiAt ( 0 ) ; } else { auto if_adaptor_frame = __ MakeLabel ( ) ; auto done = __ MakeLabel ( MachineRepresentation :: kTaggedSigned ) ; Node * frame = __ LoadFramePointer ( ) ; __ GotoIf ( __ WordEqual ( arguments_frame , frame ) , & done , __ SmiConstant ( formal_parameter_count ) ) ; __ Goto ( & if_adaptor_frame ) ; __ Bind ( & if_adaptor_frame ) ; Node * arguments_length = __ Load ( MachineType :: TaggedSigned ( ) , arguments_frame , __ IntPtrConstant ( ArgumentsAdaptorFrameConstants :: kLengthOffset ) ) ; __ Goto ( & done , arguments_length ) ; __ Bind ( & done ) ; return done . PhiAt ( 0 ) ; } }
static int run_post_create ( const char * dirname ) { if ( ! dir_is_in_dump_location ( dirname ) ) { error_msg ( "Bad problem directory name '%s', should start with: '%s'" , dirname , g_settings_dump_location ) ; return 400 ; } if ( ! dir_has_correct_permissions ( dirname ) ) { error_msg ( "Problem directory '%s' isn't owned by root:abrt or others are not restricted from access" , dirname ) ; return 400 ; } if ( g_settings_privatereports ) { struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; const bool complete = dd && problem_dump_dir_is_complete ( dd ) ; dd_close ( dd ) ; if ( complete ) { error_msg ( "Problem directory '%s' has already been processed" , dirname ) ; return 403 ; } } else if ( ! dump_dir_accessible_by_uid ( dirname , client_uid ) ) { if ( errno == ENOTDIR ) { error_msg ( "Path '%s' isn't problem directory" , dirname ) ; return 404 ; } error_msg ( "Problem directory '%s' can't be accessed by user with uid %ld" , dirname , ( long ) client_uid ) ; return 403 ; } int child_stdout_fd ; int child_pid = spawn_event_handler_child ( dirname , "post-create" , & child_stdout_fd ) ; char * dup_of_dir = NULL ; struct strbuf * cmd_output = strbuf_new ( ) ; bool child_is_post_create = 1 ; read_child_output : for ( ; ; ) { char buf [ 250 ] ; errno = 0 ; int r = safe_read ( child_stdout_fd , buf , sizeof ( buf ) - 1 ) ; if ( r <= 0 ) break ; buf [ r ] = '\0' ; char * raw = buf ; char * newline ; while ( ( newline = strchr ( raw , '\n' ) ) != NULL ) { * newline = '\0' ; strbuf_append_str ( cmd_output , raw ) ; char * msg = cmd_output -> buf ; log ( "%s" , msg ) ; if ( child_is_post_create && prefixcmp ( msg , "DUP_OF_DIR: " ) == 0 ) { free ( dup_of_dir ) ; dup_of_dir = xstrdup ( msg + strlen ( "DUP_OF_DIR: " ) ) ; } strbuf_clear ( cmd_output ) ; raw = newline + 1 ; } strbuf_append_str ( cmd_output , raw ) ; } int status = 0 ; if ( safe_waitpid ( child_pid , & status , 0 ) <= 0 ) perror_msg ( "waitpid(%d)" , child_pid ) ; if ( ! child_is_post_create ) goto ret ; if ( status != 0 ) { if ( WIFSIGNALED ( status ) ) { log ( "'post-create' on '%s' killed by signal %d" , dirname , WTERMSIG ( status ) ) ; goto delete_bad_dir ; } if ( ! dup_of_dir ) { log ( "'post-create' on '%s' exited with %d" , dirname , WEXITSTATUS ( status ) ) ; goto delete_bad_dir ; } } const char * work_dir = ( dup_of_dir ? dup_of_dir : dirname ) ; struct dump_dir * dd = dd_opendir ( work_dir , 0 ) ; if ( ! dd ) goto delete_bad_dir ; char * count_str = dd_load_text_ext ( dd , FILENAME_COUNT , DD_FAIL_QUIETLY_ENOENT ) ; unsigned long count = strtoul ( count_str , NULL , 10 ) ; if ( ( status != 0 && dup_of_dir ) || count == 0 ) { count ++ ; char new_count_str [ sizeof ( long ) * 3 + 2 ] ; sprintf ( new_count_str , "%lu" , count ) ; dd_save_text ( dd , FILENAME_COUNT , new_count_str ) ; if ( strcmp ( dd -> dd_dirname , dirname ) != 0 ) { struct dump_dir * new_dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; char * last_ocr = NULL ; if ( new_dd ) { last_ocr = dd_load_text_ext ( new_dd , FILENAME_TIME , DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT ) ; dd_close ( new_dd ) ; } else { error_msg ( "Can't read the last occurrence file from the new dump directory." ) ; } if ( ! last_ocr ) { log ( "Using current time for the last occurrence file which may be incorrect." ) ; time_t t = time ( NULL ) ; last_ocr = xasprintf ( "%lu" , ( long ) t ) ; } dd_save_text ( dd , FILENAME_LAST_OCCURRENCE , last_ocr ) ; free ( last_ocr ) ; } } dd_sanitize_mode_and_owner ( dd ) ; dd_close ( dd ) ; if ( ! dup_of_dir ) log_notice ( "New problem directory %s, processing" , work_dir ) ; else { log_warning ( "Deleting problem directory %s (dup of %s)" , strrchr ( dirname , '/' ) + 1 , strrchr ( dup_of_dir , '/' ) + 1 ) ; delete_dump_dir ( dirname ) ; } int fd ; child_pid = spawn_event_handler_child ( work_dir , ( dup_of_dir ? "notify-dup" : "notify" ) , & fd ) ; xmove_fd ( fd , child_stdout_fd ) ; child_is_post_create = 0 ; strbuf_clear ( cmd_output ) ; free ( dup_of_dir ) ; dup_of_dir = NULL ; goto read_child_output ; delete_bad_dir : log_warning ( "Deleting problem directory '%s'" , dirname ) ; delete_dump_dir ( dirname ) ; ret : strbuf_free ( cmd_output ) ; free ( dup_of_dir ) ; close ( child_stdout_fd ) ; return 0 ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 5 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * ids = GetInput ( context , node , 0 ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( ids ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , ids -> type , kTfLiteInt32 ) ; const TfLiteTensor * indices = GetInput ( context , node , 1 ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( indices ) , 2 ) ; TF_LITE_ENSURE_EQ ( context , indices -> type , kTfLiteInt32 ) ; const TfLiteTensor * shape = GetInput ( context , node , 2 ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( shape ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , shape -> type , kTfLiteInt32 ) ; const TfLiteTensor * weights = GetInput ( context , node , 3 ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( weights ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , weights -> type , kTfLiteFloat32 ) ; TF_LITE_ENSURE_EQ ( context , SizeOfDimension ( indices , 0 ) , SizeOfDimension ( ids , 0 ) ) ; TF_LITE_ENSURE_EQ ( context , SizeOfDimension ( indices , 0 ) , SizeOfDimension ( weights , 0 ) ) ; const TfLiteTensor * value = GetInput ( context , node , 4 ) ; TF_LITE_ENSURE ( context , NumDimensions ( value ) >= 2 ) ; TfLiteTensor * output = GetOutput ( context , node , 0 ) ; TF_LITE_ENSURE_TYPES_EQ ( context , output -> type , kTfLiteFloat32 ) ; output -> allocation_type = kTfLiteDynamic ; return kTfLiteOk ; }
int onion_response_flush ( onion_response * res ) { res -> sent_bytes += res -> buffer_pos ; res -> sent_bytes_total += res -> buffer_pos ; if ( res -> buffer_pos == 0 ) return 0 ; if ( ! ( res -> flags & OR_HEADER_SENT ) ) { ONION_DEBUG0 ( "Doing fast header hack: store current buffer, send current headers. Resend buffer." ) ; char tmpb [ sizeof ( res -> buffer ) ] ; int tmpp = res -> buffer_pos ; memcpy ( tmpb , res -> buffer , res -> buffer_pos ) ; res -> buffer_pos = 0 ; onion_response_write_headers ( res ) ; onion_response_write ( res , tmpb , tmpp ) ; return 0 ; } if ( res -> flags & OR_SKIP_CONTENT ) return 0 ; ONION_DEBUG0 ( "Flush %d bytes" , res -> buffer_pos ) ; onion_request * req = res -> request ; ssize_t ( * write ) ( onion_request * , const char * data , size_t len ) ; write = req -> connection . listen_point -> write ; ssize_t w ; off_t pos = 0 ; if ( res -> flags & OR_CHUNKED ) { char tmp [ 16 ] ; snprintf ( tmp , sizeof ( tmp ) , "%X\r\n" , ( unsigned int ) res -> buffer_pos ) ; if ( ( w = write ( req , tmp , strlen ( tmp ) ) ) <= 0 ) { ONION_WARNING ( "Error writing chunk encoding length (%X) %s. Aborting write." , ( unsigned int ) res -> buffer_pos , strerror ( errno ) ) ; return OCS_CLOSE_CONNECTION ; } ONION_DEBUG0 ( "Write %d-%d bytes" , res -> buffer_pos , w ) ; } int savederrno = errno ; errno = 0 ; while ( ( w = write ( req , & res -> buffer [ pos ] , res -> buffer_pos ) ) != res -> buffer_pos ) { if ( w <= 0 || res -> buffer_pos < 0 ) { ONION_ERROR ( "Error writing %d bytes (%s). Maybe closed connection. Code %d. " , res -> buffer_pos , strerror ( errno ) , w ) ; res -> buffer_pos = 0 ; errno = savederrno ; return OCS_CLOSE_CONNECTION ; } pos += w ; ONION_DEBUG0 ( "Write %d-%d bytes" , res -> buffer_pos , w ) ; res -> buffer_pos -= w ; } if ( res -> flags & OR_CHUNKED ) { write ( req , "\r\n" , 2 ) ; } res -> buffer_pos = 0 ; errno = savederrno ; return 0 ; }
void ih264e_cabac_flush ( cabac_ctxt_t * ps_cabac_ctxt ) { bitstrm_t * ps_stream = ps_cabac_ctxt -> ps_bitstrm ; encoding_envirnoment_t * ps_cab_enc_env = & ( ps_cabac_ctxt -> s_cab_enc_env ) ; UWORD32 u4_low = ps_cab_enc_env -> u4_code_int_low ; UWORD32 u4_bits_gen = ps_cab_enc_env -> u4_bits_gen ; UWORD8 * pu1_strm_buf = ps_stream -> pu1_strm_buffer ; UWORD32 u4_strm_buf_offset = ps_stream -> u4_strm_buf_offset ; WORD32 zero_run = ps_stream -> i4_zero_bytes_run ; UWORD32 u4_out_standing_bytes = ps_cab_enc_env -> u4_out_standing_bytes ; { WORD32 carry = ( u4_low > > ( u4_bits_gen + CABAC_BITS ) ) & 0x1 ; WORD32 last_byte ; WORD32 bits_left ; WORD32 rem_bits ; if ( carry ) { if ( pu1_strm_buf [ u4_strm_buf_offset - 1 ] == 0x03 && pu1_strm_buf [ u4_strm_buf_offset - 2 ] == 0x03 && pu1_strm_buf [ u4_strm_buf_offset - 3 ] == 0x00 && pu1_strm_buf [ u4_strm_buf_offset - 4 ] == 0x00 ) { u4_strm_buf_offset -= 1 ; } pu1_strm_buf [ u4_strm_buf_offset - 1 ] += carry ; zero_run = 0 ; } while ( u4_out_standing_bytes ) { UWORD8 u1_0_or_ff = carry ? 0 : 0xFF ; PUTBYTE_EPB ( pu1_strm_buf , u4_strm_buf_offset , u1_0_or_ff , zero_run ) ; u4_out_standing_bytes -- ; } u4_low &= ( ( 1 < < ( u4_bits_gen + CABAC_BITS ) ) - 1 ) ; bits_left = u4_bits_gen + 1 ; rem_bits = ( u4_low > > ( u4_bits_gen + CABAC_BITS - bits_left ) ) ; if ( bits_left >= 8 ) { last_byte = ( rem_bits > > ( bits_left - 8 ) ) & 0xFF ; PUTBYTE_EPB ( pu1_strm_buf , u4_strm_buf_offset , last_byte , zero_run ) ; bits_left -= 8 ; } last_byte = ( rem_bits < < ( 8 - bits_left ) ) | ( 1 < < ( 7 - bits_left ) | ( 1 < < ( 7 - bits_left - 1 ) ) ) ; last_byte &= 0xFF ; PUTBYTE_EPB ( pu1_strm_buf , u4_strm_buf_offset , last_byte , zero_run ) ; ps_stream -> u4_strm_buf_offset = u4_strm_buf_offset ; ps_stream -> i4_zero_bytes_run = 0 ; ps_stream -> u4_cur_word = 0 ; ps_stream -> i4_bits_left_in_cw = WORD_SIZE ; } }
FunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq * decorator_list , expr_ty returns , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! name ) { PyErr_SetString ( PyExc_ValueError , "field name is required for FunctionDef" ) ; return NULL ; } if ( ! args ) { PyErr_SetString ( PyExc_ValueError , "field args is required for FunctionDef" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = FunctionDef_kind ; p -> v . FunctionDef . name = name ; p -> v . FunctionDef . args = args ; p -> v . FunctionDef . body = body ; p -> v . FunctionDef . decorator_list = decorator_list ; p -> v . FunctionDef . returns = returns ; p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { u16 offset = sizeof ( struct ipv6hdr ) ; unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; while ( offset <= packet_len ) { struct ipv6_opt_hdr * exthdr ; switch ( * * nexthdr ) { case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : #if IS_ENABLED(CONFIG_IPV6_MIP6) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; #endif if ( found_rhdr ) return offset ; break ; default : return offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; offset += ipv6_optlen ( exthdr ) ; * nexthdr = & exthdr -> nexthdr ; } return - EINVAL ; }
Handle < FeedbackVector > Factory :: NewFeedbackVector ( Handle < SharedFunctionInfo > shared , PretenureFlag pretenure ) { int length = shared -> feedback_metadata ( ) -> slot_count ( ) ; DCHECK_LE ( 0 , length ) ; int size = FeedbackVector :: SizeFor ( length ) ; HeapObject * result = AllocateRawWithImmortalMap ( size , pretenure , * feedback_vector_map ( ) ) ; Handle < FeedbackVector > vector ( FeedbackVector :: cast ( result ) , isolate ( ) ) ; vector -> set_shared_function_info ( * shared ) ; vector -> set_optimized_code_weak_or_smi ( MaybeObject :: FromSmi ( Smi :: FromEnum ( FLAG_log_function_events ? OptimizationMarker :: kLogFirstExecution : OptimizationMarker :: kNone ) ) ) ; vector -> set_length ( length ) ; vector -> set_invocation_count ( 0 ) ; vector -> set_profiler_ticks ( 0 ) ; vector -> set_deopt_count ( 0 ) ; MemsetPointer ( vector -> slots_start ( ) , MaybeObject :: FromObject ( * undefined_value ( ) ) , length ) ; return vector ; }
static void on_l2cap_data_ind ( tBTA_JV * evt , uint32_t id ) { l2cap_socket * sock ; int app_uid = - 1 ; uint32_t bytes_read = 0 ; std :: unique_lock < std :: mutex > lock ( state_lock ) ; sock = btsock_l2cap_find_by_id_l ( id ) ; if ( ! sock ) return ; app_uid = sock -> app_uid ; if ( sock -> fixed_chan ) { tBTA_JV_LE_DATA_IND * p_le_data_ind = & evt -> le_data_ind ; BT_HDR * p_buf = p_le_data_ind -> p_buf ; uint8_t * data = ( uint8_t * ) ( p_buf + 1 ) + p_buf -> offset ; if ( packet_put_tail_l ( sock , data , p_buf -> len ) ) { bytes_read = p_buf -> len ; btsock_thread_add_fd ( pth , sock -> our_fd , BTSOCK_L2CAP , SOCK_THREAD_FD_WR , sock -> id ) ; } else { DVLOG ( 2 ) < < __func__ < < ": unable to push data to socket - closing  fixed channel" ; BTA_JvL2capCloseLE ( sock -> handle ) ; btsock_l2cap_free_l ( sock ) ; } } else { uint32_t count ; if ( BTA_JvL2capReady ( sock -> handle , & count ) == BTA_JV_SUCCESS ) { std :: vector < uint8_t > buffer ( count ) ; if ( BTA_JvL2capRead ( sock -> handle , sock -> id , buffer . data ( ) , count ) == BTA_JV_SUCCESS ) { if ( packet_put_tail_l ( sock , buffer . data ( ) , count ) ) { bytes_read = count ; btsock_thread_add_fd ( pth , sock -> our_fd , BTSOCK_L2CAP , SOCK_THREAD_FD_WR , sock -> id ) ; } else { DVLOG ( 2 ) < < __func__ < < ": unable to push data to socket - closing channel" ; BTA_JvL2capClose ( sock -> handle ) ; btsock_l2cap_free_l ( sock ) ; } } } } sock -> rx_bytes += bytes_read ; uid_set_add_rx ( uid_set , app_uid , bytes_read ) ; }
FT_CeilFix ( FT_Fixed a ) { return a >= 0 ? ( a + 0xFFFFL ) & ~ 0xFFFFL : - ( ( - a + 0xFFFFL ) & ~ 0xFFFFL ) ; }
nsresult nsHTMLEditor :: ParseFragment ( const nsAString & aFragStr , nsIAtom * aContextLocalName , nsIDocument * aTargetDocument , nsCOMPtr < nsIDOMNode > * outNode , bool aTrustedInput ) { nsCOMPtr < nsIDOMDocumentFragment > frag ; NS_NewDocumentFragment ( getter_AddRefs ( frag ) , aTargetDocument -> NodeInfoManager ( ) ) ; nsCOMPtr < nsIContent > fragment = do_QueryInterface ( frag ) ; nsresult rv = nsContentUtils :: ParseFragmentHTML ( aFragStr , fragment , aContextLocalName ? aContextLocalName : nsGkAtoms :: body , kNameSpaceID_XHTML , false , true ) ; if ( ! aTrustedInput ) { nsTreeSanitizer sanitizer ( aContextLocalName ? nsIParserUtils :: SanitizerAllowStyle : nsIParserUtils :: SanitizerAllowComments ) ; sanitizer . Sanitize ( fragment ) ; } * outNode = do_QueryInterface ( frag ) ; return rv ; }
sctp_handle_auth ( struct sctp_tcb * stcb , struct sctp_auth_chunk * auth , struct mbuf * m , uint32_t offset ) { uint16_t chunklen ; uint16_t shared_key_id ; uint16_t hmac_id ; sctp_sharedkey_t * skey ; uint32_t digestlen ; uint8_t digest [ SCTP_AUTH_DIGEST_LEN_MAX ] ; uint8_t computed_digest [ SCTP_AUTH_DIGEST_LEN_MAX ] ; chunklen = ntohs ( auth -> ch . chunk_length ) ; if ( chunklen < sizeof ( * auth ) ) { SCTP_STAT_INCR ( sctps_recvauthfailed ) ; return ( - 1 ) ; } SCTP_STAT_INCR ( sctps_recvauth ) ; shared_key_id = ntohs ( auth -> shared_key_id ) ; hmac_id = ntohs ( auth -> hmac_id ) ; SCTPDBG ( SCTP_DEBUG_AUTH1 , "SCTP AUTH Chunk: shared key %u, HMAC id %u\n" , shared_key_id , hmac_id ) ; #if defined(__Userspace__) #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION return ( 0 ) ; #endif #endif if ( ! sctp_auth_is_supported_hmac ( stcb -> asoc . local_hmacs , hmac_id ) ) { struct mbuf * op_err ; struct sctp_error_auth_invalid_hmac * cause ; SCTP_STAT_INCR ( sctps_recvivalhmacid ) ; SCTPDBG ( SCTP_DEBUG_AUTH1 , "SCTP Auth: unsupported HMAC id %u\n" , hmac_id ) ; op_err = sctp_get_mbuf_for_msg ( sizeof ( struct sctp_error_auth_invalid_hmac ) , 0 , M_NOWAIT , 1 , MT_HEADER ) ; if ( op_err != NULL ) { SCTP_BUF_RESV_UF ( op_err , sizeof ( struct sctp_chunkhdr ) ) ; cause = mtod ( op_err , struct sctp_error_auth_invalid_hmac * ) ; cause -> cause . code = htons ( SCTP_CAUSE_UNSUPPORTED_HMACID ) ; cause -> cause . length = htons ( sizeof ( struct sctp_error_auth_invalid_hmac ) ) ; cause -> hmac_id = ntohs ( hmac_id ) ; SCTP_BUF_LEN ( op_err ) = sizeof ( struct sctp_error_auth_invalid_hmac ) ; sctp_queue_op_err ( stcb , op_err ) ; } return ( - 1 ) ; } if ( ( stcb -> asoc . authinfo . recv_key == NULL ) || ( stcb -> asoc . authinfo . recv_keyid != shared_key_id ) ) { skey = sctp_find_sharedkey ( & stcb -> asoc . shared_keys , shared_key_id ) ; if ( skey == NULL ) { SCTP_STAT_INCR ( sctps_recvivalkeyid ) ; SCTPDBG ( SCTP_DEBUG_AUTH1 , "SCTP Auth: unknown key id %u\n" , shared_key_id ) ; return ( - 1 ) ; } if ( stcb -> asoc . authinfo . recv_keyid != shared_key_id ) sctp_notify_authentication ( stcb , SCTP_AUTH_NEW_KEY , shared_key_id , stcb -> asoc . authinfo . recv_keyid , SCTP_SO_NOT_LOCKED ) ; if ( stcb -> asoc . authinfo . recv_key != NULL ) sctp_free_key ( stcb -> asoc . authinfo . recv_key ) ; stcb -> asoc . authinfo . recv_key = sctp_compute_hashkey ( stcb -> asoc . authinfo . random , stcb -> asoc . authinfo . peer_random , skey -> key ) ; stcb -> asoc . authinfo . recv_keyid = shared_key_id ; #ifdef SCTP_DEBUG if ( SCTP_AUTH_DEBUG ) sctp_print_key ( stcb -> asoc . authinfo . recv_key , "Recv Key" ) ; #endif } digestlen = sctp_get_hmac_digest_len ( hmac_id ) ; if ( chunklen < ( sizeof ( * auth ) + digestlen ) ) { SCTP_STAT_INCR ( sctps_recvauthfailed ) ; SCTPDBG ( SCTP_DEBUG_AUTH1 , "SCTP Auth: chunk too short for HMAC\n" ) ; return ( - 1 ) ; } memcpy ( digest , auth -> hmac , digestlen ) ; sctp_zero_m ( m , offset + sizeof ( * auth ) , SCTP_SIZE32 ( digestlen ) ) ; ( void ) sctp_compute_hmac_m ( hmac_id , stcb -> asoc . authinfo . recv_key , m , offset , computed_digest ) ; if ( timingsafe_bcmp ( digest , computed_digest , digestlen ) != 0 ) { SCTP_STAT_INCR ( sctps_recvauthfailed ) ; SCTPDBG ( SCTP_DEBUG_AUTH1 , "SCTP Auth: HMAC digest check failed\n" ) ; return ( - 1 ) ; } return ( 0 ) ; }
reg_copy . invoke = [ ] ( TfLiteContext * context , TfLiteNode * node ) { - const TfLiteTensor * input = GetInput ( context , node , 0 ) ; - TfLiteTensor * output = GetOutput ( context , node , 0 ) ; + const TfLiteTensor * input ; + TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , 0 , & input ) ) ; + TfLiteTensor * output ; + TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , 0 , & output ) ) ; DynamicBuffer buf ; StringRef str_ref = GetString ( input , 0 ) ; buf . AddString ( str_ref ) ; buf . WriteToTensorAsVector ( output ) ; return kTfLiteOk ; } ;
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
WebSocket :: CreateAndDispatchMessageEvent ( const nsACString & aData , bool isBinary ) { NS_ABORT_IF_FALSE ( NS_IsMainThread ( ) , "Not running on main thread" ) ; nsresult rv = CheckInnerWindowCorrectness ( ) ; if ( NS_FAILED ( rv ) ) return NS_OK ; nsCOMPtr < nsIScriptGlobalObject > sgo = do_QueryInterface ( GetOwner ( ) ) ; NS_ENSURE_TRUE ( sgo , NS_ERROR_FAILURE ) ; nsIScriptContext * scriptContext = sgo -> GetContext ( ) ; NS_ENSURE_TRUE ( scriptContext , NS_ERROR_FAILURE ) ; JSContext * cx = scriptContext -> GetNativeContext ( ) ; NS_ENSURE_TRUE ( cx , NS_ERROR_FAILURE ) ; jsval jsData ; { JSAutoRequest ar ( cx ) ; if ( isBinary ) { if ( mBinaryType == BinaryTypeValues :: Blob ) { rv = nsContentUtils :: CreateBlobBuffer ( cx , aData , jsData ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } else if ( mBinaryType == BinaryTypeValues :: Arraybuffer ) { JSObject * arrayBuf ; rv = nsContentUtils :: CreateArrayBuffer ( cx , aData , & arrayBuf ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; jsData = OBJECT_TO_JSVAL ( arrayBuf ) ; } else { NS_RUNTIMEABORT ( "Unknown binary type!" ) ; return NS_ERROR_UNEXPECTED ; } } else { NS_ConvertUTF8toUTF16 utf16Data ( aData ) ; JSString * jsString ; jsString = JS_NewUCStringCopyN ( cx , utf16Data . get ( ) , utf16Data . Length ( ) ) ; NS_ENSURE_TRUE ( jsString , NS_ERROR_FAILURE ) ; jsData = STRING_TO_JSVAL ( jsString ) ; } } nsCOMPtr < nsIDOMEvent > event ; rv = NS_NewDOMMessageEvent ( getter_AddRefs ( event ) , nullptr , nullptr ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIDOMMessageEvent > messageEvent = do_QueryInterface ( event ) ; rv = messageEvent -> InitMessageEvent ( NS_LITERAL_STRING ( "message" ) , false , false , jsData , mUTF16Origin , EmptyString ( ) , nullptr ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; event -> SetTrusted ( true ) ; return DispatchDOMEvent ( nullptr , event , nullptr , nullptr ) ; }
Node * WasmGraphBuilder :: BuildDecodeException32BitValue ( Node * const * values , uint32_t * index ) { MachineOperatorBuilder * machine = mcgraph ( ) -> machine ( ) ; Node * upper = BuildChangeSmiToInt32 ( values [ * index ] ) ; ( * index ) ++ ; upper = graph ( ) -> NewNode ( machine -> Word32Shl ( ) , upper , Int32Constant ( 16 ) ) ; Node * lower = BuildChangeSmiToInt32 ( values [ * index ] ) ; ( * index ) ++ ; Node * value = graph ( ) -> NewNode ( machine -> Word32Or ( ) , upper , lower ) ; return value ; }
FunctionLiteral * Parser :: ParseProgram ( Isolate * isolate , ParseInfo * info ) { DCHECK ( parsing_on_main_thread_ ) ; RuntimeCallTimerScope runtime_timer ( runtime_call_stats_ , info -> is_eval ( ) ? RuntimeCallCounterId :: kParseEval : RuntimeCallCounterId :: kParseProgram ) ; TRACE_EVENT0 ( TRACE_DISABLED_BY_DEFAULT ( "v8.compile" ) , "V8.ParseProgram" ) ; base :: ElapsedTimer timer ; if ( V8_UNLIKELY ( FLAG_log_function_events ) ) timer . Start ( ) ; fni_ = new ( zone ( ) ) FuncNameInferrer ( ast_value_factory ( ) , zone ( ) ) ; DeserializeScopeChain ( isolate , info , info -> maybe_outer_scope_info ( ) ) ; scanner_ . Initialize ( ) ; FunctionLiteral * result = DoParseProgram ( isolate , info ) ; MaybeResetCharacterStream ( info , result ) ; HandleSourceURLComments ( isolate , info -> script ( ) ) ; if ( V8_UNLIKELY ( FLAG_log_function_events ) && result != nullptr ) { double ms = timer . Elapsed ( ) . InMillisecondsF ( ) ; const char * event_name = "parse-eval" ; Script * script = * info -> script ( ) ; int start = - 1 ; int end = - 1 ; if ( ! info -> is_eval ( ) ) { event_name = "parse-script" ; start = 0 ; end = String :: cast ( script -> source ( ) ) -> length ( ) ; } LOG ( isolate , FunctionEvent ( event_name , script -> id ( ) , ms , start , end , "" , 0 ) ) ; } return result ; }
int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , "Invalid request to unpack with offset of %d and limit of %d." , offset , len ) ; else if ( offset > len ) return luaL_error ( L , "Start offset %d greater than input length %d." , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , "Missing bytes in input." ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , "Bad data format in input." ) ; } } if ( ! decode_all ) { int offset = len - c . left ; lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }
include_batch_in_index ] ( int64 start , int64 limit ) { const int32 depth = params . depth ; const int32 in_rows = params . tensor_in_rows ; const int32 in_cols = params . tensor_in_cols ; const int32 pad_top = params . pad_top ; const int32 pad_left = params . pad_left ; const int32 window_rows = params . window_rows ; const int32 window_cols = params . window_cols ; const int32 row_stride = params . row_stride ; const int32 col_stride = params . col_stride ; const int32 out_height = params . out_height ; const int32 out_width = params . out_width ; { const int32 output_image_size = out_height * out_width * depth ; EigenMatrixMap out_shard ( out_mat . data ( ) + start * output_image_size , 1 , ( limit - start ) * output_image_size ) ; out_shard . setConstant ( Eigen :: NumTraits < T > :: lowest ( ) ) ; EigenIndexMatrixMap out_arg_max_shard ( out_arg_max_mat . data ( ) + start * output_image_size , 1 , ( limit - start ) * output_image_size ) ; out_arg_max_shard . setConstant ( kInvalidMaxPoolingIndex ) ; } for ( int64 b = start ; b < limit ; ++ b ) { for ( int h = 0 ; h < in_rows ; ++ h ) { for ( int w = 0 ; w < in_cols ; ++ w ) { const int hpad = h + pad_top ; const int wpad = w + pad_left ; const int h_start = ( hpad < window_rows ) ? 0 : ( hpad - window_rows ) / row_stride + 1 ; const int h_end = std :: min ( hpad / row_stride + 1 , out_height ) ; const int w_start = ( wpad < window_cols ) ? 0 : ( wpad - window_cols ) / col_stride + 1 ; const int w_end = std :: min ( wpad / col_stride + 1 , out_width ) ; const int64 in_index = ( b * in_rows + h ) * in_cols + w ; for ( int ph = h_start ; ph < h_end ; ++ ph ) { const int64 out_index_base = ( b * out_height + ph ) * out_width ; for ( int pw = w_start ; pw < w_end ; ++ pw ) { const int64 out_index = out_index_base + pw ; for ( int d = 0 ; d < depth ; ++ d ) { const T & input_ref = in_mat . coeffRef ( d , in_index ) ; T & output_ref = out_mat . coeffRef ( d , out_index ) ; Targmax & out_arg_max_ref = out_arg_max_mat . coeffRef ( d , out_index ) ; if ( output_ref < input_ref || out_arg_max_ref == kInvalidMaxPoolingIndex ) { output_ref = input_ref ; if ( include_batch_in_index ) { out_arg_max_ref = in_index * depth + d ; } else { out_arg_max_ref = ( h * in_cols + w ) * depth + d ; } } } } } } } } if ( input_backprop != nullptr ) { auto input_backprop_flat = input_backprop -> flat < T > ( ) ; auto out_arg_max_flat = output_arg_max -> flat < int64 > ( ) ; auto out_backprop_flat = out_backprop . flat < T > ( ) ; const int64 in_size = in_rows * in_cols * depth ; const int64 in_start = start * in_size ; const int64 in_end = limit * in_size ; EigenMatrixMap in_shard ( input_backprop_flat . data ( ) + in_start , 1 , in_end - in_start ) ; in_shard . setConstant ( T ( 0 ) ) ; const int out_size = out_height * out_width * depth ; const int out_start = start * out_size ; const int out_end = limit * out_size ; for ( int index = out_start ; index < out_end ; ++ index ) { int input_backprop_index = out_arg_max_flat ( index ) ; FastBoundsCheck ( input_backprop_index - in_start , in_end - in_start ) ; - input_backprop_flat ( input_backprop_index ) += out_backprop_flat ( index ) ; + if ( index < out_backprop . NumElements ( ) ) { + input_backprop_flat ( input_backprop_index ) += out_backprop_flat ( index ) ; + } } } } ;
ipv6_dup_options ( struct sock * sk , struct ipv6_txoptions * opt ) { struct ipv6_txoptions * opt2 ; opt2 = sock_kmalloc ( sk , opt -> tot_len , GFP_ATOMIC ) ; if ( opt2 ) { long dif = ( char * ) opt2 - ( char * ) opt ; memcpy ( opt2 , opt , opt -> tot_len ) ; if ( opt2 -> hopopt ) * ( ( char * * ) & opt2 -> hopopt ) += dif ; if ( opt2 -> dst0opt ) * ( ( char * * ) & opt2 -> dst0opt ) += dif ; if ( opt2 -> dst1opt ) * ( ( char * * ) & opt2 -> dst1opt ) += dif ; if ( opt2 -> srcrt ) * ( ( char * * ) & opt2 -> srcrt ) += dif ; } return opt2 ; }
Return < ServiceManager :: Transport > ServiceManager :: getTransport ( const hidl_string & fqName , const hidl_string & name ) { using :: android :: hardware :: getTransport ; pid_t pid = IPCThreadState :: self ( ) -> getCallingPid ( ) ; if ( ! mAcl . canGet ( fqName , pid ) ) { return Transport :: EMPTY ; } switch ( getTransport ( fqName , name ) ) { case vintf :: Transport :: HWBINDER : return Transport :: HWBINDER ; case vintf :: Transport :: PASSTHROUGH : return Transport :: PASSTHROUGH ; case vintf :: Transport :: EMPTY : default : return Transport :: EMPTY ; } }
cdf_count_chain ( const cdf_sat_t * sat , cdf_secid_t sid , size_t size ) { size_t i , j ; cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ; DPRINTF ( ( "Chain:" ) ) ; for ( j = i = 0 ; sid >= 0 ; i ++ , j ++ ) { DPRINTF ( ( " %d" , sid ) ) ; if ( j >= CDF_LOOP_LIMIT ) { DPRINTF ( ( "Counting chain loop limit" ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } if ( sid > maxsector ) { DPRINTF ( ( "Sector %d > %d\n" , sid , maxsector ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } sid = CDF_TOLE4 ( ( uint32_t ) sat -> sat_tab [ sid ] ) ; } if ( i == 0 ) { DPRINTF ( ( " none, sid: %d\n" , sid ) ) ; return ( size_t ) - 1 ; } DPRINTF ( ( "\n" ) ) ; return i ; }
status_t SampleTable :: setSyncSampleParams ( off64_t data_offset , size_t data_size ) { if ( mSyncSampleOffset >= 0 || data_size < 8 ) { return ERROR_MALFORMED ; } mSyncSampleOffset = data_offset ; uint8_t header [ 8 ] ; if ( mDataSource -> readAt ( data_offset , header , sizeof ( header ) ) < ( ssize_t ) sizeof ( header ) ) { return ERROR_IO ; } if ( U32_AT ( header ) != 0 ) { return ERROR_MALFORMED ; } mNumSyncSamples = U32_AT ( & header [ 4 ] ) ; if ( mNumSyncSamples < 2 ) { ALOGV ( "Table of sync samples is empty or has only a single entry!" ) ; } uint64_t allocSize = mNumSyncSamples * sizeof ( uint32_t ) ; if ( allocSize > SIZE_MAX ) { return ERROR_OUT_OF_RANGE ; } mSyncSamples = new uint32_t [ mNumSyncSamples ] ; size_t size = mNumSyncSamples * sizeof ( uint32_t ) ; if ( mDataSource -> readAt ( mSyncSampleOffset + 8 , mSyncSamples , size ) != ( ssize_t ) size ) { return ERROR_IO ; } for ( size_t i = 0 ; i < mNumSyncSamples ; ++ i ) { mSyncSamples [ i ] = ntohl ( mSyncSamples [ i ] ) - 1 ; } return OK ; }
status_t OMXNodeInstance :: enableNativeBuffers ( OMX_U32 portIndex , OMX_BOOL graphic , OMX_BOOL enable ) { Mutex :: Autolock autoLock ( mLock ) ; CLOG_CONFIG ( enableNativeBuffers , "%s:%u%s, %d" , portString ( portIndex ) , portIndex , graphic ? ", graphic" : "" , enable ) ; OMX_STRING name = const_cast < OMX_STRING > ( graphic ? "OMX.google.android.index.enableAndroidNativeBuffers" : "OMX.google.android.index.allocateNativeHandle" ) ; OMX_INDEXTYPE index ; OMX_ERRORTYPE err = OMX_GetExtensionIndex ( mHandle , name , & index ) ; if ( err == OMX_ErrorNone ) { EnableAndroidNativeBuffersParams params ; InitOMXParams ( & params ) ; params . nPortIndex = portIndex ; params . enable = enable ; err = OMX_SetParameter ( mHandle , index , & params ) ; CLOG_IF_ERROR ( setParameter , err , "%s(%#x): %s:%u en=%d" , name , index , portString ( portIndex ) , portIndex , enable ) ; if ( ! graphic ) { if ( err == OMX_ErrorNone ) { mSecureBufferType [ portIndex ] = enable ? kSecureBufferTypeNativeHandle : kSecureBufferTypeOpaque ; } else if ( mSecureBufferType [ portIndex ] == kSecureBufferTypeUnknown ) { mSecureBufferType [ portIndex ] = kSecureBufferTypeOpaque ; } } } else { CLOG_ERROR_IF ( enable , getExtensionIndex , err , "%s" , name ) ; if ( ! graphic ) { char value [ PROPERTY_VALUE_MAX ] ; if ( property_get ( "media.mediadrmservice.enable" , value , NULL ) && ( ! strcmp ( "1" , value ) || ! strcasecmp ( "true" , value ) ) ) { CLOG_CONFIG ( enableNativeBuffers , "system property override: using native-handles" ) ; mSecureBufferType [ portIndex ] = kSecureBufferTypeNativeHandle ; } else if ( mSecureBufferType [ portIndex ] == kSecureBufferTypeUnknown ) { mSecureBufferType [ portIndex ] = kSecureBufferTypeOpaque ; } err = OMX_ErrorNone ; } } return StatusFromOMXError ( err ) ; }
void Run ( bool on_foreground ) { if ( on_foreground ) { HandleScope scope ( job_ -> isolate_ ) ; SaveContext saved_context ( job_ -> isolate_ ) ; job_ -> isolate_ -> set_context ( * job_ -> native_context_ ) ; RunInForeground ( ) ; } else { RunInBackground ( ) ; } }
tt_cmap12_char_next ( TT_CMap cmap , FT_UInt32 * pchar_code ) { TT_CMap12 cmap12 = ( TT_CMap12 ) cmap ; FT_ULong gindex ; if ( cmap12 -> cur_charcode >= 0xFFFFFFFFUL ) return 0 ; if ( cmap12 -> valid && cmap12 -> cur_charcode == * pchar_code ) { tt_cmap12_next ( cmap12 ) ; if ( cmap12 -> valid ) { gindex = cmap12 -> cur_gindex ; if ( gindex ) * pchar_code = ( FT_UInt32 ) cmap12 -> cur_charcode ; } else gindex = 0 ; } else gindex = tt_cmap12_char_map_binary ( cmap , pchar_code , 1 ) ; return ( FT_UInt32 ) gindex ; }
base :: Optional < ParseResult > MakeFieldAccessExpression ( ParseResultIterator * child_results ) { auto object = child_results -> NextAs < Expression * > ( ) ; auto field = child_results -> NextAs < std :: string > ( ) ; LocationExpression * result = MakeNode < FieldAccessExpression > ( object , std :: move ( field ) ) ; return ParseResult { result } ; }
SYSCALL_DEFINE2 ( timerfd_create , int , clockid , int , flags ) { int ufd ; struct timerfd_ctx * ctx ; BUILD_BUG_ON ( TFD_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( TFD_NONBLOCK != O_NONBLOCK ) ; if ( ( flags & ~ TFD_CREATE_FLAGS ) || ( clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME && clockid != CLOCK_REALTIME_ALARM && clockid != CLOCK_BOOTTIME && clockid != CLOCK_BOOTTIME_ALARM ) ) return - EINVAL ; if ( ! capable ( CAP_WAKE_ALARM ) && ( clockid == CLOCK_REALTIME_ALARM || clockid == CLOCK_BOOTTIME_ALARM ) ) return - EPERM ; ctx = kzalloc ( sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ; ctx -> clockid = clockid ; if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ; else hrtimer_init ( & ctx -> t . tmr , clockid , HRTIMER_MODE_ABS ) ; ctx -> moffs = ktime_mono_to_real ( 0 ) ; ufd = anon_inode_getfd ( "[timerfd]" , & timerfd_fops , ctx , O_RDWR | ( flags & TFD_SHARED_FCNTL_FLAGS ) ) ; if ( ufd < 0 ) kfree ( ctx ) ; return ufd ; }
do_core_note ( struct magic_set * ms , unsigned char * nbuf , uint32_t type , int swap , uint32_t namesz , uint32_t descsz , size_t noff , size_t doff , int * flags , size_t size , int clazz ) { #ifdef ELFCORE int os_style = - 1 ; if ( ( namesz == 4 && strncmp ( ( char * ) & nbuf [ noff ] , "CORE" , 4 ) == 0 ) || ( namesz == 5 && strcmp ( ( char * ) & nbuf [ noff ] , "CORE" ) == 0 ) ) { os_style = OS_STYLE_SVR4 ; } if ( ( namesz == 8 && strcmp ( ( char * ) & nbuf [ noff ] , "FreeBSD" ) == 0 ) ) { os_style = OS_STYLE_FREEBSD ; } if ( ( namesz >= 11 && strncmp ( ( char * ) & nbuf [ noff ] , "NetBSD-CORE" , 11 ) == 0 ) ) { os_style = OS_STYLE_NETBSD ; } if ( os_style != - 1 && ( * flags & FLAGS_DID_CORE_STYLE ) == 0 ) { if ( file_printf ( ms , ", %s-style" , os_style_names [ os_style ] ) == - 1 ) return 1 ; * flags |= FLAGS_DID_CORE_STYLE ; * flags |= os_style ; } switch ( os_style ) { case OS_STYLE_NETBSD : if ( type == NT_NETBSD_CORE_PROCINFO ) { char sbuf [ 512 ] ; struct NetBSD_elfcore_procinfo pi ; memset ( & pi , 0 , sizeof ( pi ) ) ; memcpy ( & pi , nbuf + doff , descsz ) ; if ( file_printf ( ms , ", from '%.31s', pid=%u, uid=%u, " "gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)" , file_printable ( sbuf , sizeof ( sbuf ) , RCAST ( char * , pi . cpi_name ) ) , elf_getu32 ( swap , ( uint32_t ) pi . cpi_pid ) , elf_getu32 ( swap , pi . cpi_euid ) , elf_getu32 ( swap , pi . cpi_egid ) , elf_getu32 ( swap , pi . cpi_nlwps ) , elf_getu32 ( swap , ( uint32_t ) pi . cpi_siglwp ) , elf_getu32 ( swap , pi . cpi_signo ) , elf_getu32 ( swap , pi . cpi_sigcode ) ) == - 1 ) return 1 ; * flags |= FLAGS_DID_CORE ; return 1 ; } break ; case OS_STYLE_FREEBSD : if ( type == NT_PRPSINFO && * flags & FLAGS_IS_CORE ) { size_t argoff , pidoff ; if ( clazz == ELFCLASS32 ) argoff = 4 + 4 + 17 ; else argoff = 4 + 4 + 8 + 17 ; if ( file_printf ( ms , ", from '%.80s'" , nbuf + doff + argoff ) == - 1 ) return 1 ; pidoff = argoff + 81 + 2 ; if ( doff + pidoff + 4 <= size ) { if ( file_printf ( ms , ", pid=%u" , elf_getu32 ( swap , * RCAST ( uint32_t * , ( nbuf + doff + pidoff ) ) ) ) == - 1 ) return 1 ; } * flags |= FLAGS_DID_CORE ; } break ; default : if ( type == NT_PRPSINFO && * flags & FLAGS_IS_CORE ) { size_t i , j ; unsigned char c ; for ( i = 0 ; i < NOFFSETS ; i ++ ) { unsigned char * cname , * cp ; size_t reloffset = prpsoffsets ( i ) ; size_t noffset = doff + reloffset ; size_t k ; for ( j = 0 ; j < 16 ; j ++ , noffset ++ , reloffset ++ ) { if ( noffset >= size ) goto tryanother ; if ( reloffset >= descsz ) goto tryanother ; c = nbuf [ noffset ] ; if ( c == '\0' ) { if ( j == 0 ) goto tryanother ; else break ; } else { if ( ! isprint ( c ) || isquote ( c ) ) goto tryanother ; } } for ( k = i + 1 ; k < NOFFSETS ; k ++ ) { size_t no ; int adjust = 1 ; if ( prpsoffsets ( k ) >= prpsoffsets ( i ) ) continue ; for ( no = doff + prpsoffsets ( k ) ; no < doff + prpsoffsets ( i ) ; no ++ ) adjust = adjust && isprint ( nbuf [ no ] ) ; if ( adjust ) i = k ; } cname = ( unsigned char * ) & nbuf [ doff + prpsoffsets ( i ) ] ; for ( cp = cname ; cp < nbuf + size && * cp && isprint ( * cp ) ; cp ++ ) continue ; while ( cp > cname && isspace ( cp [ - 1 ] ) ) cp -- ; if ( file_printf ( ms , ", from '%.*s'" , ( int ) ( cp - cname ) , cname ) == - 1 ) return 1 ; * flags |= FLAGS_DID_CORE ; return 1 ; tryanother : ; } } break ; } #endif return 0 ; }
open_face_from_buffer ( FT_Library library , FT_Byte * base , FT_ULong size , FT_Long face_index , const char * driver_name , FT_Face * aface ) { FT_Open_Args args ; FT_Error error ; FT_Stream stream = NULL ; FT_Memory memory = library -> memory ; error = new_memory_stream ( library , base , size , memory_stream_close , & stream ) ; if ( error ) { FT_FREE ( base ) ; return error ; } args . flags = FT_OPEN_STREAM ; args . stream = stream ; if ( driver_name ) { args . flags = args . flags | FT_OPEN_DRIVER ; args . driver = FT_Get_Module ( library , driver_name ) ; } #ifdef FT_MACINTOSH if ( face_index > 0 ) face_index = 0 ; #endif error = FT_Open_Face ( library , & args , face_index , aface ) ; if ( error == FT_Err_Ok ) ( * aface ) -> face_flags &= ~ FT_FACE_FLAG_EXTERNAL_STREAM ; else #ifdef FT_MACINTOSH FT_Stream_Free ( stream , 0 ) ; #else { FT_Stream_Close ( stream ) ; FT_FREE ( stream ) ; } #endif return error ; }
static int snd_hrtimer_stop ( struct snd_timer * t ) { struct snd_hrtimer * stime = t -> private_data ; atomic_set ( & stime -> running , 0 ) ; return 0 ; }
static int binder_thread_release ( struct binder_proc * proc , struct binder_thread * thread ) { struct binder_transaction * t ; struct binder_transaction * send_reply = NULL ; int active_transactions = 0 ; struct binder_transaction * last_t = NULL ; binder_inner_proc_lock ( thread -> proc ) ; proc -> tmp_ref ++ ; atomic_inc ( & thread -> tmp_ref ) ; rb_erase ( & thread -> rb_node , & proc -> threads ) ; t = thread -> transaction_stack ; if ( t ) { spin_lock ( & t -> lock ) ; if ( t -> to_thread == thread ) send_reply = t ; } thread -> is_dead = true ; while ( t ) { last_t = t ; active_transactions ++ ; binder_debug ( BINDER_DEBUG_DEAD_TRANSACTION , "release %d:%d transaction %d %s, still active\n" , proc -> pid , thread -> pid , t -> debug_id , ( t -> to_thread == thread ) ? "in" : "out" ) ; if ( t -> to_thread == thread ) { t -> to_proc = NULL ; t -> to_thread = NULL ; if ( t -> buffer ) { t -> buffer -> transaction = NULL ; t -> buffer = NULL ; } t = t -> to_parent ; } else if ( t -> from == thread ) { t -> from = NULL ; t = t -> from_parent ; } else BUG ( ) ; spin_unlock ( & last_t -> lock ) ; if ( t ) spin_lock ( & t -> lock ) ; } if ( ( thread -> looper & BINDER_LOOPER_STATE_POLL ) && waitqueue_active ( & thread -> wait ) ) { wake_up_poll ( & thread -> wait , EPOLLHUP | POLLFREE ) ; } binder_inner_proc_unlock ( thread -> proc ) ; if ( send_reply ) binder_send_failed_reply ( send_reply , BR_DEAD_REPLY ) ; binder_release_work ( proc , & thread -> todo ) ; binder_thread_dec_tmpref ( thread ) ; return active_transactions ; }
std :: string TarFileReader :: extract ( const string & _path ) { if ( _path . empty ( ) ) THROW ( "path cannot be empty" ) ; if ( ! hasMore ( ) ) THROW ( "No more tar files" ) ; string path = _path ; if ( SystemUtilities :: isDirectory ( path ) ) path += "/" + getFilename ( ) ; LOG_DEBUG ( 5 , "Extracting: " < < path ) ; return extract ( * SystemUtilities :: oopen ( path ) ) ; }
js :: CloneRegExpObject ( JSContext * cx , JSObject * obj_ , JSObject * proto_ ) { RegExpObjectBuilder builder ( cx ) ; Rooted < RegExpObject * > regex ( cx , & obj_ -> as < RegExpObject > ( ) ) ; Rooted < RegExpObject * > proto ( cx , & proto_ -> as < RegExpObject > ( ) ) ; return builder . clone ( regex , proto ) ; }
static int ntlm_decode_oem_str ( struct wire_field_hdr * str_hdr , struct ntlm_buffer * buffer , size_t payload_offs , char * * _str ) { uint16_t str_len ; uint32_t str_offs ; char * str = NULL ; str_len = le16toh ( str_hdr -> len ) ; if ( str_len == 0 ) goto done ; str_offs = le32toh ( str_hdr -> offset ) ; if ( ( str_offs < payload_offs ) || ( str_offs > buffer -> length ) || ( str_offs + str_len > buffer -> length ) ) { return ERR_DECODE ; } str = strndup ( ( const char * ) & buffer -> data [ str_offs ] , str_len ) ; if ( ! str ) return ENOMEM ; done : * _str = str ; return 0 ; }
static int atl2_probe ( struct pci_dev * pdev , const struct pci_device_id * ent ) { struct net_device * netdev ; struct atl2_adapter * adapter ; static int cards_found ; unsigned long mmio_start ; int mmio_len ; int err ; cards_found = 0 ; err = pci_enable_device ( pdev ) ; if ( err ) return err ; if ( pci_set_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) && pci_set_consistent_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) ) { printk ( KERN_ERR "atl2: No usable DMA configuration, aborting\n" ) ; goto err_dma ; } err = pci_request_regions ( pdev , atl2_driver_name ) ; if ( err ) goto err_pci_reg ; pci_set_master ( pdev ) ; err = - ENOMEM ; netdev = alloc_etherdev ( sizeof ( struct atl2_adapter ) ) ; if ( ! netdev ) goto err_alloc_etherdev ; SET_NETDEV_DEV ( netdev , & pdev -> dev ) ; pci_set_drvdata ( pdev , netdev ) ; adapter = netdev_priv ( netdev ) ; adapter -> netdev = netdev ; adapter -> pdev = pdev ; adapter -> hw . back = adapter ; mmio_start = pci_resource_start ( pdev , 0x0 ) ; mmio_len = pci_resource_len ( pdev , 0x0 ) ; adapter -> hw . mem_rang = ( u32 ) mmio_len ; adapter -> hw . hw_addr = ioremap ( mmio_start , mmio_len ) ; if ( ! adapter -> hw . hw_addr ) { err = - EIO ; goto err_ioremap ; } atl2_setup_pcicmd ( pdev ) ; netdev -> netdev_ops = & atl2_netdev_ops ; netdev -> ethtool_ops = & atl2_ethtool_ops ; netdev -> watchdog_timeo = 5 * HZ ; strncpy ( netdev -> name , pci_name ( pdev ) , sizeof ( netdev -> name ) - 1 ) ; netdev -> mem_start = mmio_start ; netdev -> mem_end = mmio_start + mmio_len ; adapter -> bd_number = cards_found ; adapter -> pci_using_64 = false ; err = atl2_sw_init ( adapter ) ; if ( err ) goto err_sw_init ; err = - EIO ; netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ; atl2_phy_init ( & adapter -> hw ) ; if ( atl2_reset_hw ( & adapter -> hw ) ) { err = - EIO ; goto err_reset ; } atl2_read_mac_addr ( & adapter -> hw ) ; memcpy ( netdev -> dev_addr , adapter -> hw . mac_addr , netdev -> addr_len ) ; if ( ! is_valid_ether_addr ( netdev -> dev_addr ) ) { err = - EIO ; goto err_eeprom ; } atl2_check_options ( adapter ) ; setup_timer ( & adapter -> watchdog_timer , atl2_watchdog , ( unsigned long ) adapter ) ; setup_timer ( & adapter -> phy_config_timer , atl2_phy_config , ( unsigned long ) adapter ) ; INIT_WORK ( & adapter -> reset_task , atl2_reset_task ) ; INIT_WORK ( & adapter -> link_chg_task , atl2_link_chg_task ) ; strcpy ( netdev -> name , "eth%d" ) ; err = register_netdev ( netdev ) ; if ( err ) goto err_register ; netif_carrier_off ( netdev ) ; netif_stop_queue ( netdev ) ; cards_found ++ ; return 0 ; err_reset : err_register : err_sw_init : err_eeprom : iounmap ( adapter -> hw . hw_addr ) ; err_ioremap : free_netdev ( netdev ) ; err_alloc_etherdev : pci_release_regions ( pdev ) ; err_pci_reg : err_dma : pci_disable_device ( pdev ) ; return err ; }
static int netlbl_cipsov4_add_common ( struct genl_info * info , struct cipso_v4_doi * doi_def ) { struct nlattr * nla ; int nla_rem ; u32 iter = 0 ; doi_def -> doi = nla_get_u32 ( info -> attrs [ NLBL_CIPSOV4_A_DOI ] ) ; if ( nla_validate_nested ( info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , NLBL_CIPSOV4_A_MAX , netlbl_cipsov4_genl_policy ) != 0 ) return - EINVAL ; nla_for_each_nested ( nla , info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , nla_rem ) if ( nla -> nla_type == NLBL_CIPSOV4_A_TAG ) { if ( iter > CIPSO_V4_TAG_MAXCNT ) return - EINVAL ; doi_def -> tags [ iter ++ ] = nla_get_u8 ( nla ) ; } if ( iter < CIPSO_V4_TAG_MAXCNT ) doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ; return 0 ; }
static int rfcomm_sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct bt_security sec ; int len , err = 0 ; BT_DBG ( "sk %p" , sk ) ; if ( level == SOL_RFCOMM ) return rfcomm_sock_getsockopt_old ( sock , optname , optval , optlen ) ; if ( level != SOL_BLUETOOTH ) return - ENOPROTOOPT ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; switch ( optname ) { case BT_SECURITY : if ( sk -> sk_type != SOCK_STREAM ) { err = - EINVAL ; break ; } sec . level = rfcomm_pi ( sk ) -> sec_level ; len = min_t ( unsigned int , len , sizeof ( sec ) ) ; if ( copy_to_user ( optval , ( char * ) & sec , len ) ) err = - EFAULT ; break ; case BT_DEFER_SETUP : if ( sk -> sk_state != BT_BOUND && sk -> sk_state != BT_LISTEN ) { err = - EINVAL ; break ; } if ( put_user ( test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) , ( u32 __user * ) optval ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return err ; }
WebGLContext :: TexImage2D_base ( WebGLenum target , WebGLint level , WebGLenum internalformat , WebGLsizei width , WebGLsizei height , WebGLsizei srcStrideOrZero , WebGLint border , WebGLenum format , WebGLenum type , void * data , uint32_t byteLength , int jsArrayType , WebGLTexelFormat srcFormat , bool srcPremultiplied ) { if ( ! ValidateTexImage2DTarget ( target , width , height , "texImage2D" ) ) { return ; } switch ( format ) { case LOCAL_GL_RGB : case LOCAL_GL_RGBA : case LOCAL_GL_ALPHA : case LOCAL_GL_LUMINANCE : case LOCAL_GL_LUMINANCE_ALPHA : case LOCAL_GL_DEPTH_COMPONENT : case LOCAL_GL_DEPTH_STENCIL : break ; default : return ErrorInvalidEnumInfo ( "texImage2D: internal format" , internalformat ) ; } if ( format != internalformat ) return ErrorInvalidOperation ( "texImage2D: format does not match internalformat" ) ; if ( ! ValidateLevelWidthHeightForTarget ( target , level , width , height , "texImage2D" ) ) { return ; } if ( level >= 1 ) { if ( ! ( is_pot_assuming_nonnegative ( width ) && is_pot_assuming_nonnegative ( height ) ) ) return ErrorInvalidValue ( "texImage2D: with level > 0, width and height must be powers of two" ) ; } if ( border != 0 ) return ErrorInvalidValue ( "texImage2D: border must be 0" ) ; if ( format == LOCAL_GL_DEPTH_COMPONENT || format == LOCAL_GL_DEPTH_STENCIL ) { if ( IsExtensionEnabled ( WEBGL_depth_texture ) ) { if ( target != LOCAL_GL_TEXTURE_2D || data != NULL || level != 0 ) return ErrorInvalidOperation ( "texImage2D: " "with format of DEPTH_COMPONENT or DEPTH_STENCIL " "target must be TEXTURE_2D, " "data must be NULL, " "level must be zero" ) ; } else return ErrorInvalidEnumInfo ( "texImage2D: internal format" , internalformat ) ; } uint32_t dstTexelSize = 0 ; if ( ! ValidateTexFormatAndType ( format , type , jsArrayType , & dstTexelSize , "texImage2D" ) ) return ; WebGLTexelFormat dstFormat = GetWebGLTexelFormat ( format , type ) ; WebGLTexelFormat actualSrcFormat = srcFormat == WebGLTexelConversions :: Auto ? dstFormat : srcFormat ; uint32_t srcTexelSize = WebGLTexelConversions :: TexelBytesForFormat ( actualSrcFormat ) ; CheckedUint32 checked_neededByteLength = GetImageSize ( height , width , srcTexelSize , mPixelStoreUnpackAlignment ) ; CheckedUint32 checked_plainRowSize = CheckedUint32 ( width ) * srcTexelSize ; CheckedUint32 checked_alignedRowSize = RoundedToNextMultipleOf ( checked_plainRowSize . value ( ) , mPixelStoreUnpackAlignment ) ; if ( ! checked_neededByteLength . isValid ( ) ) return ErrorInvalidOperation ( "texImage2D: integer overflow computing the needed buffer size" ) ; uint32_t bytesNeeded = checked_neededByteLength . value ( ) ; if ( byteLength && byteLength < bytesNeeded ) return ErrorInvalidOperation ( "texImage2D: not enough data for operation (need %d, have %d)" , bytesNeeded , byteLength ) ; WebGLTexture * tex = activeBoundTextureForTarget ( target ) ; if ( ! tex ) return ErrorInvalidOperation ( "texImage2D: no texture is bound to this target" ) ; MakeContextCurrent ( ) ; internalformat = InternalFormatForFormatAndType ( format , type , gl -> IsGLES2 ( ) ) ; GLenum error = LOCAL_GL_NO_ERROR ; if ( byteLength ) { size_t srcStride = srcStrideOrZero ? srcStrideOrZero : checked_alignedRowSize . value ( ) ; size_t dstPlainRowSize = dstTexelSize * width ; size_t unpackAlignment = mPixelStoreUnpackAlignment ; size_t dstStride = ( ( dstPlainRowSize + unpackAlignment - 1 ) / unpackAlignment ) * unpackAlignment ; if ( actualSrcFormat == dstFormat && srcPremultiplied == mPixelStorePremultiplyAlpha && srcStride == dstStride && ! mPixelStoreFlipY ) { error = CheckedTexImage2D ( target , level , internalformat , width , height , border , format , type , data ) ; } else { size_t convertedDataSize = height * dstStride ; nsAutoArrayPtr < uint8_t > convertedData ( new uint8_t [ convertedDataSize ] ) ; ConvertImage ( width , height , srcStride , dstStride , static_cast < uint8_t * > ( data ) , convertedData , actualSrcFormat , srcPremultiplied , dstFormat , mPixelStorePremultiplyAlpha , dstTexelSize ) ; error = CheckedTexImage2D ( target , level , internalformat , width , height , border , format , type , convertedData ) ; } } else { void * tempZeroData = calloc ( 1 , bytesNeeded ) ; if ( ! tempZeroData ) return ErrorOutOfMemory ( "texImage2D: could not allocate %d bytes (for zero fill)" , bytesNeeded ) ; error = CheckedTexImage2D ( target , level , internalformat , width , height , border , format , type , tempZeroData ) ; free ( tempZeroData ) ; } if ( error ) { GenerateWarning ( "texImage2D generated error %s" , ErrorName ( error ) ) ; return ; } tex -> SetImageInfo ( target , level , width , height , format , type ) ; }
TEST_P ( CpuSpeedTest , TestQ0 ) { cfg_ . g_lag_in_frames = 25 ; cfg_ . rc_2pass_vbr_minsection_pct = 5 ; cfg_ . rc_2pass_vbr_minsection_pct = 2000 ; cfg_ . rc_target_bitrate = 400 ; cfg_ . rc_max_quantizer = 0 ; cfg_ . rc_min_quantizer = 0 ; :: libvpx_test :: I420VideoSource video ( "hantro_odd.yuv" , 208 , 144 , 30 , 1 , 0 , 20 ) ; ASSERT_NO_FATAL_FAILURE ( RunLoop ( & video ) ) ; }
RUNTIME_FUNCTION ( Runtime_DebugTogglePreciseCoverage ) { SealHandleScope shs ( isolate ) ; CONVERT_BOOLEAN_ARG_CHECKED ( enable , 0 ) ; Coverage :: SelectMode ( isolate , enable ? debug :: Coverage :: kPreciseCount : debug :: Coverage :: kBestEffort ) ; return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
Handle < JSArrayBuffer > JSTypedArray :: GetBuffer ( ) { if ( ! is_on_heap ( ) ) { Handle < JSArrayBuffer > array_buffer ( JSArrayBuffer :: cast ( buffer ( ) ) , GetIsolate ( ) ) ; return array_buffer ; } Handle < JSTypedArray > self ( this , GetIsolate ( ) ) ; return MaterializeArrayBuffer ( self ) ; }
CompileError :: ~ CompileError ( ) { js_free ( ( void * ) report . uclinebuf ) ; js_free ( ( void * ) report . linebuf ) ; js_free ( ( void * ) report . ucmessage ) ; js_free ( message ) ; message = nullptr ; if ( report . messageArgs ) { if ( argumentsType == ArgumentsAreASCII ) { unsigned i = 0 ; while ( report . messageArgs [ i ] ) js_free ( ( void * ) report . messageArgs [ i ++ ] ) ; } js_free ( report . messageArgs ) ; } PodZero ( & report ) ; }
Reduction JSCreateLowering :: ReduceJSCreate ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSCreate , node -> opcode ( ) ) ; Node * const target = NodeProperties :: GetValueInput ( node , 0 ) ; Type const target_type = NodeProperties :: GetType ( target ) ; Node * const new_target = NodeProperties :: GetValueInput ( node , 1 ) ; Type const new_target_type = NodeProperties :: GetType ( new_target ) ; Node * const effect = NodeProperties :: GetEffectInput ( node ) ; Node * const control = NodeProperties :: GetControlInput ( node ) ; if ( ! target_type . IsHeapConstant ( ) || ! new_target_type . IsHeapConstant ( ) || ! target_type . AsHeapConstant ( ) -> Ref ( ) . IsJSFunction ( ) || ! new_target_type . AsHeapConstant ( ) -> Ref ( ) . IsJSFunction ( ) ) { return NoChange ( ) ; } JSFunctionRef constructor = target_type . AsHeapConstant ( ) -> Ref ( ) . AsJSFunction ( ) ; if ( ! constructor . IsConstructor ( ) ) return NoChange ( ) ; JSFunctionRef original_constructor = new_target_type . AsHeapConstant ( ) -> Ref ( ) . AsJSFunction ( ) ; if ( ! original_constructor . IsConstructor ( ) ) return NoChange ( ) ; if ( ! IsAllocationInlineable ( constructor , original_constructor ) ) { return NoChange ( ) ; } SlackTrackingPrediction slack_tracking_prediction = dependencies ( ) -> DependOnInitialMapInstanceSizePrediction ( original_constructor ) ; MapRef initial_map = original_constructor . initial_map ( ) ; AllocationBuilder a ( jsgraph ( ) , effect , control ) ; a . Allocate ( slack_tracking_prediction . instance_size ( ) ) ; a . Store ( AccessBuilder :: ForMap ( ) , initial_map ) ; a . Store ( AccessBuilder :: ForJSObjectPropertiesOrHash ( ) , jsgraph ( ) -> EmptyFixedArrayConstant ( ) ) ; a . Store ( AccessBuilder :: ForJSObjectElements ( ) , jsgraph ( ) -> EmptyFixedArrayConstant ( ) ) ; for ( int i = 0 ; i < slack_tracking_prediction . inobject_property_count ( ) ; ++ i ) { a . Store ( AccessBuilder :: ForJSObjectInObjectProperty ( initial_map , i ) , jsgraph ( ) -> UndefinedConstant ( ) ) ; } RelaxControls ( node ) ; a . FinishAndChange ( node ) ; return Changed ( node ) ; }
qf_jump_open_window ( qf_info_T * qi , qfline_T * qf_ptr , int newwin , int * opened_window ) { qf_list_T * qfl = qf_get_curlist ( qi ) ; int old_changedtick = qfl -> qf_changedtick ; int old_qf_curlist = qi -> qf_curlist ; qfltype_T qfl_type = qfl -> qfl_type ; if ( qf_ptr -> qf_type == 1 && ( ! bt_help ( curwin -> w_buffer ) || cmdmod . cmod_tab != 0 ) ) if ( jump_to_help_window ( qi , newwin , opened_window ) == FAIL ) return FAIL ; if ( old_qf_curlist != qi -> qf_curlist || old_changedtick != qfl -> qf_changedtick || ! is_qf_entry_present ( qfl , qf_ptr ) ) { if ( qfl_type == QFLT_QUICKFIX ) emsg ( _ ( e_current_quickfix_list_was_changed ) ) ; else emsg ( _ ( e_current_location_list_was_changed ) ) ; return FAIL ; } if ( bt_quickfix ( curbuf ) && ! * opened_window ) { if ( qf_ptr -> qf_fnum == 0 ) return NOTDONE ; if ( qf_jump_to_usable_window ( qf_ptr -> qf_fnum , newwin , opened_window ) == FAIL ) return FAIL ; } if ( old_qf_curlist != qi -> qf_curlist || old_changedtick != qfl -> qf_changedtick || ! is_qf_entry_present ( qfl , qf_ptr ) ) { if ( qfl_type == QFLT_QUICKFIX ) emsg ( _ ( e_current_quickfix_list_was_changed ) ) ; else emsg ( _ ( e_current_location_list_was_changed ) ) ; return FAIL ; } return OK ; }
void MediaPlayerService :: Client :: setDataSource_post ( const sp < MediaPlayerBase > & p , status_t status ) { ALOGV ( " setDataSource" ) ; mStatus = status ; if ( mStatus != OK ) { ALOGE ( "  error: %d" , mStatus ) ; return ; } if ( mRetransmitEndpointValid ) { mStatus = p -> setRetransmitEndpoint ( & mRetransmitEndpoint ) ; if ( mStatus != NO_ERROR ) { ALOGE ( "setRetransmitEndpoint error: %d" , mStatus ) ; } } if ( mStatus == OK ) { mPlayer = p ; } }
void bn_sqr_comba4 ( BN_ULONG * r , const BN_ULONG * a ) { #ifdef BN_LLONG BN_ULLONG t , tt ; #else BN_ULONG bl , bh ; #endif BN_ULONG t1 , t2 ; BN_ULONG c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; sqr_add_c ( a , 0 , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 1 , 0 , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 1 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 2 , 0 , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; sqr_add_c2 ( a , 3 , 0 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 2 , 1 , c1 , c2 , c3 ) ; r [ 3 ] = c1 ; c1 = 0 ; sqr_add_c ( a , 2 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 3 , 1 , c2 , c3 , c1 ) ; r [ 4 ] = c2 ; c2 = 0 ; sqr_add_c2 ( a , 3 , 2 , c3 , c1 , c2 ) ; r [ 5 ] = c3 ; c3 = 0 ; sqr_add_c ( a , 3 , c1 , c2 , c3 ) ; r [ 6 ] = c1 ; r [ 7 ] = c2 ; }
int mingw_rmdir ( const char * pathname ) { int ret , tries = 0 ; wchar_t wpathname [ MAX_PATH ] ; if ( xutftowcs_path ( wpathname , pathname ) < 0 ) return - 1 ; while ( ( ret = _wrmdir ( wpathname ) ) == - 1 && tries < ARRAY_SIZE ( delay ) ) { if ( ! is_file_in_use_error ( GetLastError ( ) ) ) errno = err_win_to_posix ( GetLastError ( ) ) ; if ( errno != EACCES ) break ; if ( ! is_dir_empty ( wpathname ) ) { errno = ENOTEMPTY ; break ; } Sleep ( delay [ tries ] ) ; tries ++ ; } while ( ret == - 1 && errno == EACCES && is_file_in_use_error ( GetLastError ( ) ) && ask_yes_no_if_possible ( "Deletion of directory '%s' failed. " "Should I try again?" , pathname ) ) ret = _wrmdir ( wpathname ) ; return ret ; }
BackgroundParentImpl :: AllocPFileSystemRequestParent ( const FileSystemParams & aParams ) { AssertIsInMainProcess ( ) ; AssertIsOnBackgroundThread ( ) ; RefPtr < FileSystemRequestParent > result = new FileSystemRequestParent ( ) ; if ( NS_WARN_IF ( ! result -> Initialize ( aParams ) ) ) { return nullptr ; } result -> Start ( ) ; return result . forget ( ) . take ( ) ; }
void QuickOpen :: Load ( uint64 BlockPos ) { if ( ! Loaded ) { SeekPos = Arc -> Tell ( ) ; UnsyncSeekPos = false ; SaveFilePos SavePos ( * Arc ) ; Arc -> Seek ( BlockPos , SEEK_SET ) ; if ( Arc -> ReadHeader ( ) == 0 || Arc -> GetHeaderType ( ) != HEAD_SERVICE || ! Arc -> SubHead . CmpName ( SUBHEAD_TYPE_QOPEN ) ) return ; QLHeaderPos = Arc -> CurBlockPos ; RawDataStart = Arc -> Tell ( ) ; RawDataSize = Arc -> SubHead . UnpSize ; Loaded = true ; } if ( Arc -> SubHead . Encrypted ) { RAROptions * Cmd = Arc -> GetRAROptions ( ) ; #ifndef RAR_NOCRYPT if ( Cmd -> Password . IsSet ( ) ) Crypt . SetCryptKeys ( false , CRYPT_RAR50 , & Cmd -> Password , Arc -> SubHead . Salt , Arc -> SubHead . InitV , Arc -> SubHead . Lg2Count , Arc -> SubHead . HashKey , Arc -> SubHead . PswCheck ) ; else #endif return ; } RawDataPos = 0 ; ReadBufSize = 0 ; ReadBufPos = 0 ; LastReadHeader . Reset ( ) ; LastReadHeaderPos = 0 ; ReadBuffer ( ) ; }
SetProto ( JSContext * cx , JSObject * obj , JSObject * proto , bool checkForCycles ) { JS_ASSERT_IF ( ! checkForCycles , obj != proto ) ; JS_ASSERT ( obj -> isExtensible ( ) ) ; if ( obj -> isNative ( ) ) { if ( ! obj -> ensureClassReservedSlots ( cx ) ) return false ; } JSObject * oldproto = obj ; while ( oldproto && oldproto -> isNative ( ) ) { oldproto -> protoShapeChange ( cx ) ; oldproto = oldproto -> getProto ( ) ; } if ( checkForCycles ) { for ( JSObject * obj2 = proto ; obj2 ; obj2 = obj2 -> getProto ( ) ) { if ( obj2 == obj ) { JS_ReportErrorNumber ( cx , js_GetErrorMessage , NULL , JSMSG_CYCLIC_VALUE , js_proto_str ) ; return false ; } } } obj -> setProto ( proto ) ; return true ; }
static u32 svc_rdma_get_inv_rkey ( struct rpcrdma_msg * rdma_argp , struct rpcrdma_write_array * wr_ary , struct rpcrdma_write_array * rp_ary ) { struct rpcrdma_read_chunk * rd_ary ; struct rpcrdma_segment * arg_ch ; rd_ary = ( struct rpcrdma_read_chunk * ) & rdma_argp -> rm_body . rm_chunks [ 0 ] ; if ( rd_ary -> rc_discrim != xdr_zero ) return be32_to_cpu ( rd_ary -> rc_target . rs_handle ) ; if ( wr_ary && be32_to_cpu ( wr_ary -> wc_nchunks ) ) { arg_ch = & wr_ary -> wc_array [ 0 ] . wc_target ; return be32_to_cpu ( arg_ch -> rs_handle ) ; } if ( rp_ary && be32_to_cpu ( rp_ary -> wc_nchunks ) ) { arg_ch = & rp_ary -> wc_array [ 0 ] . wc_target ; return be32_to_cpu ( arg_ch -> rs_handle ) ; } return 0 ; }
MediaResource :: Create ( MediaDecoder * aDecoder , nsIChannel * aChannel ) { NS_ASSERTION ( NS_IsMainThread ( ) , "MediaResource::Open called on non-main thread" ) ; nsCOMPtr < nsIURI > uri ; nsresult rv = NS_GetFinalChannelURI ( aChannel , getter_AddRefs ( uri ) ) ; NS_ENSURE_SUCCESS ( rv , nullptr ) ; nsAutoCString contentType ; aChannel -> GetContentType ( contentType ) ; nsCOMPtr < nsIFileChannel > fc = do_QueryInterface ( aChannel ) ; if ( fc || IsBlobURI ( uri ) ) { return new FileMediaResource ( aDecoder , aChannel , uri , contentType ) ; } return new ChannelMediaResource ( aDecoder , aChannel , uri , contentType ) ; }
static bool parse_notify ( struct pool * pool , json_t * val ) { char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , * ntime , header [ 228 ] ; unsigned char * cb1 = NULL , * cb2 = NULL ; size_t cb1_len , cb2_len , alloc_len ; bool clean , ret = false ; int merkles , i ; json_t * arr ; arr = json_array_get ( val , 4 ) ; if ( ! arr || ! json_is_array ( arr ) ) goto out ; merkles = json_array_size ( arr ) ; job_id = json_array_string ( val , 0 ) ; prev_hash = __json_array_string ( val , 1 ) ; coinbase1 = json_array_string ( val , 2 ) ; coinbase2 = json_array_string ( val , 3 ) ; bbversion = __json_array_string ( val , 5 ) ; nbit = __json_array_string ( val , 6 ) ; ntime = __json_array_string ( val , 7 ) ; clean = json_is_true ( json_array_get ( val , 8 ) ) ; if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { if ( job_id ) free ( job_id ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; free ( pool -> swork . job_id ) ; pool -> swork . job_id = job_id ; snprintf ( pool -> prev_hash , 65 , "%s" , prev_hash ) ; cb1_len = strlen ( coinbase1 ) / 2 ; cb2_len = strlen ( coinbase2 ) / 2 ; snprintf ( pool -> bbversion , 9 , "%s" , bbversion ) ; snprintf ( pool -> nbit , 9 , "%s" , nbit ) ; snprintf ( pool -> ntime , 9 , "%s" , ntime ) ; pool -> swork . clean = clean ; alloc_len = pool -> coinbase_len = cb1_len + pool -> n1_len + pool -> n2size + cb2_len ; pool -> nonce2_offset = cb1_len + pool -> n1_len ; for ( i = 0 ; i < pool -> merkles ; i ++ ) free ( pool -> swork . merkle_bin [ i ] ) ; if ( merkles ) { pool -> swork . merkle_bin = realloc ( pool -> swork . merkle_bin , sizeof ( char * ) * merkles + 1 ) ; for ( i = 0 ; i < merkles ; i ++ ) { char * merkle = json_array_string ( arr , i ) ; pool -> swork . merkle_bin [ i ] = malloc ( 32 ) ; if ( unlikely ( ! pool -> swork . merkle_bin [ i ] ) ) quit ( 1 , "Failed to malloc pool swork merkle_bin" ) ; if ( opt_protocol ) applog ( LOG_DEBUG , "merkle %d: %s" , i , merkle ) ; ret = hex2bin ( pool -> swork . merkle_bin [ i ] , merkle , 32 ) ; free ( merkle ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , "Failed to convert merkle to merkle_bin in parse_notify" ) ; goto out_unlock ; } } } pool -> merkles = merkles ; if ( clean ) pool -> nonce2 = 0 ; #if 0 header_len = strlen ( pool -> bbversion ) + strlen ( pool -> prev_hash ) ; 32 + strlen ( pool -> ntime ) + strlen ( pool -> nbit ) + 8 + 96 ; #endif snprintf ( header , 225 , "%s%s%s%s%s%s%s" , pool -> bbversion , pool -> prev_hash , blank_merkle , pool -> ntime , pool -> nbit , "00000000" , workpadding ) ; ret = hex2bin ( pool -> header_bin , header , 112 ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , "Failed to convert header to header_bin in parse_notify" ) ; goto out_unlock ; } cb1 = alloca ( cb1_len ) ; ret = hex2bin ( cb1 , coinbase1 , cb1_len ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , "Failed to convert cb1 to cb1_bin in parse_notify" ) ; goto out_unlock ; } cb2 = alloca ( cb2_len ) ; ret = hex2bin ( cb2 , coinbase2 , cb2_len ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , "Failed to convert cb2 to cb2_bin in parse_notify" ) ; goto out_unlock ; } free ( pool -> coinbase ) ; align_len ( & alloc_len ) ; pool -> coinbase = calloc ( alloc_len , 1 ) ; if ( unlikely ( ! pool -> coinbase ) ) quit ( 1 , "Failed to calloc pool coinbase in parse_notify" ) ; memcpy ( pool -> coinbase , cb1 , cb1_len ) ; memcpy ( pool -> coinbase + cb1_len , pool -> nonce1bin , pool -> n1_len ) ; memcpy ( pool -> coinbase + cb1_len + pool -> n1_len + pool -> n2size , cb2 , cb2_len ) ; if ( opt_debug ) { char * cb = bin2hex ( pool -> coinbase , pool -> coinbase_len ) ; applog ( LOG_DEBUG , "Pool %d coinbase %s" , pool -> pool_no , cb ) ; free ( cb ) ; } out_unlock : cg_wunlock ( & pool -> data_lock ) ; if ( opt_protocol ) { applog ( LOG_DEBUG , "job_id: %s" , job_id ) ; applog ( LOG_DEBUG , "prev_hash: %s" , prev_hash ) ; applog ( LOG_DEBUG , "coinbase1: %s" , coinbase1 ) ; applog ( LOG_DEBUG , "coinbase2: %s" , coinbase2 ) ; applog ( LOG_DEBUG , "bbversion: %s" , bbversion ) ; applog ( LOG_DEBUG , "nbit: %s" , nbit ) ; applog ( LOG_DEBUG , "ntime: %s" , ntime ) ; applog ( LOG_DEBUG , "clean: %s" , clean ? "yes" : "no" ) ; } free ( coinbase1 ) ; free ( coinbase2 ) ; pool -> getwork_requested ++ ; total_getworks ++ ; if ( pool == current_pool ( ) ) opt_work_update = true ; out : return ret ; }
void vp9_update_spatial_layer_framerate ( VP9_COMP * const cpi , double framerate ) { const VP9_CONFIG * const oxcf = & cpi -> oxcf ; LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; RATE_CONTROL * const lrc = & lc -> rc ; lc -> framerate = framerate ; lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; lrc -> min_frame_bandwidth = ( int ) ( lrc -> av_per_frame_bandwidth * oxcf -> two_pass_vbrmin_section / 100 ) ; lrc -> max_frame_bandwidth = ( int ) ( ( ( int64_t ) lrc -> av_per_frame_bandwidth * oxcf -> two_pass_vbrmax_section ) / 100 ) ; lrc -> max_gf_interval = 16 ; lrc -> static_scene_max_gf_interval = cpi -> key_frame_frequency > > 1 ; if ( oxcf -> play_alternate && oxcf -> lag_in_frames ) { if ( lrc -> max_gf_interval > oxcf -> lag_in_frames - 1 ) lrc -> max_gf_interval = oxcf -> lag_in_frames - 1 ; if ( lrc -> static_scene_max_gf_interval > oxcf -> lag_in_frames - 1 ) lrc -> static_scene_max_gf_interval = oxcf -> lag_in_frames - 1 ; } if ( lrc -> max_gf_interval > lrc -> static_scene_max_gf_interval ) lrc -> max_gf_interval = lrc -> static_scene_max_gf_interval ; }
nsPluginInstanceOwner :: ProcessMouseDown ( nsIDOMEvent * aMouseEvent ) { #if !defined(XP_MACOSX) if ( ! mPluginWindow || ( mPluginWindow -> type == NPWindowTypeWindow ) ) return aMouseEvent -> PreventDefault ( ) ; #endif if ( mPluginFrame && mPluginWindow && mPluginWindow -> type == NPWindowTypeDrawable ) { nsIFocusManager * fm = nsFocusManager :: GetFocusManager ( ) ; if ( fm ) { nsCOMPtr < nsIDOMElement > elem = do_QueryInterface ( mContent ) ; fm -> SetFocus ( elem , 0 ) ; } } WidgetMouseEvent * mouseEvent = aMouseEvent -> GetInternalNSEvent ( ) -> AsMouseEvent ( ) ; if ( mouseEvent && mouseEvent -> mClass == eMouseEventClass ) { mLastMouseDownButtonType = mouseEvent -> button ; nsEventStatus rv = ProcessEvent ( * mouseEvent ) ; if ( nsEventStatus_eConsumeNoDefault == rv ) { return aMouseEvent -> PreventDefault ( ) ; } } return NS_OK ; }
sctp_is_in_timewait ( uint32_t tag , uint16_t lport , uint16_t rport ) { struct sctpvtaghead * chain ; struct sctp_tagblock * twait_block ; int found = 0 ; int i ; SCTP_INP_INFO_WLOCK ( ) ; chain = & SCTP_BASE_INFO ( vtag_timewait ) [ ( tag % SCTP_STACK_VTAG_HASH_SIZE ) ] ; LIST_FOREACH ( twait_block , chain , sctp_nxt_tagblock ) { for ( i = 0 ; i < SCTP_NUMBER_IN_VTAG_BLOCK ; i ++ ) { if ( ( twait_block -> vtag_block [ i ] . v_tag == tag ) && ( twait_block -> vtag_block [ i ] . lport == lport ) && ( twait_block -> vtag_block [ i ] . rport == rport ) ) { found = 1 ; break ; } } if ( found ) break ; } SCTP_INP_INFO_WUNLOCK ( ) ; return ( found ) ; }
static struct dump_dir * open_directory_for_modification_of_element ( GDBusMethodInvocation * invocation , uid_t caller_uid , const char * problem_id , const char * element ) { static const char * const protected_elements [ ] = { FILENAME_TIME , FILENAME_UID , NULL , } ; for ( const char * const * protected = protected_elements ; * protected ; ++ protected ) { if ( strcmp ( * protected , element ) == 0 ) { log_notice ( "'%s' element of '%s' can't be modified" , element , problem_id ) ; char * error = xasprintf ( _ ( "'%s' element can't be modified" ) , element ) ; g_dbus_method_invocation_return_dbus_error ( invocation , "org.freedesktop.problems.ProtectedElement" , error ) ; free ( error ) ; return NULL ; } } if ( ! dump_dir_accessible_by_uid ( problem_id , caller_uid ) ) { if ( errno == ENOTDIR ) { log_notice ( "'%s' is not a valid problem directory" , problem_id ) ; return_InvalidProblemDir_error ( invocation , problem_id ) ; } else { log_notice ( "UID(%d) is not Authorized to access '%s'" , caller_uid , problem_id ) ; g_dbus_method_invocation_return_dbus_error ( invocation , "org.freedesktop.problems.AuthFailure" , _ ( "Not Authorized" ) ) ; } return NULL ; } struct dump_dir * dd = dd_opendir ( problem_id , 0 ) ; if ( ! dd ) { log_notice ( "Can't access the problem '%s' for modification" , problem_id ) ; g_dbus_method_invocation_return_dbus_error ( invocation , "org.freedesktop.problems.Failure" , _ ( "Can't access the problem for modification" ) ) ; return NULL ; } return dd ; }
int RunMain ( v8 :: Isolate * isolate , v8 :: Platform * platform , int argc , char * argv [ ] ) { for ( int i = 1 ; i < argc ; i ++ ) { const char * str = argv [ i ] ; if ( strcmp ( str , "--shell" ) == 0 ) { run_shell = true ; } else if ( strcmp ( str , "-f" ) == 0 ) { continue ; } else if ( strncmp ( str , "--" , 2 ) == 0 ) { fprintf ( stderr , "Warning: unknown flag %s.\nTry --help for options\n" , str ) ; } else if ( strcmp ( str , "-e" ) == 0 && i + 1 < argc ) { v8 :: Local < v8 :: String > file_name = v8 :: String :: NewFromUtf8 ( isolate , "unnamed" , v8 :: NewStringType :: kNormal ) . ToLocalChecked ( ) ; v8 :: Local < v8 :: String > source ; if ( ! v8 :: String :: NewFromUtf8 ( isolate , argv [ ++ i ] , v8 :: NewStringType :: kNormal ) . ToLocal ( & source ) ) { return 1 ; } bool success = ExecuteString ( isolate , source , file_name , false , true ) ; while ( v8 :: platform :: PumpMessageLoop ( platform , isolate ) ) continue ; if ( ! success ) return 1 ; } else { v8 :: Local < v8 :: String > file_name = v8 :: String :: NewFromUtf8 ( isolate , str , v8 :: NewStringType :: kNormal ) . ToLocalChecked ( ) ; v8 :: Local < v8 :: String > source ; if ( ! ReadFile ( isolate , str ) . ToLocal ( & source ) ) { fprintf ( stderr , "Error reading '%s'\n" , str ) ; continue ; } bool success = ExecuteString ( isolate , source , file_name , false , true ) ; while ( v8 :: platform :: PumpMessageLoop ( platform , isolate ) ) continue ; if ( ! success ) return 1 ; } } return 0 ; }
nsGlobalWindow :: RunTimeoutHandler ( nsTimeout * aTimeout , nsIScriptContext * aScx ) { nsRefPtr < nsTimeout > timeout = aTimeout ; nsTimeout * last_running_timeout = mRunningTimeout ; mRunningTimeout = timeout ; timeout -> mRunning = true ; nsAutoPopupStatePusher popupStatePusher ( timeout -> mPopupState ) ; timeout -> mPopupState = openAbused ; ++ gRunningTimeoutDepth ; ++ mTimeoutFiringDepth ; bool trackNestingLevel = ! timeout -> mIsInterval ; uint32_t nestingLevel ; if ( trackNestingLevel ) { nestingLevel = sNestingLevel ; sNestingLevel = timeout -> mNestingLevel ; } nsCOMPtr < nsIScriptTimeoutHandler > handler ( timeout -> mScriptHandler ) ; nsRefPtr < Function > callback = handler -> GetCallback ( ) ; if ( ! callback ) { const char16_t * script = handler -> GetHandlerText ( ) ; NS_ASSERTION ( script , "timeout has no script nor handler text!" ) ; const char * filename = nullptr ; uint32_t lineNo = 0 ; handler -> GetLocation ( & filename , & lineNo ) ; AutoEntryScript entryScript ( this , true , aScx -> GetNativeContext ( ) ) ; JS :: CompileOptions options ( entryScript . cx ( ) ) ; options . setFileAndLine ( filename , lineNo ) . setVersion ( JSVERSION_DEFAULT ) ; JS :: Rooted < JSObject * > global ( entryScript . cx ( ) , FastGetGlobalJSObject ( ) ) ; nsJSUtils :: EvaluateString ( entryScript . cx ( ) , nsDependentString ( script ) , global , options ) ; } else { nsCOMPtr < nsISupports > me ( static_cast < nsIDOMWindow * > ( this ) ) ; ErrorResult ignored ; callback -> Call ( me , handler -> GetArgs ( ) , ignored ) ; } if ( trackNestingLevel ) { sNestingLevel = nestingLevel ; } -- mTimeoutFiringDepth ; -- gRunningTimeoutDepth ; mRunningTimeout = last_running_timeout ; timeout -> mRunning = false ; return timeout -> mCleared ; }
char * suhosin_decrypt_single_cookie ( char * name , int name_len , char * value , int value_len , char * key , char * * where TSRMLS_DC ) { char buffer [ 4096 ] ; char buffer2 [ 4096 ] ; int o_name_len = name_len ; char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; int l ; if ( name_len > sizeof ( buffer ) - 2 ) { buf = estrndup ( name , name_len ) ; } else { memcpy ( buf , name , name_len ) ; buf [ name_len ] = 0 ; } name_len = php_url_decode ( buf , name_len ) ; normalize_varname ( buf ) ; name_len = strlen ( buf ) ; if ( SUHOSIN_G ( cookie_plainlist ) ) { if ( zend_hash_exists ( SUHOSIN_G ( cookie_plainlist ) , buf , name_len + 1 ) ) { decrypt_return_plain : if ( buf != buffer ) { efree ( buf ) ; } memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , value , value_len ) ; * where += value_len ; return * where ; } } else if ( SUHOSIN_G ( cookie_cryptlist ) ) { if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) { goto decrypt_return_plain ; } } if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { memcpy ( buf2 , value , value_len ) ; buf2 [ value_len ] = 0 ; } else { buf2 = estrndup ( value , value_len ) ; } value_len = php_url_decode ( buf2 , value_len ) ; d = suhosin_decrypt_string ( buf2 , value_len , buf , name_len , key , & l , SUHOSIN_G ( cookie_checkraddr ) TSRMLS_CC ) ; if ( d == NULL ) { goto skip_cookie ; } d_url = php_url_encode ( d , l , & l ) ; efree ( d ) ; memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , d_url , l ) ; * where += l ; efree ( d_url ) ; skip_cookie : if ( buf != buffer ) { efree ( buf ) ; } if ( buf2 != buffer2 ) { efree ( buf2 ) ; } return * where ; }
status_t MPEG4Extractor :: readMetaData ( ) { if ( mInitCheck != NO_INIT ) { return mInitCheck ; } off64_t offset = 0 ; status_t err ; while ( ! mFirstTrack ) { err = parseChunk ( & offset , 0 ) ; if ( err != OK && err != ( status_t ) UNKNOWN_ERROR ) { ALOGW ( "Error %d parsing chuck at offset %lld looking for first track" , err , ( long long ) offset ) ; break ; } } if ( mInitCheck == OK ) { if ( mHasVideo ) { mFileMetaData -> setCString ( kKeyMIMEType , MEDIA_MIMETYPE_CONTAINER_MPEG4 ) ; } else { mFileMetaData -> setCString ( kKeyMIMEType , "audio/mp4" ) ; } mInitCheck = OK ; } else { mInitCheck = err ; } CHECK_NE ( err , ( status_t ) NO_INIT ) ; int psshsize = 0 ; for ( size_t i = 0 ; i < mPssh . Length ( ) ; i ++ ) { psshsize += 20 + mPssh [ i ] . datalen ; } if ( psshsize ) { char * buf = ( char * ) malloc ( psshsize ) ; char * ptr = buf ; for ( size_t i = 0 ; i < mPssh . Length ( ) ; i ++ ) { memcpy ( ptr , mPssh [ i ] . uuid , 20 ) ; memcpy ( ptr + 20 , mPssh [ i ] . data , mPssh [ i ] . datalen ) ; ptr += ( 20 + mPssh [ i ] . datalen ) ; } mFileMetaData -> setData ( kKeyPssh , 'pssh' , buf , psshsize ) ; free ( buf ) ; } return mInitCheck ; }
JSCompartment :: JSCompartment ( Zone * zone , const JS :: CompartmentOptions & options = JS :: CompartmentOptions ( ) ) : creationOptions_ ( options . creationOptions ( ) ) , behaviors_ ( options . behaviors ( ) ) , zone_ ( zone ) , runtime_ ( zone -> runtimeFromMainThread ( ) ) , principals_ ( nullptr ) , isSystem_ ( false ) , isSelfHosting ( false ) , marked ( true ) , warnedAboutExprClosure ( false ) , warnedAboutForEach ( false ) , #ifdef DEBUG firedOnNewGlobalObject ( false ) , #endif global_ ( nullptr ) , enterCompartmentDepth ( 0 ) , performanceMonitoring ( runtime_ ) , data ( nullptr ) , allocationMetadataBuilder ( nullptr ) , lastAnimationTime ( 0 ) , regExps ( runtime_ ) , globalWriteBarriered ( 0 ) , detachedTypedObjects ( 0 ) , objectMetadataState ( ImmediateMetadata ( ) ) , selfHostingScriptSource ( nullptr ) , objectMetadataTable ( nullptr ) , innerViews ( zone , InnerViewTable ( ) ) , lazyArrayBuffers ( nullptr ) , wasm ( zone ) , nonSyntacticLexicalEnvironments_ ( nullptr ) , gcIncomingGrayPointers ( nullptr ) , debugModeBits ( 0 ) , watchpointMap ( nullptr ) , scriptCountsMap ( nullptr ) , debugScriptMap ( nullptr ) , debugEnvs ( nullptr ) , enumerators ( nullptr ) , lastCachedNativeIterator ( nullptr ) , compartmentStats_ ( nullptr ) , scheduledForDestruction ( false ) , maybeAlive ( true ) , jitCompartment_ ( nullptr ) , mappedArgumentsTemplate_ ( nullptr ) , unmappedArgumentsTemplate_ ( nullptr ) , lcovOutput ( ) { PodArrayZero ( sawDeprecatedLanguageExtension ) ; runtime_ -> numCompartments ++ ; MOZ_ASSERT_IF ( creationOptions_ . mergeable ( ) , creationOptions_ . invisibleToDebugger ( ) ) ; }
AnalyserNode :: GetByteFrequencyData ( const Uint8Array & aArray ) { if ( ! FFTAnalysis ( ) ) { return ; } const double rangeScaleFactor = 1.0 / ( mMaxDecibels - mMinDecibels ) ; unsigned char * buffer = aArray . Data ( ) ; size_t length = std :: min ( size_t ( aArray . Length ( ) ) , mOutputBuffer . Length ( ) ) ; for ( size_t i = 0 ; i < length ; ++ i ) { const double decibels = WebAudioUtils :: ConvertLinearToDecibels ( mOutputBuffer [ i ] , mMinDecibels ) ; const double scaled = std :: max ( 0.0 , std :: min ( double ( UCHAR_MAX ) , UCHAR_MAX * ( decibels - mMinDecibels ) * rangeScaleFactor ) ) ; buffer [ i ] = static_cast < unsigned char > ( scaled ) ; } }
OMX_ERRORTYPE SimpleSoftOMXComponent :: internalGetParameter ( OMX_INDEXTYPE index , OMX_PTR params ) { switch ( index ) { case OMX_IndexParamPortDefinition : { OMX_PARAM_PORTDEFINITIONTYPE * defParams = ( OMX_PARAM_PORTDEFINITIONTYPE * ) params ; if ( defParams -> nPortIndex >= mPorts . size ( ) || defParams -> nSize != sizeof ( OMX_PARAM_PORTDEFINITIONTYPE ) ) { return OMX_ErrorUndefined ; } const PortInfo * port = & mPorts . itemAt ( defParams -> nPortIndex ) ; memcpy ( defParams , & port -> mDef , sizeof ( port -> mDef ) ) ; return OMX_ErrorNone ; } default : return OMX_ErrorUnsupportedIndex ; } }
nsScriptElement :: MaybeProcessScript ( ) { nsCOMPtr < nsIContent > cont = do_QueryInterface ( ( nsIScriptElement * ) this ) ; NS_ASSERTION ( cont -> DebugGetSlots ( ) -> mMutationObservers . Contains ( this ) , "You forgot to add self as observer" ) ; if ( mIsEvaluated || ! mDoneAddingChildren || ! cont -> IsInDoc ( ) || mMalformed || InNonScriptingContainer ( cont ) || ! HasScriptContent ( ) ) { return NS_OK ; } nsresult scriptresult = NS_OK ; nsRefPtr < nsScriptLoader > loader = cont -> GetOwnerDoc ( ) -> ScriptLoader ( ) ; mIsEvaluated = PR_TRUE ; scriptresult = loader -> ProcessScriptElement ( this ) ; if ( NS_FAILED ( scriptresult ) && scriptresult != NS_ERROR_HTMLPARSER_BLOCK ) { scriptresult = NS_OK ; } return scriptresult ; }
void Compute ( OpKernelContext * context ) override { OpInputList indices_list_in ; OP_REQUIRES_OK ( context , context -> input_list ( "indices" , & indices_list_in ) ) ; OpInputList values_list_in ; OP_REQUIRES_OK ( context , context -> input_list ( "values" , & values_list_in ) ) ; OpInputList shapes_list_in ; OP_REQUIRES_OK ( context , context -> input_list ( "shapes" , & shapes_list_in ) ) ; OpInputList dense_list_in ; OP_REQUIRES_OK ( context , context -> input_list ( "dense_inputs" , & dense_list_in ) ) ; OP_REQUIRES_OK ( context , ValidateInput ( indices_list_in , values_list_in , shapes_list_in , dense_list_in ) ) ; const Tensor * num_buckets_t ; OP_REQUIRES_OK ( context , context -> input ( "num_buckets" , & num_buckets_t ) ) ; const int64 num_buckets = num_buckets_t -> scalar < int64 > ( ) ( ) ; const Tensor * strong_hash_t ; OP_REQUIRES_OK ( context , context -> input ( "strong_hash" , & strong_hash_t ) ) ; const bool strong_hash = strong_hash_t -> scalar < bool > ( ) ( ) ; const Tensor * salt_t ; OP_REQUIRES_OK ( context , context -> input ( "salt" , & salt_t ) ) ; const auto salt = salt_t -> flat < int64 > ( ) ; std :: vector < int64 > key_ { salt ( 0 ) , salt ( 1 ) } ; std :: vector < std :: unique_ptr < ColumnInterface < int64 > > > columns = GenerateKeyedColumnsFromInput < int64 > ( indices_list_in , values_list_in , shapes_list_in , dense_list_in , key_ ) ; Tensor * indices_out ; Tensor * values_out ; Tensor * shape_out ; const int64 batch_size = CalculateBatchSize ( shapes_list_in , dense_list_in ) ; std :: vector < int64 > output_start_indices ( batch_size ) ; OP_REQUIRES_OK ( context , CreateOutputTensors ( columns , batch_size , context , & indices_out , & values_out , & shape_out , & output_start_indices ) ) ; const tstring unused_sep ; HashCrosserV2 crosser ( columns , num_buckets , 0 , unused_sep ) ; OutputUpdater < int64 > updater ( output_start_indices , indices_out , values_out ) ; auto do_work = [ & columns , crosser , updater , strong_hash ] ( int64 begin , int64 end ) { for ( int b = begin ; b < end ; b ++ ) { ProductIterator < int64 > product_iterator ( columns , b ) ; int64 cross_count = 0 ; while ( product_iterator . HasNext ( ) ) { const auto permutation = product_iterator . Next ( ) ; updater . Update ( b , cross_count , crosser . Generate ( b , permutation , strong_hash ) ) ; cross_count ++ ; } } } ; auto * worker_threads = context -> device ( ) -> tensorflow_cpu_worker_threads ( ) ; const int kCostPerUnit = 5000 * indices_list_in . size ( ) ; Shard ( worker_threads -> num_threads , worker_threads -> workers , batch_size , kCostPerUnit , do_work ) ; }
void * pvPortMalloc ( size_t xWantedSize ) { BlockLink_t * pxBlock , * pxPreviousBlock , * pxNewBlockLink ; static BaseType_t xHeapHasBeenInitialised = pdFALSE ; void * pvReturn = NULL ; vTaskSuspendAll ( ) ; { if ( xHeapHasBeenInitialised == pdFALSE ) { prvHeapInit ( ) ; xHeapHasBeenInitialised = pdTRUE ; } if ( xWantedSize > 0 ) { xWantedSize += heapSTRUCT_SIZE ; if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; } } if ( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) ) { pxPreviousBlock = & xStart ; pxBlock = xStart . pxNextFreeBlock ; while ( ( pxBlock -> xBlockSize < xWantedSize ) && ( pxBlock -> pxNextFreeBlock != NULL ) ) { pxPreviousBlock = pxBlock ; pxBlock = pxBlock -> pxNextFreeBlock ; } if ( pxBlock != & xEnd ) { pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock -> pxNextFreeBlock ) + heapSTRUCT_SIZE ) ; pxPreviousBlock -> pxNextFreeBlock = pxBlock -> pxNextFreeBlock ; if ( ( pxBlock -> xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ) ; pxNewBlockLink -> xBlockSize = pxBlock -> xBlockSize - xWantedSize ; pxBlock -> xBlockSize = xWantedSize ; prvInsertBlockIntoFreeList ( ( pxNewBlockLink ) ) ; } xFreeBytesRemaining -= pxBlock -> xBlockSize ; } } traceMALLOC ( pvReturn , xWantedSize ) ; } ( void ) xTaskResumeAll ( ) ; #if ( configUSE_MALLOC_FAILED_HOOK == 1 ) { if ( pvReturn == NULL ) { extern void vApplicationMallocFailedHook ( void ) ; vApplicationMallocFailedHook ( ) ; } } #endif return pvReturn ; }
% SetQuantumDepth ( ) sets the quantum depth . % % The format of the SetQuantumDepth method is : % % MagickBooleanType SetQuantumDepth ( const Image * image , % QuantumInfo * quantum_info , const size_t depth ) % % A description of each parameter follows : % % o image : the image . % % o quantum_info : the quantum info . % % o depth : the quantum depth . % * / MagickExport MagickBooleanType SetQuantumDepth ( const Image * image , QuantumInfo * quantum_info , const size_t depth ) { size_t extent , quantum ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image -> filename ) ; assert ( quantum_info != ( QuantumInfo * ) NULL ) ; assert ( quantum_info -> signature == MagickCoreSignature ) ; quantum_info -> depth = depth ; if ( quantum_info -> format == FloatingPointQuantumFormat ) {
BuildTestPacket ( uint16_t id , uint16_t off , int mf , const char content , int content_len ) { Packet * p = NULL ; int hlen = 20 ; int ttl = 64 ; uint8_t * pcontent ; IPV4Hdr ip4h ; p = SCCalloc ( 1 , sizeof ( * p ) + default_packet_size ) ; if ( unlikely ( p == NULL ) ) return NULL ; PACKET_INITIALIZE ( p ) ; gettimeofday ( & p -> ts , NULL ) ; ip4h . ip_verhl = 4 < < 4 ; ip4h . ip_verhl |= hlen > > 2 ; ip4h . ip_len = htons ( hlen + content_len ) ; ip4h . ip_id = htons ( id ) ; ip4h . ip_off = htons ( off ) ; if ( mf ) ip4h . ip_off = htons ( IP_MF | off ) ; else ip4h . ip_off = htons ( off ) ; ip4h . ip_ttl = ttl ; ip4h . ip_proto = IPPROTO_ICMP ; ip4h . s_ip_src . s_addr = 0x01010101 ; ip4h . s_ip_dst . s_addr = 0x02020202 ; PacketCopyData ( p , ( uint8_t * ) & ip4h , sizeof ( ip4h ) ) ; p -> ip4h = ( IPV4Hdr * ) GET_PKT_DATA ( p ) ; SET_IPV4_SRC_ADDR ( p , & p -> src ) ; SET_IPV4_DST_ADDR ( p , & p -> dst ) ; pcontent = SCCalloc ( 1 , content_len ) ; if ( unlikely ( pcontent == NULL ) ) return NULL ; memset ( pcontent , content , content_len ) ; PacketCopyDataOffset ( p , hlen , pcontent , content_len ) ; SET_PKT_LEN ( p , hlen + content_len ) ; SCFree ( pcontent ) ; p -> ip4h -> ip_csum = IPV4CalculateChecksum ( ( uint16_t * ) GET_PKT_DATA ( p ) , hlen ) ; if ( IPV4_GET_VER ( p ) != 4 ) goto error ; if ( IPV4_GET_HLEN ( p ) != hlen ) goto error ; if ( IPV4_GET_IPLEN ( p ) != hlen + content_len ) goto error ; if ( IPV4_GET_IPID ( p ) != id ) goto error ; if ( IPV4_GET_IPOFFSET ( p ) != off ) goto error ; if ( IPV4_GET_MF ( p ) != mf ) goto error ; if ( IPV4_GET_IPTTL ( p ) != ttl ) goto error ; if ( IPV4_GET_IPPROTO ( p ) != IPPROTO_ICMP ) goto error ; return p ; error : if ( p != NULL ) SCFree ( p ) ; return NULL ; }
static void llc_cmsg_rcv ( struct msghdr * msg , struct sk_buff * skb ) { struct llc_sock * llc = llc_sk ( skb -> sk ) ; if ( llc -> cmsg_flags & LLC_CMSG_PKTINFO ) { struct llc_pktinfo info ; info . lpi_ifindex = llc_sk ( skb -> sk ) -> dev -> ifindex ; llc_pdu_decode_dsap ( skb , & info . lpi_sap ) ; llc_pdu_decode_da ( skb , info . lpi_mac ) ; put_cmsg ( msg , SOL_LLC , LLC_OPT_PKTINFO , sizeof ( info ) , & info ) ; } }
MediaEngineGonkVideoSource :: Stop ( SourceMediaStream * aSource , TrackID aID ) { LOG ( ( __FUNCTION__ ) ) ; if ( ! mSources . RemoveElement ( aSource ) ) { return NS_OK ; } if ( ! mSources . IsEmpty ( ) ) { return NS_OK ; } ReentrantMonitorAutoEnter sync ( mCallbackMonitor ) ; if ( mState != kStarted ) { return NS_ERROR_FAILURE ; } { MonitorAutoLock lock ( mMonitor ) ; mState = kStopped ; aSource -> EndTrack ( aID ) ; mImage = nullptr ; } NS_DispatchToMainThread ( WrapRunnable ( nsRefPtr < MediaEngineGonkVideoSource > ( this ) , & MediaEngineGonkVideoSource :: StopImpl ) ) ; return NS_OK ; }
int smb2_allocate_rsp_buf ( struct ksmbd_work * work ) { struct smb2_hdr * hdr = smb2_get_msg ( work -> request_buf ) ; size_t small_sz = MAX_CIFS_SMALL_BUFFER_SIZE ; size_t large_sz = small_sz + work -> conn -> vals -> max_trans_size ; size_t sz = small_sz ; int cmd = le16_to_cpu ( hdr -> Command ) ; if ( cmd == SMB2_IOCTL_HE || cmd == SMB2_QUERY_DIRECTORY_HE ) sz = large_sz ; if ( cmd == SMB2_QUERY_INFO_HE ) { struct smb2_query_info_req * req ; req = smb2_get_msg ( work -> request_buf ) ; if ( req -> InfoType == SMB2_O_INFO_FILE && ( req -> FileInfoClass == FILE_FULL_EA_INFORMATION || req -> FileInfoClass == FILE_ALL_INFORMATION ) ) sz = large_sz ; } if ( le32_to_cpu ( hdr -> NextCommand ) > 0 ) sz = large_sz ; work -> response_buf = kvmalloc ( sz , GFP_KERNEL | __GFP_ZERO ) ; if ( ! work -> response_buf ) return - ENOMEM ; work -> response_sz = sz ; return 0 ; }
PJ_DEF ( pj_status_t ) pj_stun_msg_decode ( pj_pool_t * pool , const pj_uint8_t * pdu , pj_size_t pdu_len , unsigned options , pj_stun_msg * * p_msg , pj_size_t * p_parsed_len , pj_stun_msg * * p_response ) { pj_stun_msg * msg ; const pj_uint8_t * start_pdu = pdu ; pj_bool_t has_msg_int = PJ_FALSE ; pj_bool_t has_fingerprint = PJ_FALSE ; pj_status_t status ; PJ_UNUSED_ARG ( options ) ; PJ_ASSERT_RETURN ( pool && pdu && pdu_len && p_msg , PJ_EINVAL ) ; PJ_ASSERT_RETURN ( sizeof ( pj_stun_msg_hdr ) == 20 , PJ_EBUG ) ; if ( p_parsed_len ) * p_parsed_len = 0 ; if ( p_response ) * p_response = NULL ; if ( options & PJ_STUN_CHECK_PACKET ) { status = pj_stun_msg_check ( pdu , pdu_len , options ) ; if ( status != PJ_SUCCESS ) return status ; } msg = PJ_POOL_ZALLOC_T ( pool , pj_stun_msg ) ; pj_memcpy ( & msg -> hdr , pdu , sizeof ( pj_stun_msg_hdr ) ) ; msg -> hdr . type = pj_ntohs ( msg -> hdr . type ) ; msg -> hdr . length = pj_ntohs ( msg -> hdr . length ) ; msg -> hdr . magic = pj_ntohl ( msg -> hdr . magic ) ; pdu += sizeof ( pj_stun_msg_hdr ) ; pdu_len = msg -> hdr . length ; if ( ! PJ_STUN_IS_REQUEST ( msg -> hdr . type ) ) p_response = NULL ; while ( pdu_len >= 4 ) { unsigned attr_type , attr_val_len ; const struct attr_desc * adesc ; attr_type = GETVAL16H ( pdu , 0 ) ; attr_val_len = GETVAL16H ( pdu , 2 ) ; attr_val_len = ( attr_val_len + 3 ) & ( ~ 3 ) ; if ( pdu_len < attr_val_len ) { pj_str_t err_msg ; char err_msg_buf [ 80 ] ; err_msg . ptr = err_msg_buf ; err_msg . slen = pj_ansi_snprintf ( err_msg_buf , sizeof ( err_msg_buf ) , "Attribute %s has invalid length" , pj_stun_get_attr_name ( attr_type ) ) ; PJ_LOG ( 4 , ( THIS_FILE , "Error decoding message: %.*s" , ( int ) err_msg . slen , err_msg . ptr ) ) ; if ( p_response ) { pj_stun_msg_create_response ( pool , msg , PJ_STUN_SC_BAD_REQUEST , & err_msg , p_response ) ; } return PJNATH_ESTUNINATTRLEN ; } adesc = find_attr_desc ( attr_type ) ; if ( adesc == NULL ) { pj_stun_binary_attr * attr = NULL ; PJ_LOG ( 5 , ( THIS_FILE , "Unrecognized attribute type 0x%x" , attr_type ) ) ; if ( attr_type <= 0x7FFF ) { if ( p_response ) { unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE ; status = pj_stun_msg_create_response ( pool , msg , err_code , NULL , p_response ) ; if ( status == PJ_SUCCESS ) { pj_uint16_t d = ( pj_uint16_t ) attr_type ; pj_stun_msg_add_unknown_attr ( pool , * p_response , 1 , & d ) ; } } return PJ_STATUS_FROM_STUN_CODE ( PJ_STUN_SC_UNKNOWN_ATTRIBUTE ) ; } if ( msg -> attr_count >= PJ_STUN_MAX_ATTR ) { if ( p_response ) { pj_stun_msg_create_response ( pool , msg , PJ_STUN_SC_SERVER_ERROR , NULL , p_response ) ; } return PJNATH_ESTUNTOOMANYATTR ; } status = pj_stun_binary_attr_create ( pool , attr_type , pdu + 4 , GETVAL16H ( pdu , 2 ) , & attr ) ; if ( status != PJ_SUCCESS ) { if ( p_response ) { pj_stun_msg_create_response ( pool , msg , PJ_STUN_SC_SERVER_ERROR , NULL , p_response ) ; } PJ_LOG ( 4 , ( THIS_FILE , "Error parsing unknown STUN attribute type %d" , attr_type ) ) ; return status ; } msg -> attr [ msg -> attr_count ++ ] = & attr -> hdr ; } else { void * attr ; char err_msg1 [ PJ_ERR_MSG_SIZE ] , err_msg2 [ PJ_ERR_MSG_SIZE ] ; status = ( adesc -> decode_attr ) ( pool , pdu , & msg -> hdr , & attr ) ; if ( status != PJ_SUCCESS ) { pj_strerror ( status , err_msg1 , sizeof ( err_msg1 ) ) ; if ( p_response ) { pj_str_t e ; e . ptr = err_msg2 ; e . slen = pj_ansi_snprintf ( err_msg2 , sizeof ( err_msg2 ) , "%s in %s" , err_msg1 , pj_stun_get_attr_name ( attr_type ) ) ; if ( e . slen < 1 || e . slen >= ( int ) sizeof ( err_msg2 ) ) e . slen = sizeof ( err_msg2 ) - 1 ; pj_stun_msg_create_response ( pool , msg , PJ_STUN_SC_BAD_REQUEST , & e , p_response ) ; } PJ_LOG ( 4 , ( THIS_FILE , "Error parsing STUN attribute %s: %s" , pj_stun_get_attr_name ( attr_type ) , err_msg1 ) ) ; return status ; } if ( attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && ! has_fingerprint ) { if ( has_msg_int ) { if ( p_response ) { pj_stun_msg_create_response ( pool , msg , PJ_STUN_SC_BAD_REQUEST , NULL , p_response ) ; } return PJNATH_ESTUNDUPATTR ; } has_msg_int = PJ_TRUE ; } else if ( attr_type == PJ_STUN_ATTR_FINGERPRINT ) { if ( has_fingerprint ) { if ( p_response ) { pj_stun_msg_create_response ( pool , msg , PJ_STUN_SC_BAD_REQUEST , NULL , p_response ) ; } return PJNATH_ESTUNDUPATTR ; } has_fingerprint = PJ_TRUE ; } else { if ( has_fingerprint ) { if ( p_response ) { pj_stun_msg_create_response ( pool , msg , PJ_STUN_SC_BAD_REQUEST , NULL , p_response ) ; } return PJNATH_ESTUNFINGERPOS ; } } if ( msg -> attr_count >= PJ_STUN_MAX_ATTR ) { if ( p_response ) { pj_stun_msg_create_response ( pool , msg , PJ_STUN_SC_SERVER_ERROR , NULL , p_response ) ; } return PJNATH_ESTUNTOOMANYATTR ; } msg -> attr [ msg -> attr_count ++ ] = ( pj_stun_attr_hdr * ) attr ; } if ( attr_val_len + 4 >= pdu_len ) { pdu += pdu_len ; pdu_len = 0 ; } else { pdu += ( attr_val_len + 4 ) ; pdu_len -= ( attr_val_len + 4 ) ; } } if ( pdu_len > 0 ) { PJ_LOG ( 4 , ( THIS_FILE , "Error decoding STUN message: unparsed trailing %d bytes" , pdu_len ) ) ; return PJNATH_EINSTUNMSGLEN ; } * p_msg = msg ; if ( p_parsed_len ) * p_parsed_len = ( pdu - start_pdu ) ; return PJ_SUCCESS ; }
void nfc_ncif_proc_ee_discover_req ( uint8_t * p , uint16_t plen ) { tNFC_RESPONSE_CBACK * p_cback = nfc_cb . p_resp_cback ; tNFC_EE_DISCOVER_REQ_REVT ee_disc_req ; tNFC_EE_DISCOVER_INFO * p_info ; uint8_t u8 ; DLOG_IF ( INFO , nfc_debug_enabled ) < < StringPrintf ( "nfc_ncif_proc_ee_discover_req %d len:%d" , * p , plen ) ; if ( * p > NFC_MAX_EE_DISC_ENTRIES ) { android_errorWriteLog ( 0x534e4554 , "122361874" ) ; LOG ( ERROR ) < < __func__ < < "Exceed NFC_MAX_EE_DISC_ENTRIES" ; return ; } if ( p_cback ) { u8 = * p ; ee_disc_req . status = NFC_STATUS_OK ; ee_disc_req . num_info = * p ++ ; p_info = ee_disc_req . info ; if ( plen ) plen -- ; while ( ( u8 > 0 ) && ( plen >= NFC_EE_DISCOVER_ENTRY_LEN ) ) { p_info -> op = * p ++ ; if ( * p != NFC_EE_DISCOVER_INFO_LEN ) { DLOG_IF ( INFO , nfc_debug_enabled ) < < StringPrintf ( "bad entry len:%d" , * p ) ; return ; } p ++ ; p_info -> nfcee_id = * p ++ ; p_info -> tech_n_mode = * p ++ ; p_info -> protocol = * p ++ ; u8 -- ; plen -= NFC_EE_DISCOVER_ENTRY_LEN ; p_info ++ ; } tNFC_RESPONSE nfc_response ; nfc_response . ee_discover_req = ee_disc_req ; ( * p_cback ) ( NFC_EE_DISCOVER_REQ_REVT , & nfc_response ) ; } }
void NuPlayer :: GenericSource :: notifyPreparedAndCleanup ( status_t err ) { if ( err != OK ) { mMetaDataSize = - 1ll ; mContentType = "" ; mSniffedMIME = "" ; { sp < DataSource > dataSource = mDataSource ; sp < NuCachedSource2 > cachedSource = mCachedSource ; sp < DataSource > httpSource = mHttpSource ; { Mutex :: Autolock _l ( mDisconnectLock ) ; mDataSource . clear ( ) ; mCachedSource . clear ( ) ; mHttpSource . clear ( ) ; } } cancelPollBuffering ( ) ; } notifyPrepared ( err ) ; }
const BytecodeLivenessState * BytecodeAnalysis :: GetInLivenessFor ( int offset ) const { if ( ! do_liveness_analysis_ ) return nullptr ; return liveness_map_ . GetInLiveness ( offset ) ; }
static int fuse_notify_inval_entry ( struct fuse_conn * fc , unsigned int size , struct fuse_copy_state * cs ) { struct fuse_notify_inval_entry_out outarg ; int err = - ENOMEM ; char * buf ; struct qstr name ; buf = kzalloc ( FUSE_NAME_MAX + 1 , GFP_KERNEL ) ; if ( ! buf ) goto err ; err = - EINVAL ; if ( size < sizeof ( outarg ) ) goto err ; err = fuse_copy_one ( cs , & outarg , sizeof ( outarg ) ) ; if ( err ) goto err ; err = - ENAMETOOLONG ; if ( outarg . namelen > FUSE_NAME_MAX ) goto err ; name . name = buf ; name . len = outarg . namelen ; err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ; if ( err ) goto err ; fuse_copy_finish ( cs ) ; buf [ outarg . namelen ] = 0 ; name . hash = full_name_hash ( name . name , name . len ) ; down_read ( & fc -> killsb ) ; err = - ENOENT ; if ( fc -> sb ) err = fuse_reverse_inval_entry ( fc -> sb , outarg . parent , & name ) ; up_read ( & fc -> killsb ) ; kfree ( buf ) ; return err ; err : kfree ( buf ) ; fuse_copy_finish ( cs ) ; return err ; }
int fmt_mtm_load_song ( song_t * song , slurp_t * fp , unsigned int lflags ) { uint8_t b [ 192 ] ; uint8_t nchan , nord , npat , nsmp ; uint16_t ntrk , comment_len ; int n , pat , chan , smp , rows , todo = 0 ; song_note_t * note ; uint16_t tmp ; uint32_t tmplong ; song_note_t * * trackdata , * tracknote ; song_sample_t * sample ; slurp_read ( fp , b , 3 ) ; if ( memcmp ( b , "MTM" , 3 ) != 0 ) return LOAD_UNSUPPORTED ; n = slurp_getc ( fp ) ; sprintf ( song -> tracker_id , "MultiTracker %d.%d" , n > > 4 , n & 0xf ) ; slurp_read ( fp , song -> title , 20 ) ; song -> title [ 20 ] = 0 ; slurp_read ( fp , & ntrk , 2 ) ; ntrk = bswapLE16 ( ntrk ) ; npat = slurp_getc ( fp ) ; nord = slurp_getc ( fp ) + 1 ; slurp_read ( fp , & comment_len , 2 ) ; comment_len = bswapLE16 ( comment_len ) ; nsmp = slurp_getc ( fp ) ; slurp_getc ( fp ) ; rows = slurp_getc ( fp ) ; if ( rows != 64 ) todo |= 64 ; rows = MIN ( rows , 64 ) ; nchan = slurp_getc ( fp ) ; if ( slurp_eof ( fp ) ) { return LOAD_FORMAT_ERROR ; } for ( n = 0 ; n < 32 ; n ++ ) { int pan = slurp_getc ( fp ) & 0xf ; pan = SHORT_PANNING ( pan ) ; pan *= 4 ; song -> channels [ n ] . panning = pan ; } for ( n = nchan ; n < MAX_CHANNELS ; n ++ ) song -> channels [ n ] . flags = CHN_MUTE ; if ( nsmp > MAX_SAMPLES ) { log_appendf ( 4 , " Warning: Too many samples" ) ; } for ( n = 1 , sample = song -> samples + 1 ; n <= nsmp ; n ++ , sample ++ ) { if ( n > MAX_SAMPLES ) { slurp_seek ( fp , 37 , SEEK_CUR ) ; continue ; } char name [ 23 ] ; slurp_read ( fp , name , 22 ) ; name [ 22 ] = '\0' ; strcpy ( sample -> name , name ) ; slurp_read ( fp , & tmplong , 4 ) ; sample -> length = bswapLE32 ( tmplong ) ; slurp_read ( fp , & tmplong , 4 ) ; sample -> loop_start = bswapLE32 ( tmplong ) ; slurp_read ( fp , & tmplong , 4 ) ; sample -> loop_end = bswapLE32 ( tmplong ) ; if ( ( sample -> loop_end - sample -> loop_start ) > 2 ) { sample -> flags |= CHN_LOOP ; } else { sample -> loop_start = 0 ; sample -> loop_end = 0 ; } song -> samples [ n ] . c5speed = MOD_FINETUNE ( slurp_getc ( fp ) ) ; sample -> volume = slurp_getc ( fp ) ; sample -> volume *= 4 ; sample -> global_volume = 64 ; if ( slurp_getc ( fp ) & 1 ) { todo |= 16 ; sample -> flags |= CHN_16BIT ; sample -> length >>= 1 ; sample -> loop_start >>= 1 ; sample -> loop_end >>= 1 ; } song -> samples [ n ] . vib_type = 0 ; song -> samples [ n ] . vib_rate = 0 ; song -> samples [ n ] . vib_depth = 0 ; song -> samples [ n ] . vib_speed = 0 ; } slurp_read ( fp , song -> orderlist , 128 ) ; memset ( song -> orderlist + nord , ORDER_LAST , MAX_ORDERS - nord ) ; trackdata = mem_calloc ( ntrk , sizeof ( song_note_t * ) ) ; for ( n = 0 ; n < ntrk ; n ++ ) { slurp_read ( fp , b , 3 * rows ) ; trackdata [ n ] = mem_calloc ( rows , sizeof ( song_note_t ) ) ; mtm_unpack_track ( b , trackdata [ n ] , rows ) ; } if ( npat >= MAX_PATTERNS ) { log_appendf ( 4 , " Warning: Too many patterns" ) ; } for ( pat = 0 ; pat <= npat ; pat ++ ) { if ( pat >= MAX_PATTERNS ) { slurp_seek ( fp , 64 , SEEK_CUR ) ; continue ; } song -> patterns [ pat ] = csf_allocate_pattern ( MAX ( rows , 32 ) ) ; song -> pattern_size [ pat ] = song -> pattern_alloc_size [ pat ] = 64 ; tracknote = trackdata [ n ] ; for ( chan = 0 ; chan < 32 ; chan ++ ) { slurp_read ( fp , & tmp , 2 ) ; tmp = bswapLE16 ( tmp ) ; if ( tmp == 0 ) { continue ; } else if ( tmp > ntrk ) { for ( n = 0 ; n < ntrk ; n ++ ) free ( trackdata [ n ] ) ; free ( trackdata ) ; return LOAD_FORMAT_ERROR ; } note = song -> patterns [ pat ] + chan ; tracknote = trackdata [ tmp - 1 ] ; for ( n = 0 ; n < rows ; n ++ , tracknote ++ , note += MAX_CHANNELS ) * note = * tracknote ; } if ( rows < 32 ) { note = song -> patterns [ pat ] + 64 * ( rows - 1 ) ; while ( note -> effect || note -> param ) note ++ ; note -> effect = FX_PATTERNBREAK ; } } for ( n = 0 ; n < ntrk ; n ++ ) free ( trackdata [ n ] ) ; free ( trackdata ) ; read_lined_message ( song -> message , fp , comment_len , 40 ) ; if ( ! ( lflags & LOAD_NOSAMPLES ) ) { for ( smp = 1 ; smp <= nsmp && smp <= MAX_SAMPLES ; smp ++ ) { uint32_t ssize ; if ( song -> samples [ smp ] . length == 0 ) continue ; ssize = csf_read_sample ( song -> samples + smp , ( SF_LE | SF_PCMU | SF_M | ( ( song -> samples [ smp ] . flags & CHN_16BIT ) ? SF_16 : SF_8 ) ) , fp -> data + fp -> pos , fp -> length - fp -> pos ) ; slurp_seek ( fp , ssize , SEEK_CUR ) ; } } song -> flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX ; if ( todo & 64 ) log_appendf ( 2 , " TODO: test this file with other players (beats per track != 64)" ) ; if ( todo & 16 ) log_appendf ( 2 , " TODO: double check 16 bit sample loading" ) ; return LOAD_SUCCESS ; }
double log ( double x ) { static const double ln2_hi = 6.93147180369123816490e-01 , ln2_lo = 1.90821492927058770002e-10 , two54 = 1.80143985094819840000e+16 , Lg1 = 6.666666666666735130e-01 , Lg2 = 3.999999999940941908e-01 , Lg3 = 2.857142874366239149e-01 , Lg4 = 2.222219843214978396e-01 , Lg5 = 1.818357216161805012e-01 , Lg6 = 1.531383769920937332e-01 , Lg7 = 1.479819860511658591e-01 ; static const double zero = 0.0 ; static volatile double vzero = 0.0 ; double hfsq , f , s , z , R , w , t1 , t2 , dk ; int32_t k , hx , i , j ; uint32_t lx ; EXTRACT_WORDS ( hx , lx , x ) ; k = 0 ; if ( hx < 0x00100000 ) { if ( ( ( hx & 0x7FFFFFFF ) | lx ) == 0 ) return - two54 / vzero ; if ( hx < 0 ) return ( x - x ) / zero ; k -= 54 ; x *= two54 ; GET_HIGH_WORD ( hx , x ) ; } if ( hx >= 0x7FF00000 ) return x + x ; k += ( hx > > 20 ) - 1023 ; hx &= 0x000FFFFF ; i = ( hx + 0x95F64 ) & 0x100000 ; SET_HIGH_WORD ( x , hx | ( i ^ 0x3FF00000 ) ) ; k += ( i > > 20 ) ; f = x - 1.0 ; if ( ( 0x000FFFFF & ( 2 + hx ) ) < 3 ) { if ( f == zero ) { if ( k == 0 ) { return zero ; } else { dk = static_cast < double > ( k ) ; return dk * ln2_hi + dk * ln2_lo ; } } R = f * f * ( 0.5 - 0.33333333333333333 * f ) ; if ( k == 0 ) { return f - R ; } else { dk = static_cast < double > ( k ) ; return dk * ln2_hi - ( ( R - dk * ln2_lo ) - f ) ; } } s = f / ( 2.0 + f ) ; dk = static_cast < double > ( k ) ; z = s * s ; i = hx - 0x6147A ; w = z * z ; j = 0x6B851 - hx ; t1 = w * ( Lg2 + w * ( Lg4 + w * Lg6 ) ) ; t2 = z * ( Lg1 + w * ( Lg3 + w * ( Lg5 + w * Lg7 ) ) ) ; i |= j ; R = t2 + t1 ; if ( i > 0 ) { hfsq = 0.5 * f * f ; if ( k == 0 ) return f - ( hfsq - s * ( hfsq + R ) ) ; else return dk * ln2_hi - ( ( hfsq - ( s * ( hfsq + R ) + dk * ln2_lo ) ) - f ) ; } else { if ( k == 0 ) return f - s * ( f - R ) ; else return dk * ln2_hi - ( ( s * ( f - R ) - dk * ln2_lo ) - f ) ; } }
js :: ReportOutOfMemory ( ExclusiveContext * cxArg ) { #ifdef JS_MORE_DETERMINISTIC fprintf ( stderr , "ReportOutOfMemory called\n" ) ; #endif if ( ! cxArg -> isJSContext ( ) ) return cxArg -> addPendingOutOfMemory ( ) ; JSContext * cx = cxArg -> asJSContext ( ) ; cx -> runtime ( ) -> hadOutOfMemory = true ; if ( JS :: OutOfMemoryCallback oomCallback = cx -> runtime ( ) -> oomCallback ) { AutoSuppressGC suppressGC ( cx ) ; oomCallback ( cx , cx -> runtime ( ) -> oomCallbackData ) ; } if ( cx -> options ( ) . autoJSAPIOwnsErrorReporting ( ) || JS_IsRunning ( cx ) ) { cx -> setPendingException ( StringValue ( cx -> names ( ) . outOfMemory ) ) ; return ; } const JSErrorFormatString * efs = GetErrorMessage ( nullptr , JSMSG_OUT_OF_MEMORY ) ; const char * msg = efs ? efs -> format : "Out of memory" ; JSErrorReport report ; report . flags = JSREPORT_ERROR ; report . errorNumber = JSMSG_OUT_OF_MEMORY ; PopulateReportBlame ( cx , & report ) ; if ( JSErrorReporter onError = cx -> runtime ( ) -> errorReporter ) { AutoSuppressGC suppressGC ( cx ) ; onError ( cx , msg , & report ) ; } MOZ_ASSERT ( ! cx -> isExceptionPending ( ) ) ; }
bool HeifDecoderImpl :: reinit ( HeifFrameInfo * frameInfo ) { mFrameDecoded = false ; mFrameMemory . clear ( ) ; mRetriever = new MediaMetadataRetriever ( ) ; status_t err = mRetriever -> setDataSource ( mDataSource , "image/heif" ) ; if ( err != OK ) { ALOGE ( "failed to set data source!" ) ; mRetriever . clear ( ) ; mDataSource . clear ( ) ; return false ; } ALOGV ( "successfully set data source." ) ; const char * hasImage = mRetriever -> extractMetadata ( METADATA_KEY_HAS_IMAGE ) ; const char * hasVideo = mRetriever -> extractMetadata ( METADATA_KEY_HAS_VIDEO ) ; mHasImage = hasImage && ! strcasecmp ( hasImage , "yes" ) ; mHasVideo = hasVideo && ! strcasecmp ( hasVideo , "yes" ) ; HeifFrameInfo * defaultInfo = nullptr ; if ( mHasImage ) { sp < IMemory > sharedMem = mRetriever -> getImageAtIndex ( - 1 , mOutputColor , true ) ; if ( sharedMem == nullptr || sharedMem -> unsecurePointer ( ) == nullptr ) { ALOGE ( "init: videoFrame is a nullptr" ) ; return false ; } VideoFrame * videoFrame = static_cast < VideoFrame * > ( sharedMem -> unsecurePointer ( ) ) ; ALOGV ( "Image dimension %dx%d, display %dx%d, angle %d, iccSize %d" , videoFrame -> mWidth , videoFrame -> mHeight , videoFrame -> mDisplayWidth , videoFrame -> mDisplayHeight , videoFrame -> mRotationAngle , videoFrame -> mIccSize ) ; initFrameInfo ( & mImageInfo , videoFrame ) ; if ( videoFrame -> mTileHeight >= 512 ) { mSliceHeight = videoFrame -> mTileHeight ; ALOGV ( "mSliceHeight %u" , mSliceHeight ) ; } defaultInfo = & mImageInfo ; } if ( mHasVideo ) { sp < IMemory > sharedMem = mRetriever -> getFrameAtTime ( 0 , MediaSource :: ReadOptions :: SEEK_PREVIOUS_SYNC , mOutputColor , true ) ; if ( sharedMem == nullptr || sharedMem -> unsecurePointer ( ) == nullptr ) { ALOGE ( "init: videoFrame is a nullptr" ) ; return false ; } VideoFrame * videoFrame = static_cast < VideoFrame * > ( sharedMem -> unsecurePointer ( ) ) ; ALOGV ( "Sequence dimension %dx%d, display %dx%d, angle %d, iccSize %d" , videoFrame -> mWidth , videoFrame -> mHeight , videoFrame -> mDisplayWidth , videoFrame -> mDisplayHeight , videoFrame -> mRotationAngle , videoFrame -> mIccSize ) ; initFrameInfo ( & mSequenceInfo , videoFrame ) ; mSequenceLength = atoi ( mRetriever -> extractMetadata ( METADATA_KEY_VIDEO_FRAME_COUNT ) ) ; if ( defaultInfo == nullptr ) { defaultInfo = & mSequenceInfo ; } } if ( defaultInfo == nullptr ) { ALOGD ( "No valid image or sequence available" ) ; return false ; } if ( frameInfo != nullptr ) { * frameInfo = * defaultInfo ; } mTotalScanline = defaultInfo -> mHeight ; return true ; }
UnobservablesSet RedundantStoreFinder :: RecomputeSet ( Node * node , UnobservablesSet uses ) { switch ( node -> op ( ) -> opcode ( ) ) { case IrOpcode :: kStoreField : { Node * stored_to = node -> InputAt ( 0 ) ; const FieldAccess & access = FieldAccessOf ( node -> op ( ) ) ; StoreOffset offset = ToOffset ( access ) ; UnobservableStore observation = { stored_to -> id ( ) , offset } ; bool isNotObservable = uses . Contains ( observation ) ; if ( isNotObservable && AtMostTagged ( access ) ) { TRACE ( "  #%d is StoreField[+%d,%s](#%d), unobservable" , node -> id ( ) , offset , MachineReprToString ( access . machine_type . representation ( ) ) , stored_to -> id ( ) ) ; to_remove ( ) . insert ( node ) ; return uses ; } else if ( isNotObservable && ! AtMostTagged ( access ) ) { TRACE ( "  #%d is StoreField[+%d,%s](#%d), repeated in future but too " "big to optimize away" , node -> id ( ) , offset , MachineReprToString ( access . machine_type . representation ( ) ) , stored_to -> id ( ) ) ; return uses ; } else if ( ! isNotObservable && AtLeastTagged ( access ) ) { TRACE ( "  #%d is StoreField[+%d,%s](#%d), observable, recording in set" , node -> id ( ) , offset , MachineReprToString ( access . machine_type . representation ( ) ) , stored_to -> id ( ) ) ; return uses . Add ( observation , temp_zone ( ) ) ; } else if ( ! isNotObservable && ! AtLeastTagged ( access ) ) { TRACE ( "  #%d is StoreField[+%d,%s](#%d), observable but too small to " "record" , node -> id ( ) , offset , MachineReprToString ( access . machine_type . representation ( ) ) , stored_to -> id ( ) ) ; return uses ; } else { UNREACHABLE ( ) ; } break ; } case IrOpcode :: kLoadField : { Node * loaded_from = node -> InputAt ( 0 ) ; const FieldAccess & access = FieldAccessOf ( node -> op ( ) ) ; StoreOffset offset = ToOffset ( access ) ; TRACE ( "  #%d is LoadField[+%d,%s](#%d), removing all offsets [+%d] from " "set" , node -> id ( ) , offset , MachineReprToString ( access . machine_type . representation ( ) ) , loaded_from -> id ( ) , offset ) ; return uses . RemoveSameOffset ( offset , temp_zone ( ) ) ; break ; } default : if ( CannotObserveStoreField ( node ) ) { TRACE ( "  #%d:%s can observe nothing, set stays unchanged" , node -> id ( ) , node -> op ( ) -> mnemonic ( ) ) ; return uses ; } else { TRACE ( "  #%d:%s might observe anything, recording empty set" , node -> id ( ) , node -> op ( ) -> mnemonic ( ) ) ; return unobservables_visited_empty_ ; } } UNREACHABLE ( ) ; }
fiber_switch ( mrb_state * mrb , mrb_value self , mrb_int len , const mrb_value * a , mrb_bool resume , mrb_bool vmexec ) { struct mrb_context * c = fiber_check ( mrb , self ) ; struct mrb_context * old_c = mrb -> c ; enum mrb_fiber_state status ; mrb_value value ; fiber_check_cfunc ( mrb , c ) ; status = c -> status ; switch ( status ) { case MRB_FIBER_TRANSFERRED : if ( resume ) { mrb_raise ( mrb , E_FIBER_ERROR , "resuming transferred fiber" ) ; } break ; case MRB_FIBER_RUNNING : case MRB_FIBER_RESUMED : mrb_raise ( mrb , E_FIBER_ERROR , "double resume" ) ; break ; case MRB_FIBER_TERMINATED : mrb_raise ( mrb , E_FIBER_ERROR , "resuming dead fiber" ) ; break ; default : break ; } old_c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ; fiber_switch_context ( mrb , c ) ; if ( status == MRB_FIBER_CREATED ) { mrb_value * b , * e ; if ( ! c -> ci -> proc ) { mrb_raise ( mrb , E_FIBER_ERROR , "double resume (current)" ) ; } mrb_stack_extend ( mrb , len + 2 ) ; b = c -> stbase + 1 ; e = b + len ; while ( b < e ) { * b ++ = * a ++ ; } if ( vmexec ) { c -> ci -- ; } c -> cibase -> n = len ; value = c -> stbase [ 0 ] = MRB_PROC_ENV ( c -> cibase -> proc ) -> stack [ 0 ] ; } else { value = fiber_result ( mrb , a , len ) ; if ( vmexec ) { c -> ci [ 1 ] . stack [ 0 ] = value ; } } if ( vmexec ) { c -> vmexec = TRUE ; value = mrb_vm_exec ( mrb , c -> ci -> proc , c -> ci -> pc ) ; mrb -> c = old_c ; } else { MARK_CONTEXT_MODIFY ( c ) ; } return value ; }
IGNITION_HANDLER ( SwitchOnGeneratorState , InterpreterAssembler ) { Node * generator = LoadRegisterAtOperandIndex ( 0 ) ; Label fallthrough ( this ) ; GotoIf ( WordEqual ( generator , UndefinedConstant ( ) ) , & fallthrough ) ; Node * state = LoadObjectField ( generator , JSGeneratorObject :: kContinuationOffset ) ; Node * new_state = SmiConstant ( JSGeneratorObject :: kGeneratorExecuting ) ; StoreObjectField ( generator , JSGeneratorObject :: kContinuationOffset , new_state ) ; Node * context = LoadObjectField ( generator , JSGeneratorObject :: kContextOffset ) ; SetContext ( context ) ; Node * table_start = BytecodeOperandIdx ( 1 ) ; Node * table_length = BytecodeOperandUImmWord ( 2 ) ; CSA_ASSERT ( this , TaggedIsSmi ( state ) ) ; Node * case_value = SmiUntag ( state ) ; CSA_ASSERT ( this , IntPtrGreaterThanOrEqual ( case_value , IntPtrConstant ( 0 ) ) ) ; CSA_ASSERT ( this , IntPtrLessThan ( case_value , table_length ) ) ; USE ( table_length ) ; Node * entry = IntPtrAdd ( table_start , case_value ) ; Node * relative_jump = LoadAndUntagConstantPoolEntry ( entry ) ; Jump ( relative_jump ) ; BIND ( & fallthrough ) ; Dispatch ( ) ; }
void layer_state_t :: merge ( const layer_state_t & other ) { if ( other . what & ePositionChanged ) { what |= ePositionChanged ; x = other . x ; y = other . y ; } if ( other . what & eLayerChanged ) { what |= eLayerChanged ; what &= ~ eRelativeLayerChanged ; z = other . z ; } if ( other . what & eSizeChanged ) { what |= eSizeChanged ; w = other . w ; h = other . h ; } if ( other . what & eAlphaChanged ) { what |= eAlphaChanged ; alpha = other . alpha ; } if ( other . what & eMatrixChanged ) { what |= eMatrixChanged ; matrix = other . matrix ; } if ( other . what & eTransparentRegionChanged ) { what |= eTransparentRegionChanged ; transparentRegion = other . transparentRegion ; } if ( other . what & eFlagsChanged ) { what |= eFlagsChanged ; flags &= ~ other . mask ; flags |= ( other . flags & other . mask ) ; mask |= other . mask ; } if ( other . what & eLayerStackChanged ) { what |= eLayerStackChanged ; layerStack = other . layerStack ; } if ( other . what & eCornerRadiusChanged ) { what |= eCornerRadiusChanged ; cornerRadius = other . cornerRadius ; } if ( other . what & eBackgroundBlurRadiusChanged ) { what |= eBackgroundBlurRadiusChanged ; backgroundBlurRadius = other . backgroundBlurRadius ; } if ( other . what & eBlurRegionsChanged ) { what |= eBlurRegionsChanged ; blurRegions = other . blurRegions ; } if ( other . what & eRelativeLayerChanged ) { what |= eRelativeLayerChanged ; what &= ~ eLayerChanged ; z = other . z ; relativeLayerSurfaceControl = other . relativeLayerSurfaceControl ; } if ( other . what & eReparent ) { what |= eReparent ; parentSurfaceControlForChild = other . parentSurfaceControlForChild ; } if ( other . what & eDestroySurface ) { what |= eDestroySurface ; } if ( other . what & eTransformChanged ) { what |= eTransformChanged ; transform = other . transform ; } if ( other . what & eTransformToDisplayInverseChanged ) { what |= eTransformToDisplayInverseChanged ; transformToDisplayInverse = other . transformToDisplayInverse ; } if ( other . what & eCropChanged ) { what |= eCropChanged ; crop = other . crop ; } if ( other . what & eBufferChanged ) { what |= eBufferChanged ; buffer = other . buffer ; } if ( other . what & eAcquireFenceChanged ) { what |= eAcquireFenceChanged ; acquireFence = other . acquireFence ; } if ( other . what & eDataspaceChanged ) { what |= eDataspaceChanged ; dataspace = other . dataspace ; } if ( other . what & eHdrMetadataChanged ) { what |= eHdrMetadataChanged ; hdrMetadata = other . hdrMetadata ; } if ( other . what & eSurfaceDamageRegionChanged ) { what |= eSurfaceDamageRegionChanged ; surfaceDamageRegion = other . surfaceDamageRegion ; } if ( other . what & eApiChanged ) { what |= eApiChanged ; api = other . api ; } if ( other . what & eSidebandStreamChanged ) { what |= eSidebandStreamChanged ; sidebandStream = other . sidebandStream ; } if ( other . what & eColorTransformChanged ) { what |= eColorTransformChanged ; colorTransform = other . colorTransform ; } if ( other . what & eHasListenerCallbacksChanged ) { what |= eHasListenerCallbacksChanged ; } #ifndef NO_INPUT if ( other . what & eInputInfoChanged ) { what |= eInputInfoChanged ; inputHandle = new InputWindowHandle ( * other . inputHandle ) ; } #endif if ( other . what & eCachedBufferChanged ) { what |= eCachedBufferChanged ; cachedBuffer = other . cachedBuffer ; } if ( other . what & eBackgroundColorChanged ) { what |= eBackgroundColorChanged ; color = other . color ; bgColorAlpha = other . bgColorAlpha ; bgColorDataspace = other . bgColorDataspace ; } if ( other . what & eMetadataChanged ) { what |= eMetadataChanged ; metadata . merge ( other . metadata ) ; } if ( other . what & eShadowRadiusChanged ) { what |= eShadowRadiusChanged ; shadowRadius = other . shadowRadius ; } if ( other . what & eFrameRateSelectionPriority ) { what |= eFrameRateSelectionPriority ; frameRateSelectionPriority = other . frameRateSelectionPriority ; } if ( other . what & eFrameRateChanged ) { what |= eFrameRateChanged ; frameRate = other . frameRate ; frameRateCompatibility = other . frameRateCompatibility ; changeFrameRateStrategy = other . changeFrameRateStrategy ; } if ( other . what & eFixedTransformHintChanged ) { what |= eFixedTransformHintChanged ; fixedTransformHint = other . fixedTransformHint ; } if ( other . what & eFrameNumberChanged ) { what |= eFrameNumberChanged ; frameNumber = other . frameNumber ; } if ( other . what & eAutoRefreshChanged ) { what |= eAutoRefreshChanged ; autoRefresh = other . autoRefresh ; } if ( other . what & eTrustedOverlayChanged ) { what |= eTrustedOverlayChanged ; isTrustedOverlay = other . isTrustedOverlay ; } if ( other . what & eReleaseBufferListenerChanged ) { if ( releaseBufferListener ) { ALOGW ( "Overriding releaseBufferListener" ) ; } what |= eReleaseBufferListenerChanged ; releaseBufferListener = other . releaseBufferListener ; } if ( other . what & eStretchChanged ) { what |= eStretchChanged ; stretchEffect = other . stretchEffect ; } if ( other . what & eBufferCropChanged ) { what |= eBufferCropChanged ; bufferCrop = other . bufferCrop ; } if ( other . what & eDestinationFrameChanged ) { what |= eDestinationFrameChanged ; destinationFrame = other . destinationFrame ; } if ( ( other . what & what ) != other . what ) { ALOGE ( "Unmerged SurfaceComposer Transaction properties. LayerState::merge needs updating? " "other.what=0x%" PRIu64 " what=0x%" PRIu64 , other . what , what ) ; } }
void vp8_plane_add_noise_c ( unsigned char * Start , char * noise , char blackclamp [ 16 ] , char whiteclamp [ 16 ] , char bothclamp [ 16 ] , unsigned int Width , unsigned int Height , int Pitch ) { unsigned int i , j ; for ( i = 0 ; i < Height ; i ++ ) { unsigned char * Pos = Start + i * Pitch ; char * Ref = ( char * ) ( noise + ( rand ( ) & 0xff ) ) ; for ( j = 0 ; j < Width ; j ++ ) { if ( Pos [ j ] < blackclamp [ 0 ] ) Pos [ j ] = blackclamp [ 0 ] ; if ( Pos [ j ] > 255 + whiteclamp [ 0 ] ) Pos [ j ] = 255 + whiteclamp [ 0 ] ; Pos [ j ] += Ref [ j ] ; } } }
static void setup_pass ( struct stream_state * stream , struct VpxEncoderConfig * global , int pass ) { if ( stream -> config . stats_fn ) { if ( ! stats_open_file ( & stream -> stats , stream -> config . stats_fn , pass ) ) fatal ( "Failed to open statistics store" ) ; } else { if ( ! stats_open_mem ( & stream -> stats , pass ) ) fatal ( "Failed to open statistics store" ) ; } stream -> config . cfg . g_pass = global -> passes == 2 ? pass ? VPX_RC_LAST_PASS : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ; if ( pass ) stream -> config . cfg . rc_twopass_stats_in = stats_get ( & stream -> stats ) ; stream -> cx_time = 0 ; stream -> nbytes = 0 ; stream -> frames_out = 0 ; }
main ( int argc , char * argv [ ] ) { char buf [ BUFSIZ ] ; XML_Parser parser = XML_ParserCreate ( NULL ) ; int done ; int depth = 0 ; XML_SetUserData ( parser , & depth ) ; XML_SetElementHandler ( parser , startElement , endElement ) ; do { int len = ( int ) fread ( buf , 1 , sizeof ( buf ) , stdin ) ; done = len < sizeof ( buf ) ; if ( XML_Parse ( parser , buf , len , done ) == XML_STATUS_ERROR ) { fprintf ( stderr , "%s at line %" XML_FMT_INT_MOD "u\n" , XML_ErrorString ( XML_GetErrorCode ( parser ) ) , XML_GetCurrentLineNumber ( parser ) ) ; return 1 ; } } while ( ! done ) ; XML_ParserFree ( parser ) ; return 0 ; }
static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , struct bpf_reg_state * dst_reg , bool off_is_neg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_insn_aux_data * aux = cur_aux ( env ) ; bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) return 0 ; if ( vstate -> speculative ) goto do_sim ; alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ; if ( aux -> alu_state && ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) ) return - EACCES ; aux -> alu_state = alu_state ; aux -> alu_limit = alu_limit ; do_sim : if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg ) * dst_reg = tmp ; return ! ret ? - EFAULT : 0 ; }
% * / static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char geometry [ MaxTextExtent ] , * property ; const char * label ; DrawInfo * draw_info ; Image * image ; MagickBooleanType status ; TypeMetric metrics ; size_t height , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; ( void ) ResetImagePage ( image , "0x0+0+0" ) ; property = InterpretImageProperties ( image_info , image , image_info -> filename ) ; ( void ) SetImageProperty ( image , "label" , property ) ; property = DestroyString ( property ) ; label = GetImageProperty ( image , "label" ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; draw_info -> text = ConstantString ( label ) ; metrics . width = 0 ; metrics . ascent = 0.0 ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ; image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; } else if ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%+g%+g" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%+g%+g" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ; } status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( image -> columns == 0 ) image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ; if ( image -> columns == 0 ) image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; if ( image -> rows == 0 ) image -> rows = ( size_t ) ( metrics . ascent - metrics . descent + draw_info -> stroke_width + 0.5 ) ; if ( image -> rows == 0 ) image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%+g%+g" , draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : 0.0 , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; draw_info -> geometry = AcquireString ( geometry ) ; status = AnnotateImage ( image , draw_info ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pointsize , MaxTextExtent , "%.20g" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , "label:pointsize" , pointsize ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; }
static ErlDrvSSizeT ejabberd_zlib_drv_control ( ErlDrvData handle , unsigned int command , char * buf , ErlDrvSizeT len , char * * rbuf , ErlDrvSizeT rlen ) { ejabberd_zlib_data * d = ( ejabberd_zlib_data * ) handle ; int err ; int size ; ErlDrvBinary * b ; switch ( command ) { case DEFLATE : size = BUF_SIZE + 1 ; rlen = 1 ; b = driver_alloc_binary ( size ) ; b -> orig_bytes [ 0 ] = 0 ; d -> d_stream -> next_in = ( unsigned char * ) buf ; d -> d_stream -> avail_in = len ; d -> d_stream -> avail_out = 0 ; err = Z_OK ; while ( err == Z_OK && d -> d_stream -> avail_out == 0 ) { d -> d_stream -> next_out = ( unsigned char * ) b -> orig_bytes + rlen ; d -> d_stream -> avail_out = BUF_SIZE ; err = deflate ( d -> d_stream , Z_SYNC_FLUSH ) ; die_unless ( ( err == Z_OK ) || ( err == Z_STREAM_END ) , "Deflate error" ) ; rlen += ( BUF_SIZE - d -> d_stream -> avail_out ) ; size += ( BUF_SIZE - d -> d_stream -> avail_out ) ; b = driver_realloc_binary ( b , size ) ; } b = driver_realloc_binary ( b , rlen ) ; * rbuf = ( char * ) b ; return rlen ; case INFLATE : size = BUF_SIZE + 1 ; rlen = 1 ; b = driver_alloc_binary ( size ) ; b -> orig_bytes [ 0 ] = 0 ; if ( len > 0 ) { d -> i_stream -> next_in = ( unsigned char * ) buf ; d -> i_stream -> avail_in = len ; d -> i_stream -> avail_out = 0 ; err = Z_OK ; while ( err == Z_OK && d -> i_stream -> avail_out == 0 ) { d -> i_stream -> next_out = ( unsigned char * ) b -> orig_bytes + rlen ; d -> i_stream -> avail_out = BUF_SIZE ; err = inflate ( d -> i_stream , Z_SYNC_FLUSH ) ; die_unless ( ( err == Z_OK ) || ( err == Z_STREAM_END ) , "Inflate error" ) ; rlen += ( BUF_SIZE - d -> i_stream -> avail_out ) ; size += ( BUF_SIZE - d -> i_stream -> avail_out ) ; b = driver_realloc_binary ( b , size ) ; } } b = driver_realloc_binary ( b , rlen ) ; * rbuf = ( char * ) b ; return rlen ; } b = driver_alloc_binary ( 1 ) ; b -> orig_bytes [ 0 ] = 0 ; * rbuf = ( char * ) b ; return 1 ; }
void AllocateDataSet ( cmsIT8 * it8 ) { TABLE * t = GetTable ( it8 ) ; if ( t -> Data ) return ; t -> nSamples = atoi ( cmsIT8GetProperty ( it8 , "NUMBER_OF_FIELDS" ) ) ; t -> nPatches = atoi ( cmsIT8GetProperty ( it8 , "NUMBER_OF_SETS" ) ) ; t -> Data = ( char * * ) AllocChunk ( it8 , ( ( cmsUInt32Number ) t -> nSamples + 1 ) * ( ( cmsUInt32Number ) t -> nPatches + 1 ) * sizeof ( char * ) ) ; if ( t -> Data == NULL ) { SynError ( it8 , "AllocateDataSet: Unable to allocate data array" ) ; } }
RuntimeFunction * Declarations :: DeclareRuntimeFunction ( const std :: string & name , const Signature & signature ) { CheckAlreadyDeclared ( name , "runtime function" ) ; RuntimeFunction * result = new RuntimeFunction ( name , signature , GetCurrentGeneric ( ) ) ; Declare ( name , std :: unique_ptr < Declarable > ( result ) ) ; return result ; }
void operator ( ) ( const CPUDevice & d , typename TTypes < T > :: ConstVec input , const bool signed_input , const int num_bits , const bool range_given , Tensor * input_min_tensor , Tensor * input_max_tensor , QuantizerRoundMode round_mode , bool narrow_range , typename TTypes < T > :: Vec out ) { QuantizeAndDequantizeOneScaleImpl < CPUDevice , T > :: Compute ( d , input , signed_input , num_bits , range_given , input_min_tensor , input_max_tensor , round_mode , narrow_range , out ) ; }
txFnStartParam ( PRInt32 aNamespaceID , nsIAtom * aLocalName , nsIAtom * aPrefix , txStylesheetAttr * aAttributes , PRInt32 aAttrCount , txStylesheetCompilerState & aState ) { nsresult rv = NS_OK ; txExpandedName name ; rv = getQNameAttr ( aAttributes , aAttrCount , nsGkAtoms :: name , true , aState , name ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsAutoPtr < txCheckParam > checkParam ( new txCheckParam ( name ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aState . pushPtr ( checkParam ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsAutoPtr < txInstruction > instr ( checkParam . forget ( ) ) ; rv = aState . addInstruction ( instr ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsAutoPtr < Expr > select ; rv = getExprAttr ( aAttributes , aAttrCount , nsGkAtoms :: select , false , aState , select ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsAutoPtr < txSetVariable > var ( new txSetVariable ( name , select ) ) ; NS_ENSURE_TRUE ( var , NS_ERROR_OUT_OF_MEMORY ) ; if ( var -> mValue ) { rv = aState . pushHandlerTable ( gTxIgnoreHandler ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } else { rv = aState . pushHandlerTable ( gTxVariableHandler ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } rv = aState . pushObject ( var ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; var . forget ( ) ; return NS_OK ; }
static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case ' ' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : { int a = getnum ( L , fmt , MAXALIGN ) ; if ( ! isp2 ( a ) ) luaL_error ( L , "alignment %d is not a power of 2" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , "invalid format option '%c'" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 3 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * start = GetInput ( context , node , kStartTensor ) ; const TfLiteTensor * limit = GetInput ( context , node , kLimitTensor ) ; const TfLiteTensor * delta = GetInput ( context , node , kDeltaTensor ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( start ) , 0 ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( limit ) , 0 ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( delta ) , 0 ) ; const auto dtype = start -> type ; if ( dtype != kTfLiteFloat32 && dtype != kTfLiteInt32 ) { context -> ReportError ( context , "Unknown index output data type: %s" , TfLiteTypeGetName ( dtype ) ) ; return kTfLiteError ; } TF_LITE_ENSURE_TYPES_EQ ( context , limit -> type , dtype ) ; TF_LITE_ENSURE_TYPES_EQ ( context , delta -> type , dtype ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; output -> type = dtype ; if ( IsConstantTensor ( start ) && IsConstantTensor ( limit ) && IsConstantTensor ( delta ) ) { return ResizeOutput ( context , start , limit , delta , output ) ; } SetTensorToDynamic ( output ) ; return kTfLiteOk ; }
tt_cmap13_char_next ( TT_CMap cmap , FT_UInt32 * pchar_code ) { TT_CMap13 cmap13 = ( TT_CMap13 ) cmap ; FT_UInt gindex ; if ( cmap13 -> cur_charcode >= 0xFFFFFFFFUL ) return 0 ; if ( cmap13 -> valid && cmap13 -> cur_charcode == * pchar_code ) { tt_cmap13_next ( cmap13 ) ; if ( cmap13 -> valid ) { gindex = cmap13 -> cur_gindex ; if ( gindex ) * pchar_code = cmap13 -> cur_charcode ; } else gindex = 0 ; } else gindex = tt_cmap13_char_map_binary ( cmap , pchar_code , 1 ) ; return gindex ; }
static PyObject * __pyx_pf_17clickhouse_driver_14bufferedreader_24CompressedBufferedReader_2read_into_buffer ( struct __pyx_obj_17clickhouse_driver_14bufferedreader_CompressedBufferedReader * __pyx_v_self ) { PyObject * __pyx_r = NULL ; __Pyx_RefNannyDeclarations PyObject * __pyx_t_1 = NULL ; PyObject * __pyx_t_2 = NULL ; PyObject * __pyx_t_3 = NULL ; Py_ssize_t __pyx_t_4 ; int __pyx_t_5 ; __Pyx_RefNannySetupContext ( "read_into_buffer" , 0 ) ; __Pyx_INCREF ( __pyx_v_self -> read_block ) ; __pyx_t_2 = __pyx_v_self -> read_block ; __pyx_t_3 = NULL ; if ( CYTHON_UNPACK_METHODS && likely ( PyMethod_Check ( __pyx_t_2 ) ) ) { __pyx_t_3 = PyMethod_GET_SELF ( __pyx_t_2 ) ; if ( likely ( __pyx_t_3 ) ) { PyObject * function = PyMethod_GET_FUNCTION ( __pyx_t_2 ) ; __Pyx_INCREF ( __pyx_t_3 ) ; __Pyx_INCREF ( function ) ; __Pyx_DECREF_SET ( __pyx_t_2 , function ) ; } } __pyx_t_1 = ( __pyx_t_3 ) ? __Pyx_PyObject_CallOneArg ( __pyx_t_2 , __pyx_t_3 ) : __Pyx_PyObject_CallNoArg ( __pyx_t_2 ) ; __Pyx_XDECREF ( __pyx_t_3 ) ; __pyx_t_3 = 0 ; if ( unlikely ( ! __pyx_t_1 ) ) __PYX_ERR ( 0 , 202 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_1 ) ; __Pyx_DECREF ( __pyx_t_2 ) ; __pyx_t_2 = 0 ; __pyx_t_2 = __Pyx_PyObject_CallOneArg ( ( ( PyObject * ) ( & PyByteArray_Type ) ) , __pyx_t_1 ) ; if ( unlikely ( ! __pyx_t_2 ) ) __PYX_ERR ( 0 , 202 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_2 ) ; __Pyx_DECREF ( __pyx_t_1 ) ; __pyx_t_1 = 0 ; __Pyx_GIVEREF ( __pyx_t_2 ) ; __Pyx_GOTREF ( __pyx_v_self -> __pyx_base . buffer ) ; __Pyx_DECREF ( __pyx_v_self -> __pyx_base . buffer ) ; __pyx_v_self -> __pyx_base . buffer = ( ( PyObject * ) __pyx_t_2 ) ; __pyx_t_2 = 0 ; __pyx_t_2 = __pyx_v_self -> __pyx_base . buffer ; __Pyx_INCREF ( __pyx_t_2 ) ; if ( unlikely ( __pyx_t_2 == Py_None ) ) { PyErr_SetString ( PyExc_TypeError , "object of type 'NoneType' has no len()" ) ; __PYX_ERR ( 0 , 203 , __pyx_L1_error ) } __pyx_t_4 = PyByteArray_GET_SIZE ( __pyx_t_2 ) ; if ( unlikely ( __pyx_t_4 == ( ( Py_ssize_t ) - 1 ) ) ) __PYX_ERR ( 0 , 203 , __pyx_L1_error ) __Pyx_DECREF ( __pyx_t_2 ) ; __pyx_t_2 = 0 ; __pyx_v_self -> __pyx_base . current_buffer_size = __pyx_t_4 ; __pyx_t_5 = ( ( __pyx_v_self -> __pyx_base . current_buffer_size == 0 ) != 0 ) ; if ( unlikely ( __pyx_t_5 ) ) { __pyx_t_2 = __Pyx_PyObject_Call ( __pyx_builtin_EOFError , __pyx_tuple_ , NULL ) ; if ( unlikely ( ! __pyx_t_2 ) ) __PYX_ERR ( 0 , 206 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_2 ) ; __Pyx_Raise ( __pyx_t_2 , 0 , 0 , 0 ) ; __Pyx_DECREF ( __pyx_t_2 ) ; __pyx_t_2 = 0 ; __PYX_ERR ( 0 , 206 , __pyx_L1_error ) } __pyx_r = Py_None ; __Pyx_INCREF ( Py_None ) ; goto __pyx_L0 ; __pyx_L1_error : ; __Pyx_XDECREF ( __pyx_t_1 ) ; __Pyx_XDECREF ( __pyx_t_2 ) ; __Pyx_XDECREF ( __pyx_t_3 ) ; __Pyx_AddTraceback ( "clickhouse_driver.bufferedreader.CompressedBufferedReader.read_into_buffer" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __pyx_r = NULL ; __pyx_L0 : ; __Pyx_XGIVEREF ( __pyx_r ) ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
init_global_keywords ( bool global_active ) { install_keyword_root ( "linkbeat_use_polling" , use_polling_handler , global_active ) ; #if HAVE_DECL_CLONE_NEWNET install_keyword_root ( "net_namespace" , & net_namespace_handler , global_active ) ; install_keyword_root ( "namespace_with_ipsets" , & namespace_ipsets_handler , global_active ) ; #endif install_keyword_root ( "use_pid_dir" , & use_pid_dir_handler , global_active ) ; install_keyword_root ( "instance" , & instance_handler , global_active ) ; install_keyword_root ( "child_wait_time" , & child_wait_handler , global_active ) ; install_keyword_root ( "global_defs" , NULL , global_active ) ; install_keyword ( "router_id" , & routerid_handler ) ; install_keyword ( "notification_email_from" , & emailfrom_handler ) ; install_keyword ( "smtp_server" , & smtpserver_handler ) ; install_keyword ( "smtp_helo_name" , & smtphelo_handler ) ; install_keyword ( "smtp_connect_timeout" , & smtpto_handler ) ; install_keyword ( "notification_email" , & email_handler ) ; install_keyword ( "smtp_alert" , & smtp_alert_handler ) ; #ifdef _WITH_VRRP_ install_keyword ( "smtp_alert_vrrp" , & smtp_alert_vrrp_handler ) ; #endif #ifdef _WITH_LVS_ install_keyword ( "smtp_alert_checker" , & smtp_alert_checker_handler ) ; #endif #ifdef _WITH_VRRP_ install_keyword ( "dynamic_interfaces" , & dynamic_interfaces_handler ) ; install_keyword ( "no_email_faults" , & no_email_faults_handler ) ; install_keyword ( "default_interface" , & default_interface_handler ) ; #endif #ifdef _WITH_LVS_ install_keyword ( "lvs_timeouts" , & lvs_timeouts ) ; install_keyword ( "lvs_flush" , & lvs_flush_handler ) ; #ifdef _WITH_VRRP_ install_keyword ( "lvs_sync_daemon" , & lvs_syncd_handler ) ; #endif #endif #ifdef _WITH_VRRP_ install_keyword ( "vrrp_mcast_group4" , & vrrp_mcast_group4_handler ) ; install_keyword ( "vrrp_mcast_group6" , & vrrp_mcast_group6_handler ) ; install_keyword ( "vrrp_garp_master_delay" , & vrrp_garp_delay_handler ) ; install_keyword ( "vrrp_garp_master_repeat" , & vrrp_garp_rep_handler ) ; install_keyword ( "vrrp_garp_master_refresh" , & vrrp_garp_refresh_handler ) ; install_keyword ( "vrrp_garp_master_refresh_repeat" , & vrrp_garp_refresh_rep_handler ) ; install_keyword ( "vrrp_garp_lower_prio_delay" , & vrrp_garp_lower_prio_delay_handler ) ; install_keyword ( "vrrp_garp_lower_prio_repeat" , & vrrp_garp_lower_prio_rep_handler ) ; install_keyword ( "vrrp_garp_interval" , & vrrp_garp_interval_handler ) ; install_keyword ( "vrrp_gna_interval" , & vrrp_gna_interval_handler ) ; install_keyword ( "vrrp_lower_prio_no_advert" , & vrrp_lower_prio_no_advert_handler ) ; install_keyword ( "vrrp_higher_prio_send_advert" , & vrrp_higher_prio_send_advert_handler ) ; install_keyword ( "vrrp_version" , & vrrp_version_handler ) ; install_keyword ( "vrrp_iptables" , & vrrp_iptables_handler ) ; #ifdef _HAVE_LIBIPSET_ install_keyword ( "vrrp_ipsets" , & vrrp_ipsets_handler ) ; #endif install_keyword ( "vrrp_check_unicast_src" , & vrrp_check_unicast_src_handler ) ; install_keyword ( "vrrp_skip_check_adv_addr" , & vrrp_check_adv_addr_handler ) ; install_keyword ( "vrrp_strict" , & vrrp_strict_handler ) ; install_keyword ( "vrrp_priority" , & vrrp_prio_handler ) ; install_keyword ( "vrrp_no_swap" , & vrrp_no_swap_handler ) ; #ifdef _HAVE_SCHED_RT_ install_keyword ( "vrrp_rt_priority" , & vrrp_rt_priority_handler ) ; #if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( "vrrp_rlimit_rtime" , & vrrp_rt_rlimit_handler ) ; #endif #endif #endif install_keyword ( "notify_fifo" , & global_notify_fifo ) ; install_keyword ( "notify_fifo_script" , & global_notify_fifo_script ) ; #ifdef _WITH_VRRP_ install_keyword ( "vrrp_notify_fifo" , & vrrp_notify_fifo ) ; install_keyword ( "vrrp_notify_fifo_script" , & vrrp_notify_fifo_script ) ; #endif #ifdef _WITH_LVS_ install_keyword ( "lvs_notify_fifo" , & lvs_notify_fifo ) ; install_keyword ( "lvs_notify_fifo_script" , & lvs_notify_fifo_script ) ; install_keyword ( "checker_priority" , & checker_prio_handler ) ; install_keyword ( "checker_no_swap" , & checker_no_swap_handler ) ; #ifdef _HAVE_SCHED_RT_ install_keyword ( "checker_rt_priority" , & checker_rt_priority_handler ) ; #if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( "checker_rlimit_rtime" , & checker_rt_rlimit_handler ) ; #endif #endif #endif #ifdef _WITH_BFD_ install_keyword ( "bfd_priority" , & bfd_prio_handler ) ; install_keyword ( "bfd_no_swap" , & bfd_no_swap_handler ) ; #ifdef _HAVE_SCHED_RT_ install_keyword ( "bfd_rt_priority" , & bfd_rt_priority_handler ) ; #if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( "bfd_rlimit_rtime" , & bfd_rt_rlimit_handler ) ; #endif #endif #endif #ifdef _WITH_SNMP_ install_keyword ( "snmp_socket" , & snmp_socket_handler ) ; install_keyword ( "enable_traps" , & trap_handler ) ; #ifdef _WITH_SNMP_VRRP_ install_keyword ( "enable_snmp_vrrp" , & snmp_vrrp_handler ) ; install_keyword ( "enable_snmp_keepalived" , & snmp_vrrp_handler ) ; #endif #ifdef _WITH_SNMP_RFC_ install_keyword ( "enable_snmp_rfc" , & snmp_rfc_handler ) ; #endif #ifdef _WITH_SNMP_RFCV2_ install_keyword ( "enable_snmp_rfcv2" , & snmp_rfcv2_handler ) ; #endif #ifdef _WITH_SNMP_RFCV3_ install_keyword ( "enable_snmp_rfcv3" , & snmp_rfcv3_handler ) ; #endif #ifdef _WITH_SNMP_CHECKER_ install_keyword ( "enable_snmp_checker" , & snmp_checker_handler ) ; #endif #endif #ifdef _WITH_DBUS_ install_keyword ( "enable_dbus" , & enable_dbus_handler ) ; install_keyword ( "dbus_service_name" , & dbus_service_name_handler ) ; #endif install_keyword ( "script_user" , & script_user_handler ) ; install_keyword ( "enable_script_security" , & script_security_handler ) ; #ifdef _WITH_VRRP_ install_keyword ( "vrrp_netlink_cmd_rcv_bufs" , & vrrp_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( "vrrp_netlink_cmd_rcv_bufs_force" , & vrrp_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( "vrrp_netlink_monitor_rcv_bufs" , & vrrp_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( "vrrp_netlink_monitor_rcv_bufs_force" , & vrrp_netlink_monitor_rcv_bufs_force_handler ) ; #endif #ifdef _WITH_LVS_ install_keyword ( "lvs_netlink_cmd_rcv_bufs" , & lvs_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( "lvs_netlink_cmd_rcv_bufs_force" , & lvs_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( "lvs_netlink_monitor_rcv_bufs" , & lvs_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( "lvs_netlink_monitor_rcv_bufs_force" , & lvs_netlink_monitor_rcv_bufs_force_handler ) ; #endif #ifdef _WITH_LVS_ install_keyword ( "rs_init_notifies" , & rs_init_notifies_handler ) ; install_keyword ( "no_checker_emails" , & no_checker_emails_handler ) ; #endif #ifdef _WITH_VRRP_ install_keyword ( "vrrp_rx_bufs_policy" , & vrrp_rx_bufs_policy_handler ) ; install_keyword ( "vrrp_rx_bufs_multiplier" , & vrrp_rx_bufs_multiplier_handler ) ; #endif }
HTMLMediaElement :: RemoveMediaElementFromURITable ( ) { NS_ASSERTION ( MediaElementTableCount ( this , mLoadingSrc ) == 1 , "Before remove, should have a single entry for element in element table" ) ; NS_ASSERTION ( mDecoder , "Don't call this without decoder!" ) ; NS_ASSERTION ( mLoadingSrc , "Can't have decoder without source!" ) ; if ( ! gElementTable ) return ; MediaElementSetForURI * entry = gElementTable -> GetEntry ( mLoadingSrc ) ; if ( ! entry ) return ; entry -> mElements . RemoveElement ( this ) ; if ( entry -> mElements . IsEmpty ( ) ) { gElementTable -> RemoveEntry ( mLoadingSrc ) ; if ( gElementTable -> Count ( ) == 0 ) { delete gElementTable ; gElementTable = nullptr ; } } NS_ASSERTION ( MediaElementTableCount ( this , mLoadingSrc ) == 0 , "After remove, should no longer have an entry in element table" ) ; }
static enum integrity_status evm_verify_hmac ( struct dentry * dentry , const char * xattr_name , char * xattr_value , size_t xattr_value_len , struct integrity_iint_cache * iint ) { struct evm_ima_xattr_data * xattr_data = NULL ; struct evm_ima_xattr_data calc ; enum integrity_status evm_status = INTEGRITY_PASS ; int rc , xattr_len ; if ( iint && iint -> evm_status == INTEGRITY_PASS ) return iint -> evm_status ; rc = vfs_getxattr_alloc ( dentry , XATTR_NAME_EVM , ( char * * ) & xattr_data , 0 , GFP_NOFS ) ; if ( rc <= 0 ) { evm_status = INTEGRITY_FAIL ; if ( rc == - ENODATA ) { rc = evm_find_protected_xattrs ( dentry ) ; if ( rc > 0 ) evm_status = INTEGRITY_NOLABEL ; else if ( rc == 0 ) evm_status = INTEGRITY_NOXATTRS ; } else if ( rc == - EOPNOTSUPP ) { evm_status = INTEGRITY_UNKNOWN ; } goto out ; } xattr_len = rc ; switch ( xattr_data -> type ) { case EVM_XATTR_HMAC : rc = evm_calc_hmac ( dentry , xattr_name , xattr_value , xattr_value_len , calc . digest ) ; if ( rc ) break ; rc = memcmp ( xattr_data -> digest , calc . digest , sizeof ( calc . digest ) ) ; if ( rc ) rc = - EINVAL ; break ; case EVM_IMA_XATTR_DIGSIG : rc = evm_calc_hash ( dentry , xattr_name , xattr_value , xattr_value_len , calc . digest ) ; if ( rc ) break ; rc = integrity_digsig_verify ( INTEGRITY_KEYRING_EVM , ( const char * ) xattr_data , xattr_len , calc . digest , sizeof ( calc . digest ) ) ; if ( ! rc ) { if ( ! IS_RDONLY ( d_backing_inode ( dentry ) ) && ! IS_IMMUTABLE ( d_backing_inode ( dentry ) ) ) evm_update_evmxattr ( dentry , xattr_name , xattr_value , xattr_value_len ) ; } break ; default : rc = - EINVAL ; break ; } if ( rc ) evm_status = ( rc == - ENODATA ) ? INTEGRITY_NOXATTRS : INTEGRITY_FAIL ; out : if ( iint ) iint -> evm_status = evm_status ; kfree ( xattr_data ) ; return evm_status ; }
static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) { EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , c ) ; switch ( type ) { case EVP_CTRL_INIT : cctx -> key_set = 0 ; cctx -> iv_set = 0 ; cctx -> L = 8 ; cctx -> M = 12 ; cctx -> tag_set = 0 ; cctx -> len_set = 0 ; cctx -> tls_aad_len = - 1 ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; cctx -> tls_aad_len = arg ; { uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] < < 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ; len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ; if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) len -= cctx -> M ; EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len > > 8 ; EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ; } return cctx -> M ; case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ; return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : arg = 15 - arg ; case EVP_CTRL_CCM_SET_L : if ( arg < 2 || arg > 8 ) return 0 ; cctx -> L = arg ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ; if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ; if ( ptr ) { cctx -> tag_set = 1 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; } cctx -> M = arg ; return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( ! EVP_CIPHER_CTX_encrypting ( c ) || ! cctx -> tag_set ) return 0 ; if ( ! CRYPTO_ccm128_tag ( & cctx -> ccm , ptr , ( size_t ) arg ) ) return 0 ; cctx -> tag_set = 0 ; cctx -> iv_set = 0 ; cctx -> len_set = 0 ; return 1 ; case EVP_CTRL_COPY : { EVP_CIPHER_CTX * out = ptr ; EVP_AES_CCM_CTX * cctx_out = EVP_C_DATA ( EVP_AES_CCM_CTX , out ) ; if ( cctx -> ccm . key ) { if ( cctx -> ccm . key != & cctx -> ks ) return 0 ; cctx_out -> ccm . key = & cctx_out -> ks ; } return 1 ; } default : return - 1 ; } }
static int dcbnl_getperm_hwaddr ( struct net_device * netdev , struct nlmsghdr * nlh , u32 seq , struct nlattr * * tb , struct sk_buff * skb ) { u8 perm_addr [ MAX_ADDR_LEN ] ; if ( ! netdev -> dcbnl_ops -> getpermhwaddr ) return - EOPNOTSUPP ; netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ; }
static int get_filter ( struct sss_certmap_ctx * ctx , struct ldap_mapping_rule * parsed_mapping_rule , struct sss_cert_content * cert_content , char * * filter ) { struct ldap_mapping_rule_comp * comp ; char * result = NULL ; char * expanded = NULL ; int ret ; result = talloc_strdup ( ctx , "" ) ; if ( result == NULL ) { return ENOMEM ; } for ( comp = parsed_mapping_rule -> list ; comp != NULL ; comp = comp -> next ) { if ( comp -> type == comp_string ) { result = talloc_strdup_append ( result , comp -> val ) ; } else if ( comp -> type == comp_template ) { ret = expand_template ( ctx , comp -> parsed_template , cert_content , & expanded ) ; if ( ret != 0 ) { CM_DEBUG ( ctx , "Failed to expanded template." ) ; goto done ; } result = talloc_strdup_append ( result , expanded ) ; talloc_free ( expanded ) ; expanded = NULL ; if ( result == NULL ) { ret = ENOMEM ; goto done ; } } else { ret = EINVAL ; CM_DEBUG ( ctx , "Unsupported component type." ) ; goto done ; } } ret = 0 ; done : talloc_free ( expanded ) ; if ( ret == 0 ) { * filter = result ; } else { talloc_free ( result ) ; } return ret ; }
void DeclarationVisitor :: Visit ( Statement * stmt ) { CurrentSourcePosition :: Scope scope ( stmt -> pos ) ; switch ( stmt -> kind ) { #define ENUM_ITEM(name)        \  case AstNode::Kind::k##name: \  return Visit(name::cast(stmt)); AST_STATEMENT_NODE_KIND_LIST ( ENUM_ITEM ) #undef ENUM_ITEM default : UNIMPLEMENTED ( ) ; } }
bool IC :: ConfigureVectorState ( IC :: State new_state , Handle < Object > key ) { DCHECK_EQ ( MEGAMORPHIC , new_state ) ; DCHECK_IMPLIES ( ! is_keyed ( ) , key -> IsName ( ) ) ; bool changed = nexus ( ) -> ConfigureMegamorphic ( key -> IsName ( ) ? PROPERTY : ELEMENT ) ; vector_set_ = true ; OnFeedbackChanged ( isolate ( ) , nexus ( ) , GetHostFunction ( ) , "Megamorphic" ) ; return changed ; }
nsTextFrame :: GetPointFromOffset ( PRInt32 inOffset , nsPoint * outPoint ) { if ( ! outPoint ) return NS_ERROR_NULL_POINTER ; outPoint -> x = 0 ; outPoint -> y = 0 ; DEBUG_VERIFY_NOT_DIRTY ( mState ) ; if ( mState & NS_FRAME_IS_DIRTY ) return NS_ERROR_UNEXPECTED ; if ( GetContentLength ( ) <= 0 ) { return NS_OK ; } gfxSkipCharsIterator iter = EnsureTextRun ( ) ; if ( ! mTextRun ) return NS_ERROR_FAILURE ; PropertyProvider properties ( this , iter ) ; properties . InitializeForDisplay ( PR_FALSE ) ; if ( inOffset < GetContentOffset ( ) ) { NS_WARNING ( "offset before this frame's content" ) ; inOffset = GetContentOffset ( ) ; } else if ( inOffset > GetContentEnd ( ) ) { NS_WARNING ( "offset after this frame's content" ) ; inOffset = GetContentEnd ( ) ; } PRInt32 trimmedOffset = properties . GetStart ( ) . GetOriginalOffset ( ) ; PRInt32 trimmedEnd = trimmedOffset + properties . GetOriginalLength ( ) ; inOffset = NS_MAX ( inOffset , trimmedOffset ) ; inOffset = NS_MIN ( inOffset , trimmedEnd ) ; iter . SetOriginalOffset ( inOffset ) ; if ( inOffset < trimmedEnd && ! iter . IsOriginalCharSkipped ( ) && ! mTextRun -> IsClusterStart ( iter . GetSkippedOffset ( ) ) ) { NS_WARNING ( "GetPointFromOffset called for non-cluster boundary" ) ; FindClusterStart ( mTextRun , & iter ) ; } gfxFloat advanceWidth = mTextRun -> GetAdvanceWidth ( properties . GetStart ( ) . GetSkippedOffset ( ) , GetSkippedDistance ( properties . GetStart ( ) , iter ) , & properties ) ; nscoord width = NSToCoordCeilClamped ( advanceWidth ) ; if ( mTextRun -> IsRightToLeft ( ) ) { outPoint -> x = mRect . width - width ; } else { outPoint -> x = width ; } outPoint -> y = 0 ; return NS_OK ; }
Reduction JSCallReducer :: ReduceNumberIsNaN ( Node * node ) { if ( node -> op ( ) -> ValueInputCount ( ) < 3 ) { Node * value = jsgraph ( ) -> FalseConstant ( ) ; ReplaceWithValue ( node , value ) ; return Replace ( value ) ; } Node * input = NodeProperties :: GetValueInput ( node , 2 ) ; Node * value = graph ( ) -> NewNode ( simplified ( ) -> ObjectIsNaN ( ) , input ) ; ReplaceWithValue ( node , value ) ; return Replace ( value ) ; }
TfLiteStatus DecodeCenterSizeBoxes ( TfLiteContext * context , TfLiteNode * node , OpData * op_data ) { const TfLiteTensor * input_box_encodings = GetInput ( context , node , kInputTensorBoxEncodings ) ; TF_LITE_ENSURE_EQ ( context , input_box_encodings -> dims -> data [ 0 ] , kBatchSize ) ; const int num_boxes = input_box_encodings -> dims -> data [ 1 ] ; TF_LITE_ENSURE ( context , input_box_encodings -> dims -> data [ 2 ] >= kNumCoordBox ) ; const TfLiteTensor * input_anchors = GetInput ( context , node , kInputTensorAnchors ) ; CenterSizeEncoding box_centersize ; CenterSizeEncoding scale_values = op_data -> scale_values ; CenterSizeEncoding anchor ; for ( int idx = 0 ; idx < num_boxes ; ++ idx ) { switch ( input_box_encodings -> type ) { case kTfLiteUInt8 : DequantizeBoxEncodings ( input_box_encodings , idx , static_cast < float > ( input_box_encodings -> params . zero_point ) , static_cast < float > ( input_box_encodings -> params . scale ) , input_box_encodings -> dims -> data [ 2 ] , & box_centersize ) ; DequantizeBoxEncodings ( input_anchors , idx , static_cast < float > ( input_anchors -> params . zero_point ) , static_cast < float > ( input_anchors -> params . scale ) , kNumCoordBox , & anchor ) ; break ; case kTfLiteFloat32 : { const int box_encoding_idx = idx * input_box_encodings -> dims -> data [ 2 ] ; const float * boxes = & ( GetTensorData < float > ( input_box_encodings ) [ box_encoding_idx ] ) ; box_centersize = * reinterpret_cast < const CenterSizeEncoding * > ( boxes ) ; anchor = ReInterpretTensor < const CenterSizeEncoding * > ( input_anchors ) [ idx ] ; break ; } default : return kTfLiteError ; } float ycenter = box_centersize . y / scale_values . y * anchor . h + anchor . y ; float xcenter = box_centersize . x / scale_values . x * anchor . w + anchor . x ; float half_h = 0.5f * static_cast < float > ( std :: exp ( box_centersize . h / scale_values . h ) ) * anchor . h ; float half_w = 0.5f * static_cast < float > ( std :: exp ( box_centersize . w / scale_values . w ) ) * anchor . w ; TfLiteTensor * decoded_boxes = & context -> tensors [ op_data -> decoded_boxes_index ] ; auto & box = ReInterpretTensor < BoxCornerEncoding * > ( decoded_boxes ) [ idx ] ; box . ymin = ycenter - half_h ; box . xmin = xcenter - half_w ; box . ymax = ycenter + half_h ; box . xmax = xcenter + half_w ; } return kTfLiteOk ; }
bool Cues :: LoadCuePoint ( ) const { const long long stop = m_start + m_size ; if ( m_pos >= stop ) return false ; Init ( ) ; IMkvReader * const pReader = m_pSegment -> m_pReader ; while ( m_pos < stop ) { const long long idpos = m_pos ; long len ; const long long id = ReadUInt ( pReader , m_pos , len ) ; assert ( id >= 0 ) ; assert ( ( m_pos + len ) <= stop ) ; m_pos += len ; const long long size = ReadUInt ( pReader , m_pos , len ) ; assert ( size >= 0 ) ; assert ( ( m_pos + len ) <= stop ) ; m_pos += len ; assert ( ( m_pos + size ) <= stop ) ; if ( id != 0x3B ) { m_pos += size ; assert ( m_pos <= stop ) ; continue ; } assert ( m_preload_count > 0 ) ; CuePoint * const pCP = m_cue_points [ m_count ] ; assert ( pCP ) ; assert ( ( pCP -> GetTimeCode ( ) >= 0 ) || ( - pCP -> GetTimeCode ( ) == idpos ) ) ; if ( pCP -> GetTimeCode ( ) < 0 && ( - pCP -> GetTimeCode ( ) != idpos ) ) return false ; pCP -> Load ( pReader ) ; ++ m_count ; -- m_preload_count ; m_pos += size ; assert ( m_pos <= stop ) ; return true ; } return false ; }
void sas_deform_port ( struct asd_sas_phy * phy , int gone ) { struct sas_ha_struct * sas_ha = phy -> ha ; struct asd_sas_port * port = phy -> port ; struct sas_internal * si = to_sas_internal ( sas_ha -> core . shost -> transportt ) ; struct domain_device * dev ; unsigned long flags ; if ( ! port ) return ; dev = port -> port_dev ; if ( dev ) dev -> pathways -- ; if ( port -> num_phys == 1 ) { sas_unregister_domain_devices ( port , gone ) ; sas_port_delete ( port -> port ) ; port -> port = NULL ; } else { sas_port_delete_phy ( port -> port , phy -> phy ) ; sas_device_set_phy ( dev , port -> port ) ; } if ( si -> dft -> lldd_port_deformed ) si -> dft -> lldd_port_deformed ( phy ) ; spin_lock_irqsave ( & sas_ha -> phy_port_lock , flags ) ; spin_lock ( & port -> phy_list_lock ) ; list_del_init ( & phy -> port_phy_el ) ; sas_phy_set_target ( phy , NULL ) ; phy -> port = NULL ; port -> num_phys -- ; port -> phy_mask &= ~ ( 1U < < phy -> id ) ; if ( port -> num_phys == 0 ) { INIT_LIST_HEAD ( & port -> phy_list ) ; memset ( port -> sas_addr , 0 , SAS_ADDR_SIZE ) ; memset ( port -> attached_sas_addr , 0 , SAS_ADDR_SIZE ) ; port -> class = 0 ; port -> iproto = 0 ; port -> tproto = 0 ; port -> oob_mode = 0 ; port -> phy_mask = 0 ; } spin_unlock ( & port -> phy_list_lock ) ; spin_unlock_irqrestore ( & sas_ha -> phy_port_lock , flags ) ; return ; }
TF_BUILTIN ( ConstructProxy , ProxiesCodeStubAssembler ) { Node * argc = Parameter ( Descriptor :: kActualArgumentsCount ) ; Node * argc_ptr = ChangeInt32ToIntPtr ( argc ) ; Node * proxy = Parameter ( Descriptor :: kTarget ) ; Node * new_target = Parameter ( Descriptor :: kNewTarget ) ; Node * context = Parameter ( Descriptor :: kContext ) ; CSA_ASSERT ( this , IsJSProxy ( proxy ) ) ; CSA_ASSERT ( this , IsCallable ( proxy ) ) ; Label throw_proxy_handler_revoked ( this , Label :: kDeferred ) , trap_undefined ( this ) , not_an_object ( this , Label :: kDeferred ) ; Node * handler = LoadObjectField ( proxy , JSProxy :: kHandlerOffset ) ; CSA_ASSERT ( this , IsNullOrJSReceiver ( handler ) ) ; GotoIfNot ( IsJSReceiver ( handler ) , & throw_proxy_handler_revoked ) ; CSA_ASSERT ( this , IsJSReceiver ( handler ) ) ; Node * target = LoadObjectField ( proxy , JSProxy :: kTargetOffset ) ; Handle < Name > trap_name = factory ( ) -> construct_string ( ) ; Node * trap = GetMethod ( context , handler , trap_name , & trap_undefined ) ; CodeStubArguments args ( this , argc_ptr ) ; Node * array = AllocateJSArrayForCodeStubArguments ( context , args , argc_ptr , INTPTR_PARAMETERS ) ; Node * new_obj = CallJS ( CodeFactory :: Call ( isolate ( ) ) , context , trap , handler , target , array , new_target ) ; GotoIf ( TaggedIsSmi ( new_obj ) , & not_an_object ) ; GotoIfNot ( IsJSReceiver ( new_obj ) , & not_an_object ) ; args . PopAndReturn ( new_obj ) ; BIND ( & not_an_object ) ; { ThrowTypeError ( context , MessageTemplate :: kProxyConstructNonObject , new_obj ) ; } BIND ( & trap_undefined ) ; { CSA_ASSERT ( this , IsConstructor ( target ) ) ; TailCallStub ( CodeFactory :: Construct ( isolate ( ) ) , context , target , new_target , argc ) ; } BIND ( & throw_proxy_handler_revoked ) ; { ThrowTypeError ( context , MessageTemplate :: kProxyRevoked , "construct" ) ; } }
mrb_proc_copy ( mrb_state * mrb , struct RProc * a , struct RProc * b ) { if ( a -> body . irep ) { return ; } a -> flags = b -> flags ; a -> body = b -> body ; a -> upper = b -> upper ; if ( ! MRB_PROC_CFUNC_P ( a ) && a -> body . irep ) { mrb_irep_incref ( mrb , ( mrb_irep * ) a -> body . irep ) ; } a -> e . env = b -> e . env ; }
ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r ) { ngx_table_elt_t * header ; ngx_list_part_t * part ; ngx_uint_t i ; if ( ngx_list_init ( & sr -> headers_in . headers , sr -> pool , 20 , sizeof ( ngx_table_elt_t ) ) != NGX_OK ) { return NGX_ERROR ; } dd ( "before: parent req headers count: %d" , ( int ) r -> headers_in . headers . part . nelts ) ; part = & r -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { if ( part -> next == NULL ) { break ; } part = part -> next ; header = part -> elts ; i = 0 ; } dd ( "setting request header %.*s: %.*s" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; } } dd ( "after: parent req headers count: %d" , ( int ) r -> headers_in . headers . part . nelts ) ; return NGX_OK ; }
SizeOfFramePrefix ( FrameType type ) { switch ( type ) { case JitFrame_Entry : return IonEntryFrameLayout :: Size ( ) ; case JitFrame_BaselineJS : case JitFrame_IonJS : case JitFrame_Unwound_IonJS : return IonJSFrameLayout :: Size ( ) ; case JitFrame_BaselineStub : return IonBaselineStubFrameLayout :: Size ( ) ; case JitFrame_Rectifier : return IonRectifierFrameLayout :: Size ( ) ; case JitFrame_Unwound_Rectifier : return IonUnwoundRectifierFrameLayout :: Size ( ) ; case JitFrame_Exit : return IonExitFrameLayout :: Size ( ) ; default : MOZ_CRASH ( "unknown frame type" ) ; } }
void AccessorAssembler :: HandleStoreICTransitionMapHandlerCase ( const StoreICParameters * p , TNode < Map > transition_map , Label * miss , bool validate_transition_handler ) { Node * maybe_validity_cell = LoadObjectField ( transition_map , Map :: kPrototypeValidityCellOffset ) ; CheckPrototypeValidityCell ( maybe_validity_cell , miss ) ; TNode < Uint32T > bitfield3 = LoadMapBitField3 ( transition_map ) ; CSA_ASSERT ( this , IsClearWord32 < Map :: IsDictionaryMapBit > ( bitfield3 ) ) ; GotoIf ( IsSetWord32 < Map :: IsDeprecatedBit > ( bitfield3 ) , miss ) ; Node * nof = DecodeWordFromWord32 < Map :: NumberOfOwnDescriptorsBits > ( bitfield3 ) ; CSA_ASSERT ( this , WordNotEqual ( nof , IntPtrConstant ( 0 ) ) ) ; TNode < DescriptorArray > descriptors = LoadMapDescriptors ( transition_map ) ; Node * factor = IntPtrConstant ( DescriptorArray :: kEntrySize ) ; TNode < IntPtrT > last_key_index = UncheckedCast < IntPtrT > ( IntPtrAdd ( IntPtrConstant ( DescriptorArray :: ToKeyIndex ( - 1 ) ) , IntPtrMul ( nof , factor ) ) ) ; if ( validate_transition_handler ) { Node * key = LoadWeakFixedArrayElement ( descriptors , last_key_index ) ; GotoIf ( WordNotEqual ( key , p -> name ) , miss ) ; } else { CSA_ASSERT ( this , WordEqual ( BitcastMaybeObjectToWord ( LoadWeakFixedArrayElement ( descriptors , last_key_index ) ) , p -> name ) ) ; } Node * details = LoadDetailsByKeyIndex ( descriptors , last_key_index ) ; if ( validate_transition_handler ) { Label attributes_ok ( this ) ; const int kAttributesDontDeleteReadOnlyMask = PropertyDetails :: kAttributesDontDeleteMask | PropertyDetails :: kAttributesReadOnlyMask ; GotoIf ( IsSetWord32 ( details , kAttributesDontDeleteReadOnlyMask ) , miss ) ; Branch ( Word32Equal ( IsSetWord32 ( details , PropertyDetails :: kAttributesDontEnumMask ) , IsPrivateSymbol ( p -> name ) ) , & attributes_ok , miss ) ; BIND ( & attributes_ok ) ; } OverwriteExistingFastDataProperty ( p -> receiver , transition_map , descriptors , last_key_index , details , p -> value , miss , true ) ; }
static void lockd_down_net ( struct svc_serv * serv , struct net * net ) { struct lockd_net * ln = net_generic ( net , lockd_net_id ) ; if ( ln -> nlmsvc_users ) { if ( -- ln -> nlmsvc_users == 0 ) { nlm_shutdown_hosts_net ( net ) ; cancel_delayed_work_sync ( & ln -> grace_period_end ) ; locks_end_grace ( & ln -> lockd_manager ) ; svc_shutdown_net ( serv , net ) ; dprintk ( "lockd_down_net: per-net data destroyed; net=%p\n" , net ) ; } } else { printk ( KERN_ERR "lockd_down_net: no users! task=%p, net=%p\n" , nlmsvc_task , net ) ; BUG ( ) ; } }
void Builtins :: Generate_InterpreterEnterBytecodeAdvance ( MacroAssembler * masm ) { __ ldr ( kInterpreterBytecodeArrayRegister , MemOperand ( fp , InterpreterFrameConstants :: kBytecodeArrayFromFp ) ) ; __ ldr ( kInterpreterBytecodeOffsetRegister , MemOperand ( fp , InterpreterFrameConstants :: kBytecodeOffsetFromFp ) ) ; __ SmiUntag ( kInterpreterBytecodeOffsetRegister ) ; __ ldrb ( r1 , MemOperand ( kInterpreterBytecodeArrayRegister , kInterpreterBytecodeOffsetRegister ) ) ; Label if_return ; AdvanceBytecodeOffsetOrReturn ( masm , kInterpreterBytecodeArrayRegister , kInterpreterBytecodeOffsetRegister , r1 , r2 , & if_return ) ; __ SmiTag ( r2 , kInterpreterBytecodeOffsetRegister ) ; __ str ( r2 , MemOperand ( fp , InterpreterFrameConstants :: kBytecodeOffsetFromFp ) ) ; Generate_InterpreterEnterBytecode ( masm ) ; __ bind ( & if_return ) ; __ Abort ( AbortReason :: kInvalidBytecodeAdvance ) ; }
auto smiFunction = [ = ] ( Node * lhs , Node * rhs , Variable * var_type_feedback ) { VARIABLE ( var_result , MachineRepresentation :: kTagged ) ; - Label bailout ( this , rhs_is_smi ? Label :: kDeferred : Label :: kNonDeferred ) , + Label bailout ( this , rhs_known_smi ? Label :: kDeferred : Label :: kNonDeferred ) , end ( this ) ; - var_result . Bind ( TrySmiDiv ( CAST ( lhs ) , CAST ( rhs ) , & bailout ) ) ; - var_type_feedback -> Bind ( SmiConstant ( BinaryOperationFeedback :: kSignedSmall ) ) ; + var_result = TrySmiDiv ( lhs , rhs , & bailout ) ; + * var_type_feedback = SmiConstant ( BinaryOperationFeedback :: kSignedSmall ) ; Goto ( & end ) ; BIND ( & bailout ) ; { - var_type_feedback -> Bind ( - SmiConstant ( BinaryOperationFeedback :: kSignedSmallInputs ) ) ; - Node * value = Float64Div ( SmiToFloat64 ( lhs ) , SmiToFloat64 ( rhs ) ) ; - var_result . Bind ( AllocateHeapNumberWithValue ( value ) ) ; + * var_type_feedback = + SmiConstant ( BinaryOperationFeedback :: kSignedSmallInputs ) ; + TNode < Float64T > value = Float64Div ( SmiToFloat64 ( lhs ) , SmiToFloat64 ( rhs ) ) ; + var_result = AllocateHeapNumberWithValue ( value ) ; Goto ( & end ) ; } BIND ( & end ) ; return var_result . value ( ) ; } ;
static void process_service_search_rsp ( tCONN_CB * p_ccb , uint8_t * p_reply ) { uint16_t xx ; uint16_t total , cur_handles , orig ; uint8_t cont_len ; p_reply += 4 ; BE_STREAM_TO_UINT16 ( total , p_reply ) ; BE_STREAM_TO_UINT16 ( cur_handles , p_reply ) ; orig = p_ccb -> num_handles ; p_ccb -> num_handles += cur_handles ; if ( p_ccb -> num_handles == 0 ) { SDP_TRACE_WARNING ( "SDP - Rcvd ServiceSearchRsp, no matches" ) ; sdp_disconnect ( p_ccb , SDP_NO_RECS_MATCH ) ; return ; } if ( total > sdp_cb . max_recs_per_search ) total = sdp_cb . max_recs_per_search ; if ( p_ccb -> num_handles > sdp_cb . max_recs_per_search ) p_ccb -> num_handles = sdp_cb . max_recs_per_search ; for ( xx = orig ; xx < p_ccb -> num_handles ; xx ++ ) BE_STREAM_TO_UINT32 ( p_ccb -> handles [ xx ] , p_reply ) ; BE_STREAM_TO_UINT8 ( cont_len , p_reply ) ; if ( cont_len != 0 ) { if ( cont_len > SDP_MAX_CONTINUATION_LEN ) { sdp_disconnect ( p_ccb , SDP_INVALID_CONT_STATE ) ; return ; } sdp_snd_service_search_req ( p_ccb , cont_len , p_reply ) ; } else { p_ccb -> disc_state = SDP_DISC_WAIT_ATTR ; process_service_attr_rsp ( p_ccb , NULL ) ; } }
sctp_disposition_t sctp_sf_do_5_2_4_dupcook ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { sctp_disposition_t retval ; struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; int error = 0 ; char action ; struct sctp_chunk * err_chk_p ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } action = sctp_tietags_compare ( new_asoc , asoc ) ; switch ( action ) { case 'A' : retval = sctp_sf_do_dupcook_a ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'B' : retval = sctp_sf_do_dupcook_b ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'C' : retval = sctp_sf_do_dupcook_c ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'D' : retval = sctp_sf_do_dupcook_d ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; default : retval = sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; break ; } sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_ASOC , SCTP_ASOC ( ( struct sctp_association * ) asoc ) ) ; return retval ; nomem : return SCTP_DISPOSITION_NOMEM ; }
nsHtml5TreeBuilder :: loadState ( nsAHtml5TreeBuilderState * snapshot , nsHtml5AtomTable * interner ) { jArray < nsHtml5StackNode * , int32_t > stackCopy = snapshot -> getStack ( ) ; int32_t stackLen = snapshot -> getStackLength ( ) ; jArray < nsHtml5StackNode * , int32_t > listCopy = snapshot -> getListOfActiveFormattingElements ( ) ; int32_t listLen = snapshot -> getListOfActiveFormattingElementsLength ( ) ; for ( int32_t i = 0 ; i <= listPtr ; i ++ ) { if ( listOfActiveFormattingElements [ i ] ) { listOfActiveFormattingElements [ i ] -> release ( ) ; } } if ( listOfActiveFormattingElements . length < listLen ) { listOfActiveFormattingElements = jArray < nsHtml5StackNode * , int32_t > :: newJArray ( listLen ) ; } listPtr = listLen - 1 ; for ( int32_t i = 0 ; i <= currentPtr ; i ++ ) { stack [ i ] -> release ( ) ; } if ( stack . length < stackLen ) { stack = jArray < nsHtml5StackNode * , int32_t > :: newJArray ( stackLen ) ; } currentPtr = stackLen - 1 ; for ( int32_t i = 0 ; i < listLen ; i ++ ) { nsHtml5StackNode * node = listCopy [ i ] ; if ( node ) { nsHtml5StackNode * newNode = new nsHtml5StackNode ( node -> getFlags ( ) , node -> ns , nsHtml5Portability :: newLocalFromLocal ( node -> name , interner ) , node -> node , nsHtml5Portability :: newLocalFromLocal ( node -> popName , interner ) , node -> attributes -> cloneAttributes ( nullptr ) ) ; listOfActiveFormattingElements [ i ] = newNode ; } else { listOfActiveFormattingElements [ i ] = nullptr ; } } for ( int32_t i = 0 ; i < stackLen ; i ++ ) { nsHtml5StackNode * node = stackCopy [ i ] ; int32_t listIndex = findInArray ( node , listCopy ) ; if ( listIndex == - 1 ) { nsHtml5StackNode * newNode = new nsHtml5StackNode ( node -> getFlags ( ) , node -> ns , nsHtml5Portability :: newLocalFromLocal ( node -> name , interner ) , node -> node , nsHtml5Portability :: newLocalFromLocal ( node -> popName , interner ) , nullptr ) ; stack [ i ] = newNode ; } else { stack [ i ] = listOfActiveFormattingElements [ listIndex ] ; stack [ i ] -> retain ( ) ; } } formPointer = snapshot -> getFormPointer ( ) ; headPointer = snapshot -> getHeadPointer ( ) ; deepTreeSurrogateParent = snapshot -> getDeepTreeSurrogateParent ( ) ; mode = snapshot -> getMode ( ) ; originalMode = snapshot -> getOriginalMode ( ) ; framesetOk = snapshot -> isFramesetOk ( ) ; needToDropLF = snapshot -> isNeedToDropLF ( ) ; quirks = snapshot -> isQuirks ( ) ; }
ProxyAutoConfig :: GC ( ) { if ( ! mJSRuntime || ! mJSRuntime -> IsOK ( ) ) return ; JS_MaybeGC ( mJSRuntime -> Context ( ) ) ; }
nsXBLProtoImplField :: InstallField ( nsIScriptContext * aContext , JSObject * aBoundNode , nsIURI * aBindingDocURI , bool * aDidInstall ) const { NS_PRECONDITION ( aBoundNode , "uh-oh, bound node should NOT be null or bad things will " "happen" ) ; * aDidInstall = false ; if ( IsEmpty ( ) ) { return NS_OK ; } nsAutoMicroTask mt ; nsresult rv ; nsAutoCString uriSpec ; aBindingDocURI -> GetSpec ( uriSpec ) ; JSContext * cx = aContext -> GetNativeContext ( ) ; NS_ASSERTION ( ! :: JS_IsExceptionPending ( cx ) , "Shouldn't get here when an exception is pending!" ) ; nsCOMPtr < nsIScriptContext > context = aContext ; JSAutoRequest ar ( cx ) ; JSObject * scopeObject = xpc :: GetXBLScope ( cx , aBoundNode ) ; JSAutoCompartment ac ( cx , scopeObject ) ; jsval result = JSVAL_NULL ; JSObject * wrappedNode = aBoundNode ; if ( ! JS_WrapObject ( cx , & wrappedNode ) ) return NS_ERROR_OUT_OF_MEMORY ; JS :: CompileOptions options ( cx ) ; options . setFileAndLine ( uriSpec . get ( ) , mLineNumber ) . setVersion ( JSVERSION_LATEST ) . setUserBit ( true ) ; rv = context -> EvaluateString ( nsDependentString ( mFieldText , mFieldTextLength ) , * wrappedNode , options , false , & result ) ; if ( NS_FAILED ( rv ) ) { return rv ; } JSAutoCompartment ac2 ( cx , aBoundNode ) ; nsDependentString name ( mName ) ; if ( ! JS_WrapValue ( cx , & result ) || ! :: JS_DefineUCProperty ( cx , aBoundNode , reinterpret_cast < const jschar * > ( mName ) , name . Length ( ) , result , nullptr , nullptr , mJSAttributes ) ) { return NS_ERROR_OUT_OF_MEMORY ; } * aDidInstall = true ; return NS_OK ; }
GetLocation ( JSContext * aCx , JS :: Handle < JSObject * > aObj , JS :: Handle < jsid > aIdval , JS :: MutableHandle < JS :: Value > aVp ) { WorkerGlobalScope * scope = GetInstancePrivate ( aCx , aObj , sProperties [ SLOT_location ] . name ) ; if ( ! scope ) { return false ; } if ( JSVAL_IS_VOID ( scope -> mSlots [ SLOT_location ] ) ) { WorkerPrivate :: LocationInfo & info = scope -> mWorker -> GetLocationInfo ( ) ; nsRefPtr < WorkerLocation > location = WorkerLocation :: Create ( aCx , aObj , info ) ; if ( ! location ) { return false ; } scope -> mSlots [ SLOT_location ] = OBJECT_TO_JSVAL ( location -> GetJSObject ( ) ) ; } aVp . set ( scope -> mSlots [ SLOT_location ] ) ; return true ; }
static int verify_one_dev_extent ( struct btrfs_fs_info * fs_info , u64 chunk_offset , u64 devid , u64 physical_offset , u64 physical_len ) { struct extent_map_tree * em_tree = & fs_info -> mapping_tree . map_tree ; struct extent_map * em ; struct map_lookup * map ; struct btrfs_device * dev ; u64 stripe_len ; bool found = false ; int ret = 0 ; int i ; read_lock ( & em_tree -> lock ) ; em = lookup_extent_mapping ( em_tree , chunk_offset , 1 ) ; read_unlock ( & em_tree -> lock ) ; if ( ! em ) { btrfs_err ( fs_info , "dev extent physical offset %llu on devid %llu doesn't have corresponding chunk" , physical_offset , devid ) ; ret = - EUCLEAN ; goto out ; } map = em -> map_lookup ; stripe_len = calc_stripe_length ( map -> type , em -> len , map -> num_stripes ) ; if ( physical_len != stripe_len ) { btrfs_err ( fs_info , "dev extent physical offset %llu on devid %llu length doesn't match chunk %llu, have %llu expect %llu" , physical_offset , devid , em -> start , physical_len , stripe_len ) ; ret = - EUCLEAN ; goto out ; } for ( i = 0 ; i < map -> num_stripes ; i ++ ) { if ( map -> stripes [ i ] . dev -> devid == devid && map -> stripes [ i ] . physical == physical_offset ) { found = true ; if ( map -> verified_stripes >= map -> num_stripes ) { btrfs_err ( fs_info , "too many dev extents for chunk %llu found" , em -> start ) ; ret = - EUCLEAN ; goto out ; } map -> verified_stripes ++ ; break ; } } if ( ! found ) { btrfs_err ( fs_info , "dev extent physical offset %llu devid %llu has no corresponding chunk" , physical_offset , devid ) ; ret = - EUCLEAN ; } dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ; if ( ! dev ) { btrfs_err ( fs_info , "failed to find devid %llu" , devid ) ; ret = - EUCLEAN ; goto out ; } if ( dev -> disk_total_bytes == 0 ) { dev = find_device ( fs_info -> fs_devices -> seed , devid , NULL ) ; if ( ! dev ) { btrfs_err ( fs_info , "failed to find seed devid %llu" , devid ) ; ret = - EUCLEAN ; goto out ; } } if ( physical_offset + physical_len > dev -> disk_total_bytes ) { btrfs_err ( fs_info , "dev extent devid %llu physical offset %llu len %llu is beyond device boundary %llu" , devid , physical_offset , physical_len , dev -> disk_total_bytes ) ; ret = - EUCLEAN ; goto out ; } out : free_extent_map ( em ) ; return ret ; }
Node * WasmGraphBuilder :: BuildI32AsmjsDivS ( Node * left , Node * right ) { MachineOperatorBuilder * m = mcgraph ( ) -> machine ( ) ; Int32Matcher mr ( right ) ; if ( mr . HasValue ( ) ) { if ( mr . Value ( ) == 0 ) { return mcgraph ( ) -> Int32Constant ( 0 ) ; } else if ( mr . Value ( ) == - 1 ) { return graph ( ) -> NewNode ( m -> Int32Sub ( ) , mcgraph ( ) -> Int32Constant ( 0 ) , left ) ; } return graph ( ) -> NewNode ( m -> Int32Div ( ) , left , right , Control ( ) ) ; } if ( m -> Int32DivIsSafe ( ) ) { return graph ( ) -> NewNode ( m -> Int32Div ( ) , left , right , graph ( ) -> start ( ) ) ; } Diamond z ( graph ( ) , mcgraph ( ) -> common ( ) , graph ( ) -> NewNode ( m -> Word32Equal ( ) , right , mcgraph ( ) -> Int32Constant ( 0 ) ) , BranchHint :: kFalse ) ; Diamond n ( graph ( ) , mcgraph ( ) -> common ( ) , graph ( ) -> NewNode ( m -> Word32Equal ( ) , right , mcgraph ( ) -> Int32Constant ( - 1 ) ) , BranchHint :: kFalse ) ; Node * div = graph ( ) -> NewNode ( m -> Int32Div ( ) , left , right , z . if_false ) ; Node * neg = graph ( ) -> NewNode ( m -> Int32Sub ( ) , mcgraph ( ) -> Int32Constant ( 0 ) , left ) ; return n . Phi ( MachineRepresentation :: kWord32 , neg , z . Phi ( MachineRepresentation :: kWord32 , mcgraph ( ) -> Int32Constant ( 0 ) , div ) ) ; }
static void write_image_file ( const vpx_image_t * img , const int planes [ 3 ] , FILE * file ) { int i , y ; for ( i = 0 ; i < 3 ; ++ i ) { const int plane = planes [ i ] ; const unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; const int w = vpx_img_plane_width ( img , plane ) ; const int h = vpx_img_plane_height ( img , plane ) ; for ( y = 0 ; y < h ; ++ y ) { fwrite ( buf , 1 , w , file ) ; buf += stride ; } } }
void impeg2d_dec_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }
static int ptrace_attach ( struct task_struct * task , long request , unsigned long addr , unsigned long flags ) { bool seize = ( request == PTRACE_SEIZE ) ; int retval ; retval = - EIO ; if ( seize ) { if ( addr != 0 ) goto out ; if ( flags & ~ ( unsigned long ) PTRACE_O_MASK ) goto out ; flags = PT_PTRACED | PT_SEIZED | ( flags < < PT_OPT_FLAG_SHIFT ) ; } else { flags = PT_PTRACED ; } audit_ptrace ( task ) ; retval = - EPERM ; if ( unlikely ( task -> flags & PF_KTHREAD ) ) goto out ; if ( same_thread_group ( task , current ) ) goto out ; retval = - ERESTARTNOINTR ; if ( mutex_lock_interruptible ( & task -> signal -> cred_guard_mutex ) ) goto out ; task_lock ( task ) ; retval = __ptrace_may_access ( task , PTRACE_MODE_ATTACH_REALCREDS ) ; task_unlock ( task ) ; if ( retval ) goto unlock_creds ; write_lock_irq ( & tasklist_lock ) ; retval = - EPERM ; if ( unlikely ( task -> exit_state ) ) goto unlock_tasklist ; if ( task -> ptrace ) goto unlock_tasklist ; task -> ptrace = flags ; ptrace_link ( task , current ) ; if ( ! seize ) send_sig_info ( SIGSTOP , SEND_SIG_PRIV , task ) ; spin_lock ( & task -> sighand -> siglock ) ; if ( task_is_stopped ( task ) && task_set_jobctl_pending ( task , JOBCTL_TRAP_STOP | JOBCTL_TRAPPING ) ) signal_wake_up_state ( task , __TASK_STOPPED ) ; spin_unlock ( & task -> sighand -> siglock ) ; retval = 0 ; unlock_tasklist : write_unlock_irq ( & tasklist_lock ) ; unlock_creds : mutex_unlock ( & task -> signal -> cred_guard_mutex ) ; out : if ( ! retval ) { wait_on_bit ( & task -> jobctl , JOBCTL_TRAPPING_BIT , TASK_KILLABLE ) ; proc_ptrace_connector ( task , PTRACE_ATTACH ) ; } return retval ; }
MaybeHandle < Object > RegExpUtils :: GetLastIndex ( Isolate * isolate , Handle < JSReceiver > recv ) { if ( HasInitialRegExpMap ( isolate , * recv ) ) { return handle ( JSRegExp :: cast ( * recv ) -> last_index ( ) , isolate ) ; } else { return Object :: GetProperty ( isolate , recv , isolate -> factory ( ) -> lastIndex_string ( ) ) ; } }
int RegExpMacroAssemblerX64 :: CheckStackGuardState ( Address * return_address , Code * re_code , Address re_frame ) { return NativeRegExpMacroAssembler :: CheckStackGuardState ( frame_entry < Isolate * > ( re_frame , kIsolate ) , frame_entry < int > ( re_frame , kStartIndex ) , frame_entry < int > ( re_frame , kDirectCall ) == 1 , return_address , re_code , frame_entry_address < String * > ( re_frame , kInputString ) , frame_entry_address < const byte * > ( re_frame , kInputStart ) , frame_entry_address < const byte * > ( re_frame , kInputEnd ) ) ; }
static jstring NewStringUTF ( JNIEnv * env , const char * utf ) { if ( utf == nullptr ) { return nullptr ; } ScopedObjectAccess soa ( env ) ; mirror :: String * result = mirror :: String :: AllocFromModifiedUtf8 ( soa . Self ( ) , utf ) ; return soa . AddLocalReference < jstring > ( result ) ; }
TNode < Object > BaseCollectionsAssembler :: LoadAndNormalizeFixedArrayElement ( TNode < FixedArray > elements , TNode < IntPtrT > index ) { TNode < Object > element = LoadFixedArrayElement ( elements , index ) ; return Select < Object > ( IsTheHole ( element ) , [ = ] { return UndefinedConstant ( ) ; } , [ = ] { return element ; } ) ; }
bool MPEG4Source :: ensureMediaBufferAllocated ( int32_t aSize ) { if ( mBuffer -> size ( ) < aSize ) { ALOGE ( "Error insufficient memory, requested %u bytes (had:%u)" , aSize , mBuffer -> size ( ) ) ; mBuffer -> release ( ) ; mBuffer = NULL ; return false ; } return true ; }
static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case ' ' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : { int a = getnum ( fmt , MAXALIGN ) ; if ( ! isp2 ( a ) ) luaL_error ( L , "alignment %d is not a power of 2" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , "invalid format option '%c'" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }
BodyStream :: OnInputStreamReady ( nsIAsyncInputStream * aStream ) { AssertIsOnOwningThread ( ) ; MOZ_DIAGNOSTIC_ASSERT ( aStream ) ; Maybe < MutexAutoLock > lock ; lock . emplace ( mMutex ) ; if ( mState == eClosed ) { return NS_OK ; } nsAutoMicroTask mt ; AutoEntryScript aes ( mGlobal , "fetch body data available" ) ; MOZ_DIAGNOSTIC_ASSERT ( mInputStream ) ; MOZ_DIAGNOSTIC_ASSERT ( mState == eReading || mState == eChecking ) ; JSObject * streamObj = mStreamHolder -> GetReadableStreamBody ( ) ; if ( ! streamObj ) { return NS_ERROR_FAILURE ; } JSContext * cx = aes . cx ( ) ; JS :: Rooted < JSObject * > stream ( cx , streamObj ) ; uint64_t size = 0 ; nsresult rv = mInputStream -> Available ( & size ) ; if ( NS_SUCCEEDED ( rv ) && size == 0 ) { rv = NS_BASE_STREAM_CLOSED ; } if ( rv == NS_BASE_STREAM_CLOSED || NS_WARN_IF ( NS_FAILED ( rv ) ) ) { ErrorPropagation ( cx , * lock , stream , rv ) ; return NS_OK ; } if ( mState == eChecking ) { mState = eWaiting ; return NS_OK ; } mState = eWriting ; lock . reset ( ) ; DebugOnly < bool > ok = JS :: ReadableStreamUpdateDataAvailableFromSource ( cx , stream , size ) ; return NS_OK ; }
cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { size_t ss = CDF_SHORT_SEC_SIZE ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ; if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) { DPRINTF ( ( "Out of bounds read %" SIZE_T_FORMAT "u > %" SIZE_T_FORMAT "u\n" , pos , CDF_SEC_SIZE ( h ) * sst -> sst_len ) ) ; return - 1 ; } ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ; return len ; }
void naludmx_create_avc_decoder_config ( GF_NALUDmxCtx * ctx , u8 * * dsi , u32 * dsi_size , u8 * * dsi_enh , u32 * dsi_enh_size , u32 * max_width , u32 * max_height , u32 * max_enh_width , u32 * max_enh_height , GF_Fraction * sar ) { u32 i , count ; Bool first = GF_TRUE ; Bool first_svc = GF_TRUE ; GF_AVCConfig * cfg ; GF_AVCConfig * avcc ; GF_AVCConfig * svcc ; u32 max_w , max_h , max_ew , max_eh ; max_w = max_h = max_ew = max_eh = 0 ; sar -> num = sar -> den = 0 ; avcc = gf_odf_avc_cfg_new ( ) ; svcc = gf_odf_avc_cfg_new ( ) ; avcc -> nal_unit_size = ctx -> nal_length ; svcc -> nal_unit_size = ctx -> nal_length ; ctx -> is_mvc = GF_FALSE ; count = gf_list_count ( ctx -> sps ) ; for ( i = 0 ; i < count ; i ++ ) { Bool is_svc = GF_FALSE ; GF_NALUFFParam * sl = gf_list_get ( ctx -> sps , i ) ; AVC_SPS * sps = & ctx -> avc_state -> sps [ sl -> id ] ; u32 nal_type = sl -> data [ 0 ] & 0x1F ; if ( ( sps -> profile_idc == 118 ) || ( sps -> profile_idc == 128 ) ) { ctx -> is_mvc = GF_TRUE ; } if ( ctx -> explicit ) { cfg = svcc ; } else if ( nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM ) { cfg = svcc ; is_svc = GF_TRUE ; } else { cfg = avcc ; } if ( first || ( is_svc && first_svc ) ) { cfg -> configurationVersion = 1 ; cfg -> profile_compatibility = sps -> prof_compat ; cfg -> AVCProfileIndication = sps -> profile_idc ; cfg -> AVCLevelIndication = sps -> level_idc ; cfg -> chroma_format = sps -> chroma_format ; cfg -> luma_bit_depth = 8 + sps -> luma_bit_depth_m8 ; cfg -> chroma_bit_depth = 8 + sps -> chroma_bit_depth_m8 ; if ( ! gf_avc_is_rext_profile ( cfg -> AVCProfileIndication ) && ( ( cfg -> chroma_format > 1 ) || ( cfg -> luma_bit_depth > 8 ) || ( cfg -> chroma_bit_depth > 8 ) ) ) { if ( ( cfg -> luma_bit_depth > 8 ) || ( cfg -> chroma_bit_depth > 8 ) ) { cfg -> AVCProfileIndication = 110 ; } else { cfg -> AVCProfileIndication = ( cfg -> chroma_format == 3 ) ? 244 : 122 ; } } if ( sps -> vui_parameters_present_flag && sps -> vui . par_num && sps -> vui . par_den ) { sar -> num = sps -> vui . par_num ; sar -> den = sps -> vui . par_den ; } ctx -> interlaced = sps -> frame_mbs_only_flag ? GF_FALSE : GF_TRUE ; if ( first && ( ! ctx -> fps . num || ! ctx -> fps . den ) && sps -> vui . timing_info_present_flag && ( sps -> vui . time_scale <= 1000 * sps -> vui . num_units_in_tick ) ) { u8 DeltaTfiDivisorIdx ; if ( ! sps -> vui . pic_struct_present_flag ) { DeltaTfiDivisorIdx = 1 + ( 1 - ctx -> avc_state -> s_info . field_pic_flag ) ; } else { if ( ! ctx -> avc_state -> sei . pic_timing . pic_struct ) DeltaTfiDivisorIdx = 2 ; else if ( ctx -> avc_state -> sei . pic_timing . pic_struct == 8 ) DeltaTfiDivisorIdx = 6 ; else DeltaTfiDivisorIdx = ( ctx -> avc_state -> sei . pic_timing . pic_struct + 1 ) / 2 ; } if ( ! ctx -> timescale ) { ctx -> cur_fps . num = 2 * sps -> vui . time_scale ; ctx -> cur_fps . den = 2 * sps -> vui . num_units_in_tick * DeltaTfiDivisorIdx ; if ( ! ctx -> fps . num && ctx -> dts == ctx -> fps . den ) ctx -> dts = ctx -> cur_fps . den ; } if ( ! sps -> vui . fixed_frame_rate_flag ) GF_LOG ( GF_LOG_INFO , GF_LOG_PARSER , ( "[%s] Possible Variable Frame Rate: VUI \"fixed_frame_rate_flag\" absent\n" , ctx -> log_name ) ) ; } ctx -> fps = ctx -> cur_fps ; } first = GF_FALSE ; if ( is_svc ) { first_svc = GF_FALSE ; if ( sps -> width > max_ew ) max_ew = sps -> width ; if ( sps -> height > max_eh ) max_eh = sps -> height ; } else { if ( sps -> width > max_w ) max_w = sps -> width ; if ( sps -> height > max_h ) max_h = sps -> height ; } if ( ! ctx -> analyze ) gf_list_add ( cfg -> sequenceParameterSets , sl ) ; } cfg = ctx -> explicit ? svcc : avcc ; count = gf_list_count ( ctx -> sps_ext ) ; for ( i = 0 ; i < count ; i ++ ) { GF_NALUFFParam * sl = gf_list_get ( ctx -> sps_ext , i ) ; if ( ! cfg -> sequenceParameterSetExtensions ) cfg -> sequenceParameterSetExtensions = gf_list_new ( ) ; if ( ! ctx -> analyze ) gf_list_add ( cfg -> sequenceParameterSetExtensions , sl ) ; } cfg = ctx -> explicit ? svcc : avcc ; count = gf_list_count ( ctx -> pps ) ; for ( i = 0 ; i < count ; i ++ ) { GF_NALUFFParam * sl = gf_list_get ( ctx -> pps , i ) ; if ( ! ctx -> analyze ) gf_list_add ( cfg -> pictureParameterSets , sl ) ; } cfg = svcc ; count = gf_list_count ( ctx -> pps_svc ) ; for ( i = 0 ; i < count ; i ++ ) { GF_NALUFFParam * sl = gf_list_get ( ctx -> pps_svc , i ) ; if ( ! ctx -> analyze ) gf_list_add ( cfg -> pictureParameterSets , sl ) ; } * dsi = * dsi_enh = NULL ; * dsi_size = * dsi_enh_size = 0 ; if ( ctx -> explicit ) { gf_odf_avc_cfg_write ( svcc , dsi , dsi_size ) ; } else { gf_odf_avc_cfg_write ( avcc , dsi , dsi_size ) ; if ( gf_list_count ( svcc -> sequenceParameterSets ) || svcc -> sequenceParameterSetExtensions ) { gf_odf_avc_cfg_write ( svcc , dsi_enh , dsi_enh_size ) ; } } gf_list_reset ( avcc -> sequenceParameterSets ) ; gf_list_reset ( avcc -> sequenceParameterSetExtensions ) ; gf_list_reset ( avcc -> pictureParameterSets ) ; gf_list_reset ( svcc -> sequenceParameterSets ) ; gf_list_reset ( svcc -> sequenceParameterSetExtensions ) ; gf_list_reset ( svcc -> pictureParameterSets ) ; gf_odf_avc_cfg_del ( avcc ) ; gf_odf_avc_cfg_del ( svcc ) ; * max_width = max_w ; * max_height = max_h ; * max_enh_width = max_ew ; * max_enh_height = max_eh ; }
bool Scanner :: fill ( size_t need ) { if ( eof ) return false ; pop_finished_files ( ) ; DASSERT ( bot <= tok && tok <= lim ) ; size_t free = static_cast < size_t > ( tok - bot ) ; size_t copy = static_cast < size_t > ( lim - tok ) ; if ( free >= need ) { memmove ( bot , tok , copy ) ; shift_ptrs_and_fpos ( - static_cast < ptrdiff_t > ( free ) ) ; } else { BSIZE += std :: max ( BSIZE , need ) ; char * buf = new char [ BSIZE + YYMAXFILL ] ; if ( ! buf ) fatal ( "out of memory" ) ; memmove ( buf , tok , copy ) ; shift_ptrs_and_fpos ( buf - bot ) ; delete [ ] bot ; bot = buf ; free = BSIZE - copy ; } if ( ! read ( free ) ) { eof = lim ; memset ( lim , 0 , YYMAXFILL ) ; lim += YYMAXFILL ; } return true ; }
const char * V8HeapExplorer :: GetSystemEntryName ( HeapObject * object ) { switch ( object -> map ( ) -> instance_type ( ) ) { case MAP_TYPE : switch ( Map :: cast ( object ) -> instance_type ( ) ) { #define MAKE_STRING_MAP_CASE(instance_type, size, name, Name) \  case instance_type: return "system / Map (" #Name ")"; STRING_TYPE_LIST ( MAKE_STRING_MAP_CASE ) #undef MAKE_STRING_MAP_CASE default : return "system / Map" ; } case CELL_TYPE : return "system / Cell" ; case PROPERTY_CELL_TYPE : return "system / PropertyCell" ; case FOREIGN_TYPE : return "system / Foreign" ; case ODDBALL_TYPE : return "system / Oddball" ; case ALLOCATION_SITE_TYPE : return "system / AllocationSite" ; #define MAKE_STRUCT_CASE(NAME, Name, name) \  case NAME##_TYPE: return "system / "#Name; STRUCT_LIST ( MAKE_STRUCT_CASE ) #undef MAKE_STRUCT_CASE default : return "system" ; } }
AstRawString * AstValueFactory :: GetOneByteStringInternal ( Vector < const uint8_t > literal ) { if ( literal . length ( ) == 1 && IsInRange ( literal [ 0 ] , 'a' , 'z' ) ) { int key = literal [ 0 ] - 'a' ; if ( one_character_strings_ [ key ] == nullptr ) { uint32_t hash_field = StringHasher :: HashSequentialString < uint8_t > ( literal . start ( ) , literal . length ( ) , hash_seed_ ) ; one_character_strings_ [ key ] = GetString ( hash_field , true , literal ) ; } return one_character_strings_ [ key ] ; } uint32_t hash_field = StringHasher :: HashSequentialString < uint8_t > ( literal . start ( ) , literal . length ( ) , hash_seed_ ) ; return GetString ( hash_field , true , literal ) ; }
xmlXPathCompVariableReference ( xmlXPathParserContextPtr ctxt ) { xmlChar * name ; xmlChar * prefix ; SKIP_BLANKS ; if ( CUR != '$' ) { XP_ERROR ( XPATH_VARIABLE_REF_ERROR ) ; } NEXT ; name = xmlXPathParseQName ( ctxt , & prefix ) ; if ( name == NULL ) { XP_ERROR ( XPATH_VARIABLE_REF_ERROR ) ; } ctxt -> comp -> last = - 1 ; PUSH_LONG_EXPR ( XPATH_OP_VARIABLE , 0 , 0 , 0 , name , prefix ) ; SKIP_BLANKS ; if ( ( ctxt -> context != NULL ) && ( ctxt -> context -> flags & XML_XPATH_NOVAR ) ) { XP_ERROR ( XPATH_FORBID_VARIABLE_ERROR ) ; } }
DrawTargetCairo :: CreateShadowDrawTarget ( const IntSize & aSize , SurfaceFormat aFormat , float aSigma ) const { cairo_surface_t * similar = cairo_surface_create_similar ( cairo_get_target ( mContext ) , GfxFormatToCairoContent ( aFormat ) , aSize . width , aSize . height ) ; if ( cairo_surface_status ( similar ) ) { return nullptr ; } if ( aSigma == 0.0F ) { RefPtr < DrawTargetCairo > target = new DrawTargetCairo ( ) ; target -> InitAlreadyReferenced ( similar , aSize ) ; return target . forget ( ) ; } cairo_surface_t * blursurf = cairo_image_surface_create ( CAIRO_FORMAT_A8 , aSize . width , aSize . height ) ; if ( cairo_surface_status ( blursurf ) ) { return nullptr ; } cairo_surface_t * tee = cairo_tee_surface_create ( blursurf ) ; cairo_surface_destroy ( blursurf ) ; if ( cairo_surface_status ( tee ) ) { cairo_surface_destroy ( similar ) ; return nullptr ; } cairo_tee_surface_add ( tee , similar ) ; cairo_surface_destroy ( similar ) ; RefPtr < DrawTargetCairo > target = new DrawTargetCairo ( ) ; target -> InitAlreadyReferenced ( tee , aSize ) ; return target . forget ( ) ; }
bool AsyncStreamingProcessor :: ProcessModuleHeader ( Vector < const uint8_t > bytes , uint32_t offset ) { TRACE_STREAMING ( "Process module header...\n" ) ; decoder_ . StartDecoding ( job_ -> async_counters ( ) . get ( ) , job_ -> isolate ( ) -> wasm_engine ( ) -> allocator ( ) ) ; decoder_ . DecodeModuleHeader ( bytes , offset ) ; if ( ! decoder_ . ok ( ) ) { FinishAsyncCompileJobWithError ( decoder_ . FinishDecoding ( false ) ) ; return false ; } return true ; }
int validate_camera_metadata_structure ( const camera_metadata_t * metadata , const size_t * expected_size ) { if ( metadata == NULL ) { ALOGE ( "%s: metadata is null!" , __FUNCTION__ ) ; return ERROR ; } { static const struct { const char * name ; size_t alignment ; } alignments [ ] = { { . name = "camera_metadata" , . alignment = METADATA_ALIGNMENT } , { . name = "camera_metadata_buffer_entry" , . alignment = ENTRY_ALIGNMENT } , { . name = "camera_metadata_data" , . alignment = DATA_ALIGNMENT } , } ; for ( size_t i = 0 ; i < sizeof ( alignments ) / sizeof ( alignments [ 0 ] ) ; ++ i ) { uintptr_t aligned_ptr = ALIGN_TO ( metadata , alignments [ i ] . alignment ) ; if ( ( uintptr_t ) metadata != aligned_ptr ) { ALOGE ( "%s: Metadata pointer is not aligned (actual %p, " "expected %p) to type %s" , __FUNCTION__ , metadata , ( void * ) aligned_ptr , alignments [ i ] . name ) ; return ERROR ; } } } if ( expected_size != NULL && metadata -> size > * expected_size ) { ALOGE ( "%s: Metadata size (%" PRIu32 ") should be <= expected size (%zu)" , __FUNCTION__ , metadata -> size , * expected_size ) ; return ERROR ; } if ( metadata -> entry_count > metadata -> entry_capacity ) { ALOGE ( "%s: Entry count (%" PRIu32 ") should be <= entry capacity " "(%" PRIu32 ")" , __FUNCTION__ , metadata -> entry_count , metadata -> entry_capacity ) ; return ERROR ; } const metadata_uptrdiff_t entries_end = metadata -> entries_start + metadata -> entry_capacity ; if ( entries_end < metadata -> entries_start || entries_end > metadata -> data_start ) { ALOGE ( "%s: Entry start + capacity (%" PRIu32 ") should be <= data start " "(%" PRIu32 ")" , __FUNCTION__ , ( metadata -> entries_start + metadata -> entry_capacity ) , metadata -> data_start ) ; return ERROR ; } const metadata_uptrdiff_t data_end = metadata -> data_start + metadata -> data_capacity ; if ( data_end < metadata -> data_start || data_end > metadata -> size ) { ALOGE ( "%s: Data start + capacity (%" PRIu32 ") should be <= total size " "(%" PRIu32 ")" , __FUNCTION__ , ( metadata -> data_start + metadata -> data_capacity ) , metadata -> size ) ; return ERROR ; } const metadata_size_t entry_count = metadata -> entry_count ; camera_metadata_buffer_entry_t * entries = get_entries ( metadata ) ; for ( size_t i = 0 ; i < entry_count ; ++ i ) { if ( ( uintptr_t ) & entries [ i ] != ALIGN_TO ( & entries [ i ] , ENTRY_ALIGNMENT ) ) { ALOGE ( "%s: Entry index %zu had bad alignment (address %p)," " expected alignment %zu" , __FUNCTION__ , i , & entries [ i ] , ENTRY_ALIGNMENT ) ; return ERROR ; } camera_metadata_buffer_entry_t entry = entries [ i ] ; if ( entry . type >= NUM_TYPES ) { ALOGE ( "%s: Entry index %zu had a bad type %d" , __FUNCTION__ , i , entry . type ) ; return ERROR ; } uint32_t tag_section = entry . tag > > 16 ; int tag_type = get_camera_metadata_tag_type ( entry . tag ) ; if ( tag_type != ( int ) entry . type && tag_section < VENDOR_SECTION ) { ALOGE ( "%s: Entry index %zu had tag type %d, but the type was %d" , __FUNCTION__ , i , tag_type , entry . type ) ; return ERROR ; } size_t data_size = calculate_camera_metadata_entry_data_size ( entry . type , entry . count ) ; if ( data_size != 0 ) { camera_metadata_data_t * data = ( camera_metadata_data_t * ) ( get_data ( metadata ) + entry . data . offset ) ; if ( ( uintptr_t ) data != ALIGN_TO ( data , DATA_ALIGNMENT ) ) { ALOGE ( "%s: Entry index %zu had bad data alignment (address %p)," " expected align %zu, (tag name %s, data size %zu)" , __FUNCTION__ , i , data , DATA_ALIGNMENT , get_camera_metadata_tag_name ( entry . tag ) ? : "unknown" , data_size ) ; return ERROR ; } size_t data_entry_end = entry . data . offset + data_size ; if ( data_entry_end < entry . data . offset || data_entry_end > metadata -> data_capacity ) { ALOGE ( "%s: Entry index %zu data ends (%zu) beyond the capacity " "%" PRIu32 , __FUNCTION__ , i , data_entry_end , metadata -> data_capacity ) ; return ERROR ; } } else if ( entry . count == 0 ) { if ( entry . data . offset != 0 ) { ALOGE ( "%s: Entry index %zu had 0 items, but offset was non-0 " "(%" PRIu32 "), tag name: %s" , __FUNCTION__ , i , entry . data . offset , get_camera_metadata_tag_name ( entry . tag ) ? : "unknown" ) ; return ERROR ; } } } return OK ; }
void AccessorAssembler :: LoadIC_Uninitialized ( const LoadICParameters * p ) { Label miss ( this , Label :: kDeferred ) ; Node * receiver = p -> receiver ; GotoIf ( TaggedIsSmi ( receiver ) , & miss ) ; Node * receiver_map = LoadMap ( receiver ) ; Node * instance_type = LoadMapInstanceType ( receiver_map ) ; StoreFeedbackVectorSlot ( p -> vector , p -> slot , LoadRoot ( Heap :: kpremonomorphic_symbolRootIndex ) , SKIP_WRITE_BARRIER , 0 , SMI_PARAMETERS ) ; StoreWeakReferenceInFeedbackVector ( p -> vector , p -> slot , receiver_map , kPointerSize , SMI_PARAMETERS ) ; { Label not_function_prototype ( this , Label :: kDeferred ) ; GotoIfNot ( InstanceTypeEqual ( instance_type , JS_FUNCTION_TYPE ) , & not_function_prototype ) ; GotoIfNot ( IsPrototypeString ( p -> name ) , & not_function_prototype ) ; GotoIfPrototypeRequiresRuntimeLookup ( CAST ( receiver ) , CAST ( receiver_map ) , & not_function_prototype ) ; Return ( LoadJSFunctionPrototype ( receiver , & miss ) ) ; BIND ( & not_function_prototype ) ; } GenericPropertyLoad ( receiver , receiver_map , instance_type , p , & miss , kDontUseStubCache ) ; BIND ( & miss ) ; { StoreFeedbackVectorSlot ( p -> vector , p -> slot , LoadRoot ( Heap :: kuninitialized_symbolRootIndex ) , SKIP_WRITE_BARRIER , 0 , SMI_PARAMETERS ) ; TailCallRuntime ( Runtime :: kLoadIC_Miss , p -> context , p -> receiver , p -> name , p -> slot , p -> vector ) ; } }
void IncrementalMarking :: Start ( GarbageCollectionReason gc_reason ) { if ( FLAG_trace_incremental_marking ) { int old_generation_size_mb = static_cast < int > ( heap ( ) -> OldGenerationSizeOfObjects ( ) / MB ) ; int old_generation_limit_mb = static_cast < int > ( heap ( ) -> old_generation_allocation_limit ( ) / MB ) ; heap ( ) -> isolate ( ) -> PrintWithTimestamp ( "[IncrementalMarking] Start (%s): old generation %dMB, limit %dMB, " "slack %dMB\n" , Heap :: GarbageCollectionReasonToString ( gc_reason ) , old_generation_size_mb , old_generation_limit_mb , Max ( 0 , old_generation_limit_mb - old_generation_size_mb ) ) ; } DCHECK ( FLAG_incremental_marking ) ; DCHECK ( state_ == STOPPED ) ; DCHECK ( heap_ -> gc_state ( ) == Heap :: NOT_IN_GC ) ; DCHECK ( ! heap_ -> isolate ( ) -> serializer_enabled ( ) ) ; Counters * counters = heap_ -> isolate ( ) -> counters ( ) ; counters -> incremental_marking_reason ( ) -> AddSample ( static_cast < int > ( gc_reason ) ) ; HistogramTimerScope incremental_marking_scope ( counters -> gc_incremental_marking_start ( ) ) ; TRACE_EVENT0 ( "v8" , "V8.GCIncrementalMarkingStart" ) ; TRACE_GC ( heap ( ) -> tracer ( ) , GCTracer :: Scope :: MC_INCREMENTAL_START ) ; heap_ -> tracer ( ) -> NotifyIncrementalMarkingStart ( ) ; start_time_ms_ = heap ( ) -> MonotonicallyIncreasingTimeInMs ( ) ; initial_old_generation_size_ = heap_ -> OldGenerationSizeOfObjects ( ) ; old_generation_allocation_counter_ = heap_ -> OldGenerationAllocationCounter ( ) ; bytes_allocated_ = 0 ; bytes_marked_ahead_of_schedule_ = 0 ; bytes_marked_concurrently_ = 0 ; should_hurry_ = false ; was_activated_ = true ; if ( ! heap_ -> mark_compact_collector ( ) -> sweeping_in_progress ( ) ) { StartMarking ( ) ; } else { if ( FLAG_trace_incremental_marking ) { heap ( ) -> isolate ( ) -> PrintWithTimestamp ( "[IncrementalMarking] Start sweeping.\n" ) ; } SetState ( SWEEPING ) ; } heap_ -> AddAllocationObserversToAllSpaces ( & old_generation_observer_ , & new_generation_observer_ ) ; incremental_marking_job ( ) -> Start ( heap_ ) ; }
} static void ExportIndexQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const Quantum * magick_restrict p , unsigned char * magick_restrict q , ExceptionInfo * exception ) { ssize_t x ; ssize_t bit ; if ( image -> storage_class != PseudoClass ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , ImageError , "ColormappedImageRequired" , "`%s'" , image -> filename ) ; return ; } switch ( quantum_info -> depth ) { case 1 : { unsigned char pixel ; for ( x = ( ( ssize_t ) number_pixels - 7 ) ; x > 0 ; x -= 8 ) { pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q = ( ( pixel & 0x01 ) < < 7 ) ; p += GetPixelChannels ( image ) ; pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q |= ( ( pixel & 0x01 ) < < 6 ) ; p += GetPixelChannels ( image ) ; pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q |= ( ( pixel & 0x01 ) < < 5 ) ; p += GetPixelChannels ( image ) ; pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q |= ( ( pixel & 0x01 ) < < 4 ) ; p += GetPixelChannels ( image ) ; pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q |= ( ( pixel & 0x01 ) < < 3 ) ; p += GetPixelChannels ( image ) ; pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q |= ( ( pixel & 0x01 ) < < 2 ) ; p += GetPixelChannels ( image ) ; pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q |= ( ( pixel & 0x01 ) < < 1 ) ; p += GetPixelChannels ( image ) ; pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q |= ( ( pixel & 0x01 ) < < 0 ) ; p += GetPixelChannels ( image ) ; q ++ ; } if ( ( number_pixels % 8 ) != 0 ) { * q = '\0' ; for ( bit = 7 ; bit >= ( ssize_t ) ( 8 - ( number_pixels % 8 ) ) ; bit -- ) { pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q |= ( ( pixel & 0x01 ) < < ( unsigned char ) bit ) ; p += GetPixelChannels ( image ) ; } q ++ ; } break ; } case 4 : { unsigned char pixel ; for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 1 ) ; x += 2 ) { pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q = ( ( pixel & 0xf ) < < 4 ) ; p += GetPixelChannels ( image ) ; pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q |= ( ( pixel & 0xf ) < < 0 ) ; p += GetPixelChannels ( image ) ; q ++ ; } if ( ( number_pixels % 2 ) != 0 ) { pixel = ( unsigned char ) GetPixelIndex ( image , p ) ; * q = ( ( pixel & 0xf ) < < 4 ) ; p += GetPixelChannels ( image ) ; q ++ ; } break ; } case 8 : { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { q = PopCharPixel ( ( unsigned char ) GetPixelIndex ( image , p ) , q ) ; p += GetPixelChannels ( image ) ; q += quantum_info -> pad ; } break ; } case 16 : { if ( quantum_info -> format == FloatingPointQuantumFormat ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { q = PopShortPixel ( quantum_info -> endian , SinglePrecisionToHalf ( QuantumScale * GetPixelIndex ( image , p ) ) , q ) ; p += GetPixelChannels ( image ) ; q += quantum_info -> pad ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { q = PopShortPixel ( quantum_info -> endian , ( unsigned short ) GetPixelIndex ( image , p ) , q ) ; p += GetPixelChannels ( image ) ; q += quantum_info -> pad ; } break ; } case 32 : { if ( quantum_info -> format == FloatingPointQuantumFormat ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { q = PopFloatPixel ( quantum_info , ( float ) GetPixelIndex ( image , p ) , q ) ; p += GetPixelChannels ( image ) ; q += quantum_info -> pad ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { q = PopLongPixel ( quantum_info -> endian , ( unsigned int ) GetPixelIndex ( image , p ) , q ) ; p += GetPixelChannels ( image ) ; q += quantum_info -> pad ; } break ; } case 64 : { if ( quantum_info -> format == FloatingPointQuantumFormat ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { q = PopDoublePixel ( quantum_info , ( double ) GetPixelIndex ( image , p ) , q ) ; p += GetPixelChannels ( image ) ; q += quantum_info -> pad ; } break ; } } default : { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { q = PopQuantumPixel ( quantum_info , GetPixelIndex ( image , p ) , q ) ; p += GetPixelChannels ( image ) ; q += quantum_info -> pad ; } break ; }
void RawMachineAssembler :: Switch ( Node * index , RawMachineLabel * default_label , const int32_t * case_values , RawMachineLabel * * case_labels , size_t case_count ) { DCHECK_NE ( schedule ( ) -> end ( ) , current_block_ ) ; size_t succ_count = case_count + 1 ; Node * switch_node = AddNode ( common ( ) -> Switch ( succ_count ) , index ) ; BasicBlock * * succ_blocks = zone ( ) -> NewArray < BasicBlock * > ( succ_count ) ; for ( size_t index = 0 ; index < case_count ; ++ index ) { int32_t case_value = case_values [ index ] ; BasicBlock * case_block = schedule ( ) -> NewBasicBlock ( ) ; Node * case_node = graph ( ) -> NewNode ( common ( ) -> IfValue ( case_value ) , switch_node ) ; schedule ( ) -> AddNode ( case_block , case_node ) ; schedule ( ) -> AddGoto ( case_block , Use ( case_labels [ index ] ) ) ; succ_blocks [ index ] = case_block ; } BasicBlock * default_block = schedule ( ) -> NewBasicBlock ( ) ; Node * default_node = graph ( ) -> NewNode ( common ( ) -> IfDefault ( ) , switch_node ) ; schedule ( ) -> AddNode ( default_block , default_node ) ; schedule ( ) -> AddGoto ( default_block , Use ( default_label ) ) ; succ_blocks [ case_count ] = default_block ; schedule ( ) -> AddSwitch ( CurrentBlock ( ) , switch_node , succ_blocks , succ_count ) ; current_block_ = nullptr ; }
void IC :: TraceIC ( const char * type , Handle < Object > name ) { if ( FLAG_ic_stats ) { if ( AddressIsDeoptimizedCode ( ) ) return ; State new_state = nexus ( ) -> StateFromFeedback ( ) ; TraceIC ( type , name , state ( ) , new_state ) ; } }
bool Scope :: RemoveUnresolved ( VariableProxy * var ) { if ( unresolved_ == var ) { unresolved_ = var -> next_unresolved ( ) ; var -> set_next_unresolved ( nullptr ) ; return true ; } VariableProxy * current = unresolved_ ; while ( current != nullptr ) { VariableProxy * next = current -> next_unresolved ( ) ; if ( var == next ) { current -> set_next_unresolved ( next -> next_unresolved ( ) ) ; var -> set_next_unresolved ( nullptr ) ; return true ; } current = next ; } return false ; }
static void bond_setup ( struct net_device * bond_dev ) { struct bonding * bond = netdev_priv ( bond_dev ) ; rwlock_init ( & bond -> lock ) ; rwlock_init ( & bond -> curr_slave_lock ) ; bond -> params = bonding_defaults ; bond -> dev = bond_dev ; INIT_LIST_HEAD ( & bond -> vlan_list ) ; ether_setup ( bond_dev ) ; bond_dev -> netdev_ops = & bond_netdev_ops ; bond_dev -> ethtool_ops = & bond_ethtool_ops ; bond_set_mode_ops ( bond , bond -> params . mode ) ; bond_dev -> destructor = bond_destructor ; bond_dev -> tx_queue_len = 0 ; bond_dev -> flags |= IFF_MASTER | IFF_MULTICAST ; bond_dev -> priv_flags |= IFF_BONDING ; bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; bond_dev -> features |= NETIF_F_VLAN_CHALLENGED ; bond_dev -> features |= NETIF_F_LLTX ; bond_dev -> hw_features = BOND_VLAN_FEATURES | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER ; bond_dev -> hw_features &= ~ ( NETIF_F_ALL_CSUM & ~ NETIF_F_NO_CSUM ) ; bond_dev -> features |= bond_dev -> hw_features ; }
void FillFormField ( const FormFieldData & data , bool is_initiating_node , blink :: WebFormControlElement * field ) { if ( data . value . empty ( ) ) return ; if ( ! data . is_autofilled ) return ; WebInputElement * input_element = toWebInputElement ( field ) ; if ( IsCheckableElement ( input_element ) ) { input_element -> setChecked ( data . is_checked , true ) ; } else { base :: string16 value = data . value ; if ( IsTextInput ( input_element ) || IsMonthInput ( input_element ) ) { TruncateString ( & value , input_element -> maxLength ( ) ) ; } field -> setValue ( value , true ) ; } if ( ! field -> document ( ) . frame ( ) ) return ; field -> setAutofilled ( true ) ; if ( is_initiating_node && ( ( IsTextInput ( input_element ) || IsMonthInput ( input_element ) ) || IsTextAreaElement ( * field ) ) ) { int length = field -> value ( ) . length ( ) ; field -> setSelectionRange ( length , length ) ; field -> document ( ) . frame ( ) -> unmarkText ( ) ; } }
DOMSVGTransformList :: IndexedGetter ( uint32_t index , bool & found , ErrorResult & error ) { if ( IsAnimValList ( ) ) { Element ( ) -> FlushAnimations ( ) ; } found = index < LengthNoFlush ( ) ; if ( found ) { EnsureItemAt ( index ) ; return mItems [ index ] ; } return nullptr ; }
void CodeStatistics :: CollectCodeCommentStatistics ( HeapObject * obj , Isolate * isolate ) { if ( ! obj -> IsCode ( ) ) { return ; } Code * code = Code :: cast ( obj ) ; RelocIterator it ( code ) ; int delta = 0 ; Address prev_pc = code -> raw_instruction_start ( ) ; while ( ! it . done ( ) ) { if ( it . rinfo ( ) -> rmode ( ) == RelocInfo :: COMMENT ) { delta += static_cast < int > ( it . rinfo ( ) -> pc ( ) - prev_pc ) ; CollectCommentStatistics ( isolate , & it ) ; prev_pc = it . rinfo ( ) -> pc ( ) ; } it . next ( ) ; } DCHECK ( code -> raw_instruction_start ( ) <= prev_pc && prev_pc <= code -> raw_instruction_end ( ) ) ; delta += static_cast < int > ( code -> raw_instruction_end ( ) - prev_pc ) ; EnterComment ( isolate , "NoComment" , delta ) ; }
static void Generate_OnStackReplacementHelper ( MacroAssembler * masm , bool has_handler_frame ) { if ( has_handler_frame ) { __ LoadP ( r2 , MemOperand ( fp , StandardFrameConstants :: kCallerFPOffset ) ) ; __ LoadP ( r2 , MemOperand ( r2 , JavaScriptFrameConstants :: kFunctionOffset ) ) ; } else { __ LoadP ( r2 , MemOperand ( fp , JavaScriptFrameConstants :: kFunctionOffset ) ) ; } { FrameScope scope ( masm , StackFrame :: INTERNAL ) ; __ push ( r2 ) ; __ CallRuntime ( Runtime :: kCompileForOnStackReplacement ) ; } Label skip ; __ CmpSmiLiteral ( r2 , Smi :: kZero , r0 ) ; __ bne ( & skip ) ; __ Ret ( ) ; __ bind ( & skip ) ; if ( has_handler_frame ) { __ LeaveFrame ( StackFrame :: STUB ) ; } __ LoadP ( r3 , FieldMemOperand ( r2 , Code :: kDeoptimizationDataOffset ) ) ; __ LoadP ( r3 , FieldMemOperand ( r3 , FixedArray :: OffsetOfElementAt ( DeoptimizationData :: kOsrPcOffsetIndex ) ) ) ; __ SmiUntag ( r3 ) ; __ AddP ( r2 , r3 ) ; __ AddP ( r0 , r2 , Operand ( Code :: kHeaderSize - kHeapObjectTag ) ) ; __ LoadRR ( r14 , r0 ) ; __ Ret ( ) ; }
bool OnlyLastArgIsSpread ( ZonePtrList < Expression > * args ) { for ( int i = 0 ; i < args -> length ( ) - 1 ; i ++ ) { if ( args -> at ( i ) -> IsSpread ( ) ) { return false ; } } return args -> at ( args -> length ( ) - 1 ) -> IsSpread ( ) ; }
gray_start_cell ( RAS_ARG_ TCoord ex , TCoord ey ) { if ( ex > ras . max_ex ) ex = ( TCoord ) ( ras . max_ex ) ; if ( ex < ras . min_ex ) ex = ( TCoord ) ( ras . min_ex - 1 ) ; ras . area = 0 ; ras . cover = 0 ; ras . ex = ex - ras . min_ex ; ras . ey = ey - ras . min_ey ; ras . last_ey = SUBPIXELS ( ey ) ; ras . invalid = 0 ; gray_set_cell ( RAS_VAR_ ex , ey ) ; }
static ssize_t available_instances_show ( struct mdev_type * mtype , struct mdev_type_attribute * attr , char * buf ) { const struct mbochs_type * type = & mbochs_types [ mtype_get_type_group_id ( mtype ) ] ; int count = ( max_mbytes - mbochs_used_mbytes ) / type -> mbytes ; return sprintf ( buf , "%d\n" , count ) ; }
TPMI_ECC_CURVE_Unmarshal ( TPMI_ECC_CURVE * target , BYTE * * buffer , INT32 * size ) { TPM_RC rc = TPM_RC_SUCCESS ; if ( rc == TPM_RC_SUCCESS ) { rc = TPM_ECC_CURVE_Unmarshal ( target , buffer , size ) ; } if ( rc == TPM_RC_SUCCESS ) { switch ( * target ) { #if ECC_BN_P256 case TPM_ECC_BN_P256 : #endif #if ECC_BN_P638  // libtpms added begin case TPM_ECC_BN_P638 : #endif #if ECC_NIST_P192 case TPM_ECC_NIST_P192 : #endif #if ECC_NIST_P224 case TPM_ECC_NIST_P224 : #endif   // libtpms added end #if ECC_NIST_P256 case TPM_ECC_NIST_P256 : #endif #if ECC_NIST_P384 case TPM_ECC_NIST_P384 : #endif #if ECC_NIST_P521 // libtpms added begin case TPM_ECC_NIST_P521 : #endif #if ECC_SM2_P256 case TPM_ECC_SM2_P256 : #endif if ( ! CryptEccIsCurveRuntimeUsable ( * target ) ) rc = TPM_RC_CURVE ; break ; default : rc = TPM_RC_CURVE ; } } return rc ; }
Handle < FixedArray > Debug :: GetLoadedScripts ( ) { isolate_ -> heap ( ) -> CollectAllGarbage ( Heap :: kFinalizeIncrementalMarkingMask , GarbageCollectionReason :: kDebugger ) ; Factory * factory = isolate_ -> factory ( ) ; if ( ! factory -> script_list ( ) -> IsWeakArrayList ( ) ) { return factory -> empty_fixed_array ( ) ; } Handle < WeakArrayList > array = Handle < WeakArrayList > :: cast ( factory -> script_list ( ) ) ; Handle < FixedArray > results = factory -> NewFixedArray ( array -> length ( ) ) ; int length = 0 ; { Script :: Iterator iterator ( isolate_ ) ; Script * script ; while ( ( script = iterator . Next ( ) ) != nullptr ) { if ( script -> HasValidSource ( ) ) results -> set ( length ++ , script ) ; } } return FixedArray :: ShrinkOrEmpty ( isolate_ , results , length ) ; }
PJ_DEF ( pj_status_t ) pjmedia_vid_conf_disconnect_port ( pjmedia_vid_conf * vid_conf , unsigned src_slot , unsigned sink_slot ) { vconf_port * src_port , * dst_port ; unsigned i , j ; PJ_ASSERT_RETURN ( vid_conf && src_slot < vid_conf -> opt . max_slot_cnt && sink_slot < vid_conf -> opt . max_slot_cnt , PJ_EINVAL ) ; pj_mutex_lock ( vid_conf -> mutex ) ; src_port = vid_conf -> ports [ src_slot ] ; dst_port = vid_conf -> ports [ sink_slot ] ; if ( ! src_port || ! dst_port ) { pj_mutex_unlock ( vid_conf -> mutex ) ; return PJ_EINVAL ; } for ( i = 0 ; i < src_port -> listener_cnt ; ++ i ) { if ( src_port -> listener_slots [ i ] == sink_slot ) break ; } for ( j = 0 ; j < dst_port -> transmitter_cnt ; ++ j ) { if ( dst_port -> transmitter_slots [ j ] == src_slot ) break ; } if ( i != src_port -> listener_cnt && j != dst_port -> transmitter_cnt ) { unsigned k ; pj_assert ( src_port -> listener_cnt > 0 && src_port -> listener_cnt < vid_conf -> opt . max_slot_cnt ) ; pj_assert ( dst_port -> transmitter_cnt > 0 && dst_port -> transmitter_cnt < vid_conf -> opt . max_slot_cnt ) ; for ( k = 0 ; k < dst_port -> transmitter_cnt ; ++ k ) cleanup_render_state ( dst_port , k ) ; pj_array_erase ( src_port -> listener_slots , sizeof ( unsigned ) , src_port -> listener_cnt , i ) ; pj_array_erase ( dst_port -> transmitter_slots , sizeof ( unsigned ) , dst_port -> transmitter_cnt , j ) ; -- src_port -> listener_cnt ; -- dst_port -> transmitter_cnt ; update_render_state ( vid_conf , dst_port ) ; -- vid_conf -> connect_cnt ; if ( AUTO_STOP_CLOCK && vid_conf -> connect_cnt == 0 ) { pj_status_t status ; status = pjmedia_clock_stop ( vid_conf -> clock ) ; if ( status != PJ_SUCCESS ) { PJ_PERROR ( 4 , ( THIS_FILE , status , "Failed to stop clock" ) ) ; return status ; } } PJ_LOG ( 4 , ( THIS_FILE , "Port %d (%.*s) stop transmitting to port %d (%.*s)" , src_slot , ( int ) src_port -> name . slen , src_port -> name . ptr , sink_slot , ( int ) dst_port -> name . slen , dst_port -> name . ptr ) ) ; } pj_mutex_unlock ( vid_conf -> mutex ) ; return PJ_SUCCESS ; }
static void update_db_bp_intercept ( struct kvm_vcpu * vcpu ) { struct vcpu_svm * svm = to_svm ( vcpu ) ; clr_exception_intercept ( svm , DB_VECTOR ) ; clr_exception_intercept ( svm , BP_VECTOR ) ; if ( svm -> nmi_singlestep ) set_exception_intercept ( svm , DB_VECTOR ) ; if ( vcpu -> guest_debug & KVM_GUESTDBG_ENABLE ) { if ( vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) set_exception_intercept ( svm , DB_VECTOR ) ; if ( vcpu -> guest_debug & KVM_GUESTDBG_USE_SW_BP ) set_exception_intercept ( svm , BP_VECTOR ) ; } else vcpu -> guest_debug = 0 ; }
nsDOMAttribute :: AttributeChanged ( nsIDocument * aDocument , Element * aElement , PRInt32 aNameSpaceID , nsIAtom * aAttribute , PRInt32 aModType ) { nsIContent * content = GetContentInternal ( ) ; if ( aElement != content ) { return ; } if ( aNameSpaceID != mNodeInfo -> NamespaceID ( ) ) { return ; } nsCOMPtr < nsIAtom > nameAtom = GetNameAtom ( content ) ; if ( nameAtom != aAttribute ) { return ; } nsCOMPtr < nsIMutationObserver > kungFuDeathGrip ( this ) ; if ( mChild ) { doRemoveChild ( ) ; } EnsureChildState ( ) ; }
static struct stream_state * new_stream ( struct VpxEncoderConfig * global , struct stream_state * prev ) { struct stream_state * stream ; stream = calloc ( 1 , sizeof ( * stream ) ) ; if ( ! stream ) fatal ( "Failed to allocate new stream." ) ; if ( prev ) { memcpy ( stream , prev , sizeof ( * stream ) ) ; stream -> index ++ ; prev -> next = stream ; } else { vpx_codec_err_t res ; res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , & stream -> config . cfg , global -> usage ) ; if ( res ) fatal ( "Failed to get config: %s\n" , vpx_codec_err_to_string ( res ) ) ; stream -> config . cfg . g_timebase . den = 1000 ; stream -> config . cfg . g_w = 0 ; stream -> config . cfg . g_h = 0 ; stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; stream -> config . write_webm = 1 ; #if CONFIG_WEBM_IO stream -> ebml . last_pts_ms = - 1 ; #endif stream -> ebml . debug = global -> debug ; if ( global -> deadline == VPX_DL_REALTIME ) stream -> config . cfg . g_lag_in_frames = 0 ; } stream -> config . out_fn = NULL ; stream -> next = NULL ; return stream ; }
int main ( int argc , char * argv [ ] ) { char * fin , * fout ; FILE * fpin , * fpout ; uint8_t * inbuf , * outbuf ; uint8_t * inbuf_u , * outbuf_u ; uint8_t * inbuf_v , * outbuf_v ; int f , frames ; int width , height , target_width , target_height ; if ( argc < 5 ) { printf ( "Incorrect parameters:\n" ) ; usage ( argv [ 0 ] ) ; return 1 ; } fin = argv [ 1 ] ; fout = argv [ 4 ] ; if ( ! parse_dim ( argv [ 2 ] , & width , & height ) ) { printf ( "Incorrect parameters: %s\n" , argv [ 2 ] ) ; usage ( argv [ 0 ] ) ; return 1 ; } if ( ! parse_dim ( argv [ 3 ] , & target_width , & target_height ) ) { printf ( "Incorrect parameters: %s\n" , argv [ 3 ] ) ; usage ( argv [ 0 ] ) ; return 1 ; } fpin = fopen ( fin , "rb" ) ; if ( fpin == NULL ) { printf ( "Can't open file %s to read\n" , fin ) ; usage ( argv [ 0 ] ) ; return 1 ; } fpout = fopen ( fout , "wb" ) ; if ( fpout == NULL ) { printf ( "Can't open file %s to write\n" , fout ) ; usage ( argv [ 0 ] ) ; return 1 ; } if ( argc >= 6 ) frames = atoi ( argv [ 5 ] ) ; else frames = INT_MAX ; printf ( "Input size:  %dx%d\n" , width , height ) ; printf ( "Target size: %dx%d, Frames: " , target_width , target_height ) ; if ( frames == INT_MAX ) printf ( "All\n" ) ; else printf ( "%d\n" , frames ) ; inbuf = ( uint8_t * ) malloc ( width * height * 3 / 2 ) ; outbuf = ( uint8_t * ) malloc ( target_width * target_height * 3 / 2 ) ; inbuf_u = inbuf + width * height ; inbuf_v = inbuf_u + width * height / 4 ; outbuf_u = outbuf + target_width * target_height ; outbuf_v = outbuf_u + target_width * target_height / 4 ; f = 0 ; while ( f < frames ) { if ( fread ( inbuf , width * height * 3 / 2 , 1 , fpin ) != 1 ) break ; vp9_resize_frame420 ( inbuf , width , inbuf_u , inbuf_v , width / 2 , height , width , outbuf , target_width , outbuf_u , outbuf_v , target_width / 2 , target_height , target_width ) ; fwrite ( outbuf , target_width * target_height * 3 / 2 , 1 , fpout ) ; f ++ ; } printf ( "%d frames processed\n" , f ) ; fclose ( fpin ) ; fclose ( fpout ) ; free ( inbuf ) ; free ( outbuf ) ; return 0 ; }
ec_verify ( krb5_context context , krb5_data * req_pkt , krb5_kdc_req * request , krb5_enc_tkt_part * enc_tkt_reply , krb5_pa_data * data , krb5_kdcpreauth_callbacks cb , krb5_kdcpreauth_rock rock , krb5_kdcpreauth_moddata moddata , krb5_kdcpreauth_verify_respond_fn respond , void * arg ) { krb5_error_code retval = 0 ; krb5_enc_data * enc = NULL ; krb5_data scratch , plain ; krb5_keyblock * armor_key = cb -> fast_armor ( context , rock ) ; krb5_pa_enc_ts * ts = NULL ; krb5_keyblock * client_keys = NULL ; krb5_keyblock * challenge_key = NULL ; krb5_keyblock * kdc_challenge_key ; krb5_kdcpreauth_modreq modreq = NULL ; int i = 0 ; char * ai = NULL , * realmstr = NULL ; krb5_data realm = request -> server -> realm ; plain . data = NULL ; if ( armor_key == NULL ) { retval = ENOENT ; k5_setmsg ( context , ENOENT , _ ( "Encrypted Challenge used outside of FAST tunnel" ) ) ; } scratch . data = ( char * ) data -> contents ; scratch . length = data -> length ; if ( retval == 0 ) retval = decode_krb5_enc_data ( & scratch , & enc ) ; if ( retval == 0 ) { plain . data = malloc ( enc -> ciphertext . length ) ; plain . length = enc -> ciphertext . length ; if ( plain . data == NULL ) retval = ENOMEM ; } realmstr = k5memdup0 ( realm . data , realm . length , & retval ) ; if ( realmstr != NULL ) retval = profile_get_string ( context -> profile , KRB5_CONF_REALMS , realmstr , KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR , NULL , & ai ) ; if ( retval == 0 ) retval = cb -> client_keys ( context , rock , & client_keys ) ; if ( retval == 0 ) { for ( i = 0 ; client_keys [ i ] . enctype && ( retval == 0 ) ; i ++ ) { retval = krb5_c_fx_cf2_simple ( context , armor_key , "clientchallengearmor" , & client_keys [ i ] , "challengelongterm" , & challenge_key ) ; if ( retval == 0 ) retval = krb5_c_decrypt ( context , challenge_key , KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT , NULL , enc , & plain ) ; if ( challenge_key ) krb5_free_keyblock ( context , challenge_key ) ; challenge_key = NULL ; if ( retval == 0 ) break ; retval = 0 ; } if ( client_keys [ i ] . enctype == 0 ) { retval = KRB5KDC_ERR_PREAUTH_FAILED ; k5_setmsg ( context , retval , _ ( "Incorrect password in encrypted challenge" ) ) ; } } if ( retval == 0 ) retval = decode_krb5_pa_enc_ts ( & plain , & ts ) ; if ( retval == 0 ) retval = krb5_check_clockskew ( context , ts -> patimestamp ) ; if ( retval == 0 ) { enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; if ( krb5_c_fx_cf2_simple ( context , armor_key , "kdcchallengearmor" , & client_keys [ i ] , "challengelongterm" , & kdc_challenge_key ) == 0 ) { modreq = ( krb5_kdcpreauth_modreq ) kdc_challenge_key ; if ( ai != NULL ) cb -> add_auth_indicator ( context , rock , ai ) ; } } cb -> free_keys ( context , rock , client_keys ) ; if ( plain . data ) free ( plain . data ) ; if ( enc ) krb5_free_enc_data ( context , enc ) ; if ( ts ) krb5_free_pa_enc_ts ( context , ts ) ; free ( realmstr ) ; free ( ai ) ; ( * respond ) ( arg , retval , modreq , NULL , NULL ) ; }
int ntlm_decode_target_info ( struct ntlm_ctx * ctx , struct ntlm_buffer * buffer , char * * nb_computer_name , char * * nb_domain_name , char * * dns_computer_name , char * * dns_domain_name , char * * dns_tree_name , char * * av_target_name , uint32_t * av_flags , uint64_t * av_timestamp , struct ntlm_buffer * av_single_host , struct ntlm_buffer * av_cb ) { struct wire_av_pair * av_pair ; uint16_t av_id = ( uint16_t ) - 1 ; uint16_t av_len = ( uint16_t ) - 1 ; struct ntlm_buffer sh = { NULL , 0 } ; struct ntlm_buffer cb = { NULL , 0 } ; char * nb_computer = NULL ; char * nb_domain = NULL ; char * dns_computer = NULL ; char * dns_domain = NULL ; char * dns_tree = NULL ; char * av_target = NULL ; size_t data_offs = 0 ; uint64_t timestamp = 0 ; uint32_t flags = 0 ; int ret = 0 ; while ( data_offs + 4 <= buffer -> length ) { av_pair = ( struct wire_av_pair * ) & buffer -> data [ data_offs ] ; data_offs += 4 ; av_id = le16toh ( av_pair -> av_id ) ; av_len = le16toh ( av_pair -> av_len ) ; if ( av_len > buffer -> length - data_offs ) { ret = ERR_DECODE ; goto done ; } data_offs += av_len ; switch ( av_id ) { case MSV_AV_CHANNEL_BINDINGS : if ( ! av_cb ) continue ; cb . data = av_pair -> value ; cb . length = av_len ; break ; case MSV_AV_TARGET_NAME : if ( ! av_target_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & av_target ) ; if ( ret ) goto done ; break ; case MSV_AV_SINGLE_HOST : if ( ! av_single_host ) continue ; sh . data = av_pair -> value ; sh . length = av_len ; break ; case MSV_AV_TIMESTAMP : if ( ! av_timestamp ) continue ; memcpy ( & timestamp , av_pair -> value , sizeof ( timestamp ) ) ; timestamp = le64toh ( timestamp ) ; break ; case MSV_AV_FLAGS : if ( ! av_flags ) continue ; memcpy ( & flags , av_pair -> value , sizeof ( flags ) ) ; flags = le32toh ( flags ) ; break ; case MSV_AV_DNS_TREE_NAME : if ( ! dns_tree_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & dns_tree ) ; if ( ret ) goto done ; break ; case MSV_AV_DNS_DOMAIN_NAME : if ( ! dns_domain_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & dns_domain ) ; if ( ret ) goto done ; break ; case MSV_AV_DNS_COMPUTER_NAME : if ( ! dns_computer_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & dns_computer ) ; if ( ret ) goto done ; break ; case MSV_AV_NB_DOMAIN_NAME : if ( ! nb_domain_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & nb_domain ) ; if ( ret ) goto done ; break ; case MSV_AV_NB_COMPUTER_NAME : if ( ! nb_computer_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & nb_computer ) ; if ( ret ) goto done ; break ; default : break ; } if ( av_id == MSV_AV_EOL ) break ; } if ( av_id != MSV_AV_EOL || av_len != 0 ) { ret = ERR_DECODE ; } done : if ( ret ) { ntlm_free_buffer_data ( & sh ) ; ntlm_free_buffer_data ( & cb ) ; safefree ( nb_computer ) ; safefree ( nb_domain ) ; safefree ( dns_computer ) ; safefree ( dns_domain ) ; safefree ( dns_tree ) ; safefree ( av_target ) ; } else { if ( nb_computer_name ) * nb_computer_name = nb_computer ; if ( nb_domain_name ) * nb_domain_name = nb_domain ; if ( dns_computer_name ) * dns_computer_name = dns_computer ; if ( dns_domain_name ) * dns_domain_name = dns_domain ; if ( dns_tree_name ) * dns_tree_name = dns_tree ; if ( av_target_name ) * av_target_name = av_target ; if ( av_timestamp ) * av_timestamp = timestamp ; if ( av_single_host ) * av_single_host = sh ; if ( av_flags ) * av_flags = flags ; if ( av_cb ) * av_cb = cb ; } return ret ; }
static void reassemble_and_dispatch ( BT_HDR * packet ) { if ( ( packet -> event & MSG_EVT_MASK ) == MSG_HC_TO_STACK_HCI_ACL ) { uint8_t * stream = packet -> data ; uint16_t handle ; uint16_t acl_length ; STREAM_TO_UINT16 ( handle , stream ) ; STREAM_TO_UINT16 ( acl_length , stream ) ; CHECK ( acl_length == packet -> len - HCI_ACL_PREAMBLE_SIZE ) ; uint8_t boundary_flag = GET_BOUNDARY_FLAG ( handle ) ; handle = handle & HANDLE_MASK ; if ( boundary_flag == START_PACKET_BOUNDARY ) { if ( acl_length < 2 ) { LOG_WARN ( LOG_TAG , "%s invalid acl_length %d" , __func__ , acl_length ) ; buffer_allocator -> free ( packet ) ; return ; } uint16_t l2cap_length ; STREAM_TO_UINT16 ( l2cap_length , stream ) ; auto map_iter = partial_packets . find ( handle ) ; if ( map_iter != partial_packets . end ( ) ) { LOG_WARN ( LOG_TAG , "%s found unfinished packet for handle with start packet. " "Dropping old." , __func__ ) ; BT_HDR * hdl = map_iter -> second ; partial_packets . erase ( map_iter ) ; buffer_allocator -> free ( hdl ) ; } if ( acl_length < L2CAP_HEADER_PDU_LEN_SIZE ) { LOG_WARN ( LOG_TAG , "%s L2CAP packet too small (%d < %d). Dropping it." , __func__ , packet -> len , L2CAP_HEADER_PDU_LEN_SIZE ) ; buffer_allocator -> free ( packet ) ; return ; } uint16_t full_length = l2cap_length + L2CAP_HEADER_SIZE + HCI_ACL_PREAMBLE_SIZE ; if ( check_uint16_overflow ( l2cap_length , ( L2CAP_HEADER_SIZE + HCI_ACL_PREAMBLE_SIZE ) ) || ( ( full_length + sizeof ( BT_HDR ) ) > BT_DEFAULT_BUFFER_SIZE ) ) { LOG_ERROR ( LOG_TAG , "%s Dropping L2CAP packet with invalid length (%d)." , __func__ , l2cap_length ) ; buffer_allocator -> free ( packet ) ; return ; } if ( full_length <= packet -> len ) { if ( full_length < packet -> len ) LOG_WARN ( LOG_TAG , "%s found l2cap full length %d less than the hci length %d." , __func__ , l2cap_length , packet -> len ) ; callbacks -> reassembled ( packet ) ; return ; } BT_HDR * partial_packet = ( BT_HDR * ) buffer_allocator -> alloc ( full_length + sizeof ( BT_HDR ) ) ; partial_packet -> event = packet -> event ; partial_packet -> len = full_length ; partial_packet -> offset = packet -> len ; memcpy ( partial_packet -> data , packet -> data , packet -> len ) ; stream = partial_packet -> data ; STREAM_SKIP_UINT16 ( stream ) ; UINT16_TO_STREAM ( stream , full_length - HCI_ACL_PREAMBLE_SIZE ) ; partial_packets [ handle ] = partial_packet ; buffer_allocator -> free ( packet ) ; } else { auto map_iter = partial_packets . find ( handle ) ; if ( map_iter == partial_packets . end ( ) ) { LOG_WARN ( LOG_TAG , "%s got continuation for unknown packet. Dropping it." , __func__ ) ; buffer_allocator -> free ( packet ) ; return ; } BT_HDR * partial_packet = map_iter -> second ; packet -> offset = HCI_ACL_PREAMBLE_SIZE ; uint16_t projected_offset = partial_packet -> offset + ( packet -> len - HCI_ACL_PREAMBLE_SIZE ) ; if ( ( packet -> len - packet -> offset ) > ( partial_packet -> len - partial_packet -> offset ) ) { LOG_WARN ( LOG_TAG , "%s got packet which would exceed expected length of %d. " "Truncating." , __func__ , partial_packet -> len ) ; packet -> len = ( partial_packet -> len - partial_packet -> offset ) + packet -> offset ; projected_offset = partial_packet -> len ; } memcpy ( partial_packet -> data + partial_packet -> offset , packet -> data + packet -> offset , packet -> len - packet -> offset ) ; buffer_allocator -> free ( packet ) ; partial_packet -> offset = projected_offset ; if ( partial_packet -> offset == partial_packet -> len ) { partial_packets . erase ( handle ) ; partial_packet -> offset = 0 ; callbacks -> reassembled ( partial_packet ) ; } } } else { callbacks -> reassembled ( packet ) ; } }
Node * InterpreterAssembler :: GetContextAtDepth ( Node * context , Node * depth ) { Variable cur_context ( this , MachineRepresentation :: kTaggedPointer ) ; cur_context . Bind ( context ) ; Variable cur_depth ( this , MachineRepresentation :: kWord32 ) ; cur_depth . Bind ( depth ) ; Label context_found ( this ) ; Variable * context_search_loop_variables [ 2 ] = { & cur_depth , & cur_context } ; Label context_search ( this , 2 , context_search_loop_variables ) ; Branch ( Word32Equal ( depth , Int32Constant ( 0 ) ) , & context_found , & context_search ) ; BIND ( & context_search ) ; { cur_depth . Bind ( Int32Sub ( cur_depth . value ( ) , Int32Constant ( 1 ) ) ) ; cur_context . Bind ( LoadContextElement ( cur_context . value ( ) , Context :: PREVIOUS_INDEX ) ) ; Branch ( Word32Equal ( cur_depth . value ( ) , Int32Constant ( 0 ) ) , & context_found , & context_search ) ; } BIND ( & context_found ) ; return cur_context . value ( ) ; }
nsEventDispatcher :: Dispatch ( nsISupports * aTarget , nsPresContext * aPresContext , nsEvent * aEvent , nsIDOMEvent * aDOMEvent , nsEventStatus * aEventStatus , nsDispatchingCallback * aCallback , nsCOMArray < nsIDOMEventTarget > * aTargets ) { SAMPLE_LABEL ( "nsEventDispatcher" , "Dispatch" ) ; NS_ASSERTION ( aEvent , "Trying to dispatch without nsEvent!" ) ; NS_ENSURE_TRUE ( ! NS_IS_EVENT_IN_DISPATCH ( aEvent ) , NS_ERROR_ILLEGAL_VALUE ) ; NS_ASSERTION ( ! aTargets || ! aEvent -> message , "Wrong parameters!" ) ; NS_ENSURE_TRUE ( aEvent -> message || ! aDOMEvent || aTargets , NS_ERROR_DOM_INVALID_STATE_ERR ) ; nsCOMPtr < nsIDOMEventTarget > target = do_QueryInterface ( aTarget ) ; bool retargeted = false ; if ( aEvent -> flags & NS_EVENT_RETARGET_TO_NON_NATIVE_ANONYMOUS ) { nsCOMPtr < nsIContent > content = do_QueryInterface ( target ) ; if ( content && content -> IsInNativeAnonymousSubtree ( ) ) { nsCOMPtr < nsPIDOMEventTarget > newTarget = do_QueryInterface ( content -> FindFirstNonNativeAnonymous ( ) ) ; NS_ENSURE_STATE ( newTarget ) ; aEvent -> originalTarget = target ; target = newTarget ; retargeted = true ; } } if ( aEvent -> flags & NS_EVENT_FLAG_ONLY_CHROME_DISPATCH ) { nsCOMPtr < nsINode > node = do_QueryInterface ( aTarget ) ; if ( ! node ) { nsCOMPtr < nsPIDOMWindow > win = do_QueryInterface ( aTarget ) ; if ( win ) { node = do_QueryInterface ( win -> GetExtantDocument ( ) ) ; } } NS_ENSURE_STATE ( node ) ; nsIDocument * doc = node -> OwnerDoc ( ) ; if ( ! nsContentUtils :: IsChromeDoc ( doc ) ) { nsPIDOMWindow * win = doc ? doc -> GetInnerWindow ( ) : nullptr ; nsIDOMEventTarget * piTarget = win ? win -> GetParentTarget ( ) : nullptr ; NS_ENSURE_TRUE ( piTarget , NS_OK ) ; aEvent -> target = target ; target = piTarget ; } } #ifdef DEBUG if ( ! nsContentUtils :: IsSafeToRunScript ( ) ) { nsresult rv = NS_ERROR_FAILURE ; if ( target -> GetContextForEventHandlers ( & rv ) || NS_FAILED ( rv ) ) { nsCOMPtr < nsINode > node = do_QueryInterface ( target ) ; if ( node && nsContentUtils :: IsChromeDoc ( node -> OwnerDoc ( ) ) ) { NS_WARNING ( "Fix the caller!" ) ; } else { NS_ERROR ( "This is unsafe! Fix the caller!" ) ; } } } if ( aDOMEvent ) { nsEvent * innerEvent = aDOMEvent -> GetInternalNSEvent ( ) ; NS_ASSERTION ( innerEvent == aEvent , "The inner event of aDOMEvent is not the same as aEvent!" ) ; } #endif nsresult rv = NS_OK ; bool externalDOMEvent = ! ! ( aDOMEvent ) ; nsRefPtr < nsPresContext > kungFuDeathGrip ( aPresContext ) ; ChainItemPool pool ; NS_ENSURE_TRUE ( pool . GetPool ( ) , NS_ERROR_OUT_OF_MEMORY ) ; nsEventTargetChainItem * targetEtci = nsEventTargetChainItem :: Create ( pool . GetPool ( ) , target -> GetTargetForEventTargetChain ( ) ) ; NS_ENSURE_TRUE ( targetEtci , NS_ERROR_OUT_OF_MEMORY ) ; if ( ! targetEtci -> IsValid ( ) ) { nsEventTargetChainItem :: Destroy ( pool . GetPool ( ) , targetEtci ) ; return NS_ERROR_FAILURE ; } if ( ! aEvent -> target ) { aEvent -> target = targetEtci -> CurrentTarget ( ) ; } else { aEvent -> target = aEvent -> target -> GetTargetForEventTargetChain ( ) ; NS_ENSURE_STATE ( aEvent -> target ) ; } if ( retargeted ) { aEvent -> originalTarget = aEvent -> originalTarget -> GetTargetForEventTargetChain ( ) ; NS_ENSURE_STATE ( aEvent -> originalTarget ) ; } else { aEvent -> originalTarget = aEvent -> target ; } nsCOMPtr < nsIContent > content = do_QueryInterface ( aEvent -> originalTarget ) ; bool isInAnon = ( content && content -> IsInAnonymousSubtree ( ) ) ; NS_MARK_EVENT_DISPATCH_STARTED ( aEvent ) ; nsEventStatus status = aEventStatus ? * aEventStatus : nsEventStatus_eIgnore ; nsEventChainPreVisitor preVisitor ( aPresContext , aEvent , aDOMEvent , status , isInAnon ) ; targetEtci -> PreHandleEvent ( preVisitor ) ; if ( preVisitor . mCanHandle ) { nsCOMPtr < nsIDOMEventTarget > t = aEvent -> target ; targetEtci -> SetNewTarget ( t ) ; nsEventTargetChainItem * topEtci = targetEtci ; while ( preVisitor . mParentTarget ) { nsEventTargetChainItem * parentEtci = nsEventTargetChainItem :: Create ( pool . GetPool ( ) , preVisitor . mParentTarget , topEtci ) ; if ( ! parentEtci ) { rv = NS_ERROR_OUT_OF_MEMORY ; break ; } if ( ! parentEtci -> IsValid ( ) ) { rv = NS_ERROR_FAILURE ; break ; } if ( preVisitor . mEventTargetAtParent ) { preVisitor . mEvent -> target = preVisitor . mEventTargetAtParent ; parentEtci -> SetNewTarget ( preVisitor . mEventTargetAtParent ) ; } parentEtci -> PreHandleEvent ( preVisitor ) ; if ( preVisitor . mCanHandle ) { topEtci = parentEtci ; } else { nsEventTargetChainItem :: Destroy ( pool . GetPool ( ) , parentEtci ) ; parentEtci = nullptr ; break ; } } if ( NS_SUCCEEDED ( rv ) ) { if ( aTargets ) { aTargets -> Clear ( ) ; nsEventTargetChainItem * item = targetEtci ; while ( item ) { aTargets -> AppendObject ( item -> CurrentTarget ( ) -> GetTargetForDOMEvent ( ) ) ; item = item -> mParent ; } } else { nsEventChainPostVisitor postVisitor ( preVisitor ) ; nsCxPusher pusher ; rv = topEtci -> HandleEventTargetChain ( postVisitor , NS_EVENT_FLAG_BUBBLE | NS_EVENT_FLAG_CAPTURE , aCallback , false , & pusher ) ; preVisitor . mEventStatus = postVisitor . mEventStatus ; if ( ! preVisitor . mDOMEvent && postVisitor . mDOMEvent ) { preVisitor . mDOMEvent = postVisitor . mDOMEvent ; } } } } nsEventTargetChainItem :: Destroy ( pool . GetPool ( ) , targetEtci ) ; targetEtci = nullptr ; NS_MARK_EVENT_DISPATCH_DONE ( aEvent ) ; if ( ! externalDOMEvent && preVisitor . mDOMEvent ) { nsrefcnt rc = 0 ; NS_RELEASE2 ( preVisitor . mDOMEvent , rc ) ; if ( preVisitor . mDOMEvent ) { preVisitor . mDOMEvent -> DuplicatePrivateData ( ) ; } } if ( aEventStatus ) { * aEventStatus = preVisitor . mEventStatus ; } return rv ; }
nsCxPusher :: Push ( JSContext * cx , bool aRequiresScriptContext ) { if ( mPushedSomething ) { NS_ERROR ( "Whaaa! No double pushing with nsCxPusher::Push()!" ) ; return false ; } if ( ! cx ) { return false ; } mScx = GetScriptContextFromJSContext ( cx ) ; if ( ! mScx && aRequiresScriptContext ) { return true ; } return DoPush ( cx ) ; }
Response InjectedScript :: resolveCallArgument ( protocol :: Runtime :: CallArgument * callArgument , v8 :: Local < v8 :: Value > * result ) { if ( callArgument -> hasObjectId ( ) ) { std :: unique_ptr < RemoteObjectId > remoteObjectId ; Response response = RemoteObjectId :: parse ( callArgument -> getObjectId ( "" ) , & remoteObjectId ) ; if ( ! response . isSuccess ( ) ) return response ; if ( remoteObjectId -> contextId ( ) != m_context -> contextId ( ) ) return Response :: Error ( "Argument should belong to the same JavaScript world as target " "object" ) ; return findObject ( * remoteObjectId , result ) ; } if ( callArgument -> hasValue ( ) || callArgument -> hasUnserializableValue ( ) ) { String16 value ; if ( callArgument -> hasValue ( ) ) { value = "(" + callArgument -> getValue ( nullptr ) -> serialize ( ) + ")" ; } else { String16 unserializableValue = callArgument -> getUnserializableValue ( "" ) ; if ( isResolvableNumberLike ( unserializableValue ) ) value = "Number(\"" + unserializableValue + "\")" ; else value = unserializableValue ; } if ( ! m_context -> inspector ( ) -> compileAndRunInternalScript ( m_context -> context ( ) , toV8String ( m_context -> isolate ( ) , value ) ) . ToLocal ( result ) ) { return Response :: Error ( "Couldn't parse value object in call argument" ) ; } return Response :: OK ( ) ; } * result = v8 :: Undefined ( m_context -> isolate ( ) ) ; return Response :: OK ( ) ; }
static void SetUpTestCase ( ) { input_ = reinterpret_cast < uint8_t * > ( vpx_memalign ( kDataAlignment , kInputBufferSize + 1 ) ) + 1 ; output_ = reinterpret_cast < uint8_t * > ( vpx_memalign ( kDataAlignment , kOutputBufferSize ) ) ; }
void nsFocusManager :: RaiseWindow ( nsPIDOMWindowOuter * aWindow ) { if ( ! aWindow || aWindow == mActiveWindow || aWindow == mWindowBeingLowered ) return ; if ( sTestMode ) { nsCOMPtr < nsPIDOMWindowOuter > active ( mActiveWindow ) ; nsCOMPtr < nsPIDOMWindowOuter > window ( aWindow ) ; RefPtr < nsFocusManager > self ( this ) ; NS_DispatchToCurrentThread ( NS_NewRunnableFunction ( "nsFocusManager::RaiseWindow" , [ self , active , window ] ( ) -> void { if ( active ) { self -> WindowLowered ( active ) ; } self -> WindowRaised ( window ) ; } ) ) ; return ; } #if defined(XP_WIN) nsCOMPtr < nsPIDOMWindowOuter > childWindow ; GetFocusedDescendant ( aWindow , eIncludeAllDescendants , getter_AddRefs ( childWindow ) ) ; if ( ! childWindow ) childWindow = aWindow ; nsCOMPtr < nsIDocShell > docShell = aWindow -> GetDocShell ( ) ; if ( ! docShell ) return ; PresShell * presShell = docShell -> GetPresShell ( ) ; if ( ! presShell ) { return ; } if ( nsViewManager * vm = presShell -> GetViewManager ( ) ) { nsCOMPtr < nsIWidget > widget ; vm -> GetRootWidget ( getter_AddRefs ( widget ) ) ; if ( widget ) widget -> SetFocus ( nsIWidget :: Raise :: Yes ) ; } #else nsCOMPtr < nsIBaseWindow > treeOwnerAsWin = do_QueryInterface ( aWindow -> GetDocShell ( ) ) ; if ( treeOwnerAsWin ) { nsCOMPtr < nsIWidget > widget ; treeOwnerAsWin -> GetMainWidget ( getter_AddRefs ( widget ) ) ; if ( widget ) widget -> SetFocus ( nsIWidget :: Raise :: Yes ) ; } #endif }
IonBailoutIterator :: IonBailoutIterator ( const JitActivationIterator & activations , BailoutStack * bailout ) : JitFrameIterator ( activations ) , machine_ ( bailout -> machineState ( ) ) { uint8_t * sp = bailout -> parentStackPointer ( ) ; uint8_t * fp = sp + bailout -> frameSize ( ) ; kind_ = Kind_BailoutIterator ; current_ = fp ; type_ = JitFrame_IonJS ; topFrameSize_ = current_ - sp ; switch ( mode_ ) { case SequentialExecution : topIonScript_ = script ( ) -> ionScript ( ) ; break ; case ParallelExecution : topIonScript_ = script ( ) -> parallelIonScript ( ) ; break ; default : MOZ_CRASH ( "No such execution mode" ) ; } snapshotOffset_ = bailout -> snapshotOffset ( ) ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { const auto * params = reinterpret_cast < TfLiteBidirectionalSequenceRNNParams * > ( node -> builtin_data ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; const TfLiteTensor * fw_input_weights = GetInput ( context , node , kFwWeightsTensor ) ; const TfLiteTensor * fw_recurrent_weights = GetInput ( context , node , kFwRecurrentWeightsTensor ) ; const TfLiteTensor * fw_bias = GetInput ( context , node , kFwBiasTensor ) ; const TfLiteTensor * bw_input_weights = GetInput ( context , node , kBwWeightsTensor ) ; const TfLiteTensor * bw_recurrent_weights = GetInput ( context , node , kBwRecurrentWeightsTensor ) ; const TfLiteTensor * bw_bias = GetInput ( context , node , kBwBiasTensor ) ; const TfLiteTensor * aux_input = GetOptionalInputTensor ( context , node , kAuxInputTensor ) ; const TfLiteTensor * fw_aux_input_weights = GetOptionalInputTensor ( context , node , kFwAuxWeightsTensor ) ; const TfLiteTensor * bw_aux_input_weights = GetOptionalInputTensor ( context , node , kBwAuxWeightsTensor ) ; TfLiteTensor * fw_hidden_state = GetVariableInput ( context , node , kFwHiddenStateTensor ) ; TF_LITE_ENSURE ( context , fw_hidden_state != nullptr ) ; TfLiteTensor * bw_hidden_state = GetVariableInput ( context , node , kBwHiddenStateTensor ) ; TF_LITE_ENSURE ( context , bw_hidden_state != nullptr ) ; TfLiteTensor * fw_output = GetOutput ( context , node , kFwOutputTensor ) ; TfLiteTensor * bw_output = params -> merge_outputs ? nullptr : GetOutput ( context , node , kBwOutputTensor ) ; const bool has_previous_bw_output = ( aux_input != nullptr ) ; const bool use_aux_input = ( fw_aux_input_weights != nullptr ) ; const bool non_stacking_mode = ! use_aux_input && has_previous_bw_output ; const TfLiteTensor * bw_input = non_stacking_mode ? aux_input : input ; const TfLiteTensor * real_aux_input = non_stacking_mode ? nullptr : aux_input ; switch ( fw_input_weights -> type ) { case kTfLiteFloat32 : return EvalFloat ( input , bw_input , fw_input_weights , fw_recurrent_weights , fw_bias , bw_input_weights , bw_recurrent_weights , bw_bias , real_aux_input , fw_aux_input_weights , bw_aux_input_weights , params , fw_hidden_state , fw_output , bw_hidden_state , bw_output ) ; case kTfLiteUInt8 : case kTfLiteInt8 : { TfLiteTensor * input_quantized = GetTemporary ( context , node , kInputQuantized ) ; TfLiteTensor * fw_hidden_state_quantized = GetTemporary ( context , node , kFwHiddenStateQuantized ) ; TfLiteTensor * bw_hidden_state_quantized = GetTemporary ( context , node , kBwHiddenStateQuantized ) ; TfLiteTensor * scaling_factors = GetTemporary ( context , node , kScalingFactors ) ; TfLiteTensor * zero_points = GetTemporary ( context , node , kZeroPoints ) ; TfLiteTensor * accum_scratch = GetTemporary ( context , node , kAccumScratch ) ; TfLiteTensor * fw_row_sums = GetTemporary ( context , node , kFwRowSums ) ; TfLiteTensor * bw_row_sums = GetTemporary ( context , node , kBwRowSums ) ; TfLiteTensor * aux_input_quantized = use_aux_input ? GetTemporary ( context , node , kAuxInputQuantized ) : nullptr ; auto * op_data = reinterpret_cast < OpData * > ( node -> user_data ) ; return EvalHybrid ( input , bw_input , fw_input_weights , fw_recurrent_weights , fw_bias , bw_input_weights , bw_recurrent_weights , bw_bias , real_aux_input , fw_aux_input_weights , bw_aux_input_weights , params , scaling_factors , input_quantized , aux_input_quantized , fw_hidden_state_quantized , fw_hidden_state , fw_output , bw_hidden_state_quantized , bw_hidden_state , bw_output , zero_points , accum_scratch , fw_row_sums , bw_row_sums , & op_data -> fw_compute_row_sums , & op_data -> bw_compute_row_sums ) ; } default : context -> ReportError ( context , "Type not currently supported." ) ; return kTfLiteError ; } return kTfLiteOk ; }
void HttpBaseChannel :: MaybeReportTimingData ( ) { if ( XRE_IsE10sParentProcess ( ) ) { return ; } mozilla :: dom :: PerformanceStorage * documentPerformance = GetPerformanceStorage ( ) ; if ( documentPerformance ) { documentPerformance -> AddEntry ( this , this ) ; return ; } if ( ! nsGlobalWindowInner :: GetInnerWindowWithId ( mLoadInfo -> GetInnerWindowID ( ) ) ) { dom :: ContentChild * child = dom :: ContentChild :: GetSingleton ( ) ; if ( ! child ) { return ; } nsAutoString initiatorType ; nsAutoString entryName ; UniquePtr < dom :: PerformanceTimingData > performanceTimingData ( dom :: PerformanceTimingData :: Create ( this , this , 0 , initiatorType , entryName ) ) ; if ( ! performanceTimingData ) { return ; } child -> SendReportFrameTimingData ( mLoadInfo -> GetInnerWindowID ( ) , entryName , initiatorType , std :: move ( performanceTimingData ) ) ; } }
