static OPJ_BOOL opj_j2k_write_epc ( opj_j2k_t * p_j2k , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { opj_codestream_index_t * l_cstr_index = 00 ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; l_cstr_index = p_j2k -> cstr_index ; if ( l_cstr_index ) { l_cstr_index -> codestream_size = ( OPJ_UINT64 ) opj_stream_tell ( p_stream ) ; l_cstr_index -> codestream_size -= ( OPJ_UINT64 ) l_cstr_index -> main_head_start ; } #ifdef USE_JPWL #if 0 if ( cp -> epc_on ) { jpwl_encode ( p_j2k , p_stream , image ) ; } #endif assert ( 0 && "TODO" ) ; #endif /* USE_JPWL */ return OPJ_TRUE ; }
GF_AV1Config * gf_odf_av1_cfg_read_bs_size ( GF_BitStream * bs , u32 size ) { #ifndef GPAC_DISABLE_AV_PARSERS AV1State state ; u8 reserved ; GF_AV1Config * cfg ; if ( ! size ) size = ( u32 ) gf_bs_available ( bs ) ; if ( ! size ) return NULL ; cfg = gf_odf_av1_cfg_new ( ) ; gf_av1_init_state ( & state ) ; state . config = cfg ; cfg -> marker = gf_bs_read_int ( bs , 1 ) ; cfg -> version = gf_bs_read_int ( bs , 7 ) ; cfg -> seq_profile = gf_bs_read_int ( bs , 3 ) ; cfg -> seq_level_idx_0 = gf_bs_read_int ( bs , 5 ) ; cfg -> seq_tier_0 = gf_bs_read_int ( bs , 1 ) ; cfg -> high_bitdepth = gf_bs_read_int ( bs , 1 ) ; cfg -> twelve_bit = gf_bs_read_int ( bs , 1 ) ; cfg -> monochrome = gf_bs_read_int ( bs , 1 ) ; cfg -> chroma_subsampling_x = gf_bs_read_int ( bs , 1 ) ; cfg -> chroma_subsampling_y = gf_bs_read_int ( bs , 1 ) ; cfg -> chroma_sample_position = gf_bs_read_int ( bs , 2 ) ; reserved = gf_bs_read_int ( bs , 3 ) ; if ( reserved != 0 || cfg -> marker != 1 || cfg -> version != 1 ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( "[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\n" , reserved , cfg -> marker , cfg -> version ) ) ; gf_odf_av1_cfg_del ( cfg ) ; return NULL ; } cfg -> initial_presentation_delay_present = gf_bs_read_int ( bs , 1 ) ; if ( cfg -> initial_presentation_delay_present ) { cfg -> initial_presentation_delay_minus_one = gf_bs_read_int ( bs , 4 ) ; } else { gf_bs_read_int ( bs , 4 ) ; cfg -> initial_presentation_delay_minus_one = 0 ; } size -= 4 ; while ( size ) { u64 pos , obu_size ; ObuType obu_type ; GF_AV1_OBUArrayEntry * a ; pos = gf_bs_get_position ( bs ) ; obu_size = 0 ; if ( gf_av1_parse_obu ( bs , & obu_type , & obu_size , NULL , & state ) != GF_OK ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[AV1] could not parse AV1 OBU at position "LLU ". Leaving parsing.\n" , pos ) ) ; break ; } assert ( obu_size == gf_bs_get_position ( bs ) - pos ) ; GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( "[AV1] parsed AV1 OBU type=%u size="LLU " at position "LLU ".\n" , obu_type , obu_size , pos ) ) ; if ( ! av1_is_obu_header ( obu_type ) ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( "[AV1] AV1 unexpected OBU type=%u size="LLU " found at position "LLU ". Forwarding.\n" , pos ) ) ; } GF_SAFEALLOC ( a , GF_AV1_OBUArrayEntry ) ; if ( ! a ) break ; a -> obu = gf_malloc ( ( size_t ) obu_size ) ; if ( ! a -> obu ) { gf_free ( a ) ; break ; } gf_bs_seek ( bs , pos ) ; gf_bs_read_data ( bs , ( char * ) a -> obu , ( u32 ) obu_size ) ; a -> obu_length = obu_size ; a -> obu_type = obu_type ; gf_list_add ( cfg -> obu_array , a ) ; if ( size < obu_size ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( "[AV1] AV1 config misses %d bytes to fit the entire OBU\n" , obu_size - size ) ) ; break ; } size -= ( u32 ) obu_size ; } gf_av1_reset_state ( & state , GF_TRUE ) ; return cfg ; #else return NULL ; #endif }
bool IsPadOpSupported ( const TfLiteRegistration * registration , const TfLiteNode * node , TfLiteContext * context ) { const TfLiteTensor * padding = GetInput ( context , node , 1 ) ; if ( ! IsConstantTensor ( padding ) ) { TF_LITE_KERNEL_LOG ( context , "%s: Only constant padding is supported for PAD." , padding -> name ) ; return false ; } if ( padding -> dims -> data [ 0 ] != 4 || padding -> dims -> data [ 1 ] != 2 ) { TF_LITE_KERNEL_LOG ( context , "%s: Only 4D inputs are supported for PAD." , padding -> name ) ; return false ; } const int32_t * padding_data = GetTensorData < int32_t > ( padding ) ; if ( ! ( padding_data [ 0 ] == 0 && padding_data [ 1 ] == 0 ) ) { TF_LITE_KERNEL_LOG ( context , "%s: Padding for batch dimension is not supported in PAD." , padding -> name ) ; return false ; } if ( ! ( padding_data [ 6 ] == 0 && padding_data [ 7 ] == 0 ) ) { TF_LITE_KERNEL_LOG ( context , "%s: Padding for channel dimension is not supported in PAD." , padding -> name ) ; return false ; } return true ; }
Object * BigIntToStringImpl ( Handle < Object > receiver , Handle < Object > radix , Isolate * isolate , const char * builtin_name ) { Handle < BigInt > x ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , x , ThisBigIntValue ( isolate , receiver , builtin_name ) ) ; int radix_number ; if ( radix -> IsUndefined ( isolate ) ) { radix_number = 10 ; } else { ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , radix , Object :: ToInteger ( isolate , radix ) ) ; radix_number = static_cast < int > ( radix -> Number ( ) ) ; } if ( radix_number < 2 || radix_number > 36 ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewRangeError ( MessageTemplate :: kToRadixFormatRange ) ) ; } RETURN_RESULT_OR_FAILURE ( isolate , BigInt :: ToString ( isolate , x , radix_number ) ) ; }
Response V8InspectorSessionImpl :: unwrapObject ( const String16 & objectId , v8 :: Local < v8 :: Value > * object , v8 :: Local < v8 :: Context > * context , String16 * objectGroup ) { std :: unique_ptr < RemoteObjectId > remoteId ; Response response = RemoteObjectId :: parse ( objectId , & remoteId ) ; if ( ! response . isSuccess ( ) ) return response ; InjectedScript * injectedScript = nullptr ; response = findInjectedScript ( remoteId . get ( ) , injectedScript ) ; if ( ! response . isSuccess ( ) ) return response ; response = injectedScript -> findObject ( * remoteId , object ) ; if ( ! response . isSuccess ( ) ) return response ; * context = injectedScript -> context ( ) -> context ( ) ; if ( objectGroup ) * objectGroup = injectedScript -> objectGroupName ( * remoteId ) ; return Response :: OK ( ) ; }
lyd_new_output_anydata ( struct lyd_node * parent , const struct lys_module * module , const char * name , void * value , LYD_ANYDATA_VALUETYPE value_type ) { const struct lys_node * siblings , * snode ; if ( ( ! parent && ! module ) || ! name ) { LOGARG ; return NULL ; } siblings = lyd_new_find_schema ( parent , module , 1 ) ; if ( ! siblings ) { LOGARG ; return NULL ; } if ( lys_getnext_data ( module , lys_parent ( siblings ) , name , strlen ( name ) , LYS_ANYDATA , & snode ) || ! snode ) { LOGERR ( siblings -> module -> ctx , LY_EINVAL , "Failed to find \"%s\" as a sibling to \"%s:%s\"." , name , lys_node_module ( siblings ) -> name , siblings -> name ) ; return NULL ; } return lyd_create_anydata ( parent , snode , value , value_type ) ; }
BUILTIN ( DatePrototypeSetSeconds ) { HandleScope scope ( isolate ) ; CHECK_RECEIVER ( JSDate , date , "Date.prototype.setSeconds" ) ; int const argc = args . length ( ) - 1 ; Handle < Object > sec = args . atOrUndefined ( isolate , 1 ) ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , sec , Object :: ToNumber ( isolate , sec ) ) ; double time_val = date -> value ( ) -> Number ( ) ; if ( ! std :: isnan ( time_val ) ) { int64_t const time_ms = static_cast < int64_t > ( time_val ) ; int64_t local_time_ms = isolate -> date_cache ( ) -> ToLocal ( time_ms ) ; int day = isolate -> date_cache ( ) -> DaysFromTime ( local_time_ms ) ; int time_within_day = isolate -> date_cache ( ) -> TimeInDay ( local_time_ms , day ) ; int h = time_within_day / ( 60 * 60 * 1000 ) ; double m = ( time_within_day / ( 60 * 1000 ) ) % 60 ; double s = sec -> Number ( ) ; double milli = time_within_day % 1000 ; if ( argc >= 2 ) { Handle < Object > ms = args . at ( 2 ) ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , ms , Object :: ToNumber ( isolate , ms ) ) ; milli = ms -> Number ( ) ; } time_val = MakeDate ( day , MakeTime ( h , m , s , milli ) ) ; } return SetLocalDateValue ( isolate , date , time_val ) ; }
void luaC_barrier_ ( lua_State * L , GCObject * o , GCObject * v ) { global_State * g = G ( L ) ; lua_assert ( isblack ( o ) && iswhite ( v ) && ! isdead ( g , v ) && ! isdead ( g , o ) ) ; if ( keepinvariant ( g ) ) { reallymarkobject ( g , v ) ; if ( isold ( o ) ) { lua_assert ( ! isold ( v ) ) ; setage ( v , G_OLD0 ) ; } } else { lua_assert ( issweepphase ( g ) ) ; makewhite ( g , o ) ; } }
Reduction JSCallReducer :: ReduceReflectApply ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSCall , node -> opcode ( ) ) ; CallParameters const & p = CallParametersOf ( node -> op ( ) ) ; int arity = static_cast < int > ( p . arity ( ) - 2 ) ; DCHECK_LE ( 0 , arity ) ; node -> RemoveInput ( 0 ) ; node -> RemoveInput ( 0 ) ; while ( arity < 3 ) { node -> InsertInput ( graph ( ) -> zone ( ) , arity ++ , jsgraph ( ) -> UndefinedConstant ( ) ) ; } while ( arity -- > 3 ) { node -> RemoveInput ( arity ) ; } NodeProperties :: ChangeOp ( node , javascript ( ) -> CallWithArrayLike ( p . frequency ( ) ) ) ; Reduction const reduction = ReduceJSCallWithArrayLike ( node ) ; return reduction . Changed ( ) ? reduction : Changed ( node ) ; }
BaselineStackBuilder ( IonBailoutIterator & iter , size_t initialSize ) : iter_ ( iter ) , frame_ ( static_cast < IonJSFrameLayout * > ( iter . current ( ) ) ) , bufferTotal_ ( initialSize ) , bufferAvail_ ( 0 ) , bufferUsed_ ( 0 ) , buffer_ ( nullptr ) , header_ ( nullptr ) , framePushed_ ( 0 ) { MOZ_ASSERT ( bufferTotal_ >= HeaderSize ( ) ) ; }
static char * one_input_line ( FILE * in , char * zPrior , int isContinuation ) { char * zPrompt ; char * zResult ; if ( in != 0 ) { zResult = local_getline ( zPrior , in ) ; } else { zPrompt = isContinuation ? continuePrompt : mainPrompt ; #if defined(HAVE_READLINE) free ( zPrior ) ; zResult = readline ( zPrompt ) ; if ( zResult && * zResult ) add_history ( zResult ) ; #else printf ( "%s" , zPrompt ) ; fflush ( stdout ) ; zResult = local_getline ( zPrior , stdin ) ; #endif } return zResult ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { auto * params = reinterpret_cast < TfLiteDivParams * > ( node -> builtin_data ) ; OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; const TfLiteTensor * input1 ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kInputTensor1 , & input1 ) ) ; const TfLiteTensor * input2 ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kInputTensor2 , & input2 ) ) ; TfLiteTensor * output ; TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , kOutputTensor , & output ) ) ; if ( output -> type == kTfLiteFloat32 || output -> type == kTfLiteInt32 ) { EvalDiv < kernel_type > ( context , node , params , data , input1 , input2 , output ) ; } else if ( output -> type == kTfLiteUInt8 ) { TF_LITE_ENSURE_OK ( context , EvalQuantized < kernel_type > ( context , node , params , data , input1 , input2 , output ) ) ; } else { context -> ReportError ( context , "Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d." , output -> type ) ; return kTfLiteError ; } return kTfLiteOk ; }
main ( int argc ATTRIBUTE_UNUSED , char * * argv ATTRIBUTE_UNUSED ) { int i , a , ret = 0 ; int subset = 0 ; initializeLibxml2 ( ) ; for ( a = 1 ; a < argc ; a ++ ) { if ( ! strcmp ( argv [ a ] , "-v" ) ) verbose = 1 ; else if ( ! strcmp ( argv [ a ] , "-u" ) ) update_results = 1 ; else if ( ! strcmp ( argv [ a ] , "-quiet" ) ) tests_quiet = 1 ; else { for ( i = 0 ; testDescriptions [ i ] . func != NULL ; i ++ ) { if ( strstr ( testDescriptions [ i ] . desc , argv [ a ] ) ) { ret += runtest ( i ) ; subset ++ ; } } } } if ( subset == 0 ) { for ( i = 0 ; testDescriptions [ i ] . func != NULL ; i ++ ) { ret += runtest ( i ) ; } } if ( ( nb_errors == 0 ) && ( nb_leaks == 0 ) ) { ret = 0 ; printf ( "Total %d tests, no errors\n" , nb_tests ) ; } else { ret = 1 ; printf ( "Total %d tests, %d errors, %d leaks\n" , nb_tests , nb_errors , nb_leaks ) ; } xmlCleanupParser ( ) ; xmlMemoryDump ( ) ; return ( ret ) ; }
static int net_ctl_permissions ( struct ctl_table_header * head , struct ctl_table * table ) { struct net * net = container_of ( head -> set , struct net , sysctls ) ; kuid_t root_uid = make_kuid ( net -> user_ns , 0 ) ; kgid_t root_gid = make_kgid ( net -> user_ns , 0 ) ; if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) || uid_eq ( root_uid , current_uid ( ) ) ) { int mode = ( table -> mode > > 6 ) & 7 ; return ( mode < < 6 ) | ( mode < < 3 ) | mode ; } if ( gid_eq ( root_gid , current_gid ( ) ) ) { int mode = ( table -> mode > > 3 ) & 7 ; return ( mode < < 3 ) | mode ; } return table -> mode ; }
void Compute ( OpKernelContext * context ) override { const Tensor & boxes = context -> input ( 0 ) ; const Tensor & scores = context -> input ( 1 ) ; const Tensor & max_output_size = context -> input ( 2 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( max_output_size . shape ( ) ) , errors :: InvalidArgument ( "max_output_size must be 0-D, got shape " , max_output_size . shape ( ) . DebugString ( ) ) ) ; const Tensor & iou_threshold = context -> input ( 3 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( iou_threshold . shape ( ) ) , errors :: InvalidArgument ( "iou_threshold must be 0-D, got shape " , iou_threshold . shape ( ) . DebugString ( ) ) ) ; const T iou_threshold_val = iou_threshold . scalar < T > ( ) ( ) ; OP_REQUIRES ( context , iou_threshold_val >= static_cast < T > ( 0.0 ) && iou_threshold_val <= static_cast < T > ( 1.0 ) , errors :: InvalidArgument ( "iou_threshold must be in [0, 1]" ) ) ; const Tensor & score_threshold = context -> input ( 4 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( score_threshold . shape ( ) ) , errors :: InvalidArgument ( "score_threshold must be 0-D, got shape " , score_threshold . shape ( ) . DebugString ( ) ) ) ; const T score_threshold_val = score_threshold . scalar < T > ( ) ( ) ; const Tensor & soft_nms_sigma = context -> input ( 5 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( soft_nms_sigma . shape ( ) ) , errors :: InvalidArgument ( "soft_nms_sigma must be 0-D, got shape " , soft_nms_sigma . shape ( ) . DebugString ( ) ) ) ; const T soft_nms_sigma_val = soft_nms_sigma . scalar < T > ( ) ( ) ; OP_REQUIRES ( context , soft_nms_sigma_val >= static_cast < T > ( 0.0 ) , errors :: InvalidArgument ( "soft_nms_sigma_val must be >= 0" ) ) ; int num_boxes = 0 ; ParseAndCheckBoxSizes ( context , boxes , & num_boxes ) ; CheckScoreSizes ( context , num_boxes , scores ) ; if ( ! context -> status ( ) . ok ( ) ) { return ; } auto similarity_fn = CreateIOUSimilarityFn < T > ( boxes ) ; int num_valid_outputs ; const bool return_scores_tensor_ = true ; DoNonMaxSuppressionOp < T > ( context , scores , num_boxes , max_output_size , iou_threshold_val , score_threshold_val , soft_nms_sigma_val , similarity_fn , return_scores_tensor_ , pad_to_max_output_size_ , & num_valid_outputs ) ; Tensor * num_outputs_t = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 2 , tensorflow :: TensorShape { } , & num_outputs_t ) ) ; num_outputs_t -> scalar < int32 > ( ) . setConstant ( num_valid_outputs ) ; }
void ConstantArrayBuilder :: ConstantArraySlice :: CheckAllElementsAreUnique ( Isolate * isolate ) const { std :: set < Smi * > smis ; std :: set < double > heap_numbers ; std :: set < const AstRawString * > strings ; std :: set < const char * > bigints ; std :: set < const Scope * > scopes ; std :: set < Object * > deferred_objects ; for ( const Entry & entry : constants_ ) { bool duplicate = false ; switch ( entry . tag_ ) { case Entry :: Tag :: kSmi : duplicate = ! smis . insert ( entry . smi_ ) . second ; break ; case Entry :: Tag :: kHeapNumber : duplicate = ! heap_numbers . insert ( entry . heap_number_ ) . second ; break ; case Entry :: Tag :: kRawString : duplicate = ! strings . insert ( entry . raw_string_ ) . second ; break ; case Entry :: Tag :: kBigInt : duplicate = ! bigints . insert ( entry . bigint_ . c_str ( ) ) . second ; break ; case Entry :: Tag :: kScope : duplicate = ! scopes . insert ( entry . scope_ ) . second ; break ; case Entry :: Tag :: kHandle : duplicate = ! deferred_objects . insert ( * entry . handle_ ) . second ; break ; case Entry :: Tag :: kDeferred : UNREACHABLE ( ) ; case Entry :: Tag :: kJumpTableSmi : case Entry :: Tag :: kUninitializedJumpTableSmi : break ; #define CASE_TAG(NAME, ...) case Entry::Tag::k##NAME: SINGLETON_CONSTANT_ENTRY_TYPES ( CASE_TAG ) #undef CASE_TAG break ; } if ( duplicate ) { std :: ostringstream os ; os < < "Duplicate constant found: " < < Brief ( * entry . ToHandle ( isolate ) ) < < std :: endl ; size_t i = start_index ( ) ; for ( const Entry & prev_entry : constants_ ) { os < < i ++ < < ": " < < Brief ( * prev_entry . ToHandle ( isolate ) ) < < std :: endl ; } FATAL ( "%s" , os . str ( ) . c_str ( ) ) ; } } }
static int bgp_capability_msg_parse ( struct peer * peer , u_char * pnt , bgp_size_t length ) { u_char * end ; struct capability cap ; u_char action ; struct bgp * bgp ; afi_t afi ; safi_t safi ; bgp = peer -> bgp ; end = pnt + length ; while ( pnt < end ) { if ( pnt + 3 > end ) { zlog_info ( "%s Capability length error" , peer -> host ) ; bgp_notify_send ( peer , BGP_NOTIFY_CEASE , 0 ) ; return - 1 ; } action = * pnt ; memcpy ( & cap , pnt + 1 , sizeof ( struct capability ) ) ; if ( action != CAPABILITY_ACTION_SET && action != CAPABILITY_ACTION_UNSET ) { zlog_info ( "%s Capability Action Value error %d" , peer -> host , action ) ; bgp_notify_send ( peer , BGP_NOTIFY_CEASE , 0 ) ; return - 1 ; } if ( BGP_DEBUG ( normal , NORMAL ) ) zlog_debug ( "%s CAPABILITY has action: %d, code: %u, length %u" , peer -> host , action , cap . code , cap . length ) ; if ( pnt + ( cap . length + 3 ) > end ) { zlog_info ( "%s Capability length error" , peer -> host ) ; bgp_notify_send ( peer , BGP_NOTIFY_CEASE , 0 ) ; return - 1 ; } if ( cap . code == CAPABILITY_CODE_MP ) { afi = ntohs ( cap . mpc . afi ) ; safi = cap . mpc . safi ; if ( CHECK_FLAG ( peer -> flags , PEER_FLAG_OVERRIDE_CAPABILITY ) ) continue ; if ( ( afi == AFI_IP || afi == AFI_IP6 ) && ( safi == SAFI_UNICAST || safi == SAFI_MULTICAST || safi == BGP_SAFI_VPNV4 ) ) { if ( BGP_DEBUG ( normal , NORMAL ) ) zlog_debug ( "%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u" , peer -> host , action == CAPABILITY_ACTION_SET ? "Advertising" : "Removing" , ntohs ( cap . mpc . afi ) , cap . mpc . safi ) ; if ( safi == BGP_SAFI_VPNV4 ) safi = SAFI_MPLS_VPN ; if ( action == CAPABILITY_ACTION_SET ) { peer -> afc_recv [ afi ] [ safi ] = 1 ; if ( peer -> afc [ afi ] [ safi ] ) { peer -> afc_nego [ afi ] [ safi ] = 1 ; bgp_announce_route ( peer , afi , safi ) ; } } else { peer -> afc_recv [ afi ] [ safi ] = 0 ; peer -> afc_nego [ afi ] [ safi ] = 0 ; if ( peer_active_nego ( peer ) ) bgp_clear_route ( peer , afi , safi ) ; else BGP_EVENT_ADD ( peer , BGP_Stop ) ; } } } else { zlog_warn ( "%s unrecognized capability code: %d - ignored" , peer -> host , cap . code ) ; } pnt += cap . length + 3 ; }
pixFillMapHoles ( PIX * pix , l_int32 nx , l_int32 ny , l_int32 filltype ) { l_int32 w , h , y , nmiss , goodcol , i , j , found , ival , valtest ; l_uint32 val , lastval ; NUMA * na ; PIX * pixt ; PROCNAME ( "pixFillMapHoles" ) ; if ( ! pix || pixGetDepth ( pix ) != 8 ) return ERROR_INT ( "pix not defined or not 8 bpp" , procName , 1 ) ; if ( pixGetColormap ( pix ) ) return ERROR_INT ( "pix is colormapped" , procName , 1 ) ; pixGetDimensions ( pix , & w , & h , NULL ) ; na = numaCreate ( 0 ) ; nmiss = 0 ; valtest = ( filltype == L_FILL_WHITE ) ? 255 : 0 ; for ( j = 0 ; j < nx ; j ++ ) { found = FALSE ; for ( i = 0 ; i < ny ; i ++ ) { pixGetPixel ( pix , j , i , & val ) ; if ( val != valtest ) { y = i ; found = TRUE ; break ; } } if ( found == FALSE ) { numaAddNumber ( na , 0 ) ; nmiss ++ ; } else { numaAddNumber ( na , 1 ) ; for ( i = y - 1 ; i >= 0 ; i -- ) pixSetPixel ( pix , j , i , val ) ; pixGetPixel ( pix , j , 0 , & lastval ) ; for ( i = 1 ; i < h ; i ++ ) { pixGetPixel ( pix , j , i , & val ) ; if ( val == valtest ) pixSetPixel ( pix , j , i , lastval ) ; else lastval = val ; } } } numaAddNumber ( na , 0 ) ; if ( nmiss == nx ) { numaDestroy ( & na ) ; L_WARNING ( "no bg found; no data in any column\n" , procName ) ; return 1 ; } if ( nmiss > 0 ) { pixt = pixCopy ( NULL , pix ) ; goodcol = 0 ; for ( j = 0 ; j < w ; j ++ ) { numaGetIValue ( na , j , & ival ) ; if ( ival == 1 ) { goodcol = j ; break ; } } if ( goodcol > 0 ) { for ( j = goodcol - 1 ; j >= 0 ; j -- ) { pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j + 1 , 0 ) ; pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; } } for ( j = goodcol + 1 ; j < w ; j ++ ) { numaGetIValue ( na , j , & ival ) ; if ( ival == 0 ) { pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j - 1 , 0 ) ; pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; } } pixDestroy ( & pixt ) ; } if ( w > nx ) { for ( i = 0 ; i < h ; i ++ ) { pixGetPixel ( pix , w - 2 , i , & val ) ; pixSetPixel ( pix , w - 1 , i , val ) ; } } numaDestroy ( & na ) ; return 0 ; }
TF_BUILTIN ( SetPrototypeForEach , CollectionsBuiltinsAssembler ) { const char * const kMethodName = "Set.prototype.forEach" ; Node * const argc = Parameter ( Descriptor :: kJSActualArgumentsCount ) ; Node * const context = Parameter ( Descriptor :: kContext ) ; CodeStubArguments args ( this , ChangeInt32ToIntPtr ( argc ) ) ; Node * const receiver = args . GetReceiver ( ) ; Node * const callback = args . GetOptionalArgumentValue ( 0 ) ; Node * const this_arg = args . GetOptionalArgumentValue ( 1 ) ; ThrowIfNotInstanceType ( context , receiver , JS_SET_TYPE , kMethodName ) ; Label callback_not_callable ( this , Label :: kDeferred ) ; GotoIf ( TaggedIsSmi ( callback ) , & callback_not_callable ) ; GotoIfNot ( IsCallable ( callback ) , & callback_not_callable ) ; TVARIABLE ( IntPtrT , var_index , IntPtrConstant ( 0 ) ) ; TVARIABLE ( OrderedHashSet , var_table , CAST ( LoadObjectField ( receiver , JSSet :: kTableOffset ) ) ) ; Label loop ( this , { & var_index , & var_table } ) , done_loop ( this ) ; Goto ( & loop ) ; BIND ( & loop ) ; { TNode < IntPtrT > index = var_index . value ( ) ; TNode < OrderedHashSet > table = var_table . value ( ) ; std :: tie ( table , index ) = Transition < OrderedHashSet > ( table , index , [ ] ( Node * , Node * ) { } ) ; Node * entry_key ; Node * entry_start_position ; std :: tie ( entry_key , entry_start_position , index ) = NextSkipHoles < OrderedHashSet > ( table , index , & done_loop ) ; CallJS ( CodeFactory :: Call ( isolate ( ) ) , context , callback , this_arg , entry_key , entry_key , receiver ) ; var_index = index ; var_table = table ; Goto ( & loop ) ; } BIND ( & done_loop ) ; args . PopAndReturn ( UndefinedConstant ( ) ) ; BIND ( & callback_not_callable ) ; { CallRuntime ( Runtime :: kThrowCalledNonCallable , context , callback ) ; Unreachable ( ) ; } }
static irqreturn_t armv7pmu_handle_irq ( int irq_num , void * dev ) { unsigned long pmnc ; struct perf_sample_data data ; struct cpu_hw_events * cpuc ; struct pt_regs * regs ; int idx ; pmnc = armv7_pmnc_getreset_flags ( ) ; if ( ! armv7_pmnc_has_overflowed ( pmnc ) ) return IRQ_NONE ; regs = get_irq_regs ( ) ; perf_sample_data_init ( & data , 0 ) ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; for ( idx = 0 ; idx <= armpmu -> num_events ; ++ idx ) { struct perf_event * event = cpuc -> events [ idx ] ; struct hw_perf_event * hwc ; if ( ! test_bit ( idx , cpuc -> active_mask ) ) continue ; if ( ! armv7_pmnc_counter_has_overflowed ( pmnc , idx ) ) continue ; hwc = & event -> hw ; armpmu_event_update ( event , hwc , idx , 1 ) ; data . period = event -> hw . last_period ; if ( ! armpmu_event_set_period ( event , hwc , idx ) ) continue ; if ( perf_event_overflow ( event , 0 , & data , regs ) ) armpmu -> disable ( hwc , idx ) ; } irq_work_run ( ) ; return IRQ_HANDLED ; }
ModuleResult FinishDecoding ( bool verify_functions = true ) { if ( ok ( ) ) { CalculateGlobalOffsets ( module_ . get ( ) ) ; } ModuleResult result = toResult ( std :: move ( module_ ) ) ; if ( verify_functions && result . ok ( ) ) { result . MoveErrorFrom ( intermediate_result_ ) ; } return result ; }
int rose_rx_call_request ( struct sk_buff * skb , struct net_device * dev , struct rose_neigh * neigh , unsigned int lci ) { struct sock * sk ; struct sock * make ; struct rose_sock * make_rose ; struct rose_facilities_struct facilities ; int n , len ; skb -> sk = NULL ; memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; len = ( ( ( skb -> data [ 3 ] > > 4 ) & 0x0F ) + 1 ) > > 1 ; len += ( ( ( skb -> data [ 3 ] > > 0 ) & 0x0F ) + 1 ) > > 1 ; if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ; return 0 ; } sk = rose_find_listener ( & facilities . source_addr , & facilities . source_call ) ; if ( sk == NULL || sk_acceptq_is_full ( sk ) || ( make = rose_make_new ( sk ) ) == NULL ) { rose_transmit_clear_request ( neigh , lci , ROSE_NETWORK_CONGESTION , 120 ) ; return 0 ; } skb -> sk = make ; make -> sk_state = TCP_ESTABLISHED ; make_rose = rose_sk ( make ) ; make_rose -> lci = lci ; make_rose -> dest_addr = facilities . dest_addr ; make_rose -> dest_call = facilities . dest_call ; make_rose -> dest_ndigis = facilities . dest_ndigis ; for ( n = 0 ; n < facilities . dest_ndigis ; n ++ ) make_rose -> dest_digis [ n ] = facilities . dest_digis [ n ] ; make_rose -> source_addr = facilities . source_addr ; make_rose -> source_call = facilities . source_call ; make_rose -> source_ndigis = facilities . source_ndigis ; for ( n = 0 ; n < facilities . source_ndigis ; n ++ ) make_rose -> source_digis [ n ] = facilities . source_digis [ n ] ; make_rose -> neighbour = neigh ; make_rose -> device = dev ; make_rose -> facilities = facilities ; make_rose -> neighbour -> use ++ ; if ( rose_sk ( sk ) -> defer ) { make_rose -> state = ROSE_STATE_5 ; } else { rose_write_internal ( make , ROSE_CALL_ACCEPTED ) ; make_rose -> state = ROSE_STATE_3 ; rose_start_idletimer ( make ) ; } make_rose -> condition = 0x00 ; make_rose -> vs = 0 ; make_rose -> va = 0 ; make_rose -> vr = 0 ; make_rose -> vl = 0 ; sk -> sk_ack_backlog ++ ; rose_insert_socket ( make ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; rose_start_heartbeat ( make ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_data_ready ( sk , skb -> len ) ; return 1 ; }
nsSVGDisplayContainerFrame :: IsSVGTransformed ( gfxMatrix * aOwnTransform , gfxMatrix * aFromParentTransform ) const { bool foundTransform = false ; nsIFrame * parent = GetParent ( ) ; if ( parent && parent -> IsFrameOfType ( nsIFrame :: eSVG | nsIFrame :: eSVGContainer ) ) { foundTransform = static_cast < nsSVGContainerFrame * > ( parent ) -> HasChildrenOnlyTransform ( aFromParentTransform ) ; } nsSVGElement * content = static_cast < nsSVGElement * > ( mContent ) ; if ( content -> GetAnimatedTransformList ( ) || content -> GetAnimateMotionTransform ( ) ) { if ( aOwnTransform ) { * aOwnTransform = content -> PrependLocalTransformsTo ( gfxMatrix ( ) , nsSVGElement :: eUserSpaceToParent ) ; } foundTransform = true ; } return foundTransform ; }
PresShell :: DoReflow ( nsIFrame * target , bool aInterruptible ) { NS_TIME_FUNCTION_WITH_DOCURL ; nsAutoCString docURL ( "N/A" ) ; nsIURI * uri = mDocument -> GetDocumentURI ( ) ; if ( uri ) uri -> GetSpec ( docURL ) ; SAMPLE_LABEL_PRINTF ( "layout" , "DoReflow" , "(%s)" , docURL . get ( ) ) ; if ( mReflowContinueTimer ) { mReflowContinueTimer -> Cancel ( ) ; mReflowContinueTimer = nullptr ; } nsIFrame * rootFrame = mFrameConstructor -> GetRootFrame ( ) ; nsRefPtr < nsRenderingContext > rcx = GetReferenceRenderingContext ( ) ; if ( ! rcx ) { NS_NOTREACHED ( "CreateRenderingContext failure" ) ; return false ; } #ifdef DEBUG mCurrentReflowRoot = target ; #endif target -> WillReflow ( mPresContext ) ; nsSize size ; if ( target == rootFrame ) { size = mPresContext -> GetVisibleArea ( ) . Size ( ) ; target -> InvalidateRectDifference ( mPresContext -> GetVisibleArea ( ) , target -> GetRect ( ) ) ; } else { size = target -> GetSize ( ) ; } NS_ASSERTION ( ! target -> GetNextInFlow ( ) && ! target -> GetPrevInFlow ( ) , "reflow roots should never split" ) ; nsSize reflowSize ( size . width , NS_UNCONSTRAINEDSIZE ) ; nsHTMLReflowState reflowState ( mPresContext , target , rcx , reflowSize ) ; if ( rootFrame == target ) { bool hasUnconstrainedHeight = size . height == NS_UNCONSTRAINEDSIZE ; if ( hasUnconstrainedHeight || mLastRootReflowHadUnconstrainedHeight ) { reflowState . mFlags . mVResize = true ; } mLastRootReflowHadUnconstrainedHeight = hasUnconstrainedHeight ; } NS_ASSERTION ( reflowState . mComputedMargin == nsMargin ( 0 , 0 , 0 , 0 ) , "reflow state should not set margin for reflow roots" ) ; if ( size . height != NS_UNCONSTRAINEDSIZE ) { nscoord computedHeight = size . height - reflowState . mComputedBorderPadding . TopBottom ( ) ; computedHeight = NS_MAX ( computedHeight , 0 ) ; reflowState . SetComputedHeight ( computedHeight ) ; } NS_ASSERTION ( reflowState . ComputedWidth ( ) == size . width - reflowState . mComputedBorderPadding . LeftRight ( ) , "reflow state computed incorrect width" ) ; mPresContext -> ReflowStarted ( aInterruptible ) ; mIsReflowing = true ; nsReflowStatus status ; nsHTMLReflowMetrics desiredSize ; target -> Reflow ( mPresContext , desiredSize , reflowState , status ) ; nsRect boundsRelativeToTarget = nsRect ( 0 , 0 , desiredSize . width , desiredSize . height ) ; NS_ASSERTION ( ( target == rootFrame && size . height == NS_UNCONSTRAINEDSIZE ) || ( desiredSize . width == size . width && desiredSize . height == size . height ) , "non-root frame's desired size changed during an " "incremental reflow" ) ; NS_ASSERTION ( target == rootFrame || desiredSize . VisualOverflow ( ) . IsEqualInterior ( boundsRelativeToTarget ) , "non-root reflow roots must not have visible overflow" ) ; NS_ASSERTION ( target == rootFrame || desiredSize . ScrollableOverflow ( ) . IsEqualEdges ( boundsRelativeToTarget ) , "non-root reflow roots must not have scrollable overflow" ) ; NS_ASSERTION ( status == NS_FRAME_COMPLETE , "reflow roots should never split" ) ; target -> SetSize ( boundsRelativeToTarget . Size ( ) ) ; nsContainerFrame :: SyncFrameViewAfterReflow ( mPresContext , target , target -> GetView ( ) , boundsRelativeToTarget ) ; nsContainerFrame :: SyncWindowProperties ( mPresContext , target , target -> GetView ( ) , rcx ) ; target -> DidReflow ( mPresContext , nullptr , NS_FRAME_REFLOW_FINISHED ) ; if ( target == rootFrame && size . height == NS_UNCONSTRAINEDSIZE ) { mPresContext -> SetVisibleArea ( boundsRelativeToTarget ) ; } #ifdef DEBUG mCurrentReflowRoot = nullptr ; #endif NS_ASSERTION ( mPresContext -> HasPendingInterrupt ( ) || mFramesToDirty . Count ( ) == 0 , "Why do we need to dirty anything if not interrupted?" ) ; mIsReflowing = false ; bool interrupted = mPresContext -> HasPendingInterrupt ( ) ; if ( interrupted ) { mFramesToDirty . EnumerateEntries ( & MarkFramesDirtyToRoot , target ) ; NS_ASSERTION ( NS_SUBTREE_DIRTY ( target ) , "Why is the target not dirty?" ) ; mDirtyRoots . AppendElement ( target ) ; mDocument -> SetNeedLayoutFlush ( ) ; #ifdef NOISY_INTERRUPTIBLE_REFLOW printf ( "mFramesToDirty.Count() == %u\n" , mFramesToDirty . Count ( ) ) ; #endif /* NOISY_INTERRUPTIBLE_REFLOW */ mFramesToDirty . Clear ( ) ; mSuppressInterruptibleReflows = true ; MaybeScheduleReflow ( ) ; } nsRootPresContext * rootPC = mPresContext -> GetRootPresContext ( ) ; if ( rootPC ) { rootPC -> RequestUpdatePluginGeometry ( target ) ; } return ! interrupted ; }
gstd_accept ( int fd , char * * display_creds , char * * export_name , char * * mech ) { gss_name_t client ; gss_OID mech_oid ; struct gstd_tok * tok ; gss_ctx_id_t ctx = GSS_C_NO_CONTEXT ; gss_buffer_desc in , out ; OM_uint32 maj , min ; int ret ; * display_creds = NULL ; * export_name = NULL ; out . length = 0 ; in . length = 0 ; read_packet ( fd , & in , 60000 , 1 ) ; again : while ( ( ret = read_packet ( fd , & in , 60000 , 0 ) ) == - 2 ) ; if ( ret < 1 ) return NULL ; maj = gss_accept_sec_context ( & min , & ctx , GSS_C_NO_CREDENTIAL , & in , GSS_C_NO_CHANNEL_BINDINGS , & client , & mech_oid , & out , NULL , NULL , NULL ) ; if ( out . length && write_packet ( fd , & out ) ) { gss_release_buffer ( & min , & out ) ; return NULL ; } GSTD_GSS_ERROR ( maj , min , NULL , "gss_accept_sec_context" ) ; if ( maj & GSS_S_CONTINUE_NEEDED ) goto again ; * display_creds = gstd_get_display_name ( client ) ; * export_name = gstd_get_export_name ( client ) ; * mech = gstd_get_mech ( mech_oid ) ; gss_release_name ( & min , & client ) ; SETUP_GSTD_TOK ( tok , ctx , fd , "gstd_accept" ) ; return tok ; }
int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ; if ( s -> codec_tag == AV_RL32 ( "WV1F" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( "QMP4" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , "frame skip %d\n" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode < < 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , "startcode: %3X " , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video Object Start" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video Object Layer Start" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Reserved" ) ; else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , "FGS bp start" ) ; else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , "Reserved" ) ; else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual Object Seq Start" ) ; else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual Object Seq End" ) ; else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , "User Data" ) ; else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Group of VOP start" ) ; else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video Session Error" ) ; else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual Object Start" ) ; else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video Object Plane start" ) ; else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , "slice start" ) ; else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , "extension start" ) ; else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , "fgs start" ) ; else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , "FBA Object start" ) ; else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , "FBA Object Plane start" ) ; else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , "Mesh Object start" ) ; else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , "Mesh Object Plane start" ) ; else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , "Still Texture Object start" ) ; else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture Spatial Layer start" ) ; else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture SNR Layer start" ) ; else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture Tile start" ) ; else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture Shape Layer start" ) ; else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , "stuffing start" ) ; else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , "reserved" ) ; else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , "System start" ) ; av_log ( s -> avctx , AV_LOG_DEBUG , " at %d\n" , get_bits_count ( gb ) ) ; } if ( startcode >= 0x120 && startcode <= 0x12F ) { if ( vol ) { av_log ( s -> avctx , AV_LOG_WARNING , "Ignoring multiple VOL headers\n" ) ; continue ; } vol ++ ; if ( ( ret = decode_vol_header ( ctx , gb ) ) < 0 ) return ret ; } else if ( startcode == USER_DATA_STARTCODE ) { decode_user_data ( ctx , gb ) ; } else if ( startcode == GOP_STARTCODE ) { mpeg4_decode_gop_header ( s , gb ) ; } else if ( startcode == VOS_STARTCODE ) { int profile , level ; mpeg4_decode_profile_level ( s , gb , & profile , & level ) ; if ( profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( level > 0 && level < 9 ) ) { s -> studio_profile = 1 ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 0 ) ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , "Mixes studio and non studio profile\n" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; } else if ( startcode == VISUAL_OBJ_STARTCODE ) { if ( s -> studio_profile ) { if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ; } else mpeg4_decode_visual_object ( s , gb ) ; } else if ( startcode == VOP_STARTCODE ) { break ; } align_get_bits ( gb ) ; startcode = 0xff ; } end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; s -> avctx -> has_b_frames = ! s -> low_delay ; if ( s -> studio_profile ) { av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; if ( ! s -> avctx -> bits_per_raw_sample ) { av_log ( s -> avctx , AV_LOG_ERROR , "Missing VOL header\n" ) ; return AVERROR_INVALIDDATA ; } return decode_studio_vop_header ( ctx , gb ) ; } else return decode_vop_header ( ctx , gb ) ; }
u32 gf_bs_read_ue_log_idx3 ( GF_BitStream * bs , const char * fname , s32 idx1 , s32 idx2 , s32 idx3 ) { u32 val = 0 , code ; s32 nb_lead = - 1 ; u32 bits = 0 ; for ( code = 0 ; ! code ; nb_lead ++ ) { if ( nb_lead >= 32 ) { if ( ! gf_bs_available ( bs ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( "[Core] exp-golomb read failed, not enough bits in bitstream !\n" ) ) ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( "[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n" , nb_lead ) ) ; } return 0 ; } code = gf_bs_read_int ( bs , 1 ) ; bits ++ ; } if ( nb_lead ) { u32 leads = 1 ; val = gf_bs_read_int ( bs , nb_lead ) ; leads <<= nb_lead ; leads -= 1 ; val += leads ; bits += nb_lead ; } if ( fname ) { gf_bs_log_idx ( bs , bits , fname , val , idx1 , idx2 , idx3 ) ; } return val ; }
static pj_status_t respond_digest ( pj_pool_t * pool , pjsip_digest_credential * cred , const pjsip_digest_challenge * chal , const pj_str_t * uri , const pjsip_cred_info * cred_info , const pj_str_t * cnonce , pj_uint32_t nc , const pj_str_t * method ) { const pj_str_t pjsip_AKAv1_MD5_STR = { "AKAv1-MD5" , 9 } ; pj_bool_t algo_sha256 = PJ_FALSE ; #if PJSIP_AUTH_HAS_DIGEST_SHA256 algo_sha256 = ( pj_stricmp ( & chal -> algorithm , & pjsip_SHA256_STR ) == 0 ) ; #endif if ( chal -> algorithm . slen == 0 || ( algo_sha256 || pj_stricmp ( & chal -> algorithm , & pjsip_MD5_STR ) == 0 || pj_stricmp ( & chal -> algorithm , & pjsip_AKAv1_MD5_STR ) == 0 ) ) { PJ_LOG ( 4 , ( THIS_FILE , "Digest algorithm is \"%.*s\"" , chal -> algorithm . slen , chal -> algorithm . ptr ) ) ; } else { PJ_LOG ( 4 , ( THIS_FILE , "Unsupported digest algorithm \"%.*s\"" , chal -> algorithm . slen , chal -> algorithm . ptr ) ) ; return PJSIP_EINVALIDALGORITHM ; } pj_strdup ( pool , & cred -> username , & cred_info -> username ) ; pj_strdup ( pool , & cred -> realm , & chal -> realm ) ; pj_strdup ( pool , & cred -> nonce , & chal -> nonce ) ; pj_strdup ( pool , & cred -> uri , uri ) ; pj_strdup ( pool , & cred -> algorithm , & chal -> algorithm ) ; pj_strdup ( pool , & cred -> opaque , & chal -> opaque ) ; cred -> response . slen = algo_sha256 ? PJSIP_SHA256STRLEN : PJSIP_MD5STRLEN ; cred -> response . ptr = ( char * ) pj_pool_alloc ( pool , cred -> response . slen ) ; if ( chal -> qop . slen == 0 ) { if ( ( cred_info -> data_type & EXT_MASK ) == PJSIP_CRED_DATA_EXT_AKA ) { return ( * cred_info -> ext . aka . cb ) ( pool , chal , cred_info , method , cred ) ; } else { if ( algo_sha256 ) { pjsip_auth_create_digestSHA256 ( & cred -> response , & cred -> nonce , NULL , NULL , NULL , uri , & chal -> realm , cred_info , method ) ; } else { pjsip_auth_create_digest ( & cred -> response , & cred -> nonce , NULL , NULL , NULL , uri , & chal -> realm , cred_info , method ) ; } } } else if ( has_auth_qop ( pool , & chal -> qop ) ) { cred -> qop = pjsip_AUTH_STR ; cred -> nc . ptr = ( char * ) pj_pool_alloc ( pool , 16 ) ; cred -> nc . slen = pj_ansi_snprintf ( cred -> nc . ptr , 16 , "%08u" , nc ) ; if ( cnonce && cnonce -> slen ) { pj_strdup ( pool , & cred -> cnonce , cnonce ) ; } else { pj_str_t dummy_cnonce = { "b39971" , 6 } ; pj_strdup ( pool , & cred -> cnonce , & dummy_cnonce ) ; } if ( ( cred_info -> data_type & EXT_MASK ) == PJSIP_CRED_DATA_EXT_AKA ) { return ( * cred_info -> ext . aka . cb ) ( pool , chal , cred_info , method , cred ) ; } else { if ( algo_sha256 ) { pjsip_auth_create_digestSHA256 ( & cred -> response , & cred -> nonce , & cred -> nc , & cred -> cnonce , & pjsip_AUTH_STR , uri , & chal -> realm , cred_info , method ) ; } else { pjsip_auth_create_digest ( & cred -> response , & cred -> nonce , & cred -> nc , & cred -> cnonce , & pjsip_AUTH_STR , uri , & chal -> realm , cred_info , method ) ; } } } else { PJ_LOG ( 4 , ( THIS_FILE , "Unsupported qop offer %.*s" , chal -> qop . slen , chal -> qop . ptr ) ) ; return PJSIP_EINVALIDQOP ; } return PJ_SUCCESS ; }
FT_MulFix ( FT_Long a_ , FT_Long b_ ) { #ifdef FT_MULFIX_ASSEMBLER return FT_MULFIX_ASSEMBLER ( a_ , b_ ) ; #elif 0 FT_Long sa , sb ; FT_UInt32 a , b ; if ( a_ == 0 || b_ == 0x10000L ) return a_ ; sa = ( a_ > > ( sizeof ( a_ ) * 8 - 1 ) ) ; a = ( a_ ^ sa ) - sa ; sb = ( b_ > > ( sizeof ( b_ ) * 8 - 1 ) ) ; b = ( b_ ^ sb ) - sb ; a = ( FT_UInt32 ) a_ ; b = ( FT_UInt32 ) b_ ; if ( a + ( b > > 8 ) <= 8190UL ) a = ( a * b + 0x8000U ) > > 16 ; else { FT_UInt32 al = a & 0xFFFFUL ; a = ( a > > 16 ) * b + al * ( b > > 16 ) + ( ( al * ( b & 0xFFFFUL ) + 0x8000UL ) > > 16 ) ; } sa ^= sb ; a = ( a ^ sa ) - sa ; return ( FT_Long ) a ; #else /* 0 */ FT_Int s = 1 ; FT_UInt32 a , b ; if ( a_ == 0 || b_ == 0x10000L ) return a_ ; FT_MOVE_SIGN ( a_ , s ) ; FT_MOVE_SIGN ( b_ , s ) ; a = ( FT_UInt32 ) a_ ; b = ( FT_UInt32 ) b_ ; if ( a + ( b > > 8 ) <= 8190UL ) a = ( a * b + 0x8000UL ) > > 16 ; else { FT_UInt32 al = a & 0xFFFFUL ; a = ( a > > 16 ) * b + al * ( b > > 16 ) + ( ( al * ( b & 0xFFFFUL ) + 0x8000UL ) > > 16 ) ; } a_ = ( FT_Long ) a ; return s < 0 ? - a_ : a_ ; #endif /* 0 */ }
nsMutationReceiver :: ContentRemoved ( nsIDocument * aDocument , nsIContent * aContainer , nsIContent * aChild , int32_t aIndexInContainer , nsIContent * aPreviousSibling ) { if ( aChild -> IsInNativeAnonymousSubtree ( ) ) { return ; } nsINode * parent = NODE_FROM ( aContainer , aDocument ) ; if ( nsAutoMutationBatch :: IsBatching ( ) ) { if ( nsAutoMutationBatch :: IsRemovalDone ( ) ) { return ; } if ( nsAutoMutationBatch :: GetBatchTarget ( ) != parent ) { return ; } bool wantsChildList = ChildList ( ) && ( Subtree ( ) || parent == Target ( ) ) ; if ( wantsChildList || Subtree ( ) ) { nsAutoMutationBatch :: NodeRemoved ( aChild ) ; nsAutoMutationBatch :: UpdateObserver ( Observer ( ) , wantsChildList ) ; } return ; } if ( Subtree ( ) ) { nsMutationReceiver * orig = GetParent ( ) ? GetParent ( ) : this ; if ( Observer ( ) -> GetReceiverFor ( aChild , false ) != orig ) { bool transientExists = false ; nsCOMArray < nsMutationReceiver > * transientReceivers = nullptr ; Observer ( ) -> mTransientReceivers . Get ( aChild , & transientReceivers ) ; if ( ! transientReceivers ) { transientReceivers = new nsCOMArray < nsMutationReceiver > ( ) ; Observer ( ) -> mTransientReceivers . Put ( aChild , transientReceivers ) ; } else { for ( int32_t i = 0 ; i < transientReceivers -> Count ( ) ; ++ i ) { nsMutationReceiver * r = transientReceivers -> ObjectAt ( i ) ; if ( r -> GetParent ( ) == orig ) { transientExists = true ; } } } if ( ! transientExists ) { transientReceivers -> AppendObject ( new nsMutationReceiver ( aChild , orig ) ) ; } } } if ( ChildList ( ) && ( Subtree ( ) || parent == Target ( ) ) ) { nsDOMMutationRecord * m = Observer ( ) -> CurrentRecord ( NS_LITERAL_STRING ( "childList" ) ) ; if ( m -> mTarget ) { return ; } m -> mTarget = parent ; m -> mRemovedNodes = new nsSimpleContentList ( parent ) ; m -> mRemovedNodes -> AppendElement ( aChild ) ; m -> mPreviousSibling = aPreviousSibling ; m -> mNextSibling = parent -> GetChildAt ( aIndexInContainer ) ; } Observer ( ) -> ScheduleForRun ( ) ; }
Filter ( JSContext * cx , JSObject * wrapper , AutoIdVector & props ) { size_t w = 0 ; for ( size_t n = 0 ; n < props . length ( ) ; ++ n ) { jsid id = props [ n ] ; Permission perm ; if ( ! Policy :: check ( cx , wrapper , id , Wrapper :: GET , perm ) ) return false ; if ( perm != DenyAccess ) props [ w ++ ] = id ; } props . resize ( w ) ; return true ; }
int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) { dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; struct flush_cmd_control * fcc ; int err = 0 ; if ( SM_I ( sbi ) -> fcc_info ) { fcc = SM_I ( sbi ) -> fcc_info ; goto init_thread ; } fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , GFP_KERNEL ) ; if ( ! fcc ) return - ENOMEM ; atomic_set ( & fcc -> issued_flush , 0 ) ; atomic_set ( & fcc -> issing_flush , 0 ) ; init_waitqueue_head ( & fcc -> flush_wait_queue ) ; init_llist_head ( & fcc -> issue_list ) ; SM_I ( sbi ) -> fcc_info = fcc ; init_thread : fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , "f2fs_flush-%u:%u" , MAJOR ( dev ) , MINOR ( dev ) ) ; if ( IS_ERR ( fcc -> f2fs_issue_flush ) ) { err = PTR_ERR ( fcc -> f2fs_issue_flush ) ; kfree ( fcc ) ; SM_I ( sbi ) -> fcc_info = NULL ; return err ; } return err ; }
mjit :: Compiler :: finishLoop ( jsbytecode * head ) { if ( ! cx -> typeInferenceEnabled ( ) || ! bytecodeInChunk ( head ) ) return true ; JS_ASSERT ( loop && loop -> headOffset ( ) == uint32_t ( head - script_ -> code ) ) ; jsbytecode * entryTarget = script_ -> code + loop -> entryOffset ( ) ; Jump fallthrough = masm . jump ( ) ; #ifdef DEBUG if ( IsJaegerSpewChannelActive ( JSpew_Regalloc ) ) { RegisterAllocation * alloc = analysis -> getAllocation ( head ) ; JaegerSpew ( JSpew_Regalloc , "loop allocation at %u:" , unsigned ( head - script_ -> code ) ) ; frame . dumpAllocation ( alloc ) ; } #endif loop -> entryJump ( ) . linkTo ( masm . label ( ) , & masm ) ; jsbytecode * oldPC = PC ; PC = entryTarget ; { OOL_STUBCALL ( stubs :: MissedBoundsCheckEntry , REJOIN_RESUME ) ; if ( loop -> generatingInvariants ( ) ) { if ( oomInVector ) return false ; Label label = callSites [ callSites . length ( ) - 1 ] . loopJumpLabel ; stubcc . linkExitDirect ( masm . jump ( ) , label ) ; } stubcc . crossJump ( stubcc . masm . jump ( ) , masm . label ( ) ) ; } PC = oldPC ; frame . prepareForJump ( entryTarget , masm , true ) ; if ( ! jumpInScript ( masm . jump ( ) , entryTarget ) ) return false ; PC = head ; if ( ! analysis -> getCode ( head ) . safePoint ) { LoopEntry entry ; entry . pcOffset = head - script_ -> code ; OOL_STUBCALL ( stubs :: MissedBoundsCheckHead , REJOIN_RESUME ) ; if ( loop -> generatingInvariants ( ) ) { if ( oomInVector ) return false ; entry . label = callSites [ callSites . length ( ) - 1 ] . loopJumpLabel ; } else { entry . label = stubcc . masm . label ( ) ; } for ( uint32_t slot = ArgSlot ( 0 ) ; slot < TotalSlots ( script_ ) ; slot ++ ) { if ( a -> varTypes [ slot ] . getTypeTag ( ) == JSVAL_TYPE_DOUBLE ) { FrameEntry * fe = frame . getSlotEntry ( slot ) ; stubcc . masm . ensureInMemoryDouble ( frame . addressOf ( fe ) ) ; } } const SlotValue * newv = analysis -> newValues ( head ) ; if ( newv ) { while ( newv -> slot ) { if ( newv -> value . kind ( ) == SSAValue :: PHI && newv -> value . phiOffset ( ) == uint32_t ( head - script_ -> code ) && analysis -> trackSlot ( newv -> slot ) ) { JS_ASSERT ( newv -> slot < TotalSlots ( script_ ) ) ; types :: StackTypeSet * targetTypes = analysis -> getValueTypes ( newv -> value ) ; if ( targetTypes -> getKnownTypeTag ( ) == JSVAL_TYPE_DOUBLE ) { FrameEntry * fe = frame . getSlotEntry ( newv -> slot ) ; stubcc . masm . ensureInMemoryDouble ( frame . addressOf ( fe ) ) ; } } newv ++ ; } } frame . prepareForJump ( head , stubcc . masm , true ) ; if ( ! stubcc . jumpInScript ( stubcc . masm . jump ( ) , head ) ) return false ; loopEntries . append ( entry ) ; } PC = oldPC ; loop -> flushLoop ( stubcc ) ; LoopState * nloop = loop -> outer ; js_delete ( loop ) ; loop = nloop ; frame . setLoop ( loop ) ; fallthrough . linkTo ( masm . label ( ) , & masm ) ; frame . clearTemporaries ( ) ; return true ; }
XREMain :: XRE_main ( int argc , char * argv [ ] , const nsXREAppData * aAppData ) { ScopedLogging log ; char aLocal ; GeckoProfilerInitRAII profilerGuard ( & aLocal ) ; PROFILER_LABEL ( "Startup" , "XRE_Main" , js :: ProfileEntry :: Category :: OTHER ) ; nsresult rv = NS_OK ; gArgc = argc ; gArgv = argv ; NS_ENSURE_TRUE ( aAppData , 2 ) ; mStatisticsRecorder = MakeUnique < base :: StatisticsRecorder > ( ) ; mAppData = new ScopedAppData ( aAppData ) ; if ( ! mAppData ) return 1 ; if ( ! mAppData -> remotingName ) { SetAllocatedString ( mAppData -> remotingName , mAppData -> name ) ; } gAppData = mAppData ; mozilla :: IOInterposerInit ioInterposerGuard ; #if MOZ_WIDGET_GTK == 2 XRE_GlibInit ( ) ; #endif bool exit = false ; int result = XRE_mainInit ( & exit ) ; if ( result != 0 || exit ) return result ; result = XRE_mainStartup ( & exit ) ; if ( result != 0 || exit ) return result ; bool appInitiatedRestart = false ; mScopedXPCOM = MakeUnique < ScopedXPCOMStartup > ( ) ; if ( ! mScopedXPCOM ) return 1 ; rv = mScopedXPCOM -> Initialize ( ) ; NS_ENSURE_SUCCESS ( rv , 1 ) ; rv = XRE_mainRun ( ) ; #ifdef MOZ_INSTRUMENT_EVENT_LOOP mozilla :: ShutdownEventTracing ( ) ; #endif if ( rv == NS_SUCCESS_RESTART_APP || rv == NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE ) { appInitiatedRestart = true ; gShutdownChecks = SCM_NOTHING ; } if ( ! mShuttingDown ) { #ifdef MOZ_ENABLE_XREMOTE if ( mRemoteService ) { mRemoteService -> Shutdown ( ) ; } #endif /* MOZ_ENABLE_XREMOTE */ } mScopedXPCOM = nullptr ; mStatisticsRecorder = nullptr ; mProfileLock -> Unlock ( ) ; gProfileLock = nullptr ; #if defined(MOZ_WIDGET_QT) nsQAppInstance :: Release ( ) ; #endif if ( appInitiatedRestart ) { RestoreStateForAppInitiatedRestart ( ) ; if ( rv != NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE ) { SaveFileToEnvIfUnset ( "XRE_PROFILE_PATH" , mProfD ) ; SaveFileToEnvIfUnset ( "XRE_PROFILE_LOCAL_PATH" , mProfLD ) ; SaveWordToEnvIfUnset ( "XRE_PROFILE_NAME" , mProfileName ) ; } #ifdef MOZ_WIDGET_GTK MOZ_gdk_display_close ( mGdkDisplay ) ; #endif { rv = LaunchChild ( mNativeApp , true ) ; } #ifdef MOZ_CRASHREPORTER if ( mAppData -> flags & NS_XRE_ENABLE_CRASH_REPORTER ) CrashReporter :: UnsetExceptionHandler ( ) ; #endif return rv == NS_ERROR_LAUNCHED_CHILD_PROCESS ? 0 : 1 ; } #ifdef MOZ_WIDGET_GTK MOZ_gdk_display_close ( mGdkDisplay ) ; #endif #ifdef MOZ_CRASHREPORTER if ( mAppData -> flags & NS_XRE_ENABLE_CRASH_REPORTER ) CrashReporter :: UnsetExceptionHandler ( ) ; #endif XRE_DeinitCommandLine ( ) ; return NS_FAILED ( rv ) ? 1 : 0 ; }
WasmCode :: ~ WasmCode ( ) { if ( HasTrapHandlerIndex ( ) ) { CHECK_LT ( trap_handler_index ( ) , static_cast < size_t > ( std :: numeric_limits < int > :: max ( ) ) ) ; trap_handler :: ReleaseHandlerData ( static_cast < int > ( trap_handler_index ( ) ) ) ; } }
void CalculateOutputIndexRowSplit ( const RowPartitionTensor & row_split , const vector < INDEX_TYPE > & parent_output_index , INDEX_TYPE output_index_multiplier , INDEX_TYPE output_size , vector < INDEX_TYPE > * result ) { INDEX_TYPE row_split_size = row_split . size ( ) ; if ( row_split_size > 0 ) { result -> reserve ( row_split ( row_split_size - 1 ) ) ; } for ( INDEX_TYPE i = 0 ; i < row_split_size - 1 ; ++ i ) { INDEX_TYPE row_length = row_split ( i + 1 ) - row_split ( i ) ; INDEX_TYPE real_length = std :: min ( output_size , row_length ) ; INDEX_TYPE parent_output_index_current = parent_output_index [ i ] ; if ( parent_output_index_current == - 1 ) { real_length = 0 ; } for ( INDEX_TYPE j = 0 ; j < real_length ; ++ j ) { result -> push_back ( parent_output_index_current ) ; parent_output_index_current += output_index_multiplier ; } for ( INDEX_TYPE j = 0 ; j < row_length - real_length ; ++ j ) { result -> push_back ( - 1 ) ; } } if ( row_split_size > 0 ) { DCHECK_EQ ( result -> size ( ) , row_split ( row_split_size - 1 ) ) ; } }
bool ReadTrueTypeCollection ( Buffer * file , const uint8_t * data , size_t len , FontCollection * font_collection ) { uint32_t num_fonts ; if ( ! file -> ReadU32 ( & font_collection -> header_version ) || ! file -> ReadU32 ( & num_fonts ) ) { return FONT_COMPRESSION_FAILURE ( ) ; } std :: vector < uint32_t > offsets ; for ( auto i = 0 ; i < num_fonts ; i ++ ) { uint32_t offset ; if ( ! file -> ReadU32 ( & offset ) ) { return FONT_COMPRESSION_FAILURE ( ) ; } offsets . push_back ( offset ) ; } font_collection -> fonts . resize ( offsets . size ( ) ) ; std :: vector < Font > :: iterator font_it = font_collection -> fonts . begin ( ) ; std :: map < uint32_t , Font :: Table * > all_tables ; for ( const auto offset : offsets ) { file -> set_offset ( offset ) ; Font & font = * font_it ++ ; if ( ! ReadCollectionFont ( file , data , len , & font , & all_tables ) ) { return FONT_COMPRESSION_FAILURE ( ) ; } } return true ; }
nsAnimationManager :: BuildAnimations ( nsStyleContext * aStyleContext , InfallibleTArray < ElementAnimation > & aAnimations ) { NS_ABORT_IF_FALSE ( aAnimations . IsEmpty ( ) , "expect empty array" ) ; ResolvedStyleCache resolvedStyles ; const nsStyleDisplay * disp = aStyleContext -> StyleDisplay ( ) ; TimeStamp now = mPresContext -> RefreshDriver ( ) -> MostRecentRefresh ( ) ; for ( uint32_t animIdx = 0 , animEnd = disp -> mAnimationNameCount ; animIdx != animEnd ; ++ animIdx ) { const nsAnimation & aSrc = disp -> mAnimations [ animIdx ] ; ElementAnimation & aDest = * aAnimations . AppendElement ( ) ; aDest . mName = aSrc . GetName ( ) ; aDest . mIterationCount = aSrc . GetIterationCount ( ) ; aDest . mDirection = aSrc . GetDirection ( ) ; aDest . mFillMode = aSrc . GetFillMode ( ) ; aDest . mPlayState = aSrc . GetPlayState ( ) ; aDest . mDelay = TimeDuration :: FromMilliseconds ( aSrc . GetDelay ( ) ) ; aDest . mStartTime = now ; if ( aDest . IsPaused ( ) ) { aDest . mPauseStart = now ; } else { aDest . mPauseStart = TimeStamp ( ) ; } aDest . mIterationDuration = TimeDuration :: FromMilliseconds ( aSrc . GetDuration ( ) ) ; nsCSSKeyframesRule * rule = KeyframesRuleFor ( aDest . mName ) ; if ( ! rule ) { continue ; } AutoInfallibleTArray < KeyframeData , 16 > sortedKeyframes ; for ( uint32_t ruleIdx = 0 , ruleEnd = rule -> StyleRuleCount ( ) ; ruleIdx != ruleEnd ; ++ ruleIdx ) { css :: Rule * cssRule = rule -> GetStyleRuleAt ( ruleIdx ) ; NS_ABORT_IF_FALSE ( cssRule , "must have rule" ) ; NS_ABORT_IF_FALSE ( cssRule -> GetType ( ) == css :: Rule :: KEYFRAME_RULE , "must be keyframe rule" ) ; nsCSSKeyframeRule * kfRule = static_cast < nsCSSKeyframeRule * > ( cssRule ) ; const nsTArray < float > & keys = kfRule -> GetKeys ( ) ; for ( uint32_t keyIdx = 0 , keyEnd = keys . Length ( ) ; keyIdx != keyEnd ; ++ keyIdx ) { float key = keys [ keyIdx ] ; if ( 0.0f <= key && key <= 1.0f ) { KeyframeData * data = sortedKeyframes . AppendElement ( ) ; data -> mKey = key ; data -> mIndex = ruleIdx ; data -> mRule = kfRule ; } } } sortedKeyframes . Sort ( KeyframeDataComparator ( ) ) ; if ( sortedKeyframes . Length ( ) == 0 ) { continue ; } nsCSSPropertySet properties ; for ( uint32_t kfIdx = 0 , kfEnd = sortedKeyframes . Length ( ) ; kfIdx != kfEnd ; ++ kfIdx ) { css :: Declaration * decl = sortedKeyframes [ kfIdx ] . mRule -> Declaration ( ) ; for ( uint32_t propIdx = 0 , propEnd = decl -> Count ( ) ; propIdx != propEnd ; ++ propIdx ) { properties . AddProperty ( decl -> OrderValueAt ( propIdx ) ) ; } } for ( nsCSSProperty prop = nsCSSProperty ( 0 ) ; prop < eCSSProperty_COUNT_no_shorthands ; prop = nsCSSProperty ( prop + 1 ) ) { if ( ! properties . HasProperty ( prop ) || nsCSSProps :: kAnimTypeTable [ prop ] == eStyleAnimType_None ) { continue ; } AutoInfallibleTArray < uint32_t , 16 > keyframesWithProperty ; float lastKey = 100.0f ; for ( uint32_t kfIdx = 0 , kfEnd = sortedKeyframes . Length ( ) ; kfIdx != kfEnd ; ++ kfIdx ) { KeyframeData & kf = sortedKeyframes [ kfIdx ] ; if ( ! kf . mRule -> Declaration ( ) -> HasProperty ( prop ) ) { continue ; } if ( kf . mKey == lastKey ) { keyframesWithProperty [ keyframesWithProperty . Length ( ) - 1 ] = kfIdx ; } else { keyframesWithProperty . AppendElement ( kfIdx ) ; } lastKey = kf . mKey ; } AnimationProperty & propData = * aDest . mProperties . AppendElement ( ) ; propData . mProperty = prop ; KeyframeData * fromKeyframe = nullptr ; nsRefPtr < nsStyleContext > fromContext ; bool interpolated = true ; for ( uint32_t wpIdx = 0 , wpEnd = keyframesWithProperty . Length ( ) ; wpIdx != wpEnd ; ++ wpIdx ) { uint32_t kfIdx = keyframesWithProperty [ wpIdx ] ; KeyframeData & toKeyframe = sortedKeyframes [ kfIdx ] ; nsRefPtr < nsStyleContext > toContext = resolvedStyles . Get ( mPresContext , aStyleContext , toKeyframe . mRule ) ; if ( fromKeyframe ) { interpolated = interpolated && BuildSegment ( propData . mSegments , prop , aSrc , fromKeyframe -> mKey , fromContext , fromKeyframe -> mRule -> Declaration ( ) , toKeyframe . mKey , toContext ) ; } else { if ( toKeyframe . mKey != 0.0f ) { interpolated = interpolated && BuildSegment ( propData . mSegments , prop , aSrc , 0.0f , aStyleContext , nullptr , toKeyframe . mKey , toContext ) ; } } fromContext = toContext ; fromKeyframe = & toKeyframe ; } if ( fromKeyframe -> mKey != 1.0f ) { interpolated = interpolated && BuildSegment ( propData . mSegments , prop , aSrc , fromKeyframe -> mKey , fromContext , fromKeyframe -> mRule -> Declaration ( ) , 1.0f , aStyleContext ) ; } if ( ! interpolated ) { aDest . mProperties . RemoveElementAt ( aDest . mProperties . Length ( ) - 1 ) ; } } } }
nsMultiMixedConv :: HeadersToDefault ( ) { mContentLength = UINT64_MAX ; mContentType . Truncate ( ) ; mContentDisposition . Truncate ( ) ; mIsByteRangeRequest = false ; }
TfLiteStatus EvalGatherNd ( TfLiteContext * context , const TfLiteTensor * params , const TfLiteTensor * indices , TfLiteTensor * output ) { switch ( params -> type ) { case kTfLiteFloat32 : return GatherNd < float , IndicesT > ( params , indices , output ) ; case kTfLiteUInt8 : return GatherNd < uint8_t , IndicesT > ( params , indices , output ) ; case kTfLiteInt8 : return GatherNd < int8_t , IndicesT > ( params , indices , output ) ; case kTfLiteInt16 : return GatherNd < int16_t , IndicesT > ( params , indices , output ) ; case kTfLiteInt32 : return GatherNd < int32_t , IndicesT > ( params , indices , output ) ; case kTfLiteInt64 : return GatherNd < int64_t , IndicesT > ( params , indices , output ) ; case kTfLiteString : return GatherNdString < IndicesT > ( params , indices , output ) ; default : context -> ReportError ( context , "Params type '%s' are not supported by gather_nd." , TfLiteTypeGetName ( params -> type ) ) ; return kTfLiteError ; } }
CaptureState SourceListener :: CapturingSource ( MediaSourceEnum aSource ) const { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; if ( ( ! GetVideoDevice ( ) || GetVideoDevice ( ) -> GetMediaSource ( ) != aSource ) && ( ! GetAudioDevice ( ) || GetAudioDevice ( ) -> GetMediaSource ( ) != aSource ) ) { return CaptureState :: Off ; } DeviceState & state = ( GetAudioDevice ( ) && GetAudioDevice ( ) -> GetMediaSource ( ) == aSource ) ? * mAudioDeviceState : * mVideoDeviceState ; MOZ_ASSERT ( state . mDevice -> GetMediaSource ( ) == aSource ) ; if ( state . mStopped ) { return CaptureState :: Off ; } if ( ( aSource == MediaSourceEnum :: Camera || aSource == MediaSourceEnum :: Microphone ) && state . mDevice -> mSource -> IsFake ( ) && ! Preferences :: GetBool ( "media.navigator.permission.fake" ) ) { return CaptureState :: Off ; } if ( state . mDeviceEnabled && ! state . mDeviceMuted ) { return CaptureState :: Enabled ; } return CaptureState :: Disabled ; }
int jpc_tsfb_synthesize ( jpc_tsfb_t * tsfb , jas_seq2d_t * a ) { return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb , jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ; }
int ogg_stream_flush ( ogg_stream_state * os , ogg_page * og ) { int i ; int vals = 0 ; int maxvals = ( os -> lacing_fill > 255 ? 255 : os -> lacing_fill ) ; int bytes = 0 ; long acc = 0 ; ogg_int64_t granule_pos = - 1 ; if ( ogg_stream_check ( os ) ) return 0 ; if ( maxvals == 0 ) return 0 ; if ( os -> b_o_s == 0 ) { granule_pos = 0 ; for ( vals = 0 ; vals < maxvals ; vals ++ ) { if ( ( os -> lacing_vals [ vals ] & 0x0ff ) < 255 ) { vals ++ ; break ; } } } else { for ( vals = 0 ; vals < maxvals ; vals ++ ) { if ( acc > 4096 ) break ; acc += os -> lacing_vals [ vals ] & 0x0ff ; if ( ( os -> lacing_vals [ vals ] & 0xff ) < 255 ) granule_pos = os -> granule_vals [ vals ] ; } } memcpy ( os -> header , "OggS" , 4 ) ; os -> header [ 4 ] = 0x00 ; os -> header [ 5 ] = 0x00 ; if ( ( os -> lacing_vals [ 0 ] & 0x100 ) == 0 ) os -> header [ 5 ] |= 0x01 ; if ( os -> b_o_s == 0 ) os -> header [ 5 ] |= 0x02 ; if ( os -> e_o_s && os -> lacing_fill == vals ) os -> header [ 5 ] |= 0x04 ; os -> b_o_s = 1 ; for ( i = 6 ; i < 14 ; i ++ ) { os -> header [ i ] = ( unsigned char ) ( granule_pos & 0xff ) ; granule_pos >>= 8 ; } { long serialno = os -> serialno ; for ( i = 14 ; i < 18 ; i ++ ) { os -> header [ i ] = ( unsigned char ) ( serialno & 0xff ) ; serialno >>= 8 ; } } if ( os -> pageno == - 1 ) os -> pageno = 0 ; { long pageno = os -> pageno ++ ; for ( i = 18 ; i < 22 ; i ++ ) { os -> header [ i ] = ( unsigned char ) ( pageno & 0xff ) ; pageno >>= 8 ; } } os -> header [ 22 ] = 0 ; os -> header [ 23 ] = 0 ; os -> header [ 24 ] = 0 ; os -> header [ 25 ] = 0 ; os -> header [ 26 ] = ( unsigned char ) ( vals & 0xff ) ; for ( i = 0 ; i < vals ; i ++ ) bytes += os -> header [ i + 27 ] = ( unsigned char ) ( os -> lacing_vals [ i ] & 0xff ) ; og -> header = os -> header ; og -> header_len = os -> header_fill = vals + 27 ; og -> body = os -> body_data + os -> body_returned ; og -> body_len = bytes ; os -> lacing_fill -= vals ; memmove ( os -> lacing_vals , os -> lacing_vals + vals , os -> lacing_fill * sizeof ( * os -> lacing_vals ) ) ; memmove ( os -> granule_vals , os -> granule_vals + vals , os -> lacing_fill * sizeof ( * os -> granule_vals ) ) ; os -> body_returned += bytes ; ogg_page_checksum_set ( og ) ; return ( 1 ) ; }
static void local_socket_close_locked ( asocket * s ) { D ( "entered local_socket_close_locked. LS(%d) fd=%d" , s -> id , s -> fd ) ; if ( s -> peer ) { D ( "LS(%d): closing peer. peer->id=%d peer->fd=%d" , s -> id , s -> peer -> id , s -> peer -> fd ) ; if ( s -> peer -> shutdown ) { s -> peer -> shutdown ( s -> peer ) ; } s -> peer -> peer = 0 ; if ( s -> peer -> close == local_socket_close ) { local_socket_close_locked ( s -> peer ) ; } else { s -> peer -> close ( s -> peer ) ; } s -> peer = 0 ; } if ( s -> closing || s -> has_write_error || s -> pkt_first == NULL ) { int id = s -> id ; local_socket_destroy ( s ) ; D ( "LS(%d): closed" , id ) ; return ; } D ( "LS(%d): closing" , s -> id ) ; s -> closing = 1 ; fdevent_del ( & s -> fde , FDE_READ ) ; remove_socket ( s ) ; D ( "LS(%d): put on socket_closing_list fd=%d" , s -> id , s -> fd ) ; insert_local_socket ( s , & local_socket_closing_list ) ; CHECK_EQ ( FDE_WRITE , s -> fde . state & FDE_WRITE ) ; }
static OPJ_BOOL opj_j2k_write_mct_data_group ( opj_j2k_t * p_j2k , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { OPJ_UINT32 i ; opj_simple_mcc_decorrelation_data_t * l_mcc_record ; opj_mct_data_t * l_mct_record ; opj_tcp_t * l_tcp ; assert ( p_j2k != 00 ) ; assert ( p_stream != 00 ) ; assert ( p_manager != 00 ) ; if ( ! opj_j2k_write_cbd ( p_j2k , p_stream , p_manager ) ) { return OPJ_FALSE ; } l_tcp = & ( p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] ) ; l_mct_record = l_tcp -> m_mct_records ; for ( i = 0 ; i < l_tcp -> m_nb_mct_records ; ++ i ) { if ( ! opj_j2k_write_mct_record ( p_j2k , l_mct_record , p_stream , p_manager ) ) { return OPJ_FALSE ; } ++ l_mct_record ; } l_mcc_record = l_tcp -> m_mcc_records ; for ( i = 0 ; i < l_tcp -> m_nb_mcc_records ; ++ i ) { if ( ! opj_j2k_write_mcc_record ( p_j2k , l_mcc_record , p_stream , p_manager ) ) { return OPJ_FALSE ; } ++ l_mcc_record ; } if ( ! opj_j2k_write_mco ( p_j2k , p_stream , p_manager ) ) { return OPJ_FALSE ; } return OPJ_TRUE ; }
static int mxf_read_primer_pack ( void * arg , AVIOContext * pb , int tag , int size , UID uid , int64_t klv_offset ) { MXFContext * mxf = arg ; int item_num = avio_rb32 ( pb ) ; int item_len = avio_rb32 ( pb ) ; if ( item_len != 18 ) { avpriv_request_sample ( pb , "Primer pack item length %d" , item_len ) ; return AVERROR_PATCHWELCOME ; } if ( item_num > 65536 ) { av_log ( mxf -> fc , AV_LOG_ERROR , "item_num %d is too large\n" , item_num ) ; return AVERROR_INVALIDDATA ; } mxf -> local_tags = av_calloc ( item_num , item_len ) ; if ( ! mxf -> local_tags ) return AVERROR ( ENOMEM ) ; mxf -> local_tags_count = item_num ; avio_read ( pb , mxf -> local_tags , item_num * item_len ) ; return 0 ; }
const AstRawString * AstValueFactory :: GetString ( Handle < String > literal ) { AstRawString * result = nullptr ; DisallowHeapAllocation no_gc ; String :: FlatContent content = literal -> GetFlatContent ( ) ; if ( content . IsOneByte ( ) ) { result = GetOneByteStringInternal ( content . ToOneByteVector ( ) ) ; } else { DCHECK ( content . IsTwoByte ( ) ) ; result = GetTwoByteStringInternal ( content . ToUC16Vector ( ) ) ; } return result ; }
static void oggpack_writecopy_helper ( oggpack_buffer * b , void * source , long bits , void ( * w ) ( oggpack_buffer * , unsigned long , int ) , int msb ) { unsigned char * ptr = ( unsigned char * ) source ; long bytes = bits / 8 ; bits -= bytes * 8 ; if ( b -> endbit ) { int i ; for ( i = 0 ; i < bytes ; i ++ ) w ( b , ( unsigned long ) ( ptr [ i ] ) , 8 ) ; } else { if ( b -> endbyte + bytes + 1 >= b -> storage ) { void * ret ; if ( ! b -> ptr ) return ; b -> storage = b -> endbyte + bytes + BUFFER_INCREMENT ; ret = _ogg_realloc ( b -> buffer , b -> storage ) ; if ( ! ret ) { oggpack_writeclear ( b ) ; return ; } b -> buffer = ret ; b -> ptr = b -> buffer + b -> endbyte ; } memmove ( b -> ptr , source , bytes ) ; b -> ptr += bytes ; b -> endbyte += bytes ; * b -> ptr = 0 ; } if ( bits ) { if ( msb ) w ( b , ( unsigned long ) ( ptr [ bytes ] > > ( 8 - bits ) ) , bits ) ; else w ( b , ( unsigned long ) ( ptr [ bytes ] ) , bits ) ; } }
void EmitBinOp ( EmitFn fn ) { static constexpr RegClass src_rc = reg_class_for ( src_type ) ; static constexpr RegClass result_rc = reg_class_for ( result_type ) ; LiftoffRegister rhs = __ PopToRegister ( ) ; LiftoffRegister lhs = __ PopToRegister ( LiftoffRegList :: ForRegs ( rhs ) ) ; LiftoffRegister dst = src_rc == result_rc ? __ GetUnusedRegister ( result_rc , { lhs , rhs } ) : __ GetUnusedRegister ( result_rc ) ; fn ( dst , lhs , rhs ) ; __ PushRegister ( result_type , dst ) ; }
NS_IMETHODIMP nsPlaintextEditor :: Paste ( int32_t aSelectionType ) { if ( ! FireClipboardEvent ( NS_PASTE ) ) return NS_OK ; nsresult rv ; nsCOMPtr < nsIClipboard > clipboard ( do_GetService ( "@mozilla.org/widget/clipboard;1" , & rv ) ) ; if ( NS_FAILED ( rv ) ) return rv ; nsCOMPtr < nsITransferable > trans ; rv = PrepareTransferable ( getter_AddRefs ( trans ) ) ; if ( NS_SUCCEEDED ( rv ) && trans ) { if ( NS_SUCCEEDED ( clipboard -> GetData ( trans , aSelectionType ) ) && IsModifiable ( ) ) { nsCOMPtr < nsIDOMDocument > domdoc = GetDOMDocument ( ) ; if ( ! nsEditorHookUtils :: DoInsertionHook ( domdoc , nullptr , trans ) ) return NS_OK ; rv = InsertTextFromTransferable ( trans , nullptr , 0 , true ) ; } } return rv ; }
static int rndis_set_response ( struct rndis_params * params , rndis_set_msg_type * buf ) { u32 BufLength , BufOffset ; rndis_set_cmplt_type * resp ; rndis_resp_t * r ; BufLength = le32_to_cpu ( buf -> InformationBufferLength ) ; BufOffset = le32_to_cpu ( buf -> InformationBufferOffset ) ; if ( ( BufLength > RNDIS_MAX_TOTAL_SIZE ) || ( BufOffset + 8 >= RNDIS_MAX_TOTAL_SIZE ) ) return - EINVAL ; r = rndis_add_response ( params , sizeof ( rndis_set_cmplt_type ) ) ; if ( ! r ) return - ENOMEM ; resp = ( rndis_set_cmplt_type * ) r -> buf ; #ifdef VERBOSE_DEBUG pr_debug ( "%s: Length: %d\n" , __func__ , BufLength ) ; pr_debug ( "%s: Offset: %d\n" , __func__ , BufOffset ) ; pr_debug ( "%s: InfoBuffer: " , __func__ ) ; for ( i = 0 ; i < BufLength ; i ++ ) { pr_debug ( "%02x " , * ( ( ( u8 * ) buf ) + i + 8 + BufOffset ) ) ; } pr_debug ( "\n" ) ; #endif resp -> MessageType = cpu_to_le32 ( RNDIS_MSG_SET_C ) ; resp -> MessageLength = cpu_to_le32 ( 16 ) ; resp -> RequestID = buf -> RequestID ; if ( gen_ndis_set_resp ( params , le32_to_cpu ( buf -> OID ) , ( ( u8 * ) buf ) + 8 + BufOffset , BufLength , r ) ) resp -> Status = cpu_to_le32 ( RNDIS_STATUS_NOT_SUPPORTED ) ; else resp -> Status = cpu_to_le32 ( RNDIS_STATUS_SUCCESS ) ; params -> resp_avail ( params -> v ) ; return 0 ; }
InterfaceToJsval ( nsPIDOMWindow * aWindow , nsISupports * aObject , const nsIID * aIID ) { AutoJSContext cx ; nsCOMPtr < nsIScriptGlobalObject > sgo = do_QueryInterface ( aWindow ) ; if ( ! sgo ) { return JSVAL_NULL ; } JS :: Rooted < JSObject * > scopeObj ( cx , sgo -> GetGlobalJSObject ( ) ) ; NS_ENSURE_TRUE ( scopeObj , JSVAL_NULL ) ; JSAutoCompartment ac ( cx , scopeObj ) ; JS :: Rooted < JS :: Value > someJsVal ( cx ) ; nsresult rv = nsContentUtils :: WrapNative ( cx , aObject , aIID , & someJsVal ) ; if ( NS_FAILED ( rv ) ) { return JSVAL_NULL ; } return someJsVal ; }
cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) { cdf_summary_info_header_t si ; cdf_property_info_t * info ; size_t count ; int m ; if ( cdf_unpack_summary_info ( sst , h , & si , & info , & count ) == - 1 ) return - 1 ; if ( NOTMIME ( ms ) ) { const char * str ; if ( file_printf ( ms , "Composite Document File V2 Document" ) == - 1 ) return - 1 ; if ( file_printf ( ms , ", %s Endian" , si . si_byte_order == 0xfffe ? "Little" : "Big" ) == - 1 ) return - 2 ; switch ( si . si_os ) { case 2 : if ( file_printf ( ms , ", Os: Windows, Version %d.%d" , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version > > 8 ) == - 1 ) return - 2 ; break ; case 1 : if ( file_printf ( ms , ", Os: MacOS, Version %d.%d" , ( uint32_t ) si . si_os_version > > 8 , si . si_os_version & 0xff ) == - 1 ) return - 2 ; break ; default : if ( file_printf ( ms , ", Os %d, Version: %d.%d" , si . si_os , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version > > 8 ) == - 1 ) return - 2 ; break ; } str = cdf_clsid_to_mime ( clsid , clsid2desc ) ; if ( str ) if ( file_printf ( ms , ", %s" , str ) == - 1 ) return - 2 ; } m = cdf_file_property_info ( ms , info , count , clsid ) ; free ( info ) ; return m == - 1 ? - 2 : m ; }
void MediaDecoder :: NotifySuspendedStatusChanged ( ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; if ( ! mResource ) return ; bool suspended = mResource -> IsSuspendedByCache ( ) ; if ( mOwner ) { mOwner -> NotifySuspendedByCache ( suspended ) ; UpdateReadyStateForData ( ) ; } }
int AsmJsParser :: FindBreakLabelDepth ( AsmJsScanner :: token_t label ) { int count = 0 ; for ( auto it = block_stack_ . rbegin ( ) ; it != block_stack_ . rend ( ) ; ++ it , ++ count ) { if ( it -> kind == BlockKind :: kRegular && ( label == kTokenNone || it -> label == label ) ) { return count ; } } return - 1 ; }
void Compute ( OpKernelContext * context ) override { typedef Eigen :: Map < const Eigen :: Matrix < T , Eigen :: Dynamic , Eigen :: Dynamic > > ConstEigenMatrixMap ; typedef Eigen :: Map < Eigen :: Matrix < T , Eigen :: Dynamic , Eigen :: Dynamic > > EigenMatrixMap ; constexpr int tensor_in_and_out_dims = 4 ; const Tensor & tensor_in = context -> input ( 0 ) ; OP_REQUIRES ( context , tensor_in . dims ( ) == tensor_in_and_out_dims , errors :: InvalidArgument ( "tensor_in must be 4-dimensional" ) ) ; std :: vector < int > input_size ( tensor_in_and_out_dims ) ; std :: vector < int > output_size ( tensor_in_and_out_dims ) ; for ( int i = 0 ; i < tensor_in_and_out_dims ; ++ i ) { input_size [ i ] = tensor_in . dim_size ( i ) ; } for ( int i = 0 ; i < tensor_in_and_out_dims ; ++ i ) { output_size [ i ] = static_cast < int > ( std :: floor ( input_size [ i ] / pooling_ratio_ [ i ] ) ) ; DCHECK_GT ( output_size [ i ] , 0 ) ; } std :: vector < int64 > row_cum_seq ; std :: vector < int64 > col_cum_seq ; GuardedPhiloxRandom generator ; generator . Init ( seed_ , seed2_ ) ; row_cum_seq = GeneratePoolingSequence ( input_size [ 1 ] , output_size [ 1 ] , & generator , pseudo_random_ ) ; col_cum_seq = GeneratePoolingSequence ( input_size [ 2 ] , output_size [ 2 ] , & generator , pseudo_random_ ) ; Tensor * output_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { output_size [ 0 ] , output_size [ 1 ] , output_size [ 2 ] , output_size [ 3 ] } ) , & output_tensor ) ) ; Tensor * output_row_seq_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 1 , TensorShape ( { static_cast < int64 > ( row_cum_seq . size ( ) ) } ) , & output_row_seq_tensor ) ) ; Tensor * output_col_seq_tensor = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 2 , TensorShape ( { static_cast < int64 > ( col_cum_seq . size ( ) ) } ) , & output_col_seq_tensor ) ) ; ConstEigenMatrixMap in_mat ( tensor_in . flat < T > ( ) . data ( ) , input_size [ 3 ] , input_size [ 2 ] * input_size [ 1 ] * input_size [ 0 ] ) ; EigenMatrixMap out_mat ( output_tensor -> flat < T > ( ) . data ( ) , output_size [ 3 ] , output_size [ 2 ] * output_size [ 1 ] * output_size [ 0 ] ) ; Eigen :: Matrix < T , Eigen :: Dynamic , 1 > out_count ( out_mat . cols ( ) ) ; out_mat . setZero ( ) ; out_count . setZero ( ) ; auto output_row_seq_flat = output_row_seq_tensor -> flat < int64 > ( ) ; auto output_col_seq_flat = output_col_seq_tensor -> flat < int64 > ( ) ; for ( int i = 0 ; i < row_cum_seq . size ( ) ; ++ i ) { output_row_seq_flat ( i ) = row_cum_seq [ i ] ; } for ( int i = 0 ; i < col_cum_seq . size ( ) ; ++ i ) { output_col_seq_flat ( i ) = col_cum_seq [ i ] ; } const int64 row_max = input_size [ 1 ] - 1 ; const int64 col_max = input_size [ 2 ] - 1 ; for ( int64 b = 0 ; b < input_size [ 0 ] ; ++ b ) { for ( int64 hs = 0 ; hs < row_cum_seq . size ( ) - 1 ; ++ hs ) { const int64 row_start = row_cum_seq [ hs ] ; int64 row_end = overlapping_ ? row_cum_seq [ hs + 1 ] : row_cum_seq [ hs + 1 ] - 1 ; row_end = std :: min ( row_end , row_max ) ; for ( int64 ws = 0 ; ws < col_cum_seq . size ( ) - 1 ; ++ ws ) { const int64 out_offset = ( b * output_size [ 1 ] + hs ) * output_size [ 2 ] + ws ; const int64 col_start = col_cum_seq [ ws ] ; int64 col_end = overlapping_ ? col_cum_seq [ ws + 1 ] : col_cum_seq [ ws + 1 ] - 1 ; col_end = std :: min ( col_end , col_max ) ; for ( int64 h = row_start ; h <= row_end ; ++ h ) { for ( int64 w = col_start ; w <= col_end ; ++ w ) { const int64 in_offset = ( b * input_size [ 1 ] + h ) * input_size [ 2 ] + w ; out_mat . col ( out_offset ) += in_mat . col ( in_offset ) ; out_count ( out_offset ) ++ ; } } } } } DCHECK_GT ( out_count . minCoeff ( ) , 0 ) ; out_mat . array ( ) . rowwise ( ) /= out_count . transpose ( ) . array ( ) ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; const TfLiteTensor * fft_length = GetInput ( context , node , kFftLengthTensor ) ; const int32_t * fft_length_data = GetTensorData < int32_t > ( fft_length ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; if ( output -> type != kTfLiteComplex64 ) { context -> ReportError ( context , "Type '%s' for output is not supported by rfft2d." , TfLiteTypeGetName ( output -> type ) ) ; return kTfLiteError ; } if ( ! IsConstantTensor ( fft_length ) ) { TF_LITE_ENSURE_STATUS ( ResizeOutputandTemporaryTensors ( context , node ) ) ; } else { int num_dims_output = NumDimensions ( output ) ; const RuntimeShape output_shape = GetTensorShape ( output ) ; TF_LITE_ENSURE_EQ ( context , num_dims_output , NumDimensions ( input ) ) ; TF_LITE_ENSURE ( context , num_dims_output >= 2 ) ; TF_LITE_ENSURE_EQ ( context , output_shape . Dims ( num_dims_output - 2 ) , fft_length_data [ 0 ] ) ; TF_LITE_ENSURE_EQ ( context , output_shape . Dims ( num_dims_output - 1 ) , fft_length_data [ 1 ] / 2 + 1 ) ; } return Rfft2dHelper ( context , node ) ; }
rdpsnddbg_process ( STREAM s ) { unsigned int pkglen ; static char * rest = NULL ; char * buf ; pkglen = s -> end - s -> p ; buf = ( char * ) xmalloc ( pkglen + 1 ) ; STRNCPY ( buf , ( char * ) s -> p , pkglen + 1 ) ; str_handle_lines ( buf , & rest , rdpsnddbg_line_handler , NULL ) ; xfree ( buf ) ; }
MaybeHandle < WasmModuleObject > DeserializeNativeModule ( Isolate * isolate , Vector < const byte > data , Vector < const byte > wire_bytes ) { if ( ! IsWasmCodegenAllowed ( isolate , isolate -> native_context ( ) ) ) { return { } ; } if ( ! IsSupportedVersion ( isolate , data ) ) { return { } ; } WasmFeatures enabled_features = WasmFeaturesFromIsolate ( isolate ) ; ModuleResult decode_result = DecodeWasmModule ( enabled_features , wire_bytes . start ( ) , wire_bytes . end ( ) , false , i :: wasm :: kWasmOrigin , isolate -> counters ( ) , isolate -> allocator ( ) ) ; if ( ! decode_result . ok ( ) ) return { } ; CHECK_NOT_NULL ( decode_result . val ) ; WasmModule * module = decode_result . val . get ( ) ; Handle < Script > script = CreateWasmScript ( isolate , wire_bytes ) ; UseTrapHandler use_trap_handler = trap_handler :: IsTrapHandlerEnabled ( ) ? kUseTrapHandler : kNoTrapHandler ; ModuleEnv env ( module , use_trap_handler , RuntimeExceptionSupport :: kRuntimeExceptionSupport ) ; OwnedVector < uint8_t > wire_bytes_copy = OwnedVector < uint8_t > :: Of ( wire_bytes ) ; Handle < WasmModuleObject > module_object = WasmModuleObject :: New ( isolate , enabled_features , std :: move ( decode_result . val ) , env , std :: move ( wire_bytes_copy ) , script , Handle < ByteArray > :: null ( ) ) ; NativeModule * native_module = module_object -> native_module ( ) ; if ( FLAG_wasm_lazy_compilation ) { native_module -> SetLazyBuiltin ( BUILTIN_CODE ( isolate , WasmCompileLazy ) ) ; } NativeModuleDeserializer deserializer ( isolate , native_module ) ; Reader reader ( data + kVersionSize ) ; if ( ! deserializer . Read ( & reader ) ) return { } ; CodeSpaceMemoryModificationScope modification_scope ( isolate -> heap ( ) ) ; CompileJsToWasmWrappers ( isolate , module_object ) ; native_module -> LogWasmCodes ( isolate ) ; return module_object ; }
chpass_principal3_2_svc ( chpass3_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; gss_buffer_desc client_name , service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = chpass_principal_wrapper_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , arg -> pass ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_chpass_principal_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , arg -> pass ) ; } else { log_unauth ( "kadm5_chpass_principal" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( "kadm5_chpass_principal" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
void UpdateTypedPointers ( ) { if ( chunk_ -> typed_slot_set < OLD_TO_NEW , AccessMode :: NON_ATOMIC > ( ) != nullptr ) { CHECK_NE ( chunk_ -> owner ( ) , heap_ -> map_space ( ) ) ; const auto check_and_update_old_to_new_slot_fn = [ this ] ( MaybeObject * * slot ) { return CheckAndUpdateOldToNewSlot ( reinterpret_cast < Address > ( slot ) ) ; } ; RememberedSet < OLD_TO_NEW > :: IterateTyped ( chunk_ , [ = ] ( SlotType slot_type , Address host_addr , Address slot ) { return UpdateTypedSlotHelper :: UpdateTypedSlot ( heap_ , slot_type , slot , check_and_update_old_to_new_slot_fn ) ; } ) ; } if ( ( updating_mode_ == RememberedSetUpdatingMode :: ALL ) && ( chunk_ -> typed_slot_set < OLD_TO_OLD , AccessMode :: NON_ATOMIC > ( ) != nullptr ) ) { CHECK_NE ( chunk_ -> owner ( ) , heap_ -> map_space ( ) ) ; RememberedSet < OLD_TO_OLD > :: IterateTyped ( chunk_ , [ this ] ( SlotType slot_type , Address host_addr , Address slot ) { return UpdateTypedSlotHelper :: UpdateTypedSlot ( heap_ , slot_type , slot , UpdateStrongSlot < AccessMode :: NON_ATOMIC > ) ; } ) ; } }
void nsHistory :: Go ( int32_t aDelta , ErrorResult & aRv ) { nsCOMPtr < nsPIDOMWindowInner > win ( do_QueryReferent ( mInnerWindow ) ) ; if ( ! win || ! win -> HasActiveDocument ( ) ) { return aRv . Throw ( NS_ERROR_DOM_SECURITY_ERR ) ; } if ( ! aDelta ) { RefPtr < Location > location = win -> Location ( ) ; return location -> Reload ( false , aRv ) ; } RefPtr < ChildSHistory > session_history = GetSessionHistory ( ) ; if ( ! session_history ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return ; } if ( StaticPrefs :: dom_window_history_async ( ) ) { session_history -> AsyncGo ( aDelta , false ) ; } else { session_history -> Go ( aDelta , false , IgnoreErrors ( ) ) ; } }
void trustedGetPublicEcdsaKeyAES ( int * errStatus , char * errString , uint8_t * encryptedPrivateKey , uint32_t enc_len , char * pub_key_x , char * pub_key_y ) { LOG_DEBUG ( __FUNCTION__ ) ; INIT_ERROR_STATE SAFE_CHAR_BUF ( skey , ECDSA_SKEY_LEN ) ; mpz_t privateKeyMpz ; mpz_init ( privateKeyMpz ) ; point pKey = point_init ( ) ; point pKey_test = point_init ( ) ; CHECK_STATE ( encryptedPrivateKey ) ; CHECK_STATE ( pub_key_x ) ; CHECK_STATE ( pub_key_y ) ; int status = AES_decrypt ( encryptedPrivateKey , enc_len , skey , ECDSA_SKEY_LEN ) ; CHECK_STATUS2 ( "AES_decrypt failed with status %d" ) ; skey [ enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE ] = '\0' ; strncpy ( errString , skey , 1024 ) ; status = mpz_set_str ( privateKeyMpz , skey , ECDSA_SKEY_BASE ) ; CHECK_STATUS ( "mpz_set_str failed for private key" ) ; signature_extract_public_key ( pKey , privateKeyMpz , curve ) ; point_multiplication ( pKey_test , privateKeyMpz , curve -> G , curve ) ; if ( ! point_cmp ( pKey , pKey_test ) ) { snprintf ( errString , BUF_LEN , "Points are not equal" ) ; LOG_ERROR ( errString ) ; * errStatus = - 11 ; goto clean ; } SAFE_CHAR_BUF ( arr_x , BUF_LEN ) ; mpz_get_str ( arr_x , ECDSA_SKEY_BASE , pKey -> x ) ; int n_zeroes = 64 - strlen ( arr_x ) ; for ( int i = 0 ; i < n_zeroes ; i ++ ) { pub_key_x [ i ] = '0' ; } strncpy ( pub_key_x + n_zeroes , arr_x , 1024 - n_zeroes ) ; SAFE_CHAR_BUF ( arr_y , BUF_LEN ) ; mpz_get_str ( arr_y , ECDSA_SKEY_BASE , pKey -> y ) ; n_zeroes = 64 - strlen ( arr_y ) ; for ( int i = 0 ; i < n_zeroes ; i ++ ) { pub_key_y [ i ] = '0' ; } strncpy ( pub_key_y + n_zeroes , arr_y , 1024 - n_zeroes ) ; SET_SUCCESS clean : mpz_clear ( privateKeyMpz ) ; point_clear ( pKey ) ; point_clear ( pKey_test ) ; static uint64_t counter = 0 ; if ( counter % 1000 == 0 ) { LOG_INFO ( __FUNCTION__ ) ; LOG_INFO ( "Thousand SGX calls completed" ) ; } counter ++ ; }
static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == BT_CONNECT2 && test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) ) { hci_conn_accept ( pi -> conn -> hcon , 0 ) ; sk -> sk_state = BT_CONFIG ; release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }
BytecodeArrayBuilder & BytecodeArrayBuilder :: Bind ( BytecodeLabel * label ) { if ( register_optimizer_ ) register_optimizer_ -> Flush ( ) ; bytecode_array_writer_ . BindLabel ( label ) ; LeaveBasicBlock ( ) ; return * this ; }
nsDOMClipboardEvent :: GetClipboardData ( ) { nsClipboardEvent * event = static_cast < nsClipboardEvent * > ( mEvent ) ; if ( ! event -> clipboardData ) { if ( mEventIsInternal ) { event -> clipboardData = new nsDOMDataTransfer ( NS_COPY , false ) ; } else { event -> clipboardData = new nsDOMDataTransfer ( event -> message , event -> message == NS_PASTE ) ; } } return event -> clipboardData ; }
static void do_pclose ( FILE * fin , FILE * fout ) { char buf [ BUFFER_SIZE ] ; int64_t fptr = 0 ; read_buf ( fin , buf ) ; sscanf ( buf , "%" PRId64 , & fptr ) ; FILE * f = ( FILE * ) fptr ; int ret = :: pclose ( f ) ; fprintf ( fout , "%d\n" , ret ) ; if ( ret < 0 ) { fprintf ( fout , "%d\n" , errno ) ; } fflush ( fout ) ; }
R_API char * r_cons_hud_string ( const char * s ) { if ( ! r_cons_is_interactive ( ) ) { R_LOG_ERROR ( "Hud mode requires scr.interactive=true" ) ; return NULL ; } char * os , * track , * ret , * o = strdup ( s ) ; if ( ! o ) { return NULL ; } r_str_replace_ch ( o , '\r' , 0 , true ) ; r_str_replace_ch ( o , '\t' , 0 , true ) ; RList * fl = r_list_new ( ) ; int i ; if ( ! fl ) { free ( o ) ; return NULL ; } fl -> free = free ; for ( os = o , i = 0 ; o [ i ] ; i ++ ) { if ( o [ i ] == '\n' ) { o [ i ] = 0 ; if ( * os && * os != '#' ) { track = strdup ( os ) ; if ( ! r_list_append ( fl , track ) ) { free ( track ) ; break ; } } os = o + i + 1 ; } } ret = r_cons_hud ( fl , NULL ) ; free ( o ) ; r_list_free ( fl ) ; return ret ; }
static int get_refresh_mask ( VP9_COMP * cpi ) { #if CONFIG_MULTIPLE_ARF if ( ! cpi -> multi_arf_enabled && cpi -> refresh_golden_frame && ! cpi -> refresh_alt_ref_frame ) { #else if ( cpi -> refresh_golden_frame && ! cpi -> refresh_alt_ref_frame && ! cpi -> use_svc ) { #endif return ( cpi -> refresh_last_frame < < cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame < < cpi -> alt_fb_idx ) ; } else { int arf_idx = cpi -> alt_fb_idx ; #if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) { int sn = cpi -> sequence_number ; arf_idx = ( cpi -> frame_coding_order [ sn ] < 0 ) ? cpi -> arf_buffer_idx [ sn + 1 ] : cpi -> arf_buffer_idx [ sn ] ; } #endif return ( cpi -> refresh_last_frame < < cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame < < cpi -> gld_fb_idx ) | ( cpi -> refresh_alt_ref_frame < < arf_idx ) ; } }
void Sampler :: Stop ( ) { #if defined(USE_SIGNALS) SamplerManager :: instance ( ) -> RemoveSampler ( this ) ; #endif DCHECK ( IsActive ( ) ) ; SetActive ( false ) ; SetRegistered ( false ) ; }
void TraceCacheState ( FullDecoder * decoder ) const { #ifdef DEBUG if ( ! FLAG_trace_liftoff || ! FLAG_trace_wasm_decoder ) return ; StdoutStream os ; for ( int control_depth = decoder -> control_depth ( ) - 1 ; control_depth >= - 1 ; -- control_depth ) { auto * cache_state = control_depth == - 1 ? __ cache_state ( ) : & decoder -> control_at ( control_depth ) -> label_state ; os < < PrintCollection ( cache_state -> stack_state ) ; if ( control_depth != - 1 ) PrintF ( "; " ) ; } os < < "\n" ; #endif }
xmlParseComment ( xmlParserCtxtPtr ctxt ) { xmlChar * buf = NULL ; size_t size = XML_PARSER_BUFFER_SIZE ; size_t len = 0 ; xmlParserInputState state ; const xmlChar * in ; size_t nbchar = 0 ; int ccol ; int inputid ; if ( ( RAW != '<' ) || ( NXT ( 1 ) != '!' ) || ( NXT ( 2 ) != '-' ) || ( NXT ( 3 ) != '-' ) ) return ; state = ctxt -> instate ; ctxt -> instate = XML_PARSER_COMMENT ; inputid = ctxt -> input -> id ; SKIP ( 4 ) ; SHRINK ; GROW ; in = ctxt -> input -> cur ; do { if ( * in == 0xA ) { do { ctxt -> input -> line ++ ; ctxt -> input -> col = 1 ; in ++ ; } while ( * in == 0xA ) ; } get_more : ccol = ctxt -> input -> col ; while ( ( ( * in > '-' ) && ( * in <= 0x7F ) ) || ( ( * in >= 0x20 ) && ( * in < '-' ) ) || ( * in == 0x09 ) ) { in ++ ; ccol ++ ; } ctxt -> input -> col = ccol ; if ( * in == 0xA ) { do { ctxt -> input -> line ++ ; ctxt -> input -> col = 1 ; in ++ ; } while ( * in == 0xA ) ; goto get_more ; } nbchar = in - ctxt -> input -> cur ; if ( nbchar > 0 ) { if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> comment != NULL ) ) { if ( buf == NULL ) { if ( ( * in == '-' ) && ( in [ 1 ] == '-' ) ) size = nbchar + 1 ; else size = XML_PARSER_BUFFER_SIZE + nbchar ; buf = ( xmlChar * ) xmlMallocAtomic ( size * sizeof ( xmlChar ) ) ; if ( buf == NULL ) { xmlErrMemory ( ctxt , NULL ) ; ctxt -> instate = state ; return ; } len = 0 ; } else if ( len + nbchar + 1 >= size ) { xmlChar * new_buf ; size += len + nbchar + XML_PARSER_BUFFER_SIZE ; new_buf = ( xmlChar * ) xmlRealloc ( buf , size * sizeof ( xmlChar ) ) ; if ( new_buf == NULL ) { xmlFree ( buf ) ; xmlErrMemory ( ctxt , NULL ) ; ctxt -> instate = state ; return ; } buf = new_buf ; } memcpy ( & buf [ len ] , ctxt -> input -> cur , nbchar ) ; len += nbchar ; buf [ len ] = 0 ; } } if ( ( len > XML_MAX_TEXT_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_COMMENT_NOT_FINISHED , "Comment too big found" , NULL ) ; xmlFree ( buf ) ; return ; } ctxt -> input -> cur = in ; if ( * in == 0xA ) { in ++ ; ctxt -> input -> line ++ ; ctxt -> input -> col = 1 ; } if ( * in == 0xD ) { in ++ ; if ( * in == 0xA ) { ctxt -> input -> cur = in ; in ++ ; ctxt -> input -> line ++ ; ctxt -> input -> col = 1 ; continue ; } in -- ; } SHRINK ; GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) { xmlFree ( buf ) ; return ; } in = ctxt -> input -> cur ; if ( * in == '-' ) { if ( in [ 1 ] == '-' ) { if ( in [ 2 ] == '>' ) { if ( ctxt -> input -> id != inputid ) { xmlFatalErrMsg ( ctxt , XML_ERR_ENTITY_BOUNDARY , "comment doesn't start and stop in the same entity\n" ) ; } SKIP ( 3 ) ; if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> comment != NULL ) && ( ! ctxt -> disableSAX ) ) { if ( buf != NULL ) ctxt -> sax -> comment ( ctxt -> userData , buf ) ; else ctxt -> sax -> comment ( ctxt -> userData , BAD_CAST "" ) ; } if ( buf != NULL ) xmlFree ( buf ) ; if ( ctxt -> instate != XML_PARSER_EOF ) ctxt -> instate = state ; return ; } if ( buf != NULL ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_HYPHEN_IN_COMMENT , "Double hyphen within comment: " "<!--%.50s\n" , buf ) ; } else xmlFatalErrMsgStr ( ctxt , XML_ERR_HYPHEN_IN_COMMENT , "Double hyphen within comment\n" , NULL ) ; in ++ ; ctxt -> input -> col ++ ; } in ++ ; ctxt -> input -> col ++ ; goto get_more ; } } while ( ( ( * in >= 0x20 ) && ( * in <= 0x7F ) ) || ( * in == 0x09 ) ) ; xmlParseCommentComplex ( ctxt , buf , len , size ) ; ctxt -> instate = state ; return ; }
krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ; krb5_key_data * key_data ; if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; if ( key_data_in == NULL ) goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { krb5_data * code ; if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) { ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ; if ( ret [ j ] == NULL ) goto cleanup ; err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ; if ( err ) goto cleanup ; ret [ j ] -> bv_len = code -> length ; ret [ j ] -> bv_val = code -> data ; free ( code ) ; j ++ ; last = i + 1 ; currkvno = key_data [ i ] . key_data_kvno ; } } ret [ num_versions ] = NULL ; cleanup : free ( key_data ) ; if ( err != 0 ) { if ( ret != NULL ) { for ( i = 0 ; i <= num_versions ; i ++ ) if ( ret [ i ] != NULL ) free ( ret [ i ] ) ; free ( ret ) ; ret = NULL ; } } return ret ; }
R_API ut64 r_bin_java_element_pair_calc_size ( RBinJavaElementValuePair * evp ) { ut64 sz = 0 ; if ( evp == NULL ) { return sz ; } sz += 2 ; if ( evp -> value ) { sz += r_bin_java_element_value_calc_size ( evp -> value ) ; } return sz ; }
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN ( CallbackObject ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN ( CallbackObject ) NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK ( mCallback ) NS_IMPL_CYCLE_COLLECTION_TRACE_END CallbackObject :: CallSetup :: CallSetup ( JSObject * const aCallback , ErrorResult & aRv , ExceptionHandling aExceptionHandling ) : mCx ( nullptr ) , mErrorResult ( aRv ) , mExceptionHandling ( aExceptionHandling ) { xpc_UnmarkGrayObject ( aCallback ) ; JSObject * realCallback = js :: UnwrapObject ( aCallback ) ; JSContext * cx = nullptr ; nsIScriptContext * ctx = nullptr ; nsIScriptGlobalObject * sgo = nsJSUtils :: GetStaticScriptGlobal ( realCallback ) ; if ( sgo ) { nsCOMPtr < nsPIDOMWindow > win = do_QueryInterface ( sgo ) ; if ( win ) { MOZ_ASSERT ( win -> IsInnerWindow ( ) ) ; nsPIDOMWindow * outer = win -> GetOuterWindow ( ) ; if ( ! outer || win != outer -> GetCurrentInnerWindow ( ) ) { return ; } } ctx = sgo -> GetContext ( ) ; if ( ctx ) { cx = ctx -> GetNativeContext ( ) ; } } if ( ! cx ) { cx = nsContentUtils :: GetSafeJSContext ( ) ; } mAr . construct ( cx ) ; if ( ! mCxPusher . Push ( cx ) ) { return ; } mCtx = ctx ; nsresult rv = nsContentUtils :: GetSecurityManager ( ) -> CheckFunctionAccess ( cx , js :: UnwrapObject ( aCallback ) , nullptr ) ; if ( ctx ) { mTerminationFuncHolder . construct ( static_cast < nsJSContext * > ( ctx ) ) ; } if ( NS_FAILED ( rv ) ) { return ; } mAc . construct ( cx , aCallback ) ; mCx = cx ; if ( mExceptionHandling == eRethrowExceptions ) { mSavedJSContextOptions = JS_GetOptions ( cx ) ; JS_SetOptions ( cx , mSavedJSContextOptions | JSOPTION_DONT_REPORT_UNCAUGHT ) ; } }
const Operator * SimplifiedOperatorBuilder :: NewSmiOrObjectElements ( PretenureFlag pretenure ) { return new ( zone ( ) ) Operator1 < PretenureFlag > ( IrOpcode :: kNewSmiOrObjectElements , Operator :: kEliminatable , "NewSmiOrObjectElements" , 1 , 1 , 1 , 1 , 1 , 0 , pretenure ) ; }
static LUA_FUNCTION ( openssl_x509_check_host ) { X509 * cert = CHECK_OBJECT ( 1 , X509 , "openssl.x509" ) ; if ( lua_isstring ( L , 2 ) ) { const char * hostname = lua_tostring ( L , 2 ) ; lua_pushboolean ( L , X509_check_host ( cert , hostname , strlen ( hostname ) , 0 , NULL ) ) ; } else { lua_pushboolean ( L , 0 ) ; } return 1 ; }
JO ( JSContext * cx , HandleObject obj , StringifyContext * scx ) { AutoCycleDetector detect ( cx , obj ) ; if ( ! detect . init ( ) ) return false ; if ( detect . foundCycle ( ) ) { JS_ReportErrorNumber ( cx , js_GetErrorMessage , nullptr , JSMSG_JSON_CYCLIC_VALUE , js_object_str ) ; return false ; } if ( ! scx -> sb . append ( '{' ) ) return false ; Maybe < AutoIdVector > ids ; const AutoIdVector * props ; if ( scx -> replacer && ! scx -> replacer -> isCallable ( ) ) { MOZ_ASSERT ( JS_IsArrayObject ( cx , scx -> replacer ) ) ; props = & scx -> propertyList ; } else { MOZ_ASSERT_IF ( scx -> replacer , scx -> propertyList . length ( ) == 0 ) ; ids . emplace ( cx ) ; if ( ! GetPropertyKeys ( cx , obj , JSITER_OWNONLY , ids . ptr ( ) ) ) return false ; props = ids . ptr ( ) ; } const AutoIdVector & propertyList = * props ; bool wroteMember = false ; RootedId id ( cx ) ; for ( size_t i = 0 , len = propertyList . length ( ) ; i < len ; i ++ ) { id = propertyList [ i ] ; RootedValue outputValue ( cx ) ; if ( ! GetProperty ( cx , obj , obj , id , & outputValue ) ) return false ; if ( ! PreprocessValue ( cx , obj , HandleId ( id ) , & outputValue , scx ) ) return false ; if ( IsFilteredValue ( outputValue ) ) continue ; if ( wroteMember && ! scx -> sb . append ( ',' ) ) return false ; wroteMember = true ; if ( ! WriteIndent ( cx , scx , scx -> depth ) ) return false ; JSString * s = IdToString ( cx , id ) ; if ( ! s ) return false ; if ( ! Quote ( cx , scx -> sb , s ) || ! scx -> sb . append ( ':' ) || ! ( scx -> gap . empty ( ) || scx -> sb . append ( ' ' ) ) || ! Str ( cx , outputValue , scx ) ) { return false ; } } if ( wroteMember && ! WriteIndent ( cx , scx , scx -> depth - 1 ) ) return false ; return scx -> sb . append ( '}' ) ; }
TfLiteStatus Subgraph :: AllocateTensors ( ) { TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE ( profiler_ . get ( ) , "AllocateTensors" ) ; if ( ! consistent_ ) { ReportError ( "AllocateTensors() called on inconsistent model." ) ; return kTfLiteError ; } TF_LITE_ENSURE_STATUS ( RedoAllDelegates ( ) ) ; if ( state_ != kStateUninvokable && ! HasDynamicTensorImpl ( context_ , inputs ( ) ) ) { if ( memory_planner_ && ! memory_planner_ -> HasNonPersistentMemory ( ) ) { memory_planner_ -> AcquireNonPersistentMemory ( ) ; } return kTfLiteOk ; } next_execution_plan_index_to_prepare_ = 0 ; next_execution_plan_index_to_plan_allocation_ = 0 ; next_original_execution_plan_index_to_prepare_ = 0 ; if ( memory_planner_ ) { TF_LITE_ENSURE_STATUS ( memory_planner_ -> ResetAllocations ( ) ) ; } TF_LITE_ENSURE_STATUS ( PrepareOpsAndTensors ( ) ) ; state_ = kStateInvokable ; ResetVariableTensors ( ) ; return kTfLiteOk ; }
TEST_F ( ApexServiceRevertTest , RevertActiveSessionsSuccessful ) { if ( supports_fs_checkpointing_ ) { GTEST_SKIP ( ) < < "Can't run if filesystem checkpointing is enabled" ; } PrepareTestApexForInstall installer ( GetTestFile ( "apex.apexd_test_v2.apex" ) ) ; if ( ! installer . Prepare ( ) ) { return ; } auto session = ApexSession :: CreateSession ( 1543 ) ; ASSERT_TRUE ( IsOk ( session ) ) ; ASSERT_TRUE ( IsOk ( session -> UpdateStateAndCommit ( SessionState :: ACTIVATED ) ) ) ; ASSERT_TRUE ( IsOk ( service_ -> stagePackages ( { installer . test_file } ) ) ) ; PrepareBackup ( { GetTestFile ( "apex.apexd_test.apex" ) } ) ; ASSERT_TRUE ( IsOk ( service_ -> revertActiveSessions ( ) ) ) ; auto pkg = StringPrintf ( "%s/com.android.apex.test_package@1.apex" , kActiveApexPackagesDataDir ) ; SCOPED_TRACE ( "" ) ; CheckRevertWasPerformed ( { pkg } ) ; }
void RegExpMacroAssemblerIA32 :: Push ( Register source ) { DCHECK ( source != backtrack_stackpointer ( ) ) ; __ sub ( backtrack_stackpointer ( ) , Immediate ( kPointerSize ) ) ; __ mov ( Operand ( backtrack_stackpointer ( ) , 0 ) , source ) ; }
void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; } kfree ( bprm ) ; }
Network :: FilterStatus Context :: onUpstreamData ( int data_length , bool end_of_stream ) { if ( ! wasm_ -> onUpstreamData_ ) { return Network :: FilterStatus :: Continue ; } auto result = wasm_ -> onUpstreamData_ ( this , id_ , static_cast < uint32_t > ( data_length ) , static_cast < uint32_t > ( end_of_stream ) ) ; return result . u64_ == 0 ? Network :: FilterStatus :: Continue : Network :: FilterStatus :: StopIteration ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * cond_tensor = GetInput ( context , node , kInputConditionTensor ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; if ( cond_tensor -> type != kTfLiteBool ) { context -> ReportError ( context , "Condition tensor must be of type bool, but saw '%s'." , TfLiteTypeGetName ( cond_tensor -> type ) ) ; return kTfLiteError ; } output -> type = kTfLiteInt64 ; if ( ! IsConstantTensor ( cond_tensor ) ) { SetTensorToDynamic ( output ) ; return kTfLiteOk ; } return ResizeOutputTensor ( context , cond_tensor , output ) ; }
BUILTIN ( DatePrototypeToString ) { HandleScope scope ( isolate ) ; CHECK_RECEIVER ( JSDate , date , "Date.prototype.toString" ) ; char buffer [ 128 ] ; ToDateString ( date -> value ( ) -> Number ( ) , ArrayVector ( buffer ) , isolate -> date_cache ( ) ) ; RETURN_RESULT_OR_FAILURE ( isolate , isolate -> factory ( ) -> NewStringFromUtf8 ( CStrVector ( buffer ) ) ) ; }
static bool DoSetPropFallback ( JSContext * cx , BaselineFrame * frame , ICSetProp_Fallback * stub , Value * stack , HandleValue lhs , HandleValue rhs ) { stub -> incrementEnteredCount ( ) ; RootedScript script ( cx , frame -> script ( ) ) ; jsbytecode * pc = stub -> icEntry ( ) -> pc ( script ) ; JSOp op = JSOp ( * pc ) ; FallbackICSpew ( cx , stub , "SetProp(%s)" , CodeName [ op ] ) ; MOZ_ASSERT ( op == JSOP_SETPROP || op == JSOP_STRICTSETPROP || op == JSOP_SETNAME || op == JSOP_STRICTSETNAME || op == JSOP_SETGNAME || op == JSOP_STRICTSETGNAME || op == JSOP_INITPROP || op == JSOP_INITLOCKEDPROP || op == JSOP_INITHIDDENPROP || op == JSOP_INITGLEXICAL ) ; RootedPropertyName name ( cx , script -> getName ( pc ) ) ; RootedId id ( cx , NameToId ( name ) ) ; RootedObject obj ( cx , ToObjectFromStack ( cx , lhs ) ) ; if ( ! obj ) { return false ; } RootedShape oldShape ( cx , obj -> maybeShape ( ) ) ; RootedObjectGroup oldGroup ( cx , JSObject :: getGroup ( cx , obj ) ) ; if ( ! oldGroup ) { return false ; } if ( obj -> is < UnboxedPlainObject > ( ) ) { MOZ_ASSERT ( ! oldShape ) ; if ( UnboxedExpandoObject * expando = obj -> as < UnboxedPlainObject > ( ) . maybeExpando ( ) ) { oldShape = expando -> lastProperty ( ) ; } } bool isTemporarilyUnoptimizable = false ; bool attached = false ; if ( stub -> state ( ) . maybeTransition ( ) ) { stub -> discardStubs ( cx ) ; } if ( stub -> state ( ) . canAttachStub ( ) ) { RootedValue idVal ( cx , StringValue ( name ) ) ; SetPropIRGenerator gen ( cx , script , pc , CacheKind :: SetProp , stub -> state ( ) . mode ( ) , & isTemporarilyUnoptimizable , lhs , idVal , rhs ) ; if ( gen . tryAttachStub ( ) ) { ICStub * newStub = AttachBaselineCacheIRStub ( cx , gen . writerRef ( ) , gen . cacheKind ( ) , BaselineCacheIRStubKind :: Updated , frame -> script ( ) , stub , & attached ) ; if ( newStub ) { JitSpew ( JitSpew_BaselineIC , "  Attached SetProp CacheIR stub" ) ; SetUpdateStubData ( newStub -> toCacheIR_Updated ( ) , gen . typeCheckInfo ( ) ) ; if ( gen . shouldNotePreliminaryObjectStub ( ) ) { newStub -> toCacheIR_Updated ( ) -> notePreliminaryObject ( ) ; } else if ( gen . shouldUnlinkPreliminaryObjectStubs ( ) ) { StripPreliminaryObjectStubs ( cx , stub ) ; } } } } if ( op == JSOP_INITPROP || op == JSOP_INITLOCKEDPROP || op == JSOP_INITHIDDENPROP ) { if ( ! InitPropertyOperation ( cx , op , obj , name , rhs ) ) { return false ; } } else if ( op == JSOP_SETNAME || op == JSOP_STRICTSETNAME || op == JSOP_SETGNAME || op == JSOP_STRICTSETGNAME ) { if ( ! SetNameOperation ( cx , script , pc , obj , rhs ) ) { return false ; } } else if ( op == JSOP_INITGLEXICAL ) { RootedValue v ( cx , rhs ) ; LexicalEnvironmentObject * lexicalEnv ; if ( script -> hasNonSyntacticScope ( ) ) { lexicalEnv = & NearestEnclosingExtensibleLexicalEnvironment ( frame -> environmentChain ( ) ) ; } else { lexicalEnv = & cx -> global ( ) -> lexicalEnvironment ( ) ; } InitGlobalLexicalOperation ( cx , lexicalEnv , script , pc , v ) ; } else { MOZ_ASSERT ( op == JSOP_SETPROP || op == JSOP_STRICTSETPROP ) ; ObjectOpResult result ; if ( ! SetProperty ( cx , obj , id , rhs , lhs , result ) || ! result . checkStrictErrorOrWarning ( cx , obj , id , op == JSOP_STRICTSETPROP ) ) { return false ; } } MOZ_ASSERT ( stack [ 1 ] == lhs ) ; stack [ 1 ] = rhs ; if ( attached ) { return true ; } if ( stub -> state ( ) . maybeTransition ( ) ) { stub -> discardStubs ( cx ) ; } if ( stub -> state ( ) . canAttachStub ( ) ) { RootedValue idVal ( cx , StringValue ( name ) ) ; SetPropIRGenerator gen ( cx , script , pc , CacheKind :: SetProp , stub -> state ( ) . mode ( ) , & isTemporarilyUnoptimizable , lhs , idVal , rhs ) ; if ( gen . tryAttachAddSlotStub ( oldGroup , oldShape ) ) { ICStub * newStub = AttachBaselineCacheIRStub ( cx , gen . writerRef ( ) , gen . cacheKind ( ) , BaselineCacheIRStubKind :: Updated , frame -> script ( ) , stub , & attached ) ; if ( newStub ) { JitSpew ( JitSpew_BaselineIC , "  Attached SetProp CacheIR stub" ) ; SetUpdateStubData ( newStub -> toCacheIR_Updated ( ) , gen . typeCheckInfo ( ) ) ; if ( gen . shouldNotePreliminaryObjectStub ( ) ) { newStub -> toCacheIR_Updated ( ) -> notePreliminaryObject ( ) ; } else if ( gen . shouldUnlinkPreliminaryObjectStubs ( ) ) { StripPreliminaryObjectStubs ( cx , stub ) ; } } } else { gen . trackAttached ( IRGenerator :: NotAttached ) ; } if ( ! attached && ! isTemporarilyUnoptimizable ) { stub -> state ( ) . trackNotAttached ( ) ; } } return true ; }
static void * sock_poll_thread ( void * arg ) { struct pollfd pfds [ MAX_POLL ] ; memset ( pfds , 0 , sizeof ( pfds ) ) ; int h = ( intptr_t ) arg ; for ( ; ; ) { prepare_poll_fds ( h , pfds ) ; int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ; if ( ret == - 1 ) { APPL_TRACE_ERROR ( "poll ret -1, exit the thread, errno:%d, err:%s" , errno , strerror ( errno ) ) ; break ; } if ( ret != 0 ) { int need_process_data_fd = TRUE ; if ( pfds [ 0 ] . revents ) { asrt ( pfds [ 0 ] . fd == ts [ h ] . cmd_fdr ) ; if ( ! process_cmd_sock ( h ) ) { APPL_TRACE_DEBUG ( "h:%d, process_cmd_sock return false, exit..." , h ) ; break ; } if ( ret == 1 ) need_process_data_fd = FALSE ; else ret -- ; } if ( need_process_data_fd ) process_data_sock ( h , pfds , ret ) ; } else { APPL_TRACE_DEBUG ( "no data, select ret: %d" , ret ) } ; } ts [ h ] . thread_id = - 1 ; APPL_TRACE_DEBUG ( "socket poll thread exiting, h:%d" , h ) ; return 0 ; }
double Heap :: YoungGenerationMutatorUtilization ( ) { double mutator_speed = static_cast < double > ( tracer ( ) -> NewSpaceAllocationThroughputInBytesPerMillisecond ( ) ) ; double gc_speed = tracer ( ) -> ScavengeSpeedInBytesPerMillisecond ( kForSurvivedObjects ) ; double result = ComputeMutatorUtilization ( mutator_speed , gc_speed ) ; if ( FLAG_trace_mutator_utilization ) { isolate ( ) -> PrintWithTimestamp ( "Young generation mutator utilization = %.3f (" "mutator_speed=%.f, gc_speed=%.f)\n" , result , mutator_speed , gc_speed ) ; } return result ; }
static int cipso_v4_delopt ( struct ip_options * * opt_ptr ) { int hdr_delta = 0 ; struct ip_options * opt = * opt_ptr ; if ( opt -> srr || opt -> rr || opt -> ts || opt -> router_alert ) { u8 cipso_len ; u8 cipso_off ; unsigned char * cipso_ptr ; int iter ; int optlen_new ; cipso_off = opt -> cipso - sizeof ( struct iphdr ) ; cipso_ptr = & opt -> __data [ cipso_off ] ; cipso_len = cipso_ptr [ 1 ] ; if ( opt -> srr > opt -> cipso ) opt -> srr -= cipso_len ; if ( opt -> rr > opt -> cipso ) opt -> rr -= cipso_len ; if ( opt -> ts > opt -> cipso ) opt -> ts -= cipso_len ; if ( opt -> router_alert > opt -> cipso ) opt -> router_alert -= cipso_len ; opt -> cipso = 0 ; memmove ( cipso_ptr , cipso_ptr + cipso_len , opt -> optlen - cipso_off - cipso_len ) ; iter = 0 ; optlen_new = 0 ; while ( iter < opt -> optlen ) if ( opt -> __data [ iter ] != IPOPT_NOP ) { iter += opt -> __data [ iter + 1 ] ; optlen_new = iter ; } else iter ++ ; hdr_delta = opt -> optlen ; opt -> optlen = ( optlen_new + 3 ) & ~ 3 ; hdr_delta -= opt -> optlen ; } else { * opt_ptr = NULL ; hdr_delta = opt -> optlen ; kfree ( opt ) ; } return hdr_delta ; }
NS_IMETHODIMP nsPluginInstanceOwner :: CreateWidget ( void ) { NS_ENSURE_TRUE ( mPluginWindow , NS_ERROR_NULL_POINTER ) ; nsresult rv = NS_ERROR_FAILURE ; if ( mWidget ) { NS_WARNING ( "Trying to create a plugin widget twice!" ) ; return NS_ERROR_FAILURE ; } bool windowless = false ; mInstance -> IsWindowless ( & windowless ) ; if ( ! windowless ) { nsCOMPtr < nsIWidget > parentWidget ; nsIDocument * doc = nullptr ; if ( mContent ) { doc = mContent -> OwnerDoc ( ) ; parentWidget = nsContentUtils :: WidgetForDocument ( doc ) ; #ifndef XP_MACOSX if ( XRE_GetProcessType ( ) == GeckoProcessType_Content ) { nsCOMPtr < nsIDOMWindow > window = doc -> GetWindow ( ) ; if ( window ) { nsCOMPtr < nsIDOMWindow > topWindow ; window -> GetTop ( getter_AddRefs ( topWindow ) ) ; if ( topWindow ) { dom :: TabChild * tc = dom :: TabChild :: GetFrom ( topWindow ) ; if ( tc ) { rv = tc -> CreatePluginWidget ( parentWidget . get ( ) , getter_AddRefs ( mWidget ) ) ; if ( NS_FAILED ( rv ) ) { return rv ; } } } } } #endif // XP_MACOSX } if ( ! mWidget ) { mWidget = do_CreateInstance ( kWidgetCID , & rv ) ; nsWidgetInitData initData ; initData . mWindowType = eWindowType_plugin ; initData . mUnicode = false ; initData . clipChildren = true ; initData . clipSiblings = true ; rv = mWidget -> Create ( parentWidget . get ( ) , nullptr , nsIntRect ( 0 , 0 , 0 , 0 ) , & initData ) ; if ( NS_FAILED ( rv ) ) { mWidget -> Destroy ( ) ; mWidget = nullptr ; return rv ; } } mWidget -> EnableDragDrop ( true ) ; mWidget -> Show ( false ) ; mWidget -> Enable ( false ) ; } if ( mPluginFrame ) { mPluginFrame -> PrepForDrawing ( mWidget ) ; } if ( windowless ) { mPluginWindow -> type = NPWindowTypeDrawable ; mPluginWindow -> window = nullptr ; #ifdef MOZ_X11 NPSetWindowCallbackStruct * ws_info = static_cast < NPSetWindowCallbackStruct * > ( mPluginWindow -> ws_info ) ; ws_info -> display = DefaultXDisplay ( ) ; nsAutoCString description ; GetPluginDescription ( description ) ; NS_NAMED_LITERAL_CSTRING ( flash10Head , "Shockwave Flash 10." ) ; mFlash10Quirks = StringBeginsWith ( description , flash10Head ) ; #endif } else if ( mWidget ) { mPluginWindow -> type = NPWindowTypeWindow ; mPluginWindow -> window = GetPluginPort ( ) ; mPluginWindow -> SetPluginWidget ( mWidget ) ; nsCOMPtr < nsIPluginWidget > pluginWidget = do_QueryInterface ( mWidget ) ; if ( pluginWidget ) { pluginWidget -> SetPluginInstanceOwner ( this ) ; } } #ifdef XP_MACOSX if ( GetDrawingModel ( ) == NPDrawingModelCoreAnimation ) { AddToCARefreshTimer ( ) ; } #endif mWidgetCreationComplete = true ; return NS_OK ; }
TF_BUILTIN ( DebugBreakTrampoline , CodeStubAssembler ) { Label tailcall_to_shared ( this ) ; TNode < Context > context = CAST ( Parameter ( Descriptor :: kContext ) ) ; TNode < Object > new_target = CAST ( Parameter ( Descriptor :: kJSNewTarget ) ) ; TNode < Int32T > arg_count = UncheckedCast < Int32T > ( Parameter ( Descriptor :: kJSActualArgumentsCount ) ) ; TNode < JSFunction > function = CAST ( Parameter ( Descriptor :: kJSTarget ) ) ; TNode < SharedFunctionInfo > shared = CAST ( LoadObjectField ( function , JSFunction :: kSharedFunctionInfoOffset ) ) ; TNode < Object > maybe_heap_object_or_smi = LoadObjectField ( shared , SharedFunctionInfo :: kScriptOrDebugInfoOffset ) ; TNode < HeapObject > maybe_debug_info = TaggedToHeapObject ( maybe_heap_object_or_smi , & tailcall_to_shared ) ; GotoIfNot ( HasInstanceType ( maybe_debug_info , InstanceType :: DEBUG_INFO_TYPE ) , & tailcall_to_shared ) ; { TNode < DebugInfo > debug_info = CAST ( maybe_debug_info ) ; TNode < Smi > flags = CAST ( LoadObjectField ( debug_info , DebugInfo :: kFlagsOffset ) ) ; GotoIfNot ( SmiToInt32 ( SmiAnd ( flags , SmiConstant ( DebugInfo :: kBreakAtEntry ) ) ) , & tailcall_to_shared ) ; CallRuntime ( Runtime :: kDebugBreakAtEntry , context , function ) ; Goto ( & tailcall_to_shared ) ; } BIND ( & tailcall_to_shared ) ; TNode < Code > code = GetSharedFunctionInfoCode ( shared ) ; TailCallJSCode ( code , context , function , new_target , arg_count ) ; }
pci_emul_mem_handler ( struct vmctx * ctx , int vcpu , int dir , uint64_t addr , int size , uint64_t * val , void * arg1 , long arg2 ) { struct pci_vdev * pdi = arg1 ; struct pci_vdev_ops * ops = pdi -> dev_ops ; uint64_t offset ; int bidx = ( int ) arg2 ; assert ( bidx <= PCI_BARMAX ) ; assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ; assert ( addr >= pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . size ) ; offset = addr - pdi -> bar [ bidx ] . addr ; if ( dir == MEM_F_WRITE ) { if ( size == 8 ) { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , 4 , * val & 0xffffffff ) ; ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 , * val > > 32 ) ; } else { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , size , bar_value ( size , * val ) ) ; } } else { if ( size == 8 ) { uint64_t val_lo , val_hi ; val_lo = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , 4 ) ; val_lo = bar_value ( 4 , val_lo ) ; val_hi = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 ) ; * val = val_lo | ( val_hi < < 32 ) ; } else { * val = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , size ) ; * val = bar_value ( size , * val ) ; } } return 0 ; }
LoadAllScripts ( JSContext * aCx , WorkerPrivate * aWorkerPrivate , nsTArray < ScriptLoadInfo > & aLoadInfos , bool aIsMainScript , WorkerScriptType aWorkerScriptType ) { aWorkerPrivate -> AssertIsOnWorkerThread ( ) ; NS_ASSERTION ( ! aLoadInfos . IsEmpty ( ) , "Bad arguments!" ) ; AutoSyncLoopHolder syncLoop ( aWorkerPrivate ) ; nsRefPtr < ScriptLoaderRunnable > loader = new ScriptLoaderRunnable ( aWorkerPrivate , syncLoop . EventTarget ( ) , aLoadInfos , aIsMainScript , aWorkerScriptType ) ; NS_ASSERTION ( aLoadInfos . IsEmpty ( ) , "Should have swapped!" ) ; if ( ! aWorkerPrivate -> AddFeature ( aCx , loader ) ) { return false ; } if ( NS_FAILED ( NS_DispatchToMainThread ( loader ) ) ) { NS_ERROR ( "Failed to dispatch!" ) ; aWorkerPrivate -> RemoveFeature ( aCx , loader ) ; return false ; } return syncLoop . Run ( ) ; }
int mutt_seqset_iterator_next ( struct SeqsetIterator * iter , unsigned int * next ) { if ( ! iter || ! next ) return - 1 ; if ( iter -> in_range ) { if ( ( iter -> down && ( iter -> range_cur == ( iter -> range_end - 1 ) ) ) || ( ! iter -> down && ( iter -> range_cur == ( iter -> range_end + 1 ) ) ) ) { iter -> in_range = 0 ; } } if ( ! iter -> in_range ) { iter -> substr_cur = iter -> substr_end ; if ( iter -> substr_cur == iter -> eostr ) return 1 ; while ( ! * ( iter -> substr_cur ) ) iter -> substr_cur ++ ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ) = '\0' ; char * range_sep = strchr ( iter -> substr_cur , ':' ) ; if ( range_sep ) * range_sep ++ = '\0' ; if ( mutt_str_atoui ( iter -> substr_cur , & iter -> range_cur ) != 0 ) return - 1 ; if ( range_sep ) { if ( mutt_str_atoui ( range_sep , & iter -> range_end ) != 0 ) return - 1 ; } else iter -> range_end = iter -> range_cur ; iter -> down = ( iter -> range_end < iter -> range_cur ) ; iter -> in_range = 1 ; } * next = iter -> range_cur ; if ( iter -> down ) iter -> range_cur -- ; else iter -> range_cur ++ ; return 0 ; }
static int ntlm_decode_u16l_str_hdr ( struct ntlm_ctx * ctx , struct wire_field_hdr * str_hdr , struct ntlm_buffer * buffer , size_t payload_offs , char * * str ) { char * in , * out = NULL ; uint16_t str_len ; uint32_t str_offs ; size_t outlen ; int ret = 0 ; str_len = le16toh ( str_hdr -> len ) ; if ( str_len == 0 ) goto done ; str_offs = le32toh ( str_hdr -> offset ) ; if ( ( str_offs < payload_offs ) || ( str_offs > buffer -> length ) || ( str_offs + str_len > buffer -> length ) ) { return ERR_DECODE ; } in = ( char * ) & buffer -> data [ str_offs ] ; out = malloc ( str_len * 2 + 1 ) ; if ( ! out ) return ENOMEM ; ret = ntlm_str_convert ( ctx -> to_oem , in , out , str_len , & outlen ) ; out [ outlen ] = '\0' ; done : if ( ret ) { safefree ( out ) ; } * str = out ; return ret ; }
setkey_principal_2_svc ( setkey_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; gss_buffer_desc client_name , service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_SETKEY , arg -> princ , NULL ) ) { ret . code = kadm5_setkey_principal ( ( void * ) handle , arg -> princ , arg -> keyblocks , arg -> n_keys ) ; } else { log_unauth ( "kadm5_setkey_principal" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_SETKEY ; } if ( ret . code != KADM5_AUTH_SETKEY ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( "kadm5_setkey_principal" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
const Operator * JSOperatorBuilder :: LoadNamed ( Handle < Name > name , const VectorSlotPair & feedback ) { NamedAccess access ( LanguageMode :: kSloppy , name , feedback ) ; return new ( zone ( ) ) Operator1 < NamedAccess > ( IrOpcode :: kJSLoadNamed , Operator :: kNoProperties , "JSLoadNamed" , 1 , 1 , 1 , 1 , 1 , 2 , access ) ; }
void EffectControlLinearizer :: LowerTransitionElementsKind ( Node * node ) { ElementsTransition const transition = ElementsTransitionOf ( node -> op ( ) ) ; Node * object = node -> InputAt ( 0 ) ; auto if_map_same = __ MakeDeferredLabel ( ) ; auto done = __ MakeLabel ( ) ; Node * source_map = __ HeapConstant ( transition . source ( ) ) ; Node * target_map = __ HeapConstant ( transition . target ( ) ) ; Node * object_map = __ LoadField ( AccessBuilder :: ForMap ( ) , object ) ; Node * check = __ WordEqual ( object_map , source_map ) ; __ GotoIf ( check , & if_map_same ) ; __ Goto ( & done ) ; __ Bind ( & if_map_same ) ; switch ( transition . mode ( ) ) { case ElementsTransition :: kFastTransition : __ StoreField ( AccessBuilder :: ForMap ( ) , object , target_map ) ; break ; case ElementsTransition :: kSlowTransition : { Operator :: Properties properties = Operator :: kNoDeopt | Operator :: kNoThrow ; Runtime :: FunctionId id = Runtime :: kTransitionElementsKind ; auto call_descriptor = Linkage :: GetRuntimeCallDescriptor ( graph ( ) -> zone ( ) , id , 2 , properties , CallDescriptor :: kNoFlags ) ; __ Call ( call_descriptor , __ CEntryStubConstant ( 1 ) , object , target_map , __ ExternalConstant ( ExternalReference :: Create ( id ) ) , __ Int32Constant ( 2 ) , __ NoContextConstant ( ) ) ; break ; } } __ Goto ( & done ) ; __ Bind ( & done ) ; }
n_start_visual_mode ( int c ) { #ifdef FEAT_CONCEAL int cursor_line_was_concealed = curwin -> w_p_cole > 0 && conceal_cursor_line ( curwin ) ; #endif VIsual_mode = c ; VIsual_active = TRUE ; VIsual_reselect = TRUE ; trigger_modechanged ( ) ; if ( c == Ctrl_V && ( get_ve_flags ( ) & VE_BLOCK ) && gchar_cursor ( ) == TAB ) { validate_virtcol ( ) ; coladvance ( curwin -> w_virtcol ) ; } VIsual = curwin -> w_cursor ; #ifdef FEAT_FOLDING foldAdjustVisual ( ) ; #endif setmouse ( ) ; #ifdef FEAT_CONCEAL conceal_check_cursor_line ( cursor_line_was_concealed ) ; #endif if ( p_smd && msg_silent == 0 ) redraw_cmdline = TRUE ; #ifdef FEAT_CLIPBOARD clip_star . vmode = NUL ; #endif if ( curwin -> w_redr_type < INVERTED ) { curwin -> w_old_cursor_lnum = curwin -> w_cursor . lnum ; curwin -> w_old_visual_lnum = curwin -> w_cursor . lnum ; } }
[ & ] ( TypedValue tv ) -> bool { if ( i >= strobelight :: kMaxStackframes ) { return true ; } assertx ( isArrayLikeType ( type ( tv ) ) ) ; ArrayData * bt_frame = val ( tv ) . parr ; strobelight :: backtrace_frame_t * frame = & bt_slab . frames [ i ] ; auto const line = bt_frame -> get ( s_line . get ( ) ) ; if ( line . is_init ( ) ) { assertx ( isIntType ( type ( line ) ) ) ; frame -> line = val ( line ) . num ; } auto const file_name = bt_frame -> get ( s_file . get ( ) ) ; if ( file_name . is_init ( ) ) { assertx ( isStringType ( type ( file_name ) ) ) ; strncpy ( frame -> file_name , val ( file_name ) . pstr -> data ( ) , - std :: min ( val ( file_name ) . pstr -> size ( ) , strobelight :: kFileNameMax ) ) ; + std :: min < int64_t > ( + val ( file_name ) . pstr -> size ( ) , + strobelight :: kFileNameMax + ) ) ; frame -> file_name [ strobelight :: kFileNameMax - 1 ] = '\0' ; } auto const class_name = bt_frame -> get ( s_class . get ( ) ) ; if ( class_name . is_init ( ) ) { assertx ( isStringType ( type ( class_name ) ) ) ; strncpy ( frame -> class_name , val ( class_name ) . pstr -> data ( ) , - std :: min ( val ( class_name ) . pstr -> size ( ) , strobelight :: kClassNameMax ) ) ; + std :: min < int64_t > ( + val ( class_name ) . pstr -> size ( ) , + strobelight :: kClassNameMax + ) ) ; frame -> class_name [ strobelight :: kClassNameMax - 1 ] = '\0' ; } auto const function_name = bt_frame -> get ( s_function . get ( ) ) ; if ( function_name . is_init ( ) ) { assertx ( isStringType ( type ( function_name ) ) ) ; strncpy ( frame -> function , val ( function_name ) . pstr -> data ( ) , - std :: min ( val ( function_name ) . pstr -> size ( ) , - strobelight :: kFunctionMax ) ) ; + std :: min < int64_t > ( + val ( function_name ) . pstr -> size ( ) , + strobelight :: kFunctionMax + ) ) ; frame -> function [ strobelight :: kFunctionMax - 1 ] = '\0' ; } i ++ ; return false ; }
getSecretShares ( const string & _polyName , const char * _encryptedPolyHex , const vector < string > & _publicKeys , int _t , int _n ) { CHECK_STATE ( _encryptedPolyHex ) ; vector < char > hexEncrKey ( BUF_LEN , 0 ) ; vector < char > errMsg1 ( BUF_LEN , 0 ) ; vector < uint8_t > encrDKGPoly ( BUF_LEN , 0 ) ; int errStatus = 0 ; uint64_t encLen = 0 ; if ( ! hex2carray ( _encryptedPolyHex , & encLen , encrDKGPoly . data ( ) , BUF_LEN ) ) { throw SGXException ( INVALID_HEX , "Invalid encryptedPolyHex" ) ; } sgx_status_t status = trustedSetEncryptedDkgPolyAES ( eid , & errStatus , errMsg1 . data ( ) , encrDKGPoly . data ( ) , encLen ) ; HANDLE_TRUSTED_FUNCTION_ERROR ( status , errStatus , errMsg1 . data ( ) ) ; string result ; for ( int i = 0 ; i < _n ; i ++ ) { vector < uint8_t > encryptedSkey ( BUF_LEN , 0 ) ; uint32_t decLen ; vector < char > currentShare ( 193 , 0 ) ; vector < char > sShareG2 ( 320 , 0 ) ; string pub_keyB = _publicKeys . at ( i ) ; vector < char > pubKeyB ( 129 , 0 ) ; strncpy ( pubKeyB . data ( ) , pub_keyB . c_str ( ) , 128 ) ; pubKeyB . at ( 128 ) = 0 ; spdlog :: debug ( "pubKeyB is {}" , pub_keyB ) ; sgx_status_t status = trustedGetEncryptedSecretShareAES ( eid , & errStatus , errMsg1 . data ( ) , encryptedSkey . data ( ) , & decLen , currentShare . data ( ) , sShareG2 . data ( ) , pubKeyB . data ( ) , _t , _n , i + 1 ) ; HANDLE_TRUSTED_FUNCTION_ERROR ( status , errStatus , errMsg1 . data ( ) ) ; spdlog :: debug ( "cur_share is {}" , currentShare . data ( ) ) ; result += string ( currentShare . data ( ) ) ; spdlog :: debug ( "dec len is {}" , decLen ) ; carray2Hex ( encryptedSkey . data ( ) , decLen , hexEncrKey . data ( ) , BUF_LEN ) ; string dhKeyName = "DKG_DH_KEY_" + _polyName + "_" + to_string ( i ) + ":" ; spdlog :: debug ( "hexEncr DH Key: { }" , hexEncrKey . data ( ) ) ; spdlog :: debug ( "name to write to db is {}" , dhKeyName ) ; SGXWalletServer :: writeDataToDB ( dhKeyName , hexEncrKey . data ( ) ) ; string shareG2_name = "shareG2_" + _polyName + "_" + to_string ( i ) + ":" ; spdlog :: debug ( "name to write to db is {}" , shareG2_name ) ; spdlog :: debug ( "s_shareG2: {}" , sShareG2 . data ( ) ) ; SGXWalletServer :: writeDataToDB ( shareG2_name , sShareG2 . data ( ) ) ; } return result ; }
static int putint ( jas_stream_t * out , int sgnd , int prec , long val ) { int n ; int c ; bool s ; ulong tmp ; assert ( ( ! sgnd && prec >= 1 ) || ( sgnd && prec >= 2 ) ) ; if ( sgnd ) { val = encode_twos_comp ( val , prec ) ; } assert ( val >= 0 ) ; val &= ( 1 < < prec ) - 1 ; n = ( prec + 7 ) / 8 ; while ( -- n >= 0 ) { c = ( val > > ( n * 8 ) ) & 0xff ; if ( jas_stream_putc ( out , c ) != c ) return - 1 ; } return 0 ; }
static int flock_lock_inode_wait ( struct inode * inode , struct file_lock * fl ) { int error ; might_sleep ( ) ; for ( ; ; ) { error = flock_lock_inode ( inode , fl ) ; if ( error != FILE_LOCK_DEFERRED ) break ; error = wait_event_interruptible ( fl -> fl_wait , ! fl -> fl_blocker ) ; if ( error ) break ; } locks_delete_block ( fl ) ; return error ; }
ConnectSOCKS4 ( PRFileDesc * fd , const PRNetAddr * addr , PRIntervalTime timeout ) { NS_ENSURE_TRUE ( fd , NS_ERROR_NOT_INITIALIZED ) ; NS_ENSURE_TRUE ( addr , NS_ERROR_NOT_INITIALIZED ) ; unsigned char request [ 12 ] ; int request_len = 0 ; int write_len ; unsigned char response [ 10 ] ; int response_len = 0 ; char * ip = nsnull ; request [ 0 ] = 0x04 ; request [ 1 ] = 0x01 ; PRInt32 destPort = PR_ntohs ( PR_NetAddrInetPort ( addr ) ) ; request [ 2 ] = ( unsigned char ) ( destPort > > 8 ) ; request [ 3 ] = ( unsigned char ) destPort ; request [ 8 ] = 'M' ; request [ 9 ] = 'O' ; request [ 10 ] = 'Z' ; request [ 11 ] = 0x00 ; request_len = 12 ; nsSOCKSSocketInfo * info = ( nsSOCKSSocketInfo * ) fd -> secret ; if ( info -> Flags ( ) & nsISocketProvider :: PROXY_RESOLVES_HOST ) { LOGDEBUG ( ( "using server to resolve hostnames rather than resolving it first\n" ) ) ; const nsCString & destHost = info -> DestinationHost ( ) ; LOGDEBUG ( ( "host:port -> %s:%li\n" , destHost . get ( ) , destPort ) ) ; request [ 4 ] = 0 ; request [ 5 ] = 0 ; request [ 6 ] = 0 ; request [ 7 ] = 1 ; write_len = PR_Send ( fd , request , request_len , 0 , timeout ) ; if ( write_len != request_len ) { LOGERROR ( ( "PR_Send() failed. Wrote: %d bytes; Expected: %d." , write_len , request_len ) ) ; return NS_ERROR_FAILURE ; } int host_len = destHost . Length ( ) + 1 ; write_len = PR_Send ( fd , destHost . get ( ) , host_len , 0 , timeout ) ; if ( write_len != host_len ) { LOGERROR ( ( "PR_Send() failed. Wrote: %d bytes; Expected: %d." , write_len , host_len ) ) ; return NS_ERROR_FAILURE ; } request_len = 0 ; } else if ( PR_NetAddrFamily ( addr ) == PR_AF_INET ) { ip = ( char * ) ( & addr -> inet . ip ) ; request [ 4 ] = * ip ++ ; request [ 5 ] = * ip ++ ; request [ 6 ] = * ip ++ ; request [ 7 ] = * ip ++ ; } else if ( PR_NetAddrFamily ( addr ) == PR_AF_INET6 ) { if ( PR_IsNetAddrType ( addr , PR_IpAddrV4Mapped ) ) { ip = ( char * ) ( & addr -> ipv6 . ip . pr_s6_addr [ 12 ] ) ; request [ 4 ] = * ip ++ ; request [ 5 ] = * ip ++ ; request [ 6 ] = * ip ++ ; request [ 7 ] = * ip ++ ; } else { LOGERROR ( ( "IPv6 is not supported in SOCKS 4." ) ) ; return NS_ERROR_FAILURE ; } } else { LOGERROR ( ( "Don't know what kind of IP address this is." ) ) ; return NS_ERROR_FAILURE ; } if ( request_len > 0 ) { write_len = PR_Send ( fd , request , request_len , 0 , timeout ) ; if ( write_len != request_len ) { LOGERROR ( ( "PR_Send() failed. Wrote: %d bytes; Expected: %d." , write_len , request_len ) ) ; return NS_ERROR_FAILURE ; } } response_len = 8 ; response_len = PR_Recv ( fd , response , response_len , 0 , timeout ) ; if ( response_len <= 0 ) { LOGERROR ( ( "PR_Recv() failed. response_len = %d." , response_len ) ) ; return NS_ERROR_FAILURE ; } if ( ( response [ 0 ] != 0x00 ) && ( response [ 0 ] != 0x04 ) ) { LOGERROR ( ( "Not a SOCKS 4 reply. Expected: 0; received: %x." , response [ 0 ] ) ) ; return NS_ERROR_FAILURE ; } if ( response [ 1 ] != 0x5A ) { LOGERROR ( ( "Connection request refused. Expected: 90; received: %d." , response [ 1 ] ) ) ; return NS_ERROR_FAILURE ; } return NS_OK ; }
BUILTIN ( ListFormatConstructor ) { HandleScope scope ( isolate ) ; if ( args . new_target ( ) -> IsUndefined ( isolate ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( MessageTemplate :: kConstructorNotFunction , isolate -> factory ( ) -> NewStringFromStaticChars ( "Intl.ListFormat" ) ) ) ; } Handle < JSFunction > target = args . target ( ) ; Handle < JSReceiver > new_target = Handle < JSReceiver > :: cast ( args . new_target ( ) ) ; Handle < JSObject > result ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , result , JSObject :: New ( target , new_target ) ) ; Handle < JSListFormat > format = Handle < JSListFormat > :: cast ( result ) ; format -> set_flags ( 0 ) ; Handle < Object > locales = args . atOrUndefined ( isolate , 1 ) ; Handle < Object > options = args . atOrUndefined ( isolate , 2 ) ; RETURN_RESULT_OR_FAILURE ( isolate , JSListFormat :: InitializeListFormat ( isolate , format , locales , options ) ) ; }
const uint8_t * nsZipArchive :: GetData ( nsZipItem * aItem ) { PR_ASSERT ( aItem ) ; MOZ_WIN_MEM_TRY_BEGIN uint32_t offset = GetDataOffset ( aItem ) ; if ( ! offset || offset + aItem -> Size ( ) > mFd -> mLen ) return nullptr ; return mFd -> mFileData + offset ; MOZ_WIN_MEM_TRY_CATCH ( return nullptr ) }
int main ( void ) { FILE * f ; char * tmpname ; f = xfmkstemp ( & tmpname , NULL ) ; unlink ( tmpname ) ; free ( tmpname ) ; fclose ( f ) ; return EXIT_FAILURE ; }
status_t MPEG4Source :: parseSampleAuxiliaryInformationOffsets ( off64_t offset , off64_t size ) { ALOGV ( "parseSampleAuxiliaryInformationOffsets" ) ; uint8_t version ; if ( mDataSource -> readAt ( offset , & version , sizeof ( version ) ) != 1 ) { return ERROR_IO ; } offset ++ ; uint32_t flags ; if ( ! mDataSource -> getUInt24 ( offset , & flags ) ) { return ERROR_IO ; } offset += 3 ; uint32_t entrycount ; if ( ! mDataSource -> getUInt32 ( offset , & entrycount ) ) { return ERROR_IO ; } offset += 4 ; if ( entrycount > mCurrentSampleInfoOffsetsAllocSize ) { mCurrentSampleInfoOffsets = ( uint64_t * ) realloc ( mCurrentSampleInfoOffsets , entrycount * 8 ) ; mCurrentSampleInfoOffsetsAllocSize = entrycount ; } mCurrentSampleInfoOffsetCount = entrycount ; for ( size_t i = 0 ; i < entrycount ; i ++ ) { if ( version == 0 ) { uint32_t tmp ; if ( ! mDataSource -> getUInt32 ( offset , & tmp ) ) { return ERROR_IO ; } mCurrentSampleInfoOffsets [ i ] = tmp ; offset += 4 ; } else { uint64_t tmp ; if ( ! mDataSource -> getUInt64 ( offset , & tmp ) ) { return ERROR_IO ; } mCurrentSampleInfoOffsets [ i ] = tmp ; offset += 8 ; } } off64_t drmoffset = mCurrentSampleInfoOffsets [ 0 ] ; drmoffset += mCurrentMoofOffset ; int ivlength ; CHECK ( mFormat -> findInt32 ( kKeyCryptoDefaultIVSize , & ivlength ) ) ; if ( ivlength != 0 && ivlength != 8 && ivlength != 16 ) { ALOGW ( "unsupported IV length: %d" , ivlength ) ; return ERROR_MALFORMED ; } for ( size_t i = 0 ; i < mCurrentSampleInfoCount ; i ++ ) { if ( i >= mCurrentSamples . size ( ) ) { ALOGW ( "too few samples" ) ; break ; } Sample * smpl = & mCurrentSamples . editItemAt ( i ) ; memset ( smpl -> iv , 0 , 16 ) ; if ( mDataSource -> readAt ( drmoffset , smpl -> iv , ivlength ) != ivlength ) { return ERROR_IO ; } drmoffset += ivlength ; int32_t smplinfosize = mCurrentDefaultSampleInfoSize ; if ( smplinfosize == 0 ) { smplinfosize = mCurrentSampleInfoSizes [ i ] ; } if ( smplinfosize > ivlength ) { uint16_t numsubsamples ; if ( ! mDataSource -> getUInt16 ( drmoffset , & numsubsamples ) ) { return ERROR_IO ; } drmoffset += 2 ; for ( size_t j = 0 ; j < numsubsamples ; j ++ ) { uint16_t numclear ; uint32_t numencrypted ; if ( ! mDataSource -> getUInt16 ( drmoffset , & numclear ) ) { return ERROR_IO ; } drmoffset += 2 ; if ( ! mDataSource -> getUInt32 ( drmoffset , & numencrypted ) ) { return ERROR_IO ; } drmoffset += 4 ; smpl -> clearsizes . add ( numclear ) ; smpl -> encryptedsizes . add ( numencrypted ) ; } } else { smpl -> clearsizes . add ( 0 ) ; smpl -> encryptedsizes . add ( smpl -> size ) ; } } return OK ; }
crm_client_new ( qb_ipcs_connection_t * c , uid_t uid_client , gid_t gid_client ) { static uid_t uid_server = 0 ; static gid_t gid_cluster = 0 ; crm_client_t * client = NULL ; CRM_LOG_ASSERT ( c ) ; if ( c == NULL ) { return NULL ; } if ( gid_cluster == 0 ) { uid_server = getuid ( ) ; if ( crm_user_lookup ( CRM_DAEMON_USER , NULL , & gid_cluster ) < 0 ) { static bool have_error = FALSE ; if ( have_error == FALSE ) { crm_warn ( "Could not find group for user %s" , CRM_DAEMON_USER ) ; have_error = TRUE ; } } } if ( gid_cluster != 0 && gid_client != 0 ) { uid_t best_uid = - 1 ; if ( uid_client == 0 || uid_server == 0 ) { best_uid = QB_MAX ( uid_client , uid_server ) ; crm_trace ( "Allowing user %u to clean up after disconnect" , best_uid ) ; } crm_trace ( "Giving access to group %u" , gid_cluster ) ; qb_ipcs_connection_auth_set ( c , best_uid , gid_cluster , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) ; } crm_client_init ( ) ; client = calloc ( 1 , sizeof ( crm_client_t ) ) ; client -> ipcs = c ; client -> kind = CRM_CLIENT_IPC ; client -> pid = crm_ipcs_client_pid ( c ) ; client -> id = crm_generate_uuid ( ) ; crm_debug ( "Connecting %p for uid=%d gid=%d pid=%u id=%s" , c , uid_client , gid_client , client -> pid , client -> id ) ; #if ENABLE_ACL client -> user = uid2username ( uid_client ) ; #endif g_hash_table_insert ( client_connections , c , client ) ; return client ; }
_cupsGlobalLock ( void ) { #ifdef HAVE_PTHREAD_H pthread_mutex_lock ( & cups_global_mutex ) ; #elif defined(WIN32) EnterCriticalSection ( & cups_global_mutex . m_criticalSection ) ; #endif /* HAVE_PTHREAD_H */ }
_cairo_d2d_blend_temp_surface ( cairo_d2d_surface_t * surf , cairo_operator_t op , ID2D1RenderTarget * rt , cairo_clip_t * clip , const cairo_rectangle_int_t * bounds = NULL ) { int numPaths = 0 ; if ( clip ) { cairo_clip_path_t * path = clip -> path ; while ( path ) { numPaths ++ ; path = path -> prev ; } cairo_clip_path_t * * paths = new cairo_clip_path_t * [ numPaths ] ; numPaths = 0 ; path = clip -> path ; while ( path ) { paths [ numPaths ++ ] = path ; path = path -> prev ; } for ( int i = numPaths - 1 ; i >= 0 ; i -- ) { if ( paths [ i ] -> flags & CAIRO_CLIP_PATH_IS_BOX ) { rt -> PopAxisAlignedClip ( ) ; } else { rt -> PopLayer ( ) ; } } delete [ ] paths ; } rt -> EndDraw ( ) ; HRESULT hr ; RefPtr < ID3D10Texture2D > srcTexture = _cairo_d2d_get_buffer_texture ( surf ) ; RefPtr < ID3D10Texture2D > dstTexture ; surf -> surface -> QueryInterface ( & dstTexture ) ; ID3D10Device * device = surf -> device -> mD3D10Device ; if ( ! surf -> buffer_rt_view ) { hr = device -> CreateRenderTargetView ( dstTexture , NULL , & surf -> buffer_rt_view ) ; if ( FAILED ( hr ) ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } } if ( ! surf -> buffer_sr_view ) { hr = device -> CreateShaderResourceView ( srcTexture , NULL , & surf -> buffer_sr_view ) ; if ( FAILED ( hr ) ) { return CAIRO_INT_STATUS_UNSUPPORTED ; } } cairo_int_status_t status ; status = _cairo_d2d_set_operator ( surf -> device , op ) ; if ( unlikely ( status ) ) { return status ; } D3D10_TEXTURE2D_DESC tDesc ; dstTexture -> GetDesc ( & tDesc ) ; D3D10_VIEWPORT vp ; vp . Height = tDesc . Height ; vp . MinDepth = 0 ; vp . MaxDepth = 1.0 ; vp . TopLeftX = 0 ; vp . TopLeftY = 0 ; vp . Width = tDesc . Width ; device -> RSSetViewports ( 1 , & vp ) ; ID3D10Effect * effect = surf -> device -> mSampleEffect ; ID3D10RenderTargetView * rtViewPtr = surf -> buffer_rt_view ; device -> OMSetRenderTargets ( 1 , & rtViewPtr , 0 ) ; ID3D10EffectVectorVariable * quadDesc = effect -> GetVariableByName ( "QuadDesc" ) -> AsVector ( ) ; ID3D10EffectVectorVariable * texCoords = effect -> GetVariableByName ( "TexCoords" ) -> AsVector ( ) ; float quadDescVal [ ] = { - 1.0f , 1.0f , 2.0f , - 2.0f } ; float texCoordsVal [ ] = { 0.0 , 0.0 , 1.0f , 1.0f } ; if ( bounds && _cairo_operator_bounded_by_mask ( op ) ) { quadDescVal [ 0 ] = - 1.0f + ( ( float ) bounds -> x / ( float ) tDesc . Width ) * 2.0f ; quadDescVal [ 1 ] = 1.0f - ( ( float ) bounds -> y / ( float ) tDesc . Height ) * 2.0f ; quadDescVal [ 2 ] = ( ( float ) bounds -> width / ( float ) tDesc . Width ) * 2.0f ; quadDescVal [ 3 ] = - ( ( float ) bounds -> height / ( float ) tDesc . Height ) * 2.0f ; texCoordsVal [ 0 ] = ( float ) bounds -> x / ( float ) tDesc . Width ; texCoordsVal [ 1 ] = ( float ) bounds -> y / ( float ) tDesc . Height ; texCoordsVal [ 2 ] = ( float ) bounds -> width / ( float ) tDesc . Width ; texCoordsVal [ 3 ] = ( float ) bounds -> height / ( float ) tDesc . Height ; } quadDesc -> SetFloatVector ( quadDescVal ) ; texCoords -> SetFloatVector ( texCoordsVal ) ; _cairo_d2d_setup_for_blend ( surf -> device ) ; ID3D10EffectTechnique * technique = effect -> GetTechniqueByName ( "SampleTexture" ) ; technique -> GetPassByIndex ( 0 ) -> Apply ( 0 ) ; ID3D10ShaderResourceView * srViewPtr = surf -> buffer_sr_view ; device -> PSSetShaderResources ( 0 , 1 , & srViewPtr ) ; device -> Draw ( 4 , 0 ) ; #ifdef DEBUG srViewPtr = NULL ; device -> PSSetShaderResources ( 0 , 1 , & srViewPtr ) ; rtViewPtr = NULL ; device -> OMSetRenderTargets ( 1 , & rtViewPtr , 0 ) ; #endif return CAIRO_INT_STATUS_SUCCESS ; }
static void GenerateTailCallToReturnedCode ( MacroAssembler * masm , Runtime :: FunctionId function_id ) { { FrameScope scope ( masm , StackFrame :: INTERNAL ) ; __ SmiTag ( a0 ) ; __ Push ( a0 , a1 , a3 , a1 ) ; __ CallRuntime ( function_id , 1 ) ; __ Pop ( a0 , a1 , a3 ) ; __ SmiUntag ( a0 ) ; } static_assert ( kJavaScriptCallCodeStartRegister == a2 , "ABI mismatch" ) ; __ Daddu ( a2 , v0 , Operand ( Code :: kHeaderSize - kHeapObjectTag ) ) ; __ Jump ( a2 ) ; }
Node * WasmGraphBuilder :: CallDirect ( uint32_t index , Node * * args , Node * * * rets , wasm :: WasmCodePosition position ) { DCHECK_NULL ( args [ 0 ] ) ; wasm :: FunctionSig * sig = env_ -> module -> functions [ index ] . sig ; if ( env_ && index < env_ -> module -> num_imported_functions ) { return BuildImportWasmCall ( sig , args , rets , position , index ) ; } Address code = static_cast < Address > ( index ) ; args [ 0 ] = mcgraph ( ) -> RelocatableIntPtrConstant ( code , RelocInfo :: WASM_CALL ) ; return BuildWasmCall ( sig , args , rets , position , nullptr , kNoRetpoline ) ; }
int RegExpMacroAssemblerMIPS :: CheckStackGuardState ( Address * return_address , Code * re_code , Address re_frame ) { return NativeRegExpMacroAssembler :: CheckStackGuardState ( frame_entry < Isolate * > ( re_frame , kIsolate ) , frame_entry < int > ( re_frame , kStartIndex ) , frame_entry < int > ( re_frame , kDirectCall ) == 1 , return_address , re_code , frame_entry_address < String * > ( re_frame , kInputString ) , frame_entry_address < const byte * > ( re_frame , kInputStart ) , frame_entry_address < const byte * > ( re_frame , kInputEnd ) ) ; }
JS_IterateCompartments ( JSRuntime * rt , void * data , JSIterateCompartmentCallback compartmentCallback ) { MOZ_ASSERT ( ! rt -> isHeapBusy ( ) ) ; AutoTraceSession session ( rt ) ; for ( CompartmentsIter c ( rt , WithAtoms ) ; ! c . done ( ) ; c . next ( ) ) ( * compartmentCallback ) ( rt , data , c ) ; }
void RedundantStoreFinder :: Find ( ) { Visit ( jsgraph ( ) -> graph ( ) -> end ( ) ) ; while ( ! revisit_ . empty ( ) ) { Node * next = revisit_ . top ( ) ; revisit_ . pop ( ) ; DCHECK_LT ( next -> id ( ) , in_revisit_ . size ( ) ) ; in_revisit_ [ next -> id ( ) ] = false ; Visit ( next ) ; } #ifdef DEBUG AllNodes all ( temp_zone ( ) , jsgraph ( ) -> graph ( ) ) ; for ( Node * node : all . reachable ) { if ( node -> op ( ) -> opcode ( ) == IrOpcode :: kStoreField ) { DCHECK_EXTRA ( HasBeenVisited ( node ) , "#%d:%s" , node -> id ( ) , node -> op ( ) -> mnemonic ( ) ) ; } } #endif }
already_AddRefed < Document > DOMParser :: ParseFromString ( const nsAString & aStr , SupportedType aType , ErrorResult & aRv ) { if ( aType == SupportedType :: Text_html ) { nsCOMPtr < Document > document = SetUpDocument ( DocumentFlavorHTML , aRv ) ; if ( NS_WARN_IF ( aRv . Failed ( ) ) ) { return nullptr ; } if ( mForceEnableXULXBL ) { document -> ForceEnableXULXBL ( ) ; } nsresult rv = nsContentUtils :: ParseDocumentHTML ( aStr , document , false ) ; if ( NS_WARN_IF ( NS_FAILED ( rv ) ) ) { aRv . Throw ( rv ) ; return nullptr ; } return document . forget ( ) ; } nsAutoCString utf8str ; if ( ! AppendUTF16toUTF8 ( aStr , utf8str , mozilla :: fallible ) ) { aRv . Throw ( NS_ERROR_OUT_OF_MEMORY ) ; return nullptr ; } nsCOMPtr < nsIInputStream > stream ; nsresult rv = NS_NewByteInputStream ( getter_AddRefs ( stream ) , utf8str . get ( ) , utf8str . Length ( ) , NS_ASSIGNMENT_DEPEND ) ; if ( NS_WARN_IF ( NS_FAILED ( rv ) ) ) { aRv . Throw ( rv ) ; return nullptr ; } return ParseFromStream ( stream , NS_LITERAL_STRING ( "UTF-8" ) , utf8str . Length ( ) , aType , aRv ) ; }
XML_Parse ( XML_Parser parser , const char * s , int len , int isFinal ) { switch ( ps_parsing ) { case XML_SUSPENDED : errorCode = XML_ERROR_SUSPENDED ; return XML_STATUS_ERROR ; case XML_FINISHED : errorCode = XML_ERROR_FINISHED ; return XML_STATUS_ERROR ; case XML_INITIALIZED : if ( parentParser == NULL && ! startParsing ( parser ) ) { errorCode = XML_ERROR_NO_MEMORY ; return XML_STATUS_ERROR ; } default : ps_parsing = XML_PARSING ; } if ( len == 0 ) { ps_finalBuffer = ( XML_Bool ) isFinal ; if ( ! isFinal ) return XML_STATUS_OK ; positionPtr = bufferPtr ; parseEndPtr = bufferEnd ; errorCode = processor ( parser , bufferPtr , parseEndPtr , & bufferPtr ) ; if ( errorCode == XML_ERROR_NONE ) { switch ( ps_parsing ) { case XML_SUSPENDED : XmlUpdatePosition ( encoding , positionPtr , bufferPtr , & position ) ; positionPtr = bufferPtr ; return XML_STATUS_SUSPENDED ; case XML_INITIALIZED : case XML_PARSING : ps_parsing = XML_FINISHED ; default : return XML_STATUS_OK ; } } eventEndPtr = eventPtr ; processor = errorProcessor ; return XML_STATUS_ERROR ; } #ifndef XML_CONTEXT_BYTES else if ( bufferPtr == bufferEnd ) { const char * end ; int nLeftOver ; enum XML_Error result ; parseEndByteIndex += len ; positionPtr = s ; ps_finalBuffer = ( XML_Bool ) isFinal ; errorCode = processor ( parser , s , parseEndPtr = s + len , & end ) ; if ( errorCode != XML_ERROR_NONE ) { eventEndPtr = eventPtr ; processor = errorProcessor ; return XML_STATUS_ERROR ; } else { switch ( ps_parsing ) { case XML_SUSPENDED : result = XML_STATUS_SUSPENDED ; break ; case XML_INITIALIZED : case XML_PARSING : if ( isFinal ) { ps_parsing = XML_FINISHED ; return XML_STATUS_OK ; } default : result = XML_STATUS_OK ; } } XmlUpdatePosition ( encoding , positionPtr , end , & position ) ; nLeftOver = s + len - end ; if ( nLeftOver ) { if ( buffer == NULL || nLeftOver > bufferLim - buffer ) { char * temp ; temp = ( buffer == NULL ? ( char * ) MALLOC ( len * 2 ) : ( char * ) REALLOC ( buffer , len * 2 ) ) ; if ( temp == NULL ) { errorCode = XML_ERROR_NO_MEMORY ; eventPtr = eventEndPtr = NULL ; processor = errorProcessor ; return XML_STATUS_ERROR ; } buffer = temp ; bufferLim = buffer + len * 2 ; } memcpy ( buffer , end , nLeftOver ) ; } bufferPtr = buffer ; bufferEnd = buffer + nLeftOver ; positionPtr = bufferPtr ; parseEndPtr = bufferEnd ; eventPtr = bufferPtr ; eventEndPtr = bufferPtr ; return result ; } #endif /* not defined XML_CONTEXT_BYTES */ else { void * buff = XML_GetBuffer ( parser , len ) ; if ( buff == NULL ) return XML_STATUS_ERROR ; else { memcpy ( buff , s , len ) ; return XML_ParseBuffer ( parser , len , isFinal ) ; } } }
TF_BUILTIN ( StringPrototypeToLowerCaseIntl , IntlBuiltinsAssembler ) { Node * const maybe_string = Parameter ( Descriptor :: kReceiver ) ; Node * const context = Parameter ( Descriptor :: kContext ) ; Node * const string = ToThisString ( context , maybe_string , "String.prototype.toLowerCase" ) ; Return ( CallBuiltin ( Builtins :: kStringToLowerCaseIntl , context , string ) ) ; }
int snd_card_disconnect ( struct snd_card * card ) { struct snd_monitor_file * mfile ; if ( ! card ) return - EINVAL ; spin_lock ( & card -> files_lock ) ; if ( card -> shutdown ) { spin_unlock ( & card -> files_lock ) ; return 0 ; } card -> shutdown = 1 ; spin_unlock ( & card -> files_lock ) ; mutex_lock ( & snd_card_mutex ) ; snd_cards [ card -> number ] = NULL ; clear_bit ( card -> number , snd_cards_lock ) ; mutex_unlock ( & snd_card_mutex ) ; spin_lock ( & card -> files_lock ) ; list_for_each_entry ( mfile , & card -> files_list , list ) { mfile -> disconnected_f_op = mfile -> file -> f_op ; spin_lock ( & shutdown_lock ) ; list_add ( & mfile -> shutdown_list , & shutdown_files ) ; spin_unlock ( & shutdown_lock ) ; mfile -> file -> f_op = & snd_shutdown_f_ops ; fops_get ( mfile -> file -> f_op ) ; } spin_unlock ( & card -> files_lock ) ; #if IS_ENABLED(CONFIG_SND_MIXER_OSS) if ( snd_mixer_oss_notify_callback ) snd_mixer_oss_notify_callback ( card , SND_MIXER_OSS_NOTIFY_DISCONNECT ) ; #endif snd_device_disconnect_all ( card ) ; snd_info_card_disconnect ( card ) ; if ( card -> registered ) { device_del ( & card -> card_dev ) ; card -> registered = false ; } #ifdef CONFIG_PM wake_up ( & card -> power_sleep ) ; #endif return 0 ; }
ProcessFile ( JSContext * cx , JS :: Handle < JSObject * > obj , const char * filename , FILE * file , bool forceTTY ) { JS :: RootedScript script ( cx ) ; JS :: RootedValue result ( cx ) ; int lineno , startline ; bool ok , hitEOF ; char * bufp , buffer [ 4096 ] ; JSString * str ; if ( forceTTY ) { file = stdin ; } else if ( ! isatty ( fileno ( file ) ) ) { int ch = fgetc ( file ) ; if ( ch == '#' ) { while ( ( ch = fgetc ( file ) ) != EOF ) { if ( ch == '\n' || ch == '\r' ) break ; } } ungetc ( ch , file ) ; DoBeginRequest ( cx ) ; JS :: CompileOptions options ( cx ) ; options . setUTF8 ( true ) . setFileAndLine ( filename , 1 ) ; script = JS :: Compile ( cx , obj , options , file ) ; if ( script && ! compileOnly ) ( void ) JS_ExecuteScript ( cx , obj , script , & result ) ; DoEndRequest ( cx ) ; return ; } lineno = 1 ; hitEOF = false ; do { bufp = buffer ; * bufp = '\0' ; startline = lineno ; do { if ( ! GetLine ( cx , bufp , file , startline == lineno ? "js> " : "" ) ) { hitEOF = true ; break ; } bufp += strlen ( bufp ) ; lineno ++ ; } while ( ! JS_BufferIsCompilableUnit ( cx , obj , buffer , strlen ( buffer ) ) ) ; DoBeginRequest ( cx ) ; JS_ClearPendingException ( cx ) ; JS :: CompileOptions options ( cx ) ; options . setFileAndLine ( "typein" , startline ) ; script = JS_CompileScript ( cx , obj , buffer , strlen ( buffer ) , options ) ; if ( script ) { JSErrorReporter older ; if ( ! compileOnly ) { ok = JS_ExecuteScript ( cx , obj , script , & result ) ; if ( ok && result != JSVAL_VOID ) { older = JS_SetErrorReporter ( cx , nullptr ) ; str = ToString ( cx , result ) ; JS_SetErrorReporter ( cx , older ) ; JSAutoByteString bytes ; if ( str && bytes . encodeLatin1 ( cx , str ) ) fprintf ( gOutFile , "%s\n" , bytes . ptr ( ) ) ; else ok = false ; } } } DoEndRequest ( cx ) ; } while ( ! hitEOF && ! gQuitting ) ; fprintf ( gOutFile , "\n" ) ; }
pci_vtrnd_notify ( void * vsc , struct vqueue_info * vq ) { struct iovec iov ; struct pci_vtrnd_softc * sc ; int len ; uint16_t idx ; sc = vsc ; if ( sc -> vrsc_fd < 0 ) { vq_endchains ( vq , 0 ) ; return ; } while ( vq_has_descs ( vq ) ) { vq_getchain ( vq , & idx , & iov , 1 , NULL ) ; len = ( int ) read ( sc -> vrsc_fd , iov . iov_base , iov . iov_len ) ; DPRINTF ( ( "vtrnd: vtrnd_notify(): %d\r\n" , len ) ) ; assert ( len > 0 ) ; vq_relchain ( vq , idx , ( uint32_t ) len ) ; } vq_endchains ( vq , 1 ) ; }
tt_cmap10_char_next ( TT_CMap cmap , FT_UInt32 * pchar_code ) { FT_Byte * table = cmap -> data ; FT_UInt32 char_code = * pchar_code + 1 ; FT_UInt gindex = 0 ; FT_Byte * p = table + 12 ; FT_UInt32 start = TT_NEXT_ULONG ( p ) ; FT_UInt32 count = TT_NEXT_ULONG ( p ) ; FT_UInt32 idx ; if ( char_code < start ) char_code = start ; idx = ( FT_UInt32 ) ( char_code - start ) ; p += 2 * idx ; for ( ; idx < count ; idx ++ ) { gindex = TT_NEXT_USHORT ( p ) ; if ( gindex != 0 ) break ; char_code ++ ; } * pchar_code = char_code ; return gindex ; }
int read_xattrs_from_disk ( int fd , struct squashfs_super_block * sBlk , int flag , long long * table_start ) { int res , bytes , i , indexes , index_bytes , ids ; long long * index , start , end ; struct squashfs_xattr_table id_table ; TRACE ( "read_xattrs_from_disk\n" ) ; if ( sBlk -> xattr_id_table_start == SQUASHFS_INVALID_BLK ) return SQUASHFS_INVALID_BLK ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start , sizeof ( id_table ) , & id_table ) ; if ( res == 0 ) return 0 ; SQUASHFS_INSWAP_XATTR_TABLE ( & id_table ) ; if ( flag ) { * table_start = id_table . xattr_table_start ; return id_table . xattr_ids ; } ids = id_table . xattr_ids ; xattr_table_start = id_table . xattr_table_start ; index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ids ) ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) , index_bytes , index ) ; if ( res == 0 ) goto failed1 ; SQUASHFS_INSWAP_LONG_LONGS ( index , indexes ) ; bytes = SQUASHFS_XATTR_BYTES ( ids ) ; xattr_ids = malloc ( bytes ) ; if ( xattr_ids == NULL ) MEM_ERROR ( ) ; for ( i = 0 ; i < indexes ; i ++ ) { int expected = ( i + 1 ) != indexes ? SQUASHFS_METADATA_SIZE : bytes & ( SQUASHFS_METADATA_SIZE - 1 ) ; int length = read_block ( fd , index [ i ] , NULL , expected , ( ( unsigned char * ) xattr_ids ) + ( i * SQUASHFS_METADATA_SIZE ) ) ; TRACE ( "Read xattr id table block %d, from 0x%llx, length " "%d\n" , i , index [ i ] , length ) ; if ( length == 0 ) { ERROR ( "Failed to read xattr id table block %d, " "from 0x%llx, length %d\n" , i , index [ i ] , length ) ; goto failed2 ; } } start = xattr_table_start ; end = index [ 0 ] ; for ( i = 0 ; start < end ; i ++ ) { int length ; xattrs = realloc ( xattrs , ( i + 1 ) * SQUASHFS_METADATA_SIZE ) ; if ( xattrs == NULL ) MEM_ERROR ( ) ; save_xattr_block ( start , i * SQUASHFS_METADATA_SIZE ) ; length = read_block ( fd , start , & start , 0 , ( ( unsigned char * ) xattrs ) + ( i * SQUASHFS_METADATA_SIZE ) ) ; TRACE ( "Read xattr block %d, length %d\n" , i , length ) ; if ( length == 0 ) { ERROR ( "Failed to read xattr block %d\n" , i ) ; goto failed3 ; } if ( start != end && length != SQUASHFS_METADATA_SIZE ) { ERROR ( "Xattr block %d should be %d bytes in length, " "it is %d bytes\n" , i , SQUASHFS_METADATA_SIZE , length ) ; goto failed3 ; } } for ( i = 0 ; i < ids ; i ++ ) SQUASHFS_INSWAP_XATTR_ID ( & xattr_ids [ i ] ) ; free ( index ) ; return ids ; failed3 : free ( xattrs ) ; failed2 : free ( xattr_ids ) ; failed1 : free ( index ) ; return 0 ; }
MaybeHandle < HeapObject > Enumerate ( Isolate * isolate , Handle < JSReceiver > receiver ) { JSObject :: MakePrototypesFast ( receiver , kStartAtReceiver , isolate ) ; FastKeyAccumulator accumulator ( isolate , receiver , KeyCollectionMode :: kIncludePrototypes , ENUMERABLE_STRINGS , true ) ; if ( ! accumulator . is_receiver_simple_enum ( ) ) { Handle < FixedArray > keys ; ASSIGN_RETURN_ON_EXCEPTION ( isolate , keys , accumulator . GetKeys ( GetKeysConversion :: kConvertToString ) , HeapObject ) ; if ( ! accumulator . is_receiver_simple_enum ( ) ) return keys ; } DCHECK ( ! receiver -> IsJSModuleNamespace ( ) ) ; return handle ( receiver -> map ( ) , isolate ) ; }
Handle < Context > Factory :: NewDebugEvaluateContext ( Handle < Context > previous , Handle < ScopeInfo > scope_info , Handle < JSReceiver > extension , Handle < Context > wrapped , Handle < StringSet > whitelist ) { STATIC_ASSERT ( Context :: WHITE_LIST_INDEX == Context :: MIN_CONTEXT_SLOTS + 1 ) ; DCHECK ( scope_info -> IsDebugEvaluateScope ( ) ) ; Handle < HeapObject > ext = extension . is_null ( ) ? Handle < HeapObject > :: cast ( the_hole_value ( ) ) : Handle < HeapObject > :: cast ( extension ) ; Handle < Context > c = NewFixedArrayWithMap < Context > ( Heap :: kDebugEvaluateContextMapRootIndex , Context :: MIN_CONTEXT_SLOTS + 2 ) ; c -> set_scope_info ( * scope_info ) ; c -> set_previous ( * previous ) ; c -> set_native_context ( previous -> native_context ( ) ) ; c -> set_extension ( * ext ) ; if ( ! wrapped . is_null ( ) ) c -> set ( Context :: WRAPPED_CONTEXT_INDEX , * wrapped ) ; if ( ! whitelist . is_null ( ) ) c -> set ( Context :: WHITE_LIST_INDEX , * whitelist ) ; return c ; }
CAMLprim value caml_alloc_dummy ( value size ) { mlsize_t wosize = Int_val ( size ) ; if ( wosize == 0 ) return Atom ( 0 ) ; return caml_alloc ( wosize , 0 ) ; }
void UpdateLog :: Init ( NS_tchar * sourcePath , const NS_tchar * fileName , const NS_tchar * alternateFileName , bool append ) { if ( logFP ) return ; this -> sourcePath = sourcePath ; NS_tchar logFile [ MAXPATHLEN ] ; NS_tsnprintf ( logFile , sizeof ( logFile ) / sizeof ( logFile [ 0 ] ) , NS_T ( "%s/%s" ) , sourcePath , fileName ) ; if ( alternateFileName && NS_taccess ( logFile , F_OK ) ) { NS_tsnprintf ( logFile , sizeof ( logFile ) / sizeof ( logFile [ 0 ] ) , NS_T ( "%s/%s" ) , sourcePath , alternateFileName ) ; } logFP = NS_tfopen ( logFile , append ? NS_T ( "a" ) : NS_T ( "w" ) ) ; }
void BytecodeGraphBuilder :: VisitLdaKeyedProperty ( ) { PrepareEagerCheckpoint ( ) ; Node * key = environment ( ) -> LookupAccumulator ( ) ; Node * object = environment ( ) -> LookupRegister ( bytecode_iterator ( ) . GetRegisterOperand ( 0 ) ) ; VectorSlotPair feedback = CreateVectorSlotPair ( bytecode_iterator ( ) . GetIndexOperand ( 1 ) ) ; const Operator * op = javascript ( ) -> LoadProperty ( feedback ) ; JSTypeHintLowering :: LoweringResult lowering = TryBuildSimplifiedLoadKeyed ( op , object , key , feedback . slot ( ) ) ; if ( lowering . IsExit ( ) ) return ; Node * node = nullptr ; if ( lowering . IsSideEffectFree ( ) ) { node = lowering . value ( ) ; } else { DCHECK ( ! lowering . Changed ( ) ) ; node = NewNode ( op , object , key ) ; } environment ( ) -> BindAccumulator ( node , Environment :: kAttachFrameState ) ; }
static int tomoyo_mount_acl ( struct tomoyo_request_info * r , char * dev_name , struct path * dir , char * type , unsigned long flags ) { struct path path ; struct file_system_type * fstype = NULL ; const char * requested_type = NULL ; const char * requested_dir_name = NULL ; const char * requested_dev_name = NULL ; struct tomoyo_path_info rtype ; struct tomoyo_path_info rdev ; struct tomoyo_path_info rdir ; int need_dev = 0 ; int error = - ENOMEM ; requested_type = tomoyo_encode ( type ) ; if ( ! requested_type ) goto out ; rtype . name = requested_type ; tomoyo_fill_path_info ( & rtype ) ; requested_dir_name = tomoyo_realpath_from_path ( dir ) ; if ( ! requested_dir_name ) { error = - ENOMEM ; goto out ; } rdir . name = requested_dir_name ; tomoyo_fill_path_info ( & rdir ) ; if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_BIND_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MOVE_KEYWORD ) ) { need_dev = - 1 ; } else { fstype = get_fs_type ( type ) ; if ( ! fstype ) { error = - ENODEV ; goto out ; } if ( fstype -> fs_flags & FS_REQUIRES_DEV ) need_dev = 1 ; } if ( need_dev ) { if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) { error = - ENOENT ; goto out ; } requested_dev_name = tomoyo_realpath_from_path ( & path ) ; path_put ( & path ) ; if ( ! requested_dev_name ) { error = - ENOENT ; goto out ; } } else { if ( ! dev_name ) dev_name = "<NULL>" ; requested_dev_name = tomoyo_encode ( dev_name ) ; if ( ! requested_dev_name ) { error = - ENOMEM ; goto out ; } } rdev . name = requested_dev_name ; tomoyo_fill_path_info ( & rdev ) ; r -> param_type = TOMOYO_TYPE_MOUNT_ACL ; r -> param . mount . need_dev = need_dev ; r -> param . mount . dev = & rdev ; r -> param . mount . dir = & rdir ; r -> param . mount . type = & rtype ; r -> param . mount . flags = flags ; do { tomoyo_check_acl ( r , tomoyo_check_mount_acl ) ; error = tomoyo_audit_mount_log ( r ) ; } while ( error == TOMOYO_RETRY_REQUEST ) ; out : kfree ( requested_dev_name ) ; kfree ( requested_dir_name ) ; if ( fstype ) put_filesystem ( fstype ) ; kfree ( requested_type ) ; return error ; }
void RegExpMacroAssemblerARM :: CallCheckStackGuardState ( ) { __ PrepareCallCFunction ( 3 ) ; __ mov ( r2 , frame_pointer ( ) ) ; __ mov ( r1 , Operand ( masm_ -> CodeObject ( ) ) ) ; int stack_alignment = base :: OS :: ActivationFrameAlignment ( ) ; DCHECK ( IsAligned ( stack_alignment , kPointerSize ) ) ; __ sub ( sp , sp , Operand ( stack_alignment ) ) ; __ mov ( r0 , sp ) ; ExternalReference stack_guard_check = ExternalReference :: re_check_stack_guard_state ( isolate ( ) ) ; __ mov ( ip , Operand ( stack_guard_check ) ) ; DirectCEntryStub stub ( isolate ( ) ) ; stub . GenerateCall ( masm_ , ip ) ; __ add ( sp , sp , Operand ( stack_alignment ) ) ; DCHECK_NE ( 0 , stack_alignment ) ; __ ldr ( sp , MemOperand ( sp , 0 ) ) ; __ mov ( code_pointer ( ) , Operand ( masm_ -> CodeObject ( ) ) ) ; }
png_do_write_interlace ( png_row_infop row_info , png_bytep row , int pass ) { static PNG_CONST png_byte png_pass_start [ 7 ] = { 0 , 4 , 0 , 2 , 0 , 1 , 0 } ; static PNG_CONST png_byte png_pass_inc [ 7 ] = { 8 , 8 , 4 , 4 , 2 , 2 , 1 } ; png_debug ( 1 , "in png_do_write_interlace" ) ; if ( pass < 6 ) { switch ( row_info -> pixel_depth ) { case 1 : { png_bytep sp ; png_bytep dp ; int shift ; int d ; int value ; png_uint_32 i ; png_uint_32 row_width = row_info -> width ; dp = row ; d = 0 ; shift = 7 ; for ( i = png_pass_start [ pass ] ; i < row_width ; i += png_pass_inc [ pass ] ) { sp = row + ( png_size_t ) ( i > > 3 ) ; value = ( int ) ( * sp > > ( 7 - ( int ) ( i & 0x07 ) ) ) & 0x01 ; d |= ( value < < shift ) ; if ( shift == 0 ) { shift = 7 ; * dp ++ = ( png_byte ) d ; d = 0 ; } else shift -- ; } if ( shift != 7 ) * dp = ( png_byte ) d ; break ; } case 2 : { png_bytep sp ; png_bytep dp ; int shift ; int d ; int value ; png_uint_32 i ; png_uint_32 row_width = row_info -> width ; dp = row ; shift = 6 ; d = 0 ; for ( i = png_pass_start [ pass ] ; i < row_width ; i += png_pass_inc [ pass ] ) { sp = row + ( png_size_t ) ( i > > 2 ) ; value = ( * sp > > ( ( 3 - ( int ) ( i & 0x03 ) ) < < 1 ) ) & 0x03 ; d |= ( value < < shift ) ; if ( shift == 0 ) { shift = 6 ; * dp ++ = ( png_byte ) d ; d = 0 ; } else shift -= 2 ; } if ( shift != 6 ) * dp = ( png_byte ) d ; break ; } case 4 : { png_bytep sp ; png_bytep dp ; int shift ; int d ; int value ; png_uint_32 i ; png_uint_32 row_width = row_info -> width ; dp = row ; shift = 4 ; d = 0 ; for ( i = png_pass_start [ pass ] ; i < row_width ; i += png_pass_inc [ pass ] ) { sp = row + ( png_size_t ) ( i > > 1 ) ; value = ( * sp > > ( ( 1 - ( int ) ( i & 0x01 ) ) < < 2 ) ) & 0x0f ; d |= ( value < < shift ) ; if ( shift == 0 ) { shift = 4 ; * dp ++ = ( png_byte ) d ; d = 0 ; } else shift -= 4 ; } if ( shift != 4 ) * dp = ( png_byte ) d ; break ; } default : { png_bytep sp ; png_bytep dp ; png_uint_32 i ; png_uint_32 row_width = row_info -> width ; png_size_t pixel_bytes ; dp = row ; pixel_bytes = ( row_info -> pixel_depth > > 3 ) ; for ( i = png_pass_start [ pass ] ; i < row_width ; i += png_pass_inc [ pass ] ) { sp = row + ( png_size_t ) i * pixel_bytes ; if ( dp != sp ) memcpy ( dp , sp , pixel_bytes ) ; dp += pixel_bytes ; } break ; } } row_info -> width = ( row_info -> width + png_pass_inc [ pass ] - 1 - png_pass_start [ pass ] ) / png_pass_inc [ pass ] ; row_info -> rowbytes = PNG_ROWBYTES ( row_info -> pixel_depth , row_info -> width ) ; } }
FieldAccess AccessBuilder :: ForMapBitField2 ( ) { FieldAccess access = { kTaggedBase , Map :: kBitField2Offset , Handle < Name > ( ) , MaybeHandle < Map > ( ) , TypeCache :: Get ( ) . kUint8 , MachineType :: Uint8 ( ) , kNoWriteBarrier } ; return access ; }
static int io_register_personality ( struct io_ring_ctx * ctx ) { const struct cred * creds = get_current_cred ( ) ; int id ; id = idr_alloc_cyclic ( & ctx -> personality_idr , ( void * ) creds , 1 , USHRT_MAX , GFP_KERNEL ) ; if ( id < 0 ) put_cred ( creds ) ; return id ; }
V8InspectorSessionImpl :: wrapTable ( v8 :: Local < v8 :: Context > context , v8 :: Local < v8 :: Value > table , v8 :: Local < v8 :: Value > columns ) { InjectedScript * injectedScript = nullptr ; findInjectedScript ( InspectedContext :: contextId ( context ) , injectedScript ) ; if ( ! injectedScript ) return nullptr ; return injectedScript -> wrapTable ( table , columns ) ; }
static void bnep_data_ind ( uint16_t l2cap_cid , BT_HDR * p_buf ) { tBNEP_CONN * p_bcb ; uint8_t * p = ( uint8_t * ) ( p_buf + 1 ) + p_buf -> offset ; uint16_t rem_len = p_buf -> len ; uint8_t type , ctrl_type , ext_type = 0 ; bool extension_present , fw_ext_present ; uint16_t protocol = 0 ; p_bcb = bnepu_find_bcb_by_cid ( l2cap_cid ) ; if ( p_bcb == NULL ) { BNEP_TRACE_WARNING ( "BNEP - Rcvd L2CAP data, unknown CID: 0x%x" , l2cap_cid ) ; osi_free ( p_buf ) ; return ; } type = * p ++ ; extension_present = type > > 7 ; type &= 0x7f ; if ( type >= sizeof ( bnep_frame_hdr_sizes ) / sizeof ( bnep_frame_hdr_sizes [ 0 ] ) ) { BNEP_TRACE_EVENT ( "BNEP - rcvd frame, bad type: 0x%02x" , type ) ; android_errorWriteLog ( 0x534e4554 , "68818034" ) ; osi_free ( p_buf ) ; return ; } if ( ( rem_len <= bnep_frame_hdr_sizes [ type ] ) || ( rem_len > BNEP_MTU_SIZE ) ) { BNEP_TRACE_EVENT ( "BNEP - rcvd frame, bad len: %d  type: 0x%02x" , p_buf -> len , type ) ; osi_free ( p_buf ) ; return ; } rem_len -- ; if ( ( p_bcb -> con_state != BNEP_STATE_CONNECTED ) && ( ! ( p_bcb -> con_flags & BNEP_FLAGS_CONN_COMPLETED ) ) && ( type != BNEP_FRAME_CONTROL ) ) { BNEP_TRACE_WARNING ( "BNEP - Ignored L2CAP data while in state: %d, CID: 0x%x" , p_bcb -> con_state , l2cap_cid ) ; if ( extension_present ) { uint8_t ext , length ; uint16_t org_len , new_len ; org_len = rem_len ; new_len = 0 ; do { if ( org_len < 2 ) break ; ext = * p ++ ; length = * p ++ ; p += length ; new_len = ( length + 2 ) ; if ( new_len > org_len ) break ; if ( ( ! ( ext & 0x7F ) ) && ( * p > BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG ) ) bnep_send_command_not_understood ( p_bcb , * p ) ; org_len -= new_len ; } while ( ext & 0x80 ) ; android_errorWriteLog ( 0x534e4554 , "67863755" ) ; } osi_free ( p_buf ) ; return ; } if ( type > BNEP_FRAME_COMPRESSED_ETHERNET_DEST_ONLY ) { BNEP_TRACE_EVENT ( "BNEP - rcvd frame, unknown type: 0x%02x" , type ) ; osi_free ( p_buf ) ; return ; } BNEP_TRACE_DEBUG ( "BNEP - rcv frame, type: %d len: %d Ext: %d" , type , p_buf -> len , extension_present ) ; const RawAddress * p_src_addr , * p_dst_addr ; p_src_addr = p_dst_addr = NULL ; switch ( type ) { case BNEP_FRAME_GENERAL_ETHERNET : p_dst_addr = ( RawAddress * ) p ; p += BD_ADDR_LEN ; p_src_addr = ( RawAddress * ) p ; p += BD_ADDR_LEN ; BE_STREAM_TO_UINT16 ( protocol , p ) ; rem_len -= 14 ; break ; case BNEP_FRAME_CONTROL : ctrl_type = * p ; p = bnep_process_control_packet ( p_bcb , p , & rem_len , false ) ; if ( ctrl_type == BNEP_SETUP_CONNECTION_REQUEST_MSG && p_bcb -> con_state != BNEP_STATE_CONNECTED && extension_present && p && rem_len ) { osi_free ( p_bcb -> p_pending_data ) ; p_bcb -> p_pending_data = ( BT_HDR * ) osi_malloc ( rem_len + sizeof ( BT_HDR ) ) ; memcpy ( ( uint8_t * ) ( p_bcb -> p_pending_data + 1 ) , p , rem_len ) ; p_bcb -> p_pending_data -> len = rem_len ; p_bcb -> p_pending_data -> offset = 0 ; } else { while ( extension_present && p && rem_len ) { ext_type = * p ++ ; rem_len -- ; android_errorWriteLog ( 0x534e4554 , "69271284" ) ; extension_present = ext_type > > 7 ; ext_type &= 0x7F ; if ( ext_type ) break ; p = bnep_process_control_packet ( p_bcb , p , & rem_len , true ) ; } } osi_free ( p_buf ) ; return ; case BNEP_FRAME_COMPRESSED_ETHERNET : BE_STREAM_TO_UINT16 ( protocol , p ) ; rem_len -= 2 ; break ; case BNEP_FRAME_COMPRESSED_ETHERNET_SRC_ONLY : p_src_addr = ( RawAddress * ) p ; p += BD_ADDR_LEN ; BE_STREAM_TO_UINT16 ( protocol , p ) ; rem_len -= 8 ; break ; case BNEP_FRAME_COMPRESSED_ETHERNET_DEST_ONLY : p_dst_addr = ( RawAddress * ) p ; p += BD_ADDR_LEN ; BE_STREAM_TO_UINT16 ( protocol , p ) ; rem_len -= 8 ; break ; } while ( extension_present && p && rem_len ) { ext_type = * p ; extension_present = ext_type > > 7 ; ext_type &= 0x7F ; if ( ext_type ) { BNEP_TRACE_EVENT ( "Data extension type 0x%x found" , ext_type ) ; break ; } p ++ ; rem_len -- ; p = bnep_process_control_packet ( p_bcb , p , & rem_len , true ) ; } p_buf -> offset += p_buf -> len - rem_len ; p_buf -> len = rem_len ; if ( ! p_src_addr ) p_src_addr = & p_bcb -> rem_bda ; if ( ! p_dst_addr ) p_dst_addr = controller_get_interface ( ) -> get_address ( ) ; if ( ext_type ) fw_ext_present = true ; else fw_ext_present = false ; if ( bnep_cb . p_data_buf_cb ) { ( * bnep_cb . p_data_buf_cb ) ( p_bcb -> handle , * p_src_addr , * p_dst_addr , protocol , p_buf , fw_ext_present ) ; osi_free ( p_buf ) ; } else if ( bnep_cb . p_data_ind_cb ) { ( * bnep_cb . p_data_ind_cb ) ( p_bcb -> handle , * p_src_addr , * p_dst_addr , protocol , p , rem_len , fw_ext_present ) ; osi_free ( p_buf ) ; } }
bool mkvparser :: Match ( IMkvReader * pReader , long long & pos , unsigned long id_ , long long & val ) { assert ( pReader ) ; assert ( pos >= 0 ) ; long long total , available ; const long status = pReader -> Length ( & total , & available ) ; assert ( status >= 0 ) ; assert ( ( total < 0 ) || ( available <= total ) ) ; if ( status < 0 ) return false ; long len ; const long long id = ReadUInt ( pReader , pos , len ) ; assert ( id >= 0 ) ; assert ( len > 0 ) ; assert ( len <= 8 ) ; assert ( ( pos + len ) <= available ) ; if ( ( unsigned long ) id != id_ ) return false ; pos += len ; const long long size = ReadUInt ( pReader , pos , len ) ; assert ( size >= 0 ) ; assert ( size <= 8 ) ; assert ( len > 0 ) ; assert ( len <= 8 ) ; assert ( ( pos + len ) <= available ) ; pos += len ; val = UnserializeUInt ( pReader , pos , size ) ; assert ( val >= 0 ) ; pos += size ; return true ; }
WMFVideoMFTManager :: Output ( int64_t aStreamOffset , RefPtr < MediaData > & aOutData ) { RefPtr < IMFSample > sample ; HRESULT hr ; aOutData = nullptr ; int typeChangeCount = 0 ; while ( true ) { hr = mDecoder -> Output ( & sample ) ; if ( hr == MF_E_TRANSFORM_NEED_MORE_INPUT ) { return MF_E_TRANSFORM_NEED_MORE_INPUT ; } if ( hr == MF_E_TRANSFORM_STREAM_CHANGE ) { MOZ_ASSERT ( ! sample ) ; if ( FAILED ( ( hr = ( mDecoder -> FindDecoderOutputTypeWithSubtype ( mUseHwAccel ? MFVideoFormat_NV12 : MFVideoFormat_YV12 ) ) ) ) && FAILED ( ( hr = mDecoder -> FindDecoderOutputTypeWithSubtype ( MFVideoFormat_P010 ) ) ) && FAILED ( ( hr = mDecoder -> FindDecoderOutputTypeWithSubtype ( MFVideoFormat_P016 ) ) ) ) { LOG ( "No suitable output format found" ) ; return hr ; } RefPtr < IMFMediaType > outputType ; hr = mDecoder -> GetOutputMediaType ( outputType ) ; NS_ENSURE_TRUE ( SUCCEEDED ( hr ) , hr ) ; if ( mUseHwAccel ) { hr = mDXVA2Manager -> ConfigureForSize ( outputType , mColorSpace . refOr ( DefaultColorSpace ( { mImageSize . width , mImageSize . height } ) ) , mColorRange , mVideoInfo . ImageRect ( ) . width , mVideoInfo . ImageRect ( ) . height ) ; NS_ENSURE_TRUE ( SUCCEEDED ( hr ) , hr ) ; } else { hr = GetDefaultStride ( outputType , mVideoInfo . ImageRect ( ) . width , & mVideoStride ) ; NS_ENSURE_TRUE ( SUCCEEDED ( hr ) , hr ) ; UINT32 width = 0 , height = 0 ; hr = MFGetAttributeSize ( outputType , MF_MT_FRAME_SIZE , & width , & height ) ; NS_ENSURE_TRUE ( SUCCEEDED ( hr ) , hr ) ; NS_ENSURE_TRUE ( width <= MAX_VIDEO_WIDTH , E_FAIL ) ; NS_ENSURE_TRUE ( height <= MAX_VIDEO_HEIGHT , E_FAIL ) ; mDecodedImageSize = gfx :: IntSize ( width , height ) ; } NS_ENSURE_TRUE ( typeChangeCount < 100 , MF_E_TRANSFORM_STREAM_CHANGE ) ; ++ typeChangeCount ; continue ; } if ( SUCCEEDED ( hr ) ) { if ( ! sample ) { LOG ( "Video MFTDecoder returned success but no output!" ) ; ++ mNullOutputCount ; if ( mNullOutputCount > 250 ) { LOG ( "Excessive Video MFTDecoder returning success but no output; " "giving up" ) ; mGotExcessiveNullOutput = true ; return E_FAIL ; } continue ; } TimeUnit pts = GetSampleTime ( sample ) ; TimeUnit duration = GetSampleDurationOrLastKnownDuration ( sample ) ; if ( mStreamType == WMFStreamType :: AV1 && duration == pts ) { LOG ( "Video sample duration (%" PRId64 ") matched timestamp (%" PRId64 "), setting to previous sample duration (%" PRId64 ") instead." , pts . ToMicroseconds ( ) , duration . ToMicroseconds ( ) , mLastDuration . ToMicroseconds ( ) ) ; duration = mLastDuration ; sample -> SetSampleDuration ( UsecsToHNs ( duration . ToMicroseconds ( ) ) ) ; } if ( ! pts . IsValid ( ) || ! duration . IsValid ( ) ) { return E_FAIL ; } if ( mSeekTargetThreshold . isSome ( ) ) { if ( ( pts + duration ) < mSeekTargetThreshold . ref ( ) ) { LOG ( "Dropping video frame which pts (%" PRId64 " + %" PRId64 ") is smaller than seek target (%" PRId64 ")." , pts . ToMicroseconds ( ) , duration . ToMicroseconds ( ) , mSeekTargetThreshold -> ToMicroseconds ( ) ) ; sample = nullptr ; continue ; } mSeekTargetThreshold . reset ( ) ; } break ; } NS_WARNING ( "WMFVideoMFTManager::Output() unexpected error" ) ; return hr ; } RefPtr < VideoData > frame ; if ( mUseHwAccel ) { hr = CreateD3DVideoFrame ( sample , aStreamOffset , getter_AddRefs ( frame ) ) ; } else { hr = CreateBasicVideoFrame ( sample , aStreamOffset , getter_AddRefs ( frame ) ) ; } MOZ_ASSERT ( ( frame != nullptr ) == SUCCEEDED ( hr ) ) ; NS_ENSURE_TRUE ( SUCCEEDED ( hr ) , hr ) ; NS_ENSURE_TRUE ( frame , E_FAIL ) ; aOutData = frame ; if ( mNullOutputCount ) { mGotValidOutputAfterNullOutput = true ; } return S_OK ; }
static int holtek_kbd_probe ( struct hid_device * hdev , const struct hid_device_id * id ) { struct usb_interface * intf = to_usb_interface ( hdev -> dev . parent ) ; int ret = hid_parse ( hdev ) ; if ( ! ret ) ret = hid_hw_start ( hdev , HID_CONNECT_DEFAULT ) ; if ( ! ret && intf -> cur_altsetting -> desc . bInterfaceNumber == 1 ) { struct hid_input * hidinput ; list_for_each_entry ( hidinput , & hdev -> inputs , list ) { hidinput -> input -> event = holtek_kbd_input_event ; } } return ret ; }
void Context :: onUpstreamConnectionClose ( PeerType peer_type ) { if ( wasm_ -> onUpstreamConnectionClose_ ) { wasm_ -> onUpstreamConnectionClose_ ( this , id_ , static_cast < uint32_t > ( peer_type ) ) ; } }
xmlDictAddQString ( xmlDictPtr dict , const xmlChar * prefix , unsigned int plen , const xmlChar * name , unsigned int namelen ) { xmlDictStringsPtr pool ; const xmlChar * ret ; size_t size = 0 ; size_t limit = 0 ; if ( prefix == NULL ) return ( xmlDictAddString ( dict , name , namelen ) ) ; #ifdef DICT_DEBUG_PATTERNS fprintf ( stderr , "=" ) ; #endif pool = dict -> strings ; while ( pool != NULL ) { if ( pool -> end - pool -> free > namelen + plen + 1 ) goto found_pool ; if ( pool -> size > size ) size = pool -> size ; limit += pool -> size ; pool = pool -> next ; } if ( pool == NULL ) { if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) ) { return ( NULL ) ; } if ( size == 0 ) size = 1000 ; else size *= 4 ; if ( size < 4 * ( namelen + plen + 1 ) ) size = 4 * ( namelen + plen + 1 ) ; pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ) ; if ( pool == NULL ) return ( NULL ) ; pool -> size = size ; pool -> nbStrings = 0 ; pool -> free = & pool -> array [ 0 ] ; pool -> end = & pool -> array [ size ] ; pool -> next = dict -> strings ; dict -> strings = pool ; #ifdef DICT_DEBUG_PATTERNS fprintf ( stderr , "+" ) ; #endif } found_pool : ret = pool -> free ; memcpy ( pool -> free , prefix , plen ) ; pool -> free += plen ; * ( pool -> free ++ ) = ':' ; memcpy ( pool -> free , name , namelen ) ; pool -> free += namelen ; * ( pool -> free ++ ) = 0 ; pool -> nbStrings ++ ; return ( ret ) ; }
RUNTIME_FUNCTION ( Runtime_LoadKeyedFromSuper ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 3 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( Object , receiver , 0 ) ; CONVERT_ARG_HANDLE_CHECKED ( JSObject , home_object , 1 ) ; CONVERT_ARG_HANDLE_CHECKED ( Object , key , 2 ) ; uint32_t index = 0 ; if ( key -> ToArrayIndex ( & index ) ) { RETURN_RESULT_OR_FAILURE ( isolate , LoadElementFromSuper ( isolate , receiver , home_object , index ) ) ; } Handle < Name > name ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , name , Object :: ToName ( isolate , key ) ) ; if ( name -> AsArrayIndex ( & index ) ) { RETURN_RESULT_OR_FAILURE ( isolate , LoadElementFromSuper ( isolate , receiver , home_object , index ) ) ; } RETURN_RESULT_OR_FAILURE ( isolate , LoadFromSuper ( isolate , receiver , home_object , name ) ) ; }
virtual void ComputeWithReservedSpace ( OpKernelContext * context , bool use_reserved_space ) { Tensor x = context -> input ( 0 ) ; const Tensor & scale = context -> input ( 1 ) ; const Tensor & offset = context -> input ( 2 ) ; const Tensor & estimated_mean = context -> input ( 3 ) ; const Tensor & estimated_variance = context -> input ( 4 ) ; const Tensor * side_input = has_side_input_ ? & context -> input ( 5 ) : nullptr ; OP_REQUIRES ( context , x . dims ( ) == 4 || x . dims ( ) == 5 , errors :: InvalidArgument ( "input must be 4 or 5-dimensional" , x . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , scale . dims ( ) == 1 , errors :: InvalidArgument ( "scale must be 1-dimensional" , scale . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , offset . dims ( ) == 1 , errors :: InvalidArgument ( "offset must be 1-dimensional" , offset . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , estimated_mean . dims ( ) == 1 , errors :: InvalidArgument ( "estimated_mean must be 1-dimensional" , estimated_mean . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , estimated_variance . dims ( ) == 1 , errors :: InvalidArgument ( "estimated_variance must be 1-dimensional" , estimated_variance . shape ( ) . DebugString ( ) ) ) ; bool use_reshape = ( x . dims ( ) == 5 ) ; auto x_shape = x . shape ( ) ; TensorShape dest_shape ; if ( use_reshape ) { const int64_t in_batch = GetTensorDim ( x , tensor_format_ , 'N' ) ; int64_t in_planes = GetTensorDim ( x , tensor_format_ , '0' ) ; int64_t in_rows = GetTensorDim ( x , tensor_format_ , '1' ) ; int64_t in_cols = GetTensorDim ( x , tensor_format_ , '2' ) ; const int64_t in_depth = GetTensorDim ( x , tensor_format_ , 'C' ) ; dest_shape = ShapeFromFormat ( tensor_format_ , in_batch , { { in_planes , in_rows * in_cols } } , in_depth ) ; OP_REQUIRES ( context , x . CopyFrom ( x , dest_shape ) , errors :: InvalidArgument ( "Error during tensor copy." ) ) ; } const auto num_channels = GetTensorDim ( x , tensor_format_ , 'C' ) ; OP_REQUIRES ( context , scale . NumElements ( ) == num_channels , errors :: InvalidArgument ( "scale must have the same number of elements " "as the channels of x, got " , scale . NumElements ( ) , " and " , num_channels ) ) ; OP_REQUIRES ( context , offset . NumElements ( ) == num_channels , errors :: InvalidArgument ( "offset must have the same number of elements " "as the channels of x, got " , offset . NumElements ( ) , " and " , num_channels ) ) ; if ( estimated_mean . NumElements ( ) != 0 ) { OP_REQUIRES ( context , estimated_mean . NumElements ( ) == num_channels , errors :: InvalidArgument ( "mean must be empty or have the same number of " "elements as the channels of x, got " , estimated_mean . NumElements ( ) , " and " , num_channels ) ) ; } if ( estimated_variance . NumElements ( ) != 0 ) { OP_REQUIRES ( context , estimated_variance . NumElements ( ) == num_channels , errors :: InvalidArgument ( "variance must be empty or have the same number of " "elements as the channels of x, got " , estimated_variance . NumElements ( ) , " and " , num_channels ) ) ; } if ( has_side_input_ ) { OP_REQUIRES ( context , side_input -> shape ( ) == x . shape ( ) , errors :: InvalidArgument ( "side_input shape must be equal to input shape: " , side_input -> shape ( ) . DebugString ( ) , " != " , x . shape ( ) . DebugString ( ) ) ) ; } if ( activation_mode_ != FbnActivationMode :: kIdentity ) { OP_REQUIRES ( context , ! is_training_ || num_channels % 4 == 0 , errors :: InvalidArgument ( "FusedBatchNorm with activation requires " "channel dimension to be a multiple of 4." ) ) ; } Tensor * y = nullptr ; auto alloc_shape = use_reshape ? dest_shape : x_shape ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_output ( { 0 } , 0 , alloc_shape , & y ) ) ; Tensor * batch_mean = nullptr ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_output ( { 3 } , 1 , scale . shape ( ) , & batch_mean ) ) ; Tensor * batch_var = nullptr ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_output ( { 4 } , 2 , scale . shape ( ) , & batch_var ) ) ; Tensor * saved_mean = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 3 , scale . shape ( ) , & saved_mean ) ) ; Tensor * saved_maybe_inv_var = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 4 , scale . shape ( ) , & saved_maybe_inv_var ) ) ; if ( is_training_ ) { functor :: FusedBatchNorm < Device , T , U , true > ( ) ( context , x , scale , offset , estimated_mean , estimated_variance , side_input , epsilon_ , exponential_avg_factor_ , activation_mode_ , y , batch_mean , batch_var , saved_mean , saved_maybe_inv_var , tensor_format_ , use_reserved_space ) ; } else { functor :: FusedBatchNorm < Device , T , U , false > ( ) ( context , x , scale , offset , estimated_mean , estimated_variance , side_input , epsilon_ , exponential_avg_factor_ , activation_mode_ , y , batch_mean , batch_var , saved_mean , saved_maybe_inv_var , tensor_format_ , use_reserved_space ) ; } if ( use_reshape ) { OP_REQUIRES ( context , y -> CopyFrom ( * y , x_shape ) , errors :: InvalidArgument ( "Error during tensor copy." ) ) ; } }
TypeObjectKey :: watchStateChangeForTypedArrayBuffer ( CompilerConstraintList * constraints ) { void * viewData = asSingleObject ( ) -> as < TypedArrayObject > ( ) . viewData ( ) ; HeapTypeSetKey objectProperty = property ( JSID_EMPTY ) ; LifoAlloc * alloc = constraints -> alloc ( ) ; typedef CompilerConstraintInstance < ConstraintDataFreezeObjectForTypedArrayBuffer > T ; constraints -> add ( alloc -> new_ < T > ( alloc , objectProperty , ConstraintDataFreezeObjectForTypedArrayBuffer ( viewData ) ) ) ; }
Recv__delete__ ( const DeviceStorageResponseValue & aValue ) { if ( mCallback ) { mCallback -> RequestComplete ( ) ; mCallback = nullptr ; } switch ( aValue . type ( ) ) { case DeviceStorageResponseValue :: TErrorResponse : { ErrorResponse r = aValue ; mRequest -> FireError ( r . error ( ) ) ; break ; } case DeviceStorageResponseValue :: TSuccessResponse : { nsString fullPath ; mDSFile -> GetFullPath ( fullPath ) ; AutoJSContext cx ; JS :: Rooted < JS :: Value > result ( cx , StringToJsval ( mRequest -> GetOwner ( ) , fullPath ) ) ; mRequest -> FireSuccess ( result ) ; break ; } case DeviceStorageResponseValue :: TFileDescriptorResponse : { FileDescriptorResponse r = aValue ; nsString fullPath ; mDSFile -> GetFullPath ( fullPath ) ; AutoJSContext cx ; JS :: Rooted < JS :: Value > result ( cx , StringToJsval ( mRequest -> GetOwner ( ) , fullPath ) ) ; mDSFileDescriptor -> mDSFile = mDSFile ; mDSFileDescriptor -> mFileDescriptor = r . fileDescriptor ( ) ; mRequest -> FireSuccess ( result ) ; break ; } case DeviceStorageResponseValue :: TBlobResponse : { BlobResponse r = aValue ; BlobChild * actor = static_cast < BlobChild * > ( r . blobChild ( ) ) ; nsCOMPtr < nsIDOMBlob > blob = actor -> GetBlob ( ) ; nsCOMPtr < nsIDOMFile > file = do_QueryInterface ( blob ) ; AutoJSContext cx ; JS :: Rooted < JS :: Value > result ( cx , InterfaceToJsval ( mRequest -> GetOwner ( ) , file , & NS_GET_IID ( nsIDOMFile ) ) ) ; mRequest -> FireSuccess ( result ) ; break ; } case DeviceStorageResponseValue :: TFreeSpaceStorageResponse : { FreeSpaceStorageResponse r = aValue ; AutoJSContext cx ; JS :: Rooted < JS :: Value > result ( cx , JS_NumberValue ( double ( r . freeBytes ( ) ) ) ) ; mRequest -> FireSuccess ( result ) ; break ; } case DeviceStorageResponseValue :: TUsedSpaceStorageResponse : { UsedSpaceStorageResponse r = aValue ; AutoJSContext cx ; JS :: Rooted < JS :: Value > result ( cx , JS_NumberValue ( double ( r . usedBytes ( ) ) ) ) ; mRequest -> FireSuccess ( result ) ; break ; } case DeviceStorageResponseValue :: TAvailableStorageResponse : { AvailableStorageResponse r = aValue ; AutoJSContext cx ; JS :: Rooted < JS :: Value > result ( cx , StringToJsval ( mRequest -> GetOwner ( ) , r . mountState ( ) ) ) ; mRequest -> FireSuccess ( result ) ; break ; } case DeviceStorageResponseValue :: TStorageStatusResponse : { StorageStatusResponse r = aValue ; AutoJSContext cx ; JS :: Rooted < JS :: Value > result ( cx , StringToJsval ( mRequest -> GetOwner ( ) , r . storageStatus ( ) ) ) ; mRequest -> FireSuccess ( result ) ; break ; } case DeviceStorageResponseValue :: TFormatStorageResponse : { FormatStorageResponse r = aValue ; AutoJSContext cx ; JS :: Rooted < JS :: Value > result ( cx , StringToJsval ( mRequest -> GetOwner ( ) , r . mountState ( ) ) ) ; mRequest -> FireSuccess ( result ) ; break ; } case DeviceStorageResponseValue :: TMountStorageResponse : { MountStorageResponse r = aValue ; AutoJSContext cx ; JS :: Rooted < JS :: Value > result ( cx , StringToJsval ( mRequest -> GetOwner ( ) , r . storageStatus ( ) ) ) ; mRequest -> FireSuccess ( result ) ; break ; } case DeviceStorageResponseValue :: TUnmountStorageResponse : { UnmountStorageResponse r = aValue ; AutoJSContext cx ; JS :: Rooted < JS :: Value > result ( cx , StringToJsval ( mRequest -> GetOwner ( ) , r . storageStatus ( ) ) ) ; mRequest -> FireSuccess ( result ) ; break ; } case DeviceStorageResponseValue :: TEnumerationResponse : { EnumerationResponse r = aValue ; nsDOMDeviceStorageCursor * cursor = static_cast < nsDOMDeviceStorageCursor * > ( mRequest . get ( ) ) ; uint32_t count = r . paths ( ) . Length ( ) ; for ( uint32_t i = 0 ; i < count ; i ++ ) { nsRefPtr < DeviceStorageFile > dsf = new DeviceStorageFile ( r . type ( ) , r . paths ( ) [ i ] . storageName ( ) , r . rootdir ( ) , r . paths ( ) [ i ] . name ( ) ) ; cursor -> mFiles . AppendElement ( dsf ) ; } nsRefPtr < ContinueCursorEvent > event = new ContinueCursorEvent ( cursor ) ; event -> Continue ( ) ; break ; } default : { NS_RUNTIMEABORT ( "not reached" ) ; break ; } } return true ; }
bool IsFastLiteralHelper ( Handle < JSObject > boilerplate , int max_depth , int * max_properties ) { DCHECK_GE ( max_depth , 0 ) ; DCHECK_GE ( * max_properties , 0 ) ; if ( ! JSObject :: TryMigrateInstance ( boilerplate ) ) return false ; if ( max_depth == 0 ) return false ; Isolate * const isolate = boilerplate -> GetIsolate ( ) ; Handle < FixedArrayBase > elements ( boilerplate -> elements ( ) , isolate ) ; if ( elements -> length ( ) > 0 && elements -> map ( ) != ReadOnlyRoots ( isolate ) . fixed_cow_array_map ( ) ) { if ( boilerplate -> HasSmiOrObjectElements ( ) ) { Handle < FixedArray > fast_elements = Handle < FixedArray > :: cast ( elements ) ; int length = elements -> length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( ( * max_properties ) -- == 0 ) return false ; Handle < Object > value ( fast_elements -> get ( i ) , isolate ) ; if ( value -> IsJSObject ( ) ) { Handle < JSObject > value_object = Handle < JSObject > :: cast ( value ) ; if ( ! IsFastLiteralHelper ( value_object , max_depth - 1 , max_properties ) ) { return false ; } } } } else if ( boilerplate -> HasDoubleElements ( ) ) { if ( elements -> Size ( ) > kMaxRegularHeapObjectSize ) return false ; } else { return false ; } } if ( ! ( boilerplate -> HasFastProperties ( ) && boilerplate -> property_array ( ) -> length ( ) == 0 ) ) { return false ; } Handle < DescriptorArray > descriptors ( boilerplate -> map ( ) -> instance_descriptors ( ) , isolate ) ; int limit = boilerplate -> map ( ) -> NumberOfOwnDescriptors ( ) ; for ( int i = 0 ; i < limit ; i ++ ) { PropertyDetails details = descriptors -> GetDetails ( i ) ; if ( details . location ( ) != kField ) continue ; DCHECK_EQ ( kData , details . kind ( ) ) ; if ( ( * max_properties ) -- == 0 ) return false ; FieldIndex field_index = FieldIndex :: ForDescriptor ( boilerplate -> map ( ) , i ) ; if ( boilerplate -> IsUnboxedDoubleField ( field_index ) ) continue ; Handle < Object > value ( boilerplate -> RawFastPropertyAt ( field_index ) , isolate ) ; if ( value -> IsJSObject ( ) ) { Handle < JSObject > value_object = Handle < JSObject > :: cast ( value ) ; if ( ! IsFastLiteralHelper ( value_object , max_depth - 1 , max_properties ) ) { return false ; } } } return true ; }
rfbHandleAuthResult ( rfbClient * client ) { uint32_t authResult = 0 , reasonLen = 0 ; char * reason = NULL ; if ( ! ReadFromRFBServer ( client , ( char * ) & authResult , 4 ) ) return FALSE ; authResult = rfbClientSwap32IfLE ( authResult ) ; switch ( authResult ) { case rfbVncAuthOK : rfbClientLog ( "VNC authentication succeeded\n" ) ; return TRUE ; break ; case rfbVncAuthFailed : if ( client -> major == 3 && client -> minor > 7 ) { if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return FALSE ; reasonLen = rfbClientSwap32IfLE ( reasonLen ) ; reason = malloc ( ( uint64_t ) reasonLen + 1 ) ; if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) { free ( reason ) ; return FALSE ; } reason [ reasonLen ] = 0 ; rfbClientLog ( "VNC connection failed: %s\n" , reason ) ; free ( reason ) ; return FALSE ; } rfbClientLog ( "VNC authentication failed\n" ) ; return FALSE ; case rfbVncAuthTooMany : rfbClientLog ( "VNC authentication failed - too many tries\n" ) ; return FALSE ; } rfbClientLog ( "Unknown VNC authentication result: %d\n" , ( int ) authResult ) ; return FALSE ; }
void DebugCodegen :: GenerateFrameDropperTrampoline ( MacroAssembler * masm ) { __ movp ( rbp , rbx ) ; __ movp ( rdi , Operand ( rbp , JavaScriptFrameConstants :: kFunctionOffset ) ) ; __ leave ( ) ; __ movp ( rbx , FieldOperand ( rdi , JSFunction :: kSharedFunctionInfoOffset ) ) ; __ movzxwq ( rbx , FieldOperand ( rbx , SharedFunctionInfo :: kFormalParameterCountOffset ) ) ; ParameterCount dummy ( rbx ) ; __ InvokeFunction ( rdi , no_reg , dummy , dummy , JUMP_FUNCTION ) ; }
FieldAccess AccessBuilder :: ForArgumentsLength ( ) { FieldAccess access = { kTaggedBase , JSArgumentsObject :: kLengthOffset , Handle < Name > ( ) , MaybeHandle < Map > ( ) , Type :: NonInternal ( ) , MachineType :: AnyTagged ( ) , kFullWriteBarrier } ; return access ; }
WireBytesRef consume_string ( Decoder & decoder , bool validate_utf8 , const char * name ) { uint32_t length = decoder . consume_u32v ( "string length" ) ; uint32_t offset = decoder . pc_offset ( ) ; const byte * string_start = decoder . pc ( ) ; if ( length > 0 ) { decoder . consume_bytes ( length , name ) ; if ( decoder . ok ( ) && validate_utf8 && ! unibrow :: Utf8 :: ValidateEncoding ( string_start , length ) ) { decoder . errorf ( string_start , "%s: no valid UTF-8 string" , name ) ; } } return { offset , decoder . failed ( ) ? 0 : length } ; }
ObjectGroup :: useSingletonForAllocationSite ( JSScript * script , jsbytecode * pc , JSProtoKey key ) { JS_STATIC_ASSERT ( GenericObject == 0 ) ; if ( script -> functionNonDelazifying ( ) && ! script -> treatAsRunOnce ( ) ) return GenericObject ; if ( key != JSProto_Object && ! ( key >= JSProto_Int8Array && key <= JSProto_Uint8ClampedArray ) && ! ( key >= JSProto_SharedInt8Array && key <= JSProto_SharedUint8ClampedArray ) ) { return GenericObject ; } if ( ! script -> hasTrynotes ( ) ) return SingletonObject ; unsigned offset = script -> pcToOffset ( pc ) ; JSTryNote * tn = script -> trynotes ( ) -> vector ; JSTryNote * tnlimit = tn + script -> trynotes ( ) -> length ; for ( ; tn < tnlimit ; tn ++ ) { if ( tn -> kind != JSTRY_FOR_IN && tn -> kind != JSTRY_LOOP ) continue ; unsigned startOffset = script -> mainOffset ( ) + tn -> start ; unsigned endOffset = startOffset + tn -> length ; if ( offset >= startOffset && offset < endOffset ) return GenericObject ; } return SingletonObject ; }
string_object_to_c_ast ( const char * s , PyObject * filename , int start , PyCompilerFlags * flags , int feature_version , PyArena * arena ) { mod_ty mod ; PyCompilerFlags localflags ; perrdetail err ; int iflags = PARSER_FLAGS ( flags ) ; node * n = Ta3Parser_ParseStringObject ( s , filename , & _Ta3Parser_Grammar , start , & err , & iflags ) ; if ( flags == NULL ) { localflags . cf_flags = 0 ; flags = & localflags ; } if ( n ) { flags -> cf_flags |= iflags & PyCF_MASK ; mod = Ta3AST_FromNodeObject ( n , flags , filename , feature_version , arena ) ; Ta3Node_Free ( n ) ; } else { err_input ( & err ) ; mod = NULL ; } err_free ( & err ) ; return mod ; }
TEST_P ( Trans32x32Test , AccuracyCheck ) { ACMRandom rnd ( ACMRandom :: DeterministicSeed ( ) ) ; uint32_t max_error = 0 ; int64_t total_error = 0 ; const int count_test_block = 1000 ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , test_input_block , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , test_temp_block , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , dst , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , src , kNumCoeffs ) ; for ( int i = 0 ; i < count_test_block ; ++ i ) { for ( int j = 0 ; j < kNumCoeffs ; ++ j ) { src [ j ] = rnd . Rand8 ( ) ; dst [ j ] = rnd . Rand8 ( ) ; test_input_block [ j ] = src [ j ] - dst [ j ] ; } REGISTER_STATE_CHECK ( fwd_txfm_ ( test_input_block , test_temp_block , 32 ) ) ; REGISTER_STATE_CHECK ( inv_txfm_ ( test_temp_block , dst , 32 ) ) ; for ( int j = 0 ; j < kNumCoeffs ; ++ j ) { const uint32_t diff = dst [ j ] - src [ j ] ; const uint32_t error = diff * diff ; if ( max_error < error ) max_error = error ; total_error += error ; } } if ( version_ == 1 ) { max_error /= 2 ; total_error /= 45 ; } EXPECT_GE ( 1u , max_error ) < < "Error: 32x32 FDCT/IDCT has an individual round-trip error > 1" ; EXPECT_GE ( count_test_block , total_error ) < < "Error: 32x32 FDCT/IDCT has average round-trip error > 1 per block" ; }
MaybeHandle < Object > StoreGlobalIC :: Store ( Handle < Name > name , Handle < Object > value ) { DCHECK ( name -> IsString ( ) ) ; Handle < String > str_name = Handle < String > :: cast ( name ) ; Handle < JSGlobalObject > global = isolate ( ) -> global_object ( ) ; Handle < ScriptContextTable > script_contexts ( global -> native_context ( ) -> script_context_table ( ) , isolate ( ) ) ; ScriptContextTable :: LookupResult lookup_result ; if ( ScriptContextTable :: Lookup ( isolate ( ) , script_contexts , str_name , & lookup_result ) ) { Handle < Context > script_context = ScriptContextTable :: GetContext ( isolate ( ) , script_contexts , lookup_result . context_index ) ; if ( lookup_result . mode == VariableMode :: kConst ) { return TypeError ( MessageTemplate :: kConstAssign , global , name ) ; } Handle < Object > previous_value = FixedArray :: get ( * script_context , lookup_result . slot_index , isolate ( ) ) ; if ( previous_value -> IsTheHole ( isolate ( ) ) ) { return ReferenceError ( name ) ; } if ( FLAG_use_ic ) { if ( nexus ( ) -> ConfigureLexicalVarMode ( lookup_result . context_index , lookup_result . slot_index ) ) { TRACE_HANDLER_STATS ( isolate ( ) , StoreGlobalIC_StoreScriptContextField ) ; } else { TRACE_HANDLER_STATS ( isolate ( ) , StoreGlobalIC_SlowStub ) ; PatchCache ( name , slow_stub ( ) ) ; } TraceIC ( "StoreGlobalIC" , name ) ; } script_context -> set ( lookup_result . slot_index , * value ) ; return value ; } return StoreIC :: Store ( global , name , value ) ; }
void EmitUnOp ( EmitFn fn ) { static RegClass src_rc = reg_class_for ( src_type ) ; static RegClass result_rc = reg_class_for ( result_type ) ; LiftoffRegister src = __ PopToRegister ( ) ; LiftoffRegister dst = src_rc == result_rc ? __ GetUnusedRegister ( result_rc , { src } ) : __ GetUnusedRegister ( result_rc ) ; fn ( dst , src ) ; __ PushRegister ( result_type , dst ) ; }
WebGLContext :: DOMElementToImageSurface ( nsIDOMElement * imageOrCanvas , gfxImageSurface * * imageOut , int * format ) { gfxImageSurface * surf = nsnull ; PRUint32 flags = nsLayoutUtils :: SFE_WANT_NEW_SURFACE | nsLayoutUtils :: SFE_WANT_IMAGE_SURFACE ; if ( mPixelStoreColorspaceConversion == LOCAL_GL_NONE ) flags |= nsLayoutUtils :: SFE_NO_COLORSPACE_CONVERSION ; if ( ! mPixelStorePremultiplyAlpha ) flags |= nsLayoutUtils :: SFE_NO_PREMULTIPLY_ALPHA ; nsLayoutUtils :: SurfaceFromElementResult res = nsLayoutUtils :: SurfaceFromElement ( imageOrCanvas , flags ) ; if ( ! res . mSurface ) return NS_ERROR_FAILURE ; CanvasUtils :: DoDrawImageSecurityCheck ( HTMLCanvasElement ( ) , res . mPrincipal , res . mIsWriteOnly ) ; if ( res . mSurface -> GetType ( ) != gfxASurface :: SurfaceTypeImage ) { return NS_ERROR_FAILURE ; } surf = static_cast < gfxImageSurface * > ( res . mSurface . get ( ) ) ; res . mSurface . forget ( ) ; * imageOut = surf ; switch ( surf -> Format ( ) ) { case gfxASurface :: ImageFormatARGB32 : * format = WebGLTexelFormat :: BGRA8 ; break ; case gfxASurface :: ImageFormatRGB24 : * format = WebGLTexelFormat :: BGRX8 ; break ; case gfxASurface :: ImageFormatA8 : * format = WebGLTexelFormat :: A8 ; break ; case gfxASurface :: ImageFormatRGB16_565 : * format = WebGLTexelFormat :: RGB565 ; break ; default : NS_ASSERTION ( PR_FALSE , "Unsupported image format. Unimplemented." ) ; return NS_ERROR_NOT_IMPLEMENTED ; } return NS_OK ; }
nsPasswordManager :: AutoCompleteSearch ( const nsAString & aSearchString , nsIAutoCompleteResult * aPreviousResult , nsIDOMHTMLInputElement * aElement , nsIAutoCompleteResult * * aResult ) { PRInt32 dummy ; if ( ! SingleSignonEnabled ( ) || ! mAutoCompleteInputs . Get ( aElement , & dummy ) ) return PR_FALSE ; UserAutoComplete * result = nsnull ; if ( aPreviousResult ) { result = NS_STATIC_CAST ( UserAutoComplete * , aPreviousResult ) ; if ( result -> mArray . Count ( ) ) { for ( PRInt32 i = result -> mArray . Count ( ) - 1 ; i >= 0 ; -- i ) { nsDependentString match ( NS_STATIC_CAST ( PRUnichar * , result -> mArray . ElementAt ( i ) ) ) ; if ( aSearchString . Length ( ) > match . Length ( ) || ! StringBeginsWith ( match , aSearchString , nsCaseInsensitiveStringComparator ( ) ) ) { nsMemory :: Free ( result -> mArray . ElementAt ( i ) ) ; result -> mArray . RemoveElementAt ( i ) ; } } } } else { nsCOMPtr < nsIDOMDocument > domDoc ; aElement -> GetOwnerDocument ( getter_AddRefs ( domDoc ) ) ; nsCOMPtr < nsIDocument > doc = do_QueryInterface ( domDoc ) ; nsCAutoString realm ; if ( ! GetPasswordRealm ( doc -> GetDocumentURI ( ) , realm ) ) { * aResult = nsnull ; return NS_OK ; } result = new UserAutoComplete ( realm , aSearchString ) ; SignonHashEntry * hashEnt ; if ( mSignonTable . Get ( realm , & hashEnt ) ) { mAutoCompletingField = aElement ; for ( SignonDataEntry * e = hashEnt -> head ; e ; e = e -> next ) { nsAutoString userValue ; if ( NS_FAILED ( DecryptData ( e -> userValue , userValue ) ) ) return NS_ERROR_FAILURE ; if ( aSearchString . Length ( ) <= userValue . Length ( ) && StringBeginsWith ( userValue , aSearchString , nsCaseInsensitiveStringComparator ( ) ) ) { PRUnichar * data = ToNewUnicode ( userValue ) ; if ( data ) result -> mArray . AppendElement ( data ) ; } } mAutoCompletingField = nsnull ; } if ( result -> mArray . Count ( ) ) { result -> mArray . Sort ( SortPRUnicharComparator , nsnull ) ; result -> mResult = nsIAutoCompleteResult :: RESULT_SUCCESS ; result -> mDefaultIndex = 0 ; } else { result -> mResult = nsIAutoCompleteResult :: RESULT_NOMATCH ; result -> mDefaultIndex = - 1 ; } } * aResult = result ; NS_ADDREF ( * aResult ) ; return PR_TRUE ; }
static int32_t scsi_send_command ( SCSIRequest * req , uint8_t * buf ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; int32_t len ; uint8_t command ; uint8_t * outbuf ; int rc ; command = buf [ 0 ] ; outbuf = ( uint8_t * ) r -> iov . iov_base ; DPRINTF ( "Command: lun=%d tag=0x%x data=0x%02x" , req -> lun , req -> tag , buf [ 0 ] ) ; #ifdef DEBUG_SCSI { int i ; for ( i = 1 ; i < r -> req . cmd . len ; i ++ ) { printf ( " 0x%02x" , buf [ i ] ) ; } printf ( "\n" ) ; } #endif switch ( command ) { case TEST_UNIT_READY : case INQUIRY : case MODE_SENSE : case MODE_SENSE_10 : case RESERVE : case RESERVE_10 : case RELEASE : case RELEASE_10 : case START_STOP : case ALLOW_MEDIUM_REMOVAL : case READ_CAPACITY_10 : case READ_TOC : case GET_CONFIGURATION : case SERVICE_ACTION_IN_16 : case VERIFY_10 : rc = scsi_disk_emulate_command ( r , outbuf ) ; if ( rc < 0 ) { return 0 ; } r -> iov . iov_len = rc ; break ; case SYNCHRONIZE_CACHE : bdrv_acct_start ( s -> bs , & r -> acct , 0 , BDRV_ACCT_FLUSH ) ; r -> req . aiocb = bdrv_aio_flush ( s -> bs , scsi_flush_complete , r ) ; if ( r -> req . aiocb == NULL ) { scsi_flush_complete ( r , - EIO ) ; } return 0 ; case READ_6 : case READ_10 : case READ_12 : case READ_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( "Read (sector %" PRId64 ", count %d)\n" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) goto illegal_lba ; r -> sector = r -> req . cmd . lba * s -> cluster_size ; r -> sector_count = len * s -> cluster_size ; break ; case WRITE_6 : case WRITE_10 : case WRITE_12 : case WRITE_16 : case WRITE_VERIFY_10 : case WRITE_VERIFY_12 : case WRITE_VERIFY_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( "Write %s(sector %" PRId64 ", count %d)\n" , ( command & 0xe ) == 0xe ? "And Verify " : "" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) goto illegal_lba ; r -> sector = r -> req . cmd . lba * s -> cluster_size ; r -> sector_count = len * s -> cluster_size ; break ; case MODE_SELECT : DPRINTF ( "Mode Select(6) (len %lu)\n" , ( long ) r -> req . cmd . xfer ) ; if ( r -> req . cmd . xfer > 12 ) { goto fail ; } break ; case MODE_SELECT_10 : DPRINTF ( "Mode Select(10) (len %lu)\n" , ( long ) r -> req . cmd . xfer ) ; if ( r -> req . cmd . xfer > 16 ) { goto fail ; } break ; case SEEK_6 : case SEEK_10 : DPRINTF ( "Seek(%d) (sector %" PRId64 ")\n" , command == SEEK_6 ? 6 : 10 , r -> req . cmd . lba ) ; if ( r -> req . cmd . lba > s -> max_lba ) { goto illegal_lba ; } break ; case WRITE_SAME_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( "WRITE SAME(16) (sector %" PRId64 ", count %d)\n" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) { goto illegal_lba ; } if ( ! ( buf [ 1 ] & 0x8 ) ) { goto fail ; } rc = bdrv_discard ( s -> bs , r -> req . cmd . lba * s -> cluster_size , len * s -> cluster_size ) ; if ( rc < 0 ) { goto fail ; } break ; case REQUEST_SENSE : abort ( ) ; default : DPRINTF ( "Unknown SCSI command (%2.2x)\n" , buf [ 0 ] ) ; scsi_check_condition ( r , SENSE_CODE ( INVALID_OPCODE ) ) ; return 0 ; fail : scsi_check_condition ( r , SENSE_CODE ( INVALID_FIELD ) ) ; return 0 ; illegal_lba : scsi_check_condition ( r , SENSE_CODE ( LBA_OUT_OF_RANGE ) ) ; return 0 ; } if ( r -> sector_count == 0 && r -> iov . iov_len == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; } len = r -> sector_count * 512 + r -> iov . iov_len ; if ( r -> req . cmd . mode == SCSI_XFER_TO_DEV ) { return - len ; } else { if ( ! r -> sector_count ) r -> sector_count = - 1 ; return len ; } }
- aEnable ] ( nsresult aResult ) mutable { + [ self , this , & state , aEnable ] ( nsresult aResult ) mutable { MOZ_ASSERT_IF ( aResult != NS_ERROR_ABORT , state . mDeviceEnabled == aEnable ) ; MOZ_ASSERT ( state . mOperationInProgress ) ; state . mOperationInProgress = false ; if ( state . mStopped ) { - - + + return ; } if ( NS_FAILED ( aResult ) && aResult != NS_ERROR_ABORT && ! aEnable ) { state . mOffWhileDisabled = false ; return ; } if ( state . mTrackEnabled != state . mDeviceEnabled ) { - SetEnabledFor ( track , state . mTrackEnabled ) ; + SetDeviceEnabled ( state . mTrackEnabled ) ; } } ,
int smb2_write ( struct ksmbd_work * work ) { struct smb2_write_req * req ; struct smb2_write_rsp * rsp ; struct ksmbd_file * fp = NULL ; loff_t offset ; size_t length ; ssize_t nbytes ; char * data_buf ; bool writethrough = false , is_rdma_channel = false ; int err = 0 ; unsigned int max_write_size = work -> conn -> vals -> max_write_size ; WORK_BUFFERS ( work , req , rsp ) ; if ( test_share_config_flag ( work -> tcon -> share_conf , KSMBD_SHARE_FLAG_PIPE ) ) { ksmbd_debug ( SMB , "IPC pipe write request\n" ) ; return smb2_write_pipe ( work ) ; } offset = le64_to_cpu ( req -> Offset ) ; length = le32_to_cpu ( req -> Length ) ; if ( req -> Channel == SMB2_CHANNEL_RDMA_V1 || req -> Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE ) { is_rdma_channel = true ; max_write_size = get_smbd_max_read_write_size ( ) ; length = le32_to_cpu ( req -> RemainingBytes ) ; } if ( is_rdma_channel == true ) { unsigned int ch_offset = le16_to_cpu ( req -> WriteChannelInfoOffset ) ; if ( req -> Length != 0 || req -> DataOffset != 0 || ch_offset < offsetof ( struct smb2_write_req , Buffer ) ) { err = - EINVAL ; goto out ; } err = smb2_set_remote_key_for_rdma ( work , ( struct smb2_buffer_desc_v1 * ) ( ( char * ) req + ch_offset ) , req -> Channel , req -> WriteChannelInfoLength ) ; if ( err ) goto out ; } if ( ! test_tree_conn_flag ( work -> tcon , KSMBD_TREE_CONN_FLAG_WRITABLE ) ) { ksmbd_debug ( SMB , "User does not have write permission\n" ) ; err = - EACCES ; goto out ; } fp = ksmbd_lookup_fd_slow ( work , req -> VolatileFileId , req -> PersistentFileId ) ; if ( ! fp ) { err = - ENOENT ; goto out ; } if ( ! ( fp -> daccess & ( FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE ) ) ) { pr_err ( "Not permitted to write : 0x%x\n" , fp -> daccess ) ; err = - EACCES ; goto out ; } if ( length > max_write_size ) { ksmbd_debug ( SMB , "limiting write size to max size(%u)\n" , max_write_size ) ; err = - EINVAL ; goto out ; } ksmbd_debug ( SMB , "flags %u\n" , le32_to_cpu ( req -> Flags ) ) ; if ( le32_to_cpu ( req -> Flags ) & SMB2_WRITEFLAG_WRITE_THROUGH ) writethrough = true ; if ( is_rdma_channel == false ) { if ( ( u64 ) le16_to_cpu ( req -> DataOffset ) + length > get_rfc1002_len ( work -> request_buf ) ) { pr_err ( "invalid write data offset %u, smb_len %u\n" , le16_to_cpu ( req -> DataOffset ) , get_rfc1002_len ( work -> request_buf ) ) ; err = - EINVAL ; goto out ; } data_buf = ( char * ) ( ( ( char * ) & req -> hdr . ProtocolId ) + le16_to_cpu ( req -> DataOffset ) ) ; ksmbd_debug ( SMB , "filename %pd, offset %lld, len %zu\n" , fp -> filp -> f_path . dentry , offset , length ) ; err = ksmbd_vfs_write ( work , fp , data_buf , length , & offset , writethrough , & nbytes ) ; if ( err < 0 ) goto out ; } else { nbytes = smb2_write_rdma_channel ( work , req , fp , offset , length , writethrough ) ; if ( nbytes < 0 ) { err = ( int ) nbytes ; goto out ; } } rsp -> StructureSize = cpu_to_le16 ( 17 ) ; rsp -> DataOffset = 0 ; rsp -> Reserved = 0 ; rsp -> DataLength = cpu_to_le32 ( nbytes ) ; rsp -> DataRemaining = 0 ; rsp -> Reserved2 = 0 ; inc_rfc1001_len ( work -> response_buf , 16 ) ; ksmbd_fd_put ( work , fp ) ; return 0 ; out : if ( err == - EAGAIN ) rsp -> hdr . Status = STATUS_FILE_LOCK_CONFLICT ; else if ( err == - ENOSPC || err == - EFBIG ) rsp -> hdr . Status = STATUS_DISK_FULL ; else if ( err == - ENOENT ) rsp -> hdr . Status = STATUS_FILE_CLOSED ; else if ( err == - EACCES ) rsp -> hdr . Status = STATUS_ACCESS_DENIED ; else if ( err == - ESHARE ) rsp -> hdr . Status = STATUS_SHARING_VIOLATION ; else if ( err == - EINVAL ) rsp -> hdr . Status = STATUS_INVALID_PARAMETER ; else rsp -> hdr . Status = STATUS_INVALID_HANDLE ; smb2_set_err_rsp ( work ) ; ksmbd_fd_put ( work , fp ) ; return err ; }
void Node :: ClearInputs ( int start , int count ) { Node * * input_ptr = GetInputPtr ( start ) ; Use * use_ptr = GetUsePtr ( start ) ; while ( count -- > 0 ) { DCHECK_EQ ( input_ptr , use_ptr -> input_ptr ( ) ) ; Node * input = * input_ptr ; * input_ptr = nullptr ; if ( input ) input -> RemoveUse ( use_ptr ) ; input_ptr ++ ; use_ptr -- ; } Verify ( ) ; }
yydestruct ( const char * yymsg , int yytype , YYSTYPE * yyvaluep , void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { YYUSE ( yyvaluep ) ; YYUSE ( yyscanner ) ; YYUSE ( lex_env ) ; if ( ! yymsg ) yymsg = "Deleting" ; YY_SYMBOL_PRINT ( yymsg , yytype , yyvaluep , yylocationp ) ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN switch ( yytype ) { case 16 : #line 94 "hex_grammar.y" /* yacc.c:1257  */ { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } #line 1023 "hex_grammar.c" /* yacc.c:1257  */ break ; case 17 : #line 95 "hex_grammar.y" /* yacc.c:1257  */ { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } #line 1029 "hex_grammar.c" /* yacc.c:1257  */ break ; case 18 : #line 96 "hex_grammar.y" /* yacc.c:1257  */ { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } #line 1035 "hex_grammar.c" /* yacc.c:1257  */ break ; case 19 : #line 97 "hex_grammar.y" /* yacc.c:1257  */ { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } #line 1041 "hex_grammar.c" /* yacc.c:1257  */ break ; case 21 : #line 100 "hex_grammar.y" /* yacc.c:1257  */ { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } #line 1047 "hex_grammar.c" /* yacc.c:1257  */ break ; case 22 : #line 99 "hex_grammar.y" /* yacc.c:1257  */ { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } #line 1053 "hex_grammar.c" /* yacc.c:1257  */ break ; case 23 : #line 98 "hex_grammar.y" /* yacc.c:1257  */ { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } #line 1059 "hex_grammar.c" /* yacc.c:1257  */ break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END }
IonBuilder :: jsop_getelem_typed ( MDefinition * obj , MDefinition * index , ScalarTypeDescr :: Type arrayType ) { types :: TemporaryTypeSet * types = bytecodeTypes ( pc ) ; bool maybeUndefined = types -> hasType ( types :: Type :: UndefinedType ( ) ) ; bool allowDouble = types -> hasType ( types :: Type :: DoubleType ( ) ) ; MInstruction * idInt32 = MToInt32 :: New ( alloc ( ) , index ) ; current -> add ( idInt32 ) ; index = idInt32 ; if ( ! maybeUndefined ) { MIRType knownType = MIRTypeForTypedArrayRead ( arrayType , allowDouble ) ; MInstruction * length = getTypedArrayLength ( obj ) ; current -> add ( length ) ; index = addBoundsCheck ( index , length ) ; MInstruction * elements = getTypedArrayElements ( obj ) ; current -> add ( elements ) ; MLoadTypedArrayElement * load = MLoadTypedArrayElement :: New ( alloc ( ) , elements , index , arrayType ) ; current -> add ( load ) ; current -> push ( load ) ; load -> setResultType ( knownType ) ; return true ; } else { BarrierKind barrier = BarrierKind :: TypeSet ; switch ( arrayType ) { case ScalarTypeDescr :: TYPE_INT8 : case ScalarTypeDescr :: TYPE_UINT8 : case ScalarTypeDescr :: TYPE_UINT8_CLAMPED : case ScalarTypeDescr :: TYPE_INT16 : case ScalarTypeDescr :: TYPE_UINT16 : case ScalarTypeDescr :: TYPE_INT32 : case ScalarTypeDescr :: TYPE_UINT32 : if ( types -> hasType ( types :: Type :: Int32Type ( ) ) ) barrier = BarrierKind :: NoBarrier ; break ; case ScalarTypeDescr :: TYPE_FLOAT32 : case ScalarTypeDescr :: TYPE_FLOAT64 : if ( allowDouble ) barrier = BarrierKind :: NoBarrier ; break ; default : MOZ_ASSUME_UNREACHABLE ( "Unknown typed array type" ) ; } MLoadTypedArrayElementHole * load = MLoadTypedArrayElementHole :: New ( alloc ( ) , obj , index , arrayType , allowDouble ) ; current -> add ( load ) ; current -> push ( load ) ; return pushTypeBarrier ( load , types , barrier ) ; } }
static int prealloc_elems_and_freelist ( struct bpf_stack_map * smap ) { u32 elem_size = sizeof ( struct stack_map_bucket ) + smap -> map . value_size ; int err ; smap -> elems = bpf_map_area_alloc ( elem_size * smap -> map . max_entries , smap -> map . numa_node ) ; if ( ! smap -> elems ) return - ENOMEM ; err = pcpu_freelist_init ( & smap -> freelist ) ; if ( err ) goto free_elems ; pcpu_freelist_populate ( & smap -> freelist , smap -> elems , elem_size , smap -> map . max_entries ) ; return 0 ; free_elems : bpf_map_area_free ( smap -> elems ) ; return err ; }
void WasmGraphBuilder :: AddBytecodePositionDecorator ( NodeOriginTable * node_origins , wasm :: Decoder * decoder ) { DCHECK_NULL ( decorator_ ) ; decorator_ = new ( graph ( ) -> zone ( ) ) WasmDecorator ( node_origins , decoder ) ; graph ( ) -> AddDecorator ( decorator_ ) ; }
CpuProfile * CpuProfilesCollection :: StopProfiling ( const char * title ) { const int title_len = StrLength ( title ) ; CpuProfile * profile = nullptr ; current_profiles_semaphore_ . Wait ( ) ; auto it = std :: find_if ( current_profiles_ . rbegin ( ) , current_profiles_ . rend ( ) , [ & ] ( const std :: unique_ptr < CpuProfile > & p ) { return title_len == 0 || strcmp ( p -> title ( ) , title ) == 0 ; } ) ; if ( it != current_profiles_ . rend ( ) ) { ( * it ) -> FinishProfile ( ) ; profile = it -> get ( ) ; finished_profiles_ . push_back ( std :: move ( * it ) ) ; current_profiles_ . erase ( -- ( it . base ( ) ) ) ; } current_profiles_semaphore_ . Signal ( ) ; return profile ; }
std :: ostream & operator < < ( std :: ostream & os , const GrowFastElementsParameters & params ) { os < < params . mode ( ) ; if ( params . feedback ( ) . IsValid ( ) ) { os < < params . feedback ( ) ; } return os ; }
Handle < Context > Factory :: NewModuleContext ( Handle < Module > module , Handle < NativeContext > outer , Handle < ScopeInfo > scope_info ) { DCHECK_EQ ( scope_info -> scope_type ( ) , MODULE_SCOPE ) ; Handle < Context > context = NewFixedArrayWithMap < Context > ( Heap :: kModuleContextMapRootIndex , scope_info -> ContextLength ( ) , TENURED ) ; context -> set_scope_info ( * scope_info ) ; context -> set_previous ( * outer ) ; context -> set_extension ( * module ) ; context -> set_native_context ( * outer ) ; DCHECK ( context -> IsModuleContext ( ) ) ; return context ; }
const char * ICStats :: GetOrCacheFunctionName ( JSFunction * function ) { if ( function_name_map_ . find ( function ) != function_name_map_ . end ( ) ) { return function_name_map_ [ function ] . get ( ) ; } SharedFunctionInfo * shared = function -> shared ( ) ; ic_infos_ [ pos_ ] . is_optimized = function -> IsOptimized ( ) ; char * function_name = shared -> DebugName ( ) -> ToCString ( ) . release ( ) ; function_name_map_ . insert ( std :: make_pair ( function , std :: unique_ptr < char [ ] > ( function_name ) ) ) ; return function_name ; }
void CPCIDSKBinarySegment :: Load ( ) { if ( loaded_ ) { return ; } seg_data . SetSize ( ( int ) data_size - 1024 ) ; ReadFromFile ( seg_data . buffer , 0 , data_size - 1024 ) ; loaded_ = true ; }
void AudioFlinger :: DuplicatingThread :: removeOutputTrack ( MixerThread * thread ) { Mutex :: Autolock _l ( mLock ) ; for ( size_t i = 0 ; i < mOutputTracks . size ( ) ; i ++ ) { if ( mOutputTracks [ i ] -> thread ( ) == thread ) { mOutputTracks [ i ] -> destroy ( ) ; mOutputTracks . removeAt ( i ) ; updateWaitTime_l ( ) ; return ; } } ALOGV ( "removeOutputTrack(): unkonwn thread: %p" , thread ) ; }
Reduction JSNativeContextSpecialization :: ReduceJSAdd ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSAdd , node -> opcode ( ) ) ; HeapObjectBinopMatcher m ( node ) ; if ( m . left ( ) . HasValue ( ) && m . left ( ) . Value ( ) -> IsString ( ) && m . right ( ) . HasValue ( ) && m . right ( ) . Value ( ) -> IsString ( ) ) { Handle < String > left = Handle < String > :: cast ( m . left ( ) . Value ( ) ) ; Handle < String > right = Handle < String > :: cast ( m . right ( ) . Value ( ) ) ; if ( left -> length ( ) + right -> length ( ) <= String :: kMaxLength ) { Handle < String > result = factory ( ) -> NewConsString ( left , right ) . ToHandleChecked ( ) ; Node * value = jsgraph ( ) -> HeapConstant ( result ) ; ReplaceWithValue ( node , value ) ; return Replace ( value ) ; } } return NoChange ( ) ; }
xmlXPathStringEvalNumber ( const xmlChar * str ) { const xmlChar * cur = str ; double ret ; int ok = 0 ; int isneg = 0 ; int exponent = 0 ; int is_exponent_negative = 0 ; #ifdef __GNUC__ unsigned long tmp = 0 ; double temp ; #endif if ( cur == NULL ) return ( 0 ) ; while ( IS_BLANK_CH ( * cur ) ) cur ++ ; if ( ( * cur != '.' ) && ( ( * cur < '0' ) || ( * cur > '9' ) ) && ( * cur != '-' ) ) { return ( xmlXPathNAN ) ; } if ( * cur == '-' ) { isneg = 1 ; cur ++ ; } #ifdef __GNUC__ ret = 0 ; while ( ( * cur >= '0' ) && ( * cur <= '9' ) ) { ret = ret * 10 ; tmp = ( * cur - '0' ) ; ok = 1 ; cur ++ ; temp = ( double ) tmp ; ret = ret + temp ; } #else ret = 0 ; while ( ( * cur >= '0' ) && ( * cur <= '9' ) ) { ret = ret * 10 + ( * cur - '0' ) ; ok = 1 ; cur ++ ; } #endif if ( * cur == '.' ) { int v , frac = 0 ; double fraction = 0 ; cur ++ ; if ( ( ( * cur < '0' ) || ( * cur > '9' ) ) && ( ! ok ) ) { return ( xmlXPathNAN ) ; } while ( ( ( * cur >= '0' ) && ( * cur <= '9' ) ) && ( frac < MAX_FRAC ) ) { v = ( * cur - '0' ) ; fraction = fraction * 10 + v ; frac = frac + 1 ; cur ++ ; } fraction /= my_pow10 [ frac ] ; ret = ret + fraction ; while ( ( * cur >= '0' ) && ( * cur <= '9' ) ) cur ++ ; } if ( ( * cur == 'e' ) || ( * cur == 'E' ) ) { cur ++ ; if ( * cur == '-' ) { is_exponent_negative = 1 ; cur ++ ; } else if ( * cur == '+' ) { cur ++ ; } while ( ( * cur >= '0' ) && ( * cur <= '9' ) ) { exponent = exponent * 10 + ( * cur - '0' ) ; cur ++ ; } } while ( IS_BLANK_CH ( * cur ) ) cur ++ ; if ( * cur != 0 ) return ( xmlXPathNAN ) ; if ( isneg ) ret = - ret ; if ( is_exponent_negative ) exponent = - exponent ; ret *= pow ( 10.0 , ( double ) exponent ) ; return ( ret ) ; }
void AsmJsParser :: ValidateFunction ( ) { EXPECT_TOKEN ( TOK ( function ) ) ; if ( ! scanner_ . IsGlobal ( ) ) { FAIL ( "Expected function name" ) ; } Vector < const char > function_name_str = CopyCurrentIdentifierString ( ) ; AsmJsScanner :: token_t function_name = Consume ( ) ; VarInfo * function_info = GetVarInfo ( function_name ) ; if ( function_info -> kind == VarKind :: kUnused ) { function_info -> kind = VarKind :: kFunction ; function_info -> function_builder = module_builder_ -> AddFunction ( ) ; function_info -> index = function_info -> function_builder -> func_index ( ) ; function_info -> mutable_variable = false ; } else if ( function_info -> kind != VarKind :: kFunction ) { FAIL ( "Function name collides with variable" ) ; } else if ( function_info -> function_defined ) { FAIL ( "Function redefined" ) ; } function_info -> function_defined = true ; function_info -> function_builder -> SetName ( function_name_str ) ; current_function_builder_ = function_info -> function_builder ; return_type_ = nullptr ; current_function_builder_ -> SetAsmFunctionStartPosition ( scanner_ . Position ( ) ) ; CachedVector < AsmType * > params ( cached_asm_type_p_vectors_ ) ; ValidateFunctionParams ( & params ) ; if ( params . size ( ) >= kV8MaxWasmFunctionParams ) { FAIL ( "Number of parameters exceeds internal limit" ) ; } CachedVector < ValueType > locals ( cached_valuetype_vectors_ ) ; ValidateFunctionLocals ( params . size ( ) , & locals ) ; function_temp_locals_offset_ = static_cast < uint32_t > ( params . size ( ) + locals . size ( ) ) ; function_temp_locals_used_ = 0 ; function_temp_locals_depth_ = 0 ; bool last_statement_is_return = false ; while ( ! failed_ && ! Peek ( '}' ) ) { last_statement_is_return = Peek ( TOK ( return ) ) ; RECURSE ( ValidateStatement ( ) ) ; } EXPECT_TOKEN ( '}' ) ; if ( ! last_statement_is_return ) { if ( return_type_ == nullptr ) { return_type_ = AsmType :: Void ( ) ; } else if ( ! return_type_ -> IsA ( AsmType :: Void ( ) ) ) { FAIL ( "Expected return at end of non-void function" ) ; } } DCHECK_NOT_NULL ( return_type_ ) ; FunctionSig * sig = ConvertSignature ( return_type_ , params ) ; current_function_builder_ -> SetSignature ( sig ) ; for ( auto local : locals ) { current_function_builder_ -> AddLocal ( local ) ; } for ( int i = 0 ; i < function_temp_locals_used_ ; ++ i ) { current_function_builder_ -> AddLocal ( kWasmI32 ) ; } if ( locals . size ( ) + function_temp_locals_used_ > kV8MaxWasmFunctionLocals ) { FAIL ( "Number of local variables exceeds internal limit" ) ; } current_function_builder_ -> Emit ( kExprEnd ) ; AsmType * function_type = AsmType :: Function ( zone ( ) , return_type_ ) ; for ( auto t : params ) { function_type -> AsFunctionType ( ) -> AddArgument ( t ) ; } function_info = GetVarInfo ( function_name ) ; if ( function_info -> type -> IsA ( AsmType :: None ( ) ) ) { DCHECK_EQ ( function_info -> kind , VarKind :: kFunction ) ; function_info -> type = function_type ; } else if ( ! function_type -> IsA ( function_info -> type ) ) { FAIL ( "Function definition doesn't match use" ) ; } scanner_ . ResetLocals ( ) ; local_var_info_ . clear ( ) ; }
Node * WasmGraphBuilder :: Throw ( uint32_t tag , const wasm :: WasmException * exception , const Vector < Node * > values ) { SetNeedsStackCheck ( ) ; uint32_t encoded_size = GetExceptionEncodedSize ( exception ) ; Node * create_parameters [ ] = { BuildChangeUint31ToSmi ( ConvertExceptionTagToRuntimeId ( tag ) ) , BuildChangeUint31ToSmi ( Uint32Constant ( encoded_size ) ) } ; BuildCallToRuntime ( Runtime :: kWasmThrowCreate , create_parameters , arraysize ( create_parameters ) ) ; uint32_t index = 0 ; const wasm :: WasmExceptionSig * sig = exception -> sig ; MachineOperatorBuilder * m = mcgraph ( ) -> machine ( ) ; for ( size_t i = 0 ; i < sig -> parameter_count ( ) ; ++ i ) { Node * value = values [ i ] ; switch ( sig -> GetParam ( i ) ) { case wasm :: kWasmF32 : value = graph ( ) -> NewNode ( m -> BitcastFloat32ToInt32 ( ) , value ) ; V8_FALLTHROUGH ; case wasm :: kWasmI32 : BuildEncodeException32BitValue ( & index , value ) ; break ; case wasm :: kWasmF64 : value = graph ( ) -> NewNode ( m -> BitcastFloat64ToInt64 ( ) , value ) ; V8_FALLTHROUGH ; case wasm :: kWasmI64 : { Node * upper32 = graph ( ) -> NewNode ( m -> TruncateInt64ToInt32 ( ) , Binop ( wasm :: kExprI64ShrU , value , Int64Constant ( 32 ) ) ) ; BuildEncodeException32BitValue ( & index , upper32 ) ; Node * lower32 = graph ( ) -> NewNode ( m -> TruncateInt64ToInt32 ( ) , value ) ; BuildEncodeException32BitValue ( & index , lower32 ) ; break ; } default : UNREACHABLE ( ) ; } } DCHECK_EQ ( encoded_size , index ) ; return BuildCallToRuntime ( Runtime :: kWasmThrow , nullptr , 0 ) ; }
Run ( JSContext * cx , unsigned argc , jsval * vp ) { CallArgs args = CallArgsFromVp ( argc , vp ) ; if ( args . length ( ) != 1 ) { JS_ReportErrorNumber ( cx , my_GetErrorMessage , nullptr , JSSMSG_INVALID_ARGS , "run" ) ; return false ; } RootedObject thisobj ( cx , JS_THIS_OBJECT ( cx , vp ) ) ; if ( ! thisobj ) return false ; RootedString str ( cx , JS :: ToString ( cx , args [ 0 ] ) ) ; if ( ! str ) return false ; args [ 0 ] . setString ( str ) ; JSAutoByteString filename ( cx , str ) ; if ( ! filename ) return false ; str = FileAsString ( cx , filename . ptr ( ) ) ; if ( ! str ) return false ; AutoStableStringChars chars ( cx ) ; if ( ! chars . initTwoByte ( cx , str ) ) return false ; const jschar * ucbuf = chars . twoByteRange ( ) . start ( ) . get ( ) ; size_t buflen = str -> length ( ) ; JS :: Anchor < JSString * > a_str ( str ) ; RootedScript script ( cx ) ; int64_t startClock = PRMJ_Now ( ) ; { JS :: AutoSaveContextOptions asco ( cx ) ; JS :: ContextOptionsRef ( cx ) . setNoScriptRval ( true ) ; JS :: CompileOptions options ( cx ) ; options . setIntroductionType ( "js shell run" ) . setFileAndLine ( filename . ptr ( ) , 1 ) . setCompileAndGo ( true ) ; script = JS_CompileUCScript ( cx , thisobj , ucbuf , buflen , options ) ; if ( ! script ) return false ; } if ( ! JS_ExecuteScript ( cx , thisobj , script ) ) return false ; int64_t endClock = PRMJ_Now ( ) ; args . rval ( ) . setDouble ( ( endClock - startClock ) / double ( PRMJ_USEC_PER_MSEC ) ) ; return true ; }
static OPJ_BOOL opj_jp2_read_cmap ( opj_jp2_t * jp2 , OPJ_BYTE * p_cmap_header_data , OPJ_UINT32 p_cmap_header_size , opj_event_mgr_t * p_manager ) { opj_jp2_cmap_comp_t * cmap ; OPJ_BYTE i , nr_channels ; OPJ_UINT32 l_value ; assert ( jp2 != 00 ) ; assert ( p_cmap_header_data != 00 ) ; assert ( p_manager != 00 ) ; ( void ) p_cmap_header_size ; if ( jp2 -> color . jp2_pclr == NULL ) { opj_event_msg ( p_manager , EVT_ERROR , "Need to read a PCLR box before the CMAP box.\n" ) ; return OPJ_FALSE ; } if ( jp2 -> color . jp2_pclr -> cmap ) { opj_event_msg ( p_manager , EVT_ERROR , "Only one CMAP box is allowed.\n" ) ; return OPJ_FALSE ; } nr_channels = jp2 -> color . jp2_pclr -> nr_channels ; if ( p_cmap_header_size < ( OPJ_UINT32 ) nr_channels * 4 ) { opj_event_msg ( p_manager , EVT_ERROR , "Insufficient data for CMAP box.\n" ) ; return OPJ_FALSE ; } cmap = ( opj_jp2_cmap_comp_t * ) opj_malloc ( nr_channels * sizeof ( opj_jp2_cmap_comp_t ) ) ; if ( ! cmap ) return OPJ_FALSE ; for ( i = 0 ; i < nr_channels ; ++ i ) { opj_read_bytes ( p_cmap_header_data , & l_value , 2 ) ; p_cmap_header_data += 2 ; cmap [ i ] . cmp = ( OPJ_UINT16 ) l_value ; opj_read_bytes ( p_cmap_header_data , & l_value , 1 ) ; ++ p_cmap_header_data ; cmap [ i ] . mtyp = ( OPJ_BYTE ) l_value ; opj_read_bytes ( p_cmap_header_data , & l_value , 1 ) ; ++ p_cmap_header_data ; cmap [ i ] . pcol = ( OPJ_BYTE ) l_value ; } jp2 -> color . jp2_pclr -> cmap = cmap ; return OPJ_TRUE ; }
SVGPathSegListSMILType :: Interpolate ( const nsSMILValue & aStartVal , const nsSMILValue & aEndVal , double aUnitDistance , nsSMILValue & aResult ) const { NS_PRECONDITION ( aStartVal . mType == aEndVal . mType , "Trying to interpolate different types" ) ; NS_PRECONDITION ( aStartVal . mType == this , "Unexpected types for interpolation" ) ; NS_PRECONDITION ( aResult . mType == this , "Unexpected result type" ) ; const SVGPathDataAndInfo & start = * static_cast < const SVGPathDataAndInfo * > ( aStartVal . mU . mPtr ) ; const SVGPathDataAndInfo & end = * static_cast < const SVGPathDataAndInfo * > ( aEndVal . mU . mPtr ) ; SVGPathDataAndInfo & result = * static_cast < SVGPathDataAndInfo * > ( aResult . mU . mPtr ) ; MOZ_ASSERT ( result . IsIdentity ( ) , "expecting outparam to start out as identity" ) ; PathInterpolationResult check = CanInterpolate ( start , end ) ; if ( check == eCannotInterpolate ) { return NS_ERROR_FAILURE ; } const SVGPathDataAndInfo * startListToUse = & start ; if ( check == eRequiresConversion ) { DebugOnly < bool > success = result . SetLength ( end . Length ( ) ) ; MOZ_ASSERT ( success , "infallible nsTArray::SetLength should succeed" ) ; result . SetElement ( end . Element ( ) ) ; ConvertAllPathSegmentData ( start . begin ( ) , start . end ( ) , end . begin ( ) , end . end ( ) , result . begin ( ) ) ; startListToUse = & result ; } AddWeightedPathSegLists ( 1.0 - aUnitDistance , * startListToUse , aUnitDistance , end , result ) ; return NS_OK ; }
nsPasswordManager :: ReadPasswords ( nsIFile * aPasswordFile ) { nsCOMPtr < nsIInputStream > fileStream ; NS_NewLocalFileInputStream ( getter_AddRefs ( fileStream ) , aPasswordFile ) ; if ( ! fileStream ) return NS_ERROR_OUT_OF_MEMORY ; nsCOMPtr < nsILineInputStream > lineStream = do_QueryInterface ( fileStream ) ; NS_ASSERTION ( lineStream , "File stream is not an nsILineInputStream" ) ; nsCAutoString utf8Buffer ; PRBool moreData = PR_FALSE ; nsresult rv = lineStream -> ReadLine ( utf8Buffer , & moreData ) ; if ( NS_FAILED ( rv ) ) return NS_OK ; if ( ! utf8Buffer . Equals ( "#2c" ) ) { NS_ERROR ( "Unexpected version header in signon file" ) ; return NS_OK ; } enum { STATE_REJECT , STATE_REALM , STATE_USERFIELD , STATE_USERVALUE , STATE_PASSFIELD , STATE_PASSVALUE } state = STATE_REJECT ; nsCAutoString realm ; SignonDataEntry * entry = nsnull ; PRBool writeOnFinish = PR_FALSE ; do { rv = lineStream -> ReadLine ( utf8Buffer , & moreData ) ; if ( NS_FAILED ( rv ) ) return NS_OK ; switch ( state ) { case STATE_REJECT : if ( utf8Buffer . Equals ( NS_LITERAL_CSTRING ( "." ) ) ) state = STATE_REALM ; else mRejectTable . Put ( utf8Buffer , 1 ) ; break ; case STATE_REALM : realm . Assign ( utf8Buffer ) ; state = STATE_USERFIELD ; break ; case STATE_USERFIELD : if ( entry ) { if ( entry -> userValue . IsEmpty ( ) && entry -> passValue . IsEmpty ( ) ) { NS_WARNING ( "Discarding empty password entry" ) ; writeOnFinish = PR_TRUE ; delete entry ; } else { AddSignonData ( realm , entry ) ; } } if ( utf8Buffer . Equals ( NS_LITERAL_CSTRING ( "." ) ) ) { entry = nsnull ; state = STATE_REALM ; } else { entry = new SignonDataEntry ( ) ; CopyUTF8toUTF16 ( utf8Buffer , entry -> userField ) ; state = STATE_USERVALUE ; } break ; case STATE_USERVALUE : NS_ASSERTION ( entry , "bad state" ) ; CopyUTF8toUTF16 ( utf8Buffer , entry -> userValue ) ; state = STATE_PASSFIELD ; break ; case STATE_PASSFIELD : NS_ASSERTION ( entry , "bad state" ) ; CopyUTF8toUTF16 ( Substring ( utf8Buffer , 1 , utf8Buffer . Length ( ) - 1 ) , entry -> passField ) ; state = STATE_PASSVALUE ; break ; case STATE_PASSVALUE : NS_ASSERTION ( entry , "bad state" ) ; CopyUTF8toUTF16 ( utf8Buffer , entry -> passValue ) ; state = STATE_USERFIELD ; break ; } } while ( moreData ) ; delete entry ; if ( writeOnFinish ) { fileStream -> Close ( ) ; WritePasswords ( mSignonFile ) ; } return NS_OK ; }
void LocalEmbedderHeapTracer :: EnterFinalPause ( ) { if ( ! InUse ( ) ) return ; remote_tracer_ -> EnterFinalPause ( embedder_stack_state_ ) ; embedder_stack_state_ = EmbedderHeapTracer :: kUnknown ; }
void nsWindow :: OnSizeAllocate ( GtkAllocation * aAllocation ) { LOG ( "nsWindow::OnSizeAllocate %d,%d -> %d x %d\n" , aAllocation -> x , aAllocation -> y , aAllocation -> width , aAllocation -> height ) ; if ( mGtkWindowDecoration == GTK_DECORATION_CLIENT ) { if ( GdkIsWaylandDisplay ( ) || ( GdkIsX11Display ( ) && mDrawInTitlebar ) ) { UpdateClientOffsetFromCSDWindow ( ) ; } } mBoundsAreValid = true ; LayoutDeviceIntSize size = GdkRectToDevicePixels ( * aAllocation ) . Size ( ) ; if ( mBounds . Size ( ) == size ) { LOG ( "  Already the same size" ) ; return ; } if ( mGdkWindow ) { if ( mBounds . width < size . width ) { GdkRectangle rect = DevicePixelsToGdkRectRoundOut ( LayoutDeviceIntRect ( mBounds . width , 0 , size . width - mBounds . width , size . height ) ) ; gdk_window_invalidate_rect ( mGdkWindow , & rect , FALSE ) ; } if ( mBounds . height < size . height ) { GdkRectangle rect = DevicePixelsToGdkRectRoundOut ( LayoutDeviceIntRect ( 0 , mBounds . height , size . width , size . height - mBounds . height ) ) ; gdk_window_invalidate_rect ( mGdkWindow , & rect , FALSE ) ; } } mBounds . SizeTo ( size ) ; if ( mCompositorSession && ! wr :: WindowSizeSanityCheck ( mBounds . width , mBounds . height ) ) { gfxCriticalNoteOnce < < "Invalid mBounds in OnSizeAllocate " < < mBounds < < " size state " < < mSizeState ; } if ( mCompositorWidgetDelegate ) { mCompositorWidgetDelegate -> NotifyClientSizeChanged ( GetClientSize ( ) ) ; } mNeedsDispatchResized = true ; NS_DispatchToCurrentThread ( NewRunnableMethod ( "nsWindow::MaybeDispatchResized" , this , & nsWindow :: MaybeDispatchResized ) ) ; }
void LoadIC :: UpdateCaches ( LookupIterator * lookup ) { if ( state ( ) == UNINITIALIZED ) { if ( UseVector ( ) ) { ConfigureVectorState ( PREMONOMORPHIC ) ; } else { set_target ( * pre_monomorphic_stub ( ) ) ; } TRACE_IC ( "LoadIC" , lookup -> name ( ) ) ; return ; } Handle < Code > code ; if ( lookup -> state ( ) == LookupIterator :: JSPROXY || lookup -> state ( ) == LookupIterator :: ACCESS_CHECK ) { code = slow_stub ( ) ; } else if ( ! lookup -> IsFound ( ) ) { if ( kind ( ) == Code :: LOAD_IC ) { code = NamedLoadHandlerCompiler :: ComputeLoadNonexistent ( lookup -> name ( ) , receiver_map ( ) ) ; if ( code . is_null ( ) ) code = slow_stub ( ) ; } else { code = slow_stub ( ) ; } } else { if ( lookup -> state ( ) == LookupIterator :: ACCESSOR ) { Handle < Object > accessors = lookup -> GetAccessors ( ) ; Handle < Map > map = receiver_map ( ) ; if ( accessors -> IsExecutableAccessorInfo ( ) ) { Handle < ExecutableAccessorInfo > info = Handle < ExecutableAccessorInfo > :: cast ( accessors ) ; if ( ( v8 :: ToCData < Address > ( info -> getter ( ) ) != 0 ) && ! ExecutableAccessorInfo :: IsCompatibleReceiverMap ( isolate ( ) , info , map ) ) { TRACE_GENERIC_IC ( isolate ( ) , "LoadIC" , "incompatible receiver type" ) ; code = slow_stub ( ) ; } } else if ( accessors -> IsAccessorPair ( ) ) { Handle < Object > getter ( Handle < AccessorPair > :: cast ( accessors ) -> getter ( ) , isolate ( ) ) ; Handle < JSObject > holder = lookup -> GetHolder < JSObject > ( ) ; Handle < Object > receiver = lookup -> GetReceiver ( ) ; if ( getter -> IsJSFunction ( ) && holder -> HasFastProperties ( ) ) { Handle < JSFunction > function = Handle < JSFunction > :: cast ( getter ) ; if ( receiver -> IsJSObject ( ) || function -> IsBuiltin ( ) || ! is_sloppy ( function -> shared ( ) -> language_mode ( ) ) ) { CallOptimization call_optimization ( function ) ; if ( call_optimization . is_simple_api_call ( ) && ! call_optimization . IsCompatibleReceiver ( receiver , holder ) ) { TRACE_GENERIC_IC ( isolate ( ) , "LoadIC" , "incompatible receiver type" ) ; code = slow_stub ( ) ; } } } } } if ( code . is_null ( ) ) code = ComputeHandler ( lookup ) ; } PatchCache ( lookup -> name ( ) , code ) ; TRACE_IC ( "LoadIC" , lookup -> name ( ) ) ; }
void RegExpMacroAssemblerPPC :: LoadCurrentCharacterUnchecked ( int cp_offset , int characters ) { Register offset = current_input_offset ( ) ; if ( cp_offset != 0 ) { __ addi ( r25 , current_input_offset ( ) , Operand ( cp_offset * char_size ( ) ) ) ; offset = r25 ; } __ add ( current_character ( ) , end_of_input_address ( ) , offset ) ; #if V8_TARGET_LITTLE_ENDIAN if ( mode_ == LATIN1 ) { if ( characters == 4 ) { __ lwz ( current_character ( ) , MemOperand ( current_character ( ) ) ) ; } else if ( characters == 2 ) { __ lhz ( current_character ( ) , MemOperand ( current_character ( ) ) ) ; } else { DCHECK_EQ ( 1 , characters ) ; __ lbz ( current_character ( ) , MemOperand ( current_character ( ) ) ) ; } } else { DCHECK ( mode_ == UC16 ) ; if ( characters == 2 ) { __ lwz ( current_character ( ) , MemOperand ( current_character ( ) ) ) ; } else { DCHECK_EQ ( 1 , characters ) ; __ lhz ( current_character ( ) , MemOperand ( current_character ( ) ) ) ; } } #else if ( mode_ == LATIN1 ) { if ( characters == 4 ) { __ lwbrx ( current_character ( ) , MemOperand ( r0 , current_character ( ) ) ) ; } else if ( characters == 2 ) { __ lhbrx ( current_character ( ) , MemOperand ( r0 , current_character ( ) ) ) ; } else { DCHECK_EQ ( 1 , characters ) ; __ lbz ( current_character ( ) , MemOperand ( current_character ( ) ) ) ; } } else { DCHECK ( mode_ == UC16 ) ; if ( characters == 2 ) { __ lwz ( current_character ( ) , MemOperand ( current_character ( ) ) ) ; __ rlwinm ( current_character ( ) , current_character ( ) , 16 , 0 , 31 ) ; } else { DCHECK_EQ ( 1 , characters ) ; __ lhz ( current_character ( ) , MemOperand ( current_character ( ) ) ) ; } } #endif }
explicit DataFormatVecPermuteOp ( OpKernelConstruction * context ) : OpKernel ( context ) { string src_format ; OP_REQUIRES_OK ( context , context -> GetAttr ( "src_format" , & src_format ) ) ; string dst_format ; OP_REQUIRES_OK ( context , context -> GetAttr ( "dst_format" , & dst_format ) ) ; src_format_ = src_format ; dst_format_ = dst_format ; }
} MapObject * MapObject :: create ( JSContext * cx , HandleObject proto ) { auto map = cx -> make_unique < ValueMap > ( cx -> runtime ( ) ) ; if ( ! map || ! map -> init ( ) ) { ReportOutOfMemory ( cx ) ; return nullptr ; } MapObject * mapObj = NewObjectWithClassProto < MapObject > ( cx , proto ) ; if ( ! mapObj ) return nullptr ; mapObj -> setPrivate ( map . release ( ) ) ;
void WebAssemblyInstantiate ( const v8 :: FunctionCallbackInfo < v8 :: Value > & args ) { v8 :: Isolate * isolate = args . GetIsolate ( ) ; i :: Isolate * i_isolate = reinterpret_cast < i :: Isolate * > ( isolate ) ; i_isolate -> CountUsage ( v8 :: Isolate :: UseCounterFeature :: kWebAssemblyInstantiation ) ; MicrotasksScope runs_microtasks ( isolate , MicrotasksScope :: kRunMicrotasks ) ; ScheduledErrorThrower thrower ( i_isolate , "WebAssembly Instantiation" ) ; HandleScope scope ( isolate ) ; Local < Context > context = isolate -> GetCurrentContext ( ) ; ASSIGN ( Promise :: Resolver , promise_resolver , Promise :: Resolver :: New ( context ) ) ; Local < Promise > promise = promise_resolver -> GetPromise ( ) ; args . GetReturnValue ( ) . Set ( promise ) ; std :: unique_ptr < i :: wasm :: InstantiationResultResolver > resolver ( new InstantiateModuleResultResolver ( i_isolate , Utils :: OpenHandle ( * promise ) ) ) ; Local < Value > first_arg_value = args [ 0 ] ; i :: Handle < i :: Object > first_arg = Utils :: OpenHandle ( * first_arg_value ) ; if ( ! first_arg -> IsJSObject ( ) ) { thrower . TypeError ( "Argument 0 must be a buffer source or a WebAssembly.Module object" ) ; resolver -> OnInstantiationFailed ( thrower . Reify ( ) ) ; return ; } Local < Value > ffi = args [ 1 ] ; i :: MaybeHandle < i :: JSReceiver > maybe_imports = GetValueAsImports ( ffi , & thrower ) ; if ( thrower . error ( ) ) { resolver -> OnInstantiationFailed ( thrower . Reify ( ) ) ; return ; } if ( first_arg -> IsWasmModuleObject ( ) ) { i :: Handle < i :: WasmModuleObject > module_obj = i :: Handle < i :: WasmModuleObject > :: cast ( first_arg ) ; i_isolate -> wasm_engine ( ) -> AsyncInstantiate ( i_isolate , std :: move ( resolver ) , module_obj , maybe_imports ) ; return ; } bool is_shared = false ; auto bytes = GetFirstArgumentAsBytes ( args , & thrower , & is_shared ) ; if ( thrower . error ( ) ) { resolver -> OnInstantiationFailed ( thrower . Reify ( ) ) ; return ; } resolver . reset ( ) ; std :: shared_ptr < i :: wasm :: CompilationResultResolver > compilation_resolver ( new AsyncInstantiateCompileResultResolver ( i_isolate , Utils :: OpenHandle ( * promise ) , maybe_imports ) ) ; if ( ! i :: wasm :: IsWasmCodegenAllowed ( i_isolate , i_isolate -> native_context ( ) ) ) { thrower . CompileError ( "Wasm code generation disallowed by embedder" ) ; compilation_resolver -> OnCompilationFailed ( thrower . Reify ( ) ) ; return ; } auto enabled_features = i :: wasm :: WasmFeaturesFromIsolate ( i_isolate ) ; i_isolate -> wasm_engine ( ) -> AsyncCompile ( i_isolate , enabled_features , std :: move ( compilation_resolver ) , bytes , is_shared ) ; }
void Compute ( OpKernelContext * ctx ) override { const Tensor & values_tensor = ctx -> input ( 0 ) ; const Tensor & value_range_tensor = ctx -> input ( 1 ) ; const Tensor & nbins_tensor = ctx -> input ( 2 ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsVector ( value_range_tensor . shape ( ) ) , errors :: InvalidArgument ( "value_range should be a vector." ) ) ; OP_REQUIRES ( ctx , ( value_range_tensor . shape ( ) . num_elements ( ) == 2 ) , errors :: InvalidArgument ( "value_range should be a vector of 2 elements." ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsScalar ( nbins_tensor . shape ( ) ) , errors :: InvalidArgument ( "nbins should be a scalar." ) ) ; const auto values = values_tensor . flat < T > ( ) ; const auto value_range = value_range_tensor . flat < T > ( ) ; const auto nbins = nbins_tensor . scalar < int32 > ( ) ( ) ; OP_REQUIRES ( ctx , ( value_range ( 0 ) < value_range ( 1 ) ) , errors :: InvalidArgument ( "value_range should satisfy value_range[0] < " "value_range[1], but got '[" , value_range ( 0 ) , ", " , value_range ( 1 ) , "]'" ) ) ; OP_REQUIRES ( ctx , ( nbins > 0 ) , errors :: InvalidArgument ( "nbins should be a positive number, but got '" , nbins , "'" ) ) ; Tensor * out_tensor ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { nbins } ) , & out_tensor ) ) ; auto out = out_tensor -> flat < Tout > ( ) ; OP_REQUIRES_OK ( ctx , functor :: HistogramFixedWidthFunctor < Device , T , Tout > :: Compute ( ctx , values , value_range , nbins , out ) ) ; }
void Heap :: RemoveAllocationObserversFromAllSpaces ( AllocationObserver * observer , AllocationObserver * new_space_observer ) { DCHECK ( observer && new_space_observer ) ; for ( SpaceIterator it ( this ) ; it . has_next ( ) ; ) { Space * space = it . next ( ) ; if ( space == new_space ( ) ) { space -> RemoveAllocationObserver ( new_space_observer ) ; } else { space -> RemoveAllocationObserver ( observer ) ; } } }
Node * EffectControlLinearizer :: LowerCheckedUint32Div ( Node * node , Node * frame_state ) { Node * lhs = node -> InputAt ( 0 ) ; Node * rhs = node -> InputAt ( 1 ) ; Node * zero = __ Int32Constant ( 0 ) ; Node * check = __ Word32Equal ( rhs , zero ) ; __ DeoptimizeIf ( DeoptimizeReason :: kDivisionByZero , VectorSlotPair ( ) , check , frame_state ) ; Node * value = __ Uint32Div ( lhs , rhs ) ; check = __ Word32Equal ( lhs , __ Int32Mul ( rhs , value ) ) ; __ DeoptimizeIfNot ( DeoptimizeReason :: kLostPrecision , VectorSlotPair ( ) , check , frame_state ) ; return value ; }
png_write_tEXt ( png_structrp png_ptr , png_const_charp key , png_const_charp text , png_size_t text_len ) { png_uint_32 key_len ; png_byte new_key [ 80 ] ; png_debug ( 1 , "in png_write_tEXt" ) ; key_len = png_check_keyword ( png_ptr , key , new_key ) ; if ( key_len == 0 ) png_error ( png_ptr , "tEXt: invalid keyword" ) ; if ( text == NULL || * text == '\0' ) text_len = 0 ; else text_len = strlen ( text ) ; if ( text_len > PNG_UINT_31_MAX - ( key_len + 1 ) ) png_error ( png_ptr , "tEXt: text too long" ) ; png_write_chunk_header ( png_ptr , png_tEXt , ( png_uint_32 ) ( key_len + text_len + 1 ) ) ; png_write_chunk_data ( png_ptr , new_key , key_len + 1 ) ; if ( text_len ) png_write_chunk_data ( png_ptr , ( png_const_bytep ) text , text_len ) ; png_write_chunk_end ( png_ptr ) ; }
void mca_ccb_hdl_req ( tMCA_CCB * p_ccb , tMCA_CCB_EVT * p_data ) { BT_HDR * p_pkt = & p_data -> hdr ; uint8_t * p , * p_start ; tMCA_DCB * p_dcb ; tMCA_CTRL evt_data ; tMCA_CCB_MSG * p_rx_msg = NULL ; uint8_t reject_code = MCA_RSP_NO_RESOURCE ; bool send_rsp = false ; bool check_req = false ; uint8_t reject_opcode ; MCA_TRACE_DEBUG ( "mca_ccb_hdl_req status:%d" , p_ccb -> status ) ; p_rx_msg = ( tMCA_CCB_MSG * ) p_pkt ; p = ( uint8_t * ) ( p_pkt + 1 ) + p_pkt -> offset ; evt_data . hdr . op_code = * p ++ ; BE_STREAM_TO_UINT16 ( evt_data . hdr . mdl_id , p ) ; reject_opcode = evt_data . hdr . op_code + 1 ; MCA_TRACE_DEBUG ( "received mdl id: %d " , evt_data . hdr . mdl_id ) ; if ( p_ccb -> status == MCA_CCB_STAT_PENDING ) { MCA_TRACE_DEBUG ( "received req inpending state" ) ; if ( ( p_ccb -> status == MCA_CCB_STAT_PENDING ) && ( evt_data . hdr . op_code == MCA_OP_MDL_ABORT_REQ ) ) { reject_code = MCA_RSP_SUCCESS ; send_rsp = true ; p_ccb -> status = MCA_CCB_STAT_NORM ; if ( p_ccb -> p_tx_req && ( ( p_dcb = mca_dcb_by_hdl ( p_ccb -> p_tx_req -> dcb_idx ) ) != NULL ) ) { mca_dcb_dealloc ( p_dcb , NULL ) ; osi_free_and_reset ( ( void * * ) & p_ccb -> p_tx_req ) ; } } else reject_code = MCA_RSP_BAD_OP ; } else if ( p_ccb -> p_rx_msg ) { MCA_TRACE_DEBUG ( "still handling prev req" ) ; } else if ( p_ccb -> p_tx_req ) { MCA_TRACE_DEBUG ( "still waiting for a response ctrl_vpsm:0x%x" , p_ccb -> ctrl_vpsm ) ; if ( p_ccb -> ctrl_vpsm == 0 ) { MCA_TRACE_DEBUG ( "local is ACP. accept the cmd from INT" ) ; check_req = true ; reject_code = MCA_RSP_SUCCESS ; if ( ( p_ccb -> p_tx_req -> op_code == MCA_OP_MDL_CREATE_REQ ) && ( ( p_dcb = mca_dcb_by_hdl ( p_ccb -> p_tx_req -> dcb_idx ) ) != NULL ) ) { mca_dcb_dealloc ( p_dcb , NULL ) ; } osi_free_and_reset ( ( void * * ) & p_ccb -> p_tx_req ) ; mca_stop_timer ( p_ccb ) ; } else { osi_free ( p_pkt ) ; return ; } } else if ( p_pkt -> layer_specific != MCA_RSP_SUCCESS ) { reject_code = ( uint8_t ) p_pkt -> layer_specific ; if ( ( ( evt_data . hdr . op_code >= MCA_NUM_STANDARD_OPCODE ) && ( evt_data . hdr . op_code < MCA_FIRST_SYNC_OP ) ) || ( evt_data . hdr . op_code > MCA_LAST_SYNC_OP ) ) { reject_opcode = MCA_OP_ERROR_RSP ; evt_data . hdr . mdl_id = 0 ; } } else { check_req = true ; reject_code = MCA_RSP_SUCCESS ; } if ( check_req ) { if ( reject_code == MCA_RSP_SUCCESS ) { reject_code = MCA_RSP_BAD_MDL ; if ( MCA_IS_VALID_MDL_ID ( evt_data . hdr . mdl_id ) || ( ( evt_data . hdr . mdl_id == MCA_ALL_MDL_ID ) && ( evt_data . hdr . op_code == MCA_OP_MDL_DELETE_REQ ) ) ) { reject_code = MCA_RSP_SUCCESS ; switch ( evt_data . hdr . op_code ) { case MCA_OP_MDL_CREATE_REQ : evt_data . create_ind . dep_id = * p ++ ; evt_data . create_ind . cfg = * p ++ ; p_rx_msg -> mdep_id = evt_data . create_ind . dep_id ; if ( ! mca_is_valid_dep_id ( p_ccb -> p_rcb , p_rx_msg -> mdep_id ) ) { MCA_TRACE_ERROR ( "%s: Invalid local MDEP ID %d" , __func__ , p_rx_msg -> mdep_id ) ; reject_code = MCA_RSP_BAD_MDEP ; } else if ( mca_ccb_uses_mdl_id ( p_ccb , evt_data . hdr . mdl_id ) ) { MCA_TRACE_DEBUG ( "the mdl_id is currently used in the CL(create)" ) ; mca_dcb_close_by_mdl_id ( p_ccb , evt_data . hdr . mdl_id ) ; } else { if ( mca_dep_free_mdl ( p_ccb , evt_data . create_ind . dep_id ) == 0 ) { MCA_TRACE_ERROR ( "%s: MAX_MDL is used by MDEP %d" , __func__ , evt_data . create_ind . dep_id ) ; reject_code = MCA_RSP_MDEP_BUSY ; } } break ; case MCA_OP_MDL_RECONNECT_REQ : if ( mca_ccb_uses_mdl_id ( p_ccb , evt_data . hdr . mdl_id ) ) { MCA_TRACE_ERROR ( "%s: MDL_ID %d busy, in CL(reconn)" , __func__ , evt_data . hdr . mdl_id ) ; reject_code = MCA_RSP_MDL_BUSY ; } break ; case MCA_OP_MDL_ABORT_REQ : reject_code = MCA_RSP_BAD_OP ; break ; case MCA_OP_MDL_DELETE_REQ : mca_dcb_close_by_mdl_id ( p_ccb , evt_data . hdr . mdl_id ) ; send_rsp = true ; break ; } } } } if ( ( ( reject_code != MCA_RSP_SUCCESS ) && ( evt_data . hdr . op_code != MCA_OP_SYNC_INFO_IND ) ) || send_rsp ) { BT_HDR * p_buf = ( BT_HDR * ) osi_malloc ( MCA_CTRL_MTU + sizeof ( BT_HDR ) ) ; p_buf -> offset = L2CAP_MIN_OFFSET ; p = p_start = ( uint8_t * ) ( p_buf + 1 ) + L2CAP_MIN_OFFSET ; * p ++ = reject_opcode ; * p ++ = reject_code ; bool valid_response = true ; switch ( reject_opcode ) { case MCA_OP_ERROR_RSP : case MCA_OP_MDL_CREATE_RSP : case MCA_OP_MDL_RECONNECT_RSP : case MCA_OP_MDL_ABORT_RSP : case MCA_OP_MDL_DELETE_RSP : UINT16_TO_BE_STREAM ( p , evt_data . hdr . mdl_id ) ; break ; case MCA_OP_SYNC_CAP_RSP : memset ( p , 0 , 7 ) ; p += 7 ; break ; case MCA_OP_SYNC_SET_RSP : memset ( p , 0 , 14 ) ; p += 14 ; break ; default : MCA_TRACE_ERROR ( "%s: reject_opcode 0x%02x not recognized" , __func__ , reject_opcode ) ; valid_response = false ; break ; } if ( valid_response ) { p_buf -> len = p - p_start ; MCA_TRACE_ERROR ( "%s: reject_opcode=0x%02x, reject_code=0x%02x, length=%d" , __func__ , reject_opcode , reject_code , p_buf -> len ) ; L2CA_DataWrite ( p_ccb -> lcid , p_buf ) ; } else { osi_free ( p_buf ) ; } } if ( reject_code == MCA_RSP_SUCCESS ) { p_rx_msg -> op_code = evt_data . hdr . op_code ; p_rx_msg -> mdl_id = evt_data . hdr . mdl_id ; p_ccb -> p_rx_msg = p_rx_msg ; if ( send_rsp ) { osi_free ( p_pkt ) ; p_ccb -> p_rx_msg = NULL ; } mca_ccb_report_event ( p_ccb , evt_data . hdr . op_code , & evt_data ) ; } else osi_free ( p_pkt ) ; }
void Compute ( OpKernelContext * ctx ) override { const Tensor & handle = ctx -> input ( 0 ) ; const string & name = handle . scalar < tstring > ( ) ( ) ; Tensor val ; auto session_state = ctx -> session_state ( ) ; OP_REQUIRES ( ctx , session_state != nullptr , errors :: FailedPrecondition ( "GetSessionTensor called on null session state" ) ) ; OP_REQUIRES_OK ( ctx , session_state -> GetTensor ( name , & val ) ) ; ctx -> set_output ( 0 , val ) ; }
png_get_oFFs ( png_const_structrp png_ptr , png_const_inforp info_ptr , png_int_32 * offset_x , png_int_32 * offset_y , int * unit_type ) { png_debug1 ( 1 , "in %s retrieval function" , "oFFs" ) ; if ( png_ptr != NULL && info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_oFFs ) && offset_x != NULL && offset_y != NULL && unit_type != NULL ) { * offset_x = info_ptr -> x_offset ; * offset_y = info_ptr -> y_offset ; * unit_type = ( int ) info_ptr -> offset_unit_type ; return ( PNG_INFO_oFFs ) ; } return ( 0 ) ; }
static nsresult CreateBufferedStream ( const uint8_t * aBuffer , uint32_t aBufLen , nsCOMPtr < nsIInputStream > & aResult ) { nsCOMPtr < nsIInputStream > stream ; nsresult rv = NS_NewByteInputStream ( getter_AddRefs ( stream ) , reinterpret_cast < const char * > ( aBuffer ) , aBufLen , NS_ASSIGNMENT_DEPEND ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsCOMPtr < nsIInputStream > aBufferedStream ; if ( ! NS_InputStreamIsBuffered ( stream ) ) { rv = NS_NewBufferedInputStream ( getter_AddRefs ( aBufferedStream ) , stream . forget ( ) , 4096 ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; stream = aBufferedStream ; } aResult = stream ; return NS_OK ; }
static int cms_copy_content ( BIO * out , BIO * in , unsigned int flags ) { unsigned char buf [ 4096 ] ; int r = 0 , i ; BIO * tmpout = NULL ; if ( out == NULL ) tmpout = BIO_new ( BIO_s_null ( ) ) ; else if ( flags & CMS_TEXT ) { tmpout = BIO_new ( BIO_s_mem ( ) ) ; BIO_set_mem_eof_return ( tmpout , 0 ) ; } else tmpout = out ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } r = 1 ; err : if ( tmpout && ( tmpout != out ) ) BIO_free ( tmpout ) ; return r ; }
nsresult NS_NewByteInputStream ( nsIInputStream * * aStreamResult , const char * aStringToRead , int32_t aLength , nsAssignmentType aAssignment ) { MOZ_ASSERT ( aStreamResult , "null out ptr" ) ; RefPtr < nsStringInputStream > stream = new nsStringInputStream ( ) ; nsresult rv ; switch ( aAssignment ) { case NS_ASSIGNMENT_COPY : rv = stream -> SetData ( aStringToRead , aLength ) ; break ; case NS_ASSIGNMENT_DEPEND : rv = stream -> ShareData ( aStringToRead , aLength ) ; break ; case NS_ASSIGNMENT_ADOPT : rv = stream -> AdoptData ( const_cast < char * > ( aStringToRead ) , aLength ) ; break ; default : NS_ERROR ( "invalid assignment type" ) ; rv = NS_ERROR_INVALID_ARG ; } if ( NS_FAILED ( rv ) ) { return rv ; } stream . forget ( aStreamResult ) ; return NS_OK ; }
IW_IMPL ( int ) iw_get_input_density ( struct iw_context * ctx , double * px , double * py , int * pcode ) { * px = 1.0 ; * py = 1.0 ; * pcode = ctx -> img1 . density_code ; if ( ctx -> img1 . density_code != IW_DENSITY_UNKNOWN ) { * px = ctx -> img1 . density_x ; * py = ctx -> img1 . density_y ; return 1 ; } return 0 ; }
Error HeifContext :: get_id_of_non_virtual_child_image ( heif_item_id id , heif_item_id & out ) const { std :: string image_type = m_heif_file -> get_item_type ( id ) ; if ( image_type == "grid" || image_type == "iden" || image_type == "iovl" ) { auto iref_box = m_heif_file -> get_iref_box ( ) ; std :: vector < heif_item_id > image_references = iref_box -> get_references ( id , fourcc ( "dimg" ) ) ; if ( image_references . empty ( ) ) { return Error ( heif_error_Invalid_input , heif_suberror_No_item_data , "Derived image does not reference any other image items" ) ; } else { return get_id_of_non_virtual_child_image ( image_references [ 0 ] , out ) ; } } else { out = id ; return Error :: Ok ; } }
int __mdiobus_register ( struct mii_bus * bus , struct module * owner ) { struct mdio_device * mdiodev ; int i , err ; struct gpio_desc * gpiod ; if ( NULL == bus || NULL == bus -> name || NULL == bus -> read || NULL == bus -> write ) return - EINVAL ; BUG_ON ( bus -> state != MDIOBUS_ALLOCATED && bus -> state != MDIOBUS_UNREGISTERED ) ; bus -> owner = owner ; bus -> dev . parent = bus -> parent ; bus -> dev . class = & mdio_bus_class ; bus -> dev . groups = NULL ; dev_set_name ( & bus -> dev , "%s" , bus -> id ) ; err = device_register ( & bus -> dev ) ; if ( err ) { pr_err ( "mii_bus %s failed to register\n" , bus -> id ) ; put_device ( & bus -> dev ) ; return - EINVAL ; } mutex_init ( & bus -> mdio_lock ) ; gpiod = devm_gpiod_get_optional ( & bus -> dev , "reset" , GPIOD_OUT_LOW ) ; if ( IS_ERR ( gpiod ) ) { dev_err ( & bus -> dev , "mii_bus %s couldn't get reset GPIO\n" , bus -> id ) ; device_del ( & bus -> dev ) ; return PTR_ERR ( gpiod ) ; } else if ( gpiod ) { bus -> reset_gpiod = gpiod ; gpiod_set_value_cansleep ( gpiod , 1 ) ; udelay ( bus -> reset_delay_us ) ; gpiod_set_value_cansleep ( gpiod , 0 ) ; } if ( bus -> reset ) bus -> reset ( bus ) ; for ( i = 0 ; i < PHY_MAX_ADDR ; i ++ ) { if ( ( bus -> phy_mask & ( 1 < < i ) ) == 0 ) { struct phy_device * phydev ; phydev = mdiobus_scan ( bus , i ) ; if ( IS_ERR ( phydev ) && ( PTR_ERR ( phydev ) != - ENODEV ) ) { err = PTR_ERR ( phydev ) ; goto error ; } } } mdiobus_setup_mdiodev_from_board_info ( bus , mdiobus_create_device ) ; bus -> state = MDIOBUS_REGISTERED ; pr_info ( "%s: probed\n" , bus -> name ) ; return 0 ; error : while ( -- i >= 0 ) { mdiodev = bus -> mdio_map [ i ] ; if ( ! mdiodev ) continue ; mdiodev -> device_remove ( mdiodev ) ; mdiodev -> device_free ( mdiodev ) ; } if ( bus -> reset_gpiod ) gpiod_set_value_cansleep ( bus -> reset_gpiod , 1 ) ; device_del ( & bus -> dev ) ; return err ; }
int equalizer_get_parameter ( effect_context_t * context , effect_param_t * p , uint32_t * size ) { equalizer_context_t * eq_ctxt = ( equalizer_context_t * ) context ; int voffset = ( ( p -> psize - 1 ) / sizeof ( int32_t ) + 1 ) * sizeof ( int32_t ) ; int32_t * param_tmp = ( int32_t * ) p -> data ; int32_t param = * param_tmp ++ ; int32_t param2 ; char * name ; void * value = p -> data + voffset ; int i ; ALOGV ( "%s" , __func__ ) ; p -> status = 0 ; switch ( param ) { case EQ_PARAM_NUM_BANDS : case EQ_PARAM_CUR_PRESET : case EQ_PARAM_GET_NUM_OF_PRESETS : case EQ_PARAM_BAND_LEVEL : case EQ_PARAM_GET_BAND : if ( p -> vsize < sizeof ( int16_t ) ) p -> status = - EINVAL ; p -> vsize = sizeof ( int16_t ) ; break ; case EQ_PARAM_LEVEL_RANGE : if ( p -> vsize < 2 * sizeof ( int16_t ) ) p -> status = - EINVAL ; p -> vsize = 2 * sizeof ( int16_t ) ; break ; case EQ_PARAM_BAND_FREQ_RANGE : if ( p -> vsize < 2 * sizeof ( int32_t ) ) p -> status = - EINVAL ; p -> vsize = 2 * sizeof ( int32_t ) ; break ; case EQ_PARAM_CENTER_FREQ : if ( p -> vsize < sizeof ( int32_t ) ) p -> status = - EINVAL ; p -> vsize = sizeof ( int32_t ) ; break ; case EQ_PARAM_GET_PRESET_NAME : break ; case EQ_PARAM_PROPERTIES : if ( p -> vsize < ( 2 + NUM_EQ_BANDS ) * sizeof ( uint16_t ) ) p -> status = - EINVAL ; p -> vsize = ( 2 + NUM_EQ_BANDS ) * sizeof ( uint16_t ) ; break ; default : p -> status = - EINVAL ; } * size = sizeof ( effect_param_t ) + voffset + p -> vsize ; if ( p -> status != 0 ) return 0 ; switch ( param ) { case EQ_PARAM_NUM_BANDS : ALOGV ( "%s: EQ_PARAM_NUM_BANDS" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) NUM_EQ_BANDS ; break ; case EQ_PARAM_LEVEL_RANGE : ALOGV ( "%s: EQ_PARAM_LEVEL_RANGE" , __func__ ) ; * ( int16_t * ) value = - 1500 ; * ( ( int16_t * ) value + 1 ) = 1500 ; break ; case EQ_PARAM_BAND_LEVEL : ALOGV ( "%s: EQ_PARAM_BAND_LEVEL" , __func__ ) ; param2 = * param_tmp ; if ( param2 >= NUM_EQ_BANDS ) { p -> status = - EINVAL ; break ; } * ( int16_t * ) value = ( int16_t ) equalizer_get_band_level ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_CENTER_FREQ : ALOGV ( "%s: EQ_PARAM_CENTER_FREQ" , __func__ ) ; param2 = * param_tmp ; if ( param2 >= NUM_EQ_BANDS ) { p -> status = - EINVAL ; break ; } * ( int32_t * ) value = equalizer_get_center_frequency ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_BAND_FREQ_RANGE : ALOGV ( "%s: EQ_PARAM_BAND_FREQ_RANGE" , __func__ ) ; param2 = * param_tmp ; if ( param2 >= NUM_EQ_BANDS ) { p -> status = - EINVAL ; break ; } equalizer_get_band_freq_range ( eq_ctxt , param2 , ( uint32_t * ) value , ( ( uint32_t * ) value + 1 ) ) ; break ; case EQ_PARAM_GET_BAND : ALOGV ( "%s: EQ_PARAM_GET_BAND" , __func__ ) ; param2 = * param_tmp ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_band ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_CUR_PRESET : ALOGV ( "%s: EQ_PARAM_CUR_PRESET" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_preset ( eq_ctxt ) ; break ; case EQ_PARAM_GET_NUM_OF_PRESETS : ALOGV ( "%s: EQ_PARAM_GET_NUM_OF_PRESETS" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_num_presets ( eq_ctxt ) ; break ; case EQ_PARAM_GET_PRESET_NAME : ALOGV ( "%s: EQ_PARAM_GET_PRESET_NAME" , __func__ ) ; param2 = * param_tmp ; ALOGV ( "param2: %d" , param2 ) ; if ( param2 >= equalizer_get_num_presets ( eq_ctxt ) ) { p -> status = - EINVAL ; break ; } name = ( char * ) value ; strlcpy ( name , equalizer_get_preset_name ( eq_ctxt , param2 ) , p -> vsize - 1 ) ; name [ p -> vsize - 1 ] = 0 ; p -> vsize = strlen ( name ) + 1 ; break ; case EQ_PARAM_PROPERTIES : { ALOGV ( "%s: EQ_PARAM_PROPERTIES" , __func__ ) ; int16_t * prop = ( int16_t * ) value ; prop [ 0 ] = ( int16_t ) equalizer_get_preset ( eq_ctxt ) ; prop [ 1 ] = ( int16_t ) NUM_EQ_BANDS ; for ( i = 0 ; i < NUM_EQ_BANDS ; i ++ ) { prop [ 2 + i ] = ( int16_t ) equalizer_get_band_level ( eq_ctxt , i ) ; } } break ; default : p -> status = - EINVAL ; break ; } return 0 ; }
RUNTIME_FUNCTION ( Runtime_FunctionGetScriptId ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 1 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSReceiver , function , 0 ) ; if ( function -> IsJSFunction ( ) ) { Handle < Object > script ( Handle < JSFunction > :: cast ( function ) -> shared ( ) -> script ( ) , isolate ) ; if ( script -> IsScript ( ) ) { return Smi :: FromInt ( Handle < Script > :: cast ( script ) -> id ( ) ) ; } } return Smi :: FromInt ( - 1 ) ; }
void Compute ( OpKernelContext * context ) override { const Tensor & tensor_in = context -> input ( 0 ) ; const Tensor & grad_in = context -> input ( 1 ) ; const Tensor & argmax = context -> input ( 2 ) ; PoolParameters params { context , ksize_ , stride_ , padding_ , { } , FORMAT_NHWC , tensor_in . shape ( ) } ; if ( ! context -> status ( ) . ok ( ) ) { return ; } TensorShape out_shape ( { params . tensor_in_batch , params . tensor_in_rows , params . tensor_in_cols , params . depth } ) ; Tensor * grad_out = nullptr ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_output ( { 0 } , 0 , out_shape , & grad_out ) ) ; LaunchMaxPoolingGradWithArgmax < Device , T > :: launch ( context , params , grad_in , argmax , grad_out , include_batch_in_index_ ) ; }
OPJ_BOOL opj_j2k_encode ( opj_j2k_t * p_j2k , opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { OPJ_UINT32 i , j ; OPJ_UINT32 l_nb_tiles ; OPJ_UINT32 l_max_tile_size = 0 , l_current_tile_size ; OPJ_BYTE * l_current_data = 00 ; opj_tcd_t * p_tcd = 00 ; assert ( p_j2k != 00 ) ; assert ( p_stream != 00 ) ; assert ( p_manager != 00 ) ; p_tcd = p_j2k -> m_tcd ; l_nb_tiles = p_j2k -> m_cp . th * p_j2k -> m_cp . tw ; for ( i = 0 ; i < l_nb_tiles ; ++ i ) { if ( ! opj_j2k_pre_write_tile ( p_j2k , i , p_stream , p_manager ) ) { if ( l_current_data ) { opj_free ( l_current_data ) ; } return OPJ_FALSE ; } for ( j = 0 ; j < p_j2k -> m_tcd -> image -> numcomps ; ++ j ) { opj_tcd_tilecomp_t * l_tilec = p_tcd -> tcd_image -> tiles -> comps + j ; if ( l_nb_tiles == 1 ) { opj_image_comp_t * l_img_comp = p_tcd -> image -> comps + j ; l_tilec -> data = l_img_comp -> data ; l_tilec -> ownsData = OPJ_FALSE ; } else { if ( ! opj_alloc_tile_component_data ( l_tilec ) ) { opj_event_msg ( p_manager , EVT_ERROR , "Error allocating tile component data." ) ; if ( l_current_data ) { opj_free ( l_current_data ) ; } return OPJ_FALSE ; } } } l_current_tile_size = opj_tcd_get_encoded_tile_size ( p_j2k -> m_tcd ) ; if ( l_nb_tiles > 1 ) { if ( l_current_tile_size > l_max_tile_size ) { OPJ_BYTE * l_new_current_data = ( OPJ_BYTE * ) opj_realloc ( l_current_data , l_current_tile_size ) ; if ( ! l_new_current_data ) { if ( l_current_data ) { opj_free ( l_current_data ) ; } opj_event_msg ( p_manager , EVT_ERROR , "Not enough memory to encode all tiles\n" ) ; return OPJ_FALSE ; } l_current_data = l_new_current_data ; l_max_tile_size = l_current_tile_size ; } opj_j2k_get_tile_data ( p_j2k -> m_tcd , l_current_data ) ; if ( ! opj_tcd_copy_tile_data ( p_j2k -> m_tcd , l_current_data , l_current_tile_size ) ) { opj_event_msg ( p_manager , EVT_ERROR , "Size mismatch between tile data and sent data." ) ; opj_free ( l_current_data ) ; return OPJ_FALSE ; } } if ( ! opj_j2k_post_write_tile ( p_j2k , p_stream , p_manager ) ) { if ( l_current_data ) { opj_free ( l_current_data ) ; } return OPJ_FALSE ; } } if ( l_current_data ) { opj_free ( l_current_data ) ; } return OPJ_TRUE ; }
Handle < JSObject > NewSloppyArguments ( Isolate * isolate , Handle < JSFunction > callee , T parameters , int argument_count ) { CHECK ( ! IsDerivedConstructor ( callee -> shared ( ) -> kind ( ) ) ) ; DCHECK ( callee -> shared ( ) -> has_simple_parameters ( ) ) ; Handle < JSObject > result = isolate -> factory ( ) -> NewArgumentsObject ( callee , argument_count ) ; int parameter_count = callee -> shared ( ) -> internal_formal_parameter_count ( ) ; if ( argument_count > 0 ) { if ( parameter_count > 0 ) { int mapped_count = Min ( argument_count , parameter_count ) ; Handle < FixedArray > parameter_map = isolate -> factory ( ) -> NewFixedArray ( mapped_count + 2 , NOT_TENURED ) ; parameter_map -> set_map ( ReadOnlyRoots ( isolate ) . sloppy_arguments_elements_map ( ) ) ; result -> set_map ( isolate -> native_context ( ) -> fast_aliased_arguments_map ( ) ) ; result -> set_elements ( * parameter_map ) ; Handle < Context > context ( isolate -> context ( ) , isolate ) ; Handle < FixedArray > arguments = isolate -> factory ( ) -> NewFixedArray ( argument_count , NOT_TENURED ) ; parameter_map -> set ( 0 , * context ) ; parameter_map -> set ( 1 , * arguments ) ; int index = argument_count - 1 ; while ( index >= mapped_count ) { arguments -> set ( index , parameters [ index ] ) ; -- index ; } Handle < ScopeInfo > scope_info ( callee -> shared ( ) -> scope_info ( ) , isolate ) ; for ( int i = 0 ; i < mapped_count ; i ++ ) { arguments -> set ( i , parameters [ i ] ) ; parameter_map -> set_the_hole ( i + 2 ) ; } for ( int i = 0 ; i < scope_info -> ContextLocalCount ( ) ; i ++ ) { if ( ! scope_info -> ContextLocalIsParameter ( i ) ) continue ; int parameter = scope_info -> ContextLocalParameterNumber ( i ) ; if ( parameter >= mapped_count ) continue ; arguments -> set_the_hole ( parameter ) ; Smi * slot = Smi :: FromInt ( Context :: MIN_CONTEXT_SLOTS + i ) ; parameter_map -> set ( parameter + 2 , slot ) ; } } else { Handle < FixedArray > elements = isolate -> factory ( ) -> NewFixedArray ( argument_count , NOT_TENURED ) ; result -> set_elements ( * elements ) ; for ( int i = 0 ; i < argument_count ; ++ i ) { elements -> set ( i , parameters [ i ] ) ; } } } return result ; }
Node * WasmGraphBuilder :: Phi ( wasm :: ValueType type , unsigned count , Node * * vals , Node * control ) { DCHECK ( IrOpcode :: IsMergeOpcode ( control -> opcode ( ) ) ) ; Node * * buf = Realloc ( vals , count , count + 1 ) ; buf [ count ] = control ; return graph ( ) -> NewNode ( mcgraph ( ) -> common ( ) -> Phi ( wasm :: ValueTypes :: MachineRepresentationFor ( type ) , count ) , count + 1 , buf ) ; }
void FTPChannelChild :: DoOnStopRequest ( const nsresult & aChannelStatus , const nsCString & aErrorMsg , bool aUseUTF8 ) { LOG ( ( "FTPChannelChild::DoOnStopRequest [this=%p status=%" PRIx32 "]\n" , this , static_cast < uint32_t > ( aChannelStatus ) ) ) ; if ( mDivertingToParent ) { MOZ_RELEASE_ASSERT ( ! mFlushedForDiversion , "Should not be processing any more callbacks from parent!" ) ; SendDivertOnStopRequest ( aChannelStatus ) ; return ; } if ( ! mCanceled ) mStatus = aChannelStatus ; if ( mUnknownDecoderInvolved ) { mUnknownDecoderEventQ . AppendElement ( MakeUnique < MaybeDivertOnStopFTPEvent > ( this , aChannelStatus ) ) ; } { mIsPending = false ; AutoEventEnqueuer ensureSerialDispatch ( mEventQ ) ; ( void ) mListener -> OnStopRequest ( this , mListenerContext , aChannelStatus ) ; if ( NS_FAILED ( aChannelStatus ) && ! aErrorMsg . IsEmpty ( ) ) { nsCOMPtr < nsIPrompt > prompter ; GetCallback ( prompter ) ; if ( prompter ) { nsCOMPtr < nsIRunnable > alertEvent ; if ( aUseUTF8 ) { alertEvent = new nsFtpChildAsyncAlert ( prompter , NS_ConvertUTF8toUTF16 ( aErrorMsg ) ) ; } else { alertEvent = new nsFtpChildAsyncAlert ( prompter , NS_ConvertASCIItoUTF16 ( aErrorMsg ) ) ; } Dispatch ( alertEvent . forget ( ) ) ; } } mListener = nullptr ; mListenerContext = nullptr ; if ( mLoadGroup ) mLoadGroup -> RemoveRequest ( this , nullptr , aChannelStatus ) ; } Send__delete__ ( this ) ; }
nsJPEGDecoder :: FinishInternal ( ) { if ( ( mState != JPEG_DONE && mState != JPEG_SINK_NON_JPEG_TRAILER ) && ( mState != JPEG_ERROR ) && ! IsSizeDecode ( ) ) this -> Write ( nullptr , 0 ) ; }
Link :: SetHost ( const nsAString & aHost ) { nsCOMPtr < nsIURI > uri ( GetURIToMutate ( ) ) ; if ( ! uri ) { return ; } ( void ) uri -> SetHostPort ( NS_ConvertUTF16toUTF8 ( aHost ) ) ; SetHrefAttribute ( uri ) ; return ; }
http_cdsa_read ( SSLConnectionRef connection , void * data , size_t * dataLength ) { OSStatus result ; ssize_t bytes ; http_t * http ; http = ( http_t * ) connection ; if ( ! http -> blocking ) { while ( ! _httpWait ( http , http -> wait_value , 0 ) ) { if ( http -> timeout_cb && ( * http -> timeout_cb ) ( http , http -> timeout_data ) ) continue ; http -> error = ETIMEDOUT ; return ( - 1 ) ; } } do { bytes = recv ( http -> fd , data , * dataLength , 0 ) ; } while ( bytes == - 1 && ( errno == EINTR || errno == EAGAIN ) ) ; if ( ( size_t ) bytes == * dataLength ) { result = 0 ; } else if ( bytes > 0 ) { * dataLength = ( size_t ) bytes ; result = errSSLWouldBlock ; } else { * dataLength = 0 ; if ( bytes == 0 ) result = errSSLClosedGraceful ; else if ( errno == EAGAIN ) result = errSSLWouldBlock ; else result = errSSLClosedAbort ; } return ( result ) ; }
void CpuProfile :: FinishProfile ( ) { end_time_ = base :: TimeTicks :: HighResolutionNow ( ) ; StreamPendingTraceEvents ( ) ; auto value = TracedValue :: Create ( ) ; value -> SetDouble ( "endTime" , ( end_time_ - base :: TimeTicks ( ) ) . InMicroseconds ( ) ) ; TRACE_EVENT_SAMPLE_WITH_ID1 ( TRACE_DISABLED_BY_DEFAULT ( "v8.cpu_profiler" ) , "ProfileChunk" , id_ , "data" , std :: move ( value ) ) ; }
static void * load_bytes ( RBinFile * arch , const ut8 * buf , ut64 sz , ut64 loaddr , Sdb * sdb ) { if ( ! buf || ! sz || sz == UT64_MAX ) { return NULL ; } RBuffer * tbuf = r_buf_new ( ) ; r_buf_set_bytes ( tbuf , buf , sz ) ; struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ; r_buf_free ( tbuf ) ; return res ? res : NULL ; }
nsresult nsJSThunk :: EvaluateScript ( nsIChannel * aChannel , PopupControlState aPopupState , uint32_t aExecutionPolicy , nsPIDOMWindowInner * aOriginalInnerWindow ) { if ( aExecutionPolicy == nsIScriptChannel :: NO_EXECUTION ) { return NS_ERROR_DOM_RETVAL_UNDEFINED ; } NS_ENSURE_ARG_POINTER ( aChannel ) ; nsCOMPtr < nsISupports > owner ; aChannel -> GetOwner ( getter_AddRefs ( owner ) ) ; nsCOMPtr < nsIPrincipal > principal = do_QueryInterface ( owner ) ; if ( ! principal ) { nsCOMPtr < nsILoadInfo > loadInfo ; aChannel -> GetLoadInfo ( getter_AddRefs ( loadInfo ) ) ; if ( loadInfo && loadInfo -> GetForceInheritPrincipal ( ) ) { principal = loadInfo -> TriggeringPrincipal ( ) ; } else { NS_ASSERTION ( ! owner , "Non-principal owner?" ) ; NS_WARNING ( "No principal to execute JS with" ) ; return NS_ERROR_DOM_RETVAL_UNDEFINED ; } } nsresult rv ; nsCOMPtr < nsIContentSecurityPolicy > csp ; rv = principal -> GetCsp ( getter_AddRefs ( csp ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( csp ) { bool allowsInlineScript = true ; rv = csp -> GetAllowsInline ( nsIContentPolicy :: TYPE_SCRIPT , EmptyString ( ) , EmptyString ( ) , 0 , & allowsInlineScript ) ; if ( ! allowsInlineScript ) { return NS_ERROR_DOM_RETVAL_UNDEFINED ; } } nsIScriptGlobalObject * global = GetGlobalObject ( aChannel ) ; if ( ! global ) { return NS_ERROR_FAILURE ; } nsIDocument * doc = aOriginalInnerWindow -> GetExtantDoc ( ) ; if ( doc && ( doc -> GetSandboxFlags ( ) & SANDBOXED_SCRIPTS ) ) { return NS_ERROR_DOM_RETVAL_UNDEFINED ; } nsAutoPopupStatePusher popupStatePusher ( aPopupState ) ; nsCOMPtr < nsPIDOMWindowOuter > win = do_QueryInterface ( global ) ; nsPIDOMWindowInner * innerWin = win -> GetCurrentInnerWindow ( ) ; if ( innerWin != aOriginalInnerWindow ) { return NS_ERROR_UNEXPECTED ; } nsCOMPtr < nsIScriptGlobalObject > innerGlobal = do_QueryInterface ( innerWin ) ; nsCOMPtr < nsIDOMWindow > domWindow ( do_QueryInterface ( global , & rv ) ) ; if ( NS_FAILED ( rv ) ) { return NS_ERROR_FAILURE ; } nsCOMPtr < nsIScriptContext > scriptContext = global -> GetContext ( ) ; if ( ! scriptContext ) return NS_ERROR_FAILURE ; nsAutoCString script ( mScript ) ; NS_UnescapeURL ( script ) ; nsCOMPtr < nsIScriptSecurityManager > securityManager ; securityManager = do_GetService ( NS_SCRIPTSECURITYMANAGER_CONTRACTID , & rv ) ; if ( NS_FAILED ( rv ) ) return rv ; nsAutoMicroTask mt ; AutoEntryScript aes ( innerGlobal , "javascript: URI" , true ) ; JSContext * cx = aes . cx ( ) ; JS :: Rooted < JSObject * > globalJSObject ( cx , innerGlobal -> GetGlobalJSObject ( ) ) ; NS_ENSURE_TRUE ( globalJSObject , NS_ERROR_UNEXPECTED ) ; nsIPrincipal * objectPrincipal = nsContentUtils :: ObjectPrincipal ( globalJSObject ) ; bool subsumes ; rv = principal -> Subsumes ( objectPrincipal , & subsumes ) ; if ( NS_FAILED ( rv ) ) return rv ; if ( ! subsumes ) { return NS_ERROR_DOM_RETVAL_UNDEFINED ; } if ( nsContentUtils :: IsSystemPrincipal ( objectPrincipal ) ) { return NS_ERROR_DOM_SECURITY_ERR ; } JS :: Rooted < JS :: Value > v ( cx , JS :: UndefinedValue ( ) ) ; JS :: CompileOptions options ( cx ) ; options . setFileAndLine ( mURL . get ( ) , 1 ) . setVersion ( JSVERSION_DEFAULT ) ; nsJSUtils :: EvaluateOptions evalOptions ( cx ) ; rv = nsJSUtils :: EvaluateString ( cx , NS_ConvertUTF8toUTF16 ( script ) , globalJSObject , options , evalOptions , & v ) ; if ( NS_FAILED ( rv ) ) { return NS_ERROR_MALFORMED_URI ; } else if ( ! v . isString ( ) ) { return NS_ERROR_DOM_RETVAL_UNDEFINED ; } else { MOZ_ASSERT ( rv != NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW , "How did we get a non-undefined return value?" ) ; nsAutoJSString result ; if ( ! result . init ( cx , v ) ) { return NS_ERROR_OUT_OF_MEMORY ; } char * bytes ; uint32_t bytesLen ; NS_NAMED_LITERAL_CSTRING ( isoCharset , "ISO-8859-1" ) ; NS_NAMED_LITERAL_CSTRING ( utf8Charset , "UTF-8" ) ; const nsCString * charset ; if ( IsISO88591 ( result ) ) { bytes = ToNewCString ( result ) ; bytesLen = result . Length ( ) ; charset = & isoCharset ; } else { bytes = ToNewUTF8String ( result , & bytesLen ) ; charset = & utf8Charset ; } aChannel -> SetContentCharset ( * charset ) ; if ( bytes ) rv = NS_NewByteInputStream ( getter_AddRefs ( mInnerStream ) , bytes , bytesLen , NS_ASSIGNMENT_ADOPT ) ; else rv = NS_ERROR_OUT_OF_MEMORY ; } return rv ; }
TPM2B_SENSITIVE_DATA_Marshal ( TPM2B_SENSITIVE_DATA * source , BYTE * * buffer , INT32 * size ) { UINT16 written = 0 ; written += TPM2B_Marshal ( & source -> b , buffer , size ) ; return written ; }
static void rose_timer_expiry ( struct timer_list * t ) { struct rose_sock * rose = from_timer ( rose , t , timer ) ; struct sock * sk = & rose -> sock ; bh_lock_sock ( sk ) ; switch ( rose -> state ) { case ROSE_STATE_1 : case ROSE_STATE_4 : rose_write_internal ( sk , ROSE_CLEAR_REQUEST ) ; rose -> state = ROSE_STATE_2 ; rose_start_t3timer ( sk ) ; break ; case ROSE_STATE_2 : rose -> neighbour -> use -- ; rose_disconnect ( sk , ETIMEDOUT , - 1 , - 1 ) ; break ; case ROSE_STATE_3 : if ( rose -> condition & ROSE_COND_ACK_PENDING ) { rose -> condition &= ~ ROSE_COND_ACK_PENDING ; rose_enquiry_response ( sk ) ; } break ; } bh_unlock_sock ( sk ) ; }
static int on_frame_recv ( nghttp2_session * session , const nghttp2_frame * frame , void * user_data ) { int rv ; ogs_sbi_session_t * sbi_sess = user_data ; ogs_sbi_server_t * server = NULL ; ogs_sbi_stream_t * stream = NULL ; ogs_sbi_request_t * request = NULL ; ogs_assert ( sbi_sess ) ; server = sbi_sess -> server ; ogs_assert ( server ) ; ogs_assert ( server -> cb ) ; ogs_assert ( session ) ; ogs_assert ( frame ) ; stream = nghttp2_session_get_stream_user_data ( session , frame -> hd . stream_id ) ; if ( ! stream ) { if ( frame -> hd . type == NGHTTP2_SETTINGS ) { sbi_sess -> settings . max_concurrent_streams = nghttp2_session_get_remote_settings ( session , NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS ) ; sbi_sess -> settings . enable_push = nghttp2_session_get_remote_settings ( session , NGHTTP2_SETTINGS_ENABLE_PUSH ) ; ogs_debug ( "MAX_CONCURRENT_STREAMS = %d" , sbi_sess -> settings . max_concurrent_streams ) ; ogs_debug ( "ENABLE_PUSH = %s" , sbi_sess -> settings . enable_push ? "TRUE" : "false" ) ; } else if ( frame -> hd . type == NGHTTP2_GOAWAY ) { rv = nghttp2_submit_goaway ( session , NGHTTP2_FLAG_NONE , sbi_sess -> last_stream_id , NGHTTP2_NO_ERROR , NULL , 0 ) ; if ( rv != 0 ) { ogs_error ( "nghttp2_submit_goaway() failed (%d:%s)" , rv , nghttp2_strerror ( rv ) ) ; return OGS_ERROR ; } session_send ( sbi_sess ) ; } return 0 ; } request = stream -> request ; ogs_assert ( request ) ; switch ( frame -> hd . type ) { case NGHTTP2_HEADERS : if ( frame -> headers . cat == NGHTTP2_HCAT_REQUEST ) { const char * expect100 = ogs_sbi_header_get ( request -> http . headers , OGS_SBI_EXPECT ) ; if ( expect100 && ogs_strcasecmp ( expect100 , "100-continue" ) == 0 ) { nghttp2_nv nva ; add_header ( & nva , ":status" , status_string [ 100 ] ) ; rv = nghttp2_submit_headers ( session , NGHTTP2_FLAG_NONE , stream -> stream_id , NULL , & nva , 1 , NULL ) ; if ( rv != 0 ) { ogs_error ( "nghttp2_submit_headers() failed (%d:%s)" , rv , nghttp2_strerror ( rv ) ) ; nghttp2_submit_rst_stream ( session , NGHTTP2_FLAG_NONE , stream -> stream_id , rv ) ; return 0 ; } } } OGS_GNUC_FALLTHROUGH ; case NGHTTP2_DATA : if ( frame -> hd . flags & NGHTTP2_FLAG_END_STREAM ) { ogs_debug ( "[%s] %s" , request -> h . method , request -> h . uri ) ; if ( request -> http . content_length && request -> http . content ) { ogs_debug ( "RECEIVED: %d" , ( int ) request -> http . content_length ) ; ogs_debug ( "%s" , request -> http . content ) ; } if ( server -> cb ( request , stream ) != OGS_OK ) { ogs_warn ( "server callback error" ) ; ogs_assert ( true == ogs_sbi_server_send_error ( stream , OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR , NULL , "server callback error" , NULL ) ) ; return 0 ; } break ; } default : break ; } return 0 ; }
static OPJ_BOOL opj_pi_next_pcrl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u < < ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u < < ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { comp = & pi -> comps [ pi -> compno ] ; for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < opj_uint_min ( pi -> poc . resno1 , comp -> numresolutions ) ; pi -> resno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx < < levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy < < levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx < < levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy < < levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy < < rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 < < levelno ) % ( 1 < < rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx < < rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 < < levelno ) % ( 1 < < rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx < < levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy < < levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
MaybeHandle < BigInt > BigInt :: FromNumber ( Isolate * isolate , Handle < Object > number ) { DCHECK ( number -> IsNumber ( ) ) ; if ( number -> IsSmi ( ) ) { return MutableBigInt :: NewFromInt ( isolate , Smi :: ToInt ( * number ) ) ; } double value = HeapNumber :: cast ( * number ) -> value ( ) ; if ( ! std :: isfinite ( value ) || ( DoubleToInteger ( value ) != value ) ) { THROW_NEW_ERROR ( isolate , NewRangeError ( MessageTemplate :: kBigIntFromNumber , number ) , BigInt ) ; } return MutableBigInt :: NewFromDouble ( isolate , value ) ; }
void TEMPLATE ( process_block_dec ) ( decoder_info_t * decoder_info , int size , int yposY , int xposY , int sub ) { int width = decoder_info -> width ; int height = decoder_info -> height ; stream_t * stream = decoder_info -> stream ; frame_type_t frame_type = decoder_info -> frame_info . frame_type ; int split_flag = 0 ; if ( yposY >= height || xposY >= width ) return ; int decode_this_size = ( yposY + size <= height ) && ( xposY + size <= width ) ; int decode_rectangular_size = ! decode_this_size && frame_type != I_FRAME ; int bit_start = stream -> bitcnt ; int mode = MODE_SKIP ; block_context_t block_context ; TEMPLATE ( find_block_contexts ) ( yposY , xposY , height , width , size , decoder_info -> deblock_data , & block_context , decoder_info -> use_block_contexts ) ; decoder_info -> block_context = & block_context ; split_flag = decode_super_mode ( decoder_info , size , decode_this_size ) ; mode = decoder_info -> mode ; if ( size == ( 1 < < decoder_info -> log2_sb_size ) && ( split_flag || mode != MODE_SKIP ) && decoder_info -> max_delta_qp > 0 ) { int delta_qp = read_delta_qp ( stream ) ; int prev_qp ; if ( yposY == 0 && xposY == 0 ) prev_qp = decoder_info -> frame_info . qp ; else prev_qp = decoder_info -> frame_info . qpb ; decoder_info -> frame_info . qpb = prev_qp + delta_qp ; } decoder_info -> bit_count . super_mode [ decoder_info -> bit_count . stat_frame_type ] += ( stream -> bitcnt - bit_start ) ; if ( split_flag ) { int new_size = size / 2 ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 0 * new_size , xposY + 0 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 1 * new_size , xposY + 0 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 0 * new_size , xposY + 1 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 1 * new_size , xposY + 1 * new_size , sub ) ; } else if ( decode_this_size || decode_rectangular_size ) { decode_block ( decoder_info , size , yposY , xposY , sub ) ; } }
make_canonical ( struct ly_ctx * ctx , int type , const char * * value , void * data1 , void * data2 ) { const uint16_t buf_len = 511 ; char buf [ buf_len + 1 ] ; struct lys_type_bit * * bits = NULL ; struct lyxp_expr * exp ; const char * module_name , * cur_expr , * end ; int i , j , count ; int64_t num ; uint64_t unum ; uint8_t c ; switch ( type ) { case LY_TYPE_BITS : bits = ( struct lys_type_bit * * ) data1 ; count = * ( ( int * ) data2 ) ; buf [ 0 ] = '\0' ; for ( i = 0 ; i < count ; i ++ ) { if ( ! bits [ i ] ) { continue ; } if ( buf [ 0 ] ) { sprintf ( buf + strlen ( buf ) , " %s" , bits [ i ] -> name ) ; } else { strcpy ( buf , bits [ i ] -> name ) ; } } break ; case LY_TYPE_IDENT : module_name = ( const char * ) data1 ; if ( ! strchr ( * value , ':' ) ) { sprintf ( buf , "%s:%s" , module_name , * value ) ; } else { strcpy ( buf , * value ) ; } break ; case LY_TYPE_INST : exp = lyxp_parse_expr ( ctx , * value ) ; LY_CHECK_ERR_RETURN ( ! exp , LOGINT ( ctx ) , 0 ) ; module_name = NULL ; count = 0 ; for ( i = 0 ; ( unsigned ) i < exp -> used ; ++ i ) { cur_expr = & exp -> expr [ exp -> expr_pos [ i ] ] ; if ( i && ( ( end = exp -> expr + exp -> expr_pos [ i - 1 ] + exp -> tok_len [ i - 1 ] ) != cur_expr ) ) { if ( count + ( cur_expr - end ) > buf_len ) { LOGINT ( ctx ) ; lyxp_expr_free ( exp ) ; return 0 ; } strncpy ( & buf [ count ] , end , cur_expr - end ) ; count += cur_expr - end ; } if ( ( exp -> tokens [ i ] == LYXP_TOKEN_NAMETEST ) && ( end = strnchr ( cur_expr , ':' , exp -> tok_len [ i ] ) ) ) { ++ end ; j = end - cur_expr ; if ( ! module_name || strncmp ( cur_expr , module_name , j ) ) { if ( count + j > buf_len ) { LOGINT ( ctx ) ; lyxp_expr_free ( exp ) ; return 0 ; } strncpy ( & buf [ count ] , cur_expr , j ) ; count += j ; } module_name = cur_expr ; if ( count + ( exp -> tok_len [ i ] - j ) > buf_len ) { LOGINT ( ctx ) ; lyxp_expr_free ( exp ) ; return 0 ; } strncpy ( & buf [ count ] , end , exp -> tok_len [ i ] - j ) ; count += exp -> tok_len [ i ] - j ; } else { if ( count + exp -> tok_len [ i ] > buf_len ) { LOGINT ( ctx ) ; lyxp_expr_free ( exp ) ; return 0 ; } strncpy ( & buf [ count ] , & exp -> expr [ exp -> expr_pos [ i ] ] , exp -> tok_len [ i ] ) ; count += exp -> tok_len [ i ] ; } } if ( count > buf_len ) { LOGINT ( ctx ) ; lyxp_expr_free ( exp ) ; return 0 ; } buf [ count ] = '\0' ; lyxp_expr_free ( exp ) ; break ; case LY_TYPE_DEC64 : num = * ( ( int64_t * ) data1 ) ; c = * ( ( uint8_t * ) data2 ) ; if ( num ) { count = sprintf ( buf , "%"PRId64 " " , num ) ; if ( ( num > 0 && ( count - 1 ) <= c ) || ( count - 2 ) <= c ) { count = sprintf ( buf , "%0*"PRId64 " " , ( num > 0 ) ? ( c + 1 ) : ( c + 2 ) , num ) ; } for ( i = c , j = 1 ; i > 0 ; i -- ) { if ( j && i > 1 && buf [ count - 2 ] == '0' ) { buf [ count - 1 ] = '\0' ; } else { j = 0 ; buf [ count - 1 ] = buf [ count - 2 ] ; } count -- ; } buf [ count - 1 ] = '.' ; } else { sprintf ( buf , "0.0" ) ; } break ; case LY_TYPE_INT8 : case LY_TYPE_INT16 : case LY_TYPE_INT32 : case LY_TYPE_INT64 : num = * ( ( int64_t * ) data1 ) ; sprintf ( buf , "%"PRId64 , num ) ; break ; case LY_TYPE_UINT8 : case LY_TYPE_UINT16 : case LY_TYPE_UINT32 : case LY_TYPE_UINT64 : unum = * ( ( uint64_t * ) data1 ) ; sprintf ( buf , "%"PRIu64 , unum ) ; break ; default : return 0 ; } if ( strcmp ( buf , * value ) ) { lydict_remove ( ctx , * value ) ; * value = lydict_insert ( ctx , buf , 0 ) ; return 1 ; } return 0 ; }
WorkerMain ( void * arg ) { WorkerInput * input = ( WorkerInput * ) arg ; JSRuntime * rt = JS_NewRuntime ( 8L * 1024L * 1024L , input -> runtime ) ; if ( ! rt ) { js_delete ( input ) ; return ; } JSContext * cx = NewContext ( rt ) ; if ( ! cx ) { JS_DestroyRuntime ( rt ) ; js_delete ( input ) ; return ; } do { JSAutoRequest ar ( cx ) ; JS :: CompartmentOptions compartmentOptions ; compartmentOptions . setVersion ( JSVERSION_LATEST ) ; RootedObject global ( cx , NewGlobalObject ( cx , compartmentOptions , nullptr ) ) ; if ( ! global ) break ; JSAutoCompartment ac ( cx , global ) ; JS :: CompileOptions options ( cx ) ; options . setFileAndLine ( "<string>" , 1 ) . setCompileAndGo ( true ) ; RootedScript script ( cx , JS :: Compile ( cx , global , options , input -> chars , input -> length ) ) ; if ( ! script ) break ; RootedValue result ( cx ) ; JS_ExecuteScript ( cx , global , script , & result ) ; } while ( 0 ) ; DestroyContext ( cx , false ) ; JS_DestroyRuntime ( rt ) ; js_delete ( input ) ; }
WORD32 ih264d_init_dec_mb_grp ( dec_struct_t * ps_dec ) { dec_seq_params_t * ps_seq = ps_dec -> ps_cur_sps ; UWORD8 u1_frm = ps_seq -> u1_frame_mbs_only_flag ; ps_dec -> u1_recon_mb_grp = PARSE_MB_GROUP_4 ; if ( 0 == ps_seq -> u1_mb_aff_flag ) ps_dec -> u1_recon_mb_grp = ps_dec -> u2_frm_wd_in_mbs ; ps_dec -> u1_recon_mb_grp_pair = ps_dec -> u1_recon_mb_grp > > 1 ; if ( ! ps_dec -> u1_recon_mb_grp ) { return ERROR_MB_GROUP_ASSGN_T ; } ps_dec -> u4_num_mbs_prev_nmb = ps_dec -> u1_recon_mb_grp ; return OK ; }
const Operator * MachineOperatorBuilder :: Word64AtomicOr ( MachineType type ) { #define OR(kType)                          \  if (type == MachineType::kType()) {      \  return &cache_.kWord64AtomicOr##kType; \  } ATOMIC_U64_TYPE_LIST ( OR ) #undef OR UNREACHABLE ( ) ; }
void vp9_update_mbgraph_stats ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; int i , n_frames = vp9_lookahead_depth ( cpi -> lookahead ) ; YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; if ( n_frames <= cpi -> rc . frames_till_gf_update_due ) return ; if ( n_frames > MAX_LAG_BUFFERS ) n_frames = MAX_LAG_BUFFERS ; cpi -> mbgraph_n_frames = n_frames ; for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; vpx_memset ( frame_stats -> mb_stats , 0 , cm -> mb_rows * cm -> mb_cols * sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ; } for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; struct lookahead_entry * q_cur = vp9_lookahead_peek ( cpi -> lookahead , i ) ; assert ( q_cur != NULL ) ; update_mbgraph_frame_stats ( cpi , frame_stats , & q_cur -> img , golden_ref , cpi -> Source ) ; } vp9_clear_system_state ( ) ; separate_arf_mbs ( cpi ) ; }
static void free_huge_page ( struct page * page ) { struct hstate * h = page_hstate ( page ) ; int nid = page_to_nid ( page ) ; struct address_space * mapping ; mapping = ( struct address_space * ) page_private ( page ) ; set_page_private ( page , 0 ) ; page -> mapping = NULL ; BUG_ON ( page_count ( page ) ) ; BUG_ON ( page_mapcount ( page ) ) ; INIT_LIST_HEAD ( & page -> lru ) ; spin_lock ( & hugetlb_lock ) ; if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) { update_and_free_page ( h , page ) ; h -> surplus_huge_pages -- ; h -> surplus_huge_pages_node [ nid ] -- ; } else { enqueue_huge_page ( h , page ) ; } spin_unlock ( & hugetlb_lock ) ; if ( mapping ) hugetlb_put_quota ( mapping , 1 ) ; }
void CUser :: SetClientEncoding ( const CString & s ) { m_sClientEncoding = s ; for ( CClient * pClient : GetAllClients ( ) ) { pClient -> SetEncoding ( s ) ; } }
Scope :: Scope ( Zone * zone , const AstRawString * catch_variable_name , MaybeAssignedFlag maybe_assigned , Handle < ScopeInfo > scope_info ) : zone_ ( zone ) , outer_scope_ ( nullptr ) , variables_ ( zone ) , scope_info_ ( scope_info ) , scope_type_ ( CATCH_SCOPE ) { SetDefaults ( ) ; #ifdef DEBUG already_resolved_ = true ; #endif Variable * variable = Declare ( zone , catch_variable_name , VariableMode :: kVar , NORMAL_VARIABLE , kCreatedInitialized , maybe_assigned ) ; AllocateHeapSlot ( variable ) ; }
BodyStream :: OnInputStreamReady ( nsIAsyncInputStream * aStream ) { AssertIsOnOwningThread ( ) ; MOZ_DIAGNOSTIC_ASSERT ( aStream ) ; MutexAutoLock lock ( mMutex ) ; if ( mState == eClosed ) { return NS_OK ; } MOZ_DIAGNOSTIC_ASSERT ( mInputStream ) ; MOZ_DIAGNOSTIC_ASSERT ( mState == eReading || mState == eChecking ) ; AutoJSAPI jsapi ; if ( NS_WARN_IF ( ! jsapi . Init ( mGlobal ) ) ) { return NS_ERROR_FAILURE ; } JSObject * streamObj = mStreamHolder -> GetReadableStreamBody ( ) ; if ( ! streamObj ) { return NS_ERROR_FAILURE ; } JSContext * cx = jsapi . cx ( ) ; JS :: Rooted < JSObject * > stream ( cx , streamObj ) ; uint64_t size = 0 ; nsresult rv = mInputStream -> Available ( & size ) ; if ( NS_SUCCEEDED ( rv ) && size == 0 ) { rv = NS_BASE_STREAM_CLOSED ; } if ( rv == NS_BASE_STREAM_CLOSED || NS_WARN_IF ( NS_FAILED ( rv ) ) ) { ErrorPropagation ( cx , lock , stream , rv ) ; return NS_OK ; } if ( mState == eChecking ) { mState = eWaiting ; return NS_OK ; } mState = eWriting ; { MutexAutoUnlock unlock ( mMutex ) ; DebugOnly < bool > ok = JS :: ReadableStreamUpdateDataAvailableFromSource ( cx , stream , size ) ; MOZ_ASSERT_IF ( ok , mState == eChecking ) ; } return NS_OK ; }
CodeGenerator :: visitOsrEntry ( LOsrEntry * lir ) { masm . flushBuffer ( ) ; setOsrEntryOffset ( masm . size ( ) ) ; #ifdef JS_TRACE_LOGGING if ( gen -> info ( ) . executionMode ( ) == SequentialExecution ) { if ( ! emitTracelogStopEvent ( TraceLogger :: Baseline ) ) return false ; if ( ! emitTracelogStartEvent ( TraceLogger :: IonMonkey ) ) return false ; } #endif uint32_t size = frameSize ( ) ; if ( size != 0 ) masm . subPtr ( Imm32 ( size ) , StackPointer ) ; return true ; }
lambda_function_body ( char_u * * arg , typval_T * rettv , evalarg_T * evalarg , garray_T * newargs , garray_T * argtypes , int varargs , garray_T * default_args , char_u * ret_type ) { int evaluate = ( evalarg -> eval_flags & EVAL_EVALUATE ) ; garray_T * gap = & evalarg -> eval_ga ; garray_T * freegap = & evalarg -> eval_freega ; ufunc_T * ufunc = NULL ; exarg_T eap ; garray_T newlines ; char_u * cmdline = NULL ; int ret = FAIL ; char_u * line_to_free = NULL ; partial_T * pt ; char_u * name ; int lnum_save = - 1 ; linenr_T sourcing_lnum_top = SOURCING_LNUM ; if ( ! ends_excmd2 ( * arg , skipwhite ( * arg + 1 ) ) ) { semsg ( _ ( e_trailing_characters_str ) , * arg + 1 ) ; return FAIL ; } CLEAR_FIELD ( eap ) ; eap . cmdidx = CMD_block ; eap . forceit = FALSE ; eap . cmdlinep = & cmdline ; eap . skip = ! evaluate ; if ( evalarg -> eval_cctx != NULL ) fill_exarg_from_cctx ( & eap , evalarg -> eval_cctx ) ; else { eap . getline = evalarg -> eval_getline ; eap . cookie = evalarg -> eval_cookie ; } ga_init2 ( & newlines , ( int ) sizeof ( char_u * ) , 10 ) ; if ( get_function_body ( & eap , & newlines , NULL , & line_to_free ) == FAIL ) { if ( cmdline != line_to_free ) vim_free ( cmdline ) ; goto erret ; } evalarg -> eval_break_count += newlines . ga_len ; if ( gap -> ga_itemsize > 0 ) { int idx ; char_u * last ; size_t plen ; char_u * pnl ; for ( idx = 0 ; idx < newlines . ga_len ; ++ idx ) { char_u * p = skipwhite ( ( ( char_u * * ) newlines . ga_data ) [ idx ] ) ; if ( ga_grow ( gap , 1 ) == FAIL || ga_grow ( freegap , 1 ) == FAIL ) goto erret ; if ( * p == NUL || vim9_comment_start ( p ) ) p = ( char_u * ) "" ; plen = STRLEN ( p ) ; pnl = vim_strnsave ( ( char_u * ) "\n" , plen + 1 ) ; if ( pnl != NULL ) mch_memmove ( pnl + 1 , p , plen + 1 ) ; ( ( char_u * * ) gap -> ga_data ) [ gap -> ga_len ++ ] = pnl ; ( ( char_u * * ) freegap -> ga_data ) [ freegap -> ga_len ++ ] = pnl ; } if ( ga_grow ( gap , 1 ) == FAIL || ga_grow ( freegap , 1 ) == FAIL ) goto erret ; if ( eap . nextcmd != NULL ) last = cmdline ; else last = ( char_u * ) "}" ; plen = STRLEN ( last ) ; pnl = vim_strnsave ( ( char_u * ) "\n" , plen + 1 ) ; if ( pnl != NULL ) mch_memmove ( pnl + 1 , last , plen + 1 ) ; ( ( char_u * * ) gap -> ga_data ) [ gap -> ga_len ++ ] = pnl ; ( ( char_u * * ) freegap -> ga_data ) [ freegap -> ga_len ++ ] = pnl ; } if ( eap . nextcmd != NULL ) { garray_T * tfgap = & evalarg -> eval_tofree_ga ; * arg = eap . nextcmd ; if ( ga_grow ( tfgap , 1 ) == OK ) { ( ( char_u * * ) ( tfgap -> ga_data ) ) [ tfgap -> ga_len ++ ] = cmdline ; evalarg -> eval_using_cmdline = TRUE ; if ( cmdline == line_to_free ) line_to_free = NULL ; } } else * arg = ( char_u * ) "" ; if ( ! evaluate ) { ret = OK ; goto erret ; } name = get_lambda_name ( ) ; ufunc = alloc_clear ( offsetof ( ufunc_T , uf_name ) + STRLEN ( name ) + 1 ) ; if ( ufunc == NULL ) goto erret ; set_ufunc_name ( ufunc , name ) ; if ( hash_add ( & func_hashtab , UF2HIKEY ( ufunc ) ) == FAIL ) goto erret ; ufunc -> uf_flags = FC_LAMBDA ; ufunc -> uf_refcount = 1 ; ufunc -> uf_args = * newargs ; newargs -> ga_data = NULL ; ufunc -> uf_def_args = * default_args ; default_args -> ga_data = NULL ; ufunc -> uf_func_type = & t_func_any ; lnum_save = SOURCING_LNUM ; SOURCING_LNUM = sourcing_lnum_top ; if ( parse_argument_types ( ufunc , argtypes , varargs ) == FAIL ) { SOURCING_LNUM = lnum_save ; goto erret ; } if ( parse_return_type ( ufunc , ret_type ) == FAIL ) goto erret ; pt = ALLOC_CLEAR_ONE ( partial_T ) ; if ( pt == NULL ) goto erret ; pt -> pt_func = ufunc ; pt -> pt_refcount = 1 ; ufunc -> uf_lines = newlines ; newlines . ga_data = NULL ; if ( sandbox ) ufunc -> uf_flags |= FC_SANDBOX ; if ( ! ASCII_ISUPPER ( * ufunc -> uf_name ) ) ufunc -> uf_flags |= FC_VIM9 ; ufunc -> uf_script_ctx = current_sctx ; ufunc -> uf_script_ctx_version = current_sctx . sc_version ; ufunc -> uf_script_ctx . sc_lnum += sourcing_lnum_top ; set_function_type ( ufunc ) ; function_using_block_scopes ( ufunc , evalarg -> eval_cstack ) ; rettv -> vval . v_partial = pt ; rettv -> v_type = VAR_PARTIAL ; ufunc = NULL ; ret = OK ; erret : if ( lnum_save >= 0 ) SOURCING_LNUM = lnum_save ; vim_free ( line_to_free ) ; ga_clear_strings ( & newlines ) ; if ( newargs != NULL ) ga_clear_strings ( newargs ) ; ga_clear_strings ( default_args ) ; if ( ufunc != NULL ) { func_clear ( ufunc , TRUE ) ; func_free ( ufunc , TRUE ) ; } return ret ; }
BUILTIN ( CallSitePrototypeGetThis ) { HandleScope scope ( isolate ) ; CHECK_CALLSITE ( recv , "getThis" ) ; FrameArrayIterator it ( isolate , GetFrameArray ( isolate , recv ) , GetFrameIndex ( isolate , recv ) ) ; StackFrameBase * frame = it . Frame ( ) ; if ( frame -> IsStrict ( ) ) return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; return * frame -> GetReceiver ( ) ; }
void Heap :: FlushNumberStringCache ( ) { int len = number_string_cache ( ) -> length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { number_string_cache ( ) -> set_undefined ( i ) ; } }
privsep_preauth ( Authctxt * authctxt ) { int status , r ; pid_t pid ; struct ssh_sandbox * box = NULL ; pmonitor = monitor_init ( ) ; pmonitor -> m_pkex = & active_state -> kex ; if ( use_privsep == PRIVSEP_ON ) box = ssh_sandbox_init ( ) ; pid = fork ( ) ; if ( pid == - 1 ) { fatal ( "fork of unprivileged child failed" ) ; } else if ( pid != 0 ) { debug2 ( "Network child is on pid %ld" , ( long ) pid ) ; pmonitor -> m_pid = pid ; if ( have_agent ) { r = ssh_get_authentication_socket ( & auth_sock ) ; if ( r != 0 ) { error ( "Could not get agent socket: %s" , ssh_err ( r ) ) ; have_agent = 0 ; } } if ( box != NULL ) ssh_sandbox_parent_preauth ( box , pid ) ; monitor_child_preauth ( authctxt , pmonitor ) ; monitor_sync ( pmonitor ) ; while ( waitpid ( pid , & status , 0 ) < 0 ) { if ( errno == EINTR ) continue ; pmonitor -> m_pid = - 1 ; fatal ( "%s: waitpid: %s" , __func__ , strerror ( errno ) ) ; } privsep_is_preauth = 0 ; pmonitor -> m_pid = - 1 ; if ( WIFEXITED ( status ) ) { if ( WEXITSTATUS ( status ) != 0 ) fatal ( "%s: preauth child exited with status %d" , __func__ , WEXITSTATUS ( status ) ) ; } else if ( WIFSIGNALED ( status ) ) fatal ( "%s: preauth child terminated by signal %d" , __func__ , WTERMSIG ( status ) ) ; if ( box != NULL ) ssh_sandbox_parent_finish ( box ) ; return 1 ; } else { close ( pmonitor -> m_sendfd ) ; close ( pmonitor -> m_log_recvfd ) ; set_log_handler ( mm_log_handler , pmonitor ) ; privsep_preauth_child ( ) ; setproctitle ( "%s" , "[net]" ) ; if ( box != NULL ) ssh_sandbox_child ( box ) ; return 0 ; } }
static int smaps_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , struct mm_walk * walk ) { struct mem_size_stats * mss = walk -> private ; struct vm_area_struct * vma = mss -> vma ; pte_t * pte ; spinlock_t * ptl ; spin_lock ( & walk -> mm -> page_table_lock ) ; if ( pmd_trans_huge ( * pmd ) ) { if ( pmd_trans_splitting ( * pmd ) ) { spin_unlock ( & walk -> mm -> page_table_lock ) ; wait_split_huge_page ( vma -> anon_vma , pmd ) ; } else { smaps_pte_entry ( * ( pte_t * ) pmd , addr , HPAGE_PMD_SIZE , walk ) ; spin_unlock ( & walk -> mm -> page_table_lock ) ; mss -> anonymous_thp += HPAGE_PMD_SIZE ; return 0 ; } } else { spin_unlock ( & walk -> mm -> page_table_lock ) ; } pte = pte_offset_map_lock ( vma -> vm_mm , pmd , addr , & ptl ) ; for ( ; addr != end ; pte ++ , addr += PAGE_SIZE ) smaps_pte_entry ( * pte , addr , PAGE_SIZE , walk ) ; pte_unmap_unlock ( pte - 1 , ptl ) ; cond_resched ( ) ; return 0 ; }
Node * EffectControlLinearizer :: LowerCheckedUint32Mod ( Node * node , Node * frame_state ) { Node * lhs = node -> InputAt ( 0 ) ; Node * rhs = node -> InputAt ( 1 ) ; Node * zero = __ Int32Constant ( 0 ) ; Node * check = __ Word32Equal ( rhs , zero ) ; __ DeoptimizeIf ( DeoptimizeReason :: kDivisionByZero , VectorSlotPair ( ) , check , frame_state ) ; return BuildUint32Mod ( lhs , rhs ) ; }
nsDocument :: BlockOnload ( ) { if ( mDisplayDocument ) { mDisplayDocument -> BlockOnload ( ) ; return ; } if ( mOnloadBlockCount == 0 && mScriptGlobalObject ) { if ( ! nsContentUtils :: IsSafeToRunScript ( ) ) { ++ mAsyncOnloadBlockCount ; if ( mAsyncOnloadBlockCount == 1 ) { nsContentUtils :: AddScriptRunner ( NS_NEW_RUNNABLE_METHOD ( nsDocument , this , AsyncBlockOnload ) ) ; } return ; } nsCOMPtr < nsILoadGroup > loadGroup = GetDocumentLoadGroup ( ) ; if ( loadGroup ) { loadGroup -> AddRequest ( mOnloadBlocker , nsnull ) ; } } ++ mOnloadBlockCount ; }
void Run ( PipelineData * data , Zone * temp_zone ) { GraphTrimmer trimmer ( temp_zone , data -> graph ( ) ) ; NodeVector roots ( temp_zone ) ; data -> jsgraph ( ) -> GetCachedNodes ( & roots ) ; trimmer . TrimGraph ( roots . begin ( ) , roots . end ( ) ) ; MemoryOptimizer optimizer ( data -> jsgraph ( ) , temp_zone , data -> info ( ) -> GetPoisoningMitigationLevel ( ) , data -> info ( ) -> is_allocation_folding_enabled ( ) ? MemoryOptimizer :: AllocationFolding :: kDoAllocationFolding : MemoryOptimizer :: AllocationFolding :: kDontAllocationFolding ) ; optimizer . Optimize ( ) ; }
RepresentationSelector ( JSGraph * jsgraph , JSHeapBroker * js_heap_broker , Zone * zone , RepresentationChanger * changer , SourcePositionTable * source_positions , NodeOriginTable * node_origins ) : jsgraph_ ( jsgraph ) , zone_ ( zone ) , count_ ( jsgraph -> graph ( ) -> NodeCount ( ) ) , info_ ( count_ , zone ) , #ifdef DEBUG node_input_use_infos_ ( count_ , InputUseInfos ( zone ) , zone ) , #endif nodes_ ( zone ) , replacements_ ( zone ) , phase_ ( PROPAGATE ) , changer_ ( changer ) , queue_ ( zone ) , typing_stack_ ( zone ) , source_positions_ ( source_positions ) , node_origins_ ( node_origins ) , type_cache_ ( TypeCache :: Get ( ) ) , op_typer_ ( jsgraph -> isolate ( ) , js_heap_broker , graph_zone ( ) ) { }
TfLiteRegistration CancelOpRegistration ( ) { TfLiteRegistration reg = { nullptr , nullptr , nullptr , nullptr } ; reg . prepare = [ ] ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteTensor * in_tensor = GetInput ( context , node , 0 ) ; TfLiteTensor * out_tensor = GetOutput ( context , node , 0 ) ; TfLiteIntArray * new_size = TfLiteIntArrayCopy ( in_tensor -> dims ) ; return context -> ResizeTensor ( context , out_tensor , new_size ) ; } ; reg . invoke = [ ] ( TfLiteContext * context , TfLiteNode * node ) { cancellation_data_ . is_cancelled = true ; return kTfLiteOk ; } ; return reg ; }
void IncrementalMarking :: UpdateWeakReferencesAfterScavenge ( ) { weak_objects_ -> weak_references . Update ( [ ] ( std :: pair < HeapObject * , HeapObjectReference * * > slot_in , std :: pair < HeapObject * , HeapObjectReference * * > * slot_out ) -> bool { HeapObject * heap_obj = slot_in . first ; HeapObject * forwarded = ForwardingAddress ( heap_obj ) ; if ( forwarded ) { ptrdiff_t distance_to_slot = reinterpret_cast < Address > ( slot_in . second ) - reinterpret_cast < Address > ( slot_in . first ) ; Address new_slot = reinterpret_cast < Address > ( forwarded ) + distance_to_slot ; slot_out -> first = forwarded ; slot_out -> second = reinterpret_cast < HeapObjectReference * * > ( new_slot ) ; return true ; } return false ; } ) ; weak_objects_ -> weak_objects_in_code . Update ( [ ] ( std :: pair < HeapObject * , Code * > slot_in , std :: pair < HeapObject * , Code * > * slot_out ) -> bool { HeapObject * heap_obj = slot_in . first ; HeapObject * forwarded = ForwardingAddress ( heap_obj ) ; if ( forwarded ) { slot_out -> first = forwarded ; slot_out -> second = slot_in . second ; return true ; } return false ; } ) ; weak_objects_ -> ephemeron_hash_tables . Update ( [ ] ( EphemeronHashTable * slot_in , EphemeronHashTable * * slot_out ) -> bool { EphemeronHashTable * forwarded = ForwardingAddress ( slot_in ) ; if ( forwarded ) { * slot_out = forwarded ; return true ; } return false ; } ) ; auto ephemeron_updater = [ ] ( Ephemeron slot_in , Ephemeron * slot_out ) -> bool { HeapObject * key = slot_in . key ; HeapObject * value = slot_in . value ; HeapObject * forwarded_key = ForwardingAddress ( key ) ; HeapObject * forwarded_value = ForwardingAddress ( value ) ; if ( forwarded_key && forwarded_value ) { * slot_out = Ephemeron { forwarded_key , forwarded_value } ; return true ; } return false ; } ; weak_objects_ -> current_ephemerons . Update ( ephemeron_updater ) ; weak_objects_ -> next_ephemerons . Update ( ephemeron_updater ) ; weak_objects_ -> discovered_ephemerons . Update ( ephemeron_updater ) ; }
FT_MulDiv_No_Round ( FT_Long a_ , FT_Long b_ , FT_Long c_ ) { FT_Int s = 1 ; FT_UInt32 a , b , c ; if ( a_ == 0 || b_ == c_ ) return a_ ; FT_MOVE_SIGN ( a_ , s ) ; FT_MOVE_SIGN ( b_ , s ) ; FT_MOVE_SIGN ( c_ , s ) ; a = ( FT_UInt32 ) a_ ; b = ( FT_UInt32 ) b_ ; c = ( FT_UInt32 ) c_ ; if ( c == 0 ) a = 0x7FFFFFFFUL ; else if ( a + b <= 131071UL ) a = a * b / c ; else { FT_Int64 temp ; ft_multo64 ( a , b , & temp ) ; a = temp . hi == 0 ? temp . lo / c : ft_div64by32 ( temp . hi , temp . lo , c ) ; } a_ = ( FT_Long ) a ; return s < 0 ? - a_ : a_ ; }
bool MemFile :: seek ( int64_t offset , int whence ) { assertx ( m_len != - 1 ) ; if ( whence == SEEK_CUR ) { if ( offset > 0 && offset < bufferedLen ( ) ) { setReadPosition ( getReadPosition ( ) + offset ) ; setPosition ( getPosition ( ) + offset ) ; return true ; } offset += getPosition ( ) ; whence = SEEK_SET ; } setWritePosition ( 0 ) ; setReadPosition ( 0 ) ; if ( whence == SEEK_SET ) { m_cursor = offset ; } else { assertx ( whence == SEEK_END ) ; m_cursor = m_len + offset ; } setPosition ( m_cursor ) ; return true ; }
ft_var_readpackedpoints ( FT_Stream stream , FT_UInt * point_cnt ) { FT_UShort * points = NULL ; FT_UInt n ; FT_UInt runcnt ; FT_UInt i , j ; FT_UShort first ; FT_Memory memory = stream -> memory ; FT_Error error = FT_Err_Ok ; FT_UNUSED ( error ) ; * point_cnt = 0 ; n = FT_GET_BYTE ( ) ; if ( n == 0 ) return ALL_POINTS ; if ( n & GX_PT_POINTS_ARE_WORDS ) { n &= GX_PT_POINT_RUN_COUNT_MASK ; n <<= 8 ; n |= FT_GET_BYTE ( ) ; } if ( FT_NEW_ARRAY ( points , n ) ) return NULL ; * point_cnt = n ; i = 0 ; while ( i < n ) { runcnt = FT_GET_BYTE ( ) ; if ( runcnt & GX_PT_POINTS_ARE_WORDS ) { runcnt &= GX_PT_POINT_RUN_COUNT_MASK ; first = FT_GET_USHORT ( ) ; points [ i ++ ] = first ; if ( runcnt < 1 || i + runcnt > n ) goto Exit ; for ( j = 0 ; j < runcnt ; j ++ ) { first += FT_GET_USHORT ( ) ; points [ i ++ ] = first ; } } else { first = FT_GET_BYTE ( ) ; points [ i ++ ] = first ; if ( runcnt < 1 || i + runcnt > n ) goto Exit ; for ( j = 0 ; j < runcnt ; j ++ ) { first += FT_GET_BYTE ( ) ; points [ i ++ ] = first ; } } } Exit : return points ; }
static int check_mem_access ( struct bpf_verifier_env * env , int insn_idx , u32 regno , int off , int bpf_size , enum bpf_access_type t , int value_regno ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = cur_regs ( env ) ; struct bpf_reg_state * reg = regs + regno ; int size , err = 0 ; size = bpf_size_to_bytes ( bpf_size ) ; if ( size < 0 ) return size ; err = check_ptr_alignment ( env , reg , off , size ) ; if ( err ) return err ; off += reg -> off ; if ( reg -> type == PTR_TO_MAP_VALUE ) { if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , "R%d leaks addr into map\n" , value_regno ) ; return - EACCES ; } err = check_map_access ( env , regno , off , size , false ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) mark_reg_unknown ( env , regs , value_regno ) ; } else if ( reg -> type == PTR_TO_CTX ) { enum bpf_reg_type reg_type = SCALAR_VALUE ; if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , "R%d leaks addr into ctx\n" , value_regno ) ; return - EACCES ; } if ( reg -> off ) { verbose ( env , "dereference of modified ctx ptr R%d off=%d+%d, ctx+const is allowed, ctx+const+const is not\n" , regno , reg -> off , off - reg -> off ) ; return - EACCES ; } if ( ! tnum_is_const ( reg -> var_off ) || reg -> var_off . value ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; verbose ( env , "variable ctx access var_off=%s off=%d size=%d" , tn_buf , off , size ) ; return - EACCES ; } err = check_ctx_access ( env , insn_idx , off , size , t , & reg_type ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) { if ( reg_type == SCALAR_VALUE ) mark_reg_unknown ( env , regs , value_regno ) ; else mark_reg_known_zero ( env , regs , value_regno ) ; regs [ value_regno ] . id = 0 ; regs [ value_regno ] . off = 0 ; regs [ value_regno ] . range = 0 ; regs [ value_regno ] . type = reg_type ; } } else if ( reg -> type == PTR_TO_STACK ) { if ( ! tnum_is_const ( reg -> var_off ) ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; verbose ( env , "variable stack access var_off=%s off=%d size=%d" , tn_buf , off , size ) ; return - EACCES ; } off += reg -> var_off . value ; if ( off >= 0 || off < - MAX_BPF_STACK ) { verbose ( env , "invalid stack off=%d size=%d\n" , off , size ) ; return - EACCES ; } if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ; if ( t == BPF_WRITE ) err = check_stack_write ( env , state , off , size , value_regno ) ; else err = check_stack_read ( env , state , off , size , value_regno ) ; } else if ( reg_is_pkt_pointer ( reg ) ) { if ( t == BPF_WRITE && ! may_access_direct_pkt_data ( env , NULL , t ) ) { verbose ( env , "cannot write into packet\n" ) ; return - EACCES ; } if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , "R%d leaks addr into packet\n" , value_regno ) ; return - EACCES ; } err = check_packet_access ( env , regno , off , size , false ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) mark_reg_unknown ( env , regs , value_regno ) ; } else { verbose ( env , "R%d invalid mem access '%s'\n" , regno , reg_type_str [ reg -> type ] ) ; return - EACCES ; } if ( ! err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ && regs [ value_regno ] . type == SCALAR_VALUE ) { regs [ value_regno ] . var_off = tnum_cast ( regs [ value_regno ] . var_off , size ) ; __update_reg_bounds ( & regs [ value_regno ] ) ; } return err ; }
xmlNanoFTPFreeCtxt ( void * ctx ) { xmlNanoFTPCtxtPtr ctxt = ( xmlNanoFTPCtxtPtr ) ctx ; if ( ctxt == NULL ) return ; if ( ctxt -> hostname != NULL ) xmlFree ( ctxt -> hostname ) ; if ( ctxt -> protocol != NULL ) xmlFree ( ctxt -> protocol ) ; if ( ctxt -> path != NULL ) xmlFree ( ctxt -> path ) ; ctxt -> passive = 1 ; if ( ctxt -> controlFd != INVALID_SOCKET ) closesocket ( ctxt -> controlFd ) ; ctxt -> controlFd = INVALID_SOCKET ; ctxt -> controlBufIndex = - 1 ; ctxt -> controlBufUsed = - 1 ; xmlFree ( ctxt ) ; }
static Handle < JSObject > Create ( Isolate * isolate , Handle < HeapObject > description , int flags , PretenureFlag pretenure_flag ) { Handle < ArrayBoilerplateDescription > array_boilerplate_description = Handle < ArrayBoilerplateDescription > :: cast ( description ) ; ElementsKind constant_elements_kind = array_boilerplate_description -> elements_kind ( ) ; Handle < FixedArrayBase > constant_elements_values ( array_boilerplate_description -> constant_elements ( ) , isolate ) ; Handle < FixedArrayBase > copied_elements_values ; if ( IsDoubleElementsKind ( constant_elements_kind ) ) { copied_elements_values = isolate -> factory ( ) -> CopyFixedDoubleArray ( Handle < FixedDoubleArray > :: cast ( constant_elements_values ) ) ; } else { DCHECK ( IsSmiOrObjectElementsKind ( constant_elements_kind ) ) ; const bool is_cow = ( constant_elements_values -> map ( ) == ReadOnlyRoots ( isolate ) . fixed_cow_array_map ( ) ) ; if ( is_cow ) { copied_elements_values = constant_elements_values ; #if DEBUG Handle < FixedArray > fixed_array_values = Handle < FixedArray > :: cast ( copied_elements_values ) ; for ( int i = 0 ; i < fixed_array_values -> length ( ) ; i ++ ) { DCHECK ( ! fixed_array_values -> get ( i ) -> IsFixedArray ( ) ) ; } #endif } else { Handle < FixedArray > fixed_array_values = Handle < FixedArray > :: cast ( constant_elements_values ) ; Handle < FixedArray > fixed_array_values_copy = isolate -> factory ( ) -> CopyFixedArray ( fixed_array_values ) ; copied_elements_values = fixed_array_values_copy ; FOR_WITH_HANDLE_SCOPE ( isolate , int , i = 0 , i , i < fixed_array_values -> length ( ) , i ++ , { Handle < Object > value ( fixed_array_values -> get ( i ) , isolate ) ; if ( value -> IsArrayBoilerplateDescription ( ) || value -> IsObjectBoilerplateDescription ( ) ) { Handle < Object > result = InnerCreateBoilerplate ( isolate , value , pretenure_flag ) ; fixed_array_values_copy -> set ( i , * result ) ; } } ) ; } } return isolate -> factory ( ) -> NewJSArrayWithElements ( copied_elements_values , constant_elements_kind , copied_elements_values -> length ( ) , pretenure_flag ) ; }
nsFrameLoader :: MaybeCreateDocShell ( ) { if ( mDocShell ) { return NS_OK ; } if ( mRemoteFrame ) { return NS_OK ; } NS_ENSURE_STATE ( ! mDestroyCalled ) ; if ( ShouldUseRemoteProcess ( ) ) { mRemoteFrame = true ; return NS_OK ; } nsIDocument * doc = mOwnerContent -> OwnerDoc ( ) ; if ( ! ( doc -> IsStaticDocument ( ) || mOwnerContent -> IsInDoc ( ) ) ) { return NS_ERROR_UNEXPECTED ; } if ( doc -> IsResourceDoc ( ) || ! doc -> IsActive ( ) ) { return NS_ERROR_NOT_AVAILABLE ; } nsCOMPtr < nsISupports > container = doc -> GetContainer ( ) ; nsCOMPtr < nsIWebNavigation > parentAsWebNav = do_QueryInterface ( container ) ; NS_ENSURE_STATE ( parentAsWebNav ) ; mDocShell = do_CreateInstance ( "@mozilla.org/docshell;1" ) ; NS_ENSURE_TRUE ( mDocShell , NS_ERROR_FAILURE ) ; if ( ! mNetworkCreated ) { if ( mDocShell ) { mDocShell -> SetCreatedDynamically ( true ) ; } } NS_ENSURE_TRUE ( mDocShell , NS_ERROR_FAILURE ) ; nsAutoString frameName ; int32_t namespaceID = mOwnerContent -> GetNameSpaceID ( ) ; if ( namespaceID == kNameSpaceID_XHTML && ! mOwnerContent -> IsInHTMLDocument ( ) ) { mOwnerContent -> GetAttr ( kNameSpaceID_None , nsGkAtoms :: id , frameName ) ; } else { mOwnerContent -> GetAttr ( kNameSpaceID_None , nsGkAtoms :: name , frameName ) ; if ( frameName . IsEmpty ( ) && namespaceID == kNameSpaceID_XUL ) { mOwnerContent -> GetAttr ( kNameSpaceID_None , nsGkAtoms :: id , frameName ) ; } } if ( ! frameName . IsEmpty ( ) ) { mDocShell -> SetName ( frameName ) ; } nsCOMPtr < nsIDocShellTreeNode > parentAsNode ( do_QueryInterface ( parentAsWebNav ) ) ; if ( parentAsNode ) { nsCOMPtr < nsIDocShellTreeItem > parentAsItem = do_QueryInterface ( parentAsNode ) ; int32_t parentType ; parentAsItem -> GetItemType ( & parentType ) ; nsCOMPtr < nsIDocShellTreeOwner > parentTreeOwner ; parentAsItem -> GetTreeOwner ( getter_AddRefs ( parentTreeOwner ) ) ; NS_ENSURE_STATE ( parentTreeOwner ) ; mIsTopLevelContent = AddTreeItemToTreeOwner ( mDocShell , parentTreeOwner , parentType , parentAsNode ) ; nsCOMPtr < nsIDOMEventTarget > chromeEventHandler ; if ( parentType == nsIDocShellTreeItem :: typeChrome ) { chromeEventHandler = do_QueryInterface ( mOwnerContent ) ; NS_ASSERTION ( chromeEventHandler , "This mContent should implement this." ) ; } else { nsCOMPtr < nsIDocShell > parentShell ( do_QueryInterface ( parentAsNode ) ) ; parentShell -> GetChromeEventHandler ( getter_AddRefs ( chromeEventHandler ) ) ; } mDocShell -> SetChromeEventHandler ( chromeEventHandler ) ; } nsCOMPtr < Element > frame_element = mOwnerContent ; NS_ASSERTION ( frame_element , "frame loader owner element not a DOM element!" ) ; nsCOMPtr < nsPIDOMWindow > win_private ( do_GetInterface ( mDocShell ) ) ; nsCOMPtr < nsIBaseWindow > base_win ( do_QueryInterface ( mDocShell ) ) ; if ( win_private ) { win_private -> SetFrameElementInternal ( frame_element ) ; } if ( NS_FAILED ( base_win -> Create ( ) ) || ! win_private ) { NS_WARNING ( "Something wrong when creating the docshell for a frameloader!" ) ; return NS_ERROR_FAILURE ; } EnsureMessageManager ( ) ; if ( OwnerIsAppFrame ( ) ) { MOZ_ASSERT ( ! OwnerIsBrowserFrame ( ) ) ; nsCOMPtr < mozIApplication > ownApp = GetOwnApp ( ) ; MOZ_ASSERT ( ownApp ) ; uint32_t ownAppId = nsIScriptSecurityManager :: NO_APP_ID ; if ( ownApp ) { NS_ENSURE_SUCCESS ( ownApp -> GetLocalId ( & ownAppId ) , NS_ERROR_FAILURE ) ; } mDocShell -> SetIsApp ( ownAppId ) ; } if ( OwnerIsBrowserFrame ( ) ) { MOZ_ASSERT ( ! OwnerIsAppFrame ( ) ) ; nsCOMPtr < mozIApplication > containingApp = GetContainingApp ( ) ; uint32_t containingAppId = nsIScriptSecurityManager :: NO_APP_ID ; if ( containingApp ) { NS_ENSURE_SUCCESS ( containingApp -> GetLocalId ( & containingAppId ) , NS_ERROR_FAILURE ) ; } mDocShell -> SetIsBrowserInsideApp ( containingAppId ) ; } if ( OwnerIsBrowserOrAppFrame ( ) ) { nsCOMPtr < nsIObserverService > os = services :: GetObserverService ( ) ; if ( os ) { os -> NotifyObservers ( NS_ISUPPORTS_CAST ( nsIFrameLoader * , this ) , "in-process-browser-or-app-frame-shown" , nullptr ) ; } if ( mMessageManager ) { mMessageManager -> LoadFrameScript ( NS_LITERAL_STRING ( "chrome://global/content/BrowserElementChild.js" ) , true ) ; } } return NS_OK ; }
Handle < JSArray > Factory :: NewJSArray ( ElementsKind elements_kind , PretenureFlag pretenure ) { NativeContext * native_context = isolate ( ) -> raw_native_context ( ) ; Map * map = native_context -> GetInitialJSArrayMap ( elements_kind ) ; if ( map == nullptr ) { JSFunction * array_function = native_context -> array_function ( ) ; map = array_function -> initial_map ( ) ; } return Handle < JSArray > :: cast ( NewJSObjectFromMap ( handle ( map , isolate ( ) ) , pretenure ) ) ; }
static int llcp_sock_bind ( struct socket * sock , struct sockaddr * addr , int alen ) { struct sock * sk = sock -> sk ; struct nfc_llcp_sock * llcp_sock = nfc_llcp_sock ( sk ) ; struct nfc_llcp_local * local ; struct nfc_dev * dev ; struct sockaddr_nfc_llcp llcp_addr ; int len , ret = 0 ; if ( ! addr || alen < offsetofend ( struct sockaddr , sa_family ) || addr -> sa_family != AF_NFC ) return - EINVAL ; pr_debug ( "sk %p addr %p family %d\n" , sk , addr , addr -> sa_family ) ; memset ( & llcp_addr , 0 , sizeof ( llcp_addr ) ) ; len = min_t ( unsigned int , sizeof ( llcp_addr ) , alen ) ; memcpy ( & llcp_addr , addr , len ) ; if ( llcp_addr . dsap != 0 ) return - EINVAL ; lock_sock ( sk ) ; if ( sk -> sk_state != LLCP_CLOSED ) { ret = - EBADFD ; goto error ; } dev = nfc_get_device ( llcp_addr . dev_idx ) ; if ( dev == NULL ) { ret = - ENODEV ; goto error ; } local = nfc_llcp_find_local ( dev ) ; if ( local == NULL ) { ret = - ENODEV ; goto put_dev ; } llcp_sock -> dev = dev ; llcp_sock -> local = nfc_llcp_local_get ( local ) ; llcp_sock -> nfc_protocol = llcp_addr . nfc_protocol ; llcp_sock -> service_name_len = min_t ( unsigned int , llcp_addr . service_name_len , NFC_LLCP_MAX_SERVICE_NAME ) ; llcp_sock -> service_name = kmemdup ( llcp_addr . service_name , llcp_sock -> service_name_len , GFP_KERNEL ) ; if ( ! llcp_sock -> service_name ) { nfc_llcp_local_put ( llcp_sock -> local ) ; llcp_sock -> local = NULL ; ret = - ENOMEM ; goto put_dev ; } llcp_sock -> ssap = nfc_llcp_get_sdp_ssap ( local , llcp_sock ) ; if ( llcp_sock -> ssap == LLCP_SAP_MAX ) { nfc_llcp_local_put ( llcp_sock -> local ) ; llcp_sock -> local = NULL ; kfree ( llcp_sock -> service_name ) ; llcp_sock -> service_name = NULL ; ret = - EADDRINUSE ; goto put_dev ; } llcp_sock -> reserved_ssap = llcp_sock -> ssap ; nfc_llcp_sock_link ( & local -> sockets , sk ) ; pr_debug ( "Socket bound to SAP %d\n" , llcp_sock -> ssap ) ; sk -> sk_state = LLCP_BOUND ; put_dev : nfc_put_device ( dev ) ; error : release_sock ( sk ) ; return ret ; }
RUNTIME_FUNCTION ( Runtime_DefineSetterPropertyUnchecked ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 4 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSObject , object , 0 ) ; CONVERT_ARG_HANDLE_CHECKED ( Name , name , 1 ) ; CONVERT_ARG_HANDLE_CHECKED ( JSFunction , setter , 2 ) ; CONVERT_PROPERTY_ATTRIBUTES_CHECKED ( attrs , 3 ) ; if ( String :: cast ( setter -> shared ( ) -> Name ( ) ) -> length ( ) == 0 ) { Handle < Map > setter_map ( setter -> map ( ) , isolate ) ; if ( ! JSFunction :: SetName ( setter , name , isolate -> factory ( ) -> set_string ( ) ) ) { return ReadOnlyRoots ( isolate ) . exception ( ) ; } CHECK_EQ ( * setter_map , setter -> map ( ) ) ; } RETURN_FAILURE_ON_EXCEPTION ( isolate , JSObject :: DefineAccessor ( object , name , isolate -> factory ( ) -> null_value ( ) , setter , attrs ) ) ; return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
const char * enc_untrusted_inet_ntop ( int af , const void * src , char * dst , socklen_t size ) { if ( ! src || ! dst ) { errno = EFAULT ; return nullptr ; } size_t src_size = 0 ; if ( af == AF_INET ) { src_size = sizeof ( struct in_addr ) ; } else if ( af == AF_INET6 ) { src_size = sizeof ( struct in6_addr ) ; } else { errno = EAFNOSUPPORT ; return nullptr ; } MessageWriter input ; input . Push < int > ( TokLinuxAfFamily ( af ) ) ; input . PushByReference ( Extent { reinterpret_cast < const char * > ( src ) , src_size } ) ; input . Push ( size ) ; MessageReader output ; const auto status = NonSystemCallDispatcher ( :: asylo :: host_call :: kInetNtopHandler , & input , & output ) ; CheckStatusAndParamCount ( status , output , "enc_untrusted_inet_ntop" , 2 ) ; auto result = output . next ( ) ; int klinux_errno = output . next < int > ( ) ; if ( result . empty ( ) ) { errno = FromkLinuxErrorNumber ( klinux_errno ) ; return nullptr ; } memcpy ( dst , result . data ( ) , std :: min ( static_cast < size_t > ( size ) , static_cast < size_t > ( INET6_ADDRSTRLEN ) ) ) ; return dst ; }
int arm_cpu_caps ( void ) { int flags ; int mask ; if ( ! arm_cpu_env_flags ( & flags ) ) { return flags ; } mask = arm_cpu_env_mask ( ) ; #if HAVE_EDSP if ( mask & HAS_EDSP ) { __try { __emit ( 0xF5DDF000 ) ; flags |= HAS_EDSP ; } __except ( GetExceptionCode ( ) == EXCEPTION_ILLEGAL_INSTRUCTION ) { } } #if HAVE_MEDIA if ( mask & HAS_MEDIA ) __try { __emit ( 0xE6333F93 ) ; flags |= HAS_MEDIA ; } __except ( GetExceptionCode ( ) == EXCEPTION_ILLEGAL_INSTRUCTION ) { } }
long oggpackB_read1 ( oggpack_buffer * b ) { long ret ; if ( b -> endbyte >= b -> storage ) { ret = - 1L ; goto overflow ; } ret = ( b -> ptr [ 0 ] > > ( 7 - b -> endbit ) ) & 1 ; overflow : b -> endbit ++ ; if ( b -> endbit > 7 ) { b -> endbit = 0 ; b -> ptr ++ ; b -> endbyte ++ ; } return ( ret ) ; }
Handle < Object > ErrorThrower :: Reify ( ) { Handle < JSFunction > constructor ; switch ( error_type_ ) { case kNone : UNREACHABLE ( ) ; case kTypeError : constructor = isolate_ -> type_error_function ( ) ; break ; case kRangeError : constructor = isolate_ -> range_error_function ( ) ; break ; case kCompileError : constructor = isolate_ -> wasm_compile_error_function ( ) ; break ; case kLinkError : constructor = isolate_ -> wasm_link_error_function ( ) ; break ; case kRuntimeError : constructor = isolate_ -> wasm_runtime_error_function ( ) ; break ; } Vector < const char > msg_vec ( error_msg_ . data ( ) , error_msg_ . size ( ) ) ; Handle < String > message = isolate_ -> factory ( ) -> NewStringFromUtf8 ( msg_vec ) . ToHandleChecked ( ) ; Reset ( ) ; return isolate_ -> factory ( ) -> NewError ( constructor , message ) ; }
static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , int ctr_id , va_list args ) { vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ; if ( frame != NULL ) { YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp9_copy_reference_enc ( ctx -> cpi , ref_frame_to_vp9_reframe ( frame -> frame_type ) , & sd ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
int64_t BZ2File :: readImpl ( char * buf , int64_t length ) { if ( length == 0 ) { return 0 ; } assertx ( m_bzFile ) ; int len = BZ2_bzread ( m_bzFile , buf , length ) ; if ( len <= 0 ) { setEof ( true ) ; if ( len < 0 ) { return - 1 ; } } return len ; }
TEST_F ( SvcTest , SetMultipleOptions ) { vpx_codec_err_t res = vpx_svc_set_options ( & svc_ , "layers=2 encoding-mode=ip" ) ; res = vpx_svc_init ( & svc_ , & codec_ , vpx_codec_vp9_cx ( ) , & codec_enc_ ) ; EXPECT_EQ ( VPX_CODEC_OK , res ) ; codec_initialized_ = true ; EXPECT_EQ ( 2 , svc_ . spatial_layers ) ; EXPECT_EQ ( INTER_LAYER_PREDICTION_IP , svc_ . encoding_mode ) ; }
DataViewObject :: neuter ( void * newData ) { setSlot ( BYTELENGTH_SLOT , Int32Value ( 0 ) ) ; setSlot ( BYTEOFFSET_SLOT , Int32Value ( 0 ) ) ; setPrivate ( newData ) ; }
_evaluate ( NPP npp , NPObject * npobj , NPString * script , NPVariant * result ) { if ( ! NS_IsMainThread ( ) ) { NPN_PLUGIN_LOG ( PLUGIN_LOG_ALWAYS , ( "NPN_evaluate called from the wrong thread\n" ) ) ; return false ; } if ( ! npp ) return false ; NPPAutoPusher nppPusher ( npp ) ; nsIDocument * doc = GetDocumentFromNPP ( npp ) ; NS_ENSURE_TRUE ( doc , false ) ; JSContext * cx = GetJSContextFromDoc ( doc ) ; NS_ENSURE_TRUE ( cx , false ) ; JSObject * obj = nsNPObjWrapper :: GetNewOrUsed ( npp , cx , npobj ) ; if ( ! obj ) { return false ; } jsval vec [ ] = { OBJECT_TO_JSVAL ( obj ) , JSVAL_NULL } ; JSAutoTempValueRooter tvr ( cx , NS_ARRAY_LENGTH ( vec ) , vec ) ; jsval * rval = & vec [ 1 ] ; if ( result ) { VOID_TO_NPVARIANT ( * result ) ; } if ( ! script || ! script -> UTF8Length || ! script -> UTF8Characters ) { return true ; } NS_ConvertUTF8toUTF16 utf16script ( script -> UTF8Characters , script -> UTF8Length ) ; nsCOMPtr < nsIScriptContext > scx = GetScriptContextFromJSContext ( cx ) ; NS_ENSURE_TRUE ( scx , false ) ; nsIPrincipal * principal = doc -> NodePrincipal ( ) ; nsCAutoString specStr ; const char * spec ; nsCOMPtr < nsIURI > uri ; principal -> GetURI ( getter_AddRefs ( uri ) ) ; if ( uri ) { uri -> GetSpec ( specStr ) ; spec = specStr . get ( ) ; } else { uri = doc -> GetDocumentURI ( ) ; PRBool isChrome = PR_FALSE ; if ( uri && NS_SUCCEEDED ( uri -> SchemeIs ( "chrome" , & isChrome ) ) && isChrome ) { uri -> GetSpec ( specStr ) ; spec = specStr . get ( ) ; } else { spec = nsnull ; } } NPN_PLUGIN_LOG ( PLUGIN_LOG_NOISY , ( "NPN_Evaluate(npp %p, npobj %p, script <<<%s>>>) called\n" , npp , npobj , script -> UTF8Characters ) ) ; nsresult rv = scx -> EvaluateStringWithValue ( utf16script , obj , principal , spec , 0 , 0 , rval , nsnull ) ; return NS_SUCCEEDED ( rv ) && ( ! result || JSValToNPVariant ( npp , cx , * rval , result ) ) ; }
static PyObject * __pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter_14__setstate_cython__ ( struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter * __pyx_v_self , PyObject * __pyx_v___pyx_state ) { PyObject * __pyx_r = NULL ; __Pyx_RefNannyDeclarations PyObject * __pyx_t_1 = NULL ; __Pyx_RefNannySetupContext ( "__setstate_cython__" , 0 ) ; if ( ! ( likely ( PyTuple_CheckExact ( __pyx_v___pyx_state ) ) || ( ( __pyx_v___pyx_state ) == Py_None ) || ( PyErr_Format ( PyExc_TypeError , "Expected %.16s, got %.200s" , "tuple" , Py_TYPE ( __pyx_v___pyx_state ) -> tp_name ) , 0 ) ) ) __PYX_ERR ( 1 , 17 , __pyx_L1_error ) __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedwriter___pyx_unpickle_BufferedWriter__set_state ( __pyx_v_self , ( ( PyObject * ) __pyx_v___pyx_state ) ) ; if ( unlikely ( ! __pyx_t_1 ) ) __PYX_ERR ( 1 , 17 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_1 ) ; __Pyx_DECREF ( __pyx_t_1 ) ; __pyx_t_1 = 0 ; __pyx_r = Py_None ; __Pyx_INCREF ( Py_None ) ; goto __pyx_L0 ; __pyx_L1_error : ; __Pyx_XDECREF ( __pyx_t_1 ) ; __Pyx_AddTraceback ( "clickhouse_driver.bufferedwriter.BufferedWriter.__setstate_cython__" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __pyx_r = NULL ; __pyx_L0 : ; __Pyx_XGIVEREF ( __pyx_r ) ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
CanvasRenderingContext2D :: DrawWindow ( nsIDOMWindow * window , double x , double y , double w , double h , const nsAString & bgColor , uint32_t flags , ErrorResult & error ) { if ( ! gfxASurface :: CheckSurfaceSize ( gfxIntSize ( int32_t ( w ) , int32_t ( h ) ) , 0xffff ) ) { error . Throw ( NS_ERROR_FAILURE ) ; return ; } EnsureTarget ( ) ; if ( ! nsContentUtils :: IsCallerChrome ( ) ) { error . Throw ( NS_ERROR_DOM_SECURITY_ERR ) ; return ; } if ( ! ( flags & nsIDOMCanvasRenderingContext2D :: DRAWWINDOW_DO_NOT_FLUSH ) ) { nsContentUtils :: FlushLayoutForTree ( window ) ; } nsRefPtr < nsPresContext > presContext ; nsCOMPtr < nsPIDOMWindow > win = do_QueryInterface ( window ) ; if ( win ) { nsIDocShell * docshell = win -> GetDocShell ( ) ; if ( docshell ) { docshell -> GetPresContext ( getter_AddRefs ( presContext ) ) ; } } if ( ! presContext ) { error . Throw ( NS_ERROR_FAILURE ) ; return ; } nscolor backgroundColor ; if ( ! ParseColor ( bgColor , & backgroundColor ) ) { error . Throw ( NS_ERROR_FAILURE ) ; return ; } nsRect r ( nsPresContext :: CSSPixelsToAppUnits ( ( float ) x ) , nsPresContext :: CSSPixelsToAppUnits ( ( float ) y ) , nsPresContext :: CSSPixelsToAppUnits ( ( float ) w ) , nsPresContext :: CSSPixelsToAppUnits ( ( float ) h ) ) ; uint32_t renderDocFlags = ( nsIPresShell :: RENDER_IGNORE_VIEWPORT_SCROLLING | nsIPresShell :: RENDER_DOCUMENT_RELATIVE ) ; if ( flags & nsIDOMCanvasRenderingContext2D :: DRAWWINDOW_DRAW_CARET ) { renderDocFlags |= nsIPresShell :: RENDER_CARET ; } if ( flags & nsIDOMCanvasRenderingContext2D :: DRAWWINDOW_DRAW_VIEW ) { renderDocFlags &= ~ ( nsIPresShell :: RENDER_IGNORE_VIEWPORT_SCROLLING | nsIPresShell :: RENDER_DOCUMENT_RELATIVE ) ; } if ( flags & nsIDOMCanvasRenderingContext2D :: DRAWWINDOW_USE_WIDGET_LAYERS ) { renderDocFlags |= nsIPresShell :: RENDER_USE_WIDGET_LAYERS ; } if ( flags & nsIDOMCanvasRenderingContext2D :: DRAWWINDOW_ASYNC_DECODE_IMAGES ) { renderDocFlags |= nsIPresShell :: RENDER_ASYNC_DECODE_IMAGES ; } Matrix matrix = mTarget -> GetTransform ( ) ; nsRefPtr < gfxContext > thebes ; if ( gfxPlatform :: GetPlatform ( ) -> SupportsAzureContent ( ) ) { thebes = new gfxContext ( mTarget ) ; } else { nsRefPtr < gfxASurface > drawSurf ; GetThebesSurface ( getter_AddRefs ( drawSurf ) ) ; thebes = new gfxContext ( drawSurf ) ; } thebes -> SetMatrix ( gfxMatrix ( matrix . _11 , matrix . _12 , matrix . _21 , matrix . _22 , matrix . _31 , matrix . _32 ) ) ; unused < < presContext -> PresShell ( ) -> RenderDocument ( r , renderDocFlags , backgroundColor , thebes ) ; mTarget -> SetTransform ( matrix ) ; RedrawUser ( gfxRect ( 0 , 0 , w , h ) ) ; }
txMozillaXSLTProcessor :: TransformToDoc ( nsIDOMDocument * aOutputDoc , nsIDOMDocument * * aResult ) { nsAutoPtr < txXPathNode > sourceNode ( txXPathNativeNode :: createXPathNode ( mSource ) ) ; if ( ! sourceNode ) { return NS_ERROR_OUT_OF_MEMORY ; } nsCOMPtr < nsIDOMDocument > sourceDOMDocument ; mSource -> GetOwnerDocument ( getter_AddRefs ( sourceDOMDocument ) ) ; if ( ! sourceDOMDocument ) { sourceDOMDocument = do_QueryInterface ( mSource ) ; } txExecutionState es ( mStylesheet , IsLoadDisabled ( ) ) ; txToDocHandlerFactory handlerFactory ( & es , sourceDOMDocument , aOutputDoc , mObserver ) ; es . mOutputHandlerFactory = & handlerFactory ; es . init ( * sourceNode , & mVariables ) ; nsresult rv = txXSLTProcessor :: execute ( es ) ; nsresult endRv = es . end ( rv ) ; if ( NS_SUCCEEDED ( rv ) ) { rv = endRv ; } if ( NS_SUCCEEDED ( rv ) ) { if ( aResult ) { txAOutputXMLEventHandler * handler = static_cast < txAOutputXMLEventHandler * > ( es . mOutputHandler ) ; handler -> getOutputDocument ( aResult ) ; nsCOMPtr < nsIDocument > doc = do_QueryInterface ( * aResult ) ; doc -> SetReadyStateInternal ( nsIDocument :: READYSTATE_COMPLETE ) ; } } else if ( mObserver ) { reportError ( rv , nsnull , nsnull ) ; } return rv ; }
gss_complete_auth_token ( OM_uint32 * minor_status , const gss_ctx_id_t context_handle , gss_buffer_t input_message_buffer ) { OM_uint32 status ; gss_union_ctx_id_t ctx ; gss_mechanism mech ; if ( context_handle == GSS_C_NO_CONTEXT ) return GSS_S_NO_CONTEXT ; ctx = ( gss_union_ctx_id_t ) context_handle ; mech = gssint_get_mechanism ( ctx -> mech_type ) ; if ( mech != NULL ) { if ( mech -> gss_complete_auth_token != NULL ) { status = mech -> gss_complete_auth_token ( minor_status , ctx -> internal_ctx_id , input_message_buffer ) ; if ( status != GSS_S_COMPLETE ) map_error ( minor_status , mech ) ; } else status = GSS_S_COMPLETE ; } else status = GSS_S_BAD_MECH ; return status ; }
int inet_sk_rebuild_header ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; struct rtable * rt = ( struct rtable * ) __sk_dst_check ( sk , 0 ) ; __be32 daddr ; int err ; if ( rt ) return 0 ; daddr = inet -> inet_daddr ; if ( inet -> opt && inet -> opt -> srr ) daddr = inet -> opt -> faddr ; rt = ip_route_output_ports ( sock_net ( sk ) , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; if ( ! IS_ERR ( rt ) ) { err = 0 ; sk_setup_caps ( sk , & rt -> dst ) ; } else { err = PTR_ERR ( rt ) ; sk -> sk_route_caps = 0 ; if ( ! sysctl_ip_dynaddr || sk -> sk_state != TCP_SYN_SENT || ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) || ( err = inet_sk_reselect_saddr ( sk ) ) != 0 ) sk -> sk_err_soft = - err ; } return err ; }
int ntlm_decode_target_info ( struct ntlm_ctx * ctx , struct ntlm_buffer * buffer , char * * nb_computer_name , char * * nb_domain_name , char * * dns_computer_name , char * * dns_domain_name , char * * dns_tree_name , char * * av_target_name , uint32_t * av_flags , uint64_t * av_timestamp , struct ntlm_buffer * av_single_host , struct ntlm_buffer * av_cb ) { struct wire_av_pair * av_pair ; uint16_t av_id = ( uint16_t ) - 1 ; uint16_t av_len = ( uint16_t ) - 1 ; struct ntlm_buffer sh = { NULL , 0 } ; struct ntlm_buffer cb = { NULL , 0 } ; char * nb_computer = NULL ; char * nb_domain = NULL ; char * dns_computer = NULL ; char * dns_domain = NULL ; char * dns_tree = NULL ; char * av_target = NULL ; size_t data_offs = 0 ; uint64_t timestamp = 0 ; uint32_t flags = 0 ; int ret = 0 ; while ( data_offs + 4 <= buffer -> length ) { av_pair = ( struct wire_av_pair * ) & buffer -> data [ data_offs ] ; data_offs += 4 ; av_id = le16toh ( av_pair -> av_id ) ; av_len = le16toh ( av_pair -> av_len ) ; if ( av_len > buffer -> length - data_offs ) { ret = ERR_DECODE ; goto done ; } data_offs += av_len ; switch ( av_id ) { case MSV_AV_CHANNEL_BINDINGS : if ( ! av_cb ) continue ; cb . data = av_pair -> value ; cb . length = av_len ; break ; case MSV_AV_TARGET_NAME : if ( ! av_target_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & av_target ) ; if ( ret ) goto done ; break ; case MSV_AV_SINGLE_HOST : if ( ! av_single_host ) continue ; sh . data = av_pair -> value ; sh . length = av_len ; break ; case MSV_AV_TIMESTAMP : if ( ! av_timestamp ) continue ; memcpy ( & timestamp , av_pair -> value , sizeof ( timestamp ) ) ; timestamp = le64toh ( timestamp ) ; break ; case MSV_AV_FLAGS : if ( ! av_flags ) continue ; memcpy ( & flags , av_pair -> value , sizeof ( flags ) ) ; flags = le32toh ( flags ) ; break ; case MSV_AV_DNS_TREE_NAME : if ( ! dns_tree_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & dns_tree ) ; if ( ret ) goto done ; break ; case MSV_AV_DNS_DOMAIN_NAME : if ( ! dns_domain_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & dns_domain ) ; if ( ret ) goto done ; break ; case MSV_AV_DNS_COMPUTER_NAME : if ( ! dns_computer_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & dns_computer ) ; if ( ret ) goto done ; break ; case MSV_AV_NB_DOMAIN_NAME : if ( ! nb_domain_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & nb_domain ) ; if ( ret ) goto done ; break ; case MSV_AV_NB_COMPUTER_NAME : if ( ! nb_computer_name ) continue ; ret = ntlm_decode_av_pair_u16l_str ( ctx , av_pair , & nb_computer ) ; if ( ret ) goto done ; break ; default : break ; } if ( av_id == MSV_AV_EOL ) break ; } if ( av_id != MSV_AV_EOL || av_len != 0 ) { ret = ERR_DECODE ; } done : if ( ret ) { safefree ( nb_computer ) ; safefree ( nb_domain ) ; safefree ( dns_computer ) ; safefree ( dns_domain ) ; safefree ( dns_tree ) ; safefree ( av_target ) ; } else { if ( nb_computer_name ) * nb_computer_name = nb_computer ; if ( nb_domain_name ) * nb_domain_name = nb_domain ; if ( dns_computer_name ) * dns_computer_name = dns_computer ; if ( dns_domain_name ) * dns_domain_name = dns_domain ; if ( dns_tree_name ) * dns_tree_name = dns_tree ; if ( av_target_name ) * av_target_name = av_target ; if ( av_timestamp ) * av_timestamp = timestamp ; if ( av_single_host ) * av_single_host = sh ; if ( av_flags ) * av_flags = flags ; if ( av_cb ) * av_cb = cb ; } return ret ; }
static CACHE_BRUSH_ORDER * update_read_cache_brush_order ( rdpUpdate * update , wStream * s , UINT16 flags ) { int i ; BYTE iBitmapFormat ; BOOL compressed = FALSE ; CACHE_BRUSH_ORDER * cache_brush = calloc ( 1 , sizeof ( CACHE_BRUSH_ORDER ) ) ; if ( ! cache_brush ) goto fail ; if ( Stream_GetRemainingLength ( s ) < 6 ) goto fail ; Stream_Read_UINT8 ( s , cache_brush -> index ) ; Stream_Read_UINT8 ( s , iBitmapFormat ) ; if ( iBitmapFormat >= ARRAYSIZE ( BMF_BPP ) ) goto fail ; cache_brush -> bpp = BMF_BPP [ iBitmapFormat ] ; Stream_Read_UINT8 ( s , cache_brush -> cx ) ; Stream_Read_UINT8 ( s , cache_brush -> cy ) ; Stream_Read_UINT8 ( s , cache_brush -> style ) ; Stream_Read_UINT8 ( s , cache_brush -> length ) ; if ( ( cache_brush -> cx == 8 ) && ( cache_brush -> cy == 8 ) ) { if ( cache_brush -> bpp == 1 ) { if ( cache_brush -> length != 8 ) { WLog_Print ( update -> log , WLOG_ERROR , "incompatible 1bpp brush of length:%" PRIu32 "" , cache_brush -> length ) ; goto fail ; } if ( Stream_GetRemainingLength ( s ) < 8 ) goto fail ; for ( i = 7 ; i >= 0 ; i -- ) { Stream_Read_UINT8 ( s , cache_brush -> data [ i ] ) ; } } else { if ( ( iBitmapFormat == BMF_8BPP ) && ( cache_brush -> length == 20 ) ) compressed = TRUE ; else if ( ( iBitmapFormat == BMF_16BPP ) && ( cache_brush -> length == 24 ) ) compressed = TRUE ; else if ( ( iBitmapFormat == BMF_32BPP ) && ( cache_brush -> length == 32 ) ) compressed = TRUE ; if ( compressed != FALSE ) { if ( ! update_decompress_brush ( s , cache_brush -> data , sizeof ( cache_brush -> data ) , cache_brush -> bpp ) ) goto fail ; } else { UINT32 scanline = ( cache_brush -> bpp / 8 ) * 8 ; if ( Stream_GetRemainingLength ( s ) < scanline * 8 ) goto fail ; for ( i = 7 ; i >= 0 ; i -- ) { Stream_Read ( s , & cache_brush -> data [ i * scanline ] , scanline ) ; } } } } return cache_brush ; fail : free_cache_brush_order ( update -> context , cache_brush ) ; return NULL ; }
MatchKeyHash ( TrustDomain & trustDomain , Input keyHash , const Input subjectPublicKeyInfo , bool & match ) { if ( keyHash . GetLength ( ) != SHA1_DIGEST_LENGTH ) { return Result :: ERROR_OCSP_MALFORMED_RESPONSE ; } static uint8_t hashBuf [ SHA1_DIGEST_LENGTH ] ; Result rv = KeyHash ( trustDomain , subjectPublicKeyInfo , hashBuf , sizeof hashBuf ) ; if ( rv != Success ) { return rv ; } Input computed ( hashBuf ) ; match = InputsAreEqual ( computed , keyHash ) ; return Success ; }
png_init_palette_transformations ( png_structrp png_ptr ) { int input_has_alpha = 0 ; int input_has_transparency = 0 ; if ( png_ptr -> num_trans > 0 ) { int i ; for ( i = 0 ; i < png_ptr -> num_trans ; ++ i ) { if ( png_ptr -> trans_alpha [ i ] == 255 ) continue ; else if ( png_ptr -> trans_alpha [ i ] == 0 ) input_has_transparency = 1 ; else { input_has_transparency = 1 ; input_has_alpha = 1 ; break ; } } } if ( ! input_has_alpha ) { png_ptr -> transformations &= ~ PNG_ENCODE_ALPHA ; png_ptr -> flags &= ~ PNG_FLAG_OPTIMIZE_ALPHA ; if ( ! input_has_transparency ) png_ptr -> transformations &= ~ ( PNG_COMPOSE | PNG_BACKGROUND_EXPAND ) ; } #if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED) if ( ( png_ptr -> transformations & PNG_BACKGROUND_EXPAND ) && ( png_ptr -> transformations & PNG_EXPAND ) ) { { png_ptr -> background . red = png_ptr -> palette [ png_ptr -> background . index ] . red ; png_ptr -> background . green = png_ptr -> palette [ png_ptr -> background . index ] . green ; png_ptr -> background . blue = png_ptr -> palette [ png_ptr -> background . index ] . blue ; #ifdef PNG_READ_INVERT_ALPHA_SUPPORTED if ( png_ptr -> transformations & PNG_INVERT_ALPHA ) { if ( ! ( png_ptr -> transformations & PNG_EXPAND_tRNS ) ) { int i , istop = png_ptr -> num_trans ; for ( i = 0 ; i < istop ; i ++ ) png_ptr -> trans_alpha [ i ] = ( png_byte ) ( 255 - png_ptr -> trans_alpha [ i ] ) ; } } #endif /* PNG_READ_INVERT_ALPHA_SUPPORTED */ } } #endif /* PNG_READ_EXPAND_SUPPORTED && PNG_READ_BACKGROUND_SUPPORTED */ }
std :: string get_wml_location ( const std :: string & filename , const std :: string & current_dir ) { DBG_FS < < "Looking for '" < < filename < < "'." < < std :: endl ; assert ( game_config :: path . empty ( ) == false ) ; std :: string result ; if ( filename . empty ( ) ) { LOG_FS < < "  invalid filename" < < std :: endl ; return result ; } if ( filename . find ( ".." ) != std :: string :: npos ) { ERR_FS < < "Illegal path '" < < filename < < "' (\"..\" not allowed)." < < std :: endl ; return result ; } if ( ends_with ( filename , ".pbl" ) ) { ERR_FS < < "Illegal path '" < < filename < < "' (.pbl files are not allowed)." < < std :: endl ; return result ; } bool already_found = false ; if ( filename [ 0 ] == '~' ) { result = get_user_data_dir ( ) + "/data/" + filename . substr ( 1 ) ; DBG_FS < < "  trying '" < < result < < "'" < < std :: endl ; already_found = file_exists ( result ) || is_directory ( result ) ; } else if ( filename . size ( ) >= 2 && filename [ 0 ] == '.' && filename [ 1 ] == '/' ) { if ( ! current_dir . empty ( ) ) { result = current_dir ; } else { result = game_config :: path ; } result += filename . substr ( 2 ) ; } else if ( ! game_config :: path . empty ( ) ) result = game_config :: path + "/data/" + filename ; DBG_FS < < "  trying '" < < result < < "'" < < std :: endl ; if ( result . empty ( ) || ( ! already_found && ! file_exists ( result ) && ! is_directory ( result ) ) ) { DBG_FS < < "  not found" < < std :: endl ; result . clear ( ) ; } else DBG_FS < < "  found: '" < < result < < "'" < < std :: endl ; return result ; }
void Compute ( OpKernelContext * ctx ) override { const Tensor & gradient = ctx -> input ( 0 ) ; const Tensor & input = ctx -> input ( 1 ) ; Tensor * input_backprop = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , input . shape ( ) , & input_backprop ) ) ; OP_REQUIRES ( ctx , input . IsSameSize ( gradient ) , errors :: InvalidArgument ( "gradient and input must be the same size" ) ) ; const int depth = ( axis_ == - 1 ) ? 1 : input . dim_size ( axis_ ) ; const Tensor & input_min_tensor = ctx -> input ( 2 ) ; const Tensor & input_max_tensor = ctx -> input ( 3 ) ; if ( axis_ != - 1 ) { OP_REQUIRES ( ctx , input_min_tensor . dim_size ( 0 ) == depth , errors :: InvalidArgument ( "min has incorrect size, expected " , depth , " was " , input_min_tensor . dim_size ( 0 ) ) ) ; OP_REQUIRES ( ctx , input_max_tensor . dim_size ( 0 ) == depth , errors :: InvalidArgument ( "max has incorrect size, expected " , depth , " was " , input_max_tensor . dim_size ( 0 ) ) ) ; } TensorShape min_max_shape ( input_min_tensor . shape ( ) ) ; Tensor * input_min_backprop ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 1 , min_max_shape , & input_min_backprop ) ) ; Tensor * input_max_backprop ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 2 , min_max_shape , & input_max_backprop ) ) ; if ( axis_ == - 1 ) { functor :: QuantizeAndDequantizeOneScaleGradientFunctor < Device , T > f ; f ( ctx -> eigen_device < Device > ( ) , gradient . template flat < T > ( ) , input . template flat < T > ( ) , input_min_tensor . scalar < T > ( ) , input_max_tensor . scalar < T > ( ) , input_backprop -> template flat < T > ( ) , input_min_backprop -> template scalar < T > ( ) , input_max_backprop -> template scalar < T > ( ) ) ; } else { functor :: QuantizeAndDequantizePerChannelGradientFunctor < Device , T > f ; f ( ctx -> eigen_device < Device > ( ) , gradient . template flat_inner_outer_dims < T , 3 > ( axis_ - 1 ) , input . template flat_inner_outer_dims < T , 3 > ( axis_ - 1 ) , & input_min_tensor , & input_max_tensor , input_backprop -> template flat_inner_outer_dims < T , 3 > ( axis_ - 1 ) , input_min_backprop -> template flat < T > ( ) , input_max_backprop -> template flat < T > ( ) ) ; } }
Http2Stream :: AdjustPushedPriority ( ) { if ( mStreamID || ! mPushSource ) return ; MOZ_ASSERT ( mPushSource -> mStreamID && ! ( mPushSource -> mStreamID & 1 ) ) ; if ( mPushSource -> RecvdFin ( ) || mPushSource -> RecvdReset ( ) ) return ; uint8_t * packet = mTxInlineFrame . get ( ) + mTxInlineFrameUsed ; EnsureBuffer ( mTxInlineFrame , mTxInlineFrameUsed + Http2Session :: kFrameHeaderBytes + 5 , mTxInlineFrameUsed , mTxInlineFrameSize ) ; mTxInlineFrameUsed += Http2Session :: kFrameHeaderBytes + 5 ; mSession -> CreateFrameHeader ( packet , 5 , Http2Session :: FRAME_TYPE_PRIORITY , Http2Session :: kFlag_PRIORITY , mPushSource -> mStreamID ) ; mPushSource -> SetPriority ( mPriority ) ; memset ( packet + Http2Session :: kFrameHeaderBytes , 0 , 4 ) ; memcpy ( packet + Http2Session :: kFrameHeaderBytes + 4 , & mPriorityWeight , 1 ) ; LOG3 ( ( "AdjustPushedPriority %p id 0x%X to weight %X\n" , this , mPushSource -> mStreamID , mPriorityWeight ) ) ; }
nsDocument :: ~ nsDocument ( ) { if ( gDocumentLeakPRLog ) MOZ_LOG ( gDocumentLeakPRLog , LogLevel :: Debug , ( "DOCUMENT %p destroyed" , this ) ) ; NS_ASSERTION ( ! mIsShowing , "Destroying a currently-showing document" ) ; NS_ASSERTION ( ! mObservingAppThemeChanged , "Document leaked to shutdown, then the observer service dropped " "its ref to us so we were able to go away." ) ; if ( IsTopLevelContentDocument ( ) ) { if ( ! IsAboutPage ( ) ) { uint32_t pageLoaded = 1 ; Accumulate ( Telemetry :: MIXED_CONTENT_UNBLOCK_COUNTER , pageLoaded ) ; enum { NO_MIXED_CONTENT = 0 , MIXED_DISPLAY_CONTENT = 1 , MIXED_ACTIVE_CONTENT = 2 , MIXED_DISPLAY_AND_ACTIVE_CONTENT = 3 } ; bool mixedActiveLoaded = GetHasMixedActiveContentLoaded ( ) ; bool mixedActiveBlocked = GetHasMixedActiveContentBlocked ( ) ; bool mixedDisplayLoaded = GetHasMixedDisplayContentLoaded ( ) ; bool mixedDisplayBlocked = GetHasMixedDisplayContentBlocked ( ) ; bool hasMixedDisplay = ( mixedDisplayBlocked || mixedDisplayLoaded ) ; bool hasMixedActive = ( mixedActiveBlocked || mixedActiveLoaded ) ; uint32_t mixedContentLevel = NO_MIXED_CONTENT ; if ( hasMixedDisplay && hasMixedActive ) { mixedContentLevel = MIXED_DISPLAY_AND_ACTIVE_CONTENT ; } else if ( hasMixedActive ) { mixedContentLevel = MIXED_ACTIVE_CONTENT ; } else if ( hasMixedDisplay ) { mixedContentLevel = MIXED_DISPLAY_CONTENT ; } Accumulate ( Telemetry :: MIXED_CONTENT_PAGE_LOAD , mixedContentLevel ) ; if ( mHasMixedContentObjectSubrequest ) { Accumulate ( Telemetry :: MIXED_CONTENT_OBJECT_SUBREQUEST , 1 ) ; } else { Accumulate ( Telemetry :: MIXED_CONTENT_OBJECT_SUBREQUEST , 0 ) ; } if ( mHasCSP ) { Accumulate ( Telemetry :: CSP_DOCUMENTS_COUNT , 1 ) ; } if ( mHasUnsafeInlineCSP ) { Accumulate ( Telemetry :: CSP_UNSAFE_INLINE_DOCUMENTS_COUNT , 1 ) ; } if ( mHasUnsafeEvalCSP ) { Accumulate ( Telemetry :: CSP_UNSAFE_EVAL_DOCUMENTS_COUNT , 1 ) ; } } } ReportUseCounters ( ) ; mInDestructor = true ; mInUnlinkOrDeletion = true ; mozilla :: DropJSObjects ( this ) ; mObservers . Clear ( ) ; if ( mStyleSheetSetList ) { mStyleSheetSetList -> Disconnect ( ) ; } if ( mAnimationController ) { mAnimationController -> Disconnect ( ) ; } mParentDocument = nullptr ; delete mSubDocuments ; mSubDocuments = nullptr ; DestroyElementMaps ( ) ; nsAutoScriptBlocker scriptBlocker ; for ( uint32_t indx = mChildren . ChildCount ( ) ; indx -- != 0 ; ) { mChildren . ChildAt ( indx ) -> UnbindFromTree ( ) ; mChildren . RemoveChildAt ( indx ) ; } mFirstChild = nullptr ; mCachedRootElement = nullptr ; for ( StyleSheet * sheet : mStyleSheets ) { sheet -> SetOwningDocument ( nullptr ) ; } if ( mAttrStyleSheet ) { mAttrStyleSheet -> SetOwningDocument ( nullptr ) ; } if ( mListenerManager ) { mListenerManager -> Disconnect ( ) ; UnsetFlags ( NODE_HAS_LISTENERMANAGER ) ; } if ( mScriptLoader ) { mScriptLoader -> DropDocumentReference ( ) ; } if ( mCSSLoader ) { mCSSLoader -> DropDocumentReference ( ) ; } if ( mStyleImageLoader ) { mStyleImageLoader -> DropDocumentReference ( ) ; } delete mHeaderData ; ClearAllBoxObjects ( ) ; mPendingTitleChangeEvent . Revoke ( ) ; SetImageLockingState ( false ) ; mImageTracker . Clear ( ) ; mPlugins . Clear ( ) ; }
nsMutationReceiver :: CharacterDataWillChange ( nsIDocument * aDocument , nsIContent * aContent , CharacterDataChangeInfo * aInfo ) { if ( nsAutoMutationBatch :: IsBatching ( ) || ! CharacterData ( ) || ! ( Subtree ( ) || aContent == Target ( ) ) || aContent -> IsInNativeAnonymousSubtree ( ) ) { return ; } nsDOMMutationRecord * m = Observer ( ) -> CurrentRecord ( NS_LITERAL_STRING ( "characterData" ) ) ; NS_ASSERTION ( ! m -> mTarget || m -> mTarget == aContent , "Wrong target!" ) ; if ( ! m -> mTarget ) { m -> mTarget = aContent ; } if ( CharacterDataOldValue ( ) && m -> mPrevValue . IsVoid ( ) ) { aContent -> GetText ( ) -> AppendTo ( m -> mPrevValue ) ; } }
void Serializer < AllocatorT > :: PutAttachedReference ( SerializerReference reference , HowToCode how_to_code , WhereToPoint where_to_point ) { DCHECK ( reference . is_attached_reference ( ) ) ; DCHECK ( ( how_to_code == kPlain && where_to_point == kStartOfObject ) || ( how_to_code == kFromCode && where_to_point == kStartOfObject ) || ( how_to_code == kFromCode && where_to_point == kInnerPointer ) ) ; sink_ . Put ( kAttachedReference + how_to_code + where_to_point , "AttachedRef" ) ; sink_ . PutInt ( reference . attached_reference_index ( ) , "AttachedRefIndex" ) ; }
void JSGenericLowering :: LowerJSCreateArguments ( Node * node ) { CreateArgumentsType const type = CreateArgumentsTypeOf ( node -> op ( ) ) ; switch ( type ) { case CreateArgumentsType :: kMappedArguments : ReplaceWithRuntimeCall ( node , Runtime :: kNewSloppyArguments_Generic ) ; break ; case CreateArgumentsType :: kUnmappedArguments : ReplaceWithRuntimeCall ( node , Runtime :: kNewStrictArguments ) ; break ; case CreateArgumentsType :: kRestParameter : ReplaceWithRuntimeCall ( node , Runtime :: kNewRestParameter ) ; break ; } }
static OPJ_BOOL opj_jp2_read_jp2h ( opj_jp2_t * jp2 , OPJ_BYTE * p_header_data , OPJ_UINT32 p_header_size , opj_event_mgr_t * p_manager ) { OPJ_UINT32 l_box_size = 0 , l_current_data_size = 0 ; opj_jp2_box_t box ; const opj_jp2_header_handler_t * l_current_handler ; OPJ_BOOL l_has_ihdr = 0 ; assert ( p_header_data != 00 ) ; assert ( jp2 != 00 ) ; assert ( p_manager != 00 ) ; if ( ( jp2 -> jp2_state & JP2_STATE_FILE_TYPE ) != JP2_STATE_FILE_TYPE ) { opj_event_msg ( p_manager , EVT_ERROR , "The  box must be the first box in the file.\n" ) ; return OPJ_FALSE ; } jp2 -> jp2_img_state = JP2_IMG_STATE_NONE ; while ( p_header_size > 0 ) { if ( ! opj_jp2_read_boxhdr_char ( & box , p_header_data , & l_box_size , p_header_size , p_manager ) ) { opj_event_msg ( p_manager , EVT_ERROR , "Stream error while reading JP2 Header box\n" ) ; return OPJ_FALSE ; } if ( box . length > p_header_size ) { opj_event_msg ( p_manager , EVT_ERROR , "Stream error while reading JP2 Header box: box length is inconsistent.\n" ) ; return OPJ_FALSE ; } l_current_handler = opj_jp2_img_find_handler ( box . type ) ; l_current_data_size = box . length - l_box_size ; p_header_data += l_box_size ; if ( l_current_handler != 00 ) { if ( ! l_current_handler -> handler ( jp2 , p_header_data , l_current_data_size , p_manager ) ) { return OPJ_FALSE ; } } else { jp2 -> jp2_img_state |= JP2_IMG_STATE_UNKNOWN ; } if ( box . type == JP2_IHDR ) { l_has_ihdr = 1 ; } p_header_data += l_current_data_size ; p_header_size -= box . length ; } if ( l_has_ihdr == 0 ) { opj_event_msg ( p_manager , EVT_ERROR , "Stream error while reading JP2 Header box: no 'ihdr' box.\n" ) ; return OPJ_FALSE ; } jp2 -> jp2_state |= JP2_STATE_HEADER ; return OPJ_TRUE ; }
af_cjk_metrics_init_widths ( AF_CJKMetrics metrics , FT_Face face ) { AF_GlyphHintsRec hints [ 1 ] ; FT_TRACE5 ( ( "\n" "cjk standard widths computation (style `%s')\n" "===================================================\n" "\n" , af_style_names [ metrics -> root . style_class -> style ] ) ) ; af_glyph_hints_init ( hints , face -> memory ) ; metrics -> axis [ AF_DIMENSION_HORZ ] . width_count = 0 ; metrics -> axis [ AF_DIMENSION_VERT ] . width_count = 0 ; { FT_Error error ; FT_ULong glyph_index ; FT_Long y_offset ; int dim ; AF_CJKMetricsRec dummy [ 1 ] ; AF_Scaler scaler = & dummy -> root . scaler ; #ifdef FT_CONFIG_OPTION_PIC AF_FaceGlobals globals = metrics -> root . globals ; #endif AF_StyleClass style_class = metrics -> root . style_class ; AF_ScriptClass script_class = AF_SCRIPT_CLASSES_GET [ style_class -> script ] ; FT_UInt32 standard_char ; standard_char = script_class -> standard_char1 ; af_get_char_index ( & metrics -> root , standard_char , & glyph_index , & y_offset ) ; if ( ! glyph_index ) { if ( script_class -> standard_char2 ) { standard_char = script_class -> standard_char2 ; af_get_char_index ( & metrics -> root , standard_char , & glyph_index , & y_offset ) ; if ( ! glyph_index ) { if ( script_class -> standard_char3 ) { standard_char = script_class -> standard_char3 ; af_get_char_index ( & metrics -> root , standard_char , & glyph_index , & y_offset ) ; if ( ! glyph_index ) goto Exit ; } else goto Exit ; } } else goto Exit ; } FT_TRACE5 ( ( "standard character: U+%04lX (glyph index %d)\n" , standard_char , glyph_index ) ) ; error = FT_Load_Glyph ( face , glyph_index , FT_LOAD_NO_SCALE ) ; if ( error || face -> glyph -> outline . n_points <= 0 ) goto Exit ; FT_ZERO ( dummy ) ; dummy -> units_per_em = metrics -> units_per_em ; scaler -> x_scale = 0x10000L ; scaler -> y_scale = 0x10000L ; scaler -> x_delta = 0 ; scaler -> y_delta = 0 ; scaler -> face = face ; scaler -> render_mode = FT_RENDER_MODE_NORMAL ; scaler -> flags = 0 ; af_glyph_hints_rescale ( hints , ( AF_StyleMetrics ) dummy ) ; error = af_glyph_hints_reload ( hints , & face -> glyph -> outline ) ; if ( error ) goto Exit ; for ( dim = 0 ; dim < AF_DIMENSION_MAX ; dim ++ ) { AF_CJKAxis axis = & metrics -> axis [ dim ] ; AF_AxisHints axhints = & hints -> axis [ dim ] ; AF_Segment seg , limit , link ; FT_UInt num_widths = 0 ; error = af_latin_hints_compute_segments ( hints , ( AF_Dimension ) dim ) ; if ( error ) goto Exit ; af_latin_hints_link_segments ( hints , 0 , NULL , ( AF_Dimension ) dim ) ; seg = axhints -> segments ; limit = seg + axhints -> num_segments ; for ( ; seg < limit ; seg ++ ) { link = seg -> link ; if ( link && link -> link == seg && link > seg ) { FT_Pos dist ; dist = seg -> pos - link -> pos ; if ( dist < 0 ) dist = - dist ; if ( num_widths < AF_CJK_MAX_WIDTHS ) axis -> widths [ num_widths ++ ] . org = dist ; } } af_sort_and_quantize_widths ( & num_widths , axis -> widths , dummy -> units_per_em / 100 ) ; axis -> width_count = num_widths ; } Exit : for ( dim = 0 ; dim < AF_DIMENSION_MAX ; dim ++ ) { AF_CJKAxis axis = & metrics -> axis [ dim ] ; FT_Pos stdw ; stdw = ( axis -> width_count > 0 ) ? axis -> widths [ 0 ] . org : AF_LATIN_CONSTANT ( metrics , 50 ) ; axis -> edge_distance_threshold = stdw / 5 ; axis -> standard_width = stdw ; axis -> extra_light = 0 ; #ifdef FT_DEBUG_LEVEL_TRACE { FT_UInt i ; FT_TRACE5 ( ( "%s widths:\n" , dim == AF_DIMENSION_VERT ? "horizontal" : "vertical" ) ) ; FT_TRACE5 ( ( "  %d (standard)" , axis -> standard_width ) ) ; for ( i = 1 ; i < axis -> width_count ; i ++ ) FT_TRACE5 ( ( " %d" , axis -> widths [ i ] . org ) ) ; FT_TRACE5 ( ( "\n" ) ) ; } #endif } } FT_TRACE5 ( ( "\n" ) ) ; af_glyph_hints_done ( hints ) ; }
RUNTIME_FUNCTION ( Runtime_DefineGetterPropertyUnchecked ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 4 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSObject , object , 0 ) ; CONVERT_ARG_HANDLE_CHECKED ( Name , name , 1 ) ; CONVERT_ARG_HANDLE_CHECKED ( JSFunction , getter , 2 ) ; CONVERT_PROPERTY_ATTRIBUTES_CHECKED ( attrs , 3 ) ; if ( String :: cast ( getter -> shared ( ) -> Name ( ) ) -> length ( ) == 0 ) { Handle < Map > getter_map ( getter -> map ( ) , isolate ) ; if ( ! JSFunction :: SetName ( getter , name , isolate -> factory ( ) -> get_string ( ) ) ) { return ReadOnlyRoots ( isolate ) . exception ( ) ; } CHECK_EQ ( * getter_map , getter -> map ( ) ) ; } RETURN_FAILURE_ON_EXCEPTION ( isolate , JSObject :: DefineAccessor ( object , name , getter , isolate -> factory ( ) -> null_value ( ) , attrs ) ) ; return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
Handle < Script > Factory :: CloneScript ( Handle < Script > script ) { Heap * heap = isolate ( ) -> heap ( ) ; int script_id = isolate ( ) -> heap ( ) -> NextScriptId ( ) ; Handle < Script > new_script = Handle < Script > :: cast ( NewStruct ( SCRIPT_TYPE , TENURED ) ) ; new_script -> set_source ( script -> source ( ) ) ; new_script -> set_name ( script -> name ( ) ) ; new_script -> set_id ( script_id ) ; new_script -> set_line_offset ( script -> line_offset ( ) ) ; new_script -> set_column_offset ( script -> column_offset ( ) ) ; new_script -> set_context_data ( script -> context_data ( ) ) ; new_script -> set_type ( script -> type ( ) ) ; new_script -> set_line_ends ( ReadOnlyRoots ( heap ) . undefined_value ( ) ) ; new_script -> set_eval_from_shared_or_wrapped_arguments ( script -> eval_from_shared_or_wrapped_arguments ( ) ) ; new_script -> set_shared_function_infos ( * empty_weak_fixed_array ( ) , SKIP_WRITE_BARRIER ) ; new_script -> set_eval_from_position ( script -> eval_from_position ( ) ) ; new_script -> set_flags ( script -> flags ( ) ) ; new_script -> set_host_defined_options ( script -> host_defined_options ( ) ) ; Handle < WeakArrayList > scripts = script_list ( ) ; scripts = WeakArrayList :: AddToEnd ( isolate ( ) , scripts , MaybeObjectHandle :: Weak ( new_script ) ) ; heap -> set_script_list ( * scripts ) ; LOG ( isolate ( ) , ScriptEvent ( Logger :: ScriptEventType :: kCreate , script_id ) ) ; return new_script ; }
DOMSVGPointList :: IndexedGetter ( uint32_t aIndex , bool & aFound , ErrorResult & aError ) { if ( IsAnimValList ( ) ) { Element ( ) -> FlushAnimations ( ) ; } aFound = aIndex < LengthNoFlush ( ) ; if ( aFound ) { EnsureItemAt ( aIndex ) ; return mItems [ aIndex ] ; } return nullptr ; }
int32_t CryptoHal :: setHeapBase ( const sp < IMemoryHeap > & heap ) { if ( heap == NULL ) { ALOGE ( "setHeapBase(): heap is NULL" ) ; return - 1 ; } native_handle_t * nativeHandle = native_handle_create ( 1 , 0 ) ; if ( ! nativeHandle ) { ALOGE ( "setHeapBase(), failed to create native handle" ) ; return - 1 ; } Mutex :: Autolock autoLock ( mLock ) ; int32_t seqNum = mHeapSeqNum ++ ; int fd = heap -> getHeapID ( ) ; nativeHandle -> data [ 0 ] = fd ; auto hidlHandle = hidl_handle ( nativeHandle ) ; auto hidlMemory = hidl_memory ( "ashmem" , hidlHandle , heap -> getSize ( ) ) ; mHeapBases . add ( seqNum , mNextBufferId ) ; Return < void > hResult = mPlugin -> setSharedBufferBase ( hidlMemory , mNextBufferId ++ ) ; ALOGE_IF ( ! hResult . isOk ( ) , "setSharedBufferBase(): remote call failed" ) ; return seqNum ; }
static void get_sem_elements ( struct sem_data * p ) { size_t i ; if ( ! p || ! p -> sem_nsems || p -> sem_perm . id < 0 ) return ; p -> elements = xcalloc ( p -> sem_nsems , sizeof ( struct sem_elem ) ) ; for ( i = 0 ; i < p -> sem_nsems ; i ++ ) { struct sem_elem * e = & p -> elements [ i ] ; union semun arg = { . val = 0 } ; e -> semval = semctl ( p -> sem_perm . id , i , GETVAL , arg ) ; if ( e -> semval < 0 ) err ( EXIT_FAILURE , _ ( "%s failed" ) , "semctl(GETVAL)" ) ; e -> ncount = semctl ( p -> sem_perm . id , i , GETNCNT , arg ) ; if ( e -> ncount < 0 ) err ( EXIT_FAILURE , _ ( "%s failed" ) , "semctl(GETNCNT)" ) ; e -> zcount = semctl ( p -> sem_perm . id , i , GETZCNT , arg ) ; if ( e -> zcount < 0 ) err ( EXIT_FAILURE , _ ( "%s failed" ) , "semctl(GETZCNT)" ) ; e -> pid = semctl ( p -> sem_perm . id , i , GETPID , arg ) ; if ( e -> pid < 0 ) err ( EXIT_FAILURE , _ ( "%s failed" ) , "semctl(GETPID)" ) ; } }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { auto * params = reinterpret_cast < TfLiteDepthToSpaceParams * > ( node -> builtin_data ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; #define TF_LITE_DEPTH_TO_SPACE(type, scalar)                               \   tflite::DepthToSpaceParams op_params;                                    \   op_params.block_size = params->block_size;                               \   type::DepthToSpace(op_params, GetTensorShape(input),                     \                      GetTensorData<scalar>(input), GetTensorShape(output), \                      GetTensorData<scalar>(output)) switch ( input -> type ) { case kTfLiteFloat32 : if ( kernel_type == kReference ) { TF_LITE_DEPTH_TO_SPACE ( reference_ops , float ) ; } else { TF_LITE_DEPTH_TO_SPACE ( optimized_ops , float ) ; } break ; case kTfLiteUInt8 : if ( kernel_type == kReference ) { TF_LITE_DEPTH_TO_SPACE ( reference_ops , uint8_t ) ; } else { TF_LITE_DEPTH_TO_SPACE ( optimized_ops , uint8_t ) ; } break ; case kTfLiteInt8 : if ( kernel_type == kReference ) { TF_LITE_DEPTH_TO_SPACE ( reference_ops , int8_t ) ; } else { TF_LITE_DEPTH_TO_SPACE ( optimized_ops , int8_t ) ; } break ; case kTfLiteInt32 : if ( kernel_type == kReference ) { TF_LITE_DEPTH_TO_SPACE ( reference_ops , int32_t ) ; } else { TF_LITE_DEPTH_TO_SPACE ( optimized_ops , int32_t ) ; } break ; case kTfLiteInt64 : if ( kernel_type == kReference ) { TF_LITE_DEPTH_TO_SPACE ( reference_ops , int64_t ) ; } else { TF_LITE_DEPTH_TO_SPACE ( optimized_ops , int64_t ) ; } break ; default : context -> ReportError ( context , "Type '%s' not currently supported." , TfLiteTypeGetName ( input -> type ) ) ; return kTfLiteError ; } #undef TF_LITE_DEPTH_TO_SPACE return kTfLiteOk ; }
void vp9_iht4x4_16_add_c ( const int16_t * input , uint8_t * dest , int stride , int tx_type ) { const transform_2d IHT_4 [ ] = { { idct4 , idct4 } , { iadst4 , idct4 } , { idct4 , iadst4 } , { iadst4 , iadst4 } } ; int i , j ; int16_t out [ 4 * 4 ] ; int16_t * outptr = out ; int16_t temp_in [ 4 ] , temp_out [ 4 ] ; for ( i = 0 ; i < 4 ; ++ i ) { IHT_4 [ tx_type ] . rows ( input , outptr ) ; input += 4 ; outptr += 4 ; } for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = out [ j * 4 + i ] ; IHT_4 [ tx_type ] . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) + dest [ j * stride + i ] ) ; } }
WebGLContext :: TexImage2D_base ( WebGLenum target , WebGLint level , WebGLenum internalformat , WebGLsizei width , WebGLsizei height , WebGLsizei srcStrideOrZero , WebGLint border , WebGLenum format , WebGLenum type , void * data , uint32_t byteLength , int jsArrayType , WebGLTexelFormat srcFormat , bool srcPremultiplied ) { if ( ! ValidateTexImage2DTarget ( target , width , height , "texImage2D" ) ) { return ; } switch ( format ) { case LOCAL_GL_RGB : case LOCAL_GL_RGBA : case LOCAL_GL_ALPHA : case LOCAL_GL_LUMINANCE : case LOCAL_GL_LUMINANCE_ALPHA : case LOCAL_GL_DEPTH_COMPONENT : case LOCAL_GL_DEPTH_STENCIL : break ; default : return ErrorInvalidEnumInfo ( "texImage2D: internal format" , internalformat ) ; } if ( format != internalformat ) return ErrorInvalidOperation ( "texImage2D: format does not match internalformat" ) ; if ( ! ValidateLevelWidthHeightForTarget ( target , level , width , height , "texImage2D" ) ) { return ; } if ( level >= 1 ) { if ( ! ( is_pot_assuming_nonnegative ( width ) && is_pot_assuming_nonnegative ( height ) ) ) return ErrorInvalidValue ( "texImage2D: with level > 0, width and height must be powers of two" ) ; } if ( border != 0 ) return ErrorInvalidValue ( "texImage2D: border must be 0" ) ; if ( format == LOCAL_GL_DEPTH_COMPONENT || format == LOCAL_GL_DEPTH_STENCIL ) { if ( IsExtensionEnabled ( WEBGL_depth_texture ) ) { if ( target != LOCAL_GL_TEXTURE_2D || data != NULL || level != 0 ) return ErrorInvalidOperation ( "texImage2D: " "with format of DEPTH_COMPONENT or DEPTH_STENCIL " "target must be TEXTURE_2D, " "data must be NULL, " "level must be zero" ) ; } else return ErrorInvalidEnumInfo ( "texImage2D: internal format" , internalformat ) ; } uint32_t dstTexelSize = 0 ; if ( ! ValidateTexFormatAndType ( format , type , jsArrayType , & dstTexelSize , "texImage2D" ) ) return ; WebGLTexelFormat dstFormat = GetWebGLTexelFormat ( format , type ) ; WebGLTexelFormat actualSrcFormat = srcFormat == WebGLTexelConversions :: Auto ? dstFormat : srcFormat ; uint32_t srcTexelSize = WebGLTexelConversions :: TexelBytesForFormat ( actualSrcFormat ) ; CheckedUint32 checked_neededByteLength = GetImageSize ( height , width , srcTexelSize , mPixelStoreUnpackAlignment ) ; CheckedUint32 checked_plainRowSize = CheckedUint32 ( width ) * srcTexelSize ; CheckedUint32 checked_alignedRowSize = RoundedToNextMultipleOf ( checked_plainRowSize . value ( ) , mPixelStoreUnpackAlignment ) ; if ( ! checked_neededByteLength . isValid ( ) ) return ErrorInvalidOperation ( "texImage2D: integer overflow computing the needed buffer size" ) ; uint32_t bytesNeeded = checked_neededByteLength . value ( ) ; if ( byteLength && byteLength < bytesNeeded ) return ErrorInvalidOperation ( "texImage2D: not enough data for operation (need %d, have %d)" , bytesNeeded , byteLength ) ; WebGLTexture * tex = activeBoundTextureForTarget ( target ) ; if ( ! tex ) return ErrorInvalidOperation ( "texImage2D: no texture is bound to this target" ) ; MakeContextCurrent ( ) ; internalformat = InternalFormatForFormatAndType ( format , type , gl -> IsGLES2 ( ) ) ; #ifdef MOZ_X11 if ( gl -> WorkAroundDriverBugs ( ) && mIsMesa && level > 0 ) { size_t face = WebGLTexture :: FaceForTarget ( target ) ; if ( ! tex -> HasImageInfoAt ( 0 , face ) || tex -> ImageInfoAt ( 0 , face ) . Width ( ) <= width ) { return ErrorInvalidOperation ( "texImage2D: rejecting valid call to avoid Mesa driver crash. " "See Mozilla bug 785734" ) ; } } #endif GLenum error = LOCAL_GL_NO_ERROR ; if ( byteLength ) { size_t srcStride = srcStrideOrZero ? srcStrideOrZero : checked_alignedRowSize . value ( ) ; size_t dstPlainRowSize = dstTexelSize * width ; size_t unpackAlignment = mPixelStoreUnpackAlignment ; size_t dstStride = ( ( dstPlainRowSize + unpackAlignment - 1 ) / unpackAlignment ) * unpackAlignment ; if ( actualSrcFormat == dstFormat && srcPremultiplied == mPixelStorePremultiplyAlpha && srcStride == dstStride && ! mPixelStoreFlipY ) { error = CheckedTexImage2D ( target , level , internalformat , width , height , border , format , type , data ) ; } else { size_t convertedDataSize = height * dstStride ; nsAutoArrayPtr < uint8_t > convertedData ( new uint8_t [ convertedDataSize ] ) ; ConvertImage ( width , height , srcStride , dstStride , static_cast < uint8_t * > ( data ) , convertedData , actualSrcFormat , srcPremultiplied , dstFormat , mPixelStorePremultiplyAlpha , dstTexelSize ) ; error = CheckedTexImage2D ( target , level , internalformat , width , height , border , format , type , convertedData ) ; } } else { void * tempZeroData = calloc ( 1 , bytesNeeded ) ; if ( ! tempZeroData ) return ErrorOutOfMemory ( "texImage2D: could not allocate %d bytes (for zero fill)" , bytesNeeded ) ; error = CheckedTexImage2D ( target , level , internalformat , width , height , border , format , type , tempZeroData ) ; free ( tempZeroData ) ; } if ( error ) { GenerateWarning ( "texImage2D generated error %s" , ErrorName ( error ) ) ; return ; } tex -> SetImageInfo ( target , level , width , height , format , type ) ; }
auto decode = [ & ] ( const int64 begin , const int64 end ) { for ( int b = begin ; b < end ; ++ b ) { sequences [ b ] . resize ( 1 ) ; auto & sequence = sequences [ b ] [ 0 ] ; int prev_indices = - 1 ; for ( int t = 0 ; t < seq_len_t ( b ) ; ++ t ) { int max_class_indices ; + OP_REQUIRES ( ctx , input_list_t [ t ] . dimension ( 1 ) > 0 , + errors :: InvalidArgument ( "Invalid input dimensions." ) ) ; log_prob_t ( b , 0 ) += - RowMax < T > ( input_list_t [ t ] , b , & max_class_indices ) ; if ( max_class_indices != blank_index && ! ( merge_repeated_ && max_class_indices == prev_indices ) ) { sequence . push_back ( max_class_indices ) ; } prev_indices = max_class_indices ; } } } ;
BUILTIN ( TypedArrayPrototypeLastIndexOf ) { HandleScope scope ( isolate ) ; Handle < JSTypedArray > array ; const char * method = "%TypedArray%.prototype.lastIndexOf" ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , array , JSTypedArray :: Validate ( isolate , args . receiver ( ) , method ) ) ; int64_t len = array -> length_value ( ) ; if ( len == 0 ) return Smi :: FromInt ( - 1 ) ; int64_t index = len - 1 ; if ( args . length ( ) > 2 ) { Handle < Object > num ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , num , Object :: ToInteger ( isolate , args . at < Object > ( 2 ) ) ) ; index = std :: min < int64_t > ( CapRelativeIndex ( num , - 1 , len ) , len - 1 ) ; } if ( index < 0 ) return Smi :: FromInt ( - 1 ) ; if ( V8_UNLIKELY ( array -> WasNeutered ( ) ) ) return Smi :: FromInt ( - 1 ) ; Handle < Object > search_element = args . atOrUndefined ( isolate , 1 ) ; ElementsAccessor * elements = array -> GetElementsAccessor ( ) ; Maybe < int64_t > result = elements -> LastIndexOfValue ( array , search_element , static_cast < uint32_t > ( index ) ) ; MAYBE_RETURN ( result , ReadOnlyRoots ( isolate ) . exception ( ) ) ; return * isolate -> factory ( ) -> NewNumberFromInt64 ( result . FromJust ( ) ) ; }
rrd_info_t * rrd_graph_v ( int argc , char * * argv ) { image_desc_t im ; rrd_info_t * grinfo ; char * old_locale ; rrd_graph_init ( & im ) ; old_locale = setlocale ( LC_NUMERIC , "C" ) ; rrd_graph_options ( argc , argv , & im ) ; if ( rrd_test_error ( ) ) { rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; return NULL ; } if ( optind >= argc ) { rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; rrd_set_error ( "missing filename" ) ; return NULL ; } if ( strlen ( argv [ optind ] ) >= MAXPATH ) { rrd_set_error ( "filename (including path) too long" ) ; rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; return NULL ; } strncpy ( im . graphfile , argv [ optind ] , MAXPATH - 1 ) ; im . graphfile [ MAXPATH - 1 ] = '\0' ; if ( strcmp ( im . graphfile , "-" ) == 0 ) { im . graphfile [ 0 ] = '\0' ; } rrd_graph_script ( argc , argv , & im , 1 ) ; setlocale ( LC_NUMERIC , old_locale ) ; if ( rrd_test_error ( ) ) { rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; return NULL ; } if ( graph_paint ( & im ) == - 1 ) { rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; return NULL ; } if ( im . imginfo ) { rrd_infoval_t info ; char * path ; char * filename ; if ( bad_format_imginfo ( im . imginfo ) ) { rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; rrd_set_error ( "bad format for imginfo" ) ; return NULL ; } path = strdup ( im . graphfile ) ; filename = basename ( path ) ; info . u_str = sprintf_alloc ( im . imginfo , filename , ( long ) ( im . zoom * im . ximg ) , ( long ) ( im . zoom * im . yimg ) ) ; grinfo_push ( & im , sprintf_alloc ( "image_info" ) , RD_I_STR , info ) ; free ( info . u_str ) ; free ( path ) ; } if ( im . rendered_image ) { rrd_infoval_t img ; img . u_blo . size = im . rendered_image_size ; img . u_blo . ptr = im . rendered_image ; grinfo_push ( & im , sprintf_alloc ( "image" ) , RD_I_BLO , img ) ; } grinfo = im . grinfo ; im_free ( & im ) ; return grinfo ; }
ObjectStats :: VirtualInstanceType CodeKindToVirtualInstanceType ( Code :: Kind kind ) { switch ( kind ) { #define CODE_KIND_CASE(type) \  case Code::type:           \  return ObjectStats::type; CODE_KIND_LIST ( CODE_KIND_CASE ) #undef CODE_KIND_CASE default : UNREACHABLE ( ) ; } UNREACHABLE ( ) ; }
nsWindowSH :: OuterObject ( nsIXPConnectWrappedNative * wrapper , JSContext * cx , JSObject * obj , JSObject * * _retval ) { nsGlobalWindow * origWin = nsGlobalWindow :: FromWrapper ( wrapper ) ; nsGlobalWindow * win = origWin -> GetOuterWindowInternal ( ) ; if ( ! win ) { * _retval = nsnull ; return NS_ERROR_UNEXPECTED ; } nsresult rv ; if ( win -> IsChromeWindow ( ) ) { JSObject * outerObj = win -> GetGlobalJSObject ( ) ; if ( ! outerObj ) { NS_ASSERTION ( origWin -> IsOuterWindow ( ) , "What window is this?" ) ; * _retval = obj ; } else { * _retval = outerObj ; } rv = NS_OK ; } else { JSObject * winObj = win -> GetGlobalJSObject ( ) ; if ( ! winObj ) { NS_ASSERTION ( origWin -> IsOuterWindow ( ) , "What window is this?" ) ; * _retval = obj ; rv = NS_OK ; } else { JSObject * scope = JS_GetScopeChain ( cx ) ; if ( ! scope ) { * _retval = nsnull ; return NS_ERROR_FAILURE ; } scope = :: JS_GetGlobalForObject ( cx , scope ) ; jsval v ; rv = sXPConnect -> GetXOWForObject ( cx , scope , winObj , & v ) ; * _retval = NS_SUCCEEDED ( rv ) ? JSVAL_TO_OBJECT ( v ) : nsnull ; } } return rv ; }
Node * WasmGraphBuilder :: BuildI64DivS ( Node * left , Node * right , wasm :: WasmCodePosition position ) { if ( mcgraph ( ) -> machine ( ) -> Is32 ( ) ) { return BuildDiv64Call ( left , right , ExternalReference :: wasm_int64_div ( ) , MachineType :: Int64 ( ) , wasm :: kTrapDivByZero , position ) ; } ZeroCheck64 ( wasm :: kTrapDivByZero , right , position ) ; Node * before = Control ( ) ; Node * denom_is_m1 ; Node * denom_is_not_m1 ; BranchExpectFalse ( graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Word64Equal ( ) , right , mcgraph ( ) -> Int64Constant ( - 1 ) ) , & denom_is_m1 , & denom_is_not_m1 ) ; SetControl ( denom_is_m1 ) ; TrapIfEq64 ( wasm :: kTrapDivUnrepresentable , left , std :: numeric_limits < int64_t > :: min ( ) , position ) ; if ( Control ( ) != denom_is_m1 ) { SetControl ( graph ( ) -> NewNode ( mcgraph ( ) -> common ( ) -> Merge ( 2 ) , denom_is_not_m1 , Control ( ) ) ) ; } else { SetControl ( before ) ; } return graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Int64Div ( ) , left , right , Control ( ) ) ; }
belle_sip_dialog_t * belle_sip_provider_find_dialog ( const belle_sip_provider_t * prov , const char * call_id , const char * local_tag , const char * remote_tag ) { belle_sip_list_t * iterator ; belle_sip_dialog_t * returned_dialog = NULL ; if ( call_id == NULL || local_tag == NULL || remote_tag == NULL ) { return NULL ; } for ( iterator = prov -> dialogs ; iterator != NULL ; iterator = iterator -> next ) { belle_sip_dialog_t * dialog = ( belle_sip_dialog_t * ) iterator -> data ; dialog = ( belle_sip_dialog_t * ) iterator -> data ; if ( belle_sip_dialog_get_state ( dialog ) != BELLE_SIP_DIALOG_NULL && _belle_sip_dialog_match ( dialog , call_id , local_tag , remote_tag ) ) { if ( ! returned_dialog ) returned_dialog = dialog ; else belle_sip_fatal ( "More than 1 dialog is matching, check your app" ) ; } } return returned_dialog ; }
WebGLContext :: BufferData ( GLenum target , WebGLsizeiptr size , GLenum usage ) { if ( IsContextLost ( ) ) return ; if ( ! ValidateBufferTarget ( target , "bufferData" ) ) return ; WebGLRefPtr < WebGLBuffer > & bufferSlot = GetBufferSlotByTarget ( target ) ; if ( size < 0 ) return ErrorInvalidValue ( "bufferData: negative size" ) ; if ( ! ValidateBufferUsageEnum ( usage , "bufferData: usage" ) ) return ; if ( ! CheckedInt < GLsizeiptr > ( size ) . isValid ( ) ) return ErrorOutOfMemory ( "bufferData: bad size" ) ; WebGLBuffer * boundBuffer = bufferSlot . get ( ) ; if ( ! boundBuffer ) return ErrorInvalidOperation ( "bufferData: no buffer bound!" ) ; UniquePtr < uint8_t > zeroBuffer ( ( uint8_t * ) calloc ( size , 1 ) ) ; if ( ! zeroBuffer ) return ErrorOutOfMemory ( "bufferData: out of memory" ) ; MakeContextCurrent ( ) ; InvalidateBufferFetching ( ) ; GLenum error = CheckedBufferData ( target , size , zeroBuffer . get ( ) , usage ) ; if ( error ) { GenerateWarning ( "bufferData generated error %s" , ErrorName ( error ) ) ; return ; } boundBuffer -> SetByteLength ( size ) ; if ( ! boundBuffer -> ElementArrayCacheBufferData ( nullptr , size ) ) { return ErrorOutOfMemory ( "bufferData: out of memory" ) ; } }
sasl_process_packet ( struct sasl_session * const restrict p , char * const restrict buf , const size_t len ) { struct sasl_output_buf outbuf = { . buf = NULL , . len = 0 , . flags = ASASL_OUTFLAG_NONE , } ; enum sasl_mechanism_result rc ; bool have_responded = false ; if ( ! p -> mechptr && ! len ) { if ( ! ( p -> mechptr = sasl_mechanism_find ( buf ) ) ) { ( void ) sasl_sts ( p -> uid , 'M' , sasl_mechlist_string ) ; return false ; } ( void ) sasl_sourceinfo_recreate ( p ) ; if ( p -> mechptr -> mech_start ) rc = p -> mechptr -> mech_start ( p , & outbuf ) ; else rc = ASASL_MRESULT_CONTINUE ; } else if ( ! p -> mechptr ) { ( void ) slog ( LG_DEBUG , "%s: session has no mechanism?" , MOWGLI_FUNC_NAME ) ; return false ; } else { rc = sasl_process_input ( p , buf , len , & outbuf ) ; } if ( outbuf . buf && outbuf . len ) { if ( ! sasl_process_output ( p , & outbuf ) ) return false ; have_responded = true ; } p -> flags &= ~ ASASL_SFLAG_MARKED_FOR_DELETION ; switch ( rc ) { case ASASL_MRESULT_CONTINUE : { if ( ! have_responded ) ( void ) sasl_sts ( p -> uid , 'C' , "+" ) ; return true ; } case ASASL_MRESULT_SUCCESS : { struct user * const u = user_find ( p -> uid ) ; struct myuser * const mu = sasl_user_can_login ( p ) ; if ( ! mu ) { if ( u ) ( void ) notice ( saslsvs -> nick , u -> nick , LOGIN_CANCELLED_STR ) ; return false ; } if ( u && ! sasl_handle_login ( p , u , mu ) ) return false ; return sasl_session_success ( p , mu , ( u != NULL ) ) ; } case ASASL_MRESULT_FAILURE : { if ( * p -> authceid ) { struct myuser * const mu = myuser_find_uid ( p -> authceid ) ; if ( ! mu ) return false ; ( void ) sasl_sourceinfo_recreate ( p ) ; ( void ) logcommand ( p -> si , CMDLOG_LOGIN , "failed LOGIN (%s) to \2%s\2 (bad password)" , p -> mechptr -> name , entity ( mu ) -> name ) ; ( void ) bad_password ( p -> si , mu ) ; } return false ; } case ASASL_MRESULT_ERROR : return false ; } return false ; }
void Page :: ReleaseFreeListCategories ( ) { for ( int i = kFirstCategory ; i < kNumberOfCategories ; i ++ ) { if ( categories_ [ i ] != nullptr ) { delete categories_ [ i ] ; categories_ [ i ] = nullptr ; } } }
static int clie_5_attach ( struct usb_serial * serial ) { struct usb_serial_port * port ; unsigned int pipe ; int j ; if ( serial -> num_ports < 2 ) return - 1 ; port = serial -> port [ 0 ] ; port -> bulk_out_endpointAddress = serial -> port [ 1 ] -> bulk_out_endpointAddress ; pipe = usb_sndbulkpipe ( serial -> dev , port -> bulk_out_endpointAddress ) ; for ( j = 0 ; j < ARRAY_SIZE ( port -> write_urbs ) ; ++ j ) port -> write_urbs [ j ] -> pipe = pipe ; return 0 ; }
Reduction JSCallReducer :: ReduceObjectIs ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSCall , node -> opcode ( ) ) ; CallParameters const & params = CallParametersOf ( node -> op ( ) ) ; int const argc = static_cast < int > ( params . arity ( ) - 2 ) ; Node * lhs = ( argc >= 1 ) ? NodeProperties :: GetValueInput ( node , 2 ) : jsgraph ( ) -> UndefinedConstant ( ) ; Node * rhs = ( argc >= 2 ) ? NodeProperties :: GetValueInput ( node , 3 ) : jsgraph ( ) -> UndefinedConstant ( ) ; Node * value = graph ( ) -> NewNode ( simplified ( ) -> SameValue ( ) , lhs , rhs ) ; ReplaceWithValue ( node , value ) ; return Replace ( value ) ; }
void BytecodeGraphBuilder :: BuildLdaLookupGlobalSlot ( TypeofMode typeof_mode ) { uint32_t depth = bytecode_iterator ( ) . GetUnsignedImmediateOperand ( 2 ) ; Environment * slow_environment = CheckContextExtensions ( depth ) ; { PrepareEagerCheckpoint ( ) ; Handle < Name > name ( Name :: cast ( bytecode_iterator ( ) . GetConstantForIndexOperand ( 0 ) ) , isolate ( ) ) ; uint32_t feedback_slot_index = bytecode_iterator ( ) . GetIndexOperand ( 1 ) ; Node * node = BuildLoadGlobal ( name , feedback_slot_index , typeof_mode ) ; environment ( ) -> BindAccumulator ( node , Environment :: kAttachFrameState ) ; } if ( slow_environment != nullptr ) { NewMerge ( ) ; Environment * fast_environment = environment ( ) ; set_environment ( slow_environment ) ; { Node * name = jsgraph ( ) -> Constant ( handle ( bytecode_iterator ( ) . GetConstantForIndexOperand ( 0 ) , isolate ( ) ) ) ; const Operator * op = javascript ( ) -> CallRuntime ( typeof_mode == TypeofMode :: NOT_INSIDE_TYPEOF ? Runtime :: kLoadLookupSlot : Runtime :: kLoadLookupSlotInsideTypeof ) ; Node * value = NewNode ( op , name ) ; environment ( ) -> BindAccumulator ( value , Environment :: kAttachFrameState ) ; } fast_environment -> Merge ( environment ( ) , bytecode_analysis ( ) -> GetOutLivenessFor ( bytecode_iterator ( ) . current_offset ( ) ) ) ; set_environment ( fast_environment ) ; mark_as_needing_eager_checkpoint ( true ) ; } }
bool TCompiler :: Init ( const ShBuiltInResources & resources ) { TScopedPoolAllocator scopedAlloc ( & allocator , false ) ; if ( ! InitBuiltInSymbolTable ( resources ) ) return false ; InitExtensionBehavior ( resources , extensionBehavior ) ; return true ; }
nsDocShell :: LoadURI ( nsDocShellLoadState * aLoadState ) { MOZ_ASSERT ( aLoadState , "Must have a valid load state!" ) ; MOZ_ASSERT ( ( aLoadState -> LoadFlags ( ) & INTERNAL_LOAD_FLAGS_LOADURI_SETUP_FLAGS ) == 0 , "Should not have these flags set" ) ; MOZ_ASSERT ( aLoadState -> URI ( ) , "Should have a valid URI to load" ) ; if ( mUseStrictSecurityChecks && ! aLoadState -> TriggeringPrincipal ( ) ) { MOZ_ASSERT ( false , "LoadURI must have a triggering principal" ) ; return NS_ERROR_FAILURE ; } if ( ! IsNavigationAllowed ( true , false ) ) { return NS_OK ; } if ( ! StartupTimeline :: HasRecord ( StartupTimeline :: FIRST_LOAD_URI ) && mItemType == typeContent && ! NS_IsAboutBlank ( aLoadState -> URI ( ) ) ) { StartupTimeline :: RecordOnce ( StartupTimeline :: FIRST_LOAD_URI ) ; } MOZ_LOG ( gDocShellLeakLog , LogLevel :: Debug , ( "nsDocShell[%p]: loading %s with flags 0x%08x" , this , aLoadState -> URI ( ) -> GetSpecOrDefault ( ) . get ( ) , aLoadState -> LoadFlags ( ) ) ) ; if ( ! aLoadState -> SHEntry ( ) && ! LOAD_TYPE_HAS_FLAGS ( aLoadState -> LoadType ( ) , LOAD_FLAGS_REPLACE_HISTORY ) ) { MaybeHandleSubframeHistory ( aLoadState ) ; } if ( aLoadState -> SHEntry ( ) ) { #ifdef DEBUG MOZ_LOG ( gDocShellLog , LogLevel :: Debug , ( "nsDocShell[%p]: loading from session history" , this ) ) ; #endif return LoadHistoryEntry ( aLoadState -> SHEntry ( ) , aLoadState -> LoadType ( ) ) ; } if ( ( aLoadState -> LoadType ( ) == LOAD_NORMAL || aLoadState -> LoadType ( ) == LOAD_STOP_CONTENT ) && ShouldBlockLoadingForBackButton ( ) ) { return NS_OK ; } nsresult rv = aLoadState -> SetupInheritingPrincipal ( mItemType , mOriginAttributes ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aLoadState -> SetupTriggeringPrincipal ( mOriginAttributes ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; aLoadState -> CalculateDocShellInternalLoadFlags ( ) ; mozilla :: Maybe < nsCOMPtr < nsIURI > > resultPrincipalURI ; aLoadState -> GetMaybeResultPrincipalURI ( resultPrincipalURI ) ; MOZ_ASSERT ( aLoadState -> TypeHint ( ) . IsVoid ( ) , "Typehint should be null when calling InternalLoad from LoadURI" ) ; MOZ_ASSERT ( aLoadState -> FileName ( ) . IsVoid ( ) , "FileName should be null when calling InternalLoad from LoadURI" ) ; MOZ_ASSERT ( aLoadState -> SHEntry ( ) == nullptr , "SHEntry should be null when calling InternalLoad from LoadURI" ) ; return InternalLoad ( aLoadState -> URI ( ) , aLoadState -> OriginalURI ( ) , resultPrincipalURI , aLoadState -> KeepResultPrincipalURIIfSet ( ) , aLoadState -> LoadReplace ( ) , aLoadState -> Referrer ( ) , aLoadState -> ReferrerPolicy ( ) , aLoadState -> TriggeringPrincipal ( ) , aLoadState -> PrincipalToInherit ( ) , aLoadState -> DocShellInternalLoadFlags ( ) , aLoadState -> Target ( ) , aLoadState -> TypeHint ( ) , aLoadState -> FileName ( ) , aLoadState -> PostDataStream ( ) , aLoadState -> HeadersStream ( ) , aLoadState -> LoadType ( ) , aLoadState -> SHEntry ( ) , aLoadState -> FirstParty ( ) , aLoadState -> SrcdocData ( ) , aLoadState -> SourceDocShell ( ) , aLoadState -> BaseURI ( ) , nullptr , nullptr ) ; }
static void update_coef_probs_common ( vp9_writer * const bc , VP9_COMP * cpi , TX_SIZE tx_size , vp9_coeff_stats * frame_branch_ct ) { vp9_coeff_probs_model * new_frame_coef_probs = cpi -> frame_coef_probs [ tx_size ] ; vp9_coeff_probs_model * old_frame_coef_probs = cpi -> common . fc . coef_probs [ tx_size ] ; const vp9_prob upd = DIFF_UPDATE_PROB ; const int entropy_nodes_update = UNCONSTRAINED_NODES ; int i , j , k , l , t ; switch ( cpi -> sf . use_fast_coef_updates ) { case TWO_LOOP : { int savings = 0 ; int update [ 2 ] = { 0 , 0 } ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; const vp9_prob oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; int s ; int u = 0 ; if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , oldp , & newp , upd ) ; if ( s > 0 && newp != oldp ) u = 1 ; if ( u ) savings += s - ( int ) ( vp9_cost_zero ( upd ) ) ; else savings -= ( int ) ( vp9_cost_zero ( upd ) ) ; update [ u ] ++ ; } } } } } if ( update [ 1 ] == 0 || savings < 0 ) { vp9_write_bit ( bc , 0 ) ; return ; } vp9_write_bit ( bc , 1 ) ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ; const vp9_prob upd = DIFF_UPDATE_PROB ; int s ; int u = 0 ; if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ; if ( s > 0 && newp != * oldp ) u = 1 ; vp9_write ( bc , u , upd ) ; if ( u ) { vp9_write_prob_diff_update ( bc , newp , * oldp ) ; * oldp = newp ; } } } } } } return ; } case ONE_LOOP : case ONE_LOOP_REDUCED : { const int prev_coef_contexts_to_update = cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEFF_CONTEXTS > > 1 : COEFF_CONTEXTS ; const int coef_band_to_update = cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEF_BANDS > > 1 : COEF_BANDS ; int updates = 0 ; int noupdates_before_first = 0 ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ; int s ; int u = 0 ; if ( l >= prev_coef_contexts_to_update || k >= coef_band_to_update ) { u = 0 ; } else { if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ; if ( s > 0 && newp != * oldp ) u = 1 ; } updates += u ; if ( u == 0 && updates == 0 ) { noupdates_before_first ++ ; continue ; } if ( u == 1 && updates == 1 ) { int v ; vp9_write_bit ( bc , 1 ) ; for ( v = 0 ; v < noupdates_before_first ; ++ v ) vp9_write ( bc , 0 , upd ) ; } vp9_write ( bc , u , upd ) ; if ( u ) { vp9_write_prob_diff_update ( bc , newp , * oldp ) ; * oldp = newp ; } } } } } } if ( updates == 0 ) { vp9_write_bit ( bc , 0 ) ; } return ; } default : assert ( 0 ) ; } }
ComponentsObjectPolicy :: check ( JSContext * cx , JSObject * wrapper , jsid id , Wrapper :: Action act , Permission & perm ) { perm = DenyAccess ; JSAutoCompartment ac ( cx , wrapper ) ; if ( JSID_IS_STRING ( id ) && act == Wrapper :: GET ) { JSFlatString * flatId = JSID_TO_FLAT_STRING ( id ) ; if ( JS_FlatStringEqualsAscii ( flatId , "isSuccessCode" ) || JS_FlatStringEqualsAscii ( flatId , "lookupMethod" ) || JS_FlatStringEqualsAscii ( flatId , "interfaces" ) || JS_FlatStringEqualsAscii ( flatId , "interfacesByID" ) || JS_FlatStringEqualsAscii ( flatId , "results" ) ) { perm = PermitPropertyAccess ; return true ; } } if ( xpc :: IsUniversalXPConnectEnabled ( cx ) ) { perm = PermitPropertyAccess ; return true ; } AccessCheck :: deny ( cx , id ) ; return false ; }
WebSocketImpl :: AsyncOpen ( ErrorResult & aRv ) { MOZ_ASSERT ( NS_IsMainThread ( ) , "Not running on main thread" ) ; nsCString asciiOrigin ; aRv = nsContentUtils :: GetASCIIOrigin ( mPrincipal , asciiOrigin ) ; if ( NS_WARN_IF ( aRv . Failed ( ) ) ) { return ; } ToLowerCase ( asciiOrigin ) ; nsCOMPtr < nsIURI > uri ; aRv = NS_NewURI ( getter_AddRefs ( uri ) , mURI ) ; MOZ_ASSERT ( ! aRv . Failed ( ) ) ; aRv = mChannel -> AsyncOpen ( uri , asciiOrigin , this , nullptr ) ; if ( NS_WARN_IF ( aRv . Failed ( ) ) ) { return ; } }
static int sctp_process_param ( struct sctp_association * asoc , union sctp_params param , const union sctp_addr * peer_addr , gfp_t gfp ) { struct net * net = sock_net ( asoc -> base . sk ) ; union sctp_addr addr ; int i ; __u16 sat ; int retval = 1 ; sctp_scope_t scope ; time_t stale ; struct sctp_af * af ; union sctp_addr_param * addr_param ; struct sctp_transport * t ; struct sctp_endpoint * ep = asoc -> ep ; switch ( param . p -> type ) { case SCTP_PARAM_IPV6_ADDRESS : if ( PF_INET6 != asoc -> base . sk -> sk_family ) break ; goto do_addr_param ; case SCTP_PARAM_IPV4_ADDRESS : if ( ipv6_only_sock ( asoc -> base . sk ) ) break ; do_addr_param : af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ; af -> from_addr_param ( & addr , param . addr , htons ( asoc -> peer . port ) , 0 ) ; scope = sctp_scope ( peer_addr ) ; if ( sctp_in_scope ( net , & addr , scope ) ) if ( ! sctp_assoc_add_peer ( asoc , & addr , gfp , SCTP_UNCONFIRMED ) ) return 0 ; break ; case SCTP_PARAM_COOKIE_PRESERVATIVE : if ( ! net -> sctp . cookie_preserve_enable ) break ; stale = ntohl ( param . life -> lifespan_increment ) ; asoc -> cookie_life = ktime_add_ms ( asoc -> cookie_life , stale ) ; break ; case SCTP_PARAM_HOST_NAME_ADDRESS : pr_debug ( "%s: unimplemented SCTP_HOST_NAME_ADDRESS\n" , __func__ ) ; break ; case SCTP_PARAM_SUPPORTED_ADDRESS_TYPES : asoc -> peer . ipv4_address = 0 ; asoc -> peer . ipv6_address = 0 ; if ( peer_addr -> sa . sa_family == AF_INET6 ) asoc -> peer . ipv6_address = 1 ; else if ( peer_addr -> sa . sa_family == AF_INET ) asoc -> peer . ipv4_address = 1 ; sat = ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; if ( sat ) sat /= sizeof ( __u16 ) ; for ( i = 0 ; i < sat ; ++ i ) { switch ( param . sat -> types [ i ] ) { case SCTP_PARAM_IPV4_ADDRESS : asoc -> peer . ipv4_address = 1 ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( PF_INET6 == asoc -> base . sk -> sk_family ) asoc -> peer . ipv6_address = 1 ; break ; case SCTP_PARAM_HOST_NAME_ADDRESS : asoc -> peer . hostname_address = 1 ; break ; default : break ; } } break ; case SCTP_PARAM_STATE_COOKIE : asoc -> peer . cookie_len = ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; asoc -> peer . cookie = param . cookie -> body ; break ; case SCTP_PARAM_HEARTBEAT_INFO : break ; case SCTP_PARAM_UNRECOGNIZED_PARAMETERS : break ; case SCTP_PARAM_ECN_CAPABLE : asoc -> peer . ecn_capable = 1 ; break ; case SCTP_PARAM_ADAPTATION_LAYER_IND : asoc -> peer . adaptation_ind = ntohl ( param . aind -> adaptation_ind ) ; break ; case SCTP_PARAM_SET_PRIMARY : if ( ! net -> sctp . addip_enable ) goto fall_through ; addr_param = param . v + sizeof ( sctp_addip_param_t ) ; af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ; af -> from_addr_param ( & addr , addr_param , htons ( asoc -> peer . port ) , 0 ) ; if ( ! af -> addr_valid ( & addr , NULL , NULL ) ) break ; t = sctp_assoc_lookup_paddr ( asoc , & addr ) ; if ( ! t ) break ; sctp_assoc_set_primary ( asoc , t ) ; break ; case SCTP_PARAM_SUPPORTED_EXT : sctp_process_ext_param ( asoc , param ) ; break ; case SCTP_PARAM_FWD_TSN_SUPPORT : if ( net -> sctp . prsctp_enable ) { asoc -> peer . prsctp_capable = 1 ; break ; } goto fall_through ; case SCTP_PARAM_RANDOM : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_random = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_random ) { retval = 0 ; break ; } break ; case SCTP_PARAM_HMAC_ALGO : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_hmacs = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_hmacs ) { retval = 0 ; break ; } sctp_auth_asoc_set_default_hmac ( asoc , param . hmac_algo ) ; break ; case SCTP_PARAM_CHUNKS : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_chunks = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_chunks ) retval = 0 ; break ; fall_through : default : pr_debug ( "%s: ignoring param:%d for association:%p.\n" , __func__ , ntohs ( param . p -> type ) , asoc ) ; break ; } return retval ; }
% * / static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char geometry [ MaxTextExtent ] , * property ; const char * label ; DrawInfo * draw_info ; Image * image ; MagickBooleanType status ; TypeMetric metrics ; size_t height , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; ( void ) ResetImagePage ( image , "0x0+0+0" ) ; property = InterpretImageProperties ( image_info , image , image_info -> filename ) ; ( void ) SetImageProperty ( image , "label" , property ) ; property = DestroyString ( property ) ; label = GetImageProperty ( image , "label" ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; draw_info -> text = ConstantString ( label ) ; metrics . width = 0 ; metrics . ascent = 0.0 ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { image -> columns = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; } else if ( ( strlen ( label ) > 0 ) && ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%+g%+g" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%+g%+g" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ; } status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( image -> columns == 0 ) image -> columns = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; if ( image -> columns == 0 ) image -> columns = ( size_t ) floor ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; if ( image -> rows == 0 ) image -> rows = ( size_t ) floor ( metrics . ascent - metrics . descent + draw_info -> stroke_width + 0.5 ) ; if ( image -> rows == 0 ) image -> rows = ( size_t ) floor ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%+g%+g" , draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : 0.0 , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; draw_info -> geometry = AcquireString ( geometry ) ; status = AnnotateImage ( image , draw_info ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pointsize , MaxTextExtent , "%.20g" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , "label:pointsize" , pointsize ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; }
int arm_cpu_caps ( void ) { int flags ; int mask ; if ( ! arm_cpu_env_flags ( & flags ) ) { return flags ; } mask = arm_cpu_env_mask ( ) ; #if HAVE_EDSP flags |= HAS_EDSP ; #endif /* HAVE_EDSP */ #if HAVE_MEDIA flags |= HAS_MEDIA ; #endif /* HAVE_MEDIA */ #if HAVE_NEON flags |= HAS_NEON ; #endif /* HAVE_NEON */ return flags & mask ; }
nsGfxScrollFrameInner :: SetScrollbarEnabled ( nsIContent * aContent , nscoord aMaxPos ) { if ( aMaxPos ) { aContent -> UnsetAttr ( kNameSpaceID_None , nsGkAtoms :: disabled , true ) ; } else { aContent -> SetAttr ( kNameSpaceID_None , nsGkAtoms :: disabled , NS_LITERAL_STRING ( "true" ) , true ) ; } }
int do_set_thread_area ( struct task_struct * p , int idx , struct user_desc __user * u_info , int can_allocate ) { struct user_desc info ; if ( copy_from_user ( & info , u_info , sizeof ( info ) ) ) return - EFAULT ; if ( idx == - 1 ) idx = info . entry_number ; if ( idx == - 1 && can_allocate ) { idx = get_free_idx ( ) ; if ( idx < 0 ) return idx ; if ( put_user ( idx , & u_info -> entry_number ) ) return - EFAULT ; } if ( idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX ) return - EINVAL ; set_tls_desc ( p , idx , & info , 1 ) ; return 0 ; }
void ArrayBuiltinsAssembler :: GenerateArraySingleArgumentConstructor ( ElementsKind kind , AllocationSiteOverrideMode mode ) { typedef ArraySingleArgumentConstructorDescriptor Descriptor ; Node * context = Parameter ( Descriptor :: kContext ) ; Node * function = Parameter ( Descriptor :: kFunction ) ; Node * native_context = LoadObjectField ( function , JSFunction :: kContextOffset ) ; Node * array_map = LoadJSArrayElementsMap ( kind , native_context ) ; AllocationSiteMode allocation_site_mode = DONT_TRACK_ALLOCATION_SITE ; if ( mode == DONT_OVERRIDE ) { allocation_site_mode = AllocationSite :: ShouldTrack ( kind ) ? TRACK_ALLOCATION_SITE : DONT_TRACK_ALLOCATION_SITE ; } Node * array_size = Parameter ( Descriptor :: kArraySizeSmiParameter ) ; Node * allocation_site = Parameter ( Descriptor :: kAllocationSite ) ; GenerateConstructor ( context , function , array_map , array_size , allocation_site , kind , allocation_site_mode ) ; }
update_bar_address ( struct vmctx * ctx , struct pci_vdev * dev , uint64_t addr , int idx , int type , bool ignore_reg_unreg ) { bool decode = false ; uint64_t orig_addr = dev -> bar [ idx ] . addr ; if ( ! ignore_reg_unreg ) { if ( dev -> bar [ idx ] . type == PCIBAR_IO ) decode = porten ( dev ) ; else decode = memen ( dev ) ; } if ( decode ) unregister_bar ( dev , idx ) ; switch ( type ) { case PCIBAR_IO : case PCIBAR_MEM32 : dev -> bar [ idx ] . addr = addr ; break ; case PCIBAR_MEM64 : dev -> bar [ idx ] . addr &= ~ 0xffffffffUL ; dev -> bar [ idx ] . addr |= addr ; break ; case PCIBAR_MEMHI64 : dev -> bar [ idx ] . addr &= 0xffffffff ; dev -> bar [ idx ] . addr |= addr ; break ; default : assert ( 0 ) ; } if ( decode ) register_bar ( dev , idx ) ; if ( dev -> dev_ops -> vdev_update_bar_map && decode ) dev -> dev_ops -> vdev_update_bar_map ( ctx , dev , idx , orig_addr ) ; }
void Builtins :: Generate_WasmCompileLazy ( MacroAssembler * masm ) { __ sxtw ( x8 , w8 ) ; __ SmiTag ( x8 , x8 ) ; { HardAbortScope hard_abort ( masm ) ; FrameScope scope ( masm , StackFrame :: WASM_COMPILE_LAZY ) ; constexpr RegList gp_regs = Register :: ListOf < x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 > ( ) ; constexpr RegList fp_regs = Register :: ListOf < d0 , d1 , d2 , d3 , d4 , d5 , d6 , d7 > ( ) ; __ PushXRegList ( gp_regs ) ; __ PushDRegList ( fp_regs ) ; __ Push ( kWasmInstanceRegister , x8 ) ; __ Ldr ( x2 , FieldMemOperand ( kWasmInstanceRegister , WasmInstanceObject :: kCEntryStubOffset ) ) ; __ Mov ( cp , Smi :: kZero ) ; __ CallRuntimeWithCEntry ( Runtime :: kWasmCompileLazy , x2 ) ; __ mov ( x8 , kReturnRegister0 ) ; __ PopDRegList ( fp_regs ) ; __ PopXRegList ( gp_regs ) ; } __ Jump ( x8 ) ; }
int DoUpdate ( ) { NS_tchar manifest [ MAXPATHLEN ] ; NS_tsnprintf ( manifest , sizeof ( manifest ) / sizeof ( manifest [ 0 ] ) , NS_T ( "%s/update.manifest" ) , gSourcePath ) ; int rv = gArchiveReader . ExtractFile ( "updatev2.manifest" , manifest ) ; if ( rv ) { rv = gArchiveReader . ExtractFile ( "update.manifest" , manifest ) ; if ( rv ) { LOG ( ( "DoUpdate: error extracting manifest file" ) ) ; return rv ; } } NS_tchar * rb = GetManifestContents ( manifest ) ; if ( rb == nullptr ) { LOG ( ( "DoUpdate: error opening manifest file: " LOG_S , manifest ) ) ; return READ_ERROR ; } ActionList list ; NS_tchar * line ; bool isFirstAction = true ; while ( ( line = mstrtok ( kNL , & rb ) ) != 0 ) { if ( * line == NS_T ( '#' ) ) continue ; NS_tchar * token = mstrtok ( kWhitespace , & line ) ; if ( ! token ) { LOG ( ( "DoUpdate: token not found in manifest" ) ) ; return PARSE_ERROR ; } if ( isFirstAction && NS_tstrcmp ( token , NS_T ( "type" ) ) == 0 ) { const NS_tchar * type = mstrtok ( kQuote , & line ) ; LOG ( ( "UPDATE TYPE " LOG_S , type ) ) ; if ( NS_tstrcmp ( type , NS_T ( "complete" ) ) == 0 ) { rv = AddPreCompleteActions ( & list ) ; if ( rv ) return rv ; } isFirstAction = false ; continue ; } isFirstAction = false ; Action * action = nullptr ; if ( NS_tstrcmp ( token , NS_T ( "remove" ) ) == 0 ) { action = new RemoveFile ( ) ; } else if ( NS_tstrcmp ( token , NS_T ( "rmdir" ) ) == 0 ) { action = new RemoveDir ( ) ; } else if ( NS_tstrcmp ( token , NS_T ( "rmrfdir" ) ) == 0 ) { const NS_tchar * reldirpath = mstrtok ( kQuote , & line ) ; if ( ! reldirpath ) return PARSE_ERROR ; if ( reldirpath [ NS_tstrlen ( reldirpath ) - 1 ] != NS_T ( '/' ) ) return PARSE_ERROR ; rv = add_dir_entries ( reldirpath , & list ) ; if ( rv ) return rv ; continue ; } else if ( NS_tstrcmp ( token , NS_T ( "add" ) ) == 0 ) { action = new AddFile ( ) ; } else if ( NS_tstrcmp ( token , NS_T ( "patch" ) ) == 0 ) { action = new PatchFile ( ) ; } else if ( NS_tstrcmp ( token , NS_T ( "add-if" ) ) == 0 ) { action = new AddIfFile ( ) ; } else if ( NS_tstrcmp ( token , NS_T ( "patch-if" ) ) == 0 ) { action = new PatchIfFile ( ) ; } else if ( NS_tstrcmp ( token , NS_T ( "add-cc" ) ) == 0 ) { continue ; } else { LOG ( ( "DoUpdate: unknown token: " LOG_S , token ) ) ; return PARSE_ERROR ; } if ( ! action ) return BAD_ACTION_ERROR ; rv = action -> Parse ( line ) ; if ( rv ) return rv ; list . Append ( action ) ; } rv = list . Prepare ( ) ; if ( rv ) return rv ; rv = list . Execute ( ) ; list . Finish ( rv ) ; return rv ; }
Node * WasmGraphBuilder :: BuildImportWasmCall ( wasm :: FunctionSig * sig , Node * * args , Node * * * rets , wasm :: WasmCodePosition position , Node * func_index ) { Node * imported_instances = LOAD_INSTANCE_FIELD ( ImportedFunctionInstances , MachineType :: TaggedPointer ( ) ) ; Node * imported_instances_data = graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> IntAdd ( ) , imported_instances , mcgraph ( ) -> IntPtrConstant ( FixedArrayOffsetMinusTag ( 0 ) ) ) ; Node * func_index_times_pointersize = graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> IntMul ( ) , Uint32ToUintptr ( func_index ) , mcgraph ( ) -> Int32Constant ( kPointerSize ) ) ; Node * instance_node = SetEffect ( graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Load ( MachineType :: TaggedPointer ( ) ) , imported_instances_data , func_index_times_pointersize , Effect ( ) , Control ( ) ) ) ; Node * imported_targets = LOAD_INSTANCE_FIELD ( ImportedFunctionTargets , MachineType :: Pointer ( ) ) ; Node * target_node = SetEffect ( graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Load ( MachineType :: Pointer ( ) ) , imported_targets , func_index_times_pointersize , Effect ( ) , Control ( ) ) ) ; args [ 0 ] = target_node ; return BuildWasmCall ( sig , args , rets , position , instance_node , untrusted_code_mitigations_ ? kRetpoline : kNoRetpoline ) ; }
void Builtins :: Generate_DoubleToI ( MacroAssembler * masm ) { Label check_negative , process_64_bits , done ; const int kArgumentOffset = 4 * kRegisterSize ; MemOperand mantissa_operand ( MemOperand ( rsp , kArgumentOffset ) ) ; MemOperand exponent_operand ( MemOperand ( rsp , kArgumentOffset + kDoubleSize / 2 ) ) ; MemOperand return_operand = mantissa_operand ; Register scratch1 = rbx ; Register result_reg = rax ; Register save_reg = rax ; __ pushq ( rcx ) ; __ pushq ( scratch1 ) ; __ pushq ( save_reg ) ; __ movl ( scratch1 , mantissa_operand ) ; __ Movsd ( kScratchDoubleReg , mantissa_operand ) ; __ movl ( rcx , exponent_operand ) ; __ andl ( rcx , Immediate ( HeapNumber :: kExponentMask ) ) ; __ shrl ( rcx , Immediate ( HeapNumber :: kExponentShift ) ) ; __ leal ( result_reg , MemOperand ( rcx , - HeapNumber :: kExponentBias ) ) ; __ cmpl ( result_reg , Immediate ( HeapNumber :: kMantissaBits ) ) ; __ j ( below , & process_64_bits , Label :: kNear ) ; int delta = HeapNumber :: kExponentBias + Double :: kPhysicalSignificandSize ; __ subl ( rcx , Immediate ( delta ) ) ; __ xorl ( result_reg , result_reg ) ; __ cmpl ( rcx , Immediate ( 31 ) ) ; __ j ( above , & done , Label :: kNear ) ; __ shll_cl ( scratch1 ) ; __ jmp ( & check_negative , Label :: kNear ) ; __ bind ( & process_64_bits ) ; __ Cvttsd2siq ( result_reg , kScratchDoubleReg ) ; __ jmp ( & done , Label :: kNear ) ; __ bind ( & check_negative ) ; __ movl ( result_reg , scratch1 ) ; __ negl ( result_reg ) ; __ cmpl ( exponent_operand , Immediate ( 0 ) ) ; __ cmovl ( greater , result_reg , scratch1 ) ; __ bind ( & done ) ; __ movl ( return_operand , result_reg ) ; __ popq ( save_reg ) ; __ popq ( scratch1 ) ; __ popq ( rcx ) ; __ ret ( 0 ) ; }
SampleTable :: getSampleCencInfo ( uint32_t sample_index , Vector < uint16_t > & clear_sizes , Vector < uint32_t > & cipher_sizes , uint8_t iv [ ] ) { CHECK ( clear_sizes . isEmpty ( ) && cipher_sizes . isEmpty ( ) ) ; if ( sample_index >= mCencInfoCount ) { ALOGE ( "cenc info requested for out of range sample index" ) ; return ERROR_MALFORMED ; } auto & info = mCencInfo [ sample_index ] ; if ( clear_sizes . setCapacity ( info . mSubsampleCount ) < 0 ) { return ERROR_MALFORMED ; } if ( cipher_sizes . setCapacity ( info . mSubsampleCount ) < 0 ) { return ERROR_MALFORMED ; } for ( uint32_t i = 0 ; i < info . mSubsampleCount ; i ++ ) { clear_sizes . push ( info . mSubsamples [ i ] . mClearBytes ) ; cipher_sizes . push ( info . mSubsamples [ i ] . mCipherBytes ) ; } memcpy ( iv , info . mIV , IV_BYTES ) ; return OK ; }
xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; int count , i ; count = be32_to_cpu ( aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED ) ; acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }
struct resource_pool * dcn10_create_resource_pool ( const struct dc_init_data * init_data , struct dc * dc ) { struct dcn10_resource_pool * pool = kzalloc ( sizeof ( struct dcn10_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( init_data -> num_virtual_links , dc , pool ) ) return & pool -> base ; BREAK_TO_DEBUGGER ( ) ; return NULL ; }
{ ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , ResourceLimitError , "MemoryAllocationFailed" , "`%s'" , image -> filename ) ; } return ( compact_pixels ) ; } static size_t WritePSDChannels ( const PSDInfo * psd_info , const ImageInfo * image_info , Image * image , Image * next_image , MagickOffsetType size_offset , const MagickBooleanType separate , ExceptionInfo * exception ) { Image * mask ; MagickOffsetType rows_offset ; size_t channels , count , length , offset_length ; unsigned char * compact_pixels ; count = 0 ; offset_length = 0 ; rows_offset = 0 ; compact_pixels = ( unsigned char * ) NULL ; if ( next_image -> compression == RLECompression ) { compact_pixels = AcquireCompactPixels ( image , exception ) ; if ( compact_pixels == ( unsigned char * ) NULL ) return ( 0 ) ; } channels = 1 ; if ( separate == MagickFalse ) { if ( next_image -> storage_class != PseudoClass ) { if ( IsImageGray ( next_image ) == MagickFalse ) channels = next_image -> colorspace == CMYKColorspace ? 4 : 3 ; if ( next_image -> alpha_trait != UndefinedPixelTrait ) channels ++ ; } rows_offset = TellBlob ( image ) + 2 ; count += WriteCompressionStart ( psd_info , image , next_image , channels ) ; offset_length = ( next_image -> rows * ( psd_info -> version == 1 ? 2 : 4 ) ) ; } size_offset += 2 ; if ( next_image -> storage_class == PseudoClass ) { length = WritePSDChannel ( psd_info , image_info , image , next_image , IndexQuantum , compact_pixels , rows_offset , separate , exception ) ; if ( separate != MagickFalse ) size_offset += WritePSDSize ( psd_info , image , length , size_offset ) + 2 ; else rows_offset += offset_length ; count += length ; } else { if ( IsImageGray ( next_image ) != MagickFalse ) { length = WritePSDChannel ( psd_info , image_info , image , next_image , GrayQuantum , compact_pixels , rows_offset , separate , exception ) ; if ( separate != MagickFalse ) size_offset += WritePSDSize ( psd_info , image , length , size_offset ) + 2 ; else rows_offset += offset_length ; count += length ; } else { if ( next_image -> colorspace == CMYKColorspace ) ( void ) NegateCMYK ( next_image , exception ) ; length = WritePSDChannel ( psd_info , image_info , image , next_image , RedQuantum , compact_pixels , rows_offset , separate , exception ) ; if ( separate != MagickFalse ) size_offset += WritePSDSize ( psd_info , image , length , size_offset ) + 2 ; else rows_offset += offset_length ; count += length ; length = WritePSDChannel ( psd_info , image_info , image , next_image , GreenQuantum , compact_pixels , rows_offset , separate , exception ) ; if ( separate != MagickFalse ) size_offset += WritePSDSize ( psd_info , image , length , size_offset ) + 2 ; else rows_offset += offset_length ; count += length ; length = WritePSDChannel ( psd_info , image_info , image , next_image , BlueQuantum , compact_pixels , rows_offset , separate , exception ) ; if ( separate != MagickFalse ) size_offset += WritePSDSize ( psd_info , image , length , size_offset ) + 2 ; else rows_offset += offset_length ; count += length ; if ( next_image -> colorspace == CMYKColorspace ) { length = WritePSDChannel ( psd_info , image_info , image , next_image , BlackQuantum , compact_pixels , rows_offset , separate , exception ) ; if ( separate != MagickFalse ) size_offset += WritePSDSize ( psd_info , image , length , size_offset ) + 2 ; else rows_offset += offset_length ; count += length ; } } if ( next_image -> alpha_trait != UndefinedPixelTrait ) { length = WritePSDChannel ( psd_info , image_info , image , next_image , AlphaQuantum , compact_pixels , rows_offset , separate , exception ) ; if ( separate != MagickFalse ) size_offset += WritePSDSize ( psd_info , image , length , size_offset ) + 2 ; else rows_offset += offset_length ; count += length ; } } compact_pixels = ( unsigned char * ) RelinquishMagickMemory ( compact_pixels ) ; if ( next_image -> colorspace == CMYKColorspace ) ( void ) NegateCMYK ( next_image , exception ) ; if ( separate != MagickFalse ) { const char * property ; property = GetImageArtifact ( next_image , "psd:opacity-mask" ) ; if ( property != ( const char * ) NULL ) { mask = ( Image * ) GetImageRegistry ( ImageRegistryType , property , exception ) ; if ( mask != ( Image * ) NULL ) { if ( mask -> compression == RLECompression ) { compact_pixels = AcquireCompactPixels ( mask , exception ) ; if ( compact_pixels == ( unsigned char * ) NULL ) return ( 0 ) ; } length = WritePSDChannel ( psd_info , image_info , image , mask , RedQuantum , compact_pixels , rows_offset , MagickTrue , exception ) ; ( void ) WritePSDSize ( psd_info , image , length , size_offset ) ;
Handle < String > Factory :: NumberToString ( Smi * number , bool check_cache ) { int hash = 0 ; if ( check_cache ) { hash = NumberToStringCacheHash ( number_string_cache ( ) , number ) ; Handle < Object > cached = NumberToStringCacheGet ( number , hash ) ; if ( ! cached -> IsUndefined ( isolate ( ) ) ) return Handle < String > :: cast ( cached ) ; } char arr [ 100 ] ; Vector < char > buffer ( arr , arraysize ( arr ) ) ; const char * string = IntToCString ( number -> value ( ) , buffer ) ; return NumberToStringCacheSet ( handle ( number , isolate ( ) ) , hash , string , check_cache ) ; }
static int store_xauthority ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_XAUTHORITY_FILE ; FILE * fp = fopen ( dest , "w" ) ; if ( fp ) { fprintf ( fp , "\n" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0600 ) ; fclose ( fp ) ; } if ( asprintf ( & src , "%s/.Xauthority" , cfg . homedir ) == - 1 ) errExit ( "asprintf" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { fprintf ( stderr , "Error: invalid .Xauthority file\n" ) ; exit ( 1 ) ; } pid_t child = fork ( ) ; if ( child < 0 ) errExit ( "fork" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest ) ; if ( rv ) fprintf ( stderr , "Warning: cannot transfer .Xauthority in private home directory\n" ) ; else { fs_logger2 ( "clone" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) errExit ( "fchown" ) ; if ( chmod ( dest , 0600 ) == - 1 ) errExit ( "fchmod" ) ; return 1 ; } return 0 ; }
Time NowFromSystemTime ( ) { LockGuard < Mutex > lock_guard ( & mutex_ ) ; initial_ticks_ = GetSystemTicks ( ) ; initial_time_ = GetSystemTime ( ) ; return initial_time_ ; }
WebGLFramebuffer :: FramebufferRenderbuffer ( WebGLenum target , WebGLenum attachment , WebGLenum rbtarget , WebGLRenderbuffer * wrb ) { if ( ! mContext -> ValidateObjectAllowNull ( "framebufferRenderbuffer: renderbuffer" , wrb ) ) { return ; } if ( target != LOCAL_GL_FRAMEBUFFER ) return mContext -> ErrorInvalidEnumInfo ( "framebufferRenderbuffer: target" , target ) ; if ( rbtarget != LOCAL_GL_RENDERBUFFER ) return mContext -> ErrorInvalidEnumInfo ( "framebufferRenderbuffer: renderbuffer target:" , rbtarget ) ; switch ( attachment ) { case LOCAL_GL_DEPTH_ATTACHMENT : mDepthAttachment . SetRenderbuffer ( wrb ) ; break ; case LOCAL_GL_STENCIL_ATTACHMENT : mStencilAttachment . SetRenderbuffer ( wrb ) ; break ; case LOCAL_GL_DEPTH_STENCIL_ATTACHMENT : mDepthStencilAttachment . SetRenderbuffer ( wrb ) ; break ; default : if ( ! CheckColorAttachementNumber ( attachment , "framebufferRenderbuffer" ) ) { return ; } size_t colorAttachmentId = size_t ( attachment - LOCAL_GL_COLOR_ATTACHMENT0 ) ; EnsureColorAttachments ( colorAttachmentId ) ; mColorAttachments [ colorAttachmentId ] . SetRenderbuffer ( wrb ) ; break ; } mContext -> MakeContextCurrent ( ) ; WebGLuint parambuffername = wrb ? wrb -> GLName ( ) : 0 ; if ( attachment == LOCAL_GL_DEPTH_STENCIL_ATTACHMENT ) { WebGLuint depthbuffername = parambuffername ; WebGLuint stencilbuffername = parambuffername ; if ( ! parambuffername ) { depthbuffername = mDepthAttachment . Renderbuffer ( ) ? mDepthAttachment . Renderbuffer ( ) -> GLName ( ) : 0 ; stencilbuffername = mStencilAttachment . Renderbuffer ( ) ? mStencilAttachment . Renderbuffer ( ) -> GLName ( ) : 0 ; } mContext -> gl -> fFramebufferRenderbuffer ( target , LOCAL_GL_DEPTH_ATTACHMENT , rbtarget , depthbuffername ) ; mContext -> gl -> fFramebufferRenderbuffer ( target , LOCAL_GL_STENCIL_ATTACHMENT , rbtarget , stencilbuffername ) ; } else { WebGLuint renderbuffername = parambuffername ; if ( ! parambuffername && ( attachment == LOCAL_GL_DEPTH_ATTACHMENT || attachment == LOCAL_GL_STENCIL_ATTACHMENT ) ) { renderbuffername = mDepthStencilAttachment . Renderbuffer ( ) ? mDepthStencilAttachment . Renderbuffer ( ) -> GLName ( ) : 0 ; } mContext -> gl -> fFramebufferRenderbuffer ( target , attachment , rbtarget , renderbuffername ) ; } }
enum sctp_disposition sctp_sf_violation ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const union sctp_subtype type , void * arg , struct sctp_cmd_seq * commands ) { struct sctp_chunk * chunk = arg ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( struct sctp_chunkhdr ) ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; return SCTP_DISPOSITION_VIOLATION ; }
DataTransfer :: SetDataAtInternal ( const nsAString & aFormat , nsIVariant * aData , uint32_t aIndex , nsIPrincipal * aSubjectPrincipal ) { if ( aFormat . IsEmpty ( ) ) { return NS_OK ; } if ( mReadOnly ) { return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR ; } if ( aIndex > mItems . Length ( ) ) { return NS_ERROR_DOM_INDEX_SIZE_ERR ; } if ( aIndex > 0 && ( mEventMessage == eCut || mEventMessage == eCopy || mEventMessage == ePaste ) ) { return NS_ERROR_DOM_INDEX_SIZE_ERR ; } if ( aFormat . EqualsLiteral ( kCustomTypesMime ) ) { return NS_ERROR_TYPE_ERR ; } if ( ! nsContentUtils :: IsSystemPrincipal ( aSubjectPrincipal ) ) { if ( aFormat . EqualsLiteral ( "application/x-moz-file-promise" ) || aFormat . EqualsLiteral ( "application/x-moz-file" ) ) { return NS_ERROR_DOM_SECURITY_ERR ; } uint16_t type ; aData -> GetDataType ( & type ) ; if ( type == nsIDataType :: VTYPE_INTERFACE || type == nsIDataType :: VTYPE_INTERFACE_IS ) { return NS_ERROR_DOM_SECURITY_ERR ; } } return SetDataWithPrincipal ( aFormat , aData , aIndex , aSubjectPrincipal ) ; }
IGNITION_HANDLER ( CreateEmptyArrayLiteral , InterpreterAssembler ) { Node * feedback_vector = LoadFeedbackVector ( ) ; Node * slot_id = BytecodeOperandIdx ( 0 ) ; Node * context = GetContext ( ) ; ConstructorBuiltinsAssembler constructor_assembler ( state ( ) ) ; Node * result = constructor_assembler . EmitCreateEmptyArrayLiteral ( feedback_vector , slot_id , context ) ; SetAccumulator ( result ) ; Dispatch ( ) ; }
XrayWrapper < Base , Traits > :: delete_ ( JSContext * cx , JSObject * wrapper , jsid id , bool * bp ) { if ( XrayUtils :: IsTransparent ( cx , wrapper ) ) { JSObject * obj = Traits :: getTargetObject ( wrapper ) ; JSAutoCompartment ac ( cx , obj ) ; JSBool b ; jsval v ; if ( ! JS_DeletePropertyById2 ( cx , obj , id , & v ) || ! JS_ValueToBoolean ( cx , v , & b ) ) return false ; * bp = ! ! b ; return true ; } JSObject * target = Traits :: getTargetObject ( wrapper ) ; JSObject * expando = Traits :: singleton . getExpandoObject ( cx , target , wrapper ) ; JSBool b = true ; if ( expando ) { JSAutoCompartment ac ( cx , expando ) ; jsval v ; if ( ! JS_DeletePropertyById2 ( cx , expando , id , & v ) || ! JS_ValueToBoolean ( cx , v , & b ) ) { return false ; } } * bp = ! ! b ; return true ; }
xmlParseInternalSubset ( xmlParserCtxtPtr ctxt ) { if ( RAW == '[' ) { ctxt -> instate = XML_PARSER_DTD ; NEXT ; while ( ( RAW != ']' ) && ( ctxt -> instate != XML_PARSER_EOF ) ) { const xmlChar * check = CUR_PTR ; unsigned int cons = ctxt -> input -> consumed ; SKIP_BLANKS ; xmlParseMarkupDecl ( ctxt ) ; xmlParsePEReference ( ctxt ) ; while ( ( RAW == 0 ) && ( ctxt -> inputNr > 1 ) ) xmlPopInput ( ctxt ) ; if ( ( CUR_PTR == check ) && ( cons == ctxt -> input -> consumed ) ) { xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , "xmlParseInternalSubset: error detected in Markup declaration\n" ) ; break ; } } if ( RAW == ']' ) { NEXT ; SKIP_BLANKS ; } } if ( RAW != '>' ) { xmlFatalErr ( ctxt , XML_ERR_DOCTYPE_NOT_FINISHED , NULL ) ; return ; } NEXT ; }
Reduction JSContextSpecialization :: ReduceJSStoreContext ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSStoreContext , node -> opcode ( ) ) ; const ContextAccess & access = ContextAccessOf ( node -> op ( ) ) ; size_t depth = access . depth ( ) ; Node * context = NodeProperties :: GetOuterContext ( node , & depth ) ; base :: Optional < ContextRef > maybe_concrete = GetSpecializationContext ( js_heap_broker ( ) , context , & depth , outer ( ) ) ; if ( ! maybe_concrete . has_value ( ) ) { return SimplifyJSStoreContext ( node , context , depth ) ; } ContextRef concrete = maybe_concrete . value ( ) ; for ( ; depth > 0 ; -- depth ) { concrete = concrete . previous ( ) . value ( ) ; } return SimplifyJSStoreContext ( node , jsgraph ( ) -> Constant ( concrete ) , depth ) ; }
void WebAssemblyTableSet ( const v8 :: FunctionCallbackInfo < v8 :: Value > & args ) { v8 :: Isolate * isolate = args . GetIsolate ( ) ; i :: Isolate * i_isolate = reinterpret_cast < i :: Isolate * > ( isolate ) ; HandleScope scope ( isolate ) ; ScheduledErrorThrower thrower ( i_isolate , "WebAssembly.Table.set()" ) ; Local < Context > context = isolate -> GetCurrentContext ( ) ; EXTRACT_THIS ( receiver , WasmTableObject ) ; int64_t index ; if ( ! args [ 0 ] -> IntegerValue ( context ) . To ( & index ) ) return ; i :: Handle < i :: Object > value = Utils :: OpenHandle ( * args [ 1 ] ) ; if ( ! value -> IsNull ( i_isolate ) && ! i :: WasmExportedFunction :: IsWasmExportedFunction ( * value ) ) { thrower . TypeError ( "Argument 1 must be null or a WebAssembly function" ) ; return ; } if ( index < 0 || index >= receiver -> functions ( ) -> length ( ) ) { thrower . RangeError ( "index out of bounds" ) ; return ; } i :: WasmTableObject :: Set ( i_isolate , receiver , static_cast < int32_t > ( index ) , value -> IsNull ( i_isolate ) ? i :: Handle < i :: JSFunction > :: null ( ) : i :: Handle < i :: JSFunction > :: cast ( value ) ) ; }
static void opl3_setup_voice ( int dev , int voice , int chn ) { struct channel_info * info = & synth_devs [ dev ] -> chn_info [ chn ] ; opl3_set_instr ( dev , voice , info -> pgm_num ) ; devc -> voc [ voice ] . bender = 0 ; devc -> voc [ voice ] . bender_range = info -> bender_range ; devc -> voc [ voice ] . volume = info -> controllers [ CTL_MAIN_VOLUME ] ; devc -> voc [ voice ] . panning = ( info -> controllers [ CTL_PAN ] * 2 ) - 128 ; }
Response V8ConsoleAgentImpl :: enable ( ) { if ( m_enabled ) return Response :: OK ( ) ; m_state -> setBoolean ( ConsoleAgentState :: consoleEnabled , true ) ; m_enabled = true ; m_session -> inspector ( ) -> enableStackCapturingIfNeeded ( ) ; reportAllMessages ( ) ; return Response :: OK ( ) ; }
nsHtml5StateSnapshot :: nsHtml5StateSnapshot ( jArray < nsHtml5StackNode * , int32_t > stack , jArray < nsHtml5StackNode * , int32_t > listOfActiveFormattingElements , nsIContent * * formPointer , nsIContent * * headPointer , nsIContent * * deepTreeSurrogateParent , int32_t mode , int32_t originalMode , bool framesetOk , bool needToDropLF , bool quirks ) : stack ( stack ) , listOfActiveFormattingElements ( listOfActiveFormattingElements ) , formPointer ( formPointer ) , headPointer ( headPointer ) , deepTreeSurrogateParent ( deepTreeSurrogateParent ) , mode ( mode ) , originalMode ( originalMode ) , framesetOk ( framesetOk ) , needToDropLF ( needToDropLF ) , quirks ( quirks ) { MOZ_COUNT_CTOR ( nsHtml5StateSnapshot ) ; }
TF_BUILTIN ( ObjectIs , ObjectBuiltinsAssembler ) { Node * const left = Parameter ( Descriptor :: kLeft ) ; Node * const right = Parameter ( Descriptor :: kRight ) ; Label return_true ( this ) , return_false ( this ) ; BranchIfSameValue ( left , right , & return_true , & return_false ) ; BIND ( & return_true ) ; Return ( TrueConstant ( ) ) ; BIND ( & return_false ) ; Return ( FalseConstant ( ) ) ; }
status_t ESDS :: parseESDescriptor ( size_t offset , size_t size ) { if ( size < 3 ) { return ERROR_MALFORMED ; } offset += 2 ; size -= 2 ; unsigned streamDependenceFlag = mData [ offset ] & 0x80 ; unsigned URL_Flag = mData [ offset ] & 0x40 ; unsigned OCRstreamFlag = mData [ offset ] & 0x20 ; ++ offset ; -- size ; if ( streamDependenceFlag ) { offset += 2 ; size -= 2 ; } if ( URL_Flag ) { if ( offset >= size ) { return ERROR_MALFORMED ; } unsigned URLlength = mData [ offset ] ; offset += URLlength + 1 ; size -= URLlength + 1 ; } if ( OCRstreamFlag ) { offset += 2 ; size -= 2 ; if ( ( offset >= size || mData [ offset ] != kTag_DecoderConfigDescriptor ) && offset - 2 < size && mData [ offset - 2 ] == kTag_DecoderConfigDescriptor ) { offset -= 2 ; size += 2 ; ALOGW ( "Found malformed 'esds' atom, ignoring missing OCR_ES_Id." ) ; } } if ( offset >= size ) { return ERROR_MALFORMED ; } uint8_t tag ; size_t sub_offset , sub_size ; status_t err = skipDescriptorHeader ( offset , size , & tag , & sub_offset , & sub_size ) ; if ( err != OK ) { return err ; } if ( tag != kTag_DecoderConfigDescriptor ) { return ERROR_MALFORMED ; } err = parseDecoderConfigDescriptor ( sub_offset , sub_size ) ; return err ; }
static void TailCallRuntimeIfMarkerEquals ( MacroAssembler * masm , Register smi_entry , OptimizationMarker marker , Runtime :: FunctionId function_id ) { Label no_match ; __ CmpSmiLiteral ( smi_entry , Smi :: FromEnum ( marker ) , r0 ) ; __ bne ( & no_match ) ; GenerateTailCallToReturnedCode ( masm , function_id ) ; __ bind ( & no_match ) ; }
xmlNodePtr SimpleXMLElement_exportNode ( const Object & sxe ) { assert ( sxe -> instanceof ( SimpleXMLElement_classof ( ) ) ) ; auto data = Native :: data < SimpleXMLElement > ( sxe . get ( ) ) ; return php_sxe_get_first_node ( data , data -> nodep ( ) ) ; }
bool NeedsImplicitReceiver ( Handle < SharedFunctionInfo > shared_info ) { DisallowHeapAllocation no_gc ; if ( ! shared_info -> construct_as_builtin ( ) ) { return ! IsDerivedConstructor ( shared_info -> kind ( ) ) ; } else { return false ; } }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; const TfLiteTensor * input1 = GetInput ( context , node , kInputTensor1 ) ; const TfLiteTensor * input2 = GetInput ( context , node , kInputTensor2 ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; switch ( input1 -> type ) { case kTfLiteInt32 : { return EvalImpl < int32_t > ( context , data -> requires_broadcast , input1 , input2 , output ) ; } case kTfLiteFloat32 : { return EvalImpl < float > ( context , data -> requires_broadcast , input1 , input2 , output ) ; } default : { context -> ReportError ( context , "Type '%s' is not supported by floor_div." , TfLiteTypeGetName ( input1 -> type ) ) ; return kTfLiteError ; } } }
nsDOMStorage2 :: InitAsSessionStorage ( nsIPrincipal * aPrincipal , const nsSubstring & aDocumentURI ) { mStorage = new nsDOMStorage ( ) ; if ( ! mStorage ) return NS_ERROR_OUT_OF_MEMORY ; mStorage -> mSecurityChecker = this ; mPrincipal = aPrincipal ; mDocumentURI = aDocumentURI ; return mStorage -> InitAsSessionStorage ( aPrincipal , aDocumentURI ) ; }
void SubpelVarianceTest < vp9_subp_avg_variance_fn_t > :: RefTest ( ) { for ( int x = 0 ; x < 16 ; ++ x ) { for ( int y = 0 ; y < 16 ; ++ y ) { for ( int j = 0 ; j < block_size_ ; j ++ ) { src_ [ j ] = rnd . Rand8 ( ) ; sec_ [ j ] = rnd . Rand8 ( ) ; } for ( int j = 0 ; j < block_size_ + width_ + height_ + 1 ; j ++ ) { ref_ [ j ] = rnd . Rand8 ( ) ; } unsigned int sse1 , sse2 ; unsigned int var1 ; REGISTER_STATE_CHECK ( var1 = subpel_variance_ ( ref_ , width_ + 1 , x , y , src_ , width_ , & sse1 , sec_ ) ) ; const unsigned int var2 = subpel_avg_variance_ref ( ref_ , src_ , sec_ , log2width_ , log2height_ , x , y , & sse2 ) ; EXPECT_EQ ( sse1 , sse2 ) < < "at position " < < x < < ", " < < y ; EXPECT_EQ ( var1 , var2 ) < < "at position " < < x < < ", " < < y ; } } }
base :: Optional < JSObjectRef > AllocationSiteRef :: boilerplate ( ) const { if ( broker ( ) -> mode ( ) == JSHeapBroker :: kDisabled ) { AllowHandleAllocation handle_allocation ; AllowHandleDereference allow_handle_dereference ; return JSObjectRef ( broker ( ) , handle ( object < AllocationSite > ( ) -> boilerplate ( ) , broker ( ) -> isolate ( ) ) ) ; } else { JSObjectData * boilerplate = data ( ) -> AsAllocationSite ( ) -> boilerplate ; if ( boilerplate ) { return JSObjectRef ( boilerplate ) ; } else { return base :: nullopt ; } } }
static bool parse_reconnect ( struct pool * pool , json_t * val ) { char * sockaddr_url , * stratum_port , * tmp ; char * url , * port , address [ 256 ] ; memset ( address , 0 , 255 ) ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; else { char * dot_pool , * dot_reconnect ; dot_pool = strchr ( pool -> sockaddr_url , '.' ) ; if ( ! dot_pool ) { applog ( LOG_ERR , "Denied stratum reconnect request for pool without domain '%s'" , pool -> sockaddr_url ) ; return false ; } dot_reconnect = strchr ( url , '.' ) ; if ( ! dot_reconnect ) { applog ( LOG_ERR , "Denied stratum reconnect request to url without domain '%s'" , url ) ; return false ; } if ( strcmp ( dot_pool , dot_reconnect ) ) { applog ( LOG_ERR , "Denied stratum reconnect request to non-matching domain url '%s'" , pool -> sockaddr_url ) ; return false ; } } port = ( char * ) json_string_value ( json_array_get ( val , 1 ) ) ; if ( ! port ) port = pool -> stratum_port ; sprintf ( address , "%s:%s" , url , port ) ; if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ; applog ( LOG_WARNING , "Stratum reconnect requested from pool %d to %s" , pool -> pool_no , address ) ; clear_pool_work ( pool ) ; mutex_lock ( & pool -> stratum_lock ) ; __suspend_stratum ( pool ) ; tmp = pool -> sockaddr_url ; pool -> sockaddr_url = sockaddr_url ; pool -> stratum_url = pool -> sockaddr_url ; free ( tmp ) ; tmp = pool -> stratum_port ; pool -> stratum_port = stratum_port ; free ( tmp ) ; mutex_unlock ( & pool -> stratum_lock ) ; if ( ! restart_stratum ( pool ) ) { pool_failed ( pool ) ; return false ; } return true ; }
Handle < Object > Intl :: CompareStrings ( Isolate * isolate , Handle < JSCollator > collator , Handle < String > string1 , Handle < String > string2 ) { Factory * factory = isolate -> factory ( ) ; icu :: Collator * icu_collator = collator -> icu_collator ( ) -> raw ( ) ; CHECK_NOT_NULL ( icu_collator ) ; string1 = String :: Flatten ( isolate , string1 ) ; string2 = String :: Flatten ( isolate , string2 ) ; UCollationResult result ; UErrorCode status = U_ZERO_ERROR ; { DisallowHeapAllocation no_gc ; int32_t length1 = string1 -> length ( ) ; int32_t length2 = string2 -> length ( ) ; String :: FlatContent flat1 = string1 -> GetFlatContent ( ) ; String :: FlatContent flat2 = string2 -> GetFlatContent ( ) ; std :: unique_ptr < uc16 [ ] > sap1 ; std :: unique_ptr < uc16 [ ] > sap2 ; icu :: UnicodeString string_val1 ( FALSE , GetUCharBufferFromFlat ( flat1 , & sap1 , length1 ) , length1 ) ; icu :: UnicodeString string_val2 ( FALSE , GetUCharBufferFromFlat ( flat2 , & sap2 , length2 ) , length2 ) ; result = icu_collator -> compare ( string_val1 , string_val2 , status ) ; } DCHECK ( U_SUCCESS ( status ) ) ; return factory -> NewNumberFromInt ( result ) ; }
gl :: ErrorOrResult < Buffer11 :: BufferStorage * > Buffer11 :: getBufferStorage ( BufferUsage usage ) { ASSERT ( 0 <= usage && usage < BUFFER_USAGE_COUNT ) ; BufferStorage * & newStorage = mBufferStorages [ usage ] ; if ( ! newStorage ) { newStorage = allocateStorage ( usage ) ; } if ( newStorage -> getSize ( ) < mSize ) { ANGLE_TRY ( newStorage -> resize ( mSize , true ) ) ; } ANGLE_TRY ( updateBufferStorage ( newStorage , 0 , mSize ) ) ; ANGLE_TRY ( markBufferUsage ( usage ) ) ; return newStorage ; }
TEST_P ( Trans32x32Test , MemCheck ) { ACMRandom rnd ( ACMRandom :: DeterministicSeed ( ) ) ; const int count_test_block = 2000 ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , input_block , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , input_extreme_block , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , output_ref_block , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , output_block , kNumCoeffs ) ; for ( int i = 0 ; i < count_test_block ; ++ i ) { for ( int j = 0 ; j < kNumCoeffs ; ++ j ) { input_block [ j ] = rnd . Rand8 ( ) - rnd . Rand8 ( ) ; input_extreme_block [ j ] = rnd . Rand8 ( ) & 1 ? 255 : - 255 ; } if ( i == 0 ) for ( int j = 0 ; j < kNumCoeffs ; ++ j ) input_extreme_block [ j ] = 255 ; if ( i == 1 ) for ( int j = 0 ; j < kNumCoeffs ; ++ j ) input_extreme_block [ j ] = - 255 ; const int stride = 32 ; vp9_fdct32x32_c ( input_extreme_block , output_ref_block , stride ) ; REGISTER_STATE_CHECK ( fwd_txfm_ ( input_extreme_block , output_block , stride ) ) ; for ( int j = 0 ; j < kNumCoeffs ; ++ j ) { if ( version_ == 0 ) { EXPECT_EQ ( output_block [ j ] , output_ref_block [ j ] ) < < "Error: 32x32 FDCT versions have mismatched coefficients" ; } else { EXPECT_GE ( 6 , abs ( output_block [ j ] - output_ref_block [ j ] ) ) < < "Error: 32x32 FDCT rd has mismatched coefficients" ; } EXPECT_GE ( 4 * DCT_MAX_VALUE , abs ( output_ref_block [ j ] ) ) < < "Error: 32x32 FDCT C has coefficient larger than 4*DCT_MAX_VALUE" ; EXPECT_GE ( 4 * DCT_MAX_VALUE , abs ( output_block [ j ] ) ) < < "Error: 32x32 FDCT has coefficient larger than " < < "4*DCT_MAX_VALUE" ; } } }
txStylesheetCompiler :: startElementInternal ( PRInt32 aNamespaceID , nsIAtom * aLocalName , nsIAtom * aPrefix , txStylesheetAttr * aAttributes , PRInt32 aAttrCount , PRInt32 aIDOffset ) { nsresult rv = NS_OK ; PRInt32 i ; for ( i = mInScopeVariables . Length ( ) - 1 ; i >= 0 ; -- i ) { ++ mInScopeVariables [ i ] -> mLevel ; } for ( i = 0 ; i < aAttrCount ; ++ i ) { txStylesheetAttr * attr = aAttributes + i ; if ( attr -> mNamespaceID == kNameSpaceID_XML && attr -> mLocalName == nsGkAtoms :: space ) { rv = ensureNewElementContext ( ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( TX_StringEqualsAtom ( attr -> mValue , nsGkAtoms :: preserve ) ) { mElementContext -> mPreserveWhitespace = true ; } else if ( TX_StringEqualsAtom ( attr -> mValue , nsGkAtoms :: _default ) ) { mElementContext -> mPreserveWhitespace = false ; } else { return NS_ERROR_XSLT_PARSE_FAILURE ; } } if ( attr -> mNamespaceID == kNameSpaceID_XML && attr -> mLocalName == nsGkAtoms :: base && ! attr -> mValue . IsEmpty ( ) ) { rv = ensureNewElementContext ( ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsAutoString uri ; URIUtils :: resolveHref ( attr -> mValue , mElementContext -> mBaseURI , uri ) ; mElementContext -> mBaseURI = uri ; } if ( ( attr -> mNamespaceID == kNameSpaceID_XSLT && attr -> mLocalName == nsGkAtoms :: extensionElementPrefixes && aNamespaceID != kNameSpaceID_XSLT ) || ( attr -> mNamespaceID == kNameSpaceID_None && attr -> mLocalName == nsGkAtoms :: extensionElementPrefixes && aNamespaceID == kNameSpaceID_XSLT && ( aLocalName == nsGkAtoms :: stylesheet || aLocalName == nsGkAtoms :: transform ) ) ) { rv = ensureNewElementContext ( ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsWhitespaceTokenizer tok ( attr -> mValue ) ; while ( tok . hasMoreTokens ( ) ) { PRInt32 namespaceID = mElementContext -> mMappings -> lookupNamespaceWithDefault ( tok . nextToken ( ) ) ; if ( namespaceID == kNameSpaceID_Unknown ) return NS_ERROR_XSLT_PARSE_FAILURE ; if ( ! mElementContext -> mInstructionNamespaces . AppendElement ( namespaceID ) ) { return NS_ERROR_OUT_OF_MEMORY ; } } attr -> mLocalName = nsnull ; } if ( ( attr -> mNamespaceID == kNameSpaceID_XSLT && attr -> mLocalName == nsGkAtoms :: version && aNamespaceID != kNameSpaceID_XSLT ) || ( attr -> mNamespaceID == kNameSpaceID_None && attr -> mLocalName == nsGkAtoms :: version && aNamespaceID == kNameSpaceID_XSLT && ( aLocalName == nsGkAtoms :: stylesheet || aLocalName == nsGkAtoms :: transform ) ) ) { rv = ensureNewElementContext ( ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( attr -> mValue . EqualsLiteral ( "1.0" ) ) { mElementContext -> mForwardsCompatibleParsing = false ; } else { mElementContext -> mForwardsCompatibleParsing = true ; } } } bool isInstruction = false ; PRInt32 count = mElementContext -> mInstructionNamespaces . Length ( ) ; for ( i = 0 ; i < count ; ++ i ) { if ( mElementContext -> mInstructionNamespaces [ i ] == aNamespaceID ) { isInstruction = true ; break ; } } if ( mEmbedStatus == eNeedEmbed ) { if ( aIDOffset >= 0 && aAttributes [ aIDOffset ] . mValue . Equals ( mTarget ) ) { mEmbedStatus = eInEmbed ; } } const txElementHandler * handler ; do { handler = isInstruction ? mHandlerTable -> find ( aNamespaceID , aLocalName ) : mHandlerTable -> mLREHandler ; rv = ( handler -> mStartFunction ) ( aNamespaceID , aLocalName , aPrefix , aAttributes , aAttrCount , * this ) ; } while ( rv == NS_XSLT_GET_NEW_HANDLER ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! fcp ( ) ) { for ( i = 0 ; i < aAttrCount ; ++ i ) { txStylesheetAttr & attr = aAttributes [ i ] ; if ( attr . mLocalName && ( attr . mNamespaceID == kNameSpaceID_XSLT || ( aNamespaceID == kNameSpaceID_XSLT && attr . mNamespaceID == kNameSpaceID_None ) ) ) { return NS_ERROR_XSLT_PARSE_FAILURE ; } } } rv = pushPtr ( const_cast < txElementHandler * > ( handler ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; mElementContext -> mDepth ++ ; return NS_OK ; }
void CodeStatistics :: ReportCodeStatistics ( Isolate * isolate ) { int * code_kind_statistics = isolate -> code_kind_statistics ( ) ; PrintF ( "\n   Code kind histograms: \n" ) ; for ( int i = 0 ; i < AbstractCode :: NUMBER_OF_KINDS ; i ++ ) { if ( code_kind_statistics [ i ] > 0 ) { PrintF ( "     %-20s: %10d bytes\n" , AbstractCode :: Kind2String ( static_cast < AbstractCode :: Kind > ( i ) ) , code_kind_statistics [ i ] ) ; } } PrintF ( "\n" ) ; if ( isolate -> code_and_metadata_size ( ) > 0 ) { PrintF ( "Code size including metadata    : %10d bytes\n" , isolate -> code_and_metadata_size ( ) ) ; } if ( isolate -> bytecode_and_metadata_size ( ) > 0 ) { PrintF ( "Bytecode size including metadata: %10d bytes\n" , isolate -> bytecode_and_metadata_size ( ) ) ; } CommentStatistic * comments_statistics = isolate -> paged_space_comments_statistics ( ) ; PrintF ( "Code comment statistics (\"   [ comment-txt   :    size/   " "count  (average)\"):\n" ) ; for ( int i = 0 ; i <= CommentStatistic :: kMaxComments ; i ++ ) { const CommentStatistic & cs = comments_statistics [ i ] ; if ( cs . size > 0 ) { PrintF ( "   %-30s: %10d/%6d     (%d)\n" , cs . comment , cs . size , cs . count , cs . size / cs . count ) ; } } PrintF ( "\n" ) ; }
static void validate_dex_header ( const dex_header * dh , size_t dexsize , int support_dex_version ) { bool supported = false ; switch ( support_dex_version ) { case 38 : supported = supported || ! memcmp ( dh -> magic , DEX_HEADER_DEXMAGIC_V38 , sizeof ( dh -> magic ) ) ; FALLTHROUGH_INTENDED ; case 37 : supported = supported || ! memcmp ( dh -> magic , DEX_HEADER_DEXMAGIC_V37 , sizeof ( dh -> magic ) ) ; FALLTHROUGH_INTENDED ; case 35 : supported = supported || ! memcmp ( dh -> magic , DEX_HEADER_DEXMAGIC_V35 , sizeof ( dh -> magic ) ) ; break ; default : not_reached_log ( "Unrecognized support_dex_version %d\n" , support_dex_version ) ; } always_assert_log ( supported , "Bad dex magic %s for support_dex_version %d\n" , dh -> magic , support_dex_version ) ; always_assert_log ( dh -> file_size == dexsize , "Reported size in header (%zu) does not match file size (%u)\n" , dexsize , dh -> file_size ) ; auto off = ( uint64_t ) dh -> class_defs_off ; auto limit = off + dh -> class_defs_size * sizeof ( dex_class_def ) ; always_assert_log ( off < dexsize , "class_defs_off out of range" ) ; always_assert_log ( limit <= dexsize , "invalid class_defs_size" ) ; }
static void _begin_draw_state ( cairo_d2d_surface_t * surface ) { if ( ! surface -> isDrawing ) { surface -> rt -> BeginDraw ( ) ; surface -> isDrawing = true ; } }
nsComboboxControlFrame :: GetRollupWidget ( ) { nsIFrame * listFrame = do_QueryFrame ( mListControlFrame ) ; if ( ! listFrame ) return nullptr ; nsView * view = listFrame -> GetView ( ) ; MOZ_ASSERT ( view ) ; return view -> GetWidget ( ) ; }
int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) { void * * ptrptr = ptr ; * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; if ( ! * ptrptr && ! ( nmemb && size ) ) return AVERROR ( ENOMEM ) ; return 0 ; }
long oggpack_look ( oggpack_buffer * b , int bits ) { unsigned long ret ; unsigned long m = mask [ bits ] ; bits += b -> endbit ; if ( b -> endbyte + 4 >= b -> storage ) { if ( b -> endbyte * 8 + bits > b -> storage * 8 ) return ( - 1 ) ; } ret = b -> ptr [ 0 ] > > b -> endbit ; if ( bits > 8 ) { ret |= b -> ptr [ 1 ] < < ( 8 - b -> endbit ) ; if ( bits > 16 ) { ret |= b -> ptr [ 2 ] < < ( 16 - b -> endbit ) ; if ( bits > 24 ) { ret |= b -> ptr [ 3 ] < < ( 24 - b -> endbit ) ; if ( bits > 32 && b -> endbit ) ret |= b -> ptr [ 4 ] < < ( 32 - b -> endbit ) ; } } } return ( m & ret ) ; }
Return < void > StreamOut :: prepareForWriting ( uint32_t frameSize , uint32_t framesCount , prepareForWriting_cb _hidl_cb ) { status_t status ; ThreadInfo threadInfo = { 0 , 0 } ; auto sendError = [ & threadInfo , & _hidl_cb ] ( Result result ) { _hidl_cb ( result , CommandMQ :: Descriptor ( ) , DataMQ :: Descriptor ( ) , StatusMQ :: Descriptor ( ) , threadInfo ) ; } ; if ( mDataMQ ) { ALOGE ( "the client attempts to call prepareForWriting twice" ) ; sendError ( Result :: INVALID_STATE ) ; return Void ( ) ; } std :: unique_ptr < CommandMQ > tempCommandMQ ( new CommandMQ ( 1 ) ) ; if ( frameSize == 0 || framesCount == 0 ) { ALOGE ( "Null frameSize (%u) or framesCount (%u)" , frameSize , framesCount ) ; sendError ( Result :: INVALID_ARGUMENTS ) ; return Void ( ) ; } if ( frameSize > Stream :: MAX_BUFFER_SIZE / framesCount ) { ALOGE ( "Buffer too big: %u*%u bytes > MAX_BUFFER_SIZE (%u)" , frameSize , framesCount , Stream :: MAX_BUFFER_SIZE ) ; sendError ( Result :: INVALID_ARGUMENTS ) ; return Void ( ) ; } std :: unique_ptr < DataMQ > tempDataMQ ( new DataMQ ( frameSize * framesCount , true ) ) ; std :: unique_ptr < StatusMQ > tempStatusMQ ( new StatusMQ ( 1 ) ) ; if ( ! tempCommandMQ -> isValid ( ) || ! tempDataMQ -> isValid ( ) || ! tempStatusMQ -> isValid ( ) ) { ALOGE_IF ( ! tempCommandMQ -> isValid ( ) , "command MQ is invalid" ) ; ALOGE_IF ( ! tempDataMQ -> isValid ( ) , "data MQ is invalid" ) ; ALOGE_IF ( ! tempStatusMQ -> isValid ( ) , "status MQ is invalid" ) ; sendError ( Result :: INVALID_ARGUMENTS ) ; return Void ( ) ; } EventFlag * tempRawEfGroup { } ; status = EventFlag :: createEventFlag ( tempDataMQ -> getEventFlagWord ( ) , & tempRawEfGroup ) ; std :: unique_ptr < EventFlag , void ( * ) ( EventFlag * ) > tempElfGroup ( tempRawEfGroup , [ ] ( auto * ef ) { EventFlag :: deleteEventFlag ( & ef ) ; } ) ; if ( status != OK || ! tempElfGroup ) { ALOGE ( "failed creating event flag for data MQ: %s" , strerror ( - status ) ) ; sendError ( Result :: INVALID_ARGUMENTS ) ; return Void ( ) ; } auto tempWriteThread = std :: make_unique < WriteThread > ( & mStopWriteThread , mStream , tempCommandMQ . get ( ) , tempDataMQ . get ( ) , tempStatusMQ . get ( ) , tempElfGroup . get ( ) ) ; if ( ! tempWriteThread -> init ( ) ) { ALOGW ( "failed to start writer thread: %s" , strerror ( - status ) ) ; sendError ( Result :: INVALID_ARGUMENTS ) ; return Void ( ) ; } status = tempWriteThread -> run ( "writer" , PRIORITY_URGENT_AUDIO ) ; if ( status != OK ) { ALOGW ( "failed to start writer thread: %s" , strerror ( - status ) ) ; sendError ( Result :: INVALID_ARGUMENTS ) ; return Void ( ) ; } mCommandMQ = std :: move ( tempCommandMQ ) ; mDataMQ = std :: move ( tempDataMQ ) ; mStatusMQ = std :: move ( tempStatusMQ ) ; mWriteThread = tempWriteThread . release ( ) ; mEfGroup = tempElfGroup . release ( ) ; threadInfo . pid = getpid ( ) ; threadInfo . tid = mWriteThread -> getTid ( ) ; _hidl_cb ( Result :: OK , * mCommandMQ -> getDesc ( ) , * mDataMQ -> getDesc ( ) , * mStatusMQ -> getDesc ( ) , threadInfo ) ; return Void ( ) ; }
WebGLContext :: CompressedTexSubImage2D ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLsizei width , GLsizei height , GLenum format , const ArrayBufferView & view ) { if ( IsContextLost ( ) ) return ; const WebGLTexImageFunc func = WebGLTexImageFunc :: CompTexSubImage ; if ( ! ValidateTexImage ( 2 , target , level , format , xoffset , yoffset , 0 , width , height , 0 , 0 , format , LOCAL_GL_UNSIGNED_BYTE , func ) ) { return ; } WebGLTexture * tex = activeBoundTextureForTarget ( target ) ; MOZ_ASSERT ( tex ) ; WebGLTexture :: ImageInfo & levelInfo = tex -> ImageInfoAt ( target , level ) ; uint32_t byteLength = view . Length ( ) ; if ( ! ValidateCompTexImageDataSize ( target , format , width , height , byteLength , func ) ) return ; if ( ! ValidateCompTexImageSize ( target , level , format , xoffset , yoffset , width , height , levelInfo . Width ( ) , levelInfo . Height ( ) , func ) ) { return ; } if ( levelInfo . HasUninitializedImageData ( ) ) tex -> DoDeferredImageInitialization ( target , level ) ; MakeContextCurrent ( ) ; gl -> fCompressedTexSubImage2D ( target , level , xoffset , yoffset , width , height , format , byteLength , view . Data ( ) ) ; }
void LiveObjectVisitor :: VisitGreyObjectsNoFail ( MemoryChunk * chunk , MarkingState * marking_state , Visitor * visitor , IterationMode iteration_mode ) { TRACE_EVENT0 ( TRACE_DISABLED_BY_DEFAULT ( "v8.gc" ) , "LiveObjectVisitor::VisitGreyObjectsNoFail" ) ; for ( auto object_and_size : LiveObjectRange < kGreyObjects > ( chunk , marking_state -> bitmap ( chunk ) ) ) { HeapObject * const object = object_and_size . first ; DCHECK ( marking_state -> IsGrey ( object ) ) ; const bool success = visitor -> Visit ( object , object_and_size . second ) ; USE ( success ) ; DCHECK ( success ) ; } if ( iteration_mode == kClearMarkbits ) { marking_state -> ClearLiveness ( chunk ) ; } }
IDBRequest :: NotifyHelperCompleted ( HelperBase * aHelper ) { NS_ASSERTION ( NS_IsMainThread ( ) , "Wrong thread!" ) ; NS_ASSERTION ( ! mHaveResultOrErrorCode , "Already called!" ) ; NS_ASSERTION ( ! PreservingWrapper ( ) , "Already rooted?!" ) ; NS_ASSERTION ( JSVAL_IS_VOID ( mResultVal ) , "Should be undefined!" ) ; if ( NS_FAILED ( CheckInnerWindowCorrectness ( ) ) ) { return NS_OK ; } mHaveResultOrErrorCode = true ; nsresult rv = aHelper -> GetResultCode ( ) ; if ( NS_FAILED ( rv ) ) { SetError ( rv ) ; return NS_OK ; } JSContext * cx = GetJSContext ( ) ; if ( ! cx ) { NS_WARNING ( "Failed to get safe JSContext!" ) ; rv = NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ; SetError ( rv ) ; return rv ; } JSObject * global = GetParentObject ( ) ; NS_ASSERTION ( global , "This should never be null!" ) ; JSAutoRequest ar ( cx ) ; JSAutoEnterCompartment ac ; if ( ac . enter ( cx , global ) ) { RootResultVal ( ) ; rv = aHelper -> GetSuccessResult ( cx , & mResultVal ) ; if ( NS_FAILED ( rv ) ) { NS_WARNING ( "GetSuccessResult failed!" ) ; } } else { NS_WARNING ( "Failed to enter correct compartment!" ) ; rv = NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR ; } if ( NS_SUCCEEDED ( rv ) ) { mError = nsnull ; } else { SetError ( rv ) ; mResultVal = JSVAL_VOID ; } return rv ; }
nsPkcs11 :: Deletemodule ( const nsAString & aModuleName , PRInt32 * aReturn ) { nsNSSShutDownPreventionLock locker ; nsresult rv ; nsString errorMessage ; nsCOMPtr < nsINSSComponent > nssComponent ( do_GetService ( kNSSComponentCID , & rv ) ) ; if ( aModuleName . IsEmpty ( ) ) { * aReturn = JS_ERR_BAD_MODULE_NAME ; nssComponent -> GetPIPNSSBundleString ( "DelModuleBadName" , errorMessage ) ; alertUser ( errorMessage . get ( ) ) ; return NS_OK ; } nsString final ; nsAutoString temp ; nssComponent -> GetPIPNSSBundleString ( "DelModuleWarning" , final ) ; final . Append ( NS_LITERAL_STRING ( "\n" ) . get ( ) ) ; PRUnichar * tempUni = ToNewUnicode ( aModuleName ) ; const PRUnichar * formatStrings [ 1 ] = { tempUni } ; rv = nssComponent -> PIPBundleFormatStringFromName ( "AddModuleName" , formatStrings , 1 , temp ) ; nsMemory :: Free ( tempUni ) ; final . Append ( temp ) ; if ( ! confirm_user ( final . get ( ) ) ) { * aReturn = JS_ERR_USER_CANCEL_ACTION ; return NS_OK ; } char * modName = ToNewCString ( aModuleName ) ; PRInt32 modType ; SECStatus srv = SECMOD_DeleteModule ( modName , & modType ) ; if ( srv == SECSuccess ) { SECMODModule * module = SECMOD_FindModule ( modName ) ; if ( module ) { nssComponent -> ShutdownSmartCardThread ( module ) ; SECMOD_DestroyModule ( module ) ; } if ( modType == SECMOD_EXTERNAL ) { nssComponent -> GetPIPNSSBundleString ( "DelModuleExtSuccess" , errorMessage ) ; * aReturn = JS_OK_DEL_EXTERNAL_MOD ; } else { nssComponent -> GetPIPNSSBundleString ( "DelModuleIntSuccess" , errorMessage ) ; * aReturn = JS_OK_DEL_INTERNAL_MOD ; } } else { * aReturn = JS_ERR_DEL_MOD ; nssComponent -> GetPIPNSSBundleString ( "DelModuleError" , errorMessage ) ; } alertUser ( errorMessage . get ( ) ) ; return NS_OK ; }
BUILTIN ( ArrayConcat ) { HandleScope scope ( isolate ) ; Handle < Object > receiver = args . receiver ( ) ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , receiver , Object :: ToObject ( isolate , args . receiver ( ) , "Array.prototype.concat" ) ) ; args [ 0 ] = * receiver ; Handle < JSArray > result_array ; if ( V8_LIKELY ( receiver -> IsJSArray ( ) && Handle < JSArray > :: cast ( receiver ) -> HasArrayPrototype ( isolate ) && isolate -> IsArraySpeciesLookupChainIntact ( ) ) ) { if ( Fast_ArrayConcat ( isolate , & args ) . ToHandle ( & result_array ) ) { return * result_array ; } if ( isolate -> has_pending_exception ( ) ) return ReadOnlyRoots ( isolate ) . exception ( ) ; } Handle < Object > species ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , species , Object :: ArraySpeciesConstructor ( isolate , receiver ) ) ; if ( * species == * isolate -> array_function ( ) ) { if ( Fast_ArrayConcat ( isolate , & args ) . ToHandle ( & result_array ) ) { return * result_array ; } if ( isolate -> has_pending_exception ( ) ) return ReadOnlyRoots ( isolate ) . exception ( ) ; } return Slow_ArrayConcat ( & args , species , isolate ) ; }
nsWindow :: SetCursor ( imgIContainer * aCursor , PRUint32 aHotspotX , PRUint32 aHotspotY ) { if ( ! mContainer && mDrawingarea ) { GtkWidget * widget = get_gtk_widget_for_gdk_window ( mDrawingarea -> inner_window ) ; nsWindow * window = get_window_for_gtk_widget ( widget ) ; return window -> SetCursor ( aCursor , aHotspotX , aHotspotY ) ; } if ( ! sPixbufCursorChecked ) { PRLibrary * lib ; _gdk_cursor_new_from_pixbuf = ( _gdk_cursor_new_from_pixbuf_fn ) PR_FindFunctionSymbolAndLibrary ( "gdk_cursor_new_from_pixbuf" , & lib ) ; _gdk_display_get_default = ( _gdk_display_get_default_fn ) PR_FindFunctionSymbolAndLibrary ( "gdk_display_get_default" , & lib ) ; sPixbufCursorChecked = PR_TRUE ; } mCursor = nsCursor ( - 1 ) ; nsCOMPtr < gfxIImageFrame > frame ; aCursor -> GetFrameAt ( 0 , getter_AddRefs ( frame ) ) ; if ( ! frame ) return NS_ERROR_NOT_AVAILABLE ; nsCOMPtr < nsIImage > img ( do_GetInterface ( frame ) ) ; if ( ! img ) return NS_ERROR_NOT_AVAILABLE ; GdkPixbuf * pixbuf = nsImageToPixbuf :: ImageToPixbuf ( img ) ; if ( ! pixbuf ) return NS_ERROR_NOT_AVAILABLE ; if ( ! gdk_pixbuf_get_has_alpha ( pixbuf ) ) { GdkPixbuf * alphaBuf = gdk_pixbuf_add_alpha ( pixbuf , FALSE , 0 , 0 , 0 ) ; gdk_pixbuf_unref ( pixbuf ) ; if ( ! alphaBuf ) { return NS_ERROR_OUT_OF_MEMORY ; } pixbuf = alphaBuf ; } GdkCursor * cursor ; if ( ! _gdk_cursor_new_from_pixbuf || ! _gdk_display_get_default ) { int width = gdk_pixbuf_get_width ( pixbuf ) ; int height = gdk_pixbuf_get_height ( pixbuf ) ; GdkPixmap * mask = gdk_pixmap_new ( NULL , width , height , 1 ) ; if ( ! mask ) return NS_ERROR_OUT_OF_MEMORY ; PRUint8 * data = Data32BitTo1Bit ( gdk_pixbuf_get_pixels ( pixbuf ) , gdk_pixbuf_get_rowstride ( pixbuf ) , width , height ) ; if ( ! data ) { g_object_unref ( mask ) ; return NS_ERROR_OUT_OF_MEMORY ; } GdkPixmap * image = gdk_bitmap_create_from_data ( NULL , ( const gchar * ) data , width , height ) ; delete [ ] data ; if ( ! image ) { g_object_unref ( mask ) ; return NS_ERROR_OUT_OF_MEMORY ; } gdk_pixbuf_render_threshold_alpha ( pixbuf , mask , 0 , 0 , 0 , 0 , width , height , 1 ) ; GdkColor fg = { 0 , 0 , 0 , 0 } ; GdkColor bg = { 0 , 0xFFFF , 0xFFFF , 0xFFFF } ; cursor = gdk_cursor_new_from_pixmap ( image , mask , & fg , & bg , aHotspotX , aHotspotY ) ; g_object_unref ( image ) ; g_object_unref ( mask ) ; } else { cursor = _gdk_cursor_new_from_pixbuf ( _gdk_display_get_default ( ) , pixbuf , aHotspotX , aHotspotY ) ; } gdk_pixbuf_unref ( pixbuf ) ; nsresult rv = NS_ERROR_OUT_OF_MEMORY ; if ( cursor ) { if ( mContainer ) { gdk_window_set_cursor ( GTK_WIDGET ( mContainer ) -> window , cursor ) ; XFlush ( GDK_DISPLAY ( ) ) ; rv = NS_OK ; } gdk_cursor_unref ( cursor ) ; } return rv ; }
void Compute ( OpKernelContext * context ) override { const Tensor & tensor_in = context -> input ( 0 ) ; const Tensor & grad_in = context -> input ( 1 ) ; const Tensor & argmax = context -> input ( 2 ) ; PoolParameters params { context , ksize_ , stride_ , padding_ , { } , FORMAT_NHWC , tensor_in . shape ( ) } ; if ( ! context -> status ( ) . ok ( ) ) { return ; } TensorShape out_shape ( { params . tensor_in_batch , params . tensor_in_rows , params . tensor_in_cols , params . depth } ) ; Tensor * grad_out = nullptr ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_output ( { 0 } , 0 , out_shape , & grad_out ) ) ; if ( out_shape . num_elements ( ) == 0 ) return ; LaunchMaxPoolingGradWithArgmax < Device , T > :: launch ( context , params , grad_in , argmax , grad_out , include_batch_in_index_ ) ; }
FrameIter :: frameSlotValue ( size_t index ) const { switch ( data_ . state_ ) { case DONE : case ASMJS : break ; case JIT : if ( data_ . jitFrames_ . isIonJS ( ) ) { jit :: SnapshotIterator si ( ionInlineFrames_ . snapshotIterator ( ) ) ; index += ionInlineFrames_ . script ( ) -> nfixed ( ) ; return si . maybeReadAllocByIndex ( index ) ; } index += data_ . jitFrames_ . script ( ) -> nfixed ( ) ; return * data_ . jitFrames_ . baselineFrame ( ) -> valueSlot ( index ) ; case INTERP : return interpFrame ( ) -> base ( ) [ index ] ; } MOZ_CRASH ( "Unexpected state" ) ; }
INT FDK_get ( HANDLE_FDK_BITBUF hBitBuf , const UINT numberOfBits ) { UINT byteOffset = hBitBuf -> BitNdx > > 3 ; UINT bitOffset = hBitBuf -> BitNdx & 0x07 ; hBitBuf -> BitNdx = ( hBitBuf -> BitNdx + numberOfBits ) & ( hBitBuf -> bufBits - 1 ) ; hBitBuf -> BitCnt += numberOfBits ; hBitBuf -> ValidBits -= numberOfBits ; UINT byteMask = hBitBuf -> bufSize - 1 ; UINT tx = ( hBitBuf -> Buffer [ byteOffset & byteMask ] < < 24 ) | ( hBitBuf -> Buffer [ ( byteOffset + 1 ) & byteMask ] < < 16 ) | ( hBitBuf -> Buffer [ ( byteOffset + 2 ) & byteMask ] < < 8 ) | hBitBuf -> Buffer [ ( byteOffset + 3 ) & byteMask ] ; if ( bitOffset ) { tx <<= bitOffset ; tx |= hBitBuf -> Buffer [ ( byteOffset + 4 ) & byteMask ] > > ( 8 - bitOffset ) ; } return ( tx > > ( 32 - numberOfBits ) ) ; }
virtual void SetUp ( ) { fwd_txfm_ = GET_PARAM ( 0 ) ; inv_txfm_ = GET_PARAM ( 1 ) ; tx_type_ = GET_PARAM ( 2 ) ; pitch_ = 8 ; fwd_txfm_ref = fht8x8_ref ; }
static int do_16x16_motion_search ( VP9_COMP * cpi , const int_mv * ref_mv , int_mv * dst_mv , int mb_row , int mb_col ) { MACROBLOCK * const x = & cpi -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; unsigned int err , tmp_err ; int_mv tmp_mv ; err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride , INT_MAX ) ; dst_mv -> as_int = 0 ; tmp_err = do_16x16_motion_iteration ( cpi , & ref_mv -> as_mv , & tmp_mv . as_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { err = tmp_err ; dst_mv -> as_int = tmp_mv . as_int ; } if ( ref_mv -> as_int ) { unsigned int tmp_err ; int_mv zero_ref_mv , tmp_mv ; zero_ref_mv . as_int = 0 ; tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv . as_mv , & tmp_mv . as_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { dst_mv -> as_int = tmp_mv . as_int ; err = tmp_err ; } } return err ; }
void Parser :: DeclareArrowFunctionFormalParameters ( ParserFormalParameters * parameters , Expression * expr , const Scanner :: Location & params_loc , Scanner :: Location * duplicate_loc , bool * ok ) { if ( expr -> IsEmptyParentheses ( ) ) return ; AddArrowFunctionFormalParameters ( parameters , expr , params_loc . end_pos , CHECK_OK_VOID ) ; if ( parameters -> arity > Code :: kMaxArguments ) { ReportMessageAt ( params_loc , MessageTemplate :: kMalformedArrowFunParamList ) ; * ok = false ; return ; } bool has_duplicate = false ; DeclareFormalParameters ( parameters -> scope , parameters -> params , parameters -> is_simple , & has_duplicate ) ; if ( has_duplicate ) { * duplicate_loc = scanner ( ) -> location ( ) ; } DCHECK_EQ ( parameters -> is_simple , parameters -> scope -> has_simple_parameters ( ) ) ; }
HeapObject * Deserializer < AllocatorT > :: GetBackReferencedObject ( int space ) { HeapObject * obj ; switch ( space ) { case LO_SPACE : obj = allocator ( ) -> GetLargeObject ( source_ . GetInt ( ) ) ; break ; case MAP_SPACE : obj = allocator ( ) -> GetMap ( source_ . GetInt ( ) ) ; break ; case RO_SPACE : { uint32_t chunk_index = source_ . GetInt ( ) ; uint32_t chunk_offset = source_ . GetInt ( ) ; if ( isolate ( ) -> heap ( ) -> deserialization_complete ( ) ) { PagedSpace * read_only_space = isolate ( ) -> heap ( ) -> read_only_space ( ) ; Page * page = read_only_space -> first_page ( ) ; for ( uint32_t i = 0 ; i < chunk_index ; ++ i ) { page = page -> next_page ( ) ; } Address address = page -> OffsetToAddress ( chunk_offset ) ; obj = HeapObject :: FromAddress ( address ) ; } else { obj = allocator ( ) -> GetObject ( static_cast < AllocationSpace > ( space ) , chunk_index , chunk_offset ) ; } break ; } default : { uint32_t chunk_index = source_ . GetInt ( ) ; uint32_t chunk_offset = source_ . GetInt ( ) ; obj = allocator ( ) -> GetObject ( static_cast < AllocationSpace > ( space ) , chunk_index , chunk_offset ) ; break ; } } if ( deserializing_user_code ( ) && obj -> IsThinString ( ) ) { obj = ThinString :: cast ( obj ) -> actual ( ) ; } hot_objects_ . Add ( obj ) ; DCHECK ( ! HasWeakHeapObjectTag ( obj ) ) ; return obj ; }
long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) { if ( shmflg & SHM_RND ) addr &= ~ ( shmlba - 1 ) ; else #ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) #endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock ; } err = - EACCES ; if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) goto out_unlock ; err = security_shm_shmat ( shp , shmaddr , shmflg ) ; if ( err ) goto out_unlock ; ipc_lock_object ( & shp -> shm_perm ) ; path = shp -> shm_file -> f_path ; path_get ( & path ) ; shp -> shm_nattch ++ ; size = i_size_read ( path . dentry -> d_inode ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; err = - ENOMEM ; sfd = kzalloc ( sizeof ( * sfd ) , GFP_KERNEL ) ; if ( ! sfd ) { path_put ( & path ) ; goto out_nattch ; } file = alloc_file ( & path , f_mode , is_file_hugepages ( shp -> shm_file ) ? & shm_file_operations_huge : & shm_file_operations ) ; err = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) { kfree ( sfd ) ; path_put ( & path ) ; goto out_nattch ; } file -> private_data = sfd ; file -> f_mapping = shp -> shm_file -> f_mapping ; sfd -> id = shp -> shm_perm . id ; sfd -> ns = get_ipc_ns ( ns ) ; sfd -> file = shp -> shm_file ; sfd -> vm_ops = NULL ; err = security_mmap_file ( file , prot , flags ) ; if ( err ) goto out_fput ; down_write ( & current -> mm -> mmap_sem ) ; if ( addr && ! ( shmflg & SHM_REMAP ) ) { err = - EINVAL ; if ( find_vma_intersection ( current -> mm , addr , addr + size ) ) goto invalid ; if ( addr < current -> mm -> start_stack && addr > current -> mm -> start_stack - size - PAGE_SIZE * 5 ) goto invalid ; } addr = do_mmap_pgoff ( file , addr , size , prot , flags , 0 , & populate ) ; * raddr = addr ; err = 0 ; if ( IS_ERR_VALUE ( addr ) ) err = ( long ) addr ; invalid : up_write ( & current -> mm -> mmap_sem ) ; if ( populate ) mm_populate ( addr , populate ) ; out_fput : fput ( file ) ; out_nattch : down_write ( & shm_ids ( ns ) . rwsem ) ; shp = shm_lock ( ns , shmid ) ; BUG_ON ( IS_ERR ( shp ) ) ; shp -> shm_nattch -- ; if ( shm_may_destroy ( ns , shp ) ) shm_destroy ( ns , shp ) ; else shm_unlock ( shp ) ; up_write ( & shm_ids ( ns ) . rwsem ) ; return err ; out_unlock : rcu_read_unlock ( ) ; out : return err ; }
void BytecodeGenerator :: VisitTryFinallyStatement ( TryFinallyStatement * stmt ) { TryFinallyBuilder try_control_builder ( builder ( ) , block_coverage_builder_ , stmt , catch_prediction ( ) ) ; Register token = register_allocator ( ) -> NewRegister ( ) ; Register result = register_allocator ( ) -> NewRegister ( ) ; ControlScope :: DeferredCommands commands ( this , token , result ) ; Register context = register_allocator ( ) -> NewRegister ( ) ; builder ( ) -> MoveRegister ( Register :: current_context ( ) , context ) ; try_control_builder . BeginTry ( context ) ; { ControlScopeForTryFinally scope ( this , & try_control_builder , & commands ) ; Visit ( stmt -> try_block ( ) ) ; } try_control_builder . EndTry ( ) ; commands . RecordFallThroughPath ( ) ; try_control_builder . LeaveTry ( ) ; try_control_builder . BeginHandler ( ) ; commands . RecordHandlerReThrowPath ( ) ; try_control_builder . BeginFinally ( ) ; Register message = context ; builder ( ) -> LoadTheHole ( ) . SetPendingMessage ( ) . StoreAccumulatorInRegister ( message ) ; Visit ( stmt -> finally_block ( ) ) ; try_control_builder . EndFinally ( ) ; builder ( ) -> LoadAccumulatorWithRegister ( message ) . SetPendingMessage ( ) ; commands . ApplyDeferredCommands ( ) ; }
NS_IMPL_CYCLE_COLLECTION ( nsFormFillController , mController , mLoginManager , mFocusedPopup , mDocShells , mPopups , mLastSearchResult , mLastListener , mLastFormAutoComplete ) NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION ( nsFormFillController ) NS_INTERFACE_MAP_ENTRY_AMBIGUOUS ( nsISupports , nsIFormFillController ) NS_INTERFACE_MAP_ENTRY ( nsIFormFillController ) NS_INTERFACE_MAP_ENTRY ( nsIAutoCompleteInput ) NS_INTERFACE_MAP_ENTRY ( nsIAutoCompleteSearch ) NS_INTERFACE_MAP_ENTRY ( nsIDOMEventListener ) NS_INTERFACE_MAP_ENTRY ( nsIFormAutoCompleteObserver ) NS_INTERFACE_MAP_ENTRY ( nsIMutationObserver ) NS_INTERFACE_MAP_END NS_IMPL_CYCLE_COLLECTING_ADDREF ( nsFormFillController ) NS_IMPL_CYCLE_COLLECTING_RELEASE ( nsFormFillController ) nsFormFillController :: nsFormFillController ( ) : mFocusedInput ( nullptr ) , mFocusedInputNode ( nullptr ) , mListNode ( nullptr ) , mTimeout ( 50 ) , mMinResultsForPopup ( 1 ) , mMaxRows ( 0 ) , mDisableAutoComplete ( false ) , mCompleteDefaultIndex ( false ) , mCompleteSelectedIndex ( false ) , mForceComplete ( false ) , mSuppressOnInput ( false ) { mController = do_GetService ( "@mozilla.org/autocomplete/controller;1" ) ; }
void MetaData :: typed_data :: allocateStorage ( size_t size ) { mSize = size ; if ( usesReservoir ( ) ) { return ; } u . ext_data = malloc ( mSize ) ; }
TfLiteStatus ReverseSequenceHelper ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteTensor * seq_lengths_tensor = GetInput ( context , node , kSeqLengthsTensor ) ; switch ( seq_lengths_tensor -> type ) { case kTfLiteInt32 : { return ReverseSequenceImpl < T , int32_t > ( context , node ) ; } case kTfLiteInt64 : { return ReverseSequenceImpl < T , int64_t > ( context , node ) ; } default : { context -> ReportError ( context , "Seq_lengths type '%s' is not supported by reverse_sequence." , TfLiteTypeGetName ( seq_lengths_tensor -> type ) ) ; return kTfLiteError ; } } return kTfLiteOk ; }
mptctl_gettargetinfo ( unsigned long arg ) { struct mpt_ioctl_targetinfo __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_targetinfo karg ; MPT_ADAPTER * ioc ; VirtDevice * vdevice ; char * pmem ; int * pdata ; int iocnum ; int numDevices = 0 ; int lun ; int maxWordsLeft ; int numBytes ; u8 port ; struct scsi_device * sdev ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_targetinfo ) ) ) { printk ( KERN_ERR MYNAM "%s@%d::mptctl_gettargetinfo - " "Unable to read in mpt_ioctl_targetinfo struct @ %p\n" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM "%s::mptctl_gettargetinfo() @%d - ioc%d not found!\n" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT "mptctl_gettargetinfo called.\n" , ioc -> name ) ) ; numBytes = karg . hdr . maxDataSize - sizeof ( mpt_ioctl_header ) ; maxWordsLeft = numBytes / sizeof ( int ) ; port = karg . hdr . port ; if ( maxWordsLeft <= 0 ) { printk ( MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo() - no memory available!\n" , ioc -> name , __FILE__ , __LINE__ ) ; return - ENOMEM ; } pmem = kzalloc ( numBytes , GFP_KERNEL ) ; if ( ! pmem ) { printk ( MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo() - no memory available!\n" , ioc -> name , __FILE__ , __LINE__ ) ; return - ENOMEM ; } pdata = ( int * ) pmem ; if ( ioc -> sh ) { shost_for_each_device ( sdev , ioc -> sh ) { if ( ! maxWordsLeft ) continue ; vdevice = sdev -> hostdata ; if ( vdevice == NULL || vdevice -> vtarget == NULL ) continue ; if ( vdevice -> vtarget -> tflags & MPT_TARGET_FLAGS_RAID_COMPONENT ) continue ; lun = ( vdevice -> vtarget -> raidVolume ) ? 0x80 : vdevice -> lun ; * pdata = ( ( ( u8 ) lun < < 16 ) + ( vdevice -> vtarget -> channel < < 8 ) + ( vdevice -> vtarget -> id ) ) ; pdata ++ ; numDevices ++ ; -- maxWordsLeft ; } } karg . numDevices = numDevices ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( struct mpt_ioctl_targetinfo ) ) ) { printk ( MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo - " "Unable to write out mpt_ioctl_targetinfo struct @ %p\n" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; kfree ( pmem ) ; return - EFAULT ; } if ( copy_to_user ( uarg -> targetInfo , pmem , numBytes ) ) { printk ( MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo - " "Unable to write out mpt_ioctl_targetinfo struct @ %p\n" , ioc -> name , __FILE__ , __LINE__ , pdata ) ; kfree ( pmem ) ; return - EFAULT ; } kfree ( pmem ) ; return 0 ; }
bool __net_get_random_once ( void * buf , int nbytes , bool * done , struct static_key * done_key ) { static DEFINE_SPINLOCK ( lock ) ; unsigned long flags ; spin_lock_irqsave ( & lock , flags ) ; if ( * done ) { spin_unlock_irqrestore ( & lock , flags ) ; return false ; } get_random_bytes ( buf , nbytes ) ; * done = true ; spin_unlock_irqrestore ( & lock , flags ) ; __net_random_once_disable_jump ( done_key ) ; return true ; }
long fuse_do_ioctl ( struct file * file , unsigned int cmd , unsigned long arg , unsigned int flags ) { struct fuse_file * ff = file -> private_data ; struct fuse_conn * fc = ff -> fc ; struct fuse_ioctl_in inarg = { . fh = ff -> fh , . cmd = cmd , . arg = arg , . flags = flags } ; struct fuse_ioctl_out outarg ; struct fuse_req * req = NULL ; struct page * * pages = NULL ; struct page * iov_page = NULL ; struct iovec * in_iov = NULL , * out_iov = NULL ; unsigned int in_iovs = 0 , out_iovs = 0 , num_pages = 0 , max_pages ; size_t in_size , out_size , transferred ; int err ; BUILD_BUG_ON ( sizeof ( struct iovec ) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE ) ; err = - ENOMEM ; pages = kzalloc ( sizeof ( pages [ 0 ] ) * FUSE_MAX_PAGES_PER_REQ , GFP_KERNEL ) ; iov_page = alloc_page ( GFP_KERNEL ) ; if ( ! pages || ! iov_page ) goto out ; if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) ) { struct iovec * iov = page_address ( iov_page ) ; iov -> iov_base = ( void __user * ) arg ; iov -> iov_len = _IOC_SIZE ( cmd ) ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { in_iov = iov ; in_iovs = 1 ; } if ( _IOC_DIR ( cmd ) & _IOC_READ ) { out_iov = iov ; out_iovs = 1 ; } } retry : inarg . in_size = in_size = iov_length ( in_iov , in_iovs ) ; inarg . out_size = out_size = iov_length ( out_iov , out_iovs ) ; out_size = max_t ( size_t , out_size , PAGE_SIZE ) ; max_pages = DIV_ROUND_UP ( max ( in_size , out_size ) , PAGE_SIZE ) ; err = - ENOMEM ; if ( max_pages > FUSE_MAX_PAGES_PER_REQ ) goto out ; while ( num_pages < max_pages ) { pages [ num_pages ] = alloc_page ( GFP_KERNEL | __GFP_HIGHMEM ) ; if ( ! pages [ num_pages ] ) goto out ; num_pages ++ ; } req = fuse_get_req ( fc ) ; if ( IS_ERR ( req ) ) { err = PTR_ERR ( req ) ; req = NULL ; goto out ; } memcpy ( req -> pages , pages , sizeof ( req -> pages [ 0 ] ) * num_pages ) ; req -> num_pages = num_pages ; req -> in . h . opcode = FUSE_IOCTL ; req -> in . h . nodeid = ff -> nodeid ; req -> in . numargs = 1 ; req -> in . args [ 0 ] . size = sizeof ( inarg ) ; req -> in . args [ 0 ] . value = & inarg ; if ( in_size ) { req -> in . numargs ++ ; req -> in . args [ 1 ] . size = in_size ; req -> in . argpages = 1 ; err = fuse_ioctl_copy_user ( pages , in_iov , in_iovs , in_size , false ) ; if ( err ) goto out ; } req -> out . numargs = 2 ; req -> out . args [ 0 ] . size = sizeof ( outarg ) ; req -> out . args [ 0 ] . value = & outarg ; req -> out . args [ 1 ] . size = out_size ; req -> out . argpages = 1 ; req -> out . argvar = 1 ; fuse_request_send ( fc , req ) ; err = req -> out . h . error ; transferred = req -> out . args [ 1 ] . size ; fuse_put_request ( fc , req ) ; req = NULL ; if ( err ) goto out ; if ( outarg . flags & FUSE_IOCTL_RETRY ) { char * vaddr ; err = - EIO ; if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) ) goto out ; in_iovs = outarg . in_iovs ; out_iovs = outarg . out_iovs ; err = - ENOMEM ; if ( in_iovs > FUSE_IOCTL_MAX_IOV || out_iovs > FUSE_IOCTL_MAX_IOV || in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV ) goto out ; vaddr = kmap_atomic ( pages [ 0 ] , KM_USER0 ) ; err = fuse_copy_ioctl_iovec ( page_address ( iov_page ) , vaddr , transferred , in_iovs + out_iovs , ( flags & FUSE_IOCTL_COMPAT ) != 0 ) ; kunmap_atomic ( vaddr , KM_USER0 ) ; if ( err ) goto out ; in_iov = page_address ( iov_page ) ; out_iov = in_iov + in_iovs ; goto retry ; } err = - EIO ; if ( transferred > inarg . out_size ) goto out ; err = fuse_ioctl_copy_user ( pages , out_iov , out_iovs , transferred , true ) ; out : if ( req ) fuse_put_request ( fc , req ) ; if ( iov_page ) __free_page ( iov_page ) ; while ( num_pages ) __free_page ( pages [ -- num_pages ] ) ; kfree ( pages ) ; return err ? err : outarg . result ; }
ObjectRef :: ObjectRef ( JSHeapBroker * broker , Handle < Object > object ) { switch ( broker -> mode ( ) ) { case JSHeapBroker :: kSerialized : data_ = FLAG_strict_heap_broker ? broker -> GetData ( object ) : broker -> GetOrCreateData ( object ) ; break ; case JSHeapBroker :: kSerializing : data_ = broker -> GetOrCreateData ( object ) ; break ; case JSHeapBroker :: kDisabled : data_ = broker -> GetData ( object ) ; if ( data_ == nullptr ) { AllowHandleDereference handle_dereference ; data_ = new ( broker -> zone ( ) ) ObjectData ( broker , object , object -> IsSmi ( ) ) ; } break ; } CHECK_NOT_NULL ( data_ ) ; }
nsContentUtils :: SetDataTransferInEvent ( nsDragEvent * aDragEvent ) { if ( aDragEvent -> dataTransfer || ! aDragEvent -> mFlags . mIsTrusted ) return NS_OK ; NS_ASSERTION ( aDragEvent -> message != NS_DRAGDROP_GESTURE && aDragEvent -> message != NS_DRAGDROP_START , "draggesture event created without a dataTransfer" ) ; nsCOMPtr < nsIDragSession > dragSession = GetDragSession ( ) ; NS_ENSURE_TRUE ( dragSession , NS_OK ) ; nsCOMPtr < nsIDOMDataTransfer > initialDataTransfer ; dragSession -> GetDataTransfer ( getter_AddRefs ( initialDataTransfer ) ) ; if ( ! initialDataTransfer ) { initialDataTransfer = new nsDOMDataTransfer ( aDragEvent -> message , true ) ; NS_ENSURE_TRUE ( initialDataTransfer , NS_ERROR_OUT_OF_MEMORY ) ; dragSession -> SetDataTransfer ( initialDataTransfer ) ; } bool isCrossDomainSubFrameDrop = false ; if ( aDragEvent -> message == NS_DRAGDROP_DROP || aDragEvent -> message == NS_DRAGDROP_DRAGDROP ) { isCrossDomainSubFrameDrop = CheckForSubFrameDrop ( dragSession , aDragEvent ) ; } initialDataTransfer -> Clone ( aDragEvent -> message , aDragEvent -> userCancelled , isCrossDomainSubFrameDrop , getter_AddRefs ( aDragEvent -> dataTransfer ) ) ; NS_ENSURE_TRUE ( aDragEvent -> dataTransfer , NS_ERROR_OUT_OF_MEMORY ) ; if ( aDragEvent -> message == NS_DRAGDROP_ENTER || aDragEvent -> message == NS_DRAGDROP_OVER ) { uint32_t action , effectAllowed ; dragSession -> GetDragAction ( & action ) ; aDragEvent -> dataTransfer -> GetEffectAllowedInt ( & effectAllowed ) ; aDragEvent -> dataTransfer -> SetDropEffectInt ( FilterDropEffect ( action , effectAllowed ) ) ; } else if ( aDragEvent -> message == NS_DRAGDROP_DROP || aDragEvent -> message == NS_DRAGDROP_DRAGDROP || aDragEvent -> message == NS_DRAGDROP_END ) { uint32_t dropEffect ; initialDataTransfer -> GetDropEffectInt ( & dropEffect ) ; aDragEvent -> dataTransfer -> SetDropEffectInt ( dropEffect ) ; } return NS_OK ; }
static void copyLine ( Color8888 * dst , const unsigned char * src , const ColorMapObject * cmap , int transparent , int width ) { for ( ; width > 0 ; width -- , src ++ , dst ++ ) { if ( * src != transparent ) { * dst = gifColorToColor8888 ( cmap -> Colors [ * src ] ) ; } } }
BufferMeta ( size_t size , OMX_U32 portIndex ) : mSize ( size ) , mIsBackup ( false ) , mPortIndex ( portIndex ) { }
static void print_maps ( struct pid_info_t * info ) { FILE * maps ; size_t offset ; char device [ 10 ] ; long int inode ; char file [ PATH_MAX ] ; strlcat ( info -> path , "maps" , sizeof ( info -> path ) ) ; maps = fopen ( info -> path , "r" ) ; if ( ! maps ) goto out ; while ( fscanf ( maps , "%*x-%*x %*s %zx %s %ld %s\n" , & offset , device , & inode , file ) == 4 ) { if ( inode == 0 || ! strcmp ( device , "00:00" ) ) continue ; printf ( "%-9s %5d %10s %4s %9s %18s %9zd %10ld %s\n" , info -> cmdline , info -> pid , info -> user , "mem" , "???" , device , offset , inode , file ) ; } fclose ( maps ) ; out : info -> path [ info -> parent_length ] = '\0' ; }
Type Typer :: Visitor :: TypeInductionVariablePhi ( Node * node ) { int arity = NodeProperties :: GetControlInput ( node ) -> op ( ) -> ControlInputCount ( ) ; DCHECK_EQ ( IrOpcode :: kLoop , NodeProperties :: GetControlInput ( node ) -> opcode ( ) ) ; DCHECK_EQ ( 2 , NodeProperties :: GetControlInput ( node ) -> InputCount ( ) ) ; Type initial_type = Operand ( node , 0 ) ; Type increment_type = Operand ( node , 2 ) ; if ( ! initial_type . Is ( typer_ -> cache_ . kInteger ) || ! increment_type . Is ( typer_ -> cache_ . kInteger ) ) { Type type = NodeProperties :: IsTyped ( node ) ? NodeProperties :: GetType ( node ) : Type :: None ( ) ; for ( int i = 0 ; i < arity ; ++ i ) { type = Type :: Union ( type , Operand ( node , i ) , zone ( ) ) ; } return type ; } if ( initial_type . IsNone ( ) || increment_type . Is ( typer_ -> cache_ . kSingletonZero ) ) { return initial_type ; } auto res = induction_vars_ -> induction_variables ( ) . find ( node -> id ( ) ) ; DCHECK ( res != induction_vars_ -> induction_variables ( ) . end ( ) ) ; InductionVariable * induction_var = res -> second ; InductionVariable :: ArithmeticType arithmetic_type = induction_var -> Type ( ) ; double min = - V8_INFINITY ; double max = V8_INFINITY ; double increment_min ; double increment_max ; if ( arithmetic_type == InductionVariable :: ArithmeticType :: kAddition ) { increment_min = increment_type . Min ( ) ; increment_max = increment_type . Max ( ) ; } else { DCHECK_EQ ( InductionVariable :: ArithmeticType :: kSubtraction , arithmetic_type ) ; increment_min = - increment_type . Max ( ) ; increment_max = - increment_type . Min ( ) ; } if ( increment_min >= 0 ) { min = initial_type . Min ( ) ; for ( auto bound : induction_var -> upper_bounds ( ) ) { Type bound_type = TypeOrNone ( bound . bound ) ; if ( ! bound_type . Is ( typer_ -> cache_ . kInteger ) ) continue ; if ( bound_type . IsNone ( ) ) { max = initial_type . Max ( ) ; break ; } double bound_max = bound_type . Max ( ) ; if ( bound . kind == InductionVariable :: kStrict ) { bound_max -= 1 ; } max = std :: min ( max , bound_max + increment_max ) ; } max = std :: max ( max , initial_type . Max ( ) ) ; } else if ( increment_max <= 0 ) { max = initial_type . Max ( ) ; for ( auto bound : induction_var -> lower_bounds ( ) ) { Type bound_type = TypeOrNone ( bound . bound ) ; if ( ! bound_type . Is ( typer_ -> cache_ . kInteger ) ) continue ; if ( bound_type . IsNone ( ) ) { min = initial_type . Min ( ) ; break ; } double bound_min = bound_type . Min ( ) ; if ( bound . kind == InductionVariable :: kStrict ) { bound_min += 1 ; } min = std :: max ( min , bound_min + increment_min ) ; } min = std :: min ( min , initial_type . Min ( ) ) ; } else { return typer_ -> cache_ . kInteger ; } if ( FLAG_trace_turbo_loop ) { StdoutStream { } < < std :: setprecision ( 10 ) < < "Loop (" < < NodeProperties :: GetControlInput ( node ) -> id ( ) < < ") variable bounds in " < < ( arithmetic_type == InductionVariable :: ArithmeticType :: kAddition ? "addition" : "subtraction" ) < < " for phi " < < node -> id ( ) < < ": (" < < min < < ", " < < max < < ")\n" ; } return Type :: Range ( min , max , typer_ -> zone ( ) ) ; }
void GetSocketAddr ( nsAString & aAddrStr ) { if ( ! mConnector ) { NS_WARNING ( "No connector to get socket address from!" ) ; aAddrStr = nsString ( ) ; return ; } mConnector -> GetSocketAddr ( mAddr , aAddrStr ) ; }
void nsTreeSanitizer :: SanitizeAttributes ( mozilla :: dom :: Element * aElement , AllowedAttributes aAllowed ) { int32_t ac = ( int ) aElement -> GetAttrCount ( ) ; for ( int32_t i = ac - 1 ; i >= 0 ; -- i ) { const nsAttrName * attrName = aElement -> GetAttrNameAt ( i ) ; int32_t attrNs = attrName -> NamespaceID ( ) ; RefPtr < nsAtom > attrLocal = attrName -> LocalName ( ) ; if ( mIsCustomized ) { bool shouldRemove = true ; RefPtr < nsAtom > elemName = aElement -> NodeInfo ( ) -> NameAtom ( ) ; if ( mAllowedAttributes ) { auto allowedElements = mAllowedAttributes -> Lookup ( attrLocal ) ; if ( allowedElements ) { if ( allowedElements . Data ( ) -> Contains ( elemName ) || allowedElements . Data ( ) -> Contains ( nsGkAtoms :: _asterisk ) ) { shouldRemove = false ; } } } if ( mDroppedAttributes ) { auto dropElements = mDroppedAttributes -> Lookup ( attrLocal ) ; if ( dropElements ) { if ( dropElements . Data ( ) -> Contains ( elemName ) || dropElements . Data ( ) -> Contains ( nsGkAtoms :: _asterisk ) ) { shouldRemove = true ; } } } if ( shouldRemove ) { aElement -> UnsetAttr ( kNameSpaceID_None , attrLocal , false ) ; -- ac ; i = ac ; } continue ; } if ( kNameSpaceID_None == attrNs ) { if ( aAllowed . mStyle && nsGkAtoms :: style == attrLocal ) { continue ; } if ( aAllowed . mDangerousSrc && nsGkAtoms :: src == attrLocal ) { continue ; } if ( IsURL ( aAllowed . mURLs , attrLocal ) ) { if ( SanitizeURL ( aElement , attrNs , attrLocal ) ) { -- ac ; i = ac ; continue ; } } if ( ! mDropNonCSSPresentation && ( aAllowed . mNames == sAttributesHTML ) && sPresAttributesHTML -> Contains ( attrLocal ) ) { continue ; } if ( aAllowed . mNames -> Contains ( attrLocal ) && ! ( ( attrLocal == nsGkAtoms :: rel && aElement -> IsHTMLElement ( nsGkAtoms :: link ) ) || ( ! mFullDocument && attrLocal == nsGkAtoms :: name && aElement -> IsHTMLElement ( nsGkAtoms :: meta ) ) ) ) { continue ; } const char16_t * localStr = attrLocal -> GetUTF16String ( ) ; uint32_t localLen = attrLocal -> GetLength ( ) ; if ( UTF16StringStartsWith ( localStr , localLen , u"_" ) || UTF16StringStartsWith ( localStr , localLen , u"data-" ) || UTF16StringStartsWith ( localStr , localLen , u"aria-" ) ) { continue ; } } else if ( kNameSpaceID_XML == attrNs ) { if ( nsGkAtoms :: lang == attrLocal || nsGkAtoms :: space == attrLocal ) { continue ; } } else if ( aAllowed . mXLink && kNameSpaceID_XLink == attrNs ) { if ( nsGkAtoms :: href == attrLocal ) { if ( SanitizeURL ( aElement , attrNs , attrLocal ) ) { -- ac ; i = ac ; } continue ; } if ( nsGkAtoms :: type == attrLocal || nsGkAtoms :: title == attrLocal || nsGkAtoms :: show == attrLocal || nsGkAtoms :: actuate == attrLocal ) { continue ; } } aElement -> UnsetAttr ( kNameSpaceID_None , attrLocal , false ) ; if ( mLogRemovals ) { LogMessage ( "Removed unsafe attribute." , aElement -> OwnerDoc ( ) , aElement , attrLocal ) ; } -- ac ; i = ac ; } if ( aElement -> IsAnyOfHTMLElements ( nsGkAtoms :: video , nsGkAtoms :: audio ) ) { aElement -> SetAttr ( kNameSpaceID_None , nsGkAtoms :: controls , u""_ns , false ) ; } }
static size_t CountTotalHolesSize ( Heap * heap ) { size_t holes_size = 0 ; PagedSpaces spaces ( heap ) ; for ( PagedSpace * space = spaces . next ( ) ; space != nullptr ; space = spaces . next ( ) ) { DCHECK_GE ( holes_size + space -> Waste ( ) + space -> Available ( ) , holes_size ) ; holes_size += space -> Waste ( ) + space -> Available ( ) ; } return holes_size ; }
JS_NextProperty ( JSContext * cx , JSObject * iterobj , jsid * idp ) { jsint i ; const Shape * shape ; JSIdArray * ida ; CHECK_REQUEST ( cx ) ; assertSameCompartment ( cx , iterobj ) ; i = iterobj -> getSlot ( JSSLOT_ITER_INDEX ) . toInt32 ( ) ; if ( i < 0 ) { JS_ASSERT ( iterobj -> getParent ( ) -> isNative ( ) ) ; shape = ( Shape * ) iterobj -> getPrivate ( ) ; while ( shape -> previous ( ) && ! shape -> enumerable ( ) ) shape = shape -> previous ( ) ; if ( ! shape -> previous ( ) ) { JS_ASSERT ( shape -> isEmptyShape ( ) ) ; * idp = JSID_VOID ; } else { iterobj -> setPrivate ( const_cast < Shape * > ( shape -> previous ( ) ) ) ; * idp = shape -> propid ( ) ; } } else { ida = ( JSIdArray * ) iterobj -> getPrivate ( ) ; JS_ASSERT ( i <= ida -> length ) ; STATIC_ASSUME ( i <= ida -> length ) ; if ( i == 0 ) { * idp = JSID_VOID ; } else { * idp = ida -> vector [ -- i ] ; iterobj -> setSlot ( JSSLOT_ITER_INDEX , Int32Value ( i ) ) ; } } return JS_TRUE ; }
formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) { Buffer save ; char * p ; int spos , epos , rows , c_rows , pos , col = 0 ; Line * l ; copyBuffer ( & save , buf ) ; gotoLine ( buf , a -> start . line ) ; switch ( form -> type ) { case FORM_TEXTAREA : case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : #ifdef MENU_SELECT case FORM_SELECT : #endif    /* MENU_SELECT */ spos = a -> start . pos ; epos = a -> end . pos ; break ; default : spos = a -> start . pos + 1 ; epos = a -> end . pos - 1 ; } switch ( form -> type ) { case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : if ( buf -> currentLine == NULL || spos >= buf -> currentLine -> len || spos < 0 ) break ; if ( form -> checked ) buf -> currentLine -> lineBuf [ spos ] = '*' ; else buf -> currentLine -> lineBuf [ spos ] = ' ' ; break ; case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_TEXTAREA : #ifdef MENU_SELECT case FORM_SELECT : if ( form -> type == FORM_SELECT ) { p = form -> label -> ptr ; updateSelectOption ( form , form -> select_option ) ; } else #endif    /* MENU_SELECT */ { if ( ! form -> value ) break ; p = form -> value -> ptr ; } l = buf -> currentLine ; if ( ! l ) break ; if ( form -> type == FORM_TEXTAREA ) { int n = a -> y - buf -> currentLine -> linenumber ; if ( n > 0 ) for ( ; l && n ; l = l -> prev , n -- ) ; else if ( n < 0 ) for ( ; l && n ; l = l -> prev , n ++ ) ; if ( ! l ) break ; } rows = form -> rows ? form -> rows : 1 ; col = COLPOS ( l , a -> start . pos ) ; for ( c_rows = 0 ; c_rows < rows ; c_rows ++ , l = l -> next ) { if ( rows > 1 ) { pos = columnPos ( l , col ) ; a = retrieveAnchor ( buf -> formitem , l -> linenumber , pos ) ; if ( a == NULL ) break ; spos = a -> start . pos ; epos = a -> end . pos ; } if ( a -> start . line != a -> end . line || spos > epos || epos >= l -> len || spos < 0 || epos < 0 || COLPOS ( l , epos ) < col ) break ; pos = form_update_line ( l , & p , spos , epos , COLPOS ( l , epos ) - col , rows > 1 , form -> type == FORM_INPUT_PASSWORD ) ; if ( pos != epos ) { shiftAnchorPosition ( buf -> href , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> name , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> img , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> formitem , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; } } break ; } copyBuffer ( buf , & save ) ; arrangeLine ( buf ) ; }
pushParseTest ( const char * filename , const char * result , const char * err ATTRIBUTE_UNUSED , int options ) { xmlParserCtxtPtr ctxt ; xmlDocPtr doc ; const char * base ; int size , res ; int cur = 0 ; nb_tests ++ ; if ( loadMem ( filename , & base , & size ) != 0 ) { fprintf ( stderr , "Failed to load %s\n" , filename ) ; return ( - 1 ) ; } #ifdef LIBXML_HTML_ENABLED if ( options & XML_PARSE_HTML ) ctxt = htmlCreatePushParserCtxt ( NULL , NULL , base + cur , 4 , filename , XML_CHAR_ENCODING_NONE ) ; else #endif ctxt = xmlCreatePushParserCtxt ( NULL , NULL , base + cur , 4 , filename ) ; xmlCtxtUseOptions ( ctxt , options ) ; cur += 4 ; do { if ( cur + 1024 >= size ) { #ifdef LIBXML_HTML_ENABLED if ( options & XML_PARSE_HTML ) htmlParseChunk ( ctxt , base + cur , size - cur , 1 ) ; else #endif xmlParseChunk ( ctxt , base + cur , size - cur , 1 ) ; break ; } else { #ifdef LIBXML_HTML_ENABLED if ( options & XML_PARSE_HTML ) htmlParseChunk ( ctxt , base + cur , 1024 , 0 ) ; else #endif xmlParseChunk ( ctxt , base + cur , 1024 , 0 ) ; cur += 1024 ; } } while ( cur < size ) ; doc = ctxt -> myDoc ; #ifdef LIBXML_HTML_ENABLED if ( options & XML_PARSE_HTML ) res = 1 ; else #endif res = ctxt -> wellFormed ; xmlFreeParserCtxt ( ctxt ) ; free ( ( char * ) base ) ; if ( ! res ) { xmlFreeDoc ( doc ) ; fprintf ( stderr , "Failed to parse %s\n" , filename ) ; return ( - 1 ) ; } #ifdef LIBXML_HTML_ENABLED if ( options & XML_PARSE_HTML ) htmlDocDumpMemory ( doc , ( xmlChar * * ) & base , & size ) ; else #endif xmlDocDumpMemory ( doc , ( xmlChar * * ) & base , & size ) ; xmlFreeDoc ( doc ) ; res = compareFileMem ( result , base , size ) ; if ( ( base == NULL ) || ( res != 0 ) ) { if ( base != NULL ) xmlFree ( ( char * ) base ) ; fprintf ( stderr , "Result for %s failed in %s\n" , filename , result ) ; return ( - 1 ) ; } xmlFree ( ( char * ) base ) ; if ( err != NULL ) { res = compareFileMem ( err , testErrors , testErrorsSize ) ; if ( res != 0 ) { fprintf ( stderr , "Error for %s failed\n" , filename ) ; return ( - 1 ) ; } } return ( 0 ) ; }
static OPJ_BYTE * opj_jp2_write_bpcc ( opj_jp2_t * jp2 , OPJ_UINT32 * p_nb_bytes_written ) { OPJ_UINT32 i ; OPJ_UINT32 l_bpcc_size = 8 + jp2 -> numcomps ; OPJ_BYTE * l_bpcc_data , * l_current_bpcc_ptr ; assert ( jp2 != 00 ) ; assert ( p_nb_bytes_written != 00 ) ; l_bpcc_data = ( OPJ_BYTE * ) opj_calloc ( 1 , l_bpcc_size ) ; if ( l_bpcc_data == 00 ) { return 00 ; } l_current_bpcc_ptr = l_bpcc_data ; opj_write_bytes ( l_current_bpcc_ptr , l_bpcc_size , 4 ) ; l_current_bpcc_ptr += 4 ; opj_write_bytes ( l_current_bpcc_ptr , JP2_BPCC , 4 ) ; l_current_bpcc_ptr += 4 ; for ( i = 0 ; i < jp2 -> numcomps ; ++ i ) { opj_write_bytes ( l_current_bpcc_ptr , jp2 -> comps [ i ] . bpcc , 1 ) ; ++ l_current_bpcc_ptr ; } * p_nb_bytes_written = l_bpcc_size ; return l_bpcc_data ; }
void ParseInfo :: set_script ( Handle < Script > script ) { script_ = script ; DCHECK ( script_id_ == - 1 || script_id_ == script -> id ( ) ) ; script_id_ = script -> id ( ) ; set_native ( script -> type ( ) == Script :: TYPE_NATIVE ) ; set_eval ( script -> compilation_type ( ) == Script :: COMPILATION_TYPE_EVAL ) ; set_module ( script -> origin_options ( ) . IsModule ( ) ) ; DCHECK ( ! ( is_eval ( ) && is_module ( ) ) ) ; if ( block_coverage_enabled ( ) && script -> IsUserJavaScript ( ) ) { AllocateSourceRangeMap ( ) ; } }
nsFocusManager :: SetActiveWindow ( mozIDOMWindowProxy * aWindow ) { NS_ENSURE_STATE ( aWindow ) ; nsCOMPtr < nsPIDOMWindowOuter > piWindow = nsPIDOMWindowOuter :: From ( aWindow ) ; NS_ENSURE_TRUE ( piWindow == piWindow -> GetPrivateRoot ( ) , NS_ERROR_INVALID_ARG ) ; RaiseWindow ( piWindow ) ; return NS_OK ; }
bool initialise_control ( rzip_control * control ) { time_t now_t , tdiff ; char localeptr [ ] = "./" , * eptr ; size_t len ; memset ( control , 0 , sizeof ( rzip_control ) ) ; control -> msgout = stderr ; control -> msgerr = stderr ; register_outputfile ( control , control -> msgout ) ; control -> flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD ; control -> suffix = ".lrz" ; control -> compression_level = 7 ; control -> ramsize = get_ram ( control ) ; if ( unlikely ( control -> ramsize == - 1 ) ) return false ; control -> threads = PROCESSORS ; control -> page_size = PAGE_SIZE ; control -> nice_val = 19 ; if ( unlikely ( ( now_t = time ( NULL ) ) == ( ( time_t ) - 1 ) ) ) fatal_return ( ( "Failed to call time in main\n" ) , false ) ; if ( unlikely ( now_t < T_ZERO ) ) { print_output ( "Warning your time reads before the year 2011, check your system clock\n" ) ; now_t = T_ZERO ; } tdiff = ( now_t - T_ZERO ) / 4 ; now_t = T_ZERO + tdiff ; control -> secs = now_t ; control -> encloops = nloops ( control -> secs , control -> salt , control -> salt + 1 ) ; if ( unlikely ( ! get_rand ( control , control -> salt + 2 , 6 ) ) ) return false ; eptr = getenv ( "TMPDIR" ) ; if ( ! eptr ) eptr = getenv ( "TMP" ) ; if ( ! eptr ) eptr = getenv ( "TEMPDIR" ) ; if ( ! eptr ) eptr = getenv ( "TEMP" ) ; if ( ! eptr ) eptr = localeptr ; len = strlen ( eptr ) ; control -> tmpdir = malloc ( len + 2 ) ; if ( control -> tmpdir == NULL ) fatal_return ( ( "Failed to allocate for tmpdir\n" ) , false ) ; strcpy ( control -> tmpdir , eptr ) ; if ( control -> tmpdir [ len - 1 ] != '/' ) { control -> tmpdir [ len ] = '/' ; control -> tmpdir [ len + 1 ] = '\0' ; } return true ; }
Builtins :: Name Builtins :: GetBuiltinFromBailoutId ( BailoutId id ) { int builtin_index = id . ToInt ( ) - BailoutId :: kFirstBuiltinContinuationId ; DCHECK ( Builtins :: KindOf ( builtin_index ) == TFJ || Builtins :: KindOf ( builtin_index ) == TFC ) ; return static_cast < Name > ( builtin_index ) ; }
void BrotliDecompressorImpl :: decompress ( const Buffer :: Instance & input_buffer , Buffer :: Instance & output_buffer ) { Common :: BrotliContext ctx ( chunk_size_ ) ; for ( const Buffer :: RawSlice & input_slice : input_buffer . getRawSlices ( ) ) { ctx . avail_in_ = input_slice . len_ ; ctx . next_in_ = static_cast < uint8_t * > ( input_slice . mem_ ) ; while ( ctx . avail_in_ > 0 ) { if ( ! process ( ctx , output_buffer ) ) { ctx . finalizeOutput ( output_buffer ) ; return ; } } } bool success ; do { success = process ( ctx , output_buffer ) ; } while ( success && BrotliDecoderHasMoreOutput ( state_ . get ( ) ) ) ; ctx . finalizeOutput ( output_buffer ) ; }
size_t WasmSerializer :: GetSerializedNativeModuleSize ( ) const { Vector < WasmCode * const > code_table ( code_table_ . data ( ) , code_table_ . size ( ) ) ; NativeModuleSerializer serializer ( isolate_ , native_module_ , code_table ) ; return kVersionSize + serializer . Measure ( ) ; }
GetName ( JSContext * aCx , JS :: Handle < JSObject * > aObj , JS :: Handle < jsid > aIdval , JS :: MutableHandle < JS :: Value > aVp ) { nsIDOMFile * file = GetInstancePrivate ( aCx , aObj , "name" ) ; if ( ! file ) { return false ; } nsString name ; if ( NS_FAILED ( file -> GetName ( name ) ) ) { name . Truncate ( ) ; } JSString * jsName = JS_NewUCStringCopyN ( aCx , name . get ( ) , name . Length ( ) ) ; if ( ! jsName ) { return false ; } aVp . set ( STRING_TO_JSVAL ( jsName ) ) ; return true ; }
Dump ( JSContext * cx , unsigned argc , jsval * vp ) { JSString * str ; if ( ! argc ) return true ; str = JS_ValueToString ( cx , JS_ARGV ( cx , vp ) [ 0 ] ) ; if ( ! str ) return false ; size_t length ; const jschar * chars = JS_GetStringCharsAndLength ( cx , str , & length ) ; if ( ! chars ) return false ; NS_ConvertUTF16toUTF8 utf8str ( reinterpret_cast < const PRUnichar * > ( chars ) ) ; #ifdef ANDROID __android_log_print ( ANDROID_LOG_INFO , "Gecko" , utf8str . get ( ) ) ; #endif fputs ( utf8str . get ( ) , stdout ) ; fflush ( stdout ) ; return true ; }
void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) { void * dllhandle ; if ( useSystemLib ) Com_Printf ( "Trying to load \"%s\"...\n" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = "." ; Com_Printf ( "Trying to load \"%s\" from \"%s\"...\n" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , "%s%c%s" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( "fs_basepath" ) ; if ( ! basePath || ! * basePath ) basePath = "." ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( "Trying to load \"%s\" from \"%s\"...\n" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , "%s%c%s" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( "Loading \"%s\" failed\n" , name ) ; } } return dllhandle ; }
static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb ) { s -> avctx -> profile = get_bits ( gb , 4 ) ; s -> avctx -> level = get_bits ( gb , 4 ) ; if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) { s -> avctx -> level = 0 ; } return 0 ; }
bool Archive :: Open ( const wchar * Name , uint Mode ) { QOpen . Unload ( ) ; return File :: Open ( Name , Mode ) ; }
void Heap :: NotifyDeserializationComplete ( ) { PagedSpaces spaces ( this ) ; for ( PagedSpace * s = spaces . next ( ) ; s != nullptr ; s = spaces . next ( ) ) { if ( isolate ( ) -> snapshot_available ( ) ) s -> ShrinkImmortalImmovablePages ( ) ; #ifdef DEBUG for ( Page * p : * s ) { DCHECK ( p -> NeverEvacuate ( ) ) ; } #endif // DEBUG } read_only_space ( ) -> MarkAsReadOnly ( ) ; deserialization_complete_ = true ; }
UDateRelativeDateTimeFormatterStyle getIcuStyle ( JSRelativeTimeFormat :: Style style ) { switch ( style ) { case JSRelativeTimeFormat :: Style :: LONG : return UDAT_STYLE_LONG ; case JSRelativeTimeFormat :: Style :: SHORT : return UDAT_STYLE_SHORT ; case JSRelativeTimeFormat :: Style :: NARROW : return UDAT_STYLE_NARROW ; case JSRelativeTimeFormat :: Style :: COUNT : UNREACHABLE ( ) ; } }
static void perform_gamma_scale16_tests ( png_modifier * pm ) { #  ifndef PNG_MAX_GAMMA_8 #     define PNG_MAX_GAMMA_8 11 #  endif #  define SBIT_16_TO_8 PNG_MAX_GAMMA_8 unsigned int i , j ; for ( i = 0 ; i < pm -> ngamma_tests ; ++ i ) { for ( j = 0 ; j < pm -> ngamma_tests ; ++ j ) { if ( i != j && fabs ( pm -> gammas [ j ] / pm -> gammas [ i ] - 1 ) >= PNG_GAMMA_THRESHOLD ) { gamma_transform_test ( pm , 0 , 16 , 0 , pm -> interlace_type , 1 / pm -> gammas [ i ] , pm -> gammas [ j ] , SBIT_16_TO_8 , pm -> use_input_precision_16to8 , 1 ) ; if ( fail ( pm ) ) return ; gamma_transform_test ( pm , 2 , 16 , 0 , pm -> interlace_type , 1 / pm -> gammas [ i ] , pm -> gammas [ j ] , SBIT_16_TO_8 , pm -> use_input_precision_16to8 , 1 ) ; if ( fail ( pm ) ) return ; gamma_transform_test ( pm , 4 , 16 , 0 , pm -> interlace_type , 1 / pm -> gammas [ i ] , pm -> gammas [ j ] , SBIT_16_TO_8 , pm -> use_input_precision_16to8 , 1 ) ; if ( fail ( pm ) ) return ; gamma_transform_test ( pm , 6 , 16 , 0 , pm -> interlace_type , 1 / pm -> gammas [ i ] , pm -> gammas [ j ] , SBIT_16_TO_8 , pm -> use_input_precision_16to8 , 1 ) ; if ( fail ( pm ) ) return ; } } } }
MP4TrackDemuxer :: MP4TrackDemuxer ( MP4Demuxer * aParent , TrackInfo :: TrackType aType , uint32_t aTrackNumber ) : mParent ( aParent ) , mStream ( new mp4_demuxer :: ResourceStream ( mParent -> mResource ) ) , mNeedReIndex ( true ) , mMonitor ( "MP4TrackDemuxer" ) { mInfo = mParent -> mMetadata -> GetTrackInfo ( aType , aTrackNumber ) ; MOZ_ASSERT ( mInfo ) ; FallibleTArray < mp4_demuxer :: Index :: Indice > indices ; if ( ! mParent -> mMetadata -> ReadTrackIndex ( indices , mInfo -> mTrackId ) ) { MOZ_ASSERT ( false ) ; } mIndex = new mp4_demuxer :: Index ( indices , mStream , mInfo -> mTrackId , mInfo -> IsAudio ( ) , & mMonitor ) ; mIterator = MakeUnique < mp4_demuxer :: SampleIterator > ( mIndex ) ; EnsureUpToDateIndex ( ) ; if ( mInfo -> GetAsVideoInfo ( ) && ( mInfo -> mMimeType . EqualsLiteral ( "video/mp4" ) || mInfo -> mMimeType . EqualsLiteral ( "video/avc" ) ) ) { mNeedSPSForTelemetry = AccumulateSPSTelemetry ( mInfo -> GetAsVideoInfo ( ) -> mExtraData ) ; } else { mNeedSPSForTelemetry = false ; } }
nsSVGGlyphFrame :: GetExtentOfChar ( PRUint32 charnum , nsIDOMSVGRect * * _retval ) { * _retval = nsnull ; PRUint32 start = charnum , limit = charnum + 1 ; while ( start > 0 && ! mTextRun -> IsClusterStart ( start ) ) { -- start ; } while ( limit < mTextRun -> GetLength ( ) && ! mTextRun -> IsClusterStart ( limit ) ) { ++ limit ; } CharacterIterator iter ( this , PR_FALSE ) ; if ( ! iter . AdvanceToCharacter ( start ) ) return NS_ERROR_DOM_INDEX_SIZE_ERR ; gfxTextRun :: Metrics metrics = mTextRun -> MeasureText ( start , limit - start , gfxFont :: LOOSE_INK_EXTENTS , nsnull , nsnull ) ; nsRefPtr < gfxContext > tmpCtx = MakeTmpCtx ( ) ; iter . SetupForMetrics ( tmpCtx ) ; tmpCtx -> Rectangle ( gfxRect ( 0 , - metrics . mAscent , metrics . mAdvanceWidth , metrics . mAscent + metrics . mDescent ) ) ; tmpCtx -> IdentityMatrix ( ) ; return NS_NewSVGRect ( _retval , tmpCtx -> GetUserPathExtent ( ) ) ; }
setv4key_principal_2_svc ( setv4key_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; gss_buffer_desc client_name , service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_SETKEY , arg -> princ , NULL ) ) { ret . code = kadm5_setv4key_principal ( ( void * ) handle , arg -> princ , arg -> keyblock ) ; } else { log_unauth ( "kadm5_setv4key_principal" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_SETKEY ; } if ( ret . code != KADM5_AUTH_SETKEY ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( "kadm5_setv4key_principal" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
static void handle_rx ( struct vhost_net * net ) { struct vhost_net_virtqueue * nvq = & net -> vqs [ VHOST_NET_VQ_RX ] ; struct vhost_virtqueue * vq = & nvq -> vq ; unsigned uninitialized_var ( in ) , log ; struct vhost_log * vq_log ; struct msghdr msg = { . msg_name = NULL , . msg_namelen = 0 , . msg_control = NULL , . msg_controllen = 0 , . msg_iov = vq -> iov , . msg_flags = MSG_DONTWAIT , } ; struct virtio_net_hdr_mrg_rxbuf hdr = { . hdr . flags = 0 , . hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE } ; size_t total_len = 0 ; int err , mergeable ; s16 headcount ; size_t vhost_hlen , sock_hlen ; size_t vhost_len , sock_len ; struct socket * sock ; mutex_lock ( & vq -> mutex ) ; sock = vq -> private_data ; if ( ! sock ) goto out ; vhost_disable_notify ( & net -> dev , vq ) ; vhost_hlen = nvq -> vhost_hlen ; sock_hlen = nvq -> sock_hlen ; vq_log = unlikely ( vhost_has_feature ( & net -> dev , VHOST_F_LOG_ALL ) ) ? vq -> log : NULL ; mergeable = vhost_has_feature ( & net -> dev , VIRTIO_NET_F_MRG_RXBUF ) ; while ( ( sock_len = peek_head_len ( sock -> sk ) ) ) { sock_len += sock_hlen ; vhost_len = sock_len + vhost_hlen ; headcount = get_rx_bufs ( vq , vq -> heads , vhost_len , & in , vq_log , & log , likely ( mergeable ) ? UIO_MAXIOV : 1 ) ; if ( unlikely ( headcount < 0 ) ) break ; if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; if ( unlikely ( err != sock_len ) ) { pr_debug ( "Discarded rx packet: " " len %d, expected %zd\n" , err , sock_len ) ; vhost_discard_vq_desc ( vq , headcount ) ; continue ; } if ( unlikely ( vhost_hlen ) && memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & hdr , 0 , vhost_hlen ) ) { vq_err ( vq , "Unable to write vnet_hdr at addr %p\n" , vq -> iov -> iov_base ) ; break ; } if ( likely ( mergeable ) && memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & headcount , offsetof ( typeof ( hdr ) , num_buffers ) , sizeof hdr . num_buffers ) ) { vq_err ( vq , "Failed num_buffers write" ) ; vhost_discard_vq_desc ( vq , headcount ) ; break ; } vhost_add_used_and_signal_n ( & net -> dev , vq , vq -> heads , headcount ) ; if ( unlikely ( vq_log ) ) vhost_log_write ( vq , vq_log , log , vhost_len ) ; total_len += vhost_len ; if ( unlikely ( total_len >= VHOST_NET_WEIGHT ) ) { vhost_poll_queue ( & vq -> poll ) ; break ; } } out : mutex_unlock ( & vq -> mutex ) ; }
httpWait ( http_t * http , int msec ) { DEBUG_printf ( ( "2httpWait(http=%p, msec=%d)" , ( void * ) http , msec ) ) ; if ( http == NULL ) return ( 0 ) ; if ( http -> used ) { DEBUG_puts ( "3httpWait: Returning 1 since there is buffered data ready." ) ; return ( 1 ) ; } #ifdef HAVE_LIBZ if ( http -> coding >= _HTTP_CODING_GUNZIP && http -> stream . avail_in > 0 ) { DEBUG_puts ( "3httpWait: Returning 1 since there is buffered data ready." ) ; return ( 1 ) ; } #endif /* HAVE_LIBZ */ if ( http -> wused ) { DEBUG_puts ( "3httpWait: Flushing write buffer." ) ; if ( httpFlushWrite ( http ) < 0 ) return ( 0 ) ; } return ( _httpWait ( http , msec , 1 ) ) ; }
void Builtins :: Generate_FunctionPrototypeApply ( MacroAssembler * masm ) { { Label skip ; Register arg_size = r8 ; Register new_sp = r6 ; Register scratch = r7 ; __ ShiftLeftImm ( arg_size , r3 , Operand ( kPointerSizeLog2 ) ) ; __ add ( new_sp , sp , arg_size ) ; __ LoadRoot ( scratch , Heap :: kUndefinedValueRootIndex ) ; __ mr ( r5 , scratch ) ; __ LoadP ( r4 , MemOperand ( new_sp , 0 ) ) ; __ cmpi ( arg_size , Operand ( kPointerSize ) ) ; __ blt ( & skip ) ; __ LoadP ( scratch , MemOperand ( new_sp , 1 * - kPointerSize ) ) ; __ beq ( & skip ) ; __ LoadP ( r5 , MemOperand ( new_sp , 2 * - kPointerSize ) ) ; __ bind ( & skip ) ; __ mr ( sp , new_sp ) ; __ StoreP ( scratch , MemOperand ( sp , 0 ) ) ; } Label no_arguments ; __ JumpIfRoot ( r5 , Heap :: kNullValueRootIndex , & no_arguments ) ; __ JumpIfRoot ( r5 , Heap :: kUndefinedValueRootIndex , & no_arguments ) ; __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , CallWithArrayLike ) , RelocInfo :: CODE_TARGET ) ; __ bind ( & no_arguments ) ; { __ li ( r3 , Operand :: Zero ( ) ) ; __ Jump ( masm -> isolate ( ) -> builtins ( ) -> Call ( ) , RelocInfo :: CODE_TARGET ) ; } }
nsSVGTextPathFrame :: GetPathFrame ( ) { nsSVGTextPathProperty * property = static_cast < nsSVGTextPathProperty * > ( Properties ( ) . Get ( nsSVGEffects :: HrefProperty ( ) ) ) ; if ( ! property ) { nsSVGTextPathElement * tp = static_cast < nsSVGTextPathElement * > ( mContent ) ; nsAutoString href ; tp -> mStringAttributes [ nsSVGTextPathElement :: HREF ] . GetAnimValue ( href , tp ) ; if ( href . IsEmpty ( ) ) { return nullptr ; } nsCOMPtr < nsIURI > targetURI ; nsCOMPtr < nsIURI > base = mContent -> GetBaseURI ( ) ; nsContentUtils :: NewURIWithDocumentCharset ( getter_AddRefs ( targetURI ) , href , mContent -> GetCurrentDoc ( ) , base ) ; property = nsSVGEffects :: GetTextPathProperty ( targetURI , this , nsSVGEffects :: HrefProperty ( ) ) ; if ( ! property ) return nullptr ; } return property -> GetReferencedFrame ( nsGkAtoms :: svgPathGeometryFrame , nullptr ) ; }
Return < void > CryptoPlugin :: decrypt ( bool secure , const hidl_array < uint8_t , 16 > & keyId , const hidl_array < uint8_t , 16 > & iv , Mode mode , const Pattern & pattern , const hidl_vec < SubSample > & subSamples , const SharedBuffer & source , uint64_t offset , const DestinationBuffer & destination , decrypt_cb _hidl_cb ) { Status status = Status :: ERROR_DRM_UNKNOWN ; hidl_string detailedError ; uint32_t bytesWritten = 0 ; Return < void > hResult = decrypt_1_2 ( secure , keyId , iv , mode , pattern , subSamples , source , offset , destination , [ & ] ( Status_V1_2 hStatus , uint32_t hBytesWritten , hidl_string hDetailedError ) { status = toStatus_1_0 ( hStatus ) ; if ( status == Status :: OK ) { bytesWritten = hBytesWritten ; detailedError = hDetailedError ; } } ) ; status = hResult . isOk ( ) ? status : Status :: ERROR_DRM_CANNOT_HANDLE ; _hidl_cb ( status , bytesWritten , detailedError ) ; return Void ( ) ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; auto * params = reinterpret_cast < TfLiteSubParams * > ( node -> builtin_data ) ; TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 2 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * input1 = GetInput ( context , node , kInputTensor1 ) ; const TfLiteTensor * input2 = GetInput ( context , node , kInputTensor2 ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; TF_LITE_ENSURE_TYPES_EQ ( context , input1 -> type , input2 -> type ) ; output -> type = input2 -> type ; data -> requires_broadcast = ! HaveSameShapes ( input1 , input2 ) ; TfLiteIntArray * output_size = nullptr ; if ( data -> requires_broadcast ) { TF_LITE_ENSURE_OK ( context , CalculateShapeForBroadcast ( context , input1 , input2 , & output_size ) ) ; } else { output_size = TfLiteIntArrayCopy ( input1 -> dims ) ; } bool pot_scale_int16 = true ; bool input1_scale_is_pot = false ; bool input2_scale_is_pot = false ; bool output_scale_is_pot = false ; int input1_scale_log2_rounded { 0 } ; int input2_scale_log2_rounded { 0 } ; int output_scale_log2_rounded { 0 } ; if ( input1 -> type == kTfLiteInt16 && input2 -> type == kTfLiteInt16 && output -> type == kTfLiteInt16 ) { pot_scale_int16 = ( input1 -> params . zero_point == 0 ) && ( input2 -> params . zero_point == 0 ) && ( output -> params . zero_point == 0 ) ; input1_scale_is_pot = CheckedLog2 ( input1 -> params . scale , & input1_scale_log2_rounded ) ; input2_scale_is_pot = CheckedLog2 ( input2 -> params . scale , & input2_scale_log2_rounded ) ; output_scale_is_pot = CheckedLog2 ( output -> params . scale , & output_scale_log2_rounded ) ; pot_scale_int16 &= input1_scale_is_pot && input2_scale_is_pot && output_scale_is_pot ; } data -> pot_scale_int16 = pot_scale_int16 ; if ( output -> type == kTfLiteUInt8 || output -> type == kTfLiteInt8 || ! pot_scale_int16 ) { TF_LITE_ENSURE_OK ( context , PrepareGeneralSubOp ( context , input1 , input2 , output , params , data , - 1 ) ) ; } else if ( output -> type == kTfLiteInt16 ) { TF_LITE_ENSURE_OK ( context , PrepareInt16SubOpPOT ( context , input1 , input2 , output , params , data ) ) ; } return context -> ResizeTensor ( context , output , output_size ) ; }
Object * Module :: GetException ( ) { DisallowHeapAllocation no_alloc ; DCHECK_EQ ( status ( ) , Module :: kErrored ) ; DCHECK ( ! exception ( ) -> IsTheHole ( ) ) ; return exception ( ) ; }
static int __btrfs_set_acl ( struct btrfs_trans_handle * trans , struct inode * inode , struct posix_acl * acl , int type ) { int ret , size = 0 ; const char * name ; char * value = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { ret = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; if ( ret < 0 ) return ret ; if ( ret == 0 ) acl = NULL ; } ret = 0 ; break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EINVAL : 0 ; name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out ; } ret = __btrfs_setxattr ( trans , inode , name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! ret ) set_cached_acl ( inode , type , acl ) ; return ret ; }
const Operator * JSOperatorBuilder :: ConstructWithSpread ( uint32_t arity , CallFrequency frequency , VectorSlotPair const & feedback ) { ConstructParameters parameters ( arity , frequency , feedback ) ; return new ( zone ( ) ) Operator1 < ConstructParameters > ( IrOpcode :: kJSConstructWithSpread , Operator :: kNoProperties , "JSConstructWithSpread" , parameters . arity ( ) , 1 , 1 , 1 , 1 , 2 , parameters ) ; }
static void m_stop ( struct seq_file * m , void * v ) { struct proc_maps_private * priv = m -> private ; struct vm_area_struct * vma = v ; vma_stop ( priv , vma ) ; if ( priv -> task ) put_task_struct ( priv -> task ) ; }
vips_foreign_load_gif_scan_image ( VipsForeignLoadGif * gif ) { VipsObjectClass * class = VIPS_OBJECT_GET_CLASS ( gif ) ; GifFileType * file = gif -> file ; ColorMapObject * map = file -> Image . ColorMap ? file -> Image . ColorMap : file -> SColorMap ; GifByteType * extension ; if ( DGifGetImageDesc ( gif -> file ) == GIF_ERROR ) { vips_foreign_load_gif_error ( gif ) ; return ( - 1 ) ; } if ( file -> Image . Left < 0 || file -> Image . Width < 1 || file -> Image . Width > 10000 || file -> Image . Left + file -> Image . Width > file -> SWidth || file -> Image . Top < 0 || file -> Image . Height < 1 || file -> Image . Height > 10000 || file -> Image . Top + file -> Image . Height > file -> SHeight ) { vips_error ( class -> nickname , "%s" , _ ( "bad frame size" ) ) ; return ( - 1 ) ; } if ( ! gif -> has_colour && map ) { int i ; for ( i = 0 ; i < map -> ColorCount ; i ++ ) if ( map -> Colors [ i ] . Red != map -> Colors [ i ] . Green || map -> Colors [ i ] . Green != map -> Colors [ i ] . Blue ) { gif -> has_colour = TRUE ; break ; } } do { if ( vips_foreign_load_gif_code_next ( gif , & extension ) ) return ( - 1 ) ; } while ( extension != NULL ) ; return ( 0 ) ; }
status_t BnHDCP :: onTransact ( uint32_t code , const Parcel & data , Parcel * reply , uint32_t flags ) { switch ( code ) { case HDCP_SET_OBSERVER : { CHECK_INTERFACE ( IHDCP , data , reply ) ; sp < IHDCPObserver > observer = interface_cast < IHDCPObserver > ( data . readStrongBinder ( ) ) ; reply -> writeInt32 ( setObserver ( observer ) ) ; return OK ; } case HDCP_INIT_ASYNC : { CHECK_INTERFACE ( IHDCP , data , reply ) ; const char * host = data . readCString ( ) ; unsigned port = data . readInt32 ( ) ; reply -> writeInt32 ( initAsync ( host , port ) ) ; return OK ; } case HDCP_SHUTDOWN_ASYNC : { CHECK_INTERFACE ( IHDCP , data , reply ) ; reply -> writeInt32 ( shutdownAsync ( ) ) ; return OK ; } case HDCP_GET_CAPS : { CHECK_INTERFACE ( IHDCP , data , reply ) ; reply -> writeInt32 ( getCaps ( ) ) ; return OK ; } case HDCP_ENCRYPT : { CHECK_INTERFACE ( IHDCP , data , reply ) ; size_t size = data . readInt32 ( ) ; void * inData = NULL ; if ( size <= SIZE_MAX / 2 ) { inData = malloc ( 2 * size ) ; } if ( inData == NULL ) { reply -> writeInt32 ( ERROR_OUT_OF_RANGE ) ; return OK ; } void * outData = ( uint8_t * ) inData + size ; status_t err = data . read ( inData , size ) ; if ( err != OK ) { free ( inData ) ; reply -> writeInt32 ( err ) ; return OK ; } uint32_t streamCTR = data . readInt32 ( ) ; uint64_t inputCTR ; err = encrypt ( inData , size , streamCTR , & inputCTR , outData ) ; reply -> writeInt32 ( err ) ; if ( err == OK ) { reply -> writeInt64 ( inputCTR ) ; reply -> write ( outData , size ) ; } free ( inData ) ; inData = outData = NULL ; return OK ; } case HDCP_ENCRYPT_NATIVE : { CHECK_INTERFACE ( IHDCP , data , reply ) ; sp < GraphicBuffer > graphicBuffer = new GraphicBuffer ( ) ; data . read ( * graphicBuffer ) ; size_t offset = data . readInt32 ( ) ; size_t size = data . readInt32 ( ) ; uint32_t streamCTR = data . readInt32 ( ) ; void * outData = NULL ; uint64_t inputCTR ; status_t err = ERROR_OUT_OF_RANGE ; outData = malloc ( size ) ; if ( outData != NULL ) { err = encryptNative ( graphicBuffer , offset , size , streamCTR , & inputCTR , outData ) ; } reply -> writeInt32 ( err ) ; if ( err == OK ) { reply -> writeInt64 ( inputCTR ) ; reply -> write ( outData , size ) ; } free ( outData ) ; outData = NULL ; return OK ; } case HDCP_DECRYPT : { CHECK_INTERFACE ( IHDCP , data , reply ) ; size_t size = data . readInt32 ( ) ; size_t bufSize = 2 * size ; void * inData = NULL ; if ( bufSize > size ) { inData = malloc ( bufSize ) ; } if ( inData == NULL ) { reply -> writeInt32 ( ERROR_OUT_OF_RANGE ) ; return OK ; } void * outData = ( uint8_t * ) inData + size ; data . read ( inData , size ) ; uint32_t streamCTR = data . readInt32 ( ) ; uint64_t inputCTR = data . readInt64 ( ) ; status_t err = decrypt ( inData , size , streamCTR , inputCTR , outData ) ; reply -> writeInt32 ( err ) ; if ( err == OK ) { reply -> write ( outData , size ) ; } free ( inData ) ; inData = outData = NULL ; return OK ; } default : return BBinder :: onTransact ( code , data , reply , flags ) ; } }
static void __init netlink_add_usersock_entry ( void ) { struct listeners * listeners ; int groups = 32 ; listeners = kzalloc ( sizeof ( * listeners ) + NLGRPSZ ( groups ) , GFP_KERNEL ) ; if ( ! listeners ) panic ( "netlink_add_usersock_entry: Cannot allocate listeners\n" ) ; netlink_table_grab ( ) ; nl_table [ NETLINK_USERSOCK ] . groups = groups ; rcu_assign_pointer ( nl_table [ NETLINK_USERSOCK ] . listeners , listeners ) ; nl_table [ NETLINK_USERSOCK ] . module = THIS_MODULE ; nl_table [ NETLINK_USERSOCK ] . registered = 1 ; netlink_table_ungrab ( ) ; }
bool HeapSnapshotGenerator :: FillReferences ( ) { SnapshotFiller filler ( snapshot_ , & entries_ ) ; return v8_heap_explorer_ . IterateAndExtractReferences ( & filler ) && dom_explorer_ . IterateAndExtractReferences ( & filler ) ; }
vrrp_tfile_end_handler ( void ) { vrrp_tracked_file_t * tfile = LIST_TAIL_DATA ( vrrp_data -> vrrp_track_files ) ; struct stat statb ; FILE * tf ; int ret ; if ( ! tfile -> file_path ) { report_config_error ( CONFIG_GENERAL_ERROR , "No file set for track_file %s - removing" , tfile -> fname ) ; free_list_element ( vrrp_data -> vrrp_track_files , vrrp_data -> vrrp_track_files -> tail ) ; return ; } if ( track_file_init == TRACK_FILE_NO_INIT ) return ; ret = stat ( tfile -> file_path , & statb ) ; if ( ! ret ) { if ( track_file_init == TRACK_FILE_CREATE ) { return ; } if ( ( statb . st_mode & S_IFMT ) != S_IFREG ) { report_config_error ( CONFIG_GENERAL_ERROR , "Cannot initialise track file %s - it is not a regular file" , tfile -> fname ) ; return ; } if ( reload ) return ; } if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { if ( ( tf = fopen ( tfile -> file_path , "w" ) ) ) { fprintf ( tf , "%d\n" , track_file_init_value ) ; fclose ( tf ) ; } else report_config_error ( CONFIG_GENERAL_ERROR , "Unable to initialise track file %s" , tfile -> fname ) ; } }
xmlXPathIsPositionalPredicate ( xmlXPathParserContextPtr ctxt , xmlXPathStepOpPtr op , int * maxPos ) { xmlXPathStepOpPtr exprOp ; if ( ( op -> op != XPATH_OP_PREDICATE ) && ( op -> op != XPATH_OP_FILTER ) ) return ( 0 ) ; if ( op -> ch2 != - 1 ) { exprOp = & ctxt -> comp -> steps [ op -> ch2 ] ; } else return ( 0 ) ; if ( ( exprOp != NULL ) && ( exprOp -> op == XPATH_OP_VALUE ) && ( exprOp -> value4 != NULL ) && ( ( ( xmlXPathObjectPtr ) exprOp -> value4 ) -> type == XPATH_NUMBER ) ) { * maxPos = ( int ) ( ( xmlXPathObjectPtr ) exprOp -> value4 ) -> floatval ; if ( ( ( xmlXPathObjectPtr ) exprOp -> value4 ) -> floatval == ( float ) * maxPos ) { return ( 1 ) ; } } return ( 0 ) ; }
NS_IMETHODIMP DestroyWidgetRunnable :: Run ( ) { nsView * view = nullptr ; nsIWidget * currentWidget = GetWidget ( & view ) ; if ( view && mWidget && mWidget == currentWidget ) { view -> DestroyWidget ( ) ; } return NS_OK ; }
GfxInfo :: GetFeatureStatusImpl ( int32_t aFeature , int32_t * aStatus , nsAString & aSuggestedDriverVersion , const nsTArray < GfxDriverInfo > & aDriverInfo , OperatingSystem * aOS ) { NS_ENSURE_ARG_POINTER ( aStatus ) ; aSuggestedDriverVersion . SetIsVoid ( true ) ; * aStatus = nsIGfxInfo :: FEATURE_STATUS_UNKNOWN ; OperatingSystem os = mOS ; if ( aOS ) * aOS = os ; EnsureInitializedFromGfxInfoData ( ) ; if ( ! mError . IsEmpty ( ) ) { * aStatus = nsIGfxInfo :: FEATURE_BLOCKED_DEVICE ; return NS_OK ; } if ( aDriverInfo . IsEmpty ( ) ) { if ( aFeature == FEATURE_WEBGL_OPENGL ) { if ( mRenderer . Find ( "Adreno 200" ) != - 1 || mRenderer . Find ( "Adreno 205" ) != - 1 ) { * aStatus = nsIGfxInfo :: FEATURE_BLOCKED_DEVICE ; return NS_OK ; } } if ( aFeature == FEATURE_STAGEFRIGHT ) { NS_LossyConvertUTF16toASCII cManufacturer ( mManufacturer ) ; NS_LossyConvertUTF16toASCII cModel ( mModel ) ; if ( CompareVersions ( mOSVersion . get ( ) , "4.0.0" ) < 0 ) { * aStatus = nsIGfxInfo :: FEATURE_BLOCKED_OS_VERSION ; return NS_OK ; } else if ( CompareVersions ( mOSVersion . get ( ) , "4.1.0" ) < 0 ) { bool isWhitelisted = cManufacturer . Equals ( "samsung" , nsCaseInsensitiveCStringComparator ( ) ) || cModel . Equals ( "galaxy nexus" , nsCaseInsensitiveCStringComparator ( ) ) ; if ( ! isWhitelisted ) { * aStatus = nsIGfxInfo :: FEATURE_BLOCKED_DEVICE ; return NS_OK ; } } } } return GfxInfoBase :: GetFeatureStatusImpl ( aFeature , aStatus , aSuggestedDriverVersion , aDriverInfo , & os ) ; }
void CreateCompositor ( int32_t aWidth , int32_t aHeight ) { window . CreateLayerManager ( aWidth , aHeight ) ; mCompositorPaused = false ; OnResumedCompositor ( aWidth , aHeight ) ; }
DefragRegisterTests ( void ) { #ifdef UNITTESTS UtRegisterTest ( "DefragInOrderSimpleTest" , DefragInOrderSimpleTest ) ; UtRegisterTest ( "DefragReverseSimpleTest" , DefragReverseSimpleTest ) ; UtRegisterTest ( "DefragSturgesNovakBsdTest" , DefragSturgesNovakBsdTest ) ; UtRegisterTest ( "DefragSturgesNovakLinuxTest" , DefragSturgesNovakLinuxTest ) ; UtRegisterTest ( "DefragSturgesNovakWindowsTest" , DefragSturgesNovakWindowsTest ) ; UtRegisterTest ( "DefragSturgesNovakSolarisTest" , DefragSturgesNovakSolarisTest ) ; UtRegisterTest ( "DefragSturgesNovakFirstTest" , DefragSturgesNovakFirstTest ) ; UtRegisterTest ( "DefragSturgesNovakLastTest" , DefragSturgesNovakLastTest ) ; UtRegisterTest ( "DefragIPv4NoDataTest" , DefragIPv4NoDataTest ) ; UtRegisterTest ( "DefragIPv4TooLargeTest" , DefragIPv4TooLargeTest ) ; UtRegisterTest ( "IPV6DefragInOrderSimpleTest" , IPV6DefragInOrderSimpleTest ) ; UtRegisterTest ( "IPV6DefragReverseSimpleTest" , IPV6DefragReverseSimpleTest ) ; UtRegisterTest ( "IPV6DefragSturgesNovakBsdTest" , IPV6DefragSturgesNovakBsdTest ) ; UtRegisterTest ( "IPV6DefragSturgesNovakLinuxTest" , IPV6DefragSturgesNovakLinuxTest ) ; UtRegisterTest ( "IPV6DefragSturgesNovakWindowsTest" , IPV6DefragSturgesNovakWindowsTest ) ; UtRegisterTest ( "IPV6DefragSturgesNovakSolarisTest" , IPV6DefragSturgesNovakSolarisTest ) ; UtRegisterTest ( "IPV6DefragSturgesNovakFirstTest" , IPV6DefragSturgesNovakFirstTest ) ; UtRegisterTest ( "IPV6DefragSturgesNovakLastTest" , IPV6DefragSturgesNovakLastTest ) ; UtRegisterTest ( "DefragVlanTest" , DefragVlanTest ) ; UtRegisterTest ( "DefragVlanQinQTest" , DefragVlanQinQTest ) ; UtRegisterTest ( "DefragTrackerReuseTest" , DefragTrackerReuseTest ) ; UtRegisterTest ( "DefragTimeoutTest" , DefragTimeoutTest ) ; UtRegisterTest ( "DefragMfIpv4Test" , DefragMfIpv4Test ) ; UtRegisterTest ( "DefragMfIpv6Test" , DefragMfIpv6Test ) ; #endif /* UNITTESTS */ }
const Operator * CommonOperatorBuilder :: ArgumentsElementsState ( ArgumentsStateType type ) { return new ( zone ( ) ) Operator1 < ArgumentsStateType > ( IrOpcode :: kArgumentsElementsState , Operator :: kPure , "ArgumentsElementsState" , 0 , 0 , 0 , 1 , 0 , 0 , type ) ; }
static jas_image_cmpt_t * jas_image_cmpt_create ( int_fast32_t tlx , int_fast32_t tly , int_fast32_t hstep , int_fast32_t vstep , int_fast32_t width , int_fast32_t height , uint_fast16_t depth , bool sgnd , uint_fast32_t inmem ) { jas_image_cmpt_t * cmpt ; size_t size ; cmpt = 0 ; if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) { goto error ; } if ( ! jas_safe_intfast32_add ( tlx , width , 0 ) || ! jas_safe_intfast32_add ( tly , height , 0 ) ) { goto error ; } if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) { goto error ; } cmpt -> type_ = JAS_IMAGE_CT_UNKNOWN ; cmpt -> tlx_ = tlx ; cmpt -> tly_ = tly ; cmpt -> hstep_ = hstep ; cmpt -> vstep_ = vstep ; cmpt -> width_ = width ; cmpt -> height_ = height ; cmpt -> prec_ = depth ; cmpt -> sgnd_ = sgnd ; cmpt -> stream_ = 0 ; cmpt -> cps_ = ( depth + 7 ) / 8 ; if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) || ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) { goto error ; } cmpt -> stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) : jas_stream_tmpfile ( ) ; if ( ! cmpt -> stream_ ) { goto error ; } if ( jas_stream_seek ( cmpt -> stream_ , size - 1 , SEEK_SET ) < 0 || jas_stream_putc ( cmpt -> stream_ , 0 ) == EOF || jas_stream_seek ( cmpt -> stream_ , 0 , SEEK_SET ) < 0 ) { goto error ; } return cmpt ; error : if ( cmpt ) { jas_image_cmpt_destroy ( cmpt ) ; } return 0 ; }
static int isofs_read_inode ( struct inode * inode ) { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO "%s: out of memory\n" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG "ISOFS: Interleaved files not (yet) supported.\n" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG "ISOFS: File unit size != 0 for ISO file (%ld).\n" , inode -> i_ino ) ; } #ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG "ISOFS: Unusual flag settings for ISO file " "(%ld %x).\n" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } #endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) > > 9 ; if ( ! high_sierra ) { parse_rock_ridge_inode ( de , inode ) ; if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { #ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; #endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING "ISOFS: unable to read i-node block\n" ) ; fail : goto out ; }
static ssize_t _hostfs_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; if ( ! file || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } done : if ( buf ) oe_free ( buf ) ; return ret ; }
IGNITION_HANDLER ( LdaCurrentContextSlot , InterpreterAssembler ) { Node * slot_index = BytecodeOperandIdx ( 0 ) ; Node * slot_context = GetContext ( ) ; Node * result = LoadContextElement ( slot_context , slot_index ) ; SetAccumulator ( result ) ; Dispatch ( ) ; }
void CPU :: EnsureIAndDCacheCoherency ( void * address , size_t length , bool codeIsThreadLocal ) { #if defined(JS_SIMULATOR_ARM64) && defined(JS_CACHE_SIMULATOR_ARM64) using js :: jit :: SimulatorProcess ; js :: jit :: AutoLockSimulatorCache alsc ; if ( length > 0 ) { SimulatorProcess :: recordICacheFlush ( address , length ) ; } Simulator * sim = vixl :: Simulator :: Current ( ) ; if ( sim ) { sim -> FlushICache ( ) ; } else if ( ! codeIsThreadLocal ) { SimulatorProcess :: membarrier ( ) ; } #elif defined(_MSC_VER) && defined(_M_ARM64) FlushInstructionCache ( GetCurrentProcess ( ) , address , length ) ; #elif defined(XP_DARWIN) sys_icache_invalidate ( address , length ) ; #elif defined(__aarch64__) && (defined(__linux__) || defined(__android__)) if ( length == 0 ) { return ; } uintptr_t start = reinterpret_cast < uintptr_t > ( address ) ; uintptr_t dsize = static_cast < uintptr_t > ( dcache_line_size_ ) ; uintptr_t isize = static_cast < uintptr_t > ( icache_line_size_ ) ; uintptr_t dline = start & ~ ( dsize - 1 ) ; uintptr_t iline = start & ~ ( isize - 1 ) ; VIXL_ASSERT ( IsPowerOf2 ( dsize ) ) ; VIXL_ASSERT ( IsPowerOf2 ( isize ) ) ; uintptr_t end = start + length ; do { __asm__ __volatile__ ( "   dc    civac, %[dline]\n" : : [ dline ] "r" ( dline ) : "memory" ) ; dline += dsize ; } while ( dline < end ) ; __asm__ __volatile__ ( "   dsb   ish\n" : : : "memory" ) ; do { __asm__ __volatile__ ( "   ic   ivau, %[iline]\n" : : [ iline ] "r" ( iline ) : "memory" ) ; iline += isize ; } while ( iline < end ) ; __asm__ __volatile__ ( "   dsb  ish\n" "   isb\n" : : : "memory" ) ; if ( ! codeIsThreadLocal ) { JSContext * cx = js :: TlsContext . get ( ) ; if ( ! cx || ! cx -> isMainThreadContext ( ) ) { MOZ_RELEASE_ASSERT ( CPU :: CanFlushICacheFromBackgroundThreads ( ) ) ; if ( membarrier ( MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE , 0 ) != 0 ) { MOZ_CRASH ( "membarrier can't be executed" ) ; } } } #else USE ( address , length ) ; #endif }
nsWindow :: DrawWindowUnderlay ( LayerManagerComposite * aManager , LayoutDeviceIntRect aRect ) { if ( Destroyed ( ) ) { return ; } MOZ_ASSERT ( mLayerViewSupport ) ; GeckoLayerClient :: LocalRef client = mLayerViewSupport -> GetLayerClient ( ) ; LayerRenderer :: Frame :: LocalRef frame = client -> CreateFrame ( ) ; mLayerRendererFrame = frame ; if ( NS_WARN_IF ( ! mLayerRendererFrame ) ) { return ; } if ( ! WidgetPaintsBackground ( ) ) { return ; } frame -> BeginDrawing ( ) ; }
static void opj_t2_putcommacode ( opj_bio_t * bio , OPJ_INT32 n ) { while ( -- n >= 0 ) { opj_bio_write ( bio , 1 , 1 ) ; } opj_bio_write ( bio , 0 , 1 ) ; }
Vector < const uint8_t > WasmModuleObject :: GetRawFunctionName ( uint32_t func_index ) { DCHECK_GT ( module ( ) -> functions . size ( ) , func_index ) ; wasm :: ModuleWireBytes wire_bytes ( native_module ( ) -> wire_bytes ( ) ) ; wasm :: WireBytesRef name_ref = module ( ) -> LookupFunctionName ( wire_bytes , func_index ) ; wasm :: WasmName name = wire_bytes . GetName ( name_ref ) ; return Vector < const uint8_t > :: cast ( name ) ; }
static OPJ_BOOL opj_j2k_read_mcc ( opj_j2k_t * p_j2k , OPJ_BYTE * p_header_data , OPJ_UINT32 p_header_size , opj_event_mgr_t * p_manager ) { OPJ_UINT32 i , j ; OPJ_UINT32 l_tmp ; OPJ_UINT32 l_indix ; opj_tcp_t * l_tcp ; opj_simple_mcc_decorrelation_data_t * l_mcc_record ; opj_mct_data_t * l_mct_data ; OPJ_UINT32 l_nb_collections ; OPJ_UINT32 l_nb_comps ; OPJ_UINT32 l_nb_bytes_by_comp ; assert ( p_header_data != 00 ) ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; l_tcp = p_j2k -> m_specific_param . m_decoder . m_state == J2K_STATE_TPH ? & p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] : p_j2k -> m_specific_param . m_decoder . m_default_tcp ; if ( p_header_size < 2 ) { opj_event_msg ( p_manager , EVT_ERROR , "Error reading MCC marker\n" ) ; return OPJ_FALSE ; } opj_read_bytes ( p_header_data , & l_tmp , 2 ) ; p_header_data += 2 ; if ( l_tmp != 0 ) { opj_event_msg ( p_manager , EVT_WARNING , "Cannot take in charge multiple data spanning\n" ) ; return OPJ_TRUE ; } if ( p_header_size < 7 ) { opj_event_msg ( p_manager , EVT_ERROR , "Error reading MCC marker\n" ) ; return OPJ_FALSE ; } opj_read_bytes ( p_header_data , & l_indix , 1 ) ; ++ p_header_data ; l_mcc_record = l_tcp -> m_mcc_records ; for ( i = 0 ; i < l_tcp -> m_nb_mcc_records ; ++ i ) { if ( l_mcc_record -> m_index == l_indix ) { break ; } ++ l_mcc_record ; } if ( i == l_tcp -> m_nb_mcc_records ) { if ( l_tcp -> m_nb_mcc_records == l_tcp -> m_nb_max_mcc_records ) { opj_simple_mcc_decorrelation_data_t * new_mcc_records ; l_tcp -> m_nb_max_mcc_records += OPJ_J2K_MCC_DEFAULT_NB_RECORDS ; new_mcc_records = ( opj_simple_mcc_decorrelation_data_t * ) opj_realloc ( l_tcp -> m_mcc_records , l_tcp -> m_nb_max_mcc_records * sizeof ( opj_simple_mcc_decorrelation_data_t ) ) ; if ( ! new_mcc_records ) { opj_free ( l_tcp -> m_mcc_records ) ; l_tcp -> m_mcc_records = NULL ; l_tcp -> m_nb_max_mcc_records = 0 ; l_tcp -> m_nb_mcc_records = 0 ; opj_event_msg ( p_manager , EVT_ERROR , "Not enough memory to read MCC marker\n" ) ; return OPJ_FALSE ; } l_tcp -> m_mcc_records = new_mcc_records ; l_mcc_record = l_tcp -> m_mcc_records + l_tcp -> m_nb_mcc_records ; memset ( l_mcc_record , 0 , ( l_tcp -> m_nb_max_mcc_records - l_tcp -> m_nb_mcc_records ) * sizeof ( opj_simple_mcc_decorrelation_data_t ) ) ; } l_mcc_record = l_tcp -> m_mcc_records + l_tcp -> m_nb_mcc_records ; } l_mcc_record -> m_index = l_indix ; opj_read_bytes ( p_header_data , & l_tmp , 2 ) ; p_header_data += 2 ; if ( l_tmp != 0 ) { opj_event_msg ( p_manager , EVT_WARNING , "Cannot take in charge multiple data spanning\n" ) ; return OPJ_TRUE ; } opj_read_bytes ( p_header_data , & l_nb_collections , 2 ) ; p_header_data += 2 ; if ( l_nb_collections > 1 ) { opj_event_msg ( p_manager , EVT_WARNING , "Cannot take in charge multiple collections\n" ) ; return OPJ_TRUE ; } p_header_size -= 7 ; for ( i = 0 ; i < l_nb_collections ; ++ i ) { if ( p_header_size < 3 ) { opj_event_msg ( p_manager , EVT_ERROR , "Error reading MCC marker\n" ) ; return OPJ_FALSE ; } opj_read_bytes ( p_header_data , & l_tmp , 1 ) ; ++ p_header_data ; if ( l_tmp != 1 ) { opj_event_msg ( p_manager , EVT_WARNING , "Cannot take in charge collections other than array decorrelation\n" ) ; return OPJ_TRUE ; } opj_read_bytes ( p_header_data , & l_nb_comps , 2 ) ; p_header_data += 2 ; p_header_size -= 3 ; l_nb_bytes_by_comp = 1 + ( l_nb_comps > > 15 ) ; l_mcc_record -> m_nb_comps = l_nb_comps & 0x7fff ; if ( p_header_size < ( l_nb_bytes_by_comp * l_mcc_record -> m_nb_comps + 2 ) ) { opj_event_msg ( p_manager , EVT_ERROR , "Error reading MCC marker\n" ) ; return OPJ_FALSE ; } p_header_size -= ( l_nb_bytes_by_comp * l_mcc_record -> m_nb_comps + 2 ) ; for ( j = 0 ; j < l_mcc_record -> m_nb_comps ; ++ j ) { opj_read_bytes ( p_header_data , & l_tmp , l_nb_bytes_by_comp ) ; p_header_data += l_nb_bytes_by_comp ; if ( l_tmp != j ) { opj_event_msg ( p_manager , EVT_WARNING , "Cannot take in charge collections with indix shuffle\n" ) ; return OPJ_TRUE ; } } opj_read_bytes ( p_header_data , & l_nb_comps , 2 ) ; p_header_data += 2 ; l_nb_bytes_by_comp = 1 + ( l_nb_comps > > 15 ) ; l_nb_comps &= 0x7fff ; if ( l_nb_comps != l_mcc_record -> m_nb_comps ) { opj_event_msg ( p_manager , EVT_WARNING , "Cannot take in charge collections without same number of indixes\n" ) ; return OPJ_TRUE ; } if ( p_header_size < ( l_nb_bytes_by_comp * l_mcc_record -> m_nb_comps + 3 ) ) { opj_event_msg ( p_manager , EVT_ERROR , "Error reading MCC marker\n" ) ; return OPJ_FALSE ; } p_header_size -= ( l_nb_bytes_by_comp * l_mcc_record -> m_nb_comps + 3 ) ; for ( j = 0 ; j < l_mcc_record -> m_nb_comps ; ++ j ) { opj_read_bytes ( p_header_data , & l_tmp , l_nb_bytes_by_comp ) ; p_header_data += l_nb_bytes_by_comp ; if ( l_tmp != j ) { opj_event_msg ( p_manager , EVT_WARNING , "Cannot take in charge collections with indix shuffle\n" ) ; return OPJ_TRUE ; } } opj_read_bytes ( p_header_data , & l_tmp , 3 ) ; p_header_data += 3 ; l_mcc_record -> m_is_irreversible = ! ( ( l_tmp > > 16 ) & 1 ) ; l_mcc_record -> m_decorrelation_array = 00 ; l_mcc_record -> m_offset_array = 00 ; l_indix = l_tmp & 0xff ; if ( l_indix != 0 ) { l_mct_data = l_tcp -> m_mct_records ; for ( j = 0 ; j < l_tcp -> m_nb_mct_records ; ++ j ) { if ( l_mct_data -> m_index == l_indix ) { l_mcc_record -> m_decorrelation_array = l_mct_data ; break ; } ++ l_mct_data ; } if ( l_mcc_record -> m_decorrelation_array == 00 ) { opj_event_msg ( p_manager , EVT_ERROR , "Error reading MCC marker\n" ) ; return OPJ_FALSE ; } } l_indix = ( l_tmp > > 8 ) & 0xff ; if ( l_indix != 0 ) { l_mct_data = l_tcp -> m_mct_records ; for ( j = 0 ; j < l_tcp -> m_nb_mct_records ; ++ j ) { if ( l_mct_data -> m_index == l_indix ) { l_mcc_record -> m_offset_array = l_mct_data ; break ; } ++ l_mct_data ; } if ( l_mcc_record -> m_offset_array == 00 ) { opj_event_msg ( p_manager , EVT_ERROR , "Error reading MCC marker\n" ) ; return OPJ_FALSE ; } } } if ( p_header_size != 0 ) { opj_event_msg ( p_manager , EVT_ERROR , "Error reading MCC marker\n" ) ; return OPJ_FALSE ; } ++ l_tcp -> m_nb_mcc_records ; return OPJ_TRUE ; }
std :: ostream & operator < < ( std :: ostream & os , ScopeInfo :: VariableAllocationInfo var_info ) { switch ( var_info ) { case ScopeInfo :: VariableAllocationInfo :: NONE : return os < < "NONE" ; case ScopeInfo :: VariableAllocationInfo :: STACK : return os < < "STACK" ; case ScopeInfo :: VariableAllocationInfo :: CONTEXT : return os < < "CONTEXT" ; case ScopeInfo :: VariableAllocationInfo :: UNUSED : return os < < "UNUSED" ; } UNREACHABLE ( ) ; return os ; }
static void init_frame ( VP8D_COMP * pbi ) { VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; if ( pc -> frame_type == KEY_FRAME ) { vpx_memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; vp8_init_mbmode_probs ( pc ) ; vp8_default_coef_probs ( pc ) ; vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; xd -> mb_segement_abs_delta = SEGMENT_DELTADATA ; vpx_memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ; vpx_memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ; pc -> refresh_golden_frame = 1 ; pc -> refresh_alt_ref_frame = 1 ; pc -> copy_buffer_to_gf = 0 ; pc -> copy_buffer_to_arf = 0 ; pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] = 0 ; pc -> ref_frame_sign_bias [ ALTREF_FRAME ] = 0 ; } else { if ( ! pc -> use_bilinear_mc_filter ) { xd -> subpixel_predict = vp8_sixtap_predict4x4 ; xd -> subpixel_predict8x4 = vp8_sixtap_predict8x4 ; xd -> subpixel_predict8x8 = vp8_sixtap_predict8x8 ; xd -> subpixel_predict16x16 = vp8_sixtap_predict16x16 ; } else { xd -> subpixel_predict = vp8_bilinear_predict4x4 ; xd -> subpixel_predict8x4 = vp8_bilinear_predict8x4 ; xd -> subpixel_predict8x8 = vp8_bilinear_predict8x8 ; xd -> subpixel_predict16x16 = vp8_bilinear_predict16x16 ; } if ( pbi -> decoded_key_frame && pbi -> ec_enabled && ! pbi -> ec_active ) pbi -> ec_active = 1 ; } xd -> left_context = & pc -> left_context ; xd -> mode_info_context = pc -> mi ; xd -> frame_type = pc -> frame_type ; xd -> mode_info_context -> mbmi . mode = DC_PRED ; xd -> mode_info_stride = pc -> mode_info_stride ; xd -> corrupted = 0 ; xd -> fullpixel_mask = 0xffffffff ; if ( pc -> full_pixel ) xd -> fullpixel_mask = 0xfffffff8 ; }
RegExpCompartment :: get ( JSContext * cx , JSAtom * keyAtom , JSAtom * source , RegExpFlag flags , Type type , RegExpGuard * g ) { Key key ( keyAtom , flags , type ) ; Map :: AddPtr p = map_ . lookupForAdd ( key ) ; if ( p ) { g -> init ( * p -> value ) ; return true ; } ScopedDeletePtr < RegExpShared > shared ( cx -> new_ < RegExpShared > ( cx -> runtime , flags ) ) ; if ( ! shared ) return false ; if ( ! shared -> compile ( cx , source ) ) return false ; if ( ! map_ . relookupOrAdd ( p , key , shared ) ) { js_ReportOutOfMemory ( cx ) ; return false ; } g -> init ( * shared . forget ( ) ) ; return true ; }
RUNTIME_FUNCTION ( Runtime_DeleteLookupSlot ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 1 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( String , name , 0 ) ; int index ; PropertyAttributes attributes ; InitializationFlag flag ; VariableMode mode ; Handle < Object > holder = isolate -> context ( ) -> Lookup ( name , FOLLOW_CHAINS , & index , & attributes , & flag , & mode ) ; if ( holder . is_null ( ) ) { if ( isolate -> has_pending_exception ( ) ) return ReadOnlyRoots ( isolate ) . exception ( ) ; return ReadOnlyRoots ( isolate ) . true_value ( ) ; } if ( holder -> IsContext ( ) || holder -> IsModule ( ) ) { return ReadOnlyRoots ( isolate ) . false_value ( ) ; } Handle < JSReceiver > object = Handle < JSReceiver > :: cast ( holder ) ; Maybe < bool > result = JSReceiver :: DeleteProperty ( object , name ) ; MAYBE_RETURN ( result , ReadOnlyRoots ( isolate ) . exception ( ) ) ; return isolate -> heap ( ) -> ToBoolean ( result . FromJust ( ) ) ; }
get_cupsd_conf ( http_t * http , _cups_globals_t * cg , time_t last_update , char * name , size_t namesize , int * remote ) { int fd ; #ifndef WIN32 struct stat info ; #endif /* WIN32 */ http_status_t status ; char host [ HTTP_MAX_HOST ] ; httpGetHostname ( http , host , sizeof ( host ) ) ; if ( _cups_strcasecmp ( cg -> cupsd_hostname , host ) ) invalidate_cupsd_cache ( cg ) ; snprintf ( name , namesize , "%s/cupsd.conf" , cg -> cups_serverroot ) ; * remote = 0 ; #ifndef WIN32 if ( ! _cups_strcasecmp ( host , "localhost" ) && ! access ( name , R_OK ) ) { if ( stat ( name , & info ) ) { char message [ 1024 ] ; snprintf ( message , sizeof ( message ) , _cupsLangString ( cupsLangDefault ( ) , _ ( "stat of %s failed: %s" ) ) , name , strerror ( errno ) ) ; _cupsSetError ( IPP_STATUS_ERROR_INTERNAL , message , 0 ) ; * name = '\0' ; return ( HTTP_STATUS_SERVER_ERROR ) ; } else if ( last_update && info . st_mtime <= last_update ) status = HTTP_STATUS_NOT_MODIFIED ; else status = HTTP_STATUS_OK ; } else #endif /* !WIN32 */ { if ( ( fd = cupsTempFd ( name , ( int ) namesize ) ) < 0 ) { * name = '\0' ; _cupsSetError ( IPP_STATUS_ERROR_INTERNAL , NULL , 0 ) ; invalidate_cupsd_cache ( cg ) ; return ( HTTP_STATUS_SERVER_ERROR ) ; } * remote = 1 ; httpClearFields ( http ) ; if ( last_update ) httpSetField ( http , HTTP_FIELD_IF_MODIFIED_SINCE , httpGetDateString ( last_update ) ) ; status = cupsGetFd ( http , "/admin/conf/cupsd.conf" , fd ) ; close ( fd ) ; if ( status != HTTP_STATUS_OK ) { unlink ( name ) ; * name = '\0' ; } } return ( status ) ; }
void processInputBuffer ( client * c ) { server . current_client = c ; while ( sdslen ( c -> querybuf ) ) { if ( ! ( c -> flags & CLIENT_SLAVE ) && clientsArePaused ( ) ) break ; if ( c -> flags & CLIENT_BLOCKED ) break ; if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ; if ( ! c -> reqtype ) { if ( c -> querybuf [ 0 ] == '*' ) { c -> reqtype = PROTO_REQ_MULTIBULK ; } else { c -> reqtype = PROTO_REQ_INLINE ; } } if ( c -> reqtype == PROTO_REQ_INLINE ) { if ( processInlineBuffer ( c ) != C_OK ) break ; } else if ( c -> reqtype == PROTO_REQ_MULTIBULK ) { if ( processMultibulkBuffer ( c ) != C_OK ) break ; } else { serverPanic ( "Unknown request type" ) ; } if ( c -> argc == 0 ) { resetClient ( c ) ; } else { if ( processCommand ( c ) == C_OK ) resetClient ( c ) ; if ( server . current_client == NULL ) break ; } } server . current_client = NULL ; }
UnixSocketImpl :: Accept ( ) { if ( ! mConnector ) { NS_WARNING ( "No connector object available!" ) ; return ; } mConnector -> CreateAddr ( true , mAddrSize , & mAddr , nullptr ) ; if ( mFd . get ( ) < 0 ) { mFd = mConnector -> Create ( ) ; if ( mFd . get ( ) < 0 ) { return ; } if ( ! SetNonblockFlags ( ) ) { return ; } if ( bind ( mFd . get ( ) , & mAddr , mAddrSize ) ) { #ifdef DEBUG LOG ( "...bind(%d) gave errno %d" , mFd . get ( ) , errno ) ; #endif return ; } if ( listen ( mFd . get ( ) , 1 ) ) { #ifdef DEBUG LOG ( "...listen(%d) gave errno %d" , mFd . get ( ) , errno ) ; #endif return ; } } SetUpIO ( ) ; }
bool LoadElimination :: AbstractState :: Equals ( AbstractState const * that ) const { if ( this -> checks_ ) { if ( ! that -> checks_ || ! that -> checks_ -> Equals ( this -> checks_ ) ) { return false ; } } else if ( that -> checks_ ) { return false ; } if ( this -> elements_ ) { if ( ! that -> elements_ || ! that -> elements_ -> Equals ( this -> elements_ ) ) { return false ; } } else if ( that -> elements_ ) { return false ; } for ( size_t i = 0u ; i < arraysize ( fields_ ) ; ++ i ) { AbstractField const * this_field = this -> fields_ [ i ] ; AbstractField const * that_field = that -> fields_ [ i ] ; if ( this_field ) { if ( ! that_field || ! that_field -> Equals ( this_field ) ) return false ; } else if ( that_field ) { return false ; } } if ( this -> maps_ ) { if ( ! that -> maps_ || ! that -> maps_ -> Equals ( this -> maps_ ) ) { return false ; } } else if ( that -> maps_ ) { return false ; } return true ; }
size_t Heap :: CommittedMemory ( ) { if ( ! HasBeenSetUp ( ) ) return 0 ; return new_space_ -> CommittedMemory ( ) + CommittedOldGenerationMemory ( ) ; }
static void AdvanceBytecodeOffsetOrReturn ( MacroAssembler * masm , Register bytecode_array , Register bytecode_offset , Register bytecode , Register scratch1 , Register scratch2 , Label * if_return ) { Register bytecode_size_table = scratch1 ; DCHECK ( ! AreAliased ( bytecode_array , bytecode_offset , bytecode_size_table , bytecode ) ) ; __ li ( bytecode_size_table , ExternalReference :: bytecode_size_table_address ( ) ) ; Label process_bytecode , extra_wide ; STATIC_ASSERT ( 0 == static_cast < int > ( interpreter :: Bytecode :: kWide ) ) ; STATIC_ASSERT ( 1 == static_cast < int > ( interpreter :: Bytecode :: kExtraWide ) ) ; STATIC_ASSERT ( 2 == static_cast < int > ( interpreter :: Bytecode :: kDebugBreakWide ) ) ; STATIC_ASSERT ( 3 == static_cast < int > ( interpreter :: Bytecode :: kDebugBreakExtraWide ) ) ; __ Branch ( & process_bytecode , hi , bytecode , Operand ( 3 ) ) ; __ And ( scratch2 , bytecode , Operand ( 1 ) ) ; __ Branch ( & extra_wide , ne , scratch2 , Operand ( zero_reg ) ) ; __ Addu ( bytecode_offset , bytecode_offset , Operand ( 1 ) ) ; __ Addu ( scratch2 , bytecode_array , bytecode_offset ) ; __ lbu ( bytecode , MemOperand ( scratch2 ) ) ; __ Addu ( bytecode_size_table , bytecode_size_table , Operand ( kIntSize * interpreter :: Bytecodes :: kBytecodeCount ) ) ; __ jmp ( & process_bytecode ) ; __ bind ( & extra_wide ) ; __ Addu ( bytecode_offset , bytecode_offset , Operand ( 1 ) ) ; __ Addu ( scratch2 , bytecode_array , bytecode_offset ) ; __ lbu ( bytecode , MemOperand ( scratch2 ) ) ; __ Addu ( bytecode_size_table , bytecode_size_table , Operand ( 2 * kIntSize * interpreter :: Bytecodes :: kBytecodeCount ) ) ; __ bind ( & process_bytecode ) ; #define JUMP_IF_EQUAL(NAME)          \   __ Branch(if_return, eq, bytecode, \  Operand(static_cast<int>(interpreter::Bytecode::k##NAME))); RETURN_BYTECODE_LIST ( JUMP_IF_EQUAL ) #undef JUMP_IF_EQUAL __ Lsa ( scratch2 , bytecode_size_table , bytecode , 2 ) ; __ lw ( scratch2 , MemOperand ( scratch2 ) ) ; __ Addu ( bytecode_offset , bytecode_offset , scratch2 ) ; }
Response V8RuntimeAgentImpl :: releaseObject ( const String16 & objectId ) { InjectedScript :: ObjectScope scope ( m_session , objectId ) ; Response response = scope . initialize ( ) ; if ( ! response . isSuccess ( ) ) return response ; scope . injectedScript ( ) -> releaseObject ( objectId ) ; return Response :: OK ( ) ; }
XPCConvert :: JSErrorToXPCException ( const char * message , const char * ifaceName , const char * methodName , const JSErrorReport * report , nsIException * * exceptn ) { AutoJSContext cx ; nsresult rv = NS_ERROR_FAILURE ; RefPtr < nsScriptError > data ; if ( report ) { nsAutoString bestMessage ; if ( report && report -> ucmessage ) { bestMessage = static_cast < const char16_t * > ( report -> ucmessage ) ; } else if ( message ) { CopyASCIItoUTF16 ( message , bestMessage ) ; } else { bestMessage . AssignLiteral ( "JavaScript Error" ) ; } const char16_t * uclinebuf = static_cast < const char16_t * > ( report -> uclinebuf ) ; data = new nsScriptError ( ) ; data -> InitWithWindowID ( bestMessage , NS_ConvertASCIItoUTF16 ( report -> filename ) , uclinebuf ? nsDependentString ( uclinebuf ) : EmptyString ( ) , report -> lineno , report -> uctokenptr - report -> uclinebuf , report -> flags , NS_LITERAL_CSTRING ( "XPConnect JavaScript" ) , nsJSUtils :: GetCurrentlyRunningCodeInnerWindowID ( cx ) ) ; } if ( data ) { nsAutoCString formattedMsg ; data -> ToString ( formattedMsg ) ; rv = ConstructException ( NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS , formattedMsg . get ( ) , ifaceName , methodName , static_cast < nsIScriptError * > ( data . get ( ) ) , exceptn , nullptr , nullptr ) ; } else { rv = ConstructException ( NS_ERROR_XPC_JAVASCRIPT_ERROR , nullptr , ifaceName , methodName , nullptr , exceptn , nullptr , nullptr ) ; } return rv ; }
static DWORD WINAPI InitDwriteBG ( LPVOID lpdwThreadParam ) { SetThreadPriority ( GetCurrentThread ( ) , THREAD_MODE_BACKGROUND_BEGIN ) ; LOGREGISTRY ( L"loading dwrite.dll" ) ; HMODULE dwdll = LoadLibraryW ( L"dwrite.dll" ) ; if ( dwdll ) { decltype ( DWriteCreateFactory ) * createDWriteFactory = ( decltype ( DWriteCreateFactory ) * ) GetProcAddress ( dwdll , "DWriteCreateFactory" ) ; if ( createDWriteFactory ) { LOGREGISTRY ( L"creating dwrite factory" ) ; IDWriteFactory * factory ; HRESULT hr = createDWriteFactory ( DWRITE_FACTORY_TYPE_SHARED , __uuidof ( IDWriteFactory ) , reinterpret_cast < IUnknown * * > ( & factory ) ) ; if ( SUCCEEDED ( hr ) ) { LOGREGISTRY ( L"dwrite factory done" ) ; factory -> Release ( ) ; LOGREGISTRY ( L"freed factory" ) ; } else { LOGREGISTRY ( L"failed to create factory" ) ; } } } SetThreadPriority ( GetCurrentThread ( ) , THREAD_MODE_BACKGROUND_END ) ; return 0 ; }
v8 :: Local < v8 :: Value > DebugStackTraceIterator :: GetReturnValue ( ) const { DCHECK ( ! Done ( ) ) ; if ( frame_inspector_ -> IsWasm ( ) ) return v8 :: Local < v8 :: Value > ( ) ; bool is_optimized = iterator_ . frame ( ) -> is_optimized ( ) ; if ( is_optimized || ! is_top_frame_ || ! isolate_ -> debug ( ) -> IsBreakAtReturn ( iterator_ . javascript_frame ( ) ) ) { return v8 :: Local < v8 :: Value > ( ) ; } return Utils :: ToLocal ( isolate_ -> debug ( ) -> return_value_handle ( ) ) ; }
void vp9_setup_dst_planes ( MACROBLOCKD * xd , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , src -> alpha_buffer } ; const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , src -> alpha_stride } ; int i ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { struct macroblockd_plane * const pd = & xd -> plane [ i ] ; setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ; } }
CompilationDependencies :: DependOnInitialMapInstanceSizePrediction ( const JSFunctionRef & function ) { MapRef initial_map = DependOnInitialMap ( function ) ; int instance_size = function . InitialMapInstanceSizeWithMinSlack ( ) ; dependencies_ . push_front ( new ( zone_ ) InitialMapInstanceSizePredictionDependency ( function , instance_size ) ) ; DCHECK_LE ( instance_size , function . initial_map ( ) . instance_size ( ) ) ; return SlackTrackingPrediction ( initial_map , instance_size ) ; }
png_handle_hIST ( png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) { unsigned int num , i ; png_uint_16 readbuf [ PNG_MAX_PALETTE_LENGTH ] ; png_debug ( 1 , "in png_handle_hIST" ) ; if ( ! ( png_ptr -> mode & PNG_HAVE_IHDR ) ) png_chunk_error ( png_ptr , "missing IHDR" ) ; else if ( ( png_ptr -> mode & PNG_HAVE_IDAT ) || ! ( png_ptr -> mode & PNG_HAVE_PLTE ) ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "out of place" ) ; return ; } else if ( info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_hIST ) ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "duplicate" ) ; return ; } num = length / 2 ; if ( num != png_ptr -> num_palette || num > PNG_MAX_PALETTE_LENGTH ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "invalid" ) ; return ; } for ( i = 0 ; i < num ; i ++ ) { png_byte buf [ 2 ] ; png_crc_read ( png_ptr , buf , 2 ) ; readbuf [ i ] = png_get_uint_16 ( buf ) ; } if ( png_crc_finish ( png_ptr , 0 ) ) return ; png_set_hIST ( png_ptr , info_ptr , readbuf ) ; }
TF_BUILTIN ( WeakSetHas , WeakCollectionsBuiltinsAssembler ) { Node * const receiver = Parameter ( Descriptor :: kReceiver ) ; Node * const key = Parameter ( Descriptor :: kKey ) ; Node * const context = Parameter ( Descriptor :: kContext ) ; Label return_false ( this ) ; ThrowIfNotInstanceType ( context , receiver , JS_WEAK_SET_TYPE , "WeakSet.prototype.has" ) ; Node * const table = LoadTable ( CAST ( receiver ) ) ; Node * const index = CallBuiltin ( Builtins :: kWeakMapLookupHashIndex , context , table , key ) ; GotoIf ( WordEqual ( index , SmiConstant ( - 1 ) ) , & return_false ) ; Return ( TrueConstant ( ) ) ; BIND ( & return_false ) ; Return ( FalseConstant ( ) ) ; }
static void wnm_sleep_mode_exit_success ( struct wpa_supplicant * wpa_s , const u8 * frm , u16 key_len_total ) { u8 * ptr , * end ; u8 gtk_len ; wpa_drv_wnm_oper ( wpa_s , WNM_SLEEP_EXIT_CONFIRM , wpa_s -> bssid , NULL , NULL ) ; ptr = ( u8 * ) frm + 1 + 1 + 2 ; end = ptr + key_len_total ; wpa_hexdump_key ( MSG_DEBUG , "WNM: Key Data" , ptr , key_len_total ) ; while ( ptr + 1 < end ) { if ( ptr + 2 + ptr [ 1 ] > end ) { wpa_printf ( MSG_DEBUG , "WNM: Invalid Key Data element " "length" ) ; if ( end > ptr ) { wpa_hexdump ( MSG_DEBUG , "WNM: Remaining data" , ptr , end - ptr ) ; } break ; } if ( * ptr == WNM_SLEEP_SUBELEM_GTK ) { if ( ptr [ 1 ] < 11 + 5 ) { wpa_printf ( MSG_DEBUG , "WNM: Too short GTK " "subelem" ) ; break ; } gtk_len = * ( ptr + 4 ) ; if ( ptr [ 1 ] < 11 + gtk_len || gtk_len < 5 || gtk_len > 32 ) { wpa_printf ( MSG_DEBUG , "WNM: Invalid GTK " "subelem" ) ; break ; } wpa_wnmsleep_install_key ( wpa_s -> wpa , WNM_SLEEP_SUBELEM_GTK , ptr ) ; ptr += 13 + gtk_len ; #ifdef CONFIG_IEEE80211W } else if ( * ptr == WNM_SLEEP_SUBELEM_IGTK ) { if ( ptr [ 1 ] < 2 + 6 + WPA_IGTK_LEN ) { wpa_printf ( MSG_DEBUG , "WNM: Too short IGTK " "subelem" ) ; break ; } wpa_wnmsleep_install_key ( wpa_s -> wpa , WNM_SLEEP_SUBELEM_IGTK , ptr ) ; ptr += 10 + WPA_IGTK_LEN ; #endif /* CONFIG_IEEE80211W */ } else break ; } }
TfLiteStatus PrepareSimple ( TfLiteContext * context , TfLiteNode * node ) { TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 2 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; OpContext op_context ( context , node ) ; TF_LITE_ENSURE_TYPES_EQ ( context , op_context . axis -> type , kTfLiteInt32 ) ; TF_LITE_ENSURE_OK ( context , InitializeTemporaries ( context , node , & op_context ) ) ; TfLiteTensor * resolved_axis = GetTemporary ( context , node , 1 ) ; if ( ! IsConstantTensor ( op_context . axis ) ) { SetTensorToDynamic ( op_context . output ) ; SetTensorToDynamic ( resolved_axis ) ; return kTfLiteOk ; } resolved_axis -> allocation_type = kTfLiteArenaRw ; TF_LITE_ENSURE_OK ( context , ResizeTempAxis ( context , & op_context , resolved_axis ) ) ; TF_LITE_ENSURE_OK ( context , ResizeOutputTensor ( context , & op_context ) ) ; return kTfLiteOk ; }
Reduction JSTypedLowering :: ReduceJSLoadContext ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSLoadContext , node -> opcode ( ) ) ; ContextAccess const & access = ContextAccessOf ( node -> op ( ) ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * context = NodeProperties :: GetContextInput ( node ) ; Node * control = graph ( ) -> start ( ) ; for ( size_t i = 0 ; i < access . depth ( ) ; ++ i ) { context = effect = graph ( ) -> NewNode ( simplified ( ) -> LoadField ( AccessBuilder :: ForContextSlot ( Context :: PREVIOUS_INDEX ) ) , context , effect , control ) ; } node -> ReplaceInput ( 0 , context ) ; node -> ReplaceInput ( 1 , effect ) ; node -> AppendInput ( jsgraph ( ) -> zone ( ) , control ) ; NodeProperties :: ChangeOp ( node , simplified ( ) -> LoadField ( AccessBuilder :: ForContextSlot ( access . index ( ) ) ) ) ; return Changed ( node ) ; }
RUNTIME_FUNCTION ( Runtime_IsLiftoffFunction ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 1 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSFunction , function , 0 ) ; CHECK ( WasmExportedFunction :: IsWasmExportedFunction ( * function ) ) ; Handle < WasmExportedFunction > exp_fun = Handle < WasmExportedFunction > :: cast ( function ) ; wasm :: NativeModule * native_module = exp_fun -> instance ( ) -> module_object ( ) -> native_module ( ) ; uint32_t func_index = exp_fun -> function_index ( ) ; return isolate -> heap ( ) -> ToBoolean ( native_module -> has_code ( func_index ) && native_module -> code ( func_index ) -> is_liftoff ( ) ) ; }
image_transform_png_set_gray_to_rgb_mod ( PNG_CONST image_transform * this , image_pixel * that , png_const_structp pp , PNG_CONST transform_display * display ) { if ( ( that -> colour_type & PNG_COLOR_MASK_COLOR ) == 0 && that -> have_tRNS ) image_pixel_add_alpha ( that , & display -> this ) ; if ( that -> colour_type == PNG_COLOR_TYPE_GRAY ) { if ( that -> bit_depth < 8 ) that -> sample_depth = that -> bit_depth = 8 ; that -> colour_type = PNG_COLOR_TYPE_RGB ; } else if ( that -> colour_type == PNG_COLOR_TYPE_GRAY_ALPHA ) that -> colour_type = PNG_COLOR_TYPE_RGB_ALPHA ; this -> next -> mod ( this -> next , that , pp , display ) ; }
Scope :: Scope ( Zone * zone , ScopeType scope_type , Handle < ScopeInfo > scope_info ) : zone_ ( zone ) , outer_scope_ ( nullptr ) , variables_ ( zone ) , scope_info_ ( scope_info ) , scope_type_ ( scope_type ) { DCHECK ( ! scope_info . is_null ( ) ) ; SetDefaults ( ) ; #ifdef DEBUG already_resolved_ = true ; #endif if ( scope_info -> CallsSloppyEval ( ) ) scope_calls_eval_ = true ; set_language_mode ( scope_info -> language_mode ( ) ) ; num_heap_slots_ = scope_info -> ContextLength ( ) ; DCHECK_LE ( Context :: MIN_CONTEXT_SLOTS , num_heap_slots_ ) ; must_use_preparsed_scope_data_ = true ; }
void SyncPauseCompositor ( ) { if ( RefPtr < CompositorBridgeParent > bridge = window . GetCompositorBridgeParent ( ) ) { bridge -> SchedulePauseOnCompositorThread ( ) ; mCompositorPaused = true ; } }
struct clock_source * dce80_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce110_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } BREAK_TO_DEBUGGER ( ) ; return NULL ; }
CanFakeSync ( FrameEntry * fe ) { return fe -> isNotType ( JSVAL_TYPE_OBJECT ) && fe -> isNotType ( JSVAL_TYPE_STRING ) && fe -> isNotType ( JSVAL_TYPE_DOUBLE ) && fe -> isNotType ( JSVAL_TYPE_MAGIC ) ; }
Token :: Value Scanner :: SkipMultiLineComment ( ) { DCHECK_EQ ( c0_ , '*' ) ; Advance ( ) ; while ( c0_ != kEndOfInput ) { DCHECK ( ! unibrow :: IsLineTerminator ( kEndOfInput ) ) ; if ( ! HasLineTerminatorBeforeNext ( ) && unibrow :: IsLineTerminator ( c0_ ) ) { next ( ) . after_line_terminator = true ; } while ( V8_UNLIKELY ( c0_ == '*' ) ) { Advance ( ) ; if ( c0_ == '/' ) { Advance ( ) ; return Token :: WHITESPACE ; } } Advance ( ) ; } return Token :: ILLEGAL ; }
static void tg3_read_vpd ( struct tg3 * tp ) { u8 * vpd_data ; unsigned int block_end , rosize , len ; u32 vpdlen ; int j , i = 0 ; vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen ) ; if ( ! vpd_data ) goto out_no_vpd ; i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA ) ; if ( i < 0 ) goto out_not_found ; rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] ) ; block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize ; i += PCI_VPD_LRDT_TAG_SIZE ; if ( block_end > vpdlen ) goto out_not_found ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_MFR_ID ) ; if ( j > 0 ) { len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end || len != 4 || memcmp ( & vpd_data [ j ] , "1028" , 4 ) ) goto partno ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ; if ( j < 0 ) goto partno ; len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end ) goto partno ; memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; strncat ( tp -> fw_ver , " bc " , vpdlen - len - 1 ) ; } partno : i = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_PARTNO ) ; if ( i < 0 ) goto out_not_found ; len = pci_vpd_info_field_size ( & vpd_data [ i ] ) ; i += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( len > TG3_BPN_SIZE || ( len + i ) > vpdlen ) goto out_not_found ; memcpy ( tp -> board_part_number , & vpd_data [ i ] , len ) ; out_not_found : kfree ( vpd_data ) ; if ( tp -> board_part_number [ 0 ] ) return ; out_no_vpd : if ( tg3_asic_rev ( tp ) == ASIC_REV_5717 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717 || tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717_C ) strcpy ( tp -> board_part_number , "BCM5717" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5718 ) strcpy ( tp -> board_part_number , "BCM5718" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57780 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57780 ) strcpy ( tp -> board_part_number , "BCM57780" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57760 ) strcpy ( tp -> board_part_number , "BCM57760" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57790 ) strcpy ( tp -> board_part_number , "BCM57790" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57788 ) strcpy ( tp -> board_part_number , "BCM57788" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57765 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57761 ) strcpy ( tp -> board_part_number , "BCM57761" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57765 ) strcpy ( tp -> board_part_number , "BCM57765" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57781 ) strcpy ( tp -> board_part_number , "BCM57781" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57785 ) strcpy ( tp -> board_part_number , "BCM57785" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57791 ) strcpy ( tp -> board_part_number , "BCM57791" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57795 ) strcpy ( tp -> board_part_number , "BCM57795" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57766 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57762 ) strcpy ( tp -> board_part_number , "BCM57762" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57766 ) strcpy ( tp -> board_part_number , "BCM57766" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57782 ) strcpy ( tp -> board_part_number , "BCM57782" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57786 ) strcpy ( tp -> board_part_number , "BCM57786" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_5906 ) { strcpy ( tp -> board_part_number , "BCM95906" ) ; } else { nomatch : strcpy ( tp -> board_part_number , "none" ) ; } }
Reduction JSCallReducer :: ReduceCollectionPrototypeSize ( Node * node , CollectionKind collection_kind ) { DCHECK_EQ ( IrOpcode :: kJSCall , node -> opcode ( ) ) ; Node * receiver = NodeProperties :: GetValueInput ( node , 1 ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; if ( NodeProperties :: HasInstanceTypeWitness ( isolate ( ) , receiver , effect , InstanceTypeForCollectionKind ( collection_kind ) ) ) { Node * table = effect = graph ( ) -> NewNode ( simplified ( ) -> LoadField ( AccessBuilder :: ForJSCollectionTable ( ) ) , receiver , effect , control ) ; Node * value = effect = graph ( ) -> NewNode ( simplified ( ) -> LoadField ( AccessBuilder :: ForOrderedHashTableBaseNumberOfElements ( ) ) , table , effect , control ) ; ReplaceWithValue ( node , value , effect , control ) ; return Replace ( value ) ; } return NoChange ( ) ; }
static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { GradFunContext * s = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; int p , direct ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { direct = 0 ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } for ( p = 0 ; p < 4 && in -> data [ p ] ; p ++ ) { int w = inlink -> w ; int h = inlink -> h ; int r = s -> radius ; if ( p ) { w = s -> chroma_w ; h = s -> chroma_h ; r = s -> chroma_r ; } if ( FFMIN ( w , h ) > 2 * r ) filter ( s , out -> data [ p ] , in -> data [ p ] , w , h , out -> linesize [ p ] , in -> linesize [ p ] , r ) ; else if ( out -> data [ p ] != in -> data [ p ] ) av_image_copy_plane ( out -> data [ p ] , out -> linesize [ p ] , in -> data [ p ] , in -> linesize [ p ] , w , h ) ; } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }
void check_system_chunk ( struct btrfs_trans_handle * trans , u64 type ) { struct btrfs_transaction * cur_trans = trans -> transaction ; struct btrfs_fs_info * fs_info = trans -> fs_info ; struct btrfs_space_info * info ; u64 left ; u64 thresh ; int ret = 0 ; u64 num_devs ; lockdep_assert_held ( & fs_info -> chunk_mutex ) ; info = btrfs_find_space_info ( fs_info , BTRFS_BLOCK_GROUP_SYSTEM ) ; again : spin_lock ( & info -> lock ) ; left = info -> total_bytes - btrfs_space_info_used ( info , true ) ; spin_unlock ( & info -> lock ) ; num_devs = get_profile_num_devs ( fs_info , type ) ; thresh = btrfs_calc_metadata_size ( fs_info , num_devs ) + btrfs_calc_insert_metadata_size ( fs_info , 1 ) ; if ( left < thresh && btrfs_test_opt ( fs_info , ENOSPC_DEBUG ) ) { btrfs_info ( fs_info , "left=%llu, need=%llu, flags=%llu" , left , thresh , type ) ; btrfs_dump_space_info ( fs_info , info , 0 , 0 ) ; } if ( left < thresh ) { u64 flags = btrfs_system_alloc_profile ( fs_info ) ; u64 reserved = atomic64_read ( & cur_trans -> chunk_bytes_reserved ) ; if ( reserved > trans -> chunk_bytes_reserved ) { const u64 min_needed = reserved - thresh ; mutex_unlock ( & fs_info -> chunk_mutex ) ; wait_event ( cur_trans -> chunk_reserve_wait , atomic64_read ( & cur_trans -> chunk_bytes_reserved ) <= min_needed ) ; mutex_lock ( & fs_info -> chunk_mutex ) ; goto again ; } ret = btrfs_alloc_chunk ( trans , flags ) ; } if ( ! ret ) { ret = btrfs_block_rsv_add ( fs_info -> chunk_root , & fs_info -> chunk_block_rsv , thresh , BTRFS_RESERVE_NO_FLUSH ) ; if ( ! ret ) { atomic64_add ( thresh , & cur_trans -> chunk_bytes_reserved ) ; trans -> chunk_bytes_reserved += thresh ; } } }
_cupsSNMPRead ( int fd , cups_snmp_t * packet , double timeout ) { unsigned char buffer [ CUPS_SNMP_MAX_PACKET ] ; ssize_t bytes ; socklen_t addrlen ; http_addr_t address ; DEBUG_printf ( ( "4_cupsSNMPRead(fd=%d, packet=%p, timeout=%.1f)" , fd , packet , timeout ) ) ; if ( fd < 0 || ! packet ) { DEBUG_puts ( "5_cupsSNMPRead: Returning NULL" ) ; return ( NULL ) ; } if ( timeout >= 0.0 ) { int ready ; #ifdef HAVE_POLL struct pollfd pfd ; pfd . fd = fd ; pfd . events = POLLIN ; while ( ( ready = poll ( & pfd , 1 , ( int ) ( timeout * 1000.0 ) ) ) < 0 && ( errno == EINTR || errno == EAGAIN ) ) ; #else fd_set input_set ; struct timeval stimeout ; do { FD_ZERO ( & input_set ) ; FD_SET ( fd , & input_set ) ; stimeout . tv_sec = ( int ) timeout ; stimeout . tv_usec = ( int ) ( ( timeout - stimeout . tv_sec ) * 1000000 ) ; ready = select ( fd + 1 , & input_set , NULL , NULL , & stimeout ) ; } #  ifdef WIN32 while ( ready < 0 && WSAGetLastError ( ) == WSAEINTR ) ; #  else while ( ready < 0 && ( errno == EINTR || errno == EAGAIN ) ) ; #  endif /* WIN32 */ #endif /* HAVE_POLL */ if ( ready <= 0 ) { DEBUG_puts ( "5_cupsSNMPRead: Returning NULL (timeout)" ) ; return ( NULL ) ; } } addrlen = sizeof ( address ) ; if ( ( bytes = recvfrom ( fd , buffer , sizeof ( buffer ) , 0 , ( void * ) & address , & addrlen ) ) < 0 ) { DEBUG_printf ( ( "5_cupsSNMPRead: Returning NULL (%s)" , strerror ( errno ) ) ) ; return ( NULL ) ; } asn1_debug ( "DEBUG: IN " , buffer , ( size_t ) bytes , 0 ) ; asn1_decode_snmp ( buffer , ( size_t ) bytes , packet ) ; memcpy ( & ( packet -> address ) , & address , sizeof ( packet -> address ) ) ; DEBUG_puts ( "5_cupsSNMPRead: Returning packet" ) ; return ( packet ) ; }
Status KeyStoreService :: attestKey ( const String16 & name , const KeymasterArguments & params , :: android :: security :: keymaster :: KeymasterCertificateChain * chain , int32_t * aidl_return ) { if ( ! checkAllowedOperationParams ( params . getParameters ( ) ) ) { * aidl_return = static_cast < int32_t > ( KeyStoreServiceReturnCode ( ErrorCode :: INVALID_ARGUMENT ) ) ; return Status :: ok ( ) ; } uid_t callingUid = IPCThreadState :: self ( ) -> getCallingUid ( ) ; int needsIdAttestation = isDeviceIdAttestationRequested ( params ) ; bool needsUniqueIdAttestation = needsIdAttestation & ID_ATTESTATION_REQUEST_UNIQUE_DEVICE_ID ; bool isPrimaryUserSystemUid = ( callingUid == AID_SYSTEM ) ; bool isSomeUserSystemUid = ( get_app_id ( callingUid ) == AID_SYSTEM ) ; if ( ( needsIdAttestation && ! isSomeUserSystemUid ) || ( needsUniqueIdAttestation && ! isPrimaryUserSystemUid ) ) { * aidl_return = static_cast < int32_t > ( KeyStoreServiceReturnCode ( ErrorCode :: INVALID_ARGUMENT ) ) ; return Status :: ok ( ) ; } AuthorizationSet mutableParams = params . getParameters ( ) ; KeyStoreServiceReturnCode rc = updateParamsForAttestation ( callingUid , & mutableParams ) ; if ( ! rc . isOk ( ) ) { * aidl_return = static_cast < int32_t > ( rc ) ; return Status :: ok ( ) ; } Blob keyBlob ; String8 name8 ( name ) ; rc = mKeyStore -> getKeyForName ( & keyBlob , name8 , callingUid , TYPE_KEYMASTER_10 ) ; if ( ! rc . isOk ( ) ) { * aidl_return = static_cast < int32_t > ( rc ) ; return Status :: ok ( ) ; } KeyStoreServiceReturnCode error ; auto hidlCb = [ & ] ( ErrorCode ret , const hidl_vec < hidl_vec < uint8_t > > & certChain ) { error = ret ; if ( ! error . isOk ( ) ) { return ; } if ( chain ) { * chain = KeymasterCertificateChain ( certChain ) ; } } ; auto hidlKey = blob2hidlVec ( keyBlob ) ; auto dev = mKeyStore -> getDevice ( keyBlob ) ; rc = KS_HANDLE_HIDL_ERROR ( dev -> attestKey ( hidlKey , mutableParams . hidl_data ( ) , hidlCb ) ) ; if ( ! rc . isOk ( ) ) { * aidl_return = static_cast < int32_t > ( rc ) ; return Status :: ok ( ) ; } * aidl_return = static_cast < int32_t > ( error ) ; return Status :: ok ( ) ; }
double log2 ( double x ) { static const double two54 = 1.80143985094819840000e+16 , ivln2hi = 1.44269504072144627571e+00 , ivln2lo = 1.67517131648865118353e-10 ; static const double zero = 0.0 ; static volatile double vzero = 0.0 ; double f , hfsq , hi , lo , r , val_hi , val_lo , w , y ; int32_t i , k , hx ; uint32_t lx ; EXTRACT_WORDS ( hx , lx , x ) ; k = 0 ; if ( hx < 0x00100000 ) { if ( ( ( hx & 0x7FFFFFFF ) | lx ) == 0 ) return - two54 / vzero ; if ( hx < 0 ) return ( x - x ) / zero ; k -= 54 ; x *= two54 ; GET_HIGH_WORD ( hx , x ) ; } if ( hx >= 0x7FF00000 ) return x + x ; if ( hx == 0x3FF00000 && lx == 0 ) return zero ; k += ( hx > > 20 ) - 1023 ; hx &= 0x000FFFFF ; i = ( hx + 0x95F64 ) & 0x100000 ; SET_HIGH_WORD ( x , hx | ( i ^ 0x3FF00000 ) ) ; k += ( i > > 20 ) ; y = static_cast < double > ( k ) ; f = x - 1.0 ; hfsq = 0.5 * f * f ; r = k_log1p ( f ) ; hi = f - hfsq ; SET_LOW_WORD ( hi , 0 ) ; lo = ( f - hi ) - hfsq + r ; val_hi = hi * ivln2hi ; val_lo = ( lo + hi ) * ivln2lo + lo * ivln2hi ; w = y + val_hi ; val_lo += ( y - w ) + val_hi ; val_hi = w ; return val_lo + val_hi ; }
void luaD_call ( lua_State * L , StkId func , int nresults ) { lua_CFunction f ; retry : switch ( ttypetag ( s2v ( func ) ) ) { case LUA_VCCL : f = clCvalue ( s2v ( func ) ) -> f ; goto Cfunc ; case LUA_VLCF : f = fvalue ( s2v ( func ) ) ; Cfunc : { int n ; CallInfo * ci = next_ci ( L ) ; checkstackp ( L , LUA_MINSTACK , func ) ; ci -> nresults = nresults ; ci -> callstatus = CIST_C ; ci -> top = L -> top + LUA_MINSTACK ; ci -> func = func ; L -> ci = ci ; lua_assert ( ci -> top <= L -> stack_last ) ; if ( L -> hookmask & LUA_MASKCALL ) { int narg = cast_int ( L -> top - func ) - 1 ; luaD_hook ( L , LUA_HOOKCALL , - 1 , 1 , narg ) ; } lua_unlock ( L ) ; n = ( * f ) ( L ) ; lua_lock ( L ) ; api_checknelems ( L , n ) ; luaD_poscall ( L , ci , n ) ; break ; } case LUA_VLCL : { CallInfo * ci = next_ci ( L ) ; Proto * p = clLvalue ( s2v ( func ) ) -> p ; int narg = cast_int ( L -> top - func ) - 1 ; int nfixparams = p -> numparams ; int fsize = p -> maxstacksize ; checkstackp ( L , fsize , func ) ; ci -> nresults = nresults ; ci -> u . l . savedpc = p -> code ; ci -> callstatus = 0 ; ci -> top = func + 1 + fsize ; ci -> func = func ; L -> ci = ci ; for ( ; narg < nfixparams ; narg ++ ) setnilvalue ( s2v ( L -> top ++ ) ) ; lua_assert ( ci -> top <= L -> stack_last ) ; luaV_execute ( L , ci ) ; break ; } default : { checkstackp ( L , 1 , func ) ; luaD_tryfuncTM ( L , func ) ; goto retry ; } } }
pngtest_check_io_state ( png_structp png_ptr , png_size_t data_length , png_uint_32 io_op ) { png_uint_32 io_state = png_get_io_state ( png_ptr ) ; int err = 0 ; if ( ( io_state & PNG_IO_MASK_OP ) != io_op ) png_error ( png_ptr , "Incorrect operation in I/O state" ) ; switch ( io_state & PNG_IO_MASK_LOC ) { case PNG_IO_SIGNATURE : if ( data_length > 8 ) err = 1 ; break ; case PNG_IO_CHUNK_HDR : if ( data_length != 8 ) err = 1 ; break ; case PNG_IO_CHUNK_DATA : break ; case PNG_IO_CHUNK_CRC : if ( data_length != 4 ) err = 1 ; break ; default : err = 1 ; } if ( err ) png_error ( png_ptr , "Bad I/O state or buffer size" ) ; }
njs_generate_try_end ( njs_vm_t * vm , njs_generator_t * generator , njs_parser_node_t * node ) { njs_int_t ret ; njs_index_t exit_index ; const njs_str_t * dest_label ; njs_vmcode_finally_t * finally ; njs_generator_patch_t * patch ; njs_generator_block_t * block , * try_block , * catch_block ; njs_generator_try_ctx_t * ctx ; ctx = generator -> context ; try_block = ctx -> try_block ; exit_index = try_block -> index ; catch_block = ctx -> catch_block ; njs_generate_code_finally ( generator , finally , ctx -> exception_index , exit_index , node ) ; if ( try_block -> continuation != NULL || ( catch_block && catch_block -> continuation != NULL ) ) { dest_label = njs_generate_jump_destination ( vm , generator -> block , "try continue" , NJS_GENERATOR_LOOP , & ctx -> try_cont_label , & ctx -> catch_cont_label ) ; if ( njs_slow_path ( dest_label == NULL ) ) { return NJS_ERROR ; } block = njs_generate_find_block ( vm , generator -> block , NJS_GENERATOR_LOOP , dest_label ) ; patch = njs_generate_make_continuation_patch ( vm , block , dest_label , njs_code_offset ( generator , finally ) + offsetof ( njs_vmcode_finally_t , continue_offset ) ) ; if ( njs_slow_path ( patch == NULL ) ) { return NJS_ERROR ; } } if ( try_block -> exit != NULL || ( catch_block != NULL && catch_block -> exit != NULL ) ) { dest_label = njs_generate_jump_destination ( vm , generator -> block , "try break/return" , NJS_GENERATOR_ALL | NJS_GENERATOR_TRY , & ctx -> try_exit_label , & ctx -> catch_exit_label ) ; if ( njs_slow_path ( dest_label == NULL ) ) { return NJS_ERROR ; } block = njs_generate_find_block ( vm , generator -> block , NJS_GENERATOR_ALL | NJS_GENERATOR_TRY , dest_label ) ; if ( block != NULL ) { patch = njs_generate_make_exit_patch ( vm , block , dest_label , njs_code_offset ( generator , finally ) + offsetof ( njs_vmcode_finally_t , break_offset ) ) ; if ( njs_slow_path ( patch == NULL ) ) { return NJS_ERROR ; } } } ret = njs_generate_index_release ( vm , generator , ctx -> exception_index ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } return njs_generator_stack_pop ( vm , generator , ctx ) ; }
static tAVRC_STS avrc_pars_browsing_cmd ( tAVRC_MSG_BROWSE * p_msg , tAVRC_COMMAND * p_result , uint8_t * p_buf , uint16_t buf_len ) { tAVRC_STS status = AVRC_STS_NO_ERROR ; uint8_t * p = p_msg -> p_browse_data ; int count ; uint16_t min_len = 3 ; RETURN_STATUS_IF_FALSE ( AVRC_STS_BAD_CMD , ( p_msg -> browse_len >= min_len ) , "msg too short" ) ; p_result -> pdu = * p ++ ; AVRC_TRACE_DEBUG ( "avrc_pars_browsing_cmd() pdu:0x%x" , p_result -> pdu ) ; p += 2 ; switch ( p_result -> pdu ) { case AVRC_PDU_SET_BROWSED_PLAYER : min_len += 2 ; RETURN_STATUS_IF_FALSE ( AVRC_STS_BAD_CMD , ( p_msg -> browse_len >= min_len ) , "msg too short" ) ; BE_STREAM_TO_UINT16 ( p_result -> br_player . player_id , p ) ; break ; case AVRC_PDU_GET_FOLDER_ITEMS : min_len += 10 ; RETURN_STATUS_IF_FALSE ( AVRC_STS_BAD_CMD , ( p_msg -> browse_len >= min_len ) , "msg too short" ) ; STREAM_TO_UINT8 ( p_result -> get_items . scope , p ) ; if ( p_result -> get_items . scope > AVRC_SCOPE_NOW_PLAYING ) { status = AVRC_STS_BAD_SCOPE ; } BE_STREAM_TO_UINT32 ( p_result -> get_items . start_item , p ) ; BE_STREAM_TO_UINT32 ( p_result -> get_items . end_item , p ) ; if ( p_result -> get_items . start_item > p_result -> get_items . end_item ) { status = AVRC_STS_BAD_RANGE ; } STREAM_TO_UINT8 ( p_result -> get_items . attr_count , p ) ; p_result -> get_items . p_attr_list = NULL ; if ( p_result -> get_items . attr_count && p_buf && ( p_result -> get_items . attr_count != AVRC_FOLDER_ITEM_COUNT_NONE ) ) { p_result -> get_items . p_attr_list = ( uint32_t * ) p_buf ; count = p_result -> get_items . attr_count ; if ( buf_len < ( count < < 2 ) ) p_result -> get_items . attr_count = count = ( buf_len > > 2 ) ; for ( int idx = 0 ; idx < count ; idx ++ ) { min_len += 4 ; RETURN_STATUS_IF_FALSE ( AVRC_STS_BAD_CMD , ( p_msg -> browse_len >= min_len ) , "msg too short" ) ; BE_STREAM_TO_UINT32 ( p_result -> get_items . p_attr_list [ idx ] , p ) ; } } break ; case AVRC_PDU_CHANGE_PATH : min_len += 11 ; RETURN_STATUS_IF_FALSE ( AVRC_STS_BAD_CMD , ( p_msg -> browse_len >= min_len ) , "msg too short" ) ; BE_STREAM_TO_UINT16 ( p_result -> chg_path . uid_counter , p ) ; BE_STREAM_TO_UINT8 ( p_result -> chg_path . direction , p ) ; if ( p_result -> chg_path . direction != AVRC_DIR_UP && p_result -> chg_path . direction != AVRC_DIR_DOWN ) { status = AVRC_STS_BAD_DIR ; } BE_STREAM_TO_ARRAY ( p , p_result -> chg_path . folder_uid , AVRC_UID_SIZE ) ; break ; case AVRC_PDU_GET_ITEM_ATTRIBUTES : min_len += 12 ; RETURN_STATUS_IF_FALSE ( AVRC_STS_BAD_CMD , ( p_msg -> browse_len >= min_len ) , "msg too short" ) ; BE_STREAM_TO_UINT8 ( p_result -> get_attrs . scope , p ) ; if ( p_result -> get_attrs . scope > AVRC_SCOPE_NOW_PLAYING ) { status = AVRC_STS_BAD_SCOPE ; break ; } BE_STREAM_TO_ARRAY ( p , p_result -> get_attrs . uid , AVRC_UID_SIZE ) ; BE_STREAM_TO_UINT16 ( p_result -> get_attrs . uid_counter , p ) ; BE_STREAM_TO_UINT8 ( p_result -> get_attrs . attr_count , p ) ; p_result -> get_attrs . p_attr_list = NULL ; if ( p_result -> get_attrs . attr_count && p_buf ) { p_result -> get_attrs . p_attr_list = ( uint32_t * ) p_buf ; count = p_result -> get_attrs . attr_count ; if ( buf_len < ( count < < 2 ) ) p_result -> get_attrs . attr_count = count = ( buf_len > > 2 ) ; for ( int idx = 0 , count = 0 ; idx < p_result -> get_attrs . attr_count ; idx ++ ) { min_len += 4 ; RETURN_STATUS_IF_FALSE ( AVRC_STS_BAD_CMD , ( p_msg -> browse_len >= min_len ) , "msg too short" ) ; BE_STREAM_TO_UINT32 ( p_result -> get_attrs . p_attr_list [ count ] , p ) ; if ( AVRC_IS_VALID_MEDIA_ATTRIBUTE ( p_result -> get_attrs . p_attr_list [ count ] ) ) { count ++ ; } } if ( p_result -> get_attrs . attr_count != count && count == 0 ) status = AVRC_STS_BAD_PARAM ; else p_result -> get_attrs . attr_count = count ; } break ; case AVRC_PDU_GET_TOTAL_NUM_OF_ITEMS : ++ min_len ; RETURN_STATUS_IF_FALSE ( AVRC_STS_BAD_CMD , ( p_msg -> browse_len >= min_len ) , "msg too short" ) ; BE_STREAM_TO_UINT8 ( p_result -> get_num_of_items . scope , p ) ; if ( p_result -> get_num_of_items . scope > AVRC_SCOPE_NOW_PLAYING ) { status = AVRC_STS_BAD_SCOPE ; } break ; case AVRC_PDU_SEARCH : min_len += 4 ; RETURN_STATUS_IF_FALSE ( AVRC_STS_BAD_CMD , ( p_msg -> browse_len >= min_len ) , "msg too short" ) ; BE_STREAM_TO_UINT16 ( p_result -> search . string . charset_id , p ) ; BE_STREAM_TO_UINT16 ( p_result -> search . string . str_len , p ) ; p_result -> search . string . p_str = p_buf ; if ( p_buf ) { if ( p_result -> search . string . str_len > buf_len ) { p_result -> search . string . str_len = buf_len ; } else { android_errorWriteLog ( 0x534e4554 , "63146237" ) ; } min_len += p_result -> search . string . str_len ; RETURN_STATUS_IF_FALSE ( AVRC_STS_BAD_CMD , ( p_msg -> browse_len >= min_len ) , "msg too short" ) ; BE_STREAM_TO_ARRAY ( p , p_buf , p_result -> search . string . str_len ) ; } else { status = AVRC_STS_INTERNAL_ERR ; } break ; default : status = AVRC_STS_BAD_CMD ; break ; } return status ; }
HeapObject * Factory :: AllocateRawWithAllocationSite ( Handle < Map > map , PretenureFlag pretenure , Handle < AllocationSite > allocation_site ) { DCHECK ( map -> instance_type ( ) != MAP_TYPE ) ; int size = map -> instance_size ( ) ; if ( ! allocation_site . is_null ( ) ) size += AllocationMemento :: kSize ; AllocationSpace space = Heap :: SelectSpace ( pretenure ) ; HeapObject * result = isolate ( ) -> heap ( ) -> AllocateRawWithRetryOrFail ( size , space ) ; WriteBarrierMode write_barrier_mode = space == NEW_SPACE ? SKIP_WRITE_BARRIER : UPDATE_WRITE_BARRIER ; result -> set_map_after_allocation ( * map , write_barrier_mode ) ; if ( ! allocation_site . is_null ( ) ) { AllocationMemento * alloc_memento = reinterpret_cast < AllocationMemento * > ( reinterpret_cast < Address > ( result ) + map -> instance_size ( ) ) ; InitializeAllocationMemento ( alloc_memento , * allocation_site ) ; } return result ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TF_LITE_ENSURE_EQ ( context , node -> inputs -> size , 5 ) ; TF_LITE_ENSURE_EQ ( context , node -> outputs -> size , 1 ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; const TfLiteTensor * input_weights = GetInput ( context , node , kWeightsTensor ) ; const TfLiteTensor * recurrent_weights = GetInput ( context , node , kRecurrentWeightsTensor ) ; const TfLiteTensor * bias = GetInput ( context , node , kBiasTensor ) ; const TfLiteTensor * hidden_state = GetInput ( context , node , kHiddenStateTensor ) ; const int batch_size = input -> dims -> data [ 0 ] ; const int num_units = input_weights -> dims -> data [ 0 ] ; TF_LITE_ENSURE_EQ ( context , input -> dims -> data [ 1 ] , input_weights -> dims -> data [ 1 ] ) ; TF_LITE_ENSURE_EQ ( context , input_weights -> dims -> data [ 0 ] , bias -> dims -> data [ 0 ] ) ; TF_LITE_ENSURE_EQ ( context , recurrent_weights -> dims -> data [ 0 ] , bias -> dims -> data [ 0 ] ) ; TF_LITE_ENSURE_EQ ( context , recurrent_weights -> dims -> data [ 1 ] , bias -> dims -> data [ 0 ] ) ; TF_LITE_ENSURE_TYPES_EQ ( context , input -> type , kTfLiteFloat32 ) ; TF_LITE_ENSURE_TYPES_EQ ( context , input_weights -> type , recurrent_weights -> type ) ; TF_LITE_ENSURE_EQ ( context , NumDimensions ( hidden_state ) , 2 ) ; TF_LITE_ENSURE_EQ ( context , hidden_state -> dims -> data [ 0 ] , batch_size ) ; TF_LITE_ENSURE_EQ ( context , hidden_state -> dims -> data [ 1 ] , num_units ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; TfLiteIntArray * output_size_array = TfLiteIntArrayCreate ( 2 ) ; output_size_array -> data [ 0 ] = batch_size ; output_size_array -> data [ 1 ] = num_units ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , output , output_size_array ) ) ; const bool is_hybrid = IsHybridOp ( input , input_weights ) ; if ( is_hybrid ) { auto * op_data = reinterpret_cast < OpData * > ( node -> user_data ) ; op_data -> compute_row_sums = true ; TfLiteIntArrayFree ( node -> temporaries ) ; node -> temporaries = TfLiteIntArrayCreate ( 6 ) ; node -> temporaries -> data [ 0 ] = op_data -> scratch_tensor_index ; TfLiteTensor * input_quantized = GetTemporary ( context , node , 0 ) ; input_quantized -> type = input_weights -> type ; input_quantized -> allocation_type = kTfLiteArenaRw ; if ( ! TfLiteIntArrayEqual ( input_quantized -> dims , input -> dims ) ) { TfLiteIntArray * input_quantized_size = TfLiteIntArrayCopy ( input -> dims ) ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , input_quantized , input_quantized_size ) ) ; } node -> temporaries -> data [ 1 ] = op_data -> scratch_tensor_index + 1 ; TfLiteTensor * hidden_state_quantized = GetTemporary ( context , node , 1 ) ; hidden_state_quantized -> type = input_weights -> type ; hidden_state_quantized -> allocation_type = kTfLiteArenaRw ; if ( ! TfLiteIntArrayEqual ( hidden_state_quantized -> dims , hidden_state -> dims ) ) { TfLiteIntArray * hidden_state_quantized_size = TfLiteIntArrayCopy ( hidden_state -> dims ) ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , hidden_state_quantized , hidden_state_quantized_size ) ) ; } node -> temporaries -> data [ 2 ] = op_data -> scratch_tensor_index + 2 ; TfLiteTensor * scaling_factors = GetTemporary ( context , node , 2 ) ; scaling_factors -> type = kTfLiteFloat32 ; scaling_factors -> allocation_type = kTfLiteArenaRw ; int scaling_dims [ 1 ] = { batch_size } ; if ( ! TfLiteIntArrayEqualsArray ( scaling_factors -> dims , 1 , scaling_dims ) ) { TfLiteIntArray * scaling_factors_size = TfLiteIntArrayCreate ( 1 ) ; scaling_factors_size -> data [ 0 ] = batch_size ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , scaling_factors , scaling_factors_size ) ) ; } node -> temporaries -> data [ 3 ] = op_data -> scratch_tensor_index + 3 ; TfLiteTensor * accum_scratch = GetTemporary ( context , node , 3 ) ; accum_scratch -> type = kTfLiteInt32 ; accum_scratch -> allocation_type = kTfLiteArenaRw ; int accum_scratch_dims [ 2 ] = { num_units , batch_size } ; if ( ! TfLiteIntArrayEqualsArray ( accum_scratch -> dims , 2 , accum_scratch_dims ) ) { TfLiteIntArray * accum_scratch_size = TfLiteIntArrayCreate ( 2 ) ; accum_scratch_size -> data [ 0 ] = accum_scratch_dims [ 0 ] ; accum_scratch_size -> data [ 1 ] = accum_scratch_dims [ 1 ] ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , accum_scratch , accum_scratch_size ) ) ; } node -> temporaries -> data [ 4 ] = op_data -> scratch_tensor_index + 4 ; TfLiteTensor * zero_points = GetTemporary ( context , node , 4 ) ; zero_points -> type = kTfLiteInt32 ; zero_points -> allocation_type = kTfLiteArenaRw ; int zero_points_dims [ 1 ] = { batch_size } ; if ( ! TfLiteIntArrayEqualsArray ( zero_points -> dims , 1 , zero_points_dims ) ) { TfLiteIntArray * zero_points_size = TfLiteIntArrayCreate ( 1 ) ; zero_points_size -> data [ 0 ] = batch_size ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , zero_points , zero_points_size ) ) ; } node -> temporaries -> data [ 5 ] = op_data -> scratch_tensor_index + 5 ; TfLiteTensor * row_sums = GetTemporary ( context , node , 5 ) ; row_sums -> type = kTfLiteInt32 ; row_sums -> allocation_type = kTfLiteArenaRwPersistent ; int row_sums_dims [ 2 ] = { 2 , num_units } ; if ( ! TfLiteIntArrayEqualsArray ( row_sums -> dims , 2 , row_sums_dims ) ) { TfLiteIntArray * row_sums_size = TfLiteIntArrayCreate ( 2 ) ; row_sums_size -> data [ 0 ] = row_sums_dims [ 0 ] ; row_sums_size -> data [ 1 ] = row_sums_dims [ 1 ] ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , row_sums , row_sums_size ) ) ; } } return kTfLiteOk ; }
StackSpace :: markFrameValues ( JSTracer * trc , StackFrame * fp , Value * slotsEnd , jsbytecode * pc ) { Value * slotsBegin = fp -> slots ( ) ; if ( ! fp -> isScriptFrame ( ) ) { JS_ASSERT ( fp -> isDummyFrame ( ) ) ; gc :: MarkValueRootRange ( trc , slotsBegin , slotsEnd , "vm_stack" ) ; return ; } JS_ASSERT ( pc ) ; JSScript * script = fp -> script ( ) ; if ( ! script -> hasAnalysis ( ) || ! script -> analysis ( ) -> ranLifetimes ( ) ) { gc :: MarkValueRootRange ( trc , slotsBegin , slotsEnd , "vm_stack" ) ; return ; } analyze :: AutoEnterAnalysis aea ( script -> compartment ( ) ) ; analyze :: ScriptAnalysis * analysis = script -> analysis ( ) ; uint32_t offset = pc - script -> code ; Value * fixedEnd = slotsBegin + script -> nfixed ; for ( Value * vp = slotsBegin ; vp < fixedEnd ; vp ++ ) { uint32_t slot = analyze :: LocalSlot ( script , vp - slotsBegin ) ; if ( ! analysis -> trackSlot ( slot ) || analysis -> liveness ( slot ) . live ( offset ) ) gc :: MarkValueRoot ( trc , vp , "vm_stack" ) ; else if ( vp -> isObject ( ) ) * vp = ObjectValue ( fp -> scopeChain ( ) -> global ( ) ) ; else if ( vp -> isString ( ) ) * vp = StringValue ( trc -> runtime -> atomState . nullAtom ) ; } gc :: MarkValueRootRange ( trc , fixedEnd , slotsEnd , "vm_stack" ) ; }
OMX_ERRORTYPE omx_video :: free_input_buffer ( OMX_BUFFERHEADERTYPE * bufferHdr ) { unsigned int index = 0 ; OMX_U8 * temp_buff ; if ( bufferHdr == NULL || m_inp_mem_ptr == NULL ) { DEBUG_PRINT_ERROR ( "ERROR: free_input: Invalid bufferHdr[%p] or m_inp_mem_ptr[%p]" , bufferHdr , m_inp_mem_ptr ) ; return OMX_ErrorBadParameter ; } index = bufferHdr - ( ( ! meta_mode_enable ) ? m_inp_mem_ptr : meta_buffer_hdr ) ; #ifdef _ANDROID_ICS_ if ( meta_mode_enable ) { if ( index < m_sInPortDef . nBufferCountActual ) { memset ( & meta_buffer_hdr [ index ] , 0 , sizeof ( meta_buffer_hdr [ index ] ) ) ; memset ( & meta_buffers [ index ] , 0 , sizeof ( meta_buffers [ index ] ) ) ; } if ( ! mUseProxyColorFormat ) return OMX_ErrorNone ; else { c2d_conv . close ( ) ; opaque_buffer_hdr [ index ] = NULL ; } } #endif if ( index < m_sInPortDef . nBufferCountActual && ! mUseProxyColorFormat && dev_free_buf ( & m_pInput_pmem [ index ] , PORT_INDEX_IN ) != true ) { DEBUG_PRINT_LOW ( "ERROR: dev_free_buf() Failed for i/p buf" ) ; } if ( index < m_sInPortDef . nBufferCountActual && m_pInput_pmem ) { if ( m_pInput_pmem [ index ] . fd > 0 && input_use_buffer == false ) { DEBUG_PRINT_LOW ( "FreeBuffer:: i/p AllocateBuffer case" ) ; if ( ! secure_session ) { munmap ( m_pInput_pmem [ index ] . buffer , m_pInput_pmem [ index ] . size ) ; } else { free ( m_pInput_pmem [ index ] . buffer ) ; } close ( m_pInput_pmem [ index ] . fd ) ; #ifdef USE_ION free_ion_memory ( & m_pInput_ion [ index ] ) ; #endif m_pInput_pmem [ index ] . fd = - 1 ; } else if ( m_pInput_pmem [ index ] . fd > 0 && ( input_use_buffer == true && m_use_input_pmem == OMX_FALSE ) ) { DEBUG_PRINT_LOW ( "FreeBuffer:: i/p Heap UseBuffer case" ) ; if ( dev_free_buf ( & m_pInput_pmem [ index ] , PORT_INDEX_IN ) != true ) { DEBUG_PRINT_ERROR ( "ERROR: dev_free_buf() Failed for i/p buf" ) ; } if ( ! secure_session ) { munmap ( m_pInput_pmem [ index ] . buffer , m_pInput_pmem [ index ] . size ) ; } close ( m_pInput_pmem [ index ] . fd ) ; #ifdef USE_ION free_ion_memory ( & m_pInput_ion [ index ] ) ; #endif m_pInput_pmem [ index ] . fd = - 1 ; } else { DEBUG_PRINT_ERROR ( "FreeBuffer:: fd is invalid or i/p PMEM UseBuffer case" ) ; } } return OMX_ErrorNone ; }
void V8Debugger :: asyncTaskCanceledForStepping ( void * task ) { if ( ! m_taskWithScheduledBreakDebuggerId . isEmpty ( ) || task != m_taskWithScheduledBreak ) return ; m_taskWithScheduledBreak = nullptr ; }
TPMI_RH_PLATFORM_Unmarshal ( TPMI_RH_PLATFORM * target , BYTE * * buffer , INT32 * size ) { TPM_RC rc = TPM_RC_SUCCESS ; if ( rc == TPM_RC_SUCCESS ) { rc = TPM_HANDLE_Unmarshal ( target , buffer , size ) ; } if ( rc == TPM_RC_SUCCESS ) { switch ( * target ) { case TPM_RH_PLATFORM : break ; default : rc = TPM_RC_VALUE ; } } return rc ; }
void Heap :: EnsureFillerObjectAtTop ( ) { Address to_top = new_space_ -> top ( ) ; Page * page = Page :: FromAddress ( to_top - kPointerSize ) ; if ( page -> Contains ( to_top ) ) { int remaining_in_page = static_cast < int > ( page -> area_end ( ) - to_top ) ; CreateFillerObjectAt ( to_top , remaining_in_page , ClearRecordedSlots :: kNo ) ; } }
TfLiteTensor * GetTempRhs ( TfLiteContext * context , TfLiteNode * node , const TfLiteTensor * rhs ) { TfLiteTensor * transposed_rhs = GetTemporary ( context , node , 1 ) ; if ( rhs -> type == kTfLiteInt8 ) { transposed_rhs -> params . scale = rhs -> params . scale ; transposed_rhs -> params . zero_point = rhs -> params . zero_point ; } return transposed_rhs ; }
void pjsua_init_tpselector ( pjsua_transport_id tp_id , pjsip_tpselector * sel ) { pjsua_transport_data * tpdata ; unsigned flag ; pj_bzero ( sel , sizeof ( * sel ) ) ; if ( tp_id == PJSUA_INVALID_ID ) return ; pj_assert ( tp_id >= 0 && tp_id < ( int ) PJ_ARRAY_SIZE ( pjsua_var . tpdata ) ) ; tpdata = & pjsua_var . tpdata [ tp_id ] ; flag = pjsip_transport_get_flag_from_type ( tpdata -> type ) ; if ( flag & PJSIP_TRANSPORT_DATAGRAM ) { sel -> type = PJSIP_TPSELECTOR_TRANSPORT ; sel -> u . transport = tpdata -> data . tp ; } else { sel -> type = PJSIP_TPSELECTOR_LISTENER ; sel -> u . listener = tpdata -> data . factory ; } }
JSTypedLowering :: JSTypedLowering ( Editor * editor , JSGraph * jsgraph , JSHeapBroker * js_heap_broker , Zone * zone ) : AdvancedReducer ( editor ) , jsgraph_ ( jsgraph ) , js_heap_broker_ ( js_heap_broker ) , empty_string_type_ ( Type :: HeapConstant ( js_heap_broker , factory ( ) -> empty_string ( ) , graph ( ) -> zone ( ) ) ) , pointer_comparable_type_ ( Type :: Union ( Type :: Oddball ( ) , Type :: Union ( Type :: SymbolOrReceiver ( ) , empty_string_type_ , graph ( ) -> zone ( ) ) , graph ( ) -> zone ( ) ) ) , type_cache_ ( TypeCache :: Get ( ) ) { }
perf_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct perf_event * event = file -> private_data ; return perf_read_hw ( event , buf , count ) ; }
static int get_prop ( int fd , uint32_t client_id , const char * name , void * * value , size_t * size ) { size_t msg_size = sizeof ( struct vbg_ioctl_hgcm_call ) + 4 * sizeof ( struct vmmdev_hgcm_function_parameter64 ) ; struct vbg_ioctl_hgcm_call _cleanup_free_ * msg = calloc ( 1 , msg_size ) ; init_header ( & msg -> hdr , msg_size - sizeof ( msg -> hdr ) , msg_size - sizeof ( msg -> hdr ) ) ; msg -> client_id = client_id ; msg -> function = 1 ; msg -> timeout_ms = - 1 ; msg -> interruptible = 1 ; msg -> parm_count = 4 ; char ch ; struct vmmdev_hgcm_function_parameter64 * params = ( void * ) ( msg + 1 ) ; params [ 0 ] . type = VMMDEV_HGCM_PARM_TYPE_LINADDR_IN ; params [ 0 ] . u . pointer . size = strlen ( name ) + 1 ; params [ 0 ] . u . pointer . u . linear_addr = ( uintptr_t ) name ; params [ 1 ] . type = VMMDEV_HGCM_PARM_TYPE_LINADDR ; params [ 1 ] . u . pointer . size = 1 ; params [ 1 ] . u . pointer . u . linear_addr = ( uintptr_t ) & ch ; params [ 2 ] . type = VMMDEV_HGCM_PARM_TYPE_64BIT ; params [ 3 ] . type = VMMDEV_HGCM_PARM_TYPE_32BIT ; if ( ioctl ( fd , VBG_IOCTL_HGCM_CALL_64 ( msg_size ) , msg ) ) { return VERR_GENERAL_FAILURE ; } switch ( msg -> hdr . rc ) { case VINF_SUCCESS : case VERR_BUFFER_OVERFLOW : ; size_t buf_size = params [ 3 ] . u . value32 ; void _cleanup_free_ * buf = malloc ( buf_size ) ; params [ 1 ] . u . pointer . size = buf_size ; params [ 1 ] . u . pointer . u . linear_addr = ( uintptr_t ) buf ; if ( ioctl ( fd , VBG_IOCTL_HGCM_CALL_64 ( msg_size ) , msg ) ) { return VERR_GENERAL_FAILURE ; } if ( msg -> hdr . rc != VINF_SUCCESS ) { return msg -> hdr . rc ; } * value = buf ; buf = NULL ; * size = buf_size ; return VINF_SUCCESS ; case VERR_NOT_FOUND : * value = NULL ; * size = 0 ; return VINF_SUCCESS ; default : return msg -> hdr . rc ; } }
DescribeScriptedCaller ( JSContext * cx , UniqueChars * filename , unsigned * lineno , unsigned * column ) { if ( filename ) filename -> reset ( ) ; if ( lineno ) * lineno = 0 ; if ( column ) * column = 0 ; NonBuiltinFrameIter i ( cx ) ; if ( i . done ( ) ) return false ; if ( i . activation ( ) -> scriptedCallerIsHidden ( ) ) return false ; if ( filename && i . filename ( ) ) { UniqueChars copy = DuplicateString ( i . filename ( ) ) ; if ( ! copy ) return false ; * filename = Move ( copy ) ; } if ( lineno ) * lineno = i . computeLine ( column ) ; else if ( column ) i . computeLine ( column ) ; return true ; }
void CallPrinter :: PrintLiteral ( Handle < Object > value , bool quote ) { if ( value -> IsString ( ) ) { if ( quote ) Print ( "\"" ) ; Print ( Handle < String > :: cast ( value ) ) ; if ( quote ) Print ( "\"" ) ; } else if ( value -> IsNull ( isolate_ ) ) { Print ( "null" ) ; } else if ( value -> IsTrue ( isolate_ ) ) { Print ( "true" ) ; } else if ( value -> IsFalse ( isolate_ ) ) { Print ( "false" ) ; } else if ( value -> IsUndefined ( isolate_ ) ) { Print ( "undefined" ) ; } else if ( value -> IsNumber ( ) ) { Print ( isolate_ -> factory ( ) -> NumberToString ( value ) ) ; } else if ( value -> IsSymbol ( ) ) { PrintLiteral ( handle ( Handle < Symbol > :: cast ( value ) -> name ( ) , isolate_ ) , false ) ; } }
IDBIndex :: GetKeyPath ( JSContext * aCx , ErrorResult & aRv ) { NS_ASSERTION ( NS_IsMainThread ( ) , "Wrong thread!" ) ; if ( ! mCachedKeyPath . isUndefined ( ) ) { return mCachedKeyPath ; } aRv = GetKeyPath ( ) . ToJSVal ( aCx , mCachedKeyPath ) ; ENSURE_SUCCESS ( aRv , JSVAL_VOID ) ; if ( mCachedKeyPath . isGCThing ( ) ) { mozilla :: HoldJSObjects ( this ) ; mRooted = true ; } return mCachedKeyPath ; }
void AccessorAssembler :: HandleStoreToProxy ( const StoreICParameters * p , Node * proxy , Label * miss , ElementSupport support_elements ) { VARIABLE ( var_index , MachineType :: PointerRepresentation ( ) ) ; VARIABLE ( var_unique , MachineRepresentation :: kTagged ) ; Label if_index ( this ) , if_unique_name ( this ) , to_name_failed ( this , Label :: kDeferred ) ; Node * language_mode = GetLanguageMode ( p -> vector , p -> slot ) ; if ( support_elements == kSupportElements ) { TryToName ( p -> name , & if_index , & var_index , & if_unique_name , & var_unique , & to_name_failed ) ; BIND ( & if_unique_name ) ; CallBuiltin ( Builtins :: kProxySetProperty , p -> context , proxy , var_unique . value ( ) , p -> value , p -> receiver , language_mode ) ; Return ( p -> value ) ; BIND ( & if_index ) ; Goto ( & to_name_failed ) ; BIND ( & to_name_failed ) ; TailCallRuntime ( Runtime :: kSetPropertyWithReceiver , p -> context , proxy , p -> name , p -> value , p -> receiver , language_mode ) ; } else { Node * name = ToName ( p -> context , p -> name ) ; TailCallBuiltin ( Builtins :: kProxySetProperty , p -> context , proxy , name , p -> value , p -> receiver , language_mode ) ; } }
void btsock_rfc_signaled ( UNUSED_ATTR int fd , int flags , uint32_t user_id ) { pthread_mutex_lock ( & slot_lock ) ; rfc_slot_t * slot = find_rfc_slot_by_id ( user_id ) ; if ( ! slot ) goto out ; bool need_close = false ; if ( flags & SOCK_THREAD_FD_RD && ! slot -> f . server ) { if ( slot -> f . connected ) { int size = 0 ; if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) ) pthread_mutex_unlock ( & slot_lock ) ; BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ; } else { LOG_ERROR ( "%s socket signaled for read while disconnected, slot: %d, channel: %d" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( flags & SOCK_THREAD_FD_WR ) { if ( ! slot -> f . connected || ! flush_incoming_que_on_wr_signal ( slot ) ) { LOG_ERROR ( "%s socket signaled for write while disconnected (or write failure), slot: %d, channel: %d" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ; if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size ) cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; }
Node * ConcatStrings ( Node * const context , Node * * strings , int len ) { VARIABLE ( var_result , MachineRepresentation :: kTagged , strings [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { var_result . Bind ( CallStub ( CodeFactory :: StringAdd ( isolate ( ) ) , context , var_result . value ( ) , strings [ i ] ) ) ; } return var_result . value ( ) ; }
nfs4_atomic_open ( struct inode * dir , struct dentry * dentry , struct nameidata * nd ) { struct path path = { . mnt = nd -> path . mnt , . dentry = dentry , } ; struct dentry * parent ; struct iattr attr ; struct rpc_cred * cred ; struct nfs4_state * state ; struct dentry * res ; if ( nd -> flags & LOOKUP_CREATE ) { attr . ia_mode = nd -> intent . open . create_mode ; attr . ia_valid = ATTR_MODE ; if ( ! IS_POSIXACL ( dir ) ) attr . ia_mode &= ~ current -> fs -> umask ; } else { attr . ia_valid = 0 ; BUG_ON ( nd -> intent . open . flags & O_CREAT ) ; } cred = rpc_lookup_cred ( ) ; if ( IS_ERR ( cred ) ) return ( struct dentry * ) cred ; parent = dentry -> d_parent ; nfs_block_sillyrename ( parent ) ; state = nfs4_do_open ( dir , & path , nd -> intent . open . flags , & attr , cred ) ; put_rpccred ( cred ) ; if ( IS_ERR ( state ) ) { if ( PTR_ERR ( state ) == - ENOENT ) { d_add ( dentry , NULL ) ; nfs_set_verifier ( dentry , nfs_save_change_attribute ( dir ) ) ; } nfs_unblock_sillyrename ( parent ) ; return ( struct dentry * ) state ; } res = d_add_unique ( dentry , igrab ( state -> inode ) ) ; if ( res != NULL ) path . dentry = res ; nfs_set_verifier ( path . dentry , nfs_save_change_attribute ( dir ) ) ; nfs_unblock_sillyrename ( parent ) ; nfs4_intent_set_file ( nd , & path , state ) ; return res ; }
nsEventListenerManager :: SetJSEventListenerToJsval ( nsIAtom * aEventName , JSContext * cx , JSObject * aScope , const jsval & v ) { JSObject * handler ; if ( JSVAL_IS_PRIMITIVE ( v ) || ! JS_ObjectIsCallable ( cx , handler = JSVAL_TO_OBJECT ( v ) ) ) { RemoveScriptEventListener ( aEventName ) ; return NS_OK ; } nsIScriptContext * context = nsJSUtils :: GetStaticScriptContext ( cx , aScope ) ; NS_ENSURE_TRUE ( context , NS_ERROR_FAILURE ) ; JSObject * scope = :: JS_GetGlobalForObject ( cx , aScope ) ; nsListenerStruct * ignored ; return SetJSEventListener ( context , scope , aEventName , handler , ! nsContentUtils :: IsCallerChrome ( ) , & ignored ) ; }
void Factory :: SetRegExpIrregexpData ( Handle < JSRegExp > regexp , JSRegExp :: Type type , Handle < String > source , JSRegExp :: Flags flags , int capture_count ) { Handle < FixedArray > store = NewFixedArray ( JSRegExp :: kIrregexpDataSize ) ; Smi * uninitialized = Smi :: FromInt ( JSRegExp :: kUninitializedValue ) ; store -> set ( JSRegExp :: kTagIndex , Smi :: FromInt ( type ) ) ; store -> set ( JSRegExp :: kSourceIndex , * source ) ; store -> set ( JSRegExp :: kFlagsIndex , Smi :: FromInt ( flags ) ) ; store -> set ( JSRegExp :: kIrregexpLatin1CodeIndex , uninitialized ) ; store -> set ( JSRegExp :: kIrregexpUC16CodeIndex , uninitialized ) ; store -> set ( JSRegExp :: kIrregexpMaxRegisterCountIndex , Smi :: kZero ) ; store -> set ( JSRegExp :: kIrregexpCaptureCountIndex , Smi :: FromInt ( capture_count ) ) ; store -> set ( JSRegExp :: kIrregexpCaptureNameMapIndex , uninitialized ) ; regexp -> set_data ( * store ) ; }
nsDummyJavaPluginOwner :: SetInstance ( nsIPluginInstance * aInstance ) { mInstance = aInstance ; return NS_OK ; }
void ObjectStats :: Dump ( std :: stringstream & stream ) { double time = isolate ( ) -> time_millis_since_init ( ) ; int gc_count = heap ( ) -> gc_count ( ) ; stream < < "{" ; stream < < "\"isolate\":\"" < < reinterpret_cast < void * > ( isolate ( ) ) < < "\"," ; stream < < "\"id\":" < < gc_count < < "," ; stream < < "\"time\":" < < time < < "," ; stream < < "\"field_data\":{" ; stream < < "\"tagged_fields\":" < < ( tagged_fields_count_ * kPointerSize ) ; stream < < ",\"embedder_fields\":" < < ( embedder_fields_count_ * kPointerSize ) ; stream < < ",\"unboxed_double_fields\": " < < ( unboxed_double_fields_count_ * kDoubleSize ) ; stream < < ",\"other_raw_fields\":" < < ( raw_fields_count_ * kPointerSize ) ; stream < < "}, " ; stream < < "\"bucket_sizes\":[" ; for ( int i = 0 ; i < kNumberOfBuckets ; i ++ ) { stream < < ( 1 < < ( kFirstBucketShift + i ) ) ; if ( i != ( kNumberOfBuckets - 1 ) ) stream < < "," ; } stream < < "]," ; stream < < "\"type_data\":{" ; #define INSTANCE_TYPE_WRAPPER(name) DumpInstanceTypeData(stream, #name, name); #define VIRTUAL_INSTANCE_TYPE_WRAPPER(name) \  DumpInstanceTypeData(stream, #name, FIRST_VIRTUAL_TYPE + name); INSTANCE_TYPE_LIST ( INSTANCE_TYPE_WRAPPER ) ; VIRTUAL_INSTANCE_TYPE_LIST ( VIRTUAL_INSTANCE_TYPE_WRAPPER ) stream < < "\"END\":{}}}" ; #undef INSTANCE_TYPE_WRAPPER #undef VIRTUAL_INSTANCE_TYPE_WRAPPER }
void FindTwoByteStringIndices ( const Vector < const uc16 > subject , uc16 pattern , std :: vector < int > * indices , unsigned int limit ) { DCHECK_LT ( 0 , limit ) ; const uc16 * subject_start = subject . start ( ) ; const uc16 * subject_end = subject_start + subject . length ( ) ; for ( const uc16 * pos = subject_start ; pos < subject_end && limit > 0 ; pos ++ ) { if ( * pos == pattern ) { indices -> push_back ( static_cast < int > ( pos - subject_start ) ) ; limit -- ; } } }
int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; int err = 0 ; if ( ! asoc ) return - EINVAL ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
void BaseCollectionsAssembler :: GotoIfNotJSReceiver ( Node * const obj , Label * if_not_receiver ) { GotoIf ( TaggedIsSmi ( obj ) , if_not_receiver ) ; GotoIfNot ( IsJSReceiver ( obj ) , if_not_receiver ) ; }
gss_verify_mic ( minor_status , context_handle , message_buffer , token_buffer , qop_state ) OM_uint32 * minor_status ; gss_ctx_id_t context_handle ; gss_buffer_t message_buffer ; gss_buffer_t token_buffer ; gss_qop_t * qop_state ; { OM_uint32 status ; gss_union_ctx_id_t ctx ; gss_mechanism mech ; if ( minor_status == NULL ) return ( GSS_S_CALL_INACCESSIBLE_WRITE ) ; * minor_status = 0 ; if ( context_handle == GSS_C_NO_CONTEXT ) return ( GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT ) ; if ( ( message_buffer == GSS_C_NO_BUFFER ) || GSS_EMPTY_BUFFER ( token_buffer ) ) return ( GSS_S_CALL_INACCESSIBLE_READ ) ; ctx = ( gss_union_ctx_id_t ) context_handle ; mech = gssint_get_mechanism ( ctx -> mech_type ) ; if ( mech ) { if ( mech -> gss_verify_mic ) { status = mech -> gss_verify_mic ( minor_status , ctx -> internal_ctx_id , message_buffer , token_buffer , qop_state ) ; if ( status != GSS_S_COMPLETE ) map_error ( minor_status , mech ) ; } else status = GSS_S_UNAVAILABLE ; return ( status ) ; } return ( GSS_S_BAD_MECH ) ; }
void strbuf_utf8_align ( struct strbuf * buf , align_type position , unsigned int width , const char * s ) { int slen = strlen ( s ) ; int display_len = utf8_strnwidth ( s , slen , 0 ) ; int utf8_compensation = slen - display_len ; if ( display_len >= width ) { strbuf_addstr ( buf , s ) ; return ; } if ( position == ALIGN_LEFT ) strbuf_addf ( buf , "%-*s" , width + utf8_compensation , s ) ; else if ( position == ALIGN_MIDDLE ) { int left = ( width - display_len ) / 2 ; strbuf_addf ( buf , "%*s%-*s" , left , "" , width - left + utf8_compensation , s ) ; } else if ( position == ALIGN_RIGHT ) strbuf_addf ( buf , "%*s" , width + utf8_compensation , s ) ; }
nsSMILTimedElement :: UpdateCurrentInterval ( PRBool aForceChangeNotice ) { if ( mElementState == STATE_STARTUP ) return ; const nsSMILInstanceTime * beginTime = mElementState == STATE_ACTIVE ? mCurrentInterval -> Begin ( ) : nsnull ; nsSMILInterval updatedInterval ; if ( GetNextInterval ( GetPreviousInterval ( ) , beginTime , updatedInterval ) ) { if ( mElementState == STATE_POSTACTIVE ) { NS_ABORT_IF_FALSE ( ! mCurrentInterval , "In postactive state but the interval has been set" ) ; mCurrentInterval = new nsSMILInterval ( updatedInterval ) ; mElementState = STATE_WAITING ; NotifyNewInterval ( ) ; } else { PRBool changed = PR_FALSE ; if ( mElementState != STATE_ACTIVE && ! updatedInterval . Begin ( ) -> SameTimeAndBase ( * mCurrentInterval -> Begin ( ) ) ) { mCurrentInterval -> SetBegin ( * updatedInterval . Begin ( ) ) ; changed = PR_TRUE ; } if ( ! updatedInterval . End ( ) -> SameTimeAndBase ( * mCurrentInterval -> End ( ) ) ) { mCurrentInterval -> SetEnd ( * updatedInterval . End ( ) ) ; changed = PR_TRUE ; } if ( changed || aForceChangeNotice ) { NotifyChangedInterval ( ) ; } } RegisterMilestone ( ) ; } else { if ( mElementState == STATE_ACTIVE ) { if ( ! mCurrentInterval -> End ( ) -> SameTimeAndBase ( * mCurrentInterval -> Begin ( ) ) ) { mCurrentInterval -> SetEnd ( * mCurrentInterval -> Begin ( ) ) ; NotifyChangedInterval ( ) ; } RegisterMilestone ( ) ; } else if ( mElementState == STATE_WAITING ) { mElementState = STATE_POSTACTIVE ; ResetCurrentInterval ( ) ; } } }
IsInvisibleBreak ( nsIContent * aNode , nsIAtom * aTag ) { if ( aTag != nsGkAtoms :: br || ! aNode -> IsEditable ( ) ) { return PR_FALSE ; } nsIDocument * doc = aNode -> GetCurrentDoc ( ) ; if ( doc ) { nsPIDOMWindow * window = doc -> GetWindow ( ) ; if ( window ) { nsIDocShell * docShell = window -> GetDocShell ( ) ; if ( docShell ) { nsCOMPtr < nsIEditorDocShell > editorDocShell = do_QueryInterface ( docShell ) ; if ( editorDocShell ) { nsCOMPtr < nsIEditor > editor ; editorDocShell -> GetEditor ( getter_AddRefs ( editor ) ) ; nsCOMPtr < nsIHTMLEditor > htmlEditor = do_QueryInterface ( editor ) ; if ( htmlEditor ) { PRBool isVisible = PR_FALSE ; nsCOMPtr < nsIDOMNode > domNode = do_QueryInterface ( aNode ) ; htmlEditor -> BreakIsVisible ( domNode , & isVisible ) ; return ! isVisible ; } } } } } return PR_FALSE ; }
nsresult nsWindow :: MakeFullScreen ( bool aFullScreen , nsIScreen * aTargetScreen ) { nsCOMPtr < nsIWinTaskbar > taskbarInfo = do_GetService ( NS_TASKBAR_CONTRACTID ) ; if ( mWidgetListener ) { mWidgetListener -> FullscreenWillChange ( aFullScreen ) ; } mFullscreenMode = aFullScreen ; if ( aFullScreen ) { if ( mSizeMode == nsSizeMode_Fullscreen ) return NS_OK ; mOldSizeMode = mSizeMode ; SetSizeMode ( nsSizeMode_Fullscreen ) ; if ( taskbarInfo ) { taskbarInfo -> PrepareFullScreenHWND ( mWnd , TRUE ) ; } } else { SetSizeMode ( mOldSizeMode ) ; } UpdateNonClientMargins ( mSizeMode , ! aFullScreen ) ; nsBaseWidget :: InfallibleMakeFullScreen ( aFullScreen , aTargetScreen ) ; if ( mIsVisible && ! aFullScreen && mOldSizeMode == nsSizeMode_Normal ) { DispatchFocusToTopLevelWindow ( true ) ; } if ( ! aFullScreen && taskbarInfo ) { taskbarInfo -> PrepareFullScreenHWND ( mWnd , FALSE ) ; } OnSizeModeChange ( mSizeMode ) ; if ( mWidgetListener ) { mWidgetListener -> FullscreenChanged ( aFullScreen ) ; } return NS_OK ; }
gfxAndroidPlatform :: gfxAndroidPlatform ( ) { sFreetypeMemoryRecord . user = nullptr ; sFreetypeMemoryRecord . alloc = FreetypeReporter :: CountingAlloc ; sFreetypeMemoryRecord . free = FreetypeReporter :: CountingFree ; sFreetypeMemoryRecord . realloc = FreetypeReporter :: CountingRealloc ; FT_New_Library ( & sFreetypeMemoryRecord , & gPlatformFTLibrary ) ; FT_Add_Default_Modules ( gPlatformFTLibrary ) ; RegisterStrongMemoryReporter ( new FreetypeReporter ( ) ) ; nsCOMPtr < nsIScreenManager > screenMgr = do_GetService ( "@mozilla.org/gfx/screenmanager;1" ) ; nsCOMPtr < nsIScreen > screen ; screenMgr -> GetPrimaryScreen ( getter_AddRefs ( screen ) ) ; mScreenDepth = 24 ; screen -> GetColorDepth ( & mScreenDepth ) ; mOffscreenFormat = mScreenDepth == 16 ? gfxImageFormat :: RGB16_565 : gfxImageFormat :: RGB24 ; if ( gfxPrefs :: AndroidRGB16Force ( ) ) { mOffscreenFormat = gfxImageFormat :: RGB16_565 ; } #ifdef MOZ_WIDGET_GONK char propQemu [ PROPERTY_VALUE_MAX ] ; property_get ( "ro.kernel.qemu" , propQemu , "" ) ; mIsInGonkEmulator = ! strncmp ( propQemu , "1" , 1 ) ; #endif }
compute_U_value_R2 ( std :: string const & user_password , QPDF :: EncryptionData const & data ) { std :: string k1 = QPDF :: compute_encryption_key ( user_password , data ) ; char udata [ key_bytes ] ; pad_or_truncate_password_V4 ( "" , udata ) ; iterate_rc4 ( QUtil :: unsigned_char_pointer ( udata ) , key_bytes , QUtil :: unsigned_char_pointer ( k1 ) , data . getLengthBytes ( ) , 1 , false ) ; return std :: string ( udata , key_bytes ) ; }
MaybeHandle < BigInt > BigInt :: Exponentiate ( Isolate * isolate , Handle < BigInt > base , Handle < BigInt > exponent ) { if ( exponent -> sign ( ) ) { THROW_NEW_ERROR ( isolate , NewRangeError ( MessageTemplate :: kBigIntNegativeExponent ) , BigInt ) ; } if ( exponent -> is_zero ( ) ) { return MutableBigInt :: NewFromInt ( isolate , 1 ) ; } if ( base -> is_zero ( ) ) return base ; if ( base -> length ( ) == 1 && base -> digit ( 0 ) == 1 ) { if ( base -> sign ( ) && ( exponent -> digit ( 0 ) & 1 ) == 0 ) { return UnaryMinus ( isolate , base ) ; } return base ; } STATIC_ASSERT ( kMaxLengthBits < std :: numeric_limits < digit_t > :: max ( ) ) ; if ( exponent -> length ( ) > 1 ) { THROW_NEW_ERROR ( isolate , NewRangeError ( MessageTemplate :: kBigIntTooBig ) , BigInt ) ; } digit_t exp_value = exponent -> digit ( 0 ) ; if ( exp_value == 1 ) return base ; if ( exp_value >= kMaxLengthBits ) { THROW_NEW_ERROR ( isolate , NewRangeError ( MessageTemplate :: kBigIntTooBig ) , BigInt ) ; } STATIC_ASSERT ( kMaxLengthBits <= kMaxInt ) ; int n = static_cast < int > ( exp_value ) ; if ( base -> length ( ) == 1 && base -> digit ( 0 ) == 2 ) { int needed_digits = 1 + ( n / kDigitBits ) ; Handle < MutableBigInt > result ; if ( ! MutableBigInt :: New ( isolate , needed_digits ) . ToHandle ( & result ) ) { return MaybeHandle < BigInt > ( ) ; } result -> InitializeDigits ( needed_digits ) ; digit_t msd = static_cast < digit_t > ( 1 ) < < ( n % kDigitBits ) ; result -> set_digit ( needed_digits - 1 , msd ) ; if ( base -> sign ( ) ) result -> set_sign ( ( n & 1 ) != 0 ) ; return MutableBigInt :: MakeImmutable ( result ) ; } Handle < BigInt > result ; Handle < BigInt > running_square = base ; if ( n & 1 ) result = base ; n >>= 1 ; for ( ; n != 0 ; n >>= 1 ) { MaybeHandle < BigInt > maybe_result = Multiply ( isolate , running_square , running_square ) ; if ( ! maybe_result . ToHandle ( & running_square ) ) return maybe_result ; if ( n & 1 ) { if ( result . is_null ( ) ) { result = running_square ; } else { maybe_result = Multiply ( isolate , result , running_square ) ; if ( ! maybe_result . ToHandle ( & result ) ) return maybe_result ; } } } return result ; }
xmlValidateNotationCallback ( xmlEntityPtr cur , xmlValidCtxtPtr ctxt , const xmlChar * name ATTRIBUTE_UNUSED ) { if ( cur == NULL ) return ; if ( cur -> etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY ) { xmlChar * notation = cur -> content ; if ( notation != NULL ) { int ret ; ret = xmlValidateNotationUse ( ctxt , cur -> doc , notation ) ; if ( ret != 1 ) { ctxt -> valid = 0 ; } } } }
WebGLContext :: SetDimensions ( int32_t width , int32_t height ) { if ( ! GetCanvas ( ) ) return NS_ERROR_FAILURE ; GetCanvas ( ) -> InvalidateCanvas ( ) ; if ( gl && mWidth == width && mHeight == height ) return NS_OK ; if ( width == 0 || height == 0 ) { width = 1 ; height = 1 ; } if ( gl ) { MakeContextCurrent ( ) ; gl -> ResizeOffscreen ( gfxIntSize ( width , height ) ) ; mWidth = gl -> OffscreenActualSize ( ) . width ; mHeight = gl -> OffscreenActualSize ( ) . height ; mResetLayer = true ; gl -> ClearSafely ( ) ; return NS_OK ; } LoseOldestWebGLContextIfLimitExceeded ( ) ; NS_ENSURE_TRUE ( Preferences :: GetRootBranch ( ) , NS_ERROR_FAILURE ) ; #ifdef XP_WIN bool preferEGL = Preferences :: GetBool ( "webgl.prefer-egl" , false ) ; bool preferOpenGL = Preferences :: GetBool ( "webgl.prefer-native-gl" , false ) ; #endif bool forceEnabled = Preferences :: GetBool ( "webgl.force-enabled" , false ) ; bool useMesaLlvmPipe = Preferences :: GetBool ( "gfx.prefer-mesa-llvmpipe" , false ) ; bool disabled = Preferences :: GetBool ( "webgl.disabled" , false ) ; bool prefer16bit = Preferences :: GetBool ( "webgl.prefer-16bpp" , false ) ; ScopedGfxFeatureReporter reporter ( "WebGL" , forceEnabled ) ; if ( disabled ) return NS_ERROR_FAILURE ; if ( ! ( mGeneration + 1 ) . isValid ( ) ) return NS_ERROR_FAILURE ; gl :: ContextFormat format ( gl :: ContextFormat :: BasicRGBA32 ) ; if ( mOptions . depth ) { format . depth = 24 ; format . minDepth = 16 ; } if ( mOptions . stencil ) { format . stencil = 8 ; format . minStencil = 8 ; } if ( ! mOptions . alpha ) { format . alpha = 0 ; format . minAlpha = 0 ; } if ( prefer16bit ) { if ( mOptions . alpha ) { format . red = 4 ; format . green = 4 ; format . blue = 4 ; format . alpha = 4 ; } else { format . red = 5 ; format . green = 6 ; format . blue = 5 ; format . alpha = 0 ; } } bool forceMSAA = Preferences :: GetBool ( "webgl.msaa-force" , false ) ; int32_t status ; nsCOMPtr < nsIGfxInfo > gfxInfo = do_GetService ( "@mozilla.org/gfx/info;1" ) ; if ( mOptions . antialias && gfxInfo && NS_SUCCEEDED ( gfxInfo -> GetFeatureStatus ( nsIGfxInfo :: FEATURE_WEBGL_MSAA , & status ) ) ) { if ( status == nsIGfxInfo :: FEATURE_NO_INFO || forceMSAA ) { uint32_t msaaLevel = Preferences :: GetUint ( "webgl.msaa-level" , 2 ) ; format . samples = msaaLevel * msaaLevel ; } } #ifdef XP_WIN if ( PR_GetEnv ( "MOZ_WEBGL_PREFER_EGL" ) ) { preferEGL = true ; } #endif bool useOpenGL = true ; #ifdef XP_WIN bool useANGLE = true ; #endif if ( gfxInfo && ! forceEnabled ) { if ( NS_SUCCEEDED ( gfxInfo -> GetFeatureStatus ( nsIGfxInfo :: FEATURE_WEBGL_OPENGL , & status ) ) ) { if ( status != nsIGfxInfo :: FEATURE_NO_INFO ) { useOpenGL = false ; } } #ifdef XP_WIN if ( NS_SUCCEEDED ( gfxInfo -> GetFeatureStatus ( nsIGfxInfo :: FEATURE_WEBGL_ANGLE , & status ) ) ) { if ( status != nsIGfxInfo :: FEATURE_NO_INFO ) { useANGLE = false ; } } #endif } #ifdef XP_WIN if ( useMesaLlvmPipe || PR_GetEnv ( "MOZ_WEBGL_FORCE_OPENGL" ) ) { preferEGL = false ; useANGLE = false ; useOpenGL = true ; } #endif #ifdef XP_WIN if ( ! gl && ( preferEGL || useANGLE ) && ! preferOpenGL ) { gl = gl :: GLContextProviderEGL :: CreateOffscreen ( gfxIntSize ( width , height ) , format ) ; if ( ! gl || ! InitAndValidateGL ( ) ) { GenerateWarning ( "Error during ANGLE OpenGL ES initialization" ) ; return NS_ERROR_FAILURE ; } } #endif if ( ! gl && useOpenGL ) { GLContext :: ContextFlags flag = useMesaLlvmPipe ? GLContext :: ContextFlagsMesaLLVMPipe : GLContext :: ContextFlagsNone ; gl = gl :: GLContextProvider :: CreateOffscreen ( gfxIntSize ( width , height ) , format , flag ) ; if ( gl && ! InitAndValidateGL ( ) ) { GenerateWarning ( "Error during %s initialization" , useMesaLlvmPipe ? "Mesa LLVMpipe" : "OpenGL" ) ; return NS_ERROR_FAILURE ; } } if ( ! gl ) { GenerateWarning ( "Can't get a usable WebGL context" ) ; return NS_ERROR_FAILURE ; } #ifdef DEBUG if ( gl -> DebugMode ( ) ) { printf_stderr ( "--- WebGL context created: %p\n" , gl . get ( ) ) ; } #endif mWidth = width ; mHeight = height ; mResetLayer = true ; mOptionsFrozen = true ; mHasRobustness = gl -> HasRobustness ( ) ; ++ mGeneration ; #if 0 if ( mGeneration > 0 ) { } #endif MakeContextCurrent ( ) ; gl -> fBindFramebuffer ( LOCAL_GL_FRAMEBUFFER , gl -> GetOffscreenFBO ( ) ) ; gl -> fViewport ( 0 , 0 , mWidth , mHeight ) ; gl -> fClearColor ( 0.0f , 0.0f , 0.0f , 0.0f ) ; gl -> fClearDepth ( 1.0f ) ; gl -> fClearStencil ( 0 ) ; gl -> ClearSafely ( ) ; reporter . SetSuccessful ( ) ; return NS_OK ; }
txMozillaXSLTProcessor :: TransformToDoc ( nsIDOMDocument * * aResult , bool aCreateDataDocument ) { nsAutoPtr < txXPathNode > sourceNode ( txXPathNativeNode :: createXPathNode ( mSource ) ) ; if ( ! sourceNode ) { return NS_ERROR_OUT_OF_MEMORY ; } nsCOMPtr < nsIDOMDocument > sourceDOMDocument ; mSource -> GetOwnerDocument ( getter_AddRefs ( sourceDOMDocument ) ) ; if ( ! sourceDOMDocument ) { sourceDOMDocument = do_QueryInterface ( mSource ) ; } txExecutionState es ( mStylesheet , IsLoadDisabled ( ) ) ; txToDocHandlerFactory handlerFactory ( & es , sourceDOMDocument , mObserver , aCreateDataDocument ) ; es . mOutputHandlerFactory = & handlerFactory ; nsresult rv = es . init ( * sourceNode , & mVariables ) ; if ( NS_SUCCEEDED ( rv ) ) { rv = txXSLTProcessor :: execute ( es ) ; } nsresult endRv = es . end ( rv ) ; if ( NS_SUCCEEDED ( rv ) ) { rv = endRv ; } if ( NS_SUCCEEDED ( rv ) ) { if ( aResult ) { txAOutputXMLEventHandler * handler = static_cast < txAOutputXMLEventHandler * > ( es . mOutputHandler ) ; handler -> getOutputDocument ( aResult ) ; nsCOMPtr < nsIDocument > doc = do_QueryInterface ( * aResult ) ; MOZ_ASSERT ( doc -> GetReadyStateEnum ( ) == nsIDocument :: READYSTATE_INTERACTIVE , "Bad readyState" ) ; doc -> SetReadyStateInternal ( nsIDocument :: READYSTATE_COMPLETE ) ; } } else if ( mObserver ) { reportError ( rv , nullptr , nullptr ) ; } return rv ; }
void V8Debugger :: enable ( ) { if ( m_enableCount ++ ) return ; v8 :: HandleScope scope ( m_isolate ) ; v8 :: debug :: SetDebugDelegate ( m_isolate , this ) ; m_isolate -> AddNearHeapLimitCallback ( & V8Debugger :: nearHeapLimitCallback , this ) ; v8 :: debug :: ChangeBreakOnException ( m_isolate , v8 :: debug :: NoBreakOnException ) ; m_pauseOnExceptionsState = v8 :: debug :: NoBreakOnException ; }
void FDK_put ( HANDLE_FDK_BITBUF hBitBuf , UINT value , const UINT numberOfBits ) { if ( numberOfBits != 0 ) { UINT byteOffset0 = hBitBuf -> BitNdx > > 3 ; UINT bitOffset = hBitBuf -> BitNdx & 0x7 ; hBitBuf -> BitNdx = ( hBitBuf -> BitNdx + numberOfBits ) & ( hBitBuf -> bufBits - 1 ) ; hBitBuf -> BitCnt += numberOfBits ; hBitBuf -> ValidBits += numberOfBits ; UINT byteMask = hBitBuf -> bufSize - 1 ; UINT byteOffset1 = ( byteOffset0 + 1 ) & byteMask ; UINT byteOffset2 = ( byteOffset0 + 2 ) & byteMask ; UINT byteOffset3 = ( byteOffset0 + 3 ) & byteMask ; UINT tmp = ( value < < ( 32 - numberOfBits ) ) > > bitOffset ; UINT mask = ~ ( ( BitMask [ numberOfBits ] < < ( 32 - numberOfBits ) ) > > bitOffset ) ; UINT cache = ( ( ( UINT ) hBitBuf -> Buffer [ byteOffset0 ] ) < < 24 ) | ( ( ( UINT ) hBitBuf -> Buffer [ byteOffset1 ] ) < < 16 ) | ( ( ( UINT ) hBitBuf -> Buffer [ byteOffset2 ] ) < < 8 ) | ( ( ( UINT ) hBitBuf -> Buffer [ byteOffset3 ] ) < < 0 ) ; cache = ( cache & mask ) | tmp ; hBitBuf -> Buffer [ byteOffset0 ] = ( UCHAR ) ( cache > > 24 ) ; hBitBuf -> Buffer [ byteOffset1 ] = ( UCHAR ) ( cache > > 16 ) ; hBitBuf -> Buffer [ byteOffset2 ] = ( UCHAR ) ( cache > > 8 ) ; hBitBuf -> Buffer [ byteOffset3 ] = ( UCHAR ) ( cache > > 0 ) ; if ( ( bitOffset + numberOfBits ) > 32 ) { UINT byteOffset4 = ( byteOffset0 + 4 ) & byteMask ; int bits = ( bitOffset + numberOfBits ) & 7 ; cache = ( UINT ) hBitBuf -> Buffer [ byteOffset4 ] & ( ~ ( BitMask [ bits ] < < ( 8 - bits ) ) ) ; cache |= value < < ( 8 - bits ) ; hBitBuf -> Buffer [ byteOffset4 ] = ( UCHAR ) cache ; } } }
main ( int argc , char * * argv ) { const char * safepath = "/bin:/sbin:/usr/bin:/usr/sbin:" "/usr/local/bin:/usr/local/sbin" ; const char * confpath = NULL ; char * shargv [ ] = { NULL , NULL } ; char * sh ; const char * p ; const char * cmd ; char cmdline [ LINE_MAX ] ; struct passwd mypwstore , targpwstore ; struct passwd * mypw , * targpw ; const struct rule * rule ; uid_t uid ; uid_t target = 0 ; gid_t groups [ NGROUPS_MAX + 1 ] ; int ngroups ; int i , ch , rv ; int sflag = 0 ; int nflag = 0 ; char cwdpath [ PATH_MAX ] ; const char * cwd ; char * * envp ; setprogname ( "doas" ) ; closefrom ( STDERR_FILENO + 1 ) ; uid = getuid ( ) ; while ( ( ch = getopt ( argc , argv , "+C:Lnsu:" ) ) != - 1 ) { switch ( ch ) { case 'C' : confpath = optarg ; break ; case 'L' : #if defined(USE_TIMESTAMP) exit ( timestamp_clear ( ) == - 1 ) ; #else exit ( 0 ) ; #endif case 'u' : if ( parseuid ( optarg , & target ) != 0 ) errx ( 1 , "unknown user" ) ; break ; case 'n' : nflag = 1 ; break ; case 's' : sflag = 1 ; break ; default : usage ( ) ; break ; } } argv += optind ; argc -= optind ; if ( confpath ) { if ( sflag ) usage ( ) ; } else if ( ( ! sflag && ! argc ) || ( sflag && argc ) ) usage ( ) ; rv = mygetpwuid_r ( uid , & mypwstore , & mypw ) ; if ( rv != 0 ) err ( 1 , "getpwuid_r failed" ) ; if ( mypw == NULL ) errx ( 1 , "no passwd entry for self" ) ; ngroups = getgroups ( NGROUPS_MAX , groups ) ; if ( ngroups == - 1 ) err ( 1 , "can't get groups" ) ; groups [ ngroups ++ ] = getgid ( ) ; if ( sflag ) { sh = getenv ( "SHELL" ) ; if ( sh == NULL || * sh == '\0' ) { shargv [ 0 ] = mypw -> pw_shell ; } else shargv [ 0 ] = sh ; argv = shargv ; argc = 1 ; } if ( confpath ) { checkconfig ( confpath , argc , argv , uid , groups , ngroups , target ) ; exit ( 1 ) ; } if ( geteuid ( ) ) errx ( 1 , "not installed setuid" ) ; parseconfig ( DOAS_CONF , 1 ) ; ( void ) strlcpy ( cmdline , argv [ 0 ] , sizeof ( cmdline ) ) ; for ( i = 1 ; i < argc ; i ++ ) { if ( strlcat ( cmdline , " " , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; if ( strlcat ( cmdline , argv [ i ] , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; } cmd = argv [ 0 ] ; if ( ! permit ( uid , groups , ngroups , & rule , target , cmd , ( const char * * ) argv + 1 ) ) { syslog ( LOG_AUTHPRIV | LOG_NOTICE , "command not permitted for %s: %s" , mypw -> pw_name , cmdline ) ; errc ( 1 , EPERM , NULL ) ; } #if defined(USE_SHADOW) if ( ! ( rule -> options & NOPASS ) ) { if ( nflag ) errx ( 1 , "Authorization required" ) ; shadowauth ( mypw -> pw_name , rule -> options & PERSIST ) ; } #elif !defined(USE_PAM) ( void ) nflag ; if ( ! ( rule -> options & NOPASS ) ) errx ( 1 , "Authorization required" ) ; #endif if ( ( p = getenv ( "PATH" ) ) != NULL ) formerpath = strdup ( p ) ; if ( formerpath == NULL ) formerpath = "" ; if ( rule -> cmd ) { if ( setenv ( "PATH" , safepath , 1 ) == - 1 ) err ( 1 , "failed to set PATH '%s'" , safepath ) ; } rv = mygetpwuid_r ( target , & targpwstore , & targpw ) ; if ( rv != 0 ) err ( 1 , "getpwuid_r failed" ) ; if ( targpw == NULL ) errx ( 1 , "no passwd entry for target" ) ; #if defined(USE_PAM) pamauth ( targpw -> pw_name , mypw -> pw_name , ! nflag , rule -> options & NOPASS , rule -> options & PERSIST ) ; #endif #ifdef HAVE_LOGIN_CAP_H if ( setusercontext ( NULL , targpw , target , LOGIN_SETGROUP | LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK | LOGIN_SETUSER ) != 0 ) errx ( 1 , "failed to set user context for target" ) ; #else if ( setresgid ( targpw -> pw_gid , targpw -> pw_gid , targpw -> pw_gid ) != 0 ) err ( 1 , "setresgid" ) ; if ( initgroups ( targpw -> pw_name , targpw -> pw_gid ) != 0 ) err ( 1 , "initgroups" ) ; if ( setresuid ( target , target , target ) != 0 ) err ( 1 , "setresuid" ) ; #endif if ( getcwd ( cwdpath , sizeof ( cwdpath ) ) == NULL ) cwd = "(failed)" ; else cwd = cwdpath ; if ( ! ( rule -> options & NOLOG ) ) { syslog ( LOG_AUTHPRIV | LOG_INFO , "%s ran command %s as %s from %s" , mypw -> pw_name , cmdline , targpw -> pw_name , cwd ) ; } envp = prepenv ( rule , mypw , targpw ) ; if ( rule -> cmd ) { if ( setenv ( "PATH" , safepath , 1 ) == - 1 ) err ( 1 , "failed to set PATH '%s'" , safepath ) ; } else { if ( setenv ( "PATH" , formerpath , 1 ) == - 1 ) err ( 1 , "failed to set PATH '%s'" , formerpath ) ; } execvpe ( cmd , argv , envp ) ; if ( errno == ENOENT ) errx ( 1 , "%s: command not found" , cmd ) ; err ( 1 , "%s" , cmd ) ; }
SetEventListener ( JSContext * aCx , JS :: Handle < JSObject * > aObj , JS :: Handle < jsid > aIdval , bool aStrict , JS :: MutableHandle < JS :: Value > aVp ) { JS_ASSERT ( JSID_IS_INT ( aIdval ) ) ; JS_ASSERT ( JSID_TO_INT ( aIdval ) >= 0 && JSID_TO_INT ( aIdval ) < STRING_COUNT ) ; const char * name = sEventStrings [ JSID_TO_INT ( aIdval ) ] ; DedicatedWorkerGlobalScope * scope = GetInstancePrivate ( aCx , aObj , name ) ; if ( ! scope ) { return false ; } if ( JSVAL_IS_PRIMITIVE ( aVp ) ) { JS_ReportError ( aCx , "Not an event listener!" ) ; return false ; } ErrorResult rv ; JS :: Rooted < JSObject * > listenerObj ( aCx , JSVAL_TO_OBJECT ( aVp ) ) ; scope -> SetEventListener ( NS_ConvertASCIItoUTF16 ( name + 2 ) , listenerObj , rv ) ; if ( rv . Failed ( ) ) { JS_ReportError ( aCx , "Failed to set event listener!" ) ; return false ; } return true ; }
nsresult nsPluginHost :: NewPluginURLStream ( const nsString & aURL , nsNPAPIPluginInstance * aInstance , nsIPluginStreamListener * aListener , nsIInputStream * aPostStream , const char * aHeadersData , PRUint32 aHeadersDataLen ) { nsCOMPtr < nsIURI > url ; nsAutoString absUrl ; nsresult rv ; if ( aURL . Length ( ) <= 0 ) return NS_OK ; nsCOMPtr < nsIDocument > doc ; nsCOMPtr < nsIPluginInstanceOwner > owner ; aInstance -> GetOwner ( getter_AddRefs ( owner ) ) ; if ( owner ) { rv = owner -> GetDocument ( getter_AddRefs ( doc ) ) ; if ( NS_SUCCEEDED ( rv ) && doc ) { rv = NS_MakeAbsoluteURI ( absUrl , aURL , doc -> GetDocBaseURI ( ) ) ; } } if ( absUrl . IsEmpty ( ) ) absUrl . Assign ( aURL ) ; rv = NS_NewURI ( getter_AddRefs ( url ) , absUrl ) ; if ( NS_FAILED ( rv ) ) return rv ; nsCOMPtr < nsIPluginTagInfo > pti = do_QueryInterface ( owner ) ; nsCOMPtr < nsIDOMElement > element ; if ( pti ) pti -> GetDOMElement ( getter_AddRefs ( element ) ) ; PRInt16 shouldLoad = nsIContentPolicy :: ACCEPT ; rv = NS_CheckContentLoadPolicy ( nsIContentPolicy :: TYPE_OBJECT_SUBREQUEST , url , ( doc ? doc -> NodePrincipal ( ) : nsnull ) , element , EmptyCString ( ) , nsnull , & shouldLoad ) ; if ( NS_FAILED ( rv ) ) return rv ; if ( NS_CP_REJECTED ( shouldLoad ) ) { return NS_ERROR_CONTENT_BLOCKED ; } nsRefPtr < nsPluginStreamListenerPeer > listenerPeer = new nsPluginStreamListenerPeer ( ) ; if ( ! listenerPeer ) return NS_ERROR_OUT_OF_MEMORY ; rv = listenerPeer -> Initialize ( url , aInstance , aListener ) ; if ( NS_FAILED ( rv ) ) return rv ; nsCOMPtr < nsIInterfaceRequestor > callbacks ; if ( doc ) { nsIScriptGlobalObject * global = doc -> GetScriptGlobalObject ( ) ; if ( global ) { nsCOMPtr < nsIWebNavigation > webNav = do_GetInterface ( global ) ; callbacks = do_QueryInterface ( webNav ) ; } } nsCOMPtr < nsIChannel > channel ; rv = NS_NewChannel ( getter_AddRefs ( channel ) , url , nsnull , nsnull , callbacks ) ; if ( NS_FAILED ( rv ) ) return rv ; if ( doc ) { channel -> SetOwner ( doc -> NodePrincipal ( ) ) ; nsCOMPtr < nsIScriptChannel > scriptChannel ( do_QueryInterface ( channel ) ) ; if ( scriptChannel ) { scriptChannel -> SetExecutionPolicy ( nsIScriptChannel :: EXECUTE_NORMAL ) ; scriptChannel -> SetExecuteAsync ( PR_FALSE ) ; } } nsCOMPtr < nsIHttpChannel > httpChannel ( do_QueryInterface ( channel ) ) ; if ( httpChannel ) { if ( aPostStream ) { nsCOMPtr < nsISeekableStream > postDataSeekable ( do_QueryInterface ( aPostStream ) ) ; if ( postDataSeekable ) postDataSeekable -> Seek ( nsISeekableStream :: NS_SEEK_SET , 0 ) ; nsCOMPtr < nsIUploadChannel > uploadChannel ( do_QueryInterface ( httpChannel ) ) ; NS_ASSERTION ( uploadChannel , "http must support nsIUploadChannel" ) ; uploadChannel -> SetUploadStream ( aPostStream , EmptyCString ( ) , - 1 ) ; } if ( aHeadersData ) rv = AddHeadersToChannel ( aHeadersData , aHeadersDataLen , httpChannel ) ; } rv = channel -> AsyncOpen ( listenerPeer , nsnull ) ; return rv ; }
void __init files_init ( unsigned long mempages ) { unsigned long n ; filp_cachep = kmem_cache_create ( "filp" , sizeof ( struct file ) , 0 , SLAB_HWCACHE_ALIGN | SLAB_PANIC , NULL ) ; n = ( mempages * ( PAGE_SIZE / 1024 ) ) / 10 ; files_stat . max_files = max_t ( unsigned long , n , NR_FILE ) ; files_defer_init ( ) ; lg_lock_init ( & files_lglock , "files_lglock" ) ; percpu_counter_init ( & nr_files , 0 ) ; }
bool ConstantFolding :: MulConvPushDown ( GraphDef * optimized_graph , NodeDef * node , const GraphProperties & properties ) { if ( ! IsAnyMul ( * node ) || NumNonControlInputs ( * node ) != 2 ) return false ; NodeDef * mul_left_child = node_map_ -> GetNode ( node -> input ( 0 ) ) ; NodeDef * mul_right_child = node_map_ -> GetNode ( node -> input ( 1 ) ) ; const bool left_child_is_constant = IsReallyConstant ( * mul_left_child ) ; const bool right_child_is_constant = IsReallyConstant ( * mul_right_child ) ; if ( ! left_child_is_constant && ! right_child_is_constant ) { return false ; } NodeDef * conv_node = left_child_is_constant ? mul_right_child : mul_left_child ; if ( ! IsConv2D ( * conv_node ) && ! IsConv3D ( * conv_node ) ) { return false ; } if ( node -> device ( ) != mul_left_child -> device ( ) || node -> device ( ) != mul_right_child -> device ( ) ) { return false ; } if ( conv_node -> input_size ( ) < 2 || NumNonControlOutputs ( * conv_node , * node_map_ ) > 1 || nodes_to_preserve_ . find ( conv_node -> name ( ) ) != nodes_to_preserve_ . end ( ) ) { return false ; } NodeDef * conv_left_child = node_map_ -> GetNode ( conv_node -> input ( 0 ) ) ; NodeDef * conv_right_child = node_map_ -> GetNode ( conv_node -> input ( 1 ) ) ; const bool conv_left_is_constant = IsReallyConstant ( * conv_left_child ) ; const bool conv_right_is_constant = IsReallyConstant ( * conv_right_child ) ; if ( ! conv_left_is_constant && ! conv_right_is_constant ) { return false ; } if ( conv_left_is_constant && conv_right_is_constant ) { return false ; } const auto & mul_props = properties . GetOutputProperties ( node -> name ( ) ) ; const auto & conv_props = properties . GetOutputProperties ( conv_node -> name ( ) ) ; if ( mul_props . empty ( ) || conv_props . empty ( ) ) { return false ; } const auto & mul_shape = mul_props [ 0 ] . shape ( ) ; const auto & conv_shape = conv_props [ 0 ] . shape ( ) ; if ( ! ShapesSymbolicallyEqual ( mul_shape , conv_shape ) ) { return false ; } const auto & input_props = properties . GetInputProperties ( conv_node -> name ( ) ) ; if ( input_props . size ( ) < 2 ) { return false ; } const auto & filter_shape = input_props [ 1 ] . shape ( ) ; NodeDef * const_node = left_child_is_constant ? mul_left_child : mul_right_child ; const auto & const_props = properties . GetOutputProperties ( const_node -> name ( ) ) ; if ( const_props . empty ( ) ) { return false ; } const auto & const_shape = const_props [ 0 ] . shape ( ) ; if ( ! IsValidConstShapeForMulConvPushDown ( conv_node -> attr ( ) . at ( "data_format" ) . s ( ) , filter_shape , const_shape ) ) { return false ; } string mul_new_name = AddPrefixToNodeName ( "merged_input" , conv_node -> name ( ) ) ; if ( node_map_ -> NodeExists ( mul_new_name ) ) { return false ; } string conv_const_input = conv_left_is_constant ? conv_node -> input ( 0 ) : conv_node -> input ( 1 ) ; if ( MaybeRemoveControlInput ( conv_node -> name ( ) , const_node , optimized_graph , node_map_ . get ( ) ) ) { MaybeAddControlInput ( conv_const_input , const_node , optimized_graph , node_map_ . get ( ) ) ; } conv_node -> set_name ( node -> name ( ) ) ; node -> set_name ( mul_new_name ) ; if ( conv_left_is_constant ) { node_map_ -> UpdateInput ( conv_node -> name ( ) , node -> input ( 0 ) , mul_new_name ) ; conv_node -> set_input ( 0 , mul_new_name ) ; } else { node_map_ -> UpdateInput ( conv_node -> name ( ) , node -> input ( 1 ) , mul_new_name ) ; conv_node -> set_input ( 1 , mul_new_name ) ; } NodeDef * conv_const_node = conv_left_is_constant ? conv_left_child : conv_right_child ; if ( left_child_is_constant ) { node -> set_input ( 1 , conv_const_node -> name ( ) ) ; } else { node -> set_input ( 0 , conv_const_node -> name ( ) ) ; } node_map_ -> AddNode ( mul_new_name , node ) ; return true ; }
GLContext :: ClearSafely ( ) { GLfloat clearColor [ 4 ] ; GLfloat clearDepth ; GLint clearStencil ; fGetFloatv ( LOCAL_GL_COLOR_CLEAR_VALUE , clearColor ) ; fGetFloatv ( LOCAL_GL_DEPTH_CLEAR_VALUE , & clearDepth ) ; fGetIntegerv ( LOCAL_GL_STENCIL_CLEAR_VALUE , & clearStencil ) ; fClearColor ( 0.0f , 0.0f , 0.0f , 0.0f ) ; fClearStencil ( 0 ) ; fClearDepth ( 1.0f ) ; fClear ( LOCAL_GL_COLOR_BUFFER_BIT | LOCAL_GL_DEPTH_BUFFER_BIT | LOCAL_GL_STENCIL_BUFFER_BIT ) ; fClearColor ( clearColor [ 0 ] , clearColor [ 1 ] , clearColor [ 2 ] , clearColor [ 3 ] ) ; fClearStencil ( clearStencil ) ; fClearDepth ( clearDepth ) ; }
vips_tracked_malloc ( size_t size ) { void * buf ; vips_tracked_init ( ) ; size += 16 ; if ( ! ( buf = g_try_malloc ( size ) ) ) { #ifdef DEBUG g_assert_not_reached ( ) ; #endif /*DEBUG*/ vips_error ( "vips_tracked" , _ ( "out of memory --- size == %dMB" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; g_warning ( _ ( "out of memory --- size == %dMB" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; return ( NULL ) ; } g_mutex_lock ( vips_tracked_mutex ) ; * ( ( size_t * ) buf ) = size ; buf = ( void * ) ( ( char * ) buf + 16 ) ; vips_tracked_mem += size ; if ( vips_tracked_mem > vips_tracked_mem_highwater ) vips_tracked_mem_highwater = vips_tracked_mem ; vips_tracked_allocs += 1 ; #ifdef DEBUG_VERBOSE printf ( "vips_tracked_malloc: %p, %zd bytes\n" , buf , size ) ; #endif /*DEBUG_VERBOSE*/ g_mutex_unlock ( vips_tracked_mutex ) ; VIPS_GATE_MALLOC ( size ) ; return ( buf ) ; }
kex_input_kexinit ( int type , u_int32_t seq , void * ctxt ) { struct ssh * ssh = ctxt ; struct kex * kex = ssh -> kex ; const u_char * ptr ; u_int i ; size_t dlen ; int r ; debug ( "SSH2_MSG_KEXINIT received" ) ; if ( kex == NULL ) return SSH_ERR_INVALID_ARGUMENT ; ptr = sshpkt_ptr ( ssh , & dlen ) ; if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ; for ( i = 0 ; i < KEX_COOKIE_LEN ; i ++ ) if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 ) return r ; for ( i = 0 ; i < PROPOSAL_MAX ; i ++ ) if ( ( r = sshpkt_get_string ( ssh , NULL , NULL ) ) != 0 ) return r ; if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_u32 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) return r ; if ( ! ( kex -> flags & KEX_INIT_SENT ) ) if ( ( r = kex_send_kexinit ( ssh ) ) != 0 ) return r ; if ( ( r = kex_choose_conf ( ssh ) ) != 0 ) return r ; if ( kex -> kex_type < KEX_MAX && kex -> kex [ kex -> kex_type ] != NULL ) return ( kex -> kex [ kex -> kex_type ] ) ( ssh ) ; return SSH_ERR_INTERNAL_ERROR ; }
void Compute ( OpKernelContext * ctx ) override { const Tensor * indices_t , * values_t , * shape_t , * dense_t ; OP_REQUIRES_OK ( ctx , ctx -> input ( "sp_indices" , & indices_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( "sp_values" , & values_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( "sp_shape" , & shape_t ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( "dense" , & dense_t ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsMatrix ( indices_t -> shape ( ) ) , errors :: InvalidArgument ( "Input sp_indices should be a matrix but received shape: " , indices_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsVector ( values_t -> shape ( ) ) && TensorShapeUtils :: IsVector ( shape_t -> shape ( ) ) , errors :: InvalidArgument ( "Inputs sp_values and sp_shape should be vectors " "but received shapes: " , values_t -> shape ( ) . DebugString ( ) , " and " , shape_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsVector ( shape_t -> shape ( ) ) , errors :: InvalidArgument ( "Input sp_shape must be a vector. Got: " , shape_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , values_t -> dim_size ( 0 ) == indices_t -> dim_size ( 0 ) , errors :: InvalidArgument ( "The first dimension of values and indices should match. (" , values_t -> dim_size ( 0 ) , " vs. " , indices_t -> dim_size ( 0 ) , ")" ) ) ; OP_REQUIRES ( ctx , shape_t -> shape ( ) . dim_size ( 0 ) == indices_t -> shape ( ) . dim_size ( 1 ) , errors :: InvalidArgument ( "Number of dimensions must match second dimension of indices. " , "Got " , shape_t -> shape ( ) . dim_size ( 0 ) , " dimensions, indices shape: " , indices_t -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , shape_t -> NumElements ( ) > 0 , errors :: InvalidArgument ( "The shape argument requires at least one element." ) ) ; const auto indices_mat = indices_t -> matrix < int64_t > ( ) ; const auto shape_vec = shape_t -> vec < int64_t > ( ) ; const auto lhs_dims = BCast :: FromShape ( TensorShape ( shape_vec ) ) ; const auto rhs_dims = BCast :: FromShape ( dense_t -> shape ( ) ) ; BCast b ( lhs_dims , rhs_dims , false ) ; auto VecGreaterEq = [ ] ( ArraySlice < int64_t > lhs , ArraySlice < int64_t > rhs ) { if ( lhs . size ( ) < rhs . size ( ) ) return false ; for ( size_t i = 0 ; i < rhs . size ( ) ; ++ i ) { if ( lhs [ lhs . size ( ) - 1 - i ] < rhs [ rhs . size ( ) - 1 - i ] ) return false ; } return true ; } ; OP_REQUIRES ( ctx , VecGreaterEq ( lhs_dims , rhs_dims ) && b . IsValid ( ) , errors :: InvalidArgument ( "SparseDenseBinaryOpShared broadcasts dense to sparse " "only; got incompatible shapes: [" , absl :: StrJoin ( lhs_dims , "," ) , "] vs. [" , absl :: StrJoin ( rhs_dims , "," ) , "]" ) ) ; Tensor * output_values = nullptr ; Tensor dense_gathered ; const int64_t nnz = indices_t -> dim_size ( 0 ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( 0 , TensorShape ( { nnz } ) , & output_values ) ) ; OP_REQUIRES_OK ( ctx , ctx -> allocate_temp ( DataTypeToEnum < T > :: value , TensorShape ( { nnz } ) , & dense_gathered ) ) ; bool op_is_div = false ; if ( absl :: StrContains ( ctx -> op_kernel ( ) . type_string_view ( ) , "Div" ) ) { op_is_div = true ; } auto dense_gathered_flat = dense_gathered . flat < T > ( ) ; const int ndims = lhs_dims . size ( ) ; switch ( ndims ) { #define CASE(NDIM)                                                             \   case NDIM: {                                                                 \     TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \         dense_t->shaped<T, NDIM>(b.y_reshape())                                \             .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \     Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \     bool indices_valid = true;                                                 \     for (int i = 0; i < nnz; ++i) {                                            \       for (int d = 0; d < NDIM; ++d) {                                         \         idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \         if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \           indices_valid = false;                                               \         }                                                                      \       }                                                                        \       OP_REQUIRES(                                                             \           ctx, indices_valid,                                                  \           errors::InvalidArgument("Provided indices are out-of-bounds w.r.t. " \                                   "dense side with broadcasted shape"));       \       dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \       if (op_is_div) {                                                         \         OP_REQUIRES(ctx, dense_gathered_flat(i) != 0,                          \                     errors::InvalidArgument(                                   \                         "SparseDenseCwiseDiv cannot divide by zero,"           \                         "but input dense tensor contains zero "));             \       }                                                                        \     }                                                                          \     break;                                                                     \   } CASE ( 1 ) ; CASE ( 2 ) ; CASE ( 3 ) ; CASE ( 4 ) ; CASE ( 5 ) ; default : OP_REQUIRES ( ctx , false , errors :: InvalidArgument ( "Only tensors with ranks between 1 and 5 " "are currently supported.  Tensor rank: " , ndims ) ) ; #undef CASE } output_values -> flat < T > ( ) . device ( ctx -> eigen_device < Device > ( ) ) = values_t -> flat < T > ( ) . binaryExpr ( dense_gathered_flat , typename Functor :: func ( ) ) ; }
static int su3000_i2c_transfer ( struct i2c_adapter * adap , struct i2c_msg msg [ ] , int num ) { struct dvb_usb_device * d = i2c_get_adapdata ( adap ) ; u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ; if ( ! d ) return - ENODEV ; if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) return - EAGAIN ; switch ( num ) { case 1 : switch ( msg [ 0 ] . addr ) { case SU3000_STREAM_CTRL : obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ; obuf [ 1 ] = 3 ; obuf [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 ) err ( "i2c transfer failed." ) ; break ; case DW2102_RC_QUERY : obuf [ 0 ] = 0x10 ; if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 ) err ( "i2c transfer failed." ) ; msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ; msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ; break ; default : obuf [ 0 ] = 0x08 ; obuf [ 1 ] = msg [ 0 ] . addr ; obuf [ 2 ] = msg [ 0 ] . len ; memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 , ibuf , 1 , 0 ) < 0 ) err ( "i2c transfer failed." ) ; } break ; case 2 : obuf [ 0 ] = 0x09 ; obuf [ 1 ] = msg [ 0 ] . len ; obuf [ 2 ] = msg [ 1 ] . len ; obuf [ 3 ] = msg [ 0 ] . addr ; memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 , ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 ) err ( "i2c transfer failed." ) ; memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ; break ; default : warn ( "more than 2 i2c messages at a time is not handled yet." ) ; break ; } mutex_unlock ( & d -> i2c_mutex ) ; return num ; }
UpgradeSchemaFrom7To8 ( mozIStorageConnection * aConnection ) { NS_ASSERTION ( ! NS_IsMainThread ( ) , "Wrong thread!" ) ; NS_ASSERTION ( IndexedDatabaseManager :: IsMainProcess ( ) , "Wrong process!" ) ; PROFILER_LABEL ( "IndexedDB" , "UpgradeSchemaFrom7To8" ) ; nsresult rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( "CREATE TEMPORARY TABLE temp_upgrade (" "id, " "object_store_id, " "name, " "key_path, " "unique_index, " "object_store_autoincrement" ");" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( "INSERT INTO temp_upgrade " "SELECT id, object_store_id, name, key_path, " "unique_index, object_store_autoincrement " "FROM object_store_index;" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( "DROP TABLE object_store_index;" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( "CREATE TABLE object_store_index (" "id INTEGER, " "object_store_id INTEGER NOT NULL, " "name TEXT NOT NULL, " "key_path TEXT NOT NULL, " "unique_index INTEGER NOT NULL, " "multientry INTEGER NOT NULL, " "object_store_autoincrement INTERGER NOT NULL, " "PRIMARY KEY (id), " "UNIQUE (object_store_id, name), " "FOREIGN KEY (object_store_id) REFERENCES object_store(id) ON DELETE " "CASCADE" ");" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( "INSERT INTO object_store_index " "SELECT id, object_store_id, name, key_path, " "unique_index, 0, object_store_autoincrement " "FROM temp_upgrade;" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aConnection -> ExecuteSimpleSQL ( NS_LITERAL_CSTRING ( "DROP TABLE temp_upgrade;" ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = aConnection -> SetSchemaVersion ( 8 ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; return NS_OK ; }
void LocalEmbedderHeapTracer :: SetEmbedderStackStateForNextFinalization ( EmbedderHeapTracer :: EmbedderStackState stack_state ) { if ( ! InUse ( ) ) return ; embedder_stack_state_ = stack_state ; }
smbhash ( unsigned char * out , const unsigned char * in , unsigned char * key ) { int rc ; unsigned char key2 [ 8 ] ; struct crypto_skcipher * tfm_des ; struct scatterlist sgin , sgout ; struct skcipher_request * req ; str_to_key ( key , key2 ) ; tfm_des = crypto_alloc_skcipher ( "ecb(des)" , 0 , CRYPTO_ALG_ASYNC ) ; if ( IS_ERR ( tfm_des ) ) { rc = PTR_ERR ( tfm_des ) ; cifs_dbg ( VFS , "could not allocate des crypto API\n" ) ; goto smbhash_err ; } req = skcipher_request_alloc ( tfm_des , GFP_KERNEL ) ; if ( ! req ) { rc = - ENOMEM ; cifs_dbg ( VFS , "could not allocate des crypto API\n" ) ; goto smbhash_free_skcipher ; } crypto_skcipher_setkey ( tfm_des , key2 , 8 ) ; sg_init_one ( & sgin , in , 8 ) ; sg_init_one ( & sgout , out , 8 ) ; skcipher_request_set_callback ( req , 0 , NULL , NULL ) ; skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ; rc = crypto_skcipher_encrypt ( req ) ; if ( rc ) cifs_dbg ( VFS , "could not encrypt crypt key rc: %d\n" , rc ) ; skcipher_request_free ( req ) ; smbhash_free_skcipher : crypto_free_skcipher ( tfm_des ) ; smbhash_err : return rc ; }
static bool MigrateDeprecated ( Handle < Object > object ) { if ( ! object -> IsJSObject ( ) ) return false ; Handle < JSObject > receiver = Handle < JSObject > :: cast ( object ) ; if ( ! receiver -> map ( ) -> is_deprecated ( ) ) return false ; JSObject :: MigrateInstance ( Handle < JSObject > :: cast ( object ) ) ; return true ; }
static void ieee802_11_rx_wnmsleep_req ( struct hostapd_data * hapd , const u8 * addr , const u8 * frm , int len ) { const u8 * pos = frm ; u8 dialog_token ; struct wnm_sleep_element * wnmsleep_ie = NULL ; u8 * tfsreq_ie_start = NULL ; u8 * tfsreq_ie_end = NULL ; u16 tfsreq_ie_len = 0 ; dialog_token = * pos ++ ; while ( pos + 1 < frm + len ) { u8 ie_len = pos [ 1 ] ; if ( pos + 2 + ie_len > frm + len ) break ; if ( * pos == WLAN_EID_WNMSLEEP && ie_len >= ( int ) sizeof ( * wnmsleep_ie ) - 2 ) wnmsleep_ie = ( struct wnm_sleep_element * ) pos ; else if ( * pos == WLAN_EID_TFS_REQ ) { if ( ! tfsreq_ie_start ) tfsreq_ie_start = ( u8 * ) pos ; tfsreq_ie_end = ( u8 * ) pos ; } else wpa_printf ( MSG_DEBUG , "WNM: EID %d not recognized" , * pos ) ; pos += ie_len + 2 ; } if ( ! wnmsleep_ie ) { wpa_printf ( MSG_DEBUG , "No WNM-Sleep IE found" ) ; return ; } if ( wnmsleep_ie -> action_type == WNM_SLEEP_MODE_ENTER && tfsreq_ie_start && tfsreq_ie_end && tfsreq_ie_end - tfsreq_ie_start >= 0 ) { tfsreq_ie_len = ( tfsreq_ie_end + tfsreq_ie_end [ 1 ] + 2 ) - tfsreq_ie_start ; wpa_printf ( MSG_DEBUG , "TFS Req IE(s) found" ) ; if ( ieee80211_11_set_tfs_ie ( hapd , addr , tfsreq_ie_start , & tfsreq_ie_len , WNM_SLEEP_TFS_REQ_IE_SET ) ) wpa_printf ( MSG_DEBUG , "Fail to set TFS Req IE" ) ; } ieee802_11_send_wnmsleep_resp ( hapd , addr , dialog_token , wnmsleep_ie -> action_type , le_to_host16 ( wnmsleep_ie -> intval ) ) ; if ( wnmsleep_ie -> action_type == WNM_SLEEP_MODE_EXIT ) { ieee80211_11_set_tfs_ie ( hapd , addr , tfsreq_ie_start , & tfsreq_ie_len , WNM_SLEEP_TFS_IE_DEL ) ; } }
void AverageEvalQuantizedInt16 ( TfLiteContext * context , TfLiteNode * node , TfLitePoolParams * params , OpData * data , const TfLiteTensor * input , TfLiteTensor * output ) { int32_t activation_min ; int32_t activation_max ; CalculateActivationRangeQuantized ( context , params -> activation , output , & activation_min , & activation_max ) ; #define TF_LITE_AVERAGE_POOL(type)                                         \   tflite::PoolParams op_params;                                            \   op_params.stride_height = params->stride_height;                         \   op_params.stride_width = params->stride_width;                           \   op_params.filter_height = params->filter_height;                         \   op_params.filter_width = params->filter_width;                           \   op_params.padding_values.height = data->padding.height;                  \   op_params.padding_values.width = data->padding.width;                    \   op_params.quantized_activation_min = activation_min;                     \   op_params.quantized_activation_max = activation_max;                     \   type::AveragePool(op_params, GetTensorShape(input),                      \                     GetTensorData<int16_t>(input), GetTensorShape(output), \                     GetTensorData<int16_t>(output)) TF_LITE_AVERAGE_POOL ( reference_integer_ops ) ; #undef TF_LITE_AVERAGE_POOL }
void nsSHistory :: UpdateRootBrowsingContextState ( ) { if ( mRootBC && mRootBC -> EverAttached ( ) ) { bool sameDocument = IsEmptyOrHasEntriesForSingleTopLevelPage ( ) ; if ( sameDocument != mRootBC -> GetIsSingleToplevelInHistory ( ) ) { Unused < < mRootBC -> SetIsSingleToplevelInHistory ( sameDocument ) ; } } }
static void init_intra_pred_fn_ptrs ( void ) { #define intra_pred_allsizes(l, type) \   l[0] = vp9_##type##_predictor_4x4; \   l[1] = vp9_##type##_predictor_8x8; \   l[2] = vp9_##type##_predictor_16x16; \   l[3] = vp9_##type##_predictor_32x32 intra_pred_allsizes ( pred [ V_PRED ] , v ) ; intra_pred_allsizes ( pred [ H_PRED ] , h ) ; intra_pred_allsizes ( pred [ D207_PRED ] , d207 ) ; intra_pred_allsizes ( pred [ D45_PRED ] , d45 ) ; intra_pred_allsizes ( pred [ D63_PRED ] , d63 ) ; intra_pred_allsizes ( pred [ D117_PRED ] , d117 ) ; intra_pred_allsizes ( pred [ D135_PRED ] , d135 ) ; intra_pred_allsizes ( pred [ D153_PRED ] , d153 ) ; intra_pred_allsizes ( pred [ TM_PRED ] , tm ) ; intra_pred_allsizes ( dc_pred [ 0 ] [ 0 ] , dc_128 ) ; intra_pred_allsizes ( dc_pred [ 0 ] [ 1 ] , dc_top ) ; intra_pred_allsizes ( dc_pred [ 1 ] [ 0 ] , dc_left ) ; intra_pred_allsizes ( dc_pred [ 1 ] [ 1 ] , dc ) ; #undef intra_pred_allsizes }
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , "\nError: fread return a number of element different from the expected.\n" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; #if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; #endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , "tga_readheader: memory out\n" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , "\nError: fread return a number of element different from the expected.\n" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , "Sorry, compressed tga files are not currently supported.\n" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , "File contains a palette - not yet supported." ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
nsTableRowGroupFrame :: InsertFrames ( ChildListID aListID , nsIFrame * aPrevFrame , nsFrameList & aFrameList ) { NS_ASSERTION ( aListID == kPrincipalList , "unexpected child list" ) ; NS_ASSERTION ( ! aPrevFrame || aPrevFrame -> GetParent ( ) == this , "inserting after sibling frame with different parent" ) ; ClearRowCursor ( ) ; nsTableFrame * tableFrame = nsTableFrame :: GetTableFrame ( this ) ; nsTArray < nsTableRowFrame * > rows ; bool gotFirstRow = false ; for ( nsFrameList :: Enumerator e ( aFrameList ) ; ! e . AtEnd ( ) ; e . Next ( ) ) { nsTableRowFrame * rowFrame = do_QueryFrame ( e . get ( ) ) ; NS_ASSERTION ( rowFrame , "Unexpected frame; frame constructor screwed up" ) ; if ( rowFrame ) { NS_ASSERTION ( NS_STYLE_DISPLAY_TABLE_ROW == e . get ( ) -> StyleDisplay ( ) -> mDisplay , "wrong display type on rowframe" ) ; rows . AppendElement ( rowFrame ) ; if ( ! gotFirstRow ) { rowFrame -> SetFirstInserted ( true ) ; gotFirstRow = true ; tableFrame -> SetRowInserted ( true ) ; } } } int32_t startRowIndex = GetStartRowIndex ( ) ; mFrames . InsertFrames ( nullptr , aPrevFrame , aFrameList ) ; int32_t numRows = rows . Length ( ) ; if ( numRows > 0 ) { nsTableRowFrame * prevRow = ( nsTableRowFrame * ) nsTableFrame :: GetFrameAtOrBefore ( this , aPrevFrame , nsGkAtoms :: tableRowFrame ) ; int32_t rowIndex = ( prevRow ) ? prevRow -> GetRowIndex ( ) + 1 : startRowIndex ; tableFrame -> InsertRows ( this , rows , rowIndex , true ) ; PresContext ( ) -> PresShell ( ) -> FrameNeedsReflow ( this , nsIPresShell :: eTreeChange , NS_FRAME_HAS_DIRTY_CHILDREN ) ; tableFrame -> SetGeometryDirty ( ) ; } }
nsObjectLoadingContent :: NotifyContentObjectWrapper ( ) { nsCOMPtr < nsIContent > thisContent = do_QueryInterface ( static_cast < nsIImageLoadingContent * > ( this ) ) ; nsCOMPtr < nsIDocument > doc = thisContent -> GetDocument ( ) ; if ( ! doc ) return ; nsIScriptGlobalObject * sgo = doc -> GetScopeObject ( ) ; if ( ! sgo ) return ; nsIScriptContext * scx = sgo -> GetContext ( ) ; if ( ! scx ) return ; JSContext * cx = scx -> GetNativeContext ( ) ; nsCxPusher pusher ; pusher . Push ( cx , nsCxPusher :: ASSERT_SCRIPT_CONTEXT ) ; nsCOMPtr < nsIXPConnectWrappedNative > wrapper ; nsContentUtils :: XPConnect ( ) -> GetWrappedNativeOfNativeObject ( cx , sgo -> GetGlobalJSObject ( ) , thisContent , NS_GET_IID ( nsISupports ) , getter_AddRefs ( wrapper ) ) ; if ( ! wrapper ) { return ; } JSObject * obj = nullptr ; nsresult rv = wrapper -> GetJSObject ( & obj ) ; if ( NS_FAILED ( rv ) ) return ; nsHTMLPluginObjElementSH :: SetupProtoChain ( wrapper , cx , obj ) ; }
mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ipt_entry * e = ( struct ipt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 < < hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ipt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 < < hook ) ; if ( e -> comefrom & ( 1 < < NF_INET_NUMHOOKS ) ) { pr_err ( "iptables: loop hook %u pos %u %08X.\n" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 < < hook ) | ( 1 < < NF_INET_NUMHOOKS ) ) ; if ( ( e -> target_offset == sizeof ( struct ipt_entry ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 && unconditional ( & e -> ip ) ) || visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( "mark_source_chains: bad " "negative verdict (%i)\n" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 < < NF_INET_NUMHOOKS ) ; #ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 < < NF_INET_NUMHOOKS ) ) { duprintf ( "Back unset " "on hook %u " "rule %u\n" , hook , pos ) ; } #endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ipt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ipt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ipt_entry ) ) { duprintf ( "mark_source_chains: " "bad verdict (%i)\n" , newpos ) ; return 0 ; } duprintf ( "Jump rule %u -> %u\n" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ipt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( "Finished chain %u\n" , hook ) ; } return 1 ; }
void ecall_encrypt ( uint8_t * plaintext , uint32_t plaintext_length , uint8_t * ciphertext , uint32_t cipher_length ) { try { assert ( cipher_length >= plaintext_length + SGX_AESGCM_IV_SIZE + SGX_AESGCM_MAC_SIZE ) ; ( void ) cipher_length ; ( void ) plaintext_length ; encrypt ( plaintext , plaintext_length , ciphertext ) ; } catch ( const std :: runtime_error & e ) { ocall_throw ( e . what ( ) ) ; } }
Response InjectedScript :: CallFrameScope :: findInjectedScript ( V8InspectorSessionImpl * session ) { std :: unique_ptr < RemoteCallFrameId > remoteId ; Response response = RemoteCallFrameId :: parse ( m_remoteCallFrameId , & remoteId ) ; if ( ! response . isSuccess ( ) ) return response ; m_frameOrdinal = static_cast < size_t > ( remoteId -> frameOrdinal ( ) ) ; return session -> findInjectedScript ( remoteId . get ( ) , m_injectedScript ) ; }
long mkvparser :: UnserializeString ( IMkvReader * pReader , long long pos , long long size_ , char * & str ) { delete [ ] str ; str = NULL ; if ( size_ >= LONG_MAX ) return E_FILE_FORMAT_INVALID ; const long size = static_cast < long > ( size_ ) ; str = new ( std :: nothrow ) char [ size + 1 ] ; if ( str == NULL ) return - 1 ; unsigned char * const buf = reinterpret_cast < unsigned char * > ( str ) ; const long status = pReader -> Read ( pos , size , buf ) ; if ( status ) { delete [ ] str ; str = NULL ; return status ; } str [ size ] = '\0' ; return 0 ; }
% * / static Image * ReadSCREENSHOTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = ( Image * ) NULL ; #if defined(MAGICKCORE_WINGDI32_DELEGATE) { BITMAPINFO bmi ; DISPLAY_DEVICE device ; HBITMAP bitmap , bitmapOld ; HDC bitmapDC , hDC ; Image * screen ; int i ; MagickBooleanType status ; register Quantum * q ; register ssize_t x ; RGBTRIPLE * p ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; i = 0 ; device . cb = sizeof ( device ) ; image = ( Image * ) NULL ; while ( EnumDisplayDevices ( NULL , i , & device , 0 ) && ++ i ) { if ( ( device . StateFlags & DISPLAY_DEVICE_ACTIVE ) != DISPLAY_DEVICE_ACTIVE ) continue ; hDC = CreateDC ( device . DeviceName , device . DeviceName , NULL , NULL ) ; if ( hDC == ( HDC ) NULL ) ThrowReaderException ( CoderError , "UnableToCreateDC" ) ; screen = AcquireImage ( image_info , exception ) ; screen -> columns = ( size_t ) GetDeviceCaps ( hDC , HORZRES ) ; screen -> rows = ( size_t ) GetDeviceCaps ( hDC , VERTRES ) ; screen -> storage_class = DirectClass ; status = SetImageExtent ( screen , screen -> columns , screen -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; bitmapDC = CreateCompatibleDC ( hDC ) ; if ( bitmapDC == ( HDC ) NULL ) { DeleteDC ( hDC ) ; ThrowReaderException ( CoderError , "UnableToCreateDC" ) ; } ( void ) ResetMagickMemory ( & bmi , 0 , sizeof ( BITMAPINFO ) ) ; bmi . bmiHeader . biSize = sizeof ( BITMAPINFOHEADER ) ; bmi . bmiHeader . biWidth = ( LONG ) screen -> columns ; bmi . bmiHeader . biHeight = ( - 1 ) * ( LONG ) screen -> rows ; bmi . bmiHeader . biPlanes = 1 ; bmi . bmiHeader . biBitCount = 24 ; bmi . bmiHeader . biCompression = BI_RGB ; bitmap = CreateDIBSection ( hDC , & bmi , DIB_RGB_COLORS , ( void * * ) & p , NULL , 0 ) ; if ( bitmap == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; ThrowReaderException ( CoderError , "UnableToCreateBitmap" ) ; } bitmapOld = ( HBITMAP ) SelectObject ( bitmapDC , bitmap ) ; if ( bitmapOld == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; ThrowReaderException ( CoderError , "UnableToCreateBitmap" ) ; } BitBlt ( bitmapDC , 0 , 0 , ( int ) screen -> columns , ( int ) screen -> rows , hDC , 0 , 0 , SRCCOPY ) ; ( void ) SelectObject ( bitmapDC , bitmapOld ) ; for ( y = 0 ; y < ( ssize_t ) screen -> rows ; y ++ ) { q = QueueAuthenticPixels ( screen , 0 , y , screen -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) screen -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( p -> rgbtRed ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( p -> rgbtGreen ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( p -> rgbtBlue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( screen , exception ) == MagickFalse ) break ; } DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; } } #elif defined(MAGICKCORE_X11_DELEGATE) { const char * option ; XImportInfo ximage_info ; XGetImportInfo ( & ximage_info ) ; option = GetImageOption ( image_info , "x:screen" ) ; if ( option != ( const char * ) NULL ) ximage_info . screen = IsStringTrue ( option ) ; option = GetImageOption ( image_info , "x:silent" ) ; if ( option != ( const char * ) NULL ) ximage_info . silent = IsStringTrue ( option ) ; image = XImportImage ( image_info , & ximage_info , exception ) ; } #endif
void FXJS_DefineObjMethod ( v8 :: Isolate * pIsolate , int nObjDefnID , const wchar_t * sMethodName , v8 :: FunctionCallback pMethodCall ) { v8 :: Isolate :: Scope isolate_scope ( pIsolate ) ; v8 :: HandleScope handle_scope ( pIsolate ) ; CFX_ByteString bsMethodName = CFX_WideString ( sMethodName ) . UTF8Encode ( ) ; CFXJS_ObjDefinition * pObjDef = CFXJS_ObjDefinition :: ForID ( pIsolate , nObjDefnID ) ; pObjDef -> GetInstanceTemplate ( ) -> Set ( v8 :: String :: NewFromUtf8 ( pIsolate , bsMethodName . c_str ( ) , v8 :: NewStringType :: kNormal ) . ToLocalChecked ( ) , v8 :: FunctionTemplate :: New ( pIsolate , pMethodCall , v8 :: Local < v8 :: Value > ( ) , pObjDef -> GetSignature ( ) ) , v8 :: ReadOnly ) ; }
static int fib6_add_rt2node ( struct fib6_node * fn , struct rt6_info * rt , struct nl_info * info ) { struct rt6_info * iter = NULL ; struct rt6_info * * ins ; int replace = ( info -> nlh && ( info -> nlh -> nlmsg_flags & NLM_F_REPLACE ) ) ; int add = ( ! info -> nlh || ( info -> nlh -> nlmsg_flags & NLM_F_CREATE ) ) ; int found = 0 ; ins = & fn -> leaf ; for ( iter = fn -> leaf ; iter ; iter = iter -> dst . rt6_next ) { if ( iter -> rt6i_metric == rt -> rt6i_metric ) { if ( info -> nlh && ( info -> nlh -> nlmsg_flags & NLM_F_EXCL ) ) return - EEXIST ; if ( replace ) { found ++ ; break ; } if ( iter -> dst . dev == rt -> dst . dev && iter -> rt6i_idev == rt -> rt6i_idev && ipv6_addr_equal ( & iter -> rt6i_gateway , & rt -> rt6i_gateway ) ) { if ( rt -> rt6i_nsiblings ) rt -> rt6i_nsiblings = 0 ; if ( ! ( iter -> rt6i_flags & RTF_EXPIRES ) ) return - EEXIST ; if ( ! ( rt -> rt6i_flags & RTF_EXPIRES ) ) rt6_clean_expires ( iter ) ; else rt6_set_expires ( iter , rt -> dst . expires ) ; return - EEXIST ; } if ( rt -> rt6i_flags & RTF_GATEWAY && ! ( rt -> rt6i_flags & RTF_EXPIRES ) && ! ( iter -> rt6i_flags & RTF_EXPIRES ) ) rt -> rt6i_nsiblings ++ ; } if ( iter -> rt6i_metric > rt -> rt6i_metric ) break ; ins = & iter -> dst . rt6_next ; } if ( ins == & fn -> leaf ) fn -> rr_ptr = NULL ; if ( rt -> rt6i_nsiblings ) { unsigned int rt6i_nsiblings ; struct rt6_info * sibling , * temp_sibling ; sibling = fn -> leaf ; while ( sibling ) { if ( sibling -> rt6i_metric == rt -> rt6i_metric ) { list_add_tail ( & rt -> rt6i_siblings , & sibling -> rt6i_siblings ) ; break ; } sibling = sibling -> dst . rt6_next ; } rt6i_nsiblings = 0 ; list_for_each_entry_safe ( sibling , temp_sibling , & rt -> rt6i_siblings , rt6i_siblings ) { sibling -> rt6i_nsiblings ++ ; BUG_ON ( sibling -> rt6i_nsiblings != rt -> rt6i_nsiblings ) ; rt6i_nsiblings ++ ; } BUG_ON ( rt6i_nsiblings != rt -> rt6i_nsiblings ) ; } if ( ! replace ) { if ( ! add ) pr_warn ( "NLM_F_CREATE should be set when creating new route\n" ) ; add : rt -> dst . rt6_next = iter ; * ins = rt ; rt -> rt6i_node = fn ; atomic_inc ( & rt -> rt6i_ref ) ; inet6_rt_notify ( RTM_NEWROUTE , rt , info ) ; info -> nl_net -> ipv6 . rt6_stats -> fib_rt_entries ++ ; if ( ! ( fn -> fn_flags & RTN_RTINFO ) ) { info -> nl_net -> ipv6 . rt6_stats -> fib_route_nodes ++ ; fn -> fn_flags |= RTN_RTINFO ; } } else { if ( ! found ) { if ( add ) goto add ; pr_warn ( "NLM_F_REPLACE set, but no existing node found!\n" ) ; return - ENOENT ; } * ins = rt ; rt -> rt6i_node = fn ; rt -> dst . rt6_next = iter -> dst . rt6_next ; atomic_inc ( & rt -> rt6i_ref ) ; inet6_rt_notify ( RTM_NEWROUTE , rt , info ) ; rt6_release ( iter ) ; if ( ! ( fn -> fn_flags & RTN_RTINFO ) ) { info -> nl_net -> ipv6 . rt6_stats -> fib_route_nodes ++ ; fn -> fn_flags |= RTN_RTINFO ; } } return 0 ; }
js_watch_set ( JSContext * cx , JSObject * obj , jsval id , jsval * vp ) { JSRuntime * rt ; JSWatchPoint * wp ; JSScopeProperty * sprop ; jsval propid , userid ; JSScope * scope ; JSBool ok ; rt = cx -> runtime ; DBG_LOCK ( rt ) ; for ( wp = ( JSWatchPoint * ) rt -> watchPointList . next ; & wp -> links != & rt -> watchPointList ; wp = ( JSWatchPoint * ) wp -> links . next ) { sprop = wp -> sprop ; if ( wp -> object == obj && SPROP_USERID ( sprop ) == id && ! ( wp -> flags & JSWP_HELD ) ) { wp -> flags |= JSWP_HELD ; DBG_UNLOCK ( rt ) ; JS_LOCK_OBJ ( cx , obj ) ; propid = ID_TO_VALUE ( sprop -> id ) ; userid = ( sprop -> flags & SPROP_HAS_SHORTID ) ? INT_TO_JSVAL ( sprop -> shortid ) : propid ; scope = OBJ_SCOPE ( obj ) ; JS_UNLOCK_OBJ ( cx , obj ) ; ok = wp -> handler ( cx , obj , propid , SPROP_HAS_VALID_SLOT ( sprop , scope ) ? OBJ_GET_SLOT ( cx , obj , sprop -> slot ) : JSVAL_VOID , vp , wp -> closure ) ; if ( ok ) { JSObject * closure ; JSClass * clasp ; JSFunction * fun ; JSScript * script ; JSBool injectFrame ; uintN nslots ; jsval smallv [ 5 ] ; jsval * argv ; JSStackFrame frame ; JSFrameRegs regs ; closure = ( JSObject * ) wp -> closure ; clasp = OBJ_GET_CLASS ( cx , closure ) ; if ( clasp == & js_FunctionClass ) { fun = GET_FUNCTION_PRIVATE ( cx , closure ) ; script = FUN_SCRIPT ( fun ) ; } else if ( clasp == & js_ScriptClass ) { fun = NULL ; script = ( JSScript * ) JS_GetPrivate ( cx , closure ) ; } else { fun = NULL ; script = NULL ; } nslots = 2 ; injectFrame = JS_TRUE ; if ( fun ) { nslots += FUN_MINARGS ( fun ) ; if ( ! FUN_INTERPRETED ( fun ) ) { nslots += fun -> u . n . extra ; injectFrame = ! ( fun -> flags & JSFUN_FAST_NATIVE ) ; } } if ( injectFrame ) { if ( nslots <= JS_ARRAY_LENGTH ( smallv ) ) { argv = smallv ; } else { argv = ( jsval * ) JS_malloc ( cx , nslots * sizeof ( jsval ) ) ; if ( ! argv ) { DBG_LOCK ( rt ) ; DropWatchPointAndUnlock ( cx , wp , JSWP_HELD ) ; return JS_FALSE ; } } argv [ 0 ] = OBJECT_TO_JSVAL ( closure ) ; argv [ 1 ] = JSVAL_NULL ; memset ( argv + 2 , 0 , ( nslots - 2 ) * sizeof ( jsval ) ) ; memset ( & frame , 0 , sizeof ( frame ) ) ; frame . script = script ; frame . regs = NULL ; if ( script ) { JS_ASSERT ( script -> length >= JSOP_STOP_LENGTH ) ; regs . pc = script -> code + script -> length - JSOP_STOP_LENGTH ; regs . sp = NULL ; frame . regs = & regs ; } frame . callee = closure ; frame . fun = fun ; frame . argv = argv + 2 ; frame . down = js_GetTopStackFrame ( cx ) ; frame . scopeChain = OBJ_GET_PARENT ( cx , closure ) ; cx -> fp = & frame ; } #ifdef __GNUC__ else argv = NULL ; #endif ok = ! wp -> setter || ( ( sprop -> attrs & JSPROP_SETTER ) ? js_InternalCall ( cx , obj , OBJECT_TO_JSVAL ( ( JSObject * ) wp -> setter ) , 1 , vp , vp ) : wp -> setter ( cx , OBJ_THIS_OBJECT ( cx , obj ) , userid , vp ) ) ; if ( injectFrame ) { if ( frame . callobj ) ok &= js_PutCallObject ( cx , & frame ) ; if ( frame . argsobj ) ok &= js_PutArgsObject ( cx , & frame ) ; cx -> fp = frame . down ; if ( argv != smallv ) JS_free ( cx , argv ) ; } } DBG_LOCK ( rt ) ; return DropWatchPointAndUnlock ( cx , wp , JSWP_HELD ) && ok ; } } DBG_UNLOCK ( rt ) ; return JS_TRUE ; }
TEST ( stagefright_MPEG4Metadata , test_case_mp4_skimming ) { static const size_t step = 4u ; nsRefPtr < MediaByteBuffer > buffer = new MediaByteBuffer ( test_case_mp4_len ) ; buffer -> AppendElements ( test_case_mp4 , test_case_mp4_len ) ; for ( size_t offset = 0 ; offset < test_case_mp4_len - step ; offset += step ) { nsRefPtr < BufferStream > stream = new BufferStream ( buffer ) ; MP4Metadata :: HasCompleteMetadata ( stream ) ; nsRefPtr < MediaByteBuffer > metadataBuffer = MP4Metadata :: Metadata ( stream ) ; MP4Metadata metadata ( stream ) ; buffer -> RemoveElementsAt ( 0 , step ) ; } }
OMX_ERRORTYPE SoftFlacEncoder :: internalGetParameter ( OMX_INDEXTYPE index , OMX_PTR params ) { ALOGV ( "SoftFlacEncoder::internalGetParameter(index=0x%x)" , index ) ; switch ( index ) { case OMX_IndexParamAudioPcm : { OMX_AUDIO_PARAM_PCMMODETYPE * pcmParams = ( OMX_AUDIO_PARAM_PCMMODETYPE * ) params ; if ( pcmParams -> nPortIndex > 1 ) { return OMX_ErrorUndefined ; } pcmParams -> eNumData = OMX_NumericalDataSigned ; pcmParams -> eEndian = OMX_EndianBig ; pcmParams -> bInterleaved = OMX_TRUE ; pcmParams -> nBitPerSample = 16 ; pcmParams -> ePCMMode = OMX_AUDIO_PCMModeLinear ; pcmParams -> eChannelMapping [ 0 ] = OMX_AUDIO_ChannelLF ; pcmParams -> eChannelMapping [ 1 ] = OMX_AUDIO_ChannelRF ; pcmParams -> nChannels = mNumChannels ; pcmParams -> nSamplingRate = mSampleRate ; return OMX_ErrorNone ; } case OMX_IndexParamAudioFlac : { OMX_AUDIO_PARAM_FLACTYPE * flacParams = ( OMX_AUDIO_PARAM_FLACTYPE * ) params ; flacParams -> nCompressionLevel = mCompressionLevel ; flacParams -> nChannels = mNumChannels ; flacParams -> nSampleRate = mSampleRate ; return OMX_ErrorNone ; } default : return SimpleSoftOMXComponent :: internalGetParameter ( index , params ) ; } }
void FLAC__lpc_compute_residual_from_qlp_coefficients ( const FLAC__int32 * data , unsigned data_len , const FLAC__int32 qlp_coeff [ ] , unsigned order , int lp_quantization , FLAC__int32 residual [ ] ) #if defined(FLAC__OVERFLOW_DETECT) || !defined(FLAC__LPC_UNROLLED_FILTER_LOOPS) { FLAC__int64 sumo ; unsigned i , j ; FLAC__int32 sum ; const FLAC__int32 * history ; #ifdef FLAC__OVERFLOW_DETECT_VERBOSE fprintf ( stderr , "FLAC__lpc_compute_residual_from_qlp_coefficients: data_len=%d, order=%u, lpq=%d" , data_len , order , lp_quantization ) ; for ( i = 0 ; i < order ; i ++ ) fprintf ( stderr , ", q[%u]=%d" , i , qlp_coeff [ i ] ) ; fprintf ( stderr , "\n" ) ; #endif FLAC__ASSERT ( order > 0 ) ; for ( i = 0 ; i < data_len ; i ++ ) { sumo = 0 ; sum = 0 ; history = data ; for ( j = 0 ; j < order ; j ++ ) { sum += qlp_coeff [ j ] * ( * ( -- history ) ) ; sumo += ( FLAC__int64 ) qlp_coeff [ j ] * ( FLAC__int64 ) ( * history ) ; #if defined _MSC_VER if ( sumo > 2147483647I64 || sumo < - 2147483648I64 ) fprintf ( stderr , "FLAC__lpc_compute_residual_from_qlp_coefficients: OVERFLOW, i=%u, j=%u, c=%d, d=%d, sumo=%I64d\n" , i , j , qlp_coeff [ j ] , * history , sumo ) ; #else if ( sumo > 2147483647ll || sumo < - 2147483648ll ) fprintf ( stderr , "FLAC__lpc_compute_residual_from_qlp_coefficients: OVERFLOW, i=%u, j=%u, c=%d, d=%d, sumo=%lld\n" , i , j , qlp_coeff [ j ] , * history , ( long long ) sumo ) ; #endif } * ( residual ++ ) = * ( data ++ ) - ( sum > > lp_quantization ) ; } }
PJ_DEF ( void ) pj_scan_get ( pj_scanner * scanner , const pj_cis_t * spec , pj_str_t * out ) { register char * s = scanner -> curptr ; pj_assert ( pj_cis_match ( spec , 0 ) == 0 ) ; if ( ! pj_cis_match ( spec , * s ) ) { pj_scan_syntax_err ( scanner ) ; return ; } do { ++ s ; } while ( pj_cis_match ( spec , * s ) ) ; pj_strset3 ( out , scanner -> curptr , s ) ; scanner -> curptr = s ; if ( PJ_SCAN_IS_PROBABLY_SPACE ( * s ) && scanner -> skip_ws ) { pj_scan_skip_whitespace ( scanner ) ; } }
extern "C" int register_localized_collators ( sqlite3 * handle __attribute ( ( unused ) ) , const char * systemLocale __attribute ( ( unused ) ) , int utf16Storage __attribute ( ( unused ) ) ) { #ifdef SQLITE_ENABLE_ICU UErrorCode status = U_ZERO_ERROR ; UCollator * collator = ucol_open ( systemLocale , & status ) ; if ( U_FAILURE ( status ) ) { return - 1 ; } ucol_setAttribute ( collator , UCOL_STRENGTH , UCOL_PRIMARY , & status ) ; if ( U_FAILURE ( status ) ) { return - 1 ; } int err ; if ( utf16Storage ) { err = sqlite3_create_collation_v2 ( handle , LOCALIZED_COLLATOR_NAME , SQLITE_UTF16 , collator , collate16 , ( void ( * ) ( void * ) ) localized_collator_dtor ) ; } else { err = sqlite3_create_collation_v2 ( handle , LOCALIZED_COLLATOR_NAME , SQLITE_UTF8 , collator , collate8 , ( void ( * ) ( void * ) ) localized_collator_dtor ) ; } if ( err != SQLITE_OK ) { return err ; } err = sqlite3_create_function ( handle , "_TOKENIZE" , 4 , SQLITE_UTF16 , collator , tokenize , NULL , NULL ) ; if ( err != SQLITE_OK ) { return err ; } err = sqlite3_create_function ( handle , "_TOKENIZE" , 5 , SQLITE_UTF16 , collator , tokenize , NULL , NULL ) ; if ( err != SQLITE_OK ) { return err ; } err = sqlite3_create_function ( handle , "_TOKENIZE" , 6 , SQLITE_UTF16 , collator , tokenize , NULL , NULL ) ; if ( err != SQLITE_OK ) { return err ; } status = U_ZERO_ERROR ; collator = ucol_open ( systemLocale , & status ) ; if ( U_FAILURE ( status ) ) { return - 1 ; } status = U_ZERO_ERROR ; ucol_setAttribute ( collator , UCOL_STRENGTH , UCOL_PRIMARY , & status ) ; if ( U_FAILURE ( status ) ) { return - 1 ; } if ( utf16Storage ) { err = sqlite3_create_collation_v2 ( handle , PHONEBOOK_COLLATOR_NAME , SQLITE_UTF16 , collator , collate16 , ( void ( * ) ( void * ) ) localized_collator_dtor ) ; } else { err = sqlite3_create_collation_v2 ( handle , PHONEBOOK_COLLATOR_NAME , SQLITE_UTF8 , collator , collate8 , ( void ( * ) ( void * ) ) localized_collator_dtor ) ; } if ( err != SQLITE_OK ) { return err ; } #endif //SQLITE_ENABLE_ICU return SQLITE_OK ; }
static void encode_segmentation ( VP9_COMP * cpi , struct vp9_write_bit_buffer * wb ) { int i , j ; struct segmentation * seg = & cpi -> common . seg ; vp9_wb_write_bit ( wb , seg -> enabled ) ; if ( ! seg -> enabled ) return ; vp9_wb_write_bit ( wb , seg -> update_map ) ; if ( seg -> update_map ) { vp9_choose_segmap_coding_method ( cpi ) ; for ( i = 0 ; i < SEG_TREE_PROBS ; i ++ ) { const int prob = seg -> tree_probs [ i ] ; const int update = prob != MAX_PROB ; vp9_wb_write_bit ( wb , update ) ; if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; } vp9_wb_write_bit ( wb , seg -> temporal_update ) ; if ( seg -> temporal_update ) { for ( i = 0 ; i < PREDICTION_PROBS ; i ++ ) { const int prob = seg -> pred_probs [ i ] ; const int update = prob != MAX_PROB ; vp9_wb_write_bit ( wb , update ) ; if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; } } } vp9_wb_write_bit ( wb , seg -> update_data ) ; if ( seg -> update_data ) { vp9_wb_write_bit ( wb , seg -> abs_delta ) ; for ( i = 0 ; i < MAX_SEGMENTS ; i ++ ) { for ( j = 0 ; j < SEG_LVL_MAX ; j ++ ) { const int active = vp9_segfeature_active ( seg , i , j ) ; vp9_wb_write_bit ( wb , active ) ; if ( active ) { const int data = vp9_get_segdata ( seg , i , j ) ; const int data_max = vp9_seg_feature_data_max ( j ) ; if ( vp9_is_segfeature_signed ( j ) ) { encode_unsigned_max ( wb , abs ( data ) , data_max ) ; vp9_wb_write_bit ( wb , data < 0 ) ; } else { encode_unsigned_max ( wb , data , data_max ) ; } } } } } }
int main ( int argc , char * * argv ) { MYSQL mysql ; option_string * eptr ; MY_INIT ( argv [ 0 ] ) ; my_getopt_use_args_separator = TRUE ; if ( load_defaults ( "my" , load_default_groups , & argc , & argv ) ) { my_end ( 0 ) ; exit ( 1 ) ; } my_getopt_use_args_separator = FALSE ; defaults_argv = argv ; if ( get_options ( & argc , & argv ) ) { free_defaults ( defaults_argv ) ; my_end ( 0 ) ; exit ( 1 ) ; } if ( auto_generate_sql ) srandom ( ( uint ) time ( NULL ) ) ; delimiter_length = strlen ( delimiter ) ; if ( argc > 2 ) { fprintf ( stderr , "%s: Too many arguments\n" , my_progname ) ; free_defaults ( defaults_argv ) ; my_end ( 0 ) ; exit ( 1 ) ; } mysql_init ( & mysql ) ; if ( opt_compress ) mysql_options ( & mysql , MYSQL_OPT_COMPRESS , NullS ) ; #ifdef HAVE_OPENSSL if ( opt_use_ssl ) { mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } #endif if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; #if defined (_WIN32) && !defined (EMBEDDED_LIBRARY) if ( shared_memory_base_name ) mysql_options ( & mysql , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; #endif mysql_options ( & mysql , MYSQL_SET_CHARSET_NAME , default_charset ) ; if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql , MYSQL_OPT_CONNECT_ATTR_ADD , "program_name" , "mysqlslap" ) ; if ( using_opt_enable_cleartext_plugin ) mysql_options ( & mysql , MYSQL_ENABLE_CLEARTEXT_PLUGIN , ( char * ) & opt_enable_cleartext_plugin ) ; if ( ! opt_only_print ) { if ( ! ( mysql_real_connect ( & mysql , host , user , opt_password , NULL , opt_mysql_port , opt_mysql_unix_port , connect_flags ) ) ) { fprintf ( stderr , "%s: Error when connecting to server: %s\n" , my_progname , mysql_error ( & mysql ) ) ; free_defaults ( defaults_argv ) ; my_end ( 0 ) ; exit ( 1 ) ; } } pthread_mutex_init ( & counter_mutex , NULL ) ; pthread_cond_init ( & count_threshhold , NULL ) ; pthread_mutex_init ( & sleeper_mutex , NULL ) ; pthread_cond_init ( & sleep_threshhold , NULL ) ; eptr = engine_options ; do { uint * current ; if ( verbose >= 2 ) printf ( "Starting Concurrency Test\n" ) ; if ( * concurrency ) { for ( current = concurrency ; current && * current ; current ++ ) concurrency_loop ( & mysql , * current , eptr ) ; } else { uint infinite = 1 ; do { concurrency_loop ( & mysql , infinite , eptr ) ; } while ( infinite ++ ) ; } if ( ! opt_preserve ) drop_schema ( & mysql , create_schema_string ) ; } while ( eptr ? ( eptr = eptr -> next ) : 0 ) ; pthread_mutex_destroy ( & counter_mutex ) ; pthread_cond_destroy ( & count_threshhold ) ; pthread_mutex_destroy ( & sleeper_mutex ) ; pthread_cond_destroy ( & sleep_threshhold ) ; if ( ! opt_only_print ) mysql_close ( & mysql ) ; my_free ( opt_password ) ; my_free ( concurrency ) ; statement_cleanup ( create_statements ) ; statement_cleanup ( query_statements ) ; statement_cleanup ( pre_statements ) ; statement_cleanup ( post_statements ) ; option_cleanup ( engine_options ) ; #if defined (_WIN32) && !defined (EMBEDDED_LIBRARY) my_free ( shared_memory_base_name ) ; #endif free_defaults ( defaults_argv ) ; my_end ( my_end_arg ) ; return 0 ; }
TPMI_RH_AC_Unmarshal ( TPMI_RH_AC * target , BYTE * * buffer , INT32 * size ) { TPM_RC rc = TPM_RC_SUCCESS ; if ( rc == TPM_RC_SUCCESS ) { rc = TPM_HANDLE_Unmarshal ( target , buffer , size ) ; } if ( rc == TPM_RC_SUCCESS ) { BOOL isNotAC = ( * target < AC_FIRST ) || ( * target > AC_LAST ) ; if ( isNotAC ) { rc = TPM_RC_VALUE ; } } return rc ; }
Node * InterpreterAssembler :: CallRuntimeN ( Node * function_id , Node * context , const RegListNodePair & args , int result_size ) { DCHECK ( Bytecodes :: MakesCallAlongCriticalPath ( bytecode_ ) ) ; DCHECK ( Bytecodes :: IsCallRuntime ( bytecode_ ) ) ; Callable callable = CodeFactory :: InterpreterCEntry ( isolate ( ) , result_size ) ; Node * code_target = HeapConstant ( callable . code ( ) ) ; Node * function_table = ExternalConstant ( ExternalReference :: runtime_function_table_address ( isolate ( ) ) ) ; Node * function_offset = Int32Mul ( function_id , Int32Constant ( sizeof ( Runtime :: Function ) ) ) ; Node * function = IntPtrAdd ( function_table , ChangeUint32ToWord ( function_offset ) ) ; Node * function_entry = Load ( MachineType :: Pointer ( ) , function , IntPtrConstant ( offsetof ( Runtime :: Function , entry ) ) ) ; return CallStubR ( callable . descriptor ( ) , result_size , code_target , context , args . reg_count ( ) , args . base_reg_location ( ) , function_entry ) ; }
const Operator * MachineOperatorBuilder :: Word64AtomicAnd ( MachineType type ) { #define AND(kType)                          \  if (type == MachineType::kType()) {       \  return &cache_.kWord64AtomicAnd##kType; \  } ATOMIC_U64_TYPE_LIST ( AND ) #undef AND UNREACHABLE ( ) ; }
const Operator * SimplifiedOperatorBuilder :: CheckedFloat64ToInt32 ( CheckForMinusZeroMode mode , const VectorSlotPair & feedback ) { if ( ! feedback . IsValid ( ) ) { switch ( mode ) { case CheckForMinusZeroMode :: kCheckForMinusZero : return & cache_ . kCheckedFloat64ToInt32CheckForMinusZeroOperator ; case CheckForMinusZeroMode :: kDontCheckForMinusZero : return & cache_ . kCheckedFloat64ToInt32DontCheckForMinusZeroOperator ; } } return new ( zone ( ) ) Operator1 < CheckMinusZeroParameters > ( IrOpcode :: kCheckedFloat64ToInt32 , Operator :: kFoldable | Operator :: kNoThrow , "CheckedFloat64ToInt32" , 1 , 1 , 1 , 1 , 1 , 0 , CheckMinusZeroParameters ( mode , feedback ) ) ; }
NS_IMPL_CYCLE_COLLECTION_UNLINK ( mCollection ) NS_IMPL_CYCLE_COLLECTION_UNLINK ( mElements ) NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER NS_IMPL_CYCLE_COLLECTION_UNLINK_END NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN ( PropertyNodeList ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE ( mDoc ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE ( mParent ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE ( mCollection ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE ( mElements ) NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN ( PropertyNodeList ) NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER NS_IMPL_CYCLE_COLLECTION_TRACE_END NS_IMPL_CYCLE_COLLECTING_ADDREF ( PropertyNodeList ) NS_IMPL_CYCLE_COLLECTING_RELEASE ( PropertyNodeList ) NS_INTERFACE_TABLE_HEAD ( PropertyNodeList ) NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY NS_INTERFACE_TABLE ( PropertyNodeList , nsIDOMNodeList , nsINodeList , nsIMutationObserver ) NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION ( PropertyNodeList ) NS_INTERFACE_MAP_END void PropertyNodeList :: GetValues ( JSContext * aCx , nsTArray < JS :: Value > & aResult , ErrorResult & aError ) { EnsureFresh ( ) ; JS :: Rooted < JSObject * > wrapper ( aCx , GetWrapper ( ) ) ; JSAutoCompartment ac ( aCx , wrapper ) ; uint32_t length = mElements . Length ( ) ; for ( uint32_t i = 0 ; i < length ; ++ i ) { JS :: Value v = mElements . ElementAt ( i ) -> GetItemValue ( aCx , wrapper , aError ) ; if ( aError . Failed ( ) ) { return ; } aResult . AppendElement ( v ) ; } }
static struct rpmsg_device * rpmsg_virtio_add_ctrl_dev ( struct virtio_device * vdev ) { struct virtproc_info * vrp = vdev -> priv ; struct virtio_rpmsg_channel * vch ; struct rpmsg_device * rpdev_ctrl ; int err = 0 ; vch = kzalloc ( sizeof ( * vch ) , GFP_KERNEL ) ; if ( ! vch ) return ERR_PTR ( - ENOMEM ) ; vch -> vrp = vrp ; rpdev_ctrl = & vch -> rpdev ; rpdev_ctrl -> ops = & virtio_rpmsg_ops ; rpdev_ctrl -> dev . parent = & vrp -> vdev -> dev ; rpdev_ctrl -> dev . release = virtio_rpmsg_release_device ; rpdev_ctrl -> little_endian = virtio_is_little_endian ( vrp -> vdev ) ; err = rpmsg_ctrldev_register_device ( rpdev_ctrl ) ; if ( err ) { kfree ( vch ) ; return ERR_PTR ( err ) ; } return rpdev_ctrl ; }
IndexToValue ( JSContext * cx , jsuint index , jsval * vp ) { if ( index <= JSVAL_INT_MAX ) { * vp = INT_TO_JSVAL ( index ) ; return JS_TRUE ; } return JS_NewDoubleValue ( cx , ( jsdouble ) index , vp ) ; }
int NrSocket :: sendto ( const void * msg , size_t len , int flags , nr_transport_addr * to ) { ASSERT_ON_THREAD ( ststhread_ ) ; int r , _status ; PRNetAddr naddr ; int32_t status ; if ( ( r = nr_transport_addr_to_praddr ( to , & naddr ) ) ) ABORT ( r ) ; if ( fd_ == nullptr ) ABORT ( R_EOD ) ; if ( nr_is_stun_request_message ( ( UCHAR * ) msg , len ) ) { static SimpleTokenBucket burst ( 16384 * 1 , 16384 ) ; static SimpleTokenBucket sustained ( 7372 * 20 , 7372 ) ; if ( burst . getTokens ( UINT32_MAX ) < len ) { r_log ( LOG_GENERIC , LOG_ERR , "Short term global rate limit for STUN requests exceeded." ) ; #ifdef MOZILLA_INTERNAL_API nr_socket_short_term_violation_time = TimeStamp :: Now ( ) ; #endif #if !EARLY_BETA_OR_EARLIER ABORT ( R_WOULDBLOCK ) ; #else MOZ_ASSERT ( false , "Short term global rate limit for STUN requests exceeded. Go " "bug bcampen@mozilla.com if you weren't intentionally " "spamming ICE candidates, or don't know what that means." ) ; #endif } if ( sustained . getTokens ( UINT32_MAX ) < len ) { r_log ( LOG_GENERIC , LOG_ERR , "Long term global rate limit for STUN requests exceeded." ) ; #ifdef MOZILLA_INTERNAL_API nr_socket_long_term_violation_time = TimeStamp :: Now ( ) ; #endif #if !EARLY_BETA_OR_EARLIER ABORT ( R_WOULDBLOCK ) ; #else MOZ_ASSERT ( false , "Long term global rate limit for STUN requests exceeded. Go " "bug bcampen@mozilla.com if you weren't intentionally " "spamming ICE candidates, or don't know what that means." ) ; #endif } burst . getTokens ( len ) ; sustained . getTokens ( len ) ; } status = PR_SendTo ( fd_ , msg , len , flags , & naddr , PR_INTERVAL_NO_WAIT ) ; if ( status < 0 || ( size_t ) status != len ) { if ( PR_GetError ( ) == PR_WOULD_BLOCK_ERROR ) ABORT ( R_WOULDBLOCK ) ; r_log ( LOG_GENERIC , LOG_INFO , "Error in sendto %s: %d" , to -> as_string , PR_GetError ( ) ) ; ABORT ( R_IO_ERROR ) ; } _status = 0 ; abort : return ( _status ) ; }
nsSVGFilterInstance :: BuildPrimitives ( ) { nsTArray < nsRefPtr < nsSVGFE > > primitives ; for ( nsIContent * child = mFilterElement -> nsINode :: GetFirstChild ( ) ; child ; child = child -> GetNextSibling ( ) ) { nsRefPtr < nsSVGFE > primitive ; CallQueryInterface ( child , ( nsSVGFE * * ) getter_AddRefs ( primitive ) ) ; if ( primitive ) { primitives . AppendElement ( primitive ) ; } } nsDataHashtable < nsStringHashKey , int32_t > imageTable ( 10 ) ; for ( uint32_t i = 0 ; i < primitives . Length ( ) ; ++ i ) { nsSVGFE * filter = primitives [ i ] ; nsAutoTArray < int32_t , 2 > sourceIndices ; nsresult rv = GetSourceIndices ( filter , i , imageTable , sourceIndices ) ; if ( NS_FAILED ( rv ) ) { return rv ; } IntRect primitiveSubregion = ComputeFilterPrimitiveSubregion ( filter , sourceIndices ) ; FilterPrimitiveDescription descr = filter -> GetPrimitiveDescription ( this , primitiveSubregion , mInputImages ) ; descr . SetPrimitiveSubregion ( primitiveSubregion ) ; for ( uint32_t j = 0 ; j < sourceIndices . Length ( ) ; j ++ ) { int32_t inputIndex = sourceIndices [ j ] ; descr . SetInputPrimitive ( j , inputIndex ) ; ColorSpace inputColorSpace = inputIndex < 0 ? SRGB : mPrimitiveDescriptions [ inputIndex ] . OutputColorSpace ( ) ; ColorSpace desiredInputColorSpace = filter -> GetInputColorSpace ( j , inputColorSpace ) ; descr . SetInputColorSpace ( j , desiredInputColorSpace ) ; if ( j == 0 ) { descr . SetOutputColorSpace ( desiredInputColorSpace ) ; } } if ( sourceIndices . Length ( ) == 0 ) { descr . SetOutputColorSpace ( filter -> GetOutputColorSpace ( ) ) ; } mPrimitiveDescriptions . AppendElement ( descr ) ; nsAutoString str ; filter -> GetResultImageName ( ) . GetAnimValue ( str , filter ) ; imageTable . Put ( str , i ) ; } return NS_OK ; }
static int check_options ( int argc , char * * argv , char * operation ) { int i = 0 ; int num_found = 0 ; char config_file [ FN_REFLEN ] ; char plugin_name [ FN_REFLEN ] ; const char * basedir_prefix = "--basedir=" ; int basedir_len = strlen ( basedir_prefix ) ; const char * datadir_prefix = "--datadir=" ; int datadir_len = strlen ( datadir_prefix ) ; const char * plugin_dir_prefix = "--plugin_dir=" ; int plugin_dir_len = strlen ( plugin_dir_prefix ) ; strcpy ( plugin_name , "" ) ; for ( i = 0 ; i < argc && num_found < 5 ; i ++ ) { if ( ! argv [ i ] ) { continue ; } if ( ( strcasecmp ( argv [ i ] , "ENABLE" ) == 0 ) || ( strcasecmp ( argv [ i ] , "DISABLE" ) == 0 ) ) { strcpy ( operation , argv [ i ] ) ; num_found ++ ; } else if ( ( strncasecmp ( argv [ i ] , basedir_prefix , basedir_len ) == 0 ) && ! opt_basedir ) { opt_basedir = my_strndup ( argv [ i ] + basedir_len , strlen ( argv [ i ] ) - basedir_len , MYF ( MY_FAE ) ) ; num_found ++ ; } else if ( ( strncasecmp ( argv [ i ] , datadir_prefix , datadir_len ) == 0 ) && ! opt_datadir ) { opt_datadir = my_strndup ( argv [ i ] + datadir_len , strlen ( argv [ i ] ) - datadir_len , MYF ( MY_FAE ) ) ; num_found ++ ; } else if ( ( strncasecmp ( argv [ i ] , plugin_dir_prefix , plugin_dir_len ) == 0 ) && ! opt_plugin_dir ) { opt_plugin_dir = my_strndup ( argv [ i ] + plugin_dir_len , strlen ( argv [ i ] ) - plugin_dir_len , MYF ( MY_FAE ) ) ; num_found ++ ; } else { strcpy ( plugin_name , argv [ i ] ) ; strcpy ( config_file , argv [ i ] ) ; strcat ( config_file , ".ini" ) ; } } if ( ! opt_basedir ) { fprintf ( stderr , "ERROR: Missing --basedir option.\n" ) ; return 1 ; } if ( ! opt_datadir ) { fprintf ( stderr , "ERROR: Missing --datadir option.\n" ) ; return 1 ; } if ( ! opt_plugin_dir ) { fprintf ( stderr , "ERROR: Missing --plugin_dir option.\n" ) ; return 1 ; } else if ( strlen ( plugin_name ) > 0 ) { if ( load_plugin_data ( plugin_name , config_file ) ) { return 1 ; } if ( strcasecmp ( plugin_data . name , plugin_name ) != 0 ) { fprintf ( stderr , "ERROR: plugin name requested does not match config " "file data.\n" ) ; return 1 ; } } else { fprintf ( stderr , "ERROR: No plugin specified.\n" ) ; return 1 ; } if ( ( strlen ( operation ) == 0 ) ) { fprintf ( stderr , "ERROR: missing operation. Please specify either " "'<plugin> ENABLE' or '<plugin> DISABLE'.\n" ) ; return 1 ; } return 0 ; }
Reduction TypedOptimization :: ReduceNumberToUint8Clamped ( Node * node ) { Node * const input = NodeProperties :: GetValueInput ( node , 0 ) ; Type const input_type = NodeProperties :: GetType ( input ) ; if ( input_type . Is ( type_cache_ . kUint8 ) ) { return Replace ( input ) ; } return NoChange ( ) ; }
static bool write_hci_command ( hci_packet_t type , const void * packet , size_t length ) { int sock = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ) ; if ( sock == INVALID_FD ) goto error ; struct sockaddr_in addr ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = htonl ( 0x7F000001 ) ; addr . sin_port = htons ( 8873 ) ; if ( connect ( sock , ( const struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) goto error ; if ( send ( sock , & type , 1 , 0 ) != 1 ) goto error ; if ( send ( sock , & length , 2 , 0 ) != 2 ) goto error ; if ( send ( sock , packet , length , 0 ) != ( ssize_t ) length ) goto error ; close ( sock ) ; return true ; error : ; close ( sock ) ; return false ; }
zlib_advance ( struct zlib * zlib , png_uint_32 nbytes ) #  define ZLIB_TOO_FAR_BACK (-1) #  define ZLIB_OK           0 #  define ZLIB_STREAM_END   1 #  define ZLIB_FATAL        2 { int state = zlib -> state ; int endrc = ZLIB_OK ; png_uint_32 in_bytes = 0 ; struct file * file = zlib -> file ; assert ( state >= 0 ) ; while ( in_bytes < nbytes && endrc == ZLIB_OK ) { png_uint_32 out_bytes ; int flush ; png_byte bIn = reread_byte ( file ) ; png_byte bOut ; switch ( state ) { case 0 : { int file_bits = 8 + ( bIn > > 4 ) ; int new_bits = zlib -> window_bits ; zlib -> file_bits = file_bits ; if ( new_bits == 0 ) zlib -> window_bits = file_bits ; else if ( new_bits != file_bits ) bIn = ( png_byte ) ( ( bIn & 0xf ) + ( ( new_bits - 8 ) < < 4 ) ) ; } zlib -> header [ 0 ] = bIn ; zlib -> state = state = 1 ; break ; case 1 : { int b2 = bIn & 0xe0 ; b2 += 0x1f - ( ( zlib -> header [ 0 ] < < 8 ) + b2 ) % 0x1f ; if ( bIn != b2 ) { if ( zlib -> file_bits == zlib -> window_bits ) zlib -> cksum = 1 ; bIn = ( png_byte ) b2 ; } } zlib -> header [ 1 ] = bIn ; zlib -> state = state = 2 ; break ; default : break ; } zlib -> z . next_in = & bIn ; zlib -> z . avail_in = 1 ; zlib -> z . next_out = & bOut ; zlib -> z . avail_out = 0 ; flush = Z_NO_FLUSH ; out_bytes = 0 ; for ( ; endrc == ZLIB_OK ; flush = Z_SYNC_FLUSH , zlib -> z . next_out = & bOut , zlib -> z . avail_out = 1 , ++ out_bytes ) { zlib -> rc = inflate ( & zlib -> z , flush ) ; out_bytes -= zlib -> z . avail_out ; switch ( zlib -> rc ) { case Z_BUF_ERROR : if ( zlib -> z . avail_out == 0 ) continue ; if ( zlib -> z . avail_in == 0 ) break ; zlib_message ( zlib , 1 ) ; endrc = ZLIB_FATAL ; break ; case Z_OK : assert ( zlib -> z . avail_out == 0 || zlib -> z . avail_in == 0 ) ; continue ; case Z_STREAM_END : zlib -> state = 3 ; endrc = ZLIB_STREAM_END ; break ; case Z_NEED_DICT : zlib_message ( zlib , 0 ) ; endrc = ZLIB_FATAL ; break ; case Z_DATA_ERROR : if ( zlib -> z . msg != NULL && strcmp ( zlib -> z . msg , "invalid distance too far back" ) == 0 ) { endrc = ZLIB_TOO_FAR_BACK ; break ; } default : zlib_message ( zlib , 0 ) ; endrc = ZLIB_FATAL ; break ; } break ; } zlib -> uncompressed_digits = uarb_add32 ( zlib -> uncompressed_bytes , zlib -> uncompressed_digits , out_bytes ) ; assert ( zlib -> z . avail_in == 0 || endrc != ZLIB_OK ) ; in_bytes += 1 - zlib -> z . avail_in ; } assert ( in_bytes == nbytes || endrc != ZLIB_OK ) ; zlib -> compressed_digits = uarb_add32 ( zlib -> compressed_bytes , zlib -> compressed_digits , in_bytes - zlib -> z . avail_in ) ; if ( endrc == ZLIB_STREAM_END && zlib -> window_bits < zlib -> ok_bits ) { struct chunk * chunk = zlib -> chunk ; chunk -> uncompressed_digits = uarb_copy ( chunk -> uncompressed_bytes , zlib -> uncompressed_bytes , zlib -> uncompressed_digits ) ; chunk -> compressed_digits = uarb_copy ( chunk -> compressed_bytes , zlib -> compressed_bytes , zlib -> compressed_digits ) ; chunk -> rewrite_buffer [ 0 ] = zlib -> header [ 0 ] ; chunk -> rewrite_buffer [ 1 ] = zlib -> header [ 1 ] ; if ( zlib -> window_bits != zlib -> file_bits || zlib -> cksum ) { chunk -> rewrite_offset = zlib -> rewrite_offset ; chunk -> rewrite_length = 2 ; } else { chunk -> rewrite_offset = 0 ; chunk -> rewrite_length = 0 ; } if ( in_bytes < nbytes ) chunk_message ( chunk , "extra compressed data" ) ; zlib -> extra_bytes = nbytes - in_bytes ; zlib -> ok_bits = zlib -> window_bits ; } return endrc ; }
static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; if ( ret < 0 ) { mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; ops -> destroy ( dev ) ; return ret ; } kvm_get_kvm ( kvm ) ; cd -> fd = ret ; return 0 ; }
void AsyncStreamingProcessor :: FinishAsyncCompileJobWithError ( ResultBase error ) { job_ -> background_task_manager_ . CancelAndWait ( ) ; ModuleResult result ( nullptr ) ; result . MoveErrorFrom ( error ) ; if ( job_ -> native_module_ ) { job_ -> native_module_ -> compilation_state ( ) -> Abort ( ) ; if ( job_ -> pending_foreground_task_ == nullptr ) { job_ -> DoSync < AsyncCompileJob :: DecodeFail > ( std :: move ( result ) ) ; } else { job_ -> NextStep < AsyncCompileJob :: DecodeFail > ( std :: move ( result ) ) ; } if ( compilation_unit_builder_ ) compilation_unit_builder_ -> Clear ( ) ; } else { job_ -> DoSync < AsyncCompileJob :: DecodeFail > ( std :: move ( result ) ) ; } }
int32_t WasmMemoryObject :: Grow ( Isolate * isolate , Handle < WasmMemoryObject > memory_object , uint32_t pages ) { Handle < JSArrayBuffer > old_buffer ( memory_object -> array_buffer ( ) , isolate ) ; if ( ! old_buffer -> is_growable ( ) ) return - 1 ; uint32_t old_size = 0 ; CHECK ( old_buffer -> byte_length ( ) -> ToUint32 ( & old_size ) ) ; DCHECK_EQ ( 0 , old_size % wasm :: kWasmPageSize ) ; Handle < JSArrayBuffer > new_buffer ; uint32_t maximum_pages = FLAG_wasm_max_mem_pages ; if ( memory_object -> has_maximum_pages ( ) ) { maximum_pages = Min ( FLAG_wasm_max_mem_pages , static_cast < uint32_t > ( memory_object -> maximum_pages ( ) ) ) ; } if ( ! GrowMemoryBuffer ( isolate , old_buffer , pages , maximum_pages ) . ToHandle ( & new_buffer ) ) { return - 1 ; } if ( memory_object -> has_instances ( ) ) { Handle < WeakArrayList > instances ( memory_object -> instances ( ) , isolate ) ; for ( int i = 0 ; i < instances -> length ( ) ; i ++ ) { MaybeObject * elem = instances -> Get ( i ) ; HeapObject * heap_object ; if ( elem -> ToWeakHeapObject ( & heap_object ) ) { Handle < WasmInstanceObject > instance ( WasmInstanceObject :: cast ( heap_object ) , isolate ) ; SetInstanceMemory ( instance , new_buffer ) ; } else { DCHECK ( elem -> IsClearedWeakHeapObject ( ) ) ; } } } memory_object -> set_array_buffer ( * new_buffer ) ; return old_size / wasm :: kWasmPageSize ; }
nsHtml5TreeOpExecutor :: MarkAsBroken ( ) { NS_ASSERTION ( NS_IsMainThread ( ) , "Wrong thread!" ) ; NS_ASSERTION ( ! mRunsToCompletion , "Fragment parsers can't be broken!" ) ; mBroken = true ; if ( mStreamParser ) { mStreamParser -> Terminate ( ) ; } if ( mParser ) { nsCOMPtr < nsIRunnable > terminator = NS_NewRunnableMethod ( GetParser ( ) , & nsHtml5Parser :: Terminate ) ; if ( NS_FAILED ( NS_DispatchToMainThread ( terminator ) ) ) { NS_WARNING ( "failed to dispatch executor flush event" ) ; } } }
static int mxf_read_primer_pack ( void * arg , AVIOContext * pb , int tag , int size , UID uid , int64_t klv_offset ) { MXFContext * mxf = arg ; int item_num = avio_rb32 ( pb ) ; int item_len = avio_rb32 ( pb ) ; if ( item_len != 18 ) { avpriv_request_sample ( pb , "Primer pack item length %d" , item_len ) ; return AVERROR_PATCHWELCOME ; } if ( item_num > 65536 ) { av_log ( mxf -> fc , AV_LOG_ERROR , "item_num %d is too large\n" , item_num ) ; return AVERROR_INVALIDDATA ; } if ( mxf -> local_tags ) av_log ( mxf -> fc , AV_LOG_VERBOSE , "Multiple primer packs\n" ) ; av_free ( mxf -> local_tags ) ; mxf -> local_tags_count = 0 ; mxf -> local_tags = av_calloc ( item_num , item_len ) ; if ( ! mxf -> local_tags ) return AVERROR ( ENOMEM ) ; mxf -> local_tags_count = item_num ; avio_read ( pb , mxf -> local_tags , item_num * item_len ) ; return 0 ; }
void HeapProfiler :: QueryObjects ( Handle < Context > context , debug :: QueryObjectPredicate * predicate , PersistentValueVector < v8 :: Object > * objects ) { heap ( ) -> CollectAllAvailableGarbage ( GarbageCollectionReason :: kLowMemoryNotification ) ; heap ( ) -> CollectAllGarbage ( Heap :: kMakeHeapIterableMask , GarbageCollectionReason :: kHeapProfiler ) ; HeapIterator heap_iterator ( heap ( ) ) ; HeapObject * heap_obj ; while ( ( heap_obj = heap_iterator . next ( ) ) != nullptr ) { if ( ! heap_obj -> IsJSObject ( ) || heap_obj -> IsExternal ( isolate ( ) ) ) continue ; v8 :: Local < v8 :: Object > v8_obj ( Utils :: ToLocal ( handle ( JSObject :: cast ( heap_obj ) , isolate ( ) ) ) ) ; if ( ! predicate -> Filter ( v8_obj ) ) continue ; objects -> Append ( v8_obj ) ; } }
PatchIfFile :: Parse ( NS_tchar * line ) { mTestFile = get_valid_path ( & line ) ; if ( ! mTestFile ) return PARSE_ERROR ; NS_tchar * q = mstrtok ( kQuote , & line ) ; if ( ! q ) return PARSE_ERROR ; return PatchFile :: Parse ( line ) ; }
ast_for_with_stmt ( struct compiling * c , const node * n , int is_async ) { int i , n_items , nch_minus_type , has_type_comment ; asdl_seq * items , * body ; string type_comment ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , "Async with statements are only supported in Python 3.5 and greater" ) ; return NULL ; } REQ ( n , with_stmt ) ; has_type_comment = TYPE ( CHILD ( n , NCH ( n ) - 2 ) ) == TYPE_COMMENT ; nch_minus_type = NCH ( n ) - has_type_comment ; n_items = ( nch_minus_type - 2 ) / 2 ; items = _Ta3_asdl_seq_new ( n_items , c -> c_arena ) ; if ( ! items ) return NULL ; for ( i = 1 ; i < nch_minus_type - 2 ; i += 2 ) { withitem_ty item = ast_for_with_item ( c , CHILD ( n , i ) ) ; if ( ! item ) return NULL ; asdl_seq_SET ( items , ( i - 1 ) / 2 , item ) ; } body = ast_for_suite ( c , CHILD ( n , NCH ( n ) - 1 ) ) ; if ( ! body ) return NULL ; if ( has_type_comment ) type_comment = NEW_TYPE_COMMENT ( CHILD ( n , NCH ( n ) - 2 ) ) ; else type_comment = NULL ; if ( is_async ) return AsyncWith ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return With ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
xmlValidateDtdFinal ( xmlValidCtxtPtr ctxt , xmlDocPtr doc ) { xmlDtdPtr dtd ; xmlAttributeTablePtr table ; xmlEntitiesTablePtr entities ; if ( ( doc == NULL ) || ( ctxt == NULL ) ) return ( 0 ) ; if ( ( doc -> intSubset == NULL ) && ( doc -> extSubset == NULL ) ) return ( 0 ) ; ctxt -> doc = doc ; ctxt -> valid = 1 ; dtd = doc -> intSubset ; if ( ( dtd != NULL ) && ( dtd -> attributes != NULL ) ) { table = ( xmlAttributeTablePtr ) dtd -> attributes ; xmlHashScan ( table , ( xmlHashScanner ) xmlValidateAttributeCallback , ctxt ) ; } if ( ( dtd != NULL ) && ( dtd -> entities != NULL ) ) { entities = ( xmlEntitiesTablePtr ) dtd -> entities ; xmlHashScan ( entities , ( xmlHashScanner ) xmlValidateNotationCallback , ctxt ) ; } dtd = doc -> extSubset ; if ( ( dtd != NULL ) && ( dtd -> attributes != NULL ) ) { table = ( xmlAttributeTablePtr ) dtd -> attributes ; xmlHashScan ( table , ( xmlHashScanner ) xmlValidateAttributeCallback , ctxt ) ; } if ( ( dtd != NULL ) && ( dtd -> entities != NULL ) ) { entities = ( xmlEntitiesTablePtr ) dtd -> entities ; xmlHashScan ( entities , ( xmlHashScanner ) xmlValidateNotationCallback , ctxt ) ; } return ( ctxt -> valid ) ; }
void V8HeapExplorer :: ExtractPropertyReferences ( JSObject * js_obj , int entry ) { Isolate * isolate = js_obj -> GetIsolate ( ) ; if ( js_obj -> HasFastProperties ( ) ) { DescriptorArray * descs = js_obj -> map ( ) -> instance_descriptors ( ) ; int real_size = js_obj -> map ( ) -> NumberOfOwnDescriptors ( ) ; for ( int i = 0 ; i < real_size ; i ++ ) { PropertyDetails details = descs -> GetDetails ( i ) ; switch ( details . location ( ) ) { case kField : { Representation r = details . representation ( ) ; if ( r . IsSmi ( ) || r . IsDouble ( ) ) break ; Name * k = descs -> GetKey ( i ) ; FieldIndex field_index = FieldIndex :: ForDescriptor ( js_obj -> map ( ) , i ) ; Object * value = js_obj -> RawFastPropertyAt ( field_index ) ; int field_offset = field_index . is_inobject ( ) ? field_index . offset ( ) : - 1 ; SetDataOrAccessorPropertyReference ( details . kind ( ) , js_obj , entry , k , value , nullptr , field_offset ) ; break ; } case kDescriptor : SetDataOrAccessorPropertyReference ( details . kind ( ) , js_obj , entry , descs -> GetKey ( i ) , descs -> GetStrongValue ( i ) ) ; break ; } } } else if ( js_obj -> IsJSGlobalObject ( ) ) { GlobalDictionary * dictionary = JSGlobalObject :: cast ( js_obj ) -> global_dictionary ( ) ; int length = dictionary -> Capacity ( ) ; ReadOnlyRoots roots ( isolate ) ; for ( int i = 0 ; i < length ; ++ i ) { if ( dictionary -> IsKey ( roots , dictionary -> KeyAt ( i ) ) ) { PropertyCell * cell = dictionary -> CellAt ( i ) ; Name * name = cell -> name ( ) ; Object * value = cell -> value ( ) ; PropertyDetails details = cell -> property_details ( ) ; SetDataOrAccessorPropertyReference ( details . kind ( ) , js_obj , entry , name , value ) ; } } } else { NameDictionary * dictionary = js_obj -> property_dictionary ( ) ; int length = dictionary -> Capacity ( ) ; ReadOnlyRoots roots ( isolate ) ; for ( int i = 0 ; i < length ; ++ i ) { Object * k = dictionary -> KeyAt ( i ) ; if ( dictionary -> IsKey ( roots , k ) ) { Object * value = dictionary -> ValueAt ( i ) ; PropertyDetails details = dictionary -> DetailsAt ( i ) ; SetDataOrAccessorPropertyReference ( details . kind ( ) , js_obj , entry , Name :: cast ( k ) , value ) ; } } } }
int vpx_img_read ( vpx_image_t * img , FILE * file ) { int plane ; for ( plane = 0 ; plane < 3 ; ++ plane ) { unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; const int w = vpx_img_plane_width ( img , plane ) ; const int h = vpx_img_plane_height ( img , plane ) ; int y ; for ( y = 0 ; y < h ; ++ y ) { if ( fread ( buf , 1 , w , file ) != w ) return 0 ; buf += stride ; } } return 1 ; }
void F64Const ( FullDecoder * decoder , Value * result , double value ) { LiftoffRegister reg = __ GetUnusedRegister ( kFpReg ) ; __ LoadConstant ( reg , WasmValue ( value ) ) ; __ PushRegister ( kWasmF64 , reg ) ; }
void Run ( BasicBlock * block , Node * exit ) { ResetDataStructures ( ) ; Queue ( exit ) ; component_entry_ = nullptr ; component_start_ = block ; component_end_ = schedule_ -> block ( exit ) ; scheduler_ -> equivalence_ -> Run ( exit ) ; while ( ! queue_ . empty ( ) ) { Node * node = queue_ . front ( ) ; queue_ . pop ( ) ; if ( IsSingleEntrySingleExitRegion ( node , exit ) ) { TRACE ( "Found SESE at #%d:%s\n" , node -> id ( ) , node -> op ( ) -> mnemonic ( ) ) ; DCHECK ( ! component_entry_ ) ; component_entry_ = node ; continue ; } int max = NodeProperties :: PastControlIndex ( node ) ; for ( int i = NodeProperties :: FirstControlIndex ( node ) ; i < max ; i ++ ) { Queue ( node -> InputAt ( i ) ) ; } } DCHECK ( component_entry_ ) ; for ( NodeVector :: iterator i = control_ . begin ( ) ; i != control_ . end ( ) ; ++ i ) { ConnectBlocks ( * i ) ; } }
void S32_D565_Opaque_Dither_neon ( uint16_t * SK_RESTRICT dst , const SkPMColor * SK_RESTRICT src , int count , U8CPU alpha , int x , int y ) { SkASSERT ( 255 == alpha ) ; #define    UNROLL    8 if ( count >= UNROLL ) { uint8x8_t d ; const uint8_t * dstart = & gDitherMatrix_Neon [ ( y & 3 ) * 12 + ( x & 3 ) ] ; d = vld1_u8 ( dstart ) ; while ( count >= UNROLL ) { uint8x8_t sr , sg , sb ; uint16x8_t dr , dg , db ; uint16x8_t dst8 ; uint8x8x4_t vsrc ; #ifdef SK_CPU_ARM64 vsrc = sk_vld4_u8_arm64_3 ( src ) ; #else { register uint8x8_t d0 asm ( "d0" ) ; register uint8x8_t d1 asm ( "d1" ) ; register uint8x8_t d2 asm ( "d2" ) ; register uint8x8_t d3 asm ( "d3" ) ; asm ( "vld4.8    {d0-d3},[%[src]]! " : "=w" ( d0 ) , "=w" ( d1 ) , "=w" ( d2 ) , "=w" ( d3 ) , [ src ] "+&r" ( src ) : ) ; vsrc . val [ 0 ] = d0 ; vsrc . val [ 1 ] = d1 ; vsrc . val [ 2 ] = d2 ; } #endif sr = vsrc . val [ NEON_R ] ; sg = vsrc . val [ NEON_G ] ; sb = vsrc . val [ NEON_B ] ; sr = vsub_u8 ( sr , vshr_n_u8 ( sr , 5 ) ) ; dr = vaddl_u8 ( sr , d ) ; sb = vsub_u8 ( sb , vshr_n_u8 ( sb , 5 ) ) ; db = vaddl_u8 ( sb , d ) ; sg = vsub_u8 ( sg , vshr_n_u8 ( sg , 6 ) ) ; dg = vaddl_u8 ( sg , vshr_n_u8 ( d , 1 ) ) ; dst8 = vshrq_n_u16 ( db , 3 ) ; dst8 = vsliq_n_u16 ( dst8 , vshrq_n_u16 ( dg , 2 ) , 5 ) ; dst8 = vsliq_n_u16 ( dst8 , vshrq_n_u16 ( dr , 3 ) , 11 ) ; vst1q_u16 ( dst , dst8 ) ; #if    defined(DEBUG_S32_OPAQUE_DITHER) { int i , myx = x , myy = y ; DITHER_565_SCAN ( myy ) ; for ( i = 0 ; i < UNROLL ; i ++ ) { SkPMColor c = src [ i - 8 ] ; unsigned dither = DITHER_VALUE ( myx ) ; uint16_t val = SkDitherRGB32To565 ( c , dither ) ; if ( val != dst [ i ] ) { SkDebugf ( "RBE: src %08x dither %02x, want %04x got %04x dbas[i] %02x\n" , c , dither , val , dst [ i ] , dstart [ i ] ) ; } DITHER_INC_X ( myx ) ; } } #endif dst += UNROLL ; count -= UNROLL ; x += UNROLL ; } } #undef    UNROLL if ( count > 0 ) { DITHER_565_SCAN ( y ) ; do { SkPMColor c = * src ++ ; SkPMColorAssert ( c ) ; SkASSERT ( SkGetPackedA32 ( c ) == 255 ) ; unsigned dither = DITHER_VALUE ( x ) ; * dst ++ = SkDitherRGB32To565 ( c , dither ) ; DITHER_INC_X ( x ) ; } while ( -- count != 0 ) ; } }
uc32 NextCodePoint ( Isolate * isolate , BuiltinArguments args , int index ) { Handle < Object > value = args . at ( 1 + index ) ; ASSIGN_RETURN_ON_EXCEPTION_VALUE ( isolate , value , Object :: ToNumber ( isolate , value ) , - 1 ) ; if ( ! IsValidCodePoint ( isolate , value ) ) { isolate -> Throw ( * isolate -> factory ( ) -> NewRangeError ( MessageTemplate :: kInvalidCodePoint , value ) ) ; return - 1 ; } return DoubleToUint32 ( value -> Number ( ) ) ; }
EventListenerManager :: DispatchEvent ( JSContext * aCx , const EventTarget & aTarget , JSObject * aEvent , ErrorResult & aRv ) const { using namespace mozilla :: dom :: workers :: events ; if ( ! IsSupportedEventClass ( aEvent ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } jsval val ; if ( ! JS_GetProperty ( aCx , aEvent , "target" , & val ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } if ( ! JSVAL_IS_NULL ( val ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } if ( PR_CLIST_IS_EMPTY ( & mCollectionHead ) ) { return false ; } JSString * eventType ; JSBool eventIsTrusted ; if ( ! JS_GetProperty ( aCx , aEvent , "type" , & val ) || ! ( eventType = JS_ValueToString ( aCx , val ) ) || ! ( eventType = JS_InternJSString ( aCx , eventType ) ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } if ( ! JS_GetProperty ( aCx , aEvent , "isTrusted" , & val ) || ! JS_ValueToBoolean ( aCx , val , & eventIsTrusted ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } ListenerCollection * collection = GetCollectionForType ( & mCollectionHead , INTERNED_STRING_TO_JSID ( aCx , eventType ) ) ; if ( ! collection ) { return false ; } ContextAllocPolicy ap ( aCx ) ; js :: Vector < JSObject * , 10 , ContextAllocPolicy > listeners ( ap ) ; for ( PRCList * elem = PR_NEXT_LINK ( & collection -> mListenerHead ) ; elem != & collection -> mListenerHead ; elem = PR_NEXT_LINK ( elem ) ) { ListenerData * listenerData = static_cast < ListenerData * > ( elem ) ; if ( ( eventIsTrusted || listenerData -> mWantsUntrusted ) && ! listeners . append ( listenerData -> mListener ) ) { aRv . Throw ( NS_ERROR_OUT_OF_MEMORY ) ; return false ; } } if ( listeners . empty ( ) ) { return false ; } SetEventTarget ( aEvent , aTarget . GetJSObject ( ) ) ; for ( size_t index = 0 ; index < listeners . length ( ) ; index ++ ) { if ( EventImmediatePropagationStopped ( aEvent ) ) { break ; } jsval listenerVal = OBJECT_TO_JSVAL ( listeners [ index ] ) ; JSObject * listenerObj ; if ( ! JS_ValueToObject ( aCx , listenerVal , & listenerObj ) ) { if ( ! JS_ReportPendingException ( aCx ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } continue ; } static const char sHandleEventChars [ ] = "handleEvent" ; JSObject * thisObj = aTarget . GetJSObject ( ) ; JSBool hasHandleEvent ; if ( ! JS_HasProperty ( aCx , listenerObj , sHandleEventChars , & hasHandleEvent ) ) { if ( ! JS_ReportPendingException ( aCx ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } continue ; } if ( hasHandleEvent ) { if ( ! JS_GetProperty ( aCx , listenerObj , sHandleEventChars , & listenerVal ) ) { if ( ! JS_ReportPendingException ( aCx ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } continue ; } thisObj = listenerObj ; } jsval argv [ ] = { OBJECT_TO_JSVAL ( aEvent ) } ; jsval rval = JSVAL_VOID ; if ( ! JS_CallFunctionValue ( aCx , thisObj , listenerVal , ArrayLength ( argv ) , argv , & rval ) ) { if ( ! JS_ReportPendingException ( aCx ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } continue ; } } return EventWasCanceled ( aEvent ) ; }
int nestlex ( const char * * addr , char * * token , size_t * len , const char * ends [ ] , const char * hquotes [ ] , const char * squotes [ ] , const char * nests [ ] , bool dropquotes , bool c_esc , bool html_esc ) { const char * in = * addr ; const char * * endx ; const char * * quotx ; const char * * nestx ; char * out = * token ; char c ; int i ; int result ; while ( true ) { if ( * in == 0 ) { break ; } endx = ends ; i = 0 ; while ( * endx ) { if ( ! strncmp ( in , * endx , strlen ( * endx ) ) ) { * addr = in ; * token = out ; return 0 ; } ++ endx ; } quotx = hquotes ; while ( hquotes && * quotx ) { if ( ! strncmp ( in , * quotx , strlen ( * quotx ) ) ) { const char * endnest [ 2 ] ; if ( dropquotes ) { in += strlen ( * quotx ) ; } else { for ( i = strlen ( * quotx ) ; i > 0 ; -- i ) { * out ++ = * in ++ ; if ( -- * len <= 0 ) { * addr = in ; * token = out ; return - 1 ; } } } endnest [ 0 ] = * quotx ; endnest [ 1 ] = NULL ; result = nestlex ( & in , & out , len , endnest , NULL , NULL , NULL , false , c_esc , html_esc ) ; if ( result == 0 && dropquotes ) { in += strlen ( * quotx ) ; } else { for ( i = strlen ( * quotx ) ; i > 0 ; -- i ) { * out ++ = * in ++ ; if ( -- * len <= 0 ) { * addr = in ; * token = out ; return - 1 ; } } } break ; } ++ quotx ; } if ( hquotes && * quotx != NULL ) { continue ; } quotx = squotes ; while ( squotes && * quotx ) { if ( ! strncmp ( in , * quotx , strlen ( * quotx ) ) ) { const char * endnest [ 2 ] ; if ( dropquotes ) { in += strlen ( * quotx ) ; } else { for ( i = strlen ( * quotx ) ; i > 0 ; -- i ) { * out ++ = * in ++ ; if ( -- * len <= 0 ) { * addr = in ; * token = out ; return - 1 ; } } } endnest [ 0 ] = * quotx ; endnest [ 1 ] = NULL ; result = nestlex ( & in , & out , len , endnest , hquotes , squotes , nests , false , c_esc , html_esc ) ; if ( result == 0 && dropquotes ) { in += strlen ( * quotx ) ; } else { for ( i = strlen ( * quotx ) ; i > 0 ; -- i ) { * out ++ = * in ++ ; if ( -- * len <= 0 ) { * addr = in ; * token = out ; return - 1 ; } } } break ; } ++ quotx ; } if ( squotes && * quotx != NULL ) { continue ; } nestx = nests ; i = 0 ; while ( nests && * nestx ) { if ( ! strncmp ( in , * nestx , strlen ( * nestx ) ) ) { const char * endnest [ 2 ] ; endnest [ 0 ] = nestx [ 1 ] ; endnest [ 1 ] = NULL ; for ( i = strlen ( nestx [ 1 ] ) ; i > 0 ; -- i ) { * out ++ = * in ++ ; if ( -- * len <= 0 ) { * addr = in ; * token = out ; return - 1 ; } } result = nestlex ( & in , & out , len , endnest , hquotes , squotes , nests , false , c_esc , html_esc ) ; if ( result == 0 ) { i = strlen ( nestx [ 1 ] ) ; while ( i > 0 ) { * out ++ = * in ++ ; if ( -- * len <= 0 ) { * addr = in ; * token = out ; return - 1 ; } -- i ; } } break ; } nestx += 2 ; } if ( nests && * nestx ) { continue ; } c = * in ++ ; if ( c == '\\' ) { c = * in ++ ; if ( c == 0 ) { break ; } if ( c_esc ) { switch ( c ) { case '0' : c = '\0' ; break ; case 'a' : c = '\a' ; break ; case 'b' : c = '\b' ; break ; case 'f' : c = '\f' ; break ; case 'n' : c = '\n' ; break ; case 'r' : c = '\r' ; break ; case 't' : c = '\t' ; break ; case 'v' : c = '\v' ; break ; #if LATER case 'x' : ! ! ! 1 to 2 hex digits ; break ; case 'u' : ! ! ! 4 hex digits ? ; break ; case 'U' : ! ! ! 8 hex digits ? ; break ; #endif default : break ; } } * out ++ = c ; -- * len ; if ( len == 0 ) { * addr = in ; * token = out ; return - 1 ; } continue ; } * out ++ = c ; -- * len ; if ( len == 0 ) { * addr = in ; * token = out ; return - 1 ; } } * addr = in ; * token = out ; return 0 ; }
static bool has_byte ( const eager_reader_t * reader ) { assert ( reader != NULL ) ; fd_set read_fds ; FD_ZERO ( & read_fds ) ; FD_SET ( reader -> bytes_available_fd , & read_fds ) ; struct timeval timeout ; timeout . tv_sec = 0 ; timeout . tv_usec = 0 ; select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ; return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ; }
void GCIdleTimeHeapState :: Print ( ) { PrintF ( "contexts_disposed=%d " , contexts_disposed ) ; PrintF ( "contexts_disposal_rate=%f " , contexts_disposal_rate ) ; PrintF ( "size_of_objects=%" PRIuS " " , size_of_objects ) ; PrintF ( "incremental_marking_stopped=%d " , incremental_marking_stopped ) ; }
validate_as_request ( kdc_realm_t * kdc_active_realm , register krb5_kdc_req * request , krb5_db_entry client , krb5_db_entry server , krb5_timestamp kdc_time , const char * * status , krb5_pa_data * * * e_data ) { int errcode ; krb5_error_code ret ; if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = "INVALID AS OPTIONS" ; return KDC_ERR_BADOPTION ; } if ( client . expiration && client . expiration < kdc_time ) { * status = "CLIENT EXPIRED" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_NAME_EXP ) ; } if ( client . pw_expiration && client . pw_expiration < kdc_time && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = "CLIENT KEY EXPIRED" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_KEY_EXP ) ; } if ( server . expiration && server . expiration < kdc_time ) { * status = "SERVICE EXPIRED" ; return ( KDC_ERR_SERVICE_EXP ) ; } if ( isflagset ( client . attributes , KRB5_KDB_REQUIRES_PWCHANGE ) && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = "REQUIRED PWCHANGE" ; return ( KDC_ERR_KEY_EXP ) ; } if ( ( isflagset ( request -> kdc_options , KDC_OPT_ALLOW_POSTDATE ) || isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_POSTDATED ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_POSTDATED ) ) ) { * status = "POSTDATE NOT ALLOWED" ; return ( KDC_ERR_CANNOT_POSTDATE ) ; } if ( isflagset ( request -> kdc_options , KDC_OPT_PROXIABLE ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) ) ) { * status = "PROXIABLE NOT ALLOWED" ; return ( KDC_ERR_POLICY ) ; } if ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = "CLIENT LOCKED OUT" ; return ( KDC_ERR_CLIENT_REVOKED ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = "SERVICE LOCKED OUT" ; return ( KDC_ERR_S_PRINCIPAL_UNKNOWN ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_SVR ) ) { * status = "SERVICE NOT ALLOWED" ; return ( KDC_ERR_MUST_USE_USER2USER ) ; } if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) { * status = "ANONYMOUS NOT ALLOWED" ; return ( KDC_ERR_POLICY ) ; } ret = krb5_db_check_policy_as ( kdc_context , request , & client , & server , kdc_time , status , e_data ) ; if ( ret && ret != KRB5_PLUGIN_OP_NOTSUPP ) return errcode_to_protocol ( ret ) ; errcode = against_local_policy_as ( request , client , server , kdc_time , status , e_data ) ; if ( errcode ) return errcode ; return 0 ; }
nsINode :: SetUserData ( JSContext * aCx , const nsAString & aKey , JS :: Handle < JS :: Value > aData , nsIDOMUserDataHandler * aHandler , ErrorResult & aError ) { nsCOMPtr < nsIVariant > data ; JS :: Rooted < JS :: Value > dataVal ( aCx , aData ) ; aError = nsContentUtils :: XPConnect ( ) -> JSValToVariant ( aCx , dataVal , getter_AddRefs ( data ) ) ; if ( aError . Failed ( ) ) { return JS :: UndefinedValue ( ) ; } nsCOMPtr < nsIVariant > oldData ; aError = SetUserData ( aKey , data , aHandler , getter_AddRefs ( oldData ) ) ; if ( aError . Failed ( ) ) { return JS :: UndefinedValue ( ) ; } if ( ! oldData ) { return JS :: NullValue ( ) ; } JS :: Rooted < JS :: Value > result ( aCx ) ; JSAutoCompartment ac ( aCx , GetWrapper ( ) ) ; aError = nsContentUtils :: XPConnect ( ) -> VariantToJS ( aCx , GetWrapper ( ) , oldData , & result ) ; return result ; }
Operand RegExpMacroAssemblerIA32 :: register_location ( int register_index ) { DCHECK ( register_index < ( 1 < < 30 ) ) ; if ( num_registers_ <= register_index ) { num_registers_ = register_index + 1 ; } return Operand ( ebp , kRegisterZero - register_index * kPointerSize ) ; }
MYSOFA_EXPORT struct MYSOFA_HRTF * mysofa_load ( const char * filename , int * err ) { struct READER reader ; struct MYSOFA_HRTF * hrtf = NULL ; if ( filename == NULL ) filename = CMAKE_INSTALL_PREFIX "/share/libmysofa/default.sofa" ; if ( strcmp ( filename , "-" ) ) reader . fhd = fopen ( filename , "rb" ) ; else reader . fhd = stdin ; if ( ! reader . fhd ) { log ( "cannot open file %s\n" , filename ) ; * err = errno ; return NULL ; } reader . gcol = NULL ; reader . all = NULL ; * err = superblockRead ( & reader , & reader . superblock ) ; if ( ! * err ) { hrtf = getHrtf ( & reader , err ) ; } superblockFree ( & reader , & reader . superblock ) ; gcolFree ( reader . gcol ) ; if ( strcmp ( filename , "-" ) ) fclose ( reader . fhd ) ; return hrtf ; }
static void * my_malloc ( size_t size ) { malloc_called += 1 ; return malloc ( size ) ; }
void CreateTemplates ( Isolate * isolate , int slack ) { Factory * factory = isolate -> factory ( ) ; descriptor_array_template_ = factory -> empty_descriptor_array ( ) ; properties_dictionary_template_ = factory -> empty_property_dictionary ( ) ; if ( property_count_ || HasDictionaryProperties ( ) || slack ) { if ( HasDictionaryProperties ( ) ) { properties_dictionary_template_ = NameDictionary :: New ( isolate , property_count_ + computed_count_ + slack ) ; } else { descriptor_array_template_ = DescriptorArray :: Allocate ( isolate , 0 , property_count_ + slack ) ; } } elements_dictionary_template_ = element_count_ || computed_count_ ? NumberDictionary :: New ( isolate , element_count_ + computed_count_ ) : factory -> empty_slow_element_dictionary ( ) ; computed_properties_ = computed_count_ ? factory -> NewFixedArray ( computed_count_ * ClassBoilerplate :: kFullComputedEntrySize ) : factory -> empty_fixed_array ( ) ; temp_handle_ = handle ( Smi :: kZero , isolate ) ; }
} static void ImportCbYCrYQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) { QuantumAny range ; register ssize_t x ; unsigned int pixel ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; switch ( quantum_info -> depth ) { case 10 : { Quantum cbcr [ 4 ] ; pixel = 0 ; if ( quantum_info -> pack == MagickFalse ) { register ssize_t i ; size_t quantum ; ssize_t n ; n = 0 ; quantum = 0 ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x += 2 ) { for ( i = 0 ; i < 4 ; i ++ ) { switch ( n % 3 ) { case 0 : { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel > > 22 ) & 0x3ff ) < < 6 ) ) ) ; break ; } case 1 : { quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel > > 12 ) & 0x3ff ) < < 6 ) ) ) ; break ; } case 2 : { quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel > > 2 ) & 0x3ff ) < < 6 ) ) ) ; break ; } } cbcr [ i ] = ( Quantum ) ( quantum ) ; n ++ ; } p += quantum_info -> pad ; SetPixelRed ( image , cbcr [ 1 ] , q ) ; SetPixelGreen ( image , cbcr [ 0 ] , q ) ; SetPixelBlue ( image , cbcr [ 2 ] , q ) ; q += GetPixelChannels ( image ) ; SetPixelRed ( image , cbcr [ 3 ] , q ) ; SetPixelGreen ( image , cbcr [ 0 ] , q ) ; SetPixelBlue ( image , cbcr [ 2 ] , q ) ; q += GetPixelChannels ( image ) ; } break ; } } default : { range = GetQuantumRange ( quantum_info -> depth ) ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelRed ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGreen ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; }
int t2p_process_jpeg_strip ( unsigned char * strip , tsize_t * striplength , unsigned char * buffer , tsize_t * bufferoffset , tstrip_t no , uint32 height ) { tsize_t i = 0 ; while ( i < * striplength ) { tsize_t datalen ; uint16 ri ; uint16 v_samp ; uint16 h_samp ; int j ; int ncomp ; if ( strip [ i ] != 0xff ) return ( 0 ) ; i ++ ; while ( i < * striplength && strip [ i ] == 0xff ) i ++ ; if ( i >= * striplength ) return ( 0 ) ; if ( strip [ i ] == 0xd8 ) datalen = 0 ; else { if ( ( * striplength - i ) <= 2 ) return ( 0 ) ; datalen = ( strip [ i + 1 ] < < 8 ) | strip [ i + 2 ] ; if ( datalen < 2 || datalen >= ( * striplength - i ) ) return ( 0 ) ; } switch ( strip [ i ] ) { case 0xd8 : _TIFFmemcpy ( & ( buffer [ * bufferoffset ] ) , & ( strip [ i - 1 ] ) , 2 ) ; * bufferoffset += 2 ; break ; case 0xc0 : case 0xc1 : case 0xc3 : case 0xc9 : case 0xca : if ( no == 0 ) { _TIFFmemcpy ( & ( buffer [ * bufferoffset ] ) , & ( strip [ i - 1 ] ) , datalen + 2 ) ; ncomp = buffer [ * bufferoffset + 9 ] ; if ( ncomp < 1 || ncomp > 4 ) return ( 0 ) ; v_samp = 1 ; h_samp = 1 ; for ( j = 0 ; j < ncomp ; j ++ ) { uint16 samp = buffer [ * bufferoffset + 11 + ( 3 * j ) ] ; if ( ( samp > > 4 ) > h_samp ) h_samp = ( samp > > 4 ) ; if ( ( samp & 0x0f ) > v_samp ) v_samp = ( samp & 0x0f ) ; } v_samp *= 8 ; h_samp *= 8 ; ri = ( ( ( ( ( uint16 ) ( buffer [ * bufferoffset + 5 ] ) < < 8 ) | ( uint16 ) ( buffer [ * bufferoffset + 6 ] ) ) + v_samp - 1 ) / v_samp ) ; ri *= ( ( ( ( ( uint16 ) ( buffer [ * bufferoffset + 7 ] ) < < 8 ) | ( uint16 ) ( buffer [ * bufferoffset + 8 ] ) ) + h_samp - 1 ) / h_samp ) ; buffer [ * bufferoffset + 5 ] = ( unsigned char ) ( ( height > > 8 ) & 0xff ) ; buffer [ * bufferoffset + 6 ] = ( unsigned char ) ( height & 0xff ) ; * bufferoffset += datalen + 2 ; buffer [ ( * bufferoffset ) ++ ] = 0xff ; buffer [ ( * bufferoffset ) ++ ] = 0xdd ; buffer [ ( * bufferoffset ) ++ ] = 0x00 ; buffer [ ( * bufferoffset ) ++ ] = 0x04 ; buffer [ ( * bufferoffset ) ++ ] = ( ri > > 8 ) & 0xff ; buffer [ ( * bufferoffset ) ++ ] = ri & 0xff ; } break ; case 0xc4 : case 0xdb : _TIFFmemcpy ( & ( buffer [ * bufferoffset ] ) , & ( strip [ i - 1 ] ) , datalen + 2 ) ; * bufferoffset += datalen + 2 ; break ; case 0xda : if ( no == 0 ) { _TIFFmemcpy ( & ( buffer [ * bufferoffset ] ) , & ( strip [ i - 1 ] ) , datalen + 2 ) ; * bufferoffset += datalen + 2 ; } else { buffer [ ( * bufferoffset ) ++ ] = 0xff ; buffer [ ( * bufferoffset ) ++ ] = ( unsigned char ) ( 0xd0 | ( ( no - 1 ) % 8 ) ) ; } i += datalen + 1 ; _TIFFmemcpy ( & ( buffer [ * bufferoffset ] ) , & ( strip [ i ] ) , * striplength - i ) ; * bufferoffset += * striplength - i ; return ( 1 ) ; default : break ; } i += datalen + 1 ; } return ( 0 ) ; }
nsXBLProtoImplField :: InstallField ( nsIScriptContext * aContext , JSObject * aBoundNode , nsIURI * aBindingDocURI , bool * aDidInstall ) const { NS_PRECONDITION ( aBoundNode , "uh-oh, bound node should NOT be null or bad things will " "happen" ) ; * aDidInstall = false ; if ( IsEmpty ( ) ) { return NS_OK ; } nsAutoMicroTask mt ; nsresult rv ; nsAutoCString uriSpec ; aBindingDocURI -> GetSpec ( uriSpec ) ; JSContext * cx = aContext -> GetNativeContext ( ) ; NS_ASSERTION ( ! :: JS_IsExceptionPending ( cx ) , "Shouldn't get here when an exception is pending!" ) ; nsCOMPtr < nsIScriptContext > context = aContext ; JSAutoRequest ar ( cx ) ; jsval result = JSVAL_NULL ; JS :: CompileOptions options ( cx ) ; options . setFileAndLine ( uriSpec . get ( ) , mLineNumber ) . setVersion ( JSVERSION_LATEST ) . setUserBit ( true ) ; rv = context -> EvaluateString ( nsDependentString ( mFieldText , mFieldTextLength ) , * aBoundNode , options , false , & result ) ; if ( NS_FAILED ( rv ) ) { return rv ; } nsDependentString name ( mName ) ; if ( ! :: JS_DefineUCProperty ( cx , aBoundNode , reinterpret_cast < const jschar * > ( mName ) , name . Length ( ) , result , nullptr , nullptr , mJSAttributes ) ) { return NS_ERROR_OUT_OF_MEMORY ; } * aDidInstall = true ; return NS_OK ; }
jit :: RecompileOnStackBaselineScriptsForDebugMode ( JSContext * cx , JSCompartment * comp ) { AutoCompartment ac ( cx , comp ) ; Vector < DebugModeOSREntry > entries ( cx ) ; for ( JitActivationIterator iter ( cx -> runtime ( ) ) ; ! iter . done ( ) ; ++ iter ) { if ( iter . activation ( ) -> compartment ( ) == comp ) { if ( ! CollectOnStackScripts ( cx , iter , entries ) ) return false ; } } #ifdef JSGC_GENERATIONAL if ( ! entries . empty ( ) ) MinorGC ( cx -> runtime ( ) , JS :: gcreason :: EVICT_NURSERY ) ; #endif for ( size_t i = 0 ; i < entries . length ( ) ; i ++ ) { JSScript * script = entries [ i ] . script ; if ( ! RecompileBaselineScriptForDebugMode ( cx , script ) || ! CloneOldBaselineStub ( cx , entries , i ) ) { UndoRecompileBaselineScriptsForDebugMode ( cx , entries ) ; return false ; } } for ( size_t i = 0 ; i < entries . length ( ) ; i ++ ) { if ( entries [ i ] . recompiled ( ) ) BaselineScript :: Destroy ( cx -> runtime ( ) -> defaultFreeOp ( ) , entries [ i ] . oldBaselineScript ) ; } size_t processed = 0 ; for ( JitActivationIterator iter ( cx -> runtime ( ) ) ; ! iter . done ( ) ; ++ iter ) { if ( iter . activation ( ) -> compartment ( ) == comp ) PatchBaselineFramesForDebugMode ( cx , iter , entries , & processed ) ; } MOZ_ASSERT ( processed == entries . length ( ) ) ; return true ; }
WebGLContext :: CompressedTexImage2D ( WebGLenum target , WebGLint level , WebGLenum internalformat , WebGLsizei width , WebGLsizei height , WebGLint border , ArrayBufferView & view ) { if ( ! IsContextStable ( ) ) { return ; } if ( ! ValidateTexImage2DTarget ( target , width , height , "compressedTexImage2D" ) ) { return ; } WebGLTexture * tex = activeBoundTextureForTarget ( target ) ; if ( ! tex ) { ErrorInvalidOperation ( "compressedTexImage2D: no texture is bound to this target" ) ; return ; } if ( ! mCompressedTextureFormats . Contains ( internalformat ) ) { ErrorInvalidEnum ( "compressedTexImage2D: compressed texture format 0x%x is not supported" , internalformat ) ; return ; } if ( border ) { ErrorInvalidValue ( "compressedTexImage2D: border is not 0" ) ; return ; } uint32_t byteLength = view . Length ( ) ; if ( ! ValidateCompressedTextureSize ( target , level , internalformat , width , height , byteLength , "compressedTexImage2D" ) ) { return ; } gl -> fCompressedTexImage2D ( target , level , internalformat , width , height , border , byteLength , view . Data ( ) ) ; tex -> SetImageInfo ( target , level , width , height , internalformat , LOCAL_GL_UNSIGNED_BYTE ) ; }
static int uvesafb_setcmap ( struct fb_cmap * cmap , struct fb_info * info ) { struct uvesafb_pal_entry * entries ; int shift = 16 - dac_width ; int i , err = 0 ; if ( info -> var . bits_per_pixel == 8 ) { if ( cmap -> start + cmap -> len > info -> cmap . start + info -> cmap . len || cmap -> start < info -> cmap . start ) return - EINVAL ; entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ; if ( ! entries ) return - ENOMEM ; for ( i = 0 ; i < cmap -> len ; i ++ ) { entries [ i ] . red = cmap -> red [ i ] > > shift ; entries [ i ] . green = cmap -> green [ i ] > > shift ; entries [ i ] . blue = cmap -> blue [ i ] > > shift ; entries [ i ] . pad = 0 ; } err = uvesafb_setpalette ( entries , cmap -> len , cmap -> start , info ) ; kfree ( entries ) ; } else { for ( i = 0 ; i < cmap -> len ; i ++ ) { err |= uvesafb_setcolreg ( cmap -> start + i , cmap -> red [ i ] , cmap -> green [ i ] , cmap -> blue [ i ] , 0 , info ) ; } } return err ; }
static int16_t decodeSample ( ms_adpcm_state & state , uint8_t code , const int16_t * coefficient ) { int linearSample = ( state . sample1 * coefficient [ 0 ] + state . sample2 * coefficient [ 1 ] ) > > 8 ; linearSample += ( ( code & 0x08 ) ? ( code - 0x10 ) : code ) * state . delta ; linearSample = clamp ( linearSample , MIN_INT16 , MAX_INT16 ) ; int delta = ( state . delta * adaptationTable [ code ] ) > > 8 ; if ( delta < 16 ) delta = 16 ; state . delta = delta ; state . sample2 = state . sample1 ; state . sample1 = linearSample ; return static_cast < int16_t > ( linearSample ) ; }
void vp8_update_gf_useage_maps ( VP8_COMP * cpi , VP8_COMMON * cm , MACROBLOCK * x ) { int mb_row , mb_col ; MODE_INFO * this_mb_mode_info = cm -> mi ; x -> gf_active_ptr = ( signed char * ) cpi -> gf_active_flags ; if ( ( cm -> frame_type == KEY_FRAME ) || ( cm -> refresh_golden_frame ) ) { vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; } else { for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( ( this_mb_mode_info -> mbmi . ref_frame == GOLDEN_FRAME ) || ( this_mb_mode_info -> mbmi . ref_frame == ALTREF_FRAME ) ) { if ( * ( x -> gf_active_ptr ) == 0 ) { * ( x -> gf_active_ptr ) = 1 ; cpi -> gf_active_count ++ ; } } else if ( ( this_mb_mode_info -> mbmi . mode != ZEROMV ) && * ( x -> gf_active_ptr ) ) { * ( x -> gf_active_ptr ) = 0 ; cpi -> gf_active_count -- ; } x -> gf_active_ptr ++ ; this_mb_mode_info ++ ; } this_mb_mode_info ++ ; } } }
nsEventListenerManager :: AddScriptEventListener ( nsIAtom * aName , const nsAString & aBody , PRUint32 aLanguage , bool aDeferCompilation , bool aPermitUntrustedEvents ) { NS_PRECONDITION ( aLanguage != nsIProgrammingLanguage :: UNKNOWN , "Must know the language for the script event listener" ) ; if ( aPermitUntrustedEvents && aLanguage != nsIProgrammingLanguage :: JAVASCRIPT ) { NS_WARNING ( "Discarding non-JS event listener from untrusted source" ) ; return NS_ERROR_FAILURE ; } nsCOMPtr < nsINode > node ( do_QueryInterface ( mTarget ) ) ; nsCOMPtr < nsIDocument > doc ; nsCOMPtr < nsIScriptGlobalObject > global ; if ( node ) { global = node -> OwnerDoc ( ) -> GetScriptGlobalObject ( ) ; } else { nsCOMPtr < nsPIDOMWindow > win ( do_QueryInterface ( mTarget ) ) ; if ( win ) { NS_ASSERTION ( win -> IsInnerWindow ( ) , "Event listener added to outer window!" ) ; nsCOMPtr < nsIDOMDocument > domdoc ; win -> GetDocument ( getter_AddRefs ( domdoc ) ) ; doc = do_QueryInterface ( domdoc ) ; global = do_QueryInterface ( win ) ; } else { global = do_QueryInterface ( mTarget ) ; } } if ( ! global ) { return NS_OK ; } nsresult rv = NS_OK ; if ( doc ) { nsCOMPtr < nsIContentSecurityPolicy > csp ; rv = doc -> NodePrincipal ( ) -> GetCsp ( getter_AddRefs ( csp ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( csp ) { bool inlineOK ; rv = csp -> GetAllowsInlineScript ( & inlineOK ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! inlineOK ) { nsIURI * uri = doc -> GetDocumentURI ( ) ; nsCAutoString asciiSpec ; if ( uri ) uri -> GetAsciiSpec ( asciiSpec ) ; nsAutoString scriptSample , attr , tagName ( NS_LITERAL_STRING ( "UNKNOWN" ) ) ; aName -> ToString ( attr ) ; nsCOMPtr < nsIDOMNode > domNode ( do_QueryInterface ( mTarget ) ) ; if ( domNode ) domNode -> GetNodeName ( tagName ) ; scriptSample . Assign ( attr ) ; scriptSample . AppendLiteral ( " attribute on " ) ; scriptSample . Append ( tagName ) ; scriptSample . AppendLiteral ( " element" ) ; csp -> LogViolationDetails ( nsIContentSecurityPolicy :: VIOLATION_TYPE_INLINE_SCRIPT , NS_ConvertUTF8toUTF16 ( asciiSpec ) , scriptSample , nsnull ) ; return NS_OK ; } } } if ( NS_FAILED ( global -> EnsureScriptEnvironment ( ) ) ) { NS_WARNING ( "Failed to setup script environment for this language" ) ; } nsIScriptContext * context = global -> GetScriptContext ( ) ; NS_ENSURE_TRUE ( context , NS_ERROR_FAILURE ) ; JSObject * scope = global -> GetGlobalJSObject ( ) ; nsListenerStruct * ls ; rv = SetJSEventListener ( context , scope , aName , nsnull , aPermitUntrustedEvents , & ls ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! aDeferCompilation ) { return CompileEventHandlerInternal ( ls , true , & aBody ) ; } return NS_OK ; }
Node * Node :: Clone ( Zone * zone , NodeId id , const Node * node ) { int const input_count = node -> InputCount ( ) ; Node * const * const inputs = node -> has_inline_inputs ( ) ? node -> inputs_ . inline_ : node -> inputs_ . outline_ -> inputs_ ; Node * const clone = New ( zone , id , node -> op ( ) , input_count , inputs , false ) ; clone -> set_type ( node -> type ( ) ) ; return clone ; }
BUILTIN ( NumberPrototypeToPrecision ) { HandleScope scope ( isolate ) ; Handle < Object > value = args . at ( 0 ) ; Handle < Object > precision = args . atOrUndefined ( isolate , 1 ) ; if ( value -> IsJSValue ( ) ) { value = handle ( Handle < JSValue > :: cast ( value ) -> value ( ) , isolate ) ; } if ( ! value -> IsNumber ( ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( MessageTemplate :: kNotGeneric , isolate -> factory ( ) -> NewStringFromAsciiChecked ( "Number.prototype.toPrecision" ) , isolate -> factory ( ) -> Number_string ( ) ) ) ; } double const value_number = value -> Number ( ) ; if ( precision -> IsUndefined ( isolate ) ) { return * isolate -> factory ( ) -> NumberToString ( value ) ; } ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , precision , Object :: ToInteger ( isolate , precision ) ) ; double const precision_number = precision -> Number ( ) ; if ( std :: isnan ( value_number ) ) return ReadOnlyRoots ( isolate ) . NaN_string ( ) ; if ( std :: isinf ( value_number ) ) { return ( value_number < 0.0 ) ? ReadOnlyRoots ( isolate ) . minus_Infinity_string ( ) : ReadOnlyRoots ( isolate ) . Infinity_string ( ) ; } if ( precision_number < 1.0 || precision_number > kMaxFractionDigits ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewRangeError ( MessageTemplate :: kToPrecisionFormatRange ) ) ; } char * const str = DoubleToPrecisionCString ( value_number , static_cast < int > ( precision_number ) ) ; Handle < String > result = isolate -> factory ( ) -> NewStringFromAsciiChecked ( str ) ; DeleteArray ( str ) ; return * result ; }
WorkerRun ( JSContext * aCx , WorkerPrivate * aWorkerPrivate ) override { MOZ_ASSERT ( aWorkerPrivate ) ; RefPtr < EventTarget > target = do_QueryObject ( aWorkerPrivate -> GlobalScope ( ) ) ; ErrorResult result ; RefPtr < Notification > notification = Notification :: ConstructFromFields ( aWorkerPrivate -> GlobalScope ( ) , mID , mTitle , mDir , mLang , mBody , mTag , mIcon , mData , mScope , result ) ; if ( NS_WARN_IF ( result . Failed ( ) ) ) { return false ; } NotificationEventInit nei ; nei . mNotification = notification ; nei . mBubbles = false ; nei . mCancelable = false ; RefPtr < NotificationEvent > event = NotificationEvent :: Constructor ( target , mEventName , nei , result ) ; if ( NS_WARN_IF ( result . Failed ( ) ) ) { return false ; } event -> SetTrusted ( true ) ; aWorkerPrivate -> GlobalScope ( ) -> AllowWindowInteraction ( ) ; RefPtr < AllowWindowInteractionHandler > allowWindowInteraction = new AllowWindowInteractionHandler ( aWorkerPrivate ) ; nsresult rv = DispatchExtendableEventOnWorkerScope ( aCx , aWorkerPrivate -> GlobalScope ( ) , event , allowWindowInteraction ) ; if ( NS_FAILED ( rv ) && rv != NS_ERROR_XPC_JS_THREW_EXCEPTION ) { allowWindowInteraction -> FinishedWithResult ( Rejected ) ; } aWorkerPrivate -> GlobalScope ( ) -> ConsumeWindowInteraction ( ) ; return true ; }
BUILTIN ( ReflectOwnKeys ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 2 , args . length ( ) ) ; Handle < Object > target = args . at ( 1 ) ; if ( ! target -> IsJSReceiver ( ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( MessageTemplate :: kCalledOnNonObject , isolate -> factory ( ) -> NewStringFromAsciiChecked ( "Reflect.ownKeys" ) ) ) ; } Handle < FixedArray > keys ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , keys , KeyAccumulator :: GetKeys ( Handle < JSReceiver > :: cast ( target ) , KeyCollectionMode :: kOwnOnly , ALL_PROPERTIES , GetKeysConversion :: kConvertToString ) ) ; return * isolate -> factory ( ) -> NewJSArrayWithElements ( keys ) ; }
static OPJ_BOOL opj_j2k_read_ppm ( opj_j2k_t * p_j2k , OPJ_BYTE * p_header_data , OPJ_UINT32 p_header_size , opj_event_mgr_t * p_manager ) { opj_cp_t * l_cp = 00 ; OPJ_UINT32 l_Z_ppm ; assert ( p_header_data != 00 ) ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; if ( p_header_size < 2 ) { opj_event_msg ( p_manager , EVT_ERROR , "Error reading PPM marker\n" ) ; return OPJ_FALSE ; } l_cp = & ( p_j2k -> m_cp ) ; l_cp -> ppm = 1 ; opj_read_bytes ( p_header_data , & l_Z_ppm , 1 ) ; ++ p_header_data ; -- p_header_size ; if ( l_cp -> ppm_markers == NULL ) { OPJ_UINT32 l_newCount = l_Z_ppm + 1U ; assert ( l_cp -> ppm_markers_count == 0U ) ; l_cp -> ppm_markers = ( opj_ppx * ) opj_calloc ( l_newCount , sizeof ( opj_ppx ) ) ; if ( l_cp -> ppm_markers == NULL ) { opj_event_msg ( p_manager , EVT_ERROR , "Not enough memory to read PPM marker\n" ) ; return OPJ_FALSE ; } l_cp -> ppm_markers_count = l_newCount ; } else if ( l_cp -> ppm_markers_count <= l_Z_ppm ) { OPJ_UINT32 l_newCount = l_Z_ppm + 1U ; opj_ppx * new_ppm_markers ; new_ppm_markers = ( opj_ppx * ) opj_realloc ( l_cp -> ppm_markers , l_newCount * sizeof ( opj_ppx ) ) ; if ( new_ppm_markers == NULL ) { opj_event_msg ( p_manager , EVT_ERROR , "Not enough memory to read PPM marker\n" ) ; return OPJ_FALSE ; } l_cp -> ppm_markers = new_ppm_markers ; memset ( l_cp -> ppm_markers + l_cp -> ppm_markers_count , 0 , ( l_newCount - l_cp -> ppm_markers_count ) * sizeof ( opj_ppx ) ) ; l_cp -> ppm_markers_count = l_newCount ; } if ( l_cp -> ppm_markers [ l_Z_ppm ] . m_data != NULL ) { opj_event_msg ( p_manager , EVT_ERROR , "Zppm %u already read\n" , l_Z_ppm ) ; return OPJ_FALSE ; } l_cp -> ppm_markers [ l_Z_ppm ] . m_data = opj_malloc ( p_header_size ) ; if ( l_cp -> ppm_markers [ l_Z_ppm ] . m_data == NULL ) { opj_event_msg ( p_manager , EVT_ERROR , "Not enough memory to read PPM marker\n" ) ; return OPJ_FALSE ; } l_cp -> ppm_markers [ l_Z_ppm ] . m_data_size = p_header_size ; memcpy ( l_cp -> ppm_markers [ l_Z_ppm ] . m_data , p_header_data , p_header_size ) ; return OPJ_TRUE ; }
DOMSVGPointList :: InternalListWillChangeTo ( const SVGPointList & aNewValue ) { PRUint32 oldLength = mItems . Length ( ) ; PRUint32 newLength = aNewValue . Length ( ) ; if ( newLength > DOMSVGPoint :: MaxListIndex ( ) ) { newLength = DOMSVGPoint :: MaxListIndex ( ) ; } nsRefPtr < DOMSVGPointList > kungFuDeathGrip ; if ( oldLength && ! newLength ) { kungFuDeathGrip = this ; } for ( PRUint32 i = newLength ; i < oldLength ; ++ i ) { if ( mItems [ i ] ) { mItems [ i ] -> RemovingFromList ( ) ; } } if ( ! mItems . SetLength ( newLength ) ) { mItems . Clear ( ) ; return ; } for ( PRUint32 i = oldLength ; i < newLength ; ++ i ) { mItems [ i ] = nsnull ; } }
cifs_lookup ( struct inode * parent_dir_inode , struct dentry * direntry , struct nameidata * nd ) { int xid ; int rc = 0 ; __u32 oplock = enable_oplocks ? REQ_OPLOCK : 0 ; __u16 fileHandle = 0 ; bool posix_open = false ; struct cifs_sb_info * cifs_sb ; struct tcon_link * tlink ; struct cifs_tcon * pTcon ; struct cifsFileInfo * cfile ; struct inode * newInode = NULL ; char * full_path = NULL ; struct file * filp ; xid = GetXid ( ) ; cFYI ( 1 , "parent inode = 0x%p name is: %s and dentry = 0x%p" , parent_dir_inode , direntry -> d_name . name , direntry ) ; cifs_sb = CIFS_SB ( parent_dir_inode -> i_sb ) ; tlink = cifs_sb_tlink ( cifs_sb ) ; if ( IS_ERR ( tlink ) ) { FreeXid ( xid ) ; return ( struct dentry * ) tlink ; } pTcon = tlink_tcon ( tlink ) ; if ( ! ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) ) { int i ; for ( i = 0 ; i < direntry -> d_name . len ; i ++ ) if ( direntry -> d_name . name [ i ] == '\\' ) { cFYI ( 1 , "Invalid file name" ) ; rc = - EINVAL ; goto lookup_out ; } } if ( nd && ( nd -> flags & LOOKUP_EXCL ) ) { d_instantiate ( direntry , NULL ) ; rc = 0 ; goto lookup_out ; } full_path = build_path_from_dentry ( direntry ) ; if ( full_path == NULL ) { rc = - ENOMEM ; goto lookup_out ; } if ( direntry -> d_inode != NULL ) { cFYI ( 1 , "non-NULL inode in lookup" ) ; } else { cFYI ( 1 , "NULL inode in lookup" ) ; } cFYI ( 1 , "Full path: %s inode = 0x%p" , full_path , direntry -> d_inode ) ; if ( pTcon -> unix_ext ) { if ( nd && ! ( nd -> flags & LOOKUP_DIRECTORY ) && ( nd -> flags & LOOKUP_OPEN ) && ! pTcon -> broken_posix_open && ( nd -> intent . open . file -> f_flags & O_CREAT ) ) { rc = cifs_posix_open ( full_path , & newInode , parent_dir_inode -> i_sb , nd -> intent . open . create_mode , nd -> intent . open . file -> f_flags , & oplock , & fileHandle , xid ) ; if ( ( rc == 0 ) || ( rc == - ENOENT ) ) posix_open = true ; else if ( ( rc == - EINVAL ) || ( rc != - EOPNOTSUPP ) ) pTcon -> broken_posix_open = true ; } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; if ( ( rc == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if ( rc == - ENOENT ) { rc = 0 ; direntry -> d_time = jiffies ; d_add ( direntry , NULL ) ; } else if ( rc != - EACCES ) { cERROR ( 1 , "Unexpected lookup error %d" , rc ) ; } lookup_out : kfree ( full_path ) ; cifs_put_tlink ( tlink ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }
void StartupDeserializer :: DeserializeInto ( Isolate * isolate ) { Initialize ( isolate ) ; BuiltinDeserializer builtin_deserializer ( isolate , builtin_data_ ) ; if ( ! DefaultDeserializerAllocator :: ReserveSpace ( this , & builtin_deserializer ) ) { V8 :: FatalProcessOutOfMemory ( isolate , "StartupDeserializer" ) ; } DCHECK_NULL ( isolate -> thread_manager ( ) -> FirstThreadStateInUse ( ) ) ; DCHECK ( isolate -> handle_scope_implementer ( ) -> blocks ( ) -> empty ( ) ) ; DCHECK ( isolate -> partial_snapshot_cache ( ) -> empty ( ) ) ; DCHECK ( ! isolate -> builtins ( ) -> is_initialized ( ) ) ; { DisallowHeapAllocation no_gc ; isolate -> heap ( ) -> IterateSmiRoots ( this ) ; isolate -> heap ( ) -> IterateStrongRoots ( this , VISIT_ONLY_STRONG ) ; isolate -> heap ( ) -> RepairFreeListsAfterDeserialization ( ) ; isolate -> heap ( ) -> IterateWeakRoots ( this , VISIT_FOR_SERIALIZATION ) ; DeserializeDeferredObjects ( ) ; RestoreExternalReferenceRedirectors ( accessor_infos ( ) ) ; RestoreExternalReferenceRedirectors ( call_handler_infos ( ) ) ; builtin_deserializer . DeserializeEagerBuiltinsAndHandlers ( ) ; FlushICacheForNewIsolate ( ) ; } isolate -> heap ( ) -> set_native_contexts_list ( ReadOnlyRoots ( isolate ) . undefined_value ( ) ) ; if ( isolate -> heap ( ) -> allocation_sites_list ( ) == Smi :: kZero ) { isolate -> heap ( ) -> set_allocation_sites_list ( ReadOnlyRoots ( isolate ) . undefined_value ( ) ) ; } LOG_CODE_EVENT ( isolate , LogCodeObjects ( ) ) ; LOG_CODE_EVENT ( isolate , LogBytecodeHandlers ( ) ) ; LOG_CODE_EVENT ( isolate , LogCompiledFunctions ( ) ) ; isolate -> builtins ( ) -> MarkInitialized ( ) ; PrintDisassembledCodeObjects ( ) ; if ( FLAG_rehash_snapshot && can_rehash ( ) ) RehashHeap ( ) ; }
void OS :: SetRandomMmapSeed ( int64_t seed ) { if ( seed ) { LockGuard < Mutex > guard ( rng_mutex . Pointer ( ) ) ; platform_random_number_generator . Pointer ( ) -> SetSeed ( seed ) ; } }
IonBailoutIterator :: IonBailoutIterator ( const JitActivationIterator & activations , BailoutStack * bailout ) : JitFrameIterator ( activations ) , machine_ ( bailout -> machine ( ) ) { uint8_t * sp = bailout -> parentStackPointer ( ) ; uint8_t * fp = sp + bailout -> frameSize ( ) ; kind_ = Kind_BailoutIterator ; current_ = fp ; type_ = JitFrame_IonJS ; topFrameSize_ = current_ - sp ; switch ( mode_ ) { case SequentialExecution : topIonScript_ = script ( ) -> ionScript ( ) ; break ; case ParallelExecution : topIonScript_ = script ( ) -> parallelIonScript ( ) ; break ; default : MOZ_CRASH ( "No such execution mode" ) ; } if ( bailout -> frameClass ( ) == FrameSizeClass :: None ( ) ) { snapshotOffset_ = bailout -> snapshotOffset ( ) ; return ; } JitActivation * activation = activations . activation ( ) -> asJit ( ) ; JSRuntime * rt = activation -> compartment ( ) -> runtimeFromMainThread ( ) ; JitCode * code = rt -> jitRuntime ( ) -> getBailoutTable ( bailout -> frameClass ( ) ) ; uintptr_t tableOffset = bailout -> tableOffset ( ) ; uintptr_t tableStart = reinterpret_cast < uintptr_t > ( code -> raw ( ) ) ; MOZ_ASSERT ( tableOffset >= tableStart && tableOffset < tableStart + code -> instructionsSize ( ) ) ; MOZ_ASSERT ( ( tableOffset - tableStart ) % BAILOUT_TABLE_ENTRY_SIZE == 0 ) ; uint32_t bailoutId = ( ( tableOffset - tableStart ) / BAILOUT_TABLE_ENTRY_SIZE ) - 1 ; MOZ_ASSERT ( bailoutId < BAILOUT_TABLE_SIZE ) ; snapshotOffset_ = topIonScript_ -> bailoutToSnapshot ( bailoutId ) ; }
static bool GetX4Lane ( JSContext * cx , unsigned argc , Value * vp ) { typedef typename Type32x4 :: Elem Elem ; CallArgs args = CallArgsFromVp ( argc , vp ) ; if ( ! args . thisv ( ) . isObject ( ) || ! args . thisv ( ) . toObject ( ) . is < TypedObject > ( ) ) { JS_ReportErrorNumber ( cx , js_GetErrorMessage , nullptr , JSMSG_INCOMPATIBLE_PROTO , X4TypeDescr :: class_ . name , laneNames [ lane ] , InformalValueTypeName ( args . thisv ( ) ) ) ; return false ; } TypedObject & typedObj = args . thisv ( ) . toObject ( ) . as < TypedObject > ( ) ; TypeDescr & descr = typedObj . typeDescr ( ) ; if ( descr . kind ( ) != TypeDescr :: X4 || descr . as < X4TypeDescr > ( ) . type ( ) != Type32x4 :: type ) { JS_ReportErrorNumber ( cx , js_GetErrorMessage , nullptr , JSMSG_INCOMPATIBLE_PROTO , X4TypeDescr :: class_ . name , laneNames [ lane ] , InformalValueTypeName ( args . thisv ( ) ) ) ; return false ; } Elem * data = reinterpret_cast < Elem * > ( typedObj . typedMem ( ) ) ; Type32x4 :: setReturn ( args , data [ lane ] ) ; return true ; }
void StaNamedProperty ( Callable ic ) { Node * code_target = HeapConstant ( ic . code ( ) ) ; Node * object = LoadRegisterAtOperandIndex ( 0 ) ; Node * name = LoadConstantPoolEntryAtOperandIndex ( 1 ) ; Node * value = GetAccumulator ( ) ; Node * raw_slot = BytecodeOperandIdx ( 2 ) ; Node * smi_slot = SmiTag ( raw_slot ) ; Node * feedback_vector = LoadFeedbackVector ( ) ; Node * context = GetContext ( ) ; Node * result = CallStub ( ic . descriptor ( ) , code_target , context , object , name , value , smi_slot , feedback_vector ) ; SetAccumulator ( result ) ; Dispatch ( ) ; }
Controller :: constructHeaderForSessionProtocol ( Request * req , char * restrict buffer , unsigned int & size , const SessionProtocolWorkingState & state , string delta_monotonic ) { char * pos = buffer ; const char * end = buffer + size ; pos += sizeof ( boost :: uint32_t ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "REQUEST_URI" ) ) ; pos = appendData ( pos , end , req -> path . start -> data , req -> path . size ) ; pos = appendData ( pos , end , "" , 1 ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "PATH_INFO" ) ) ; pos = appendData ( pos , end , state . path . data ( ) , state . path . size ( ) ) ; pos = appendData ( pos , end , "" , 1 ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "SCRIPT_NAME" ) ) ; if ( state . hasBaseURI ) { pos = appendData ( pos , end , req -> options . baseURI ) ; pos = appendData ( pos , end , "" , 1 ) ; } else { pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "" ) ) ; } pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "QUERY_STRING" ) ) ; pos = appendData ( pos , end , state . queryString . data ( ) , state . queryString . size ( ) ) ; pos = appendData ( pos , end , "" , 1 ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "REQUEST_METHOD" ) ) ; pos = appendData ( pos , end , state . methodStr ) ; pos = appendData ( pos , end , "" , 1 ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "SERVER_NAME" ) ) ; pos = appendData ( pos , end , state . serverName ) ; pos = appendData ( pos , end , "" , 1 ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "SERVER_PORT" ) ) ; pos = appendData ( pos , end , state . serverPort ) ; pos = appendData ( pos , end , "" , 1 ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "SERVER_SOFTWARE" ) ) ; pos = appendData ( pos , end , serverSoftware ) ; pos = appendData ( pos , end , "" , 1 ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "SERVER_PROTOCOL" ) ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "HTTP/1.1" ) ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "REMOTE_ADDR" ) ) ; if ( state . remoteAddr != NULL ) { pos = appendData ( pos , end , state . remoteAddr ) ; pos = appendData ( pos , end , "" , 1 ) ; } else { pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "127.0.0.1" ) ) ; } pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "REMOTE_PORT" ) ) ; if ( state . remotePort != NULL ) { pos = appendData ( pos , end , state . remotePort ) ; pos = appendData ( pos , end , "" , 1 ) ; } else { pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "0" ) ) ; } if ( state . remoteUser != NULL ) { pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "REMOTE_USER" ) ) ; pos = appendData ( pos , end , state . remoteUser ) ; pos = appendData ( pos , end , "" , 1 ) ; } if ( state . contentType != NULL ) { pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "CONTENT_TYPE" ) ) ; pos = appendData ( pos , end , state . contentType ) ; pos = appendData ( pos , end , "" , 1 ) ; } if ( state . contentLength != NULL ) { pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "CONTENT_LENGTH" ) ) ; pos = appendData ( pos , end , state . contentLength ) ; pos = appendData ( pos , end , "" , 1 ) ; } pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "PASSENGER_CONNECT_PASSWORD" ) ) ; pos = appendData ( pos , end , req -> session -> getApiKey ( ) . toStaticString ( ) ) ; pos = appendData ( pos , end , "" , 1 ) ; if ( req -> https ) { pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "HTTPS" ) ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "on" ) ) ; } if ( req -> options . analytics ) { pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "PASSENGER_TXN_ID" ) ) ; pos = appendData ( pos , end , req -> options . transaction -> getTxnId ( ) ) ; pos = appendData ( pos , end , "" , 1 ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "PASSENGER_DELTA_MONOTONIC" ) ) ; pos = appendData ( pos , end , delta_monotonic ) ; pos = appendData ( pos , end , "" , 1 ) ; } if ( req -> upgraded ( ) ) { pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "HTTP_CONNECTION" ) ) ; pos = appendData ( pos , end , P_STATIC_STRING_WITH_NULL ( "upgrade" ) ) ; } ServerKit :: HeaderTable :: Iterator it ( req -> headers ) ; while ( * it != NULL ) { if ( ( it -> header -> hash == HTTP_CONTENT_LENGTH . hash ( ) || it -> header -> hash == HTTP_CONTENT_TYPE . hash ( ) || it -> header -> hash == HTTP_CONNECTION . hash ( ) ) && ( psg_lstr_cmp ( & it -> header -> key , P_STATIC_STRING ( "content-type" ) ) || psg_lstr_cmp ( & it -> header -> key , P_STATIC_STRING ( "content-length" ) ) || psg_lstr_cmp ( & it -> header -> key , P_STATIC_STRING ( "connection" ) ) ) ) { it . next ( ) ; continue ; } pos = appendData ( pos , end , P_STATIC_STRING ( "HTTP_" ) ) ; const LString :: Part * part = it -> header -> key . start ; while ( part != NULL ) { char * start = pos ; pos = appendData ( pos , end , part -> data , part -> size ) ; httpHeaderToScgiUpperCase ( ( unsigned char * ) start , pos - start ) ; part = part -> next ; } pos = appendData ( pos , end , "" , 1 ) ; part = it -> header -> val . start ; while ( part != NULL ) { pos = appendData ( pos , end , part -> data , part -> size ) ; part = part -> next ; } pos = appendData ( pos , end , "" , 1 ) ; it . next ( ) ; } if ( state . environmentVariablesData != NULL ) { pos = appendData ( pos , end , state . environmentVariablesData , state . environmentVariablesSize ) ; } Uint32Message :: generate ( buffer , pos - buffer - sizeof ( boost :: uint32_t ) ) ; size = pos - buffer ; return pos < end ; }
static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ; else { offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ; segs = skb_segment ( skb , features ) ; } out : return segs ; }
BumpChunk :: tryAllocUnaligned ( size_t n ) { char * oldBump = bump ; char * newBump = bump + n ; if ( newBump > limit ) return NULL ; JS_ASSERT ( canAllocUnaligned ( n ) ) ; setBump ( newBump ) ; return oldBump ; }
void vp9_rc_postencode_update ( VP9_COMP * cpi , uint64_t bytes_used ) { VP9_COMMON * const cm = & cpi -> common ; const VP9_CONFIG * const oxcf = & cpi -> oxcf ; RATE_CONTROL * const rc = & cpi -> rc ; cm -> last_frame_type = cm -> frame_type ; rc -> projected_frame_size = ( int ) ( bytes_used < < 3 ) ; vp9_rc_update_rate_correction_factors ( cpi , ( cpi -> sf . recode_loop >= ALLOW_RECODE_KFARFGF || oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) ? 2 : 0 ) ; if ( cm -> frame_type == KEY_FRAME ) { rc -> last_q [ KEY_FRAME ] = cm -> base_qindex ; rc -> avg_frame_qindex [ KEY_FRAME ] = ROUND_POWER_OF_TWO ( 3 * rc -> avg_frame_qindex [ KEY_FRAME ] + cm -> base_qindex , 2 ) ; } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) && ! ( cpi -> use_svc && oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) ) { rc -> last_q [ 2 ] = cm -> base_qindex ; rc -> avg_frame_qindex [ 2 ] = ROUND_POWER_OF_TWO ( 3 * rc -> avg_frame_qindex [ 2 ] + cm -> base_qindex , 2 ) ; } else { rc -> last_q [ INTER_FRAME ] = cm -> base_qindex ; rc -> avg_frame_qindex [ INTER_FRAME ] = ROUND_POWER_OF_TWO ( 3 * rc -> avg_frame_qindex [ INTER_FRAME ] + cm -> base_qindex , 2 ) ; rc -> ni_frames ++ ; rc -> tot_q += vp9_convert_qindex_to_q ( cm -> base_qindex ) ; rc -> avg_q = rc -> tot_q / ( double ) rc -> ni_frames ; rc -> ni_tot_qi += cm -> base_qindex ; rc -> ni_av_qi = rc -> ni_tot_qi / rc -> ni_frames ; } if ( ( cm -> base_qindex < rc -> last_boosted_qindex ) || ( ( cpi -> static_mb_pct < 100 ) && ( ( cm -> frame_type == KEY_FRAME ) || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! rc -> is_src_frame_alt_ref ) ) ) ) { rc -> last_boosted_qindex = cm -> base_qindex ; } update_buffer_level ( cpi , rc -> projected_frame_size ) ; if ( cm -> frame_type != KEY_FRAME ) { rc -> rolling_target_bits = ROUND_POWER_OF_TWO ( rc -> rolling_target_bits * 3 + rc -> this_frame_target , 2 ) ; rc -> rolling_actual_bits = ROUND_POWER_OF_TWO ( rc -> rolling_actual_bits * 3 + rc -> projected_frame_size , 2 ) ; rc -> long_rolling_target_bits = ROUND_POWER_OF_TWO ( rc -> long_rolling_target_bits * 31 + rc -> this_frame_target , 5 ) ; rc -> long_rolling_actual_bits = ROUND_POWER_OF_TWO ( rc -> long_rolling_actual_bits * 31 + rc -> projected_frame_size , 5 ) ; } rc -> total_actual_bits += rc -> projected_frame_size ; rc -> total_target_bits += ( cm -> show_frame ? rc -> av_per_frame_bandwidth : 0 ) ; rc -> total_target_vs_actual = rc -> total_actual_bits - rc -> total_target_bits ; if ( oxcf -> play_alternate && cpi -> refresh_alt_ref_frame && ( cm -> frame_type != KEY_FRAME ) ) update_alt_ref_frame_stats ( cpi ) ; else update_golden_frame_stats ( cpi ) ; if ( cm -> frame_type == KEY_FRAME ) rc -> frames_since_key = 0 ; if ( cm -> show_frame ) { rc -> frames_since_key ++ ; rc -> frames_to_key -- ; } }
V8InspectorSessionImpl :: V8InspectorSessionImpl ( V8InspectorImpl * inspector , int contextGroupId , int sessionId , V8Inspector :: Channel * channel , const StringView & savedState ) : m_contextGroupId ( contextGroupId ) , m_sessionId ( sessionId ) , m_inspector ( inspector ) , m_channel ( channel ) , m_customObjectFormatterEnabled ( false ) , m_dispatcher ( this ) , m_state ( nullptr ) , m_runtimeAgent ( nullptr ) , m_debuggerAgent ( nullptr ) , m_heapProfilerAgent ( nullptr ) , m_profilerAgent ( nullptr ) , m_consoleAgent ( nullptr ) , m_schemaAgent ( nullptr ) { if ( savedState . length ( ) ) { std :: unique_ptr < protocol :: Value > state = protocol :: StringUtil :: parseJSON ( toString16 ( savedState ) ) ; if ( state ) m_state = protocol :: DictionaryValue :: cast ( std :: move ( state ) ) ; if ( ! m_state ) m_state = protocol :: DictionaryValue :: create ( ) ; } else { m_state = protocol :: DictionaryValue :: create ( ) ; } m_runtimeAgent . reset ( new V8RuntimeAgentImpl ( this , this , agentState ( protocol :: Runtime :: Metainfo :: domainName ) ) ) ; protocol :: Runtime :: Dispatcher :: wire ( & m_dispatcher , m_runtimeAgent . get ( ) ) ; m_debuggerAgent . reset ( new V8DebuggerAgentImpl ( this , this , agentState ( protocol :: Debugger :: Metainfo :: domainName ) ) ) ; protocol :: Debugger :: Dispatcher :: wire ( & m_dispatcher , m_debuggerAgent . get ( ) ) ; m_profilerAgent . reset ( new V8ProfilerAgentImpl ( this , this , agentState ( protocol :: Profiler :: Metainfo :: domainName ) ) ) ; protocol :: Profiler :: Dispatcher :: wire ( & m_dispatcher , m_profilerAgent . get ( ) ) ; m_heapProfilerAgent . reset ( new V8HeapProfilerAgentImpl ( this , this , agentState ( protocol :: HeapProfiler :: Metainfo :: domainName ) ) ) ; protocol :: HeapProfiler :: Dispatcher :: wire ( & m_dispatcher , m_heapProfilerAgent . get ( ) ) ; m_consoleAgent . reset ( new V8ConsoleAgentImpl ( this , this , agentState ( protocol :: Console :: Metainfo :: domainName ) ) ) ; protocol :: Console :: Dispatcher :: wire ( & m_dispatcher , m_consoleAgent . get ( ) ) ; m_schemaAgent . reset ( new V8SchemaAgentImpl ( this , this , agentState ( protocol :: Schema :: Metainfo :: domainName ) ) ) ; protocol :: Schema :: Dispatcher :: wire ( & m_dispatcher , m_schemaAgent . get ( ) ) ; if ( savedState . length ( ) ) { m_runtimeAgent -> restore ( ) ; m_debuggerAgent -> restore ( ) ; m_heapProfilerAgent -> restore ( ) ; m_profilerAgent -> restore ( ) ; m_consoleAgent -> restore ( ) ; } }
static const char * parse_string ( cJSON * item , const char * str ) { const char * ptr = str + 1 ; char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; if ( * str != '\"' ) { ep = str ; return 0 ; } while ( * ptr != '\"' && * ptr && ++ len ) if ( * ptr ++ == '\\' ) ptr ++ ; if ( ! ( out = ( char * ) cJSON_malloc ( len + 1 ) ) ) return 0 ; ptr = str + 1 ; ptr2 = out ; while ( * ptr != '\"' && * ptr ) { if ( * ptr != '\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\b' ; break ; case 'f' : * ptr2 ++ = '\f' ; break ; case 'n' : * ptr2 ++ = '\n' ; break ; case 'r' : * ptr2 ++ = '\r' ; break ; case 't' : * ptr2 ++ = '\t' ; break ; case 'u' : sscanf ( ptr + 1 , "%4x" , & uc ) ; ptr += 4 ; if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) break ; if ( uc >= 0xD800 && uc <= 0xDBFF ) { if ( ptr [ 1 ] != '\\' || ptr [ 2 ] != 'u' ) break ; sscanf ( ptr + 3 , "%4x" , & uc2 ) ; ptr += 6 ; if ( uc2 < 0xDC00 || uc2 > 0xDFFF ) break ; uc = 0x10000 | ( ( uc & 0x3FF ) < < 10 ) | ( uc2 & 0x3FF ) ; } len = 4 ; if ( uc < 0x80 ) len = 1 ; else if ( uc < 0x800 ) len = 2 ; else if ( uc < 0x10000 ) len = 3 ; ptr2 += len ; switch ( len ) { case 4 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 3 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 2 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 1 : * -- ptr2 = ( uc | firstByteMark [ len ] ) ; } ptr2 += len ; break ; default : * ptr2 ++ = * ptr ; break ; } ++ ptr ; } } * ptr2 = 0 ; if ( * ptr == '\"' ) ++ ptr ; item -> valuestring = out ; item -> type = cJSON_String ; return ptr ; }
PresShell :: ContentInserted ( nsIDocument * aDocument , nsIContent * aContainer , nsIContent * aChild , PRInt32 aIndexInContainer ) { NS_PRECONDITION ( ! mIsDocumentGone , "Unexpected ContentInserted" ) ; NS_PRECONDITION ( aDocument == mDocument , "Unexpected aDocument" ) ; if ( ! mDidInitialReflow ) { return ; } nsAutoScriptBlocker scriptBlocker ; if ( aContainer ) mFrameConstructor -> RestyleForInsertOrChange ( aContainer , aChild ) ; mFrameConstructor -> ContentInserted ( aContainer , aChild , aIndexInContainer , nsnull ) ; VERIFY_STYLE_TREE ; }
TPMI_TDES_KEY_BITS_Unmarshal ( TPMI_SM4_KEY_BITS * target , BYTE * * buffer , INT32 * size ) { TPM_RC rc = TPM_RC_SUCCESS ; if ( rc == TPM_RC_SUCCESS ) { rc = TPM_KEY_BITS_Unmarshal ( target , buffer , size ) ; } if ( rc == TPM_RC_SUCCESS ) { switch ( * target ) { case 128 : case 192 : break ; default : rc = TPM_RC_VALUE ; } } return rc ; }
void ProfilerEventsProcessor :: AddCurrentStack ( Isolate * isolate , bool update_stats ) { TickSampleEventRecord record ( last_code_event_id_ ) ; RegisterState regs ; StackFrameIterator it ( isolate ) ; if ( ! it . done ( ) ) { StackFrame * frame = it . frame ( ) ; regs . sp = reinterpret_cast < void * > ( frame -> sp ( ) ) ; regs . fp = reinterpret_cast < void * > ( frame -> fp ( ) ) ; regs . pc = reinterpret_cast < void * > ( frame -> pc ( ) ) ; } record . sample . Init ( isolate , regs , TickSample :: kSkipCEntryFrame , update_stats , false ) ; ticks_from_vm_buffer_ . Enqueue ( record ) ; }
nsBMPEncoder :: ConvertHostARGBRow ( const PRUint8 * aSrc , PRUint8 * aDest , PRUint32 aPixelWidth ) { for ( PRUint32 x = 0 ; x < aPixelWidth ; x ++ ) { const PRUint32 & pixelIn = ( ( const PRUint32 * ) ( aSrc ) ) [ x ] ; PRUint8 * pixelOut = & aDest [ x * BytesPerPixel ( mBMPInfoHeader . bpp ) ] ; PRUint8 alpha = ( pixelIn & 0xff000000 ) > > 24 ; pixelOut [ 0 ] = ( ( ( pixelIn & 0xff0000 ) > > 16 ) ) ; pixelOut [ 1 ] = ( ( ( pixelIn & 0x00ff00 ) > > 8 ) ) ; pixelOut [ 2 ] = ( ( ( pixelIn & 0x0000ff ) > > 0 ) ) ; if ( mBMPInfoHeader . bpp == 32 ) { pixelOut [ 3 ] = alpha ; } } }
FLAC__StreamDecoderWriteStatus write_audio_frame_to_client_ ( FLAC__StreamDecoder * decoder , const FLAC__Frame * frame , const FLAC__int32 * const buffer [ ] ) { if ( decoder -> private_ -> is_seeking ) { FLAC__uint64 this_frame_sample = frame -> header . number . sample_number ; FLAC__uint64 next_frame_sample = this_frame_sample + ( FLAC__uint64 ) frame -> header . blocksize ; FLAC__uint64 target_sample = decoder -> private_ -> target_sample ; FLAC__ASSERT ( frame -> header . number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER ) ; #if FLAC__HAS_OGG decoder -> private_ -> got_a_frame = true ; #endif decoder -> private_ -> last_frame = * frame ; if ( this_frame_sample <= target_sample && target_sample < next_frame_sample ) { unsigned delta = ( unsigned ) ( target_sample - this_frame_sample ) ; decoder -> private_ -> is_seeking = false ; if ( delta > 0 ) { unsigned channel ; const FLAC__int32 * newbuffer [ FLAC__MAX_CHANNELS ] ; for ( channel = 0 ; channel < frame -> header . channels ; channel ++ ) newbuffer [ channel ] = buffer [ channel ] + delta ; decoder -> private_ -> last_frame . header . blocksize -= delta ; decoder -> private_ -> last_frame . header . number . sample_number += ( FLAC__uint64 ) delta ; return decoder -> private_ -> write_callback ( decoder , & decoder -> private_ -> last_frame , newbuffer , decoder -> private_ -> client_data ) ; } else { return decoder -> private_ -> write_callback ( decoder , frame , buffer , decoder -> private_ -> client_data ) ; } } else { return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ; } } else { if ( ! decoder -> private_ -> has_stream_info ) decoder -> private_ -> do_md5_checking = false ; #ifndef FLAC__NO_MD5 if ( decoder -> private_ -> do_md5_checking ) { if ( ! FLAC__MD5Accumulate ( & decoder -> private_ -> md5context , buffer , frame -> header . channels , frame -> header . blocksize , ( frame -> header . bits_per_sample + 7 ) / 8 ) ) return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT ; } #endif return decoder -> private_ -> write_callback ( decoder , frame , buffer , decoder -> private_ -> client_data ) ; } }
void WebAssemblyInstance ( const v8 :: FunctionCallbackInfo < v8 :: Value > & args ) { Isolate * isolate = args . GetIsolate ( ) ; i :: Isolate * i_isolate = reinterpret_cast < i :: Isolate * > ( isolate ) ; i_isolate -> CountUsage ( v8 :: Isolate :: UseCounterFeature :: kWebAssemblyInstantiation ) ; MicrotasksScope does_not_run_microtasks ( isolate , MicrotasksScope :: kDoNotRunMicrotasks ) ; HandleScope scope ( args . GetIsolate ( ) ) ; if ( i_isolate -> wasm_instance_callback ( ) ( args ) ) return ; ScheduledErrorThrower thrower ( i_isolate , "WebAssembly.Instance()" ) ; if ( ! args . IsConstructCall ( ) ) { thrower . TypeError ( "WebAssembly.Instance must be invoked with 'new'" ) ; return ; } GetFirstArgumentAsModule ( args , & thrower ) ; if ( thrower . error ( ) ) return ; Local < Value > data = args [ 1 ] ; Local < Value > instance ; if ( WebAssemblyInstantiateImpl ( isolate , args [ 0 ] , data ) . ToLocal ( & instance ) ) { args . GetReturnValue ( ) . Set ( instance ) ; } }
static void lsr_read_extend_class ( GF_LASeRCodec * lsr , char * * out_data , u32 * out_len , const char * name ) { u32 len ; GF_LSR_READ_INT ( lsr , len , lsr -> info -> cfg . extensionIDBits , "reserved" ) ; len = lsr_read_vluimsbf5 ( lsr , "len" ) ; gf_bs_read_long_int ( lsr -> bs , len ) ; if ( out_data ) * out_data = NULL ; if ( out_len ) * out_len = 0 ; }
PJ_DEF ( pj_status_t ) pjsip_ua_unregister_dlg ( pjsip_user_agent * ua , pjsip_dialog * dlg ) { struct dlg_set * dlg_set ; pjsip_dialog * d ; PJ_ASSERT_RETURN ( ua && dlg , PJ_EINVAL ) ; PJ_ASSERT_RETURN ( dlg -> dlg_set , PJ_EINVALIDOP ) ; pj_mutex_lock ( mod_ua . mutex ) ; dlg_set = ( struct dlg_set * ) dlg -> dlg_set ; d = dlg_set -> dlg_list . next ; while ( d != ( pjsip_dialog * ) & dlg_set -> dlg_list && d != dlg ) { d = d -> next ; } if ( d != dlg ) { pj_assert ( ! "Dialog is not registered!" ) ; pj_mutex_unlock ( mod_ua . mutex ) ; return PJ_EINVALIDOP ; } pj_list_erase ( dlg ) ; if ( pj_list_empty ( & dlg_set -> dlg_list ) ) { pj_hash_set_lower ( NULL , mod_ua . dlg_table , dlg -> local . info -> tag . ptr , ( unsigned ) dlg -> local . info -> tag . slen , dlg -> local . tag_hval , NULL ) ; pj_list_push_back ( & mod_ua . free_dlgset_nodes , dlg_set ) ; } pj_mutex_unlock ( mod_ua . mutex ) ; return PJ_SUCCESS ; }
TEST_P ( VP9WorkerThreadTest , HookFailure ) { EXPECT_NE ( vp9_worker_reset ( & worker_ ) , 0 ) ; int hook_data = 0 ; int return_value = 0 ; worker_ . hook = ThreadHook ; worker_ . data1 = & hook_data ; worker_ . data2 = & return_value ; const bool synchronous = GetParam ( ) ; if ( synchronous ) { vp9_worker_execute ( & worker_ ) ; } else { vp9_worker_launch ( & worker_ ) ; } EXPECT_FALSE ( vp9_worker_sync ( & worker_ ) ) ; EXPECT_EQ ( 1 , worker_ . had_error ) ; return_value = 1 ; EXPECT_NE ( vp9_worker_reset ( & worker_ ) , 0 ) ; EXPECT_FALSE ( worker_ . had_error ) ; vp9_worker_launch ( & worker_ ) ; EXPECT_NE ( vp9_worker_sync ( & worker_ ) , 0 ) ; EXPECT_FALSE ( worker_ . had_error ) ; }
do { MOZ_ASSERT ( ! shape -> isMarked ( js :: gc :: GRAY ) ) ; shape -> traceChildren ( & childTracer ) ; shape = childTracer . previousShape ; childTracer . previousShape = nullptr ; } while ( shape ) ; unmarkedAny |= childTracer . unmarkedAny ; } template < typename T > static bool TypedUnmarkGrayCellRecursively ( T * t ) { MOZ_ASSERT ( t ) ; JSRuntime * rt = t -> runtimeFromMainThread ( ) ; MOZ_ASSERT ( ! rt -> isHeapBusy ( ) ) ; bool unmarkedArg = false ; if ( t -> isTenured ( ) ) { if ( ! t -> asTenured ( ) . isMarked ( GRAY ) ) return false ;
Expression * Parser :: RewriteReturn ( Expression * return_value , int pos ) { if ( IsDerivedConstructor ( function_state_ -> kind ( ) ) ) { Variable * temp = NewTemporary ( ast_value_factory ( ) -> empty_string ( ) ) ; Assignment * assign = factory ( ) -> NewAssignment ( Token :: ASSIGN , factory ( ) -> NewVariableProxy ( temp ) , return_value , pos ) ; Expression * is_undefined = factory ( ) -> NewCompareOperation ( Token :: EQ_STRICT , assign , factory ( ) -> NewUndefinedLiteral ( kNoSourcePosition ) , pos ) ; return_value = factory ( ) -> NewConditional ( is_undefined , ThisExpression ( pos ) , factory ( ) -> NewVariableProxy ( temp ) , pos ) ; } return return_value ; }
nsXPConnect :: InitClasses ( JSContext * aJSContext , JSObject * aGlobalJSObj ) { NS_ASSERTION ( aJSContext , "bad param" ) ; NS_ASSERTION ( aGlobalJSObj , "bad param" ) ; SaveFrame sf ( aJSContext ) ; XPCCallContext ccx ( NATIVE_CALLER , aJSContext ) ; if ( ! ccx . IsValid ( ) ) return UnexpectedFailure ( NS_ERROR_FAILURE ) ; if ( ! xpc_InitJSxIDClassObjects ( ) ) return UnexpectedFailure ( NS_ERROR_FAILURE ) ; if ( ! xpc_InitWrappedNativeJSOps ( ) ) return UnexpectedFailure ( NS_ERROR_FAILURE ) ; XPCWrappedNativeScope * scope = XPCWrappedNativeScope :: GetNewOrUsed ( ccx , aGlobalJSObj ) ; if ( ! scope ) return UnexpectedFailure ( NS_ERROR_FAILURE ) ; scope -> RemoveWrappedNativeProtos ( ) ; if ( ! nsXPCComponents :: AttachNewComponentsObject ( ccx , scope , aGlobalJSObj ) ) return UnexpectedFailure ( NS_ERROR_FAILURE ) ; if ( ! XPCNativeWrapper :: AttachNewConstructorObject ( ccx , aGlobalJSObj ) ) return UnexpectedFailure ( NS_ERROR_FAILURE ) ; if ( ! XPC_SJOW_AttachNewConstructorObject ( ccx , aGlobalJSObj ) ) return UnexpectedFailure ( NS_ERROR_FAILURE ) ; return NS_OK ; }
GCRuntime :: sweepBackgroundThings ( ZoneList & zones , LifoAlloc & freeBlocks , ThreadType threadType ) { freeBlocks . freeAll ( ) ; if ( zones . isEmpty ( ) ) return ; ArenaHeader * emptyArenas = nullptr ; FreeOp fop ( rt , threadType ) ; for ( unsigned phase = 0 ; phase < ArrayLength ( BackgroundFinalizePhases ) ; ++ phase ) { for ( Zone * zone = zones . front ( ) ; zone ; zone = zone -> nextZone ( ) ) { AutoSetZoneBackgroundSweeping zbs ( zone ) ; for ( unsigned index = 0 ; index < BackgroundFinalizePhases [ phase ] . length ; ++ index ) { AllocKind kind = BackgroundFinalizePhases [ phase ] . kinds [ index ] ; ArenaHeader * arenas = zone -> arenas . arenaListsToSweep [ kind ] ; if ( arenas ) ArenaLists :: backgroundFinalize ( & fop , arenas , & emptyArenas ) ; } } } AutoLockGC lock ( rt ) ; ReleaseArenaList ( rt , emptyArenas , lock ) ; while ( ! zones . isEmpty ( ) ) zones . removeFront ( ) ; }
build_config ( char * prefix , struct server * server ) { char * path = NULL ; int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ; path = ss_malloc ( path_size ) ; snprintf ( path , path_size , "%s/.shadowsocks_%s.conf" , prefix , server -> port ) ; FILE * f = fopen ( path , "w+" ) ; if ( f == NULL ) { if ( verbose ) { LOGE ( "unable to open config file" ) ; } ss_free ( path ) ; return ; } fprintf ( f , "{\n" ) ; fprintf ( f , "\"server_port\":%d,\n" , atoi ( server -> port ) ) ; fprintf ( f , "\"password\":\"%s\"" , server -> password ) ; if ( server -> fast_open [ 0 ] ) fprintf ( f , ",\n\"fast_open\": %s" , server -> fast_open ) ; if ( server -> mode ) fprintf ( f , ",\n\"mode\":\"%s\"" , server -> mode ) ; if ( server -> method ) fprintf ( f , ",\n\"method\":\"%s\"" , server -> method ) ; if ( server -> plugin ) fprintf ( f , ",\n\"plugin\":\"%s\"" , server -> plugin ) ; if ( server -> plugin_opts ) fprintf ( f , ",\n\"plugin_opts\":\"%s\"" , server -> plugin_opts ) ; fprintf ( f , "\n}\n" ) ; fclose ( f ) ; ss_free ( path ) ; }
static PyObject * __pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_2read_into_buffer ( CYTHON_UNUSED struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader * __pyx_v_self ) { PyObject * __pyx_r = NULL ; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext ( "read_into_buffer" , 0 ) ; __Pyx_Raise ( __pyx_builtin_NotImplementedError , 0 , 0 , 0 ) ; __PYX_ERR ( 0 , 23 , __pyx_L1_error ) __pyx_L1_error : ; __Pyx_AddTraceback ( "clickhouse_driver.bufferedreader.BufferedReader.read_into_buffer" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __pyx_r = NULL ; __Pyx_XGIVEREF ( __pyx_r ) ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
void XMLHttpRequestMainThread :: SendInternal ( const BodyExtractorBase * aBody , bool aBodyIsDocumentOrString , ErrorResult & aRv ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; if ( ! mPrincipal ) { aRv . Throw ( NS_ERROR_NOT_INITIALIZED ) ; return ; } if ( mState != XMLHttpRequest_Binding :: OPENED ) { aRv . ThrowInvalidStateError ( "XMLHttpRequest state must be OPENED." ) ; return ; } if ( mFlagSend ) { aRv . ThrowInvalidStateError ( "XMLHttpRequest must not be sending." ) ; return ; } if ( NS_FAILED ( CheckCurrentGlobalCorrectness ( ) ) ) { aRv . Throw ( NS_ERROR_DOM_INVALID_STATE_XHR_HAS_INVALID_CONTEXT ) ; return ; } if ( ! mChannel ) { mFlagSend = true ; aRv = MaybeSilentSendFailure ( NS_ERROR_DOM_NETWORK_ERR ) ; return ; } if ( IsBlobURI ( mRequestURL ) && ! mRequestMethod . EqualsLiteral ( "GET" ) ) { mFlagSend = true ; aRv = MaybeSilentSendFailure ( NS_ERROR_DOM_NETWORK_ERR ) ; return ; } mUploadTransferred = 0 ; mUploadTotal = 0 ; mUploadComplete = true ; mErrorLoad = ErrorType :: eOK ; mLoadTotal = - 1 ; nsCOMPtr < nsIInputStream > uploadStream ; nsAutoCString uploadContentType ; nsCOMPtr < nsIHttpChannel > httpChannel ( do_QueryInterface ( mChannel ) ) ; if ( aBody && httpChannel && ! mRequestMethod . EqualsLiteral ( "GET" ) && ! mRequestMethod . EqualsLiteral ( "HEAD" ) ) { nsAutoCString charset ; nsAutoCString defaultContentType ; uint64_t size_u64 ; aRv = aBody -> GetAsStream ( getter_AddRefs ( uploadStream ) , & size_u64 , defaultContentType , charset ) ; if ( aRv . Failed ( ) ) { return ; } mUploadTotal = net :: InScriptableRange ( size_u64 ) ? static_cast < int64_t > ( size_u64 ) : - 1 ; if ( uploadStream ) { mAuthorRequestHeaders . Get ( "content-type" , uploadContentType ) ; if ( uploadContentType . IsVoid ( ) ) { uploadContentType = defaultContentType ; } else if ( aBodyIsDocumentOrString && StaticPrefs :: dom_xhr_standard_content_type_normalization ( ) ) { UniquePtr < CMimeType > contentTypeRecord = CMimeType :: Parse ( uploadContentType ) ; nsAutoCString charset ; if ( contentTypeRecord && contentTypeRecord -> GetParameterValue ( kLiteralString_charset , charset ) && ! charset . EqualsIgnoreCase ( "utf-8" ) ) { contentTypeRecord -> SetParameterValue ( kLiteralString_charset , kLiteralString_UTF_8 ) ; contentTypeRecord -> Serialize ( uploadContentType ) ; } } else if ( ! charset . IsEmpty ( ) ) { RequestHeaders :: CharsetIterator iter ( uploadContentType ) ; while ( iter . Next ( ) ) { if ( ! iter . Equals ( charset , nsCaseInsensitiveCStringComparator ) ) { iter . Replace ( charset ) ; } } } mUploadComplete = false ; } } ResetResponse ( ) ; if ( mUpload && mUpload -> HasListeners ( ) ) { mFlagHadUploadListenersOnSend = true ; } mIsMappedArrayBuffer = false ; if ( mResponseType == XMLHttpRequestResponseType :: Arraybuffer && StaticPrefs :: dom_mapped_arraybuffer_enabled ( ) ) { nsCOMPtr < nsIURI > uri ; nsAutoCString scheme ; aRv = mChannel -> GetURI ( getter_AddRefs ( uri ) ) ; if ( ! aRv . Failed ( ) ) { uri -> GetScheme ( scheme ) ; if ( scheme . LowerCaseEqualsLiteral ( "jar" ) ) { mIsMappedArrayBuffer = true ; } } } aRv = InitiateFetch ( uploadStream . forget ( ) , mUploadTotal , uploadContentType ) ; if ( aRv . Failed ( ) ) { return ; } mRequestSentTime = PR_Now ( ) ; StartTimeoutTimer ( ) ; mWaitingForOnStopRequest = true ; mFlagSend = true ; RefPtr < Document > suspendedDoc ; if ( mFlagSynchronous ) { auto scopeExit = MakeScopeExit ( [ & ] { CancelSyncTimeoutTimer ( ) ; ResumeTimeout ( ) ; ResumeEventDispatching ( ) ; } ) ; Maybe < AutoSuppressEventHandling > autoSuppress ; mFlagSyncLooping = true ; if ( GetOwner ( ) ) { if ( nsCOMPtr < nsPIDOMWindowOuter > topWindow = GetOwner ( ) -> GetOuterWindow ( ) -> GetInProcessTop ( ) ) { if ( nsCOMPtr < nsPIDOMWindowInner > topInner = topWindow -> GetCurrentInnerWindow ( ) ) { suspendedDoc = topWindow -> GetExtantDoc ( ) ; autoSuppress . emplace ( topWindow -> GetBrowsingContext ( ) ) ; topInner -> Suspend ( ) ; mResumeTimeoutRunnable = new nsResumeTimeoutsEvent ( topInner ) ; } } } SuspendEventDispatching ( ) ; StopProgressEventTimer ( ) ; SyncTimeoutType syncTimeoutType = MaybeStartSyncTimeoutTimer ( ) ; if ( syncTimeoutType == eErrorOrExpired ) { Abort ( ) ; aRv . Throw ( NS_ERROR_DOM_NETWORK_ERR ) ; return ; } nsAutoSyncOperation sync ( suspendedDoc , SyncOperationBehavior :: eSuspendInput ) ; if ( ! SpinEventLoopUntil ( "XMLHttpRequestMainThread::SendInternal"_ns , [ & ] ( ) { return ! mFlagSyncLooping ; } ) ) { aRv . Throw ( NS_ERROR_UNEXPECTED ) ; return ; } if ( syncTimeoutType == eTimerStarted && ! mSyncTimeoutTimer ) { aRv . Throw ( NS_ERROR_DOM_NETWORK_ERR ) ; return ; } } else { StopProgressEventTimer ( ) ; if ( mUpload && mUpload -> HasListenersFor ( nsGkAtoms :: onprogress ) ) { StartProgressEventTimer ( ) ; } DispatchProgressEvent ( this , ProgressEventType :: loadstart , 0 , - 1 ) ; if ( mUpload && ! mUploadComplete ) { DispatchProgressEvent ( mUpload , ProgressEventType :: loadstart , 0 , mUploadTotal ) ; } } if ( ! mChannel ) { aRv = MaybeSilentSendFailure ( NS_ERROR_DOM_NETWORK_ERR ) ; } }
void ArrayBuiltinsAssembler :: GenerateConstructor ( Node * context , Node * array_function , Node * array_map , Node * array_size , Node * allocation_site , ElementsKind elements_kind , AllocationSiteMode mode ) { Label ok ( this ) ; Label smi_size ( this ) ; Label small_smi_size ( this ) ; Label call_runtime ( this , Label :: kDeferred ) ; Branch ( TaggedIsSmi ( array_size ) , & smi_size , & call_runtime ) ; BIND ( & smi_size ) ; if ( IsFastPackedElementsKind ( elements_kind ) ) { Label abort ( this , Label :: kDeferred ) ; Branch ( SmiEqual ( CAST ( array_size ) , SmiConstant ( 0 ) ) , & small_smi_size , & abort ) ; BIND ( & abort ) ; Node * reason = SmiConstant ( AbortReason :: kAllocatingNonEmptyPackedArray ) ; TailCallRuntime ( Runtime :: kAbort , context , reason ) ; } else { int element_size = IsDoubleElementsKind ( elements_kind ) ? kDoubleSize : kPointerSize ; int max_fast_elements = ( kMaxRegularHeapObjectSize - FixedArray :: kHeaderSize - JSArray :: kSize - AllocationMemento :: kSize ) / element_size ; Branch ( SmiAboveOrEqual ( CAST ( array_size ) , SmiConstant ( max_fast_elements ) ) , & call_runtime , & small_smi_size ) ; } BIND ( & small_smi_size ) ; { Node * array = AllocateJSArray ( elements_kind , array_map , array_size , array_size , mode == DONT_TRACK_ALLOCATION_SITE ? nullptr : allocation_site , CodeStubAssembler :: SMI_PARAMETERS ) ; Return ( array ) ; } BIND ( & call_runtime ) ; { TailCallRuntime ( Runtime :: kNewArray , context , array_function , array_size , array_function , allocation_site ) ; } }
nsINode :: After ( const Sequence < OwningNodeOrString > & aNodes , ErrorResult & aRv ) { nsCOMPtr < nsINode > parent = GetParentNode ( ) ; if ( ! parent ) { return ; } nsINode * viableNextSibling = FindViableNextSibling ( * this , aNodes ) ; nsCOMPtr < nsINode > node = ConvertNodesOrStringsIntoNode ( aNodes , OwnerDoc ( ) , aRv ) ; if ( aRv . Failed ( ) ) { return ; } parent -> InsertBefore ( * node , viableNextSibling , aRv ) ; }
png_get_tRNS ( png_const_structrp png_ptr , png_inforp info_ptr , png_bytep * trans_alpha , int * num_trans , png_color_16p * trans_color ) { png_uint_32 retval = 0 ; if ( png_ptr != NULL && info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_tRNS ) ) { png_debug1 ( 1 , "in %s retrieval function" , "tRNS" ) ; if ( info_ptr -> color_type == PNG_COLOR_TYPE_PALETTE ) { if ( trans_alpha != NULL ) { * trans_alpha = info_ptr -> trans_alpha ; retval |= PNG_INFO_tRNS ; } if ( trans_color != NULL ) * trans_color = & ( info_ptr -> trans_color ) ; } else { if ( trans_color != NULL ) { * trans_color = & ( info_ptr -> trans_color ) ; retval |= PNG_INFO_tRNS ; } if ( trans_alpha != NULL ) * trans_alpha = NULL ; } if ( num_trans != NULL ) { * num_trans = info_ptr -> num_trans ; retval |= PNG_INFO_tRNS ; } } return ( retval ) ; }
nsHTMLContentSerializer :: AppendElementStart ( Element * aElement , Element * aOriginalElement , nsAString & aStr ) { NS_ENSURE_ARG ( aElement ) ; nsIContent * content = aElement ; PRBool forceFormat = PR_FALSE ; if ( ! CheckElementStart ( content , forceFormat , aStr ) ) { return NS_OK ; } nsIAtom * name = content -> Tag ( ) ; if ( ( mFlags & nsIDocumentEncoder :: OutputPreformatted ) && IsInvisibleBreak ( content , name ) ) { return NS_OK ; } PRBool lineBreakBeforeOpen = LineBreakBeforeOpen ( content -> GetNameSpaceID ( ) , name ) ; if ( ( mDoFormat || forceFormat ) && ! mPreLevel && ! mDoRaw ) { if ( mColPos && lineBreakBeforeOpen ) { AppendNewLineToString ( aStr ) ; } else { MaybeAddNewlineForRootNode ( aStr ) ; } if ( ! mColPos ) { AppendIndentation ( aStr ) ; } else if ( mAddSpace ) { AppendToString ( PRUnichar ( ' ' ) , aStr ) ; mAddSpace = PR_FALSE ; } } else if ( mAddSpace ) { AppendToString ( PRUnichar ( ' ' ) , aStr ) ; mAddSpace = PR_FALSE ; } else { MaybeAddNewlineForRootNode ( aStr ) ; } mAddNewlineForRootNode = PR_FALSE ; AppendToString ( kLessThan , aStr ) ; AppendToString ( nsDependentAtomString ( name ) , aStr ) ; MaybeEnterInPreContent ( content ) ; if ( ( mDoFormat || forceFormat ) && ! mPreLevel && ! mDoRaw ) IncrIndentation ( name ) ; if ( mIsCopying && name == nsGkAtoms :: ol ) { nsAutoString start ; PRInt32 startAttrVal = 0 ; aElement -> GetAttr ( kNameSpaceID_None , nsGkAtoms :: start , start ) ; if ( ! start . IsEmpty ( ) ) { PRInt32 rv = 0 ; startAttrVal = start . ToInteger ( & rv ) ; if ( NS_SUCCEEDED ( rv ) ) startAttrVal -- ; else startAttrVal = 0 ; } mOLStateStack . AppendElement ( olState ( startAttrVal , PR_TRUE ) ) ; } if ( mIsCopying && name == nsGkAtoms :: li ) { mIsFirstChildOfOL = IsFirstChildOfOL ( aOriginalElement ) ; if ( mIsFirstChildOfOL ) { SerializeLIValueAttribute ( aElement , aStr ) ; } } nsAutoString dummyPrefix ; SerializeHTMLAttributes ( content , aOriginalElement , dummyPrefix , EmptyString ( ) , name , aStr ) ; AppendToString ( kGreaterThan , aStr ) ; if ( name == nsGkAtoms :: script || name == nsGkAtoms :: style || name == nsGkAtoms :: noscript || name == nsGkAtoms :: noframes ) { ++ mDisableEntityEncoding ; } if ( ( mDoFormat || forceFormat ) && ! mPreLevel && ! mDoRaw && LineBreakAfterOpen ( content -> GetNameSpaceID ( ) , name ) ) { AppendNewLineToString ( aStr ) ; } AfterElementStart ( content , aOriginalElement , aStr ) ; return NS_OK ; }
void MarkCompactCollector :: EvacuatePagesInParallel ( ) { ItemParallelJob evacuation_job ( isolate ( ) -> cancelable_task_manager ( ) , & page_parallel_job_semaphore_ ) ; intptr_t live_bytes = 0 ; for ( Page * page : old_space_evacuation_pages_ ) { live_bytes += non_atomic_marking_state ( ) -> live_bytes ( page ) ; evacuation_job . AddItem ( new PageEvacuationItem ( page ) ) ; } for ( Page * page : new_space_evacuation_pages_ ) { intptr_t live_bytes_on_page = non_atomic_marking_state ( ) -> live_bytes ( page ) ; if ( live_bytes_on_page == 0 && ! page -> contains_array_buffers ( ) ) continue ; live_bytes += live_bytes_on_page ; if ( ShouldMovePage ( page , live_bytes_on_page ) ) { if ( page -> IsFlagSet ( MemoryChunk :: NEW_SPACE_BELOW_AGE_MARK ) ) { EvacuateNewSpacePageVisitor < NEW_TO_OLD > :: Move ( page ) ; DCHECK_EQ ( heap ( ) -> old_space ( ) , page -> owner ( ) ) ; heap ( ) -> old_space ( ) -> DecreaseAllocatedBytes ( page -> allocated_bytes ( ) , page ) ; } else { EvacuateNewSpacePageVisitor < NEW_TO_NEW > :: Move ( page ) ; } } evacuation_job . AddItem ( new PageEvacuationItem ( page ) ) ; } if ( evacuation_job . NumberOfItems ( ) == 0 ) return ; RecordMigratedSlotVisitor record_visitor ( this ) ; CreateAndExecuteEvacuationTasks < FullEvacuator > ( this , & evacuation_job , & record_visitor , nullptr , live_bytes ) ; PostProcessEvacuationCandidates ( ) ; }
~ AutoNewContext ( ) { if ( newcx ) { RootedValue exc ( oldcx ) ; bool throwing = JS_IsExceptionPending ( newcx ) ; if ( throwing ) JS_GetPendingException ( newcx , exc . address ( ) ) ; newRequest . destroy ( ) ; if ( throwing ) JS_SetPendingException ( oldcx , exc ) ; DestroyContext ( newcx , false ) ; } }
WebGLContext :: SynthesizeGLError ( WebGLenum err ) { if ( mWebGLError == LOCAL_GL_NO_ERROR ) { MakeContextCurrent ( ) ; mWebGLError = gl -> fGetError ( ) ; if ( mWebGLError == LOCAL_GL_NO_ERROR ) mWebGLError = err ; } return NS_OK ; }
pci_lintr_release ( struct pci_vdev * dev ) { struct businfo * bi ; struct slotinfo * si ; int pin ; bi = pci_businfo [ dev -> bus ] ; assert ( bi != NULL ) ; si = & bi -> slotinfo [ dev -> slot ] ; for ( pin = 1 ; pin < 4 ; pin ++ ) { si -> si_intpins [ pin ] . ii_count = 0 ; si -> si_intpins [ pin ] . ii_pirq_pin = 0 ; si -> si_intpins [ pin ] . ii_ioapic_irq = 0 ; } }
static void output_reset ( struct callback_data * p ) { if ( p -> outfile [ 0 ] == '|' ) { pclose ( p -> out ) ; } else { output_file_close ( p -> out ) ; } p -> outfile [ 0 ] = 0 ; p -> out = stdout ; }
MemOperand RegExpMacroAssemblerPPC :: register_location ( int register_index ) { DCHECK ( register_index < ( 1 < < 30 ) ) ; if ( num_registers_ <= register_index ) { num_registers_ = register_index + 1 ; } return MemOperand ( frame_pointer ( ) , kRegisterZero - register_index * kPointerSize ) ; }
FLAC__bool read_metadata_vorbiscomment_ ( FLAC__StreamDecoder * decoder , FLAC__StreamMetadata_VorbisComment * obj ) { FLAC__uint32 i ; FLAC__ASSERT ( FLAC__bitreader_is_consumed_byte_aligned ( decoder -> private_ -> input ) ) ; FLAC__ASSERT ( FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN == 32 ) ; if ( ! FLAC__bitreader_read_uint32_little_endian ( decoder -> private_ -> input , & obj -> vendor_string . length ) ) return false ; if ( obj -> vendor_string . length > 0 ) { if ( 0 == ( obj -> vendor_string . entry = ( FLAC__byte * ) safe_malloc_add_2op_ ( obj -> vendor_string . length , 1 ) ) ) { decoder -> protected_ -> state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR ; return false ; } if ( ! FLAC__bitreader_read_byte_block_aligned_no_crc ( decoder -> private_ -> input , obj -> vendor_string . entry , obj -> vendor_string . length ) ) return false ; obj -> vendor_string . entry [ obj -> vendor_string . length ] = '\0' ; } else obj -> vendor_string . entry = 0 ; FLAC__ASSERT ( FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN == 32 ) ; if ( ! FLAC__bitreader_read_uint32_little_endian ( decoder -> private_ -> input , & obj -> num_comments ) ) return false ; if ( obj -> num_comments > 0 ) { if ( 0 == ( obj -> comments = ( FLAC__StreamMetadata_VorbisComment_Entry * ) safe_malloc_mul_2op_ ( obj -> num_comments , sizeof ( FLAC__StreamMetadata_VorbisComment_Entry ) ) ) ) { decoder -> protected_ -> state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR ; return false ; } for ( i = 0 ; i < obj -> num_comments ; i ++ ) { FLAC__ASSERT ( FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN == 32 ) ; if ( ! FLAC__bitreader_read_uint32_little_endian ( decoder -> private_ -> input , & obj -> comments [ i ] . length ) ) return false ; if ( obj -> comments [ i ] . length > 0 ) { if ( 0 == ( obj -> comments [ i ] . entry = ( FLAC__byte * ) safe_malloc_add_2op_ ( obj -> comments [ i ] . length , 1 ) ) ) { decoder -> protected_ -> state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR ; return false ; } if ( ! FLAC__bitreader_read_byte_block_aligned_no_crc ( decoder -> private_ -> input , obj -> comments [ i ] . entry , obj -> comments [ i ] . length ) ) return false ; obj -> comments [ i ] . entry [ obj -> comments [ i ] . length ] = '\0' ; } else obj -> comments [ i ] . entry = 0 ; } } else { obj -> comments = 0 ; } return true ; }
void DebugCodegen :: GenerateFrameDropperTrampoline ( MacroAssembler * masm ) { __ mov ( fp , a1 ) ; __ lw ( a1 , MemOperand ( fp , JavaScriptFrameConstants :: kFunctionOffset ) ) ; __ LeaveFrame ( StackFrame :: INTERNAL ) ; __ lw ( a0 , FieldMemOperand ( a1 , JSFunction :: kSharedFunctionInfoOffset ) ) ; __ lhu ( a0 , FieldMemOperand ( a0 , SharedFunctionInfo :: kFormalParameterCountOffset ) ) ; __ mov ( a2 , a0 ) ; ParameterCount dummy1 ( a2 ) ; ParameterCount dummy2 ( a0 ) ; __ InvokeFunction ( a1 , dummy1 , dummy2 , JUMP_FUNCTION ) ; }
static int mcryptd_create_hash ( struct crypto_template * tmpl , struct rtattr * * tb , struct mcryptd_queue * queue ) { struct hashd_instance_ctx * ctx ; struct ahash_instance * inst ; struct hash_alg_common * halg ; struct crypto_alg * alg ; u32 type = 0 ; u32 mask = 0 ; int err ; mcryptd_check_internal ( tb , & type , & mask ) ; halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ; if ( IS_ERR ( halg ) ) return PTR_ERR ( halg ) ; alg = & halg -> base ; pr_debug ( "crypto: mcryptd hash alg: %s\n" , alg -> cra_name ) ; inst = mcryptd_alloc_instance ( alg , ahash_instance_headroom ( ) , sizeof ( * ctx ) ) ; err = PTR_ERR ( inst ) ; if ( IS_ERR ( inst ) ) goto out_put_alg ; ctx = ahash_instance_ctx ( inst ) ; ctx -> queue = queue ; err = crypto_init_ahash_spawn ( & ctx -> spawn , halg , ahash_crypto_instance ( inst ) ) ; if ( err ) goto out_free_inst ; type = CRYPTO_ALG_ASYNC ; if ( alg -> cra_flags & CRYPTO_ALG_INTERNAL ) type |= CRYPTO_ALG_INTERNAL ; inst -> alg . halg . base . cra_flags = type ; inst -> alg . halg . digestsize = halg -> digestsize ; inst -> alg . halg . statesize = halg -> statesize ; inst -> alg . halg . base . cra_ctxsize = sizeof ( struct mcryptd_hash_ctx ) ; inst -> alg . halg . base . cra_init = mcryptd_hash_init_tfm ; inst -> alg . halg . base . cra_exit = mcryptd_hash_exit_tfm ; inst -> alg . init = mcryptd_hash_init_enqueue ; inst -> alg . update = mcryptd_hash_update_enqueue ; inst -> alg . final = mcryptd_hash_final_enqueue ; inst -> alg . finup = mcryptd_hash_finup_enqueue ; inst -> alg . export = mcryptd_hash_export ; inst -> alg . import = mcryptd_hash_import ; inst -> alg . setkey = mcryptd_hash_setkey ; inst -> alg . digest = mcryptd_hash_digest_enqueue ; err = ahash_register_instance ( tmpl , inst ) ; if ( err ) { crypto_drop_ahash ( & ctx -> spawn ) ; out_free_inst : kfree ( inst ) ; } out_put_alg : crypto_mod_put ( alg ) ; return err ; }
void CalculateGlobalOffsets ( WasmModule * module ) { uint32_t offset = 0 ; uint32_t num_imported_mutable_globals = 0 ; if ( module -> globals . size ( ) == 0 ) { module -> globals_buffer_size = 0 ; return ; } for ( WasmGlobal & global : module -> globals ) { byte size = ValueTypes :: MemSize ( ValueTypes :: MachineTypeFor ( global . type ) ) ; if ( global . mutability && global . imported ) { DCHECK ( enabled_features_ . mut_global ) ; global . index = num_imported_mutable_globals ++ ; } else { offset = ( offset + size - 1 ) & ~ ( size - 1 ) ; global . offset = offset ; offset += size ; } } module -> globals_buffer_size = offset ; }
nsXPConnect :: VariantToJS ( JSContext * ctx , JSObject * scopeArg , nsIVariant * value , jsval * _retval ) { NS_PRECONDITION ( ctx , "bad param" ) ; NS_PRECONDITION ( scopeArg , "bad param" ) ; NS_PRECONDITION ( value , "bad param" ) ; NS_PRECONDITION ( _retval , "bad param" ) ; RootedObject scope ( ctx , scopeArg ) ; XPCCallContext ccx ( NATIVE_CALLER , ctx ) ; if ( ! ccx . IsValid ( ) ) return NS_ERROR_FAILURE ; XPCLazyCallContext lccx ( ccx ) ; ccx . SetScopeForNewJSObjects ( scope ) ; nsresult rv = NS_OK ; if ( ! XPCVariant :: VariantDataToJS ( lccx , value , & rv , _retval ) ) { if ( NS_FAILED ( rv ) ) return rv ; return NS_ERROR_FAILURE ; } return NS_OK ; }
static void opj_tcd_code_block_enc_deallocate ( opj_tcd_precinct_t * p_precinct ) { OPJ_UINT32 cblkno , l_nb_code_blocks ; opj_tcd_cblk_enc_t * l_code_block = p_precinct -> cblks . enc ; if ( l_code_block ) { l_nb_code_blocks = p_precinct -> block_size / sizeof ( opj_tcd_cblk_enc_t ) ; for ( cblkno = 0 ; cblkno < l_nb_code_blocks ; ++ cblkno ) { if ( l_code_block -> data ) { opj_free ( l_code_block -> data - 1 ) ; l_code_block -> data = 00 ; } if ( l_code_block -> layers ) { opj_free ( l_code_block -> layers ) ; l_code_block -> layers = 00 ; } if ( l_code_block -> passes ) { opj_free ( l_code_block -> passes ) ; l_code_block -> passes = 00 ; } ++ l_code_block ; } opj_free ( p_precinct -> cblks . enc ) ; p_precinct -> cblks . enc = 00 ; } }
static BOOLEAN flush_incoming_que_on_wr_signal_l ( l2cap_socket * sock ) { uint8_t * buf ; uint32_t len ; while ( packet_get_head_l ( sock , & buf , & len ) ) { int sent = send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ; if ( sent == ( signed ) len ) osi_free ( buf ) ; else if ( sent >= 0 ) { packet_put_head_l ( sock , buf + sent , len - sent ) ; osi_free ( buf ) ; if ( ! sent ) return TRUE ; } else { packet_put_head_l ( sock , buf , len ) ; osi_free ( buf ) ; return errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN ; } } return FALSE ; }
PopOffPrec ( SprintStack * ss , uint8_t prec , jsbytecode * * ppc = NULL ) { unsigned top ; const JSCodeSpec * topcs ; ptrdiff_t off ; if ( ppc ) * ppc = NULL ; top = ss -> top ; JS_ASSERT ( top != 0 ) ; if ( top == 0 ) return 0 ; ss -> top = -- top ; off = GetOff ( ss , top ) ; int op = ss -> opcodes [ top ] ; if ( op >= JSOP_LIMIT ) op = JSOP_NOP ; topcs = & js_CodeSpec [ op ] ; jsbytecode * pc = ss -> bytecodes [ top ] ; if ( ppc ) * ppc = pc ; if ( topcs -> prec != 0 && topcs -> prec < prec ) { ss -> offsets [ top ] = off - 2 ; ss -> sprinter . setOffset ( off - 2 ) ; off = Sprint ( & ss -> sprinter , "(%s)" , ss -> sprinter . stringAt ( off ) ) ; if ( ss -> printer -> decompiledOpcodes && pc ) ss -> printer -> decompiled ( pc ) . parenthesized = true ; } else { ss -> sprinter . setOffset ( off ) ; } return off ; }
void VPrintFToString ( std :: string & str , size_t str_offset , const char * format , va_list args ) { DCHECK_LE ( str_offset , str . size ( ) ) ; size_t len = str_offset + strlen ( format ) ; for ( ; ; len = base :: bits :: RoundUpToPowerOfTwo64 ( len + 1 ) ) { DCHECK_GE ( kMaxInt , len ) ; str . resize ( len ) ; va_list args_copy ; va_copy ( args_copy , args ) ; int written = VSNPrintF ( Vector < char > ( & str . front ( ) + str_offset , static_cast < int > ( len - str_offset ) ) , format , args_copy ) ; va_end ( args_copy ) ; if ( written < 0 ) continue ; str . resize ( str_offset + written ) ; return ; } }
void Builtins :: Generate_InterpreterPushArgsThenCallImpl ( MacroAssembler * masm , ConvertReceiverMode receiver_mode , InterpreterPushArgsMode mode ) { DCHECK ( mode != InterpreterPushArgsMode :: kArrayFunction ) ; Label stack_overflow ; __ addi ( r6 , r3 , Operand ( 1 ) ) ; Generate_StackOverflowCheck ( masm , r6 , ip , & stack_overflow ) ; if ( receiver_mode == ConvertReceiverMode :: kNullOrUndefined ) { __ PushRoot ( Heap :: kUndefinedValueRootIndex ) ; __ mr ( r6 , r3 ) ; } Generate_InterpreterPushArgs ( masm , r6 , r5 , r6 , r7 ) ; if ( mode == InterpreterPushArgsMode :: kWithFinalSpread ) { __ Pop ( r5 ) ; __ subi ( r3 , r3 , Operand ( 1 ) ) ; } if ( mode == InterpreterPushArgsMode :: kWithFinalSpread ) { __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , CallWithSpread ) , RelocInfo :: CODE_TARGET ) ; } else { __ Jump ( masm -> isolate ( ) -> builtins ( ) -> Call ( ConvertReceiverMode :: kAny ) , RelocInfo :: CODE_TARGET ) ; } __ bind ( & stack_overflow ) ; { __ TailCallRuntime ( Runtime :: kThrowStackOverflow ) ; __ bkpt ( 0 ) ; } }
AudioTrackEncoder :: InterleaveTrackData ( AudioChunk & aChunk , int32_t aDuration , uint32_t aOutputChannels , AudioDataValue * aOutput ) { switch ( aChunk . mBufferFormat ) { case AUDIO_FORMAT_S16 : { AutoTArray < const int16_t * , 2 > array ; array . SetLength ( aOutputChannels ) ; for ( uint32_t i = 0 ; i < array . Length ( ) ; i ++ ) { array [ i ] = static_cast < const int16_t * > ( aChunk . mChannelData [ i ] ) ; } InterleaveTrackData ( array , aDuration , aOutputChannels , aOutput , aChunk . mVolume ) ; break ; } case AUDIO_FORMAT_FLOAT32 : { AutoTArray < const float * , 2 > array ; array . SetLength ( aOutputChannels ) ; for ( uint32_t i = 0 ; i < array . Length ( ) ; i ++ ) { array [ i ] = static_cast < const float * > ( aChunk . mChannelData [ i ] ) ; } InterleaveTrackData ( array , aDuration , aOutputChannels , aOutput , aChunk . mVolume ) ; break ; } case AUDIO_FORMAT_SILENCE : { MOZ_ASSERT ( false , "To implement." ) ; } } ; }
IGNITION_HANDLER ( ToObject , InterpreterAssembler ) { Node * accumulator = GetAccumulator ( ) ; Node * context = GetContext ( ) ; Node * result = CallBuiltin ( Builtins :: kToObject , context , accumulator ) ; StoreRegisterAtOperandIndex ( result , 0 ) ; Dispatch ( ) ; }
void RegExpMacroAssemblerARM64 :: Backtrack ( ) { CheckPreemption ( ) ; Pop ( w10 ) ; __ Add ( x10 , code_pointer ( ) , Operand ( w10 , UXTW ) ) ; __ Br ( x10 ) ; }
key_ref_t key_create_or_update ( key_ref_t keyring_ref , const char * type , const char * description , const void * payload , size_t plen , key_perm_t perm , unsigned long flags ) { struct keyring_index_key index_key = { . description = description , } ; struct key_preparsed_payload prep ; struct assoc_array_edit * edit ; const struct cred * cred = current_cred ( ) ; struct key * keyring , * key = NULL ; key_ref_t key_ref ; int ret ; index_key . type = key_type_lookup ( type ) ; if ( IS_ERR ( index_key . type ) ) { key_ref = ERR_PTR ( - ENODEV ) ; goto error ; } key_ref = ERR_PTR ( - EINVAL ) ; if ( ! index_key . type -> match || ! index_key . type -> instantiate || ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ; keyring = key_ref_to_ptr ( keyring_ref ) ; key_check ( keyring ) ; key_ref = ERR_PTR ( - ENOTDIR ) ; if ( keyring -> type != & key_type_keyring ) goto error_put_type ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = index_key . type -> def_datalen ; prep . trusted = flags & KEY_ALLOC_TRUSTED ; prep . expiry = TIME_T_MAX ; if ( index_key . type -> preparse ) { ret = index_key . type -> preparse ( & prep ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_free_prep ; } if ( ! index_key . description ) index_key . description = prep . description ; key_ref = ERR_PTR ( - EINVAL ) ; if ( ! index_key . description ) goto error_free_prep ; } index_key . desc_len = strlen ( index_key . description ) ; key_ref = ERR_PTR ( - EPERM ) ; if ( ! prep . trusted && test_bit ( KEY_FLAG_TRUSTED_ONLY , & keyring -> flags ) ) goto error_free_prep ; flags |= prep . trusted ? KEY_ALLOC_TRUSTED : 0 ; ret = __key_link_begin ( keyring , & index_key , & edit ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_free_prep ; } ret = key_permission ( keyring_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_link_end ; } if ( index_key . type -> update ) { key_ref = find_key_to_update ( keyring_ref , & index_key ) ; if ( key_ref ) goto found_matching_key ; } if ( perm == KEY_PERM_UNDEF ) { perm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR ; perm |= KEY_USR_VIEW ; if ( index_key . type -> read ) perm |= KEY_POS_READ ; if ( index_key . type == & key_type_keyring || index_key . type -> update ) perm |= KEY_POS_WRITE ; } key = key_alloc ( index_key . type , index_key . description , cred -> fsuid , cred -> fsgid , cred , perm , flags ) ; if ( IS_ERR ( key ) ) { key_ref = ERR_CAST ( key ) ; goto error_link_end ; } ret = __key_instantiate_and_link ( key , & prep , keyring , NULL , & edit ) ; if ( ret < 0 ) { key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto error_link_end ; } key_ref = make_key_ref ( key , is_key_possessed ( keyring_ref ) ) ; error_link_end : __key_link_end ( keyring , & index_key , edit ) ; error_free_prep : if ( index_key . type -> preparse ) index_key . type -> free_preparse ( & prep ) ; error_put_type : key_type_put ( index_key . type ) ; error : return key_ref ; found_matching_key : __key_link_end ( keyring , & index_key , edit ) ; key_ref = __key_update ( key_ref , & prep ) ; goto error_free_prep ; }
const Operator * CommonOperatorBuilder :: Switch ( size_t control_output_count ) { return new ( zone ( ) ) Operator ( IrOpcode :: kSwitch , Operator :: kKontrol , "Switch" , 1 , 0 , 1 , 0 , 0 , control_output_count ) ; }
void Heap :: ReduceNewSpaceSize ( ) { static const size_t kLowAllocationThroughput = 1000 ; const double allocation_throughput = tracer ( ) -> CurrentAllocationThroughputInBytesPerMillisecond ( ) ; if ( FLAG_predictable ) return ; if ( ShouldReduceMemory ( ) || ( ( allocation_throughput != 0 ) && ( allocation_throughput < kLowAllocationThroughput ) ) ) { new_space_ -> Shrink ( ) ; UncommitFromSpace ( ) ; } }
void setattr_copy ( struct inode * inode , const struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; if ( ia_valid & ATTR_ATIME ) inode -> i_atime = timespec_trunc ( attr -> ia_atime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MTIME ) inode -> i_mtime = timespec_trunc ( attr -> ia_mtime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_CTIME ) inode -> i_ctime = timespec_trunc ( attr -> ia_ctime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MODE ) { umode_t mode = attr -> ia_mode ; if ( ! in_group_p ( inode -> i_gid ) && ! inode_capable ( inode , CAP_FSETID ) ) mode &= ~ S_ISGID ; inode -> i_mode = mode ; } }
Block * Parser :: BuildRejectPromiseOnException ( Block * inner_block ) { Block * result = factory ( ) -> NewBlock ( 2 , true ) ; Statement * set_promise ; { Expression * create_promise = factory ( ) -> NewCallRuntime ( Context :: ASYNC_FUNCTION_PROMISE_CREATE_INDEX , new ( zone ( ) ) ZonePtrList < Expression > ( 0 , zone ( ) ) , kNoSourcePosition ) ; Assignment * assign_promise = factory ( ) -> NewAssignment ( Token :: ASSIGN , factory ( ) -> NewVariableProxy ( PromiseVariable ( ) ) , create_promise , kNoSourcePosition ) ; set_promise = factory ( ) -> NewExpressionStatement ( assign_promise , kNoSourcePosition ) ; } result -> statements ( ) -> Add ( set_promise , zone ( ) ) ; Scope * catch_scope = NewHiddenCatchScope ( ) ; Expression * promise_reject = BuildRejectPromise ( factory ( ) -> NewVariableProxy ( catch_scope -> catch_variable ( ) ) , kNoSourcePosition ) ; Block * catch_block = IgnoreCompletion ( factory ( ) -> NewReturnStatement ( promise_reject , kNoSourcePosition ) ) ; TryStatement * try_catch_statement = factory ( ) -> NewTryCatchStatementForAsyncAwait ( inner_block , catch_scope , catch_block , kNoSourcePosition ) ; Block * outer_try_block = IgnoreCompletion ( try_catch_statement ) ; Block * finally_block ; { ZonePtrList < Expression > * args = new ( zone ( ) ) ZonePtrList < Expression > ( 1 , zone ( ) ) ; args -> Add ( factory ( ) -> NewVariableProxy ( PromiseVariable ( ) ) , zone ( ) ) ; args -> Add ( factory ( ) -> NewBooleanLiteral ( function_state_ -> CanSuspend ( ) , kNoSourcePosition ) , zone ( ) ) ; Expression * call_promise_release = factory ( ) -> NewCallRuntime ( Context :: ASYNC_FUNCTION_PROMISE_RELEASE_INDEX , args , kNoSourcePosition ) ; Statement * promise_release = factory ( ) -> NewExpressionStatement ( call_promise_release , kNoSourcePosition ) ; finally_block = IgnoreCompletion ( promise_release ) ; } Statement * try_finally_statement = factory ( ) -> NewTryFinallyStatement ( outer_try_block , finally_block , kNoSourcePosition ) ; result -> statements ( ) -> Add ( try_finally_statement , zone ( ) ) ; return result ; }
UACHelper :: DisableUnneededPrivileges ( HANDLE token , LPCTSTR * unneededPrivs , size_t count ) { HANDLE obtainedToken = nullptr ; if ( ! token ) { HANDLE process = GetCurrentProcess ( ) ; if ( ! OpenProcessToken ( process , TOKEN_ALL_ACCESS_P , & obtainedToken ) ) { LOG_WARN ( ( "Could not obtain token for current process, no " "privileges changed. (%d)" , GetLastError ( ) ) ) ; return FALSE ; } token = obtainedToken ; } BOOL result = TRUE ; for ( size_t i = 0 ; i < count ; i ++ ) { if ( SetPrivilege ( token , unneededPrivs [ i ] , FALSE ) ) { LOG ( ( "Disabled unneeded token privilege: %s." , unneededPrivs [ i ] ) ) ; } else { LOG ( ( "Could not disable token privilege value: %s. (%d)" , unneededPrivs [ i ] , GetLastError ( ) ) ) ; result = FALSE ; } } if ( obtainedToken ) { CloseHandle ( obtainedToken ) ; } return result ; }
bool LazyStubTier :: createOneEntryStub ( uint32_t funcExportIndex , const CodeTier & codeTier ) { Uint32Vector funcExportIndexes ; if ( ! funcExportIndexes . append ( funcExportIndex ) ) { return false ; } bool flushAllThreadIcaches = false ; size_t stubSegmentIndex ; if ( ! createManyEntryStubs ( funcExportIndexes , codeTier , flushAllThreadIcaches , & stubSegmentIndex ) ) { return false ; } const UniqueLazyStubSegment & segment = stubSegments_ [ stubSegmentIndex ] ; const CodeRangeVector & codeRanges = segment -> codeRanges ( ) ; if ( ! codeTier . metadata ( ) . funcExports [ funcExportIndex ] . canHaveJitEntry ( ) ) { MOZ_ASSERT ( codeRanges . length ( ) >= 1 ) ; MOZ_ASSERT ( codeRanges . back ( ) . isInterpEntry ( ) ) ; return true ; } MOZ_ASSERT ( codeRanges . length ( ) >= 2 ) ; MOZ_ASSERT ( codeRanges [ codeRanges . length ( ) - 2 ] . isInterpEntry ( ) ) ; const CodeRange & cr = codeRanges [ codeRanges . length ( ) - 1 ] ; MOZ_ASSERT ( cr . isJitEntry ( ) ) ; codeTier . code ( ) . setJitEntry ( cr . funcIndex ( ) , segment -> base ( ) + cr . begin ( ) ) ; return true ; }
void __split_huge_pmd ( struct vm_area_struct * vma , pmd_t * pmd , unsigned long address , bool freeze , struct page * page ) { spinlock_t * ptl ; struct mmu_notifier_range range ; mmu_notifier_range_init ( & range , MMU_NOTIFY_CLEAR , 0 , vma , vma -> vm_mm , address & HPAGE_PMD_MASK , ( address & HPAGE_PMD_MASK ) + HPAGE_PMD_SIZE ) ; mmu_notifier_invalidate_range_start ( & range ) ; ptl = pmd_lock ( vma -> vm_mm , pmd ) ; VM_BUG_ON ( freeze && ! page ) ; if ( page && page != pmd_page ( * pmd ) ) goto out ; if ( pmd_trans_huge ( * pmd ) ) { page = pmd_page ( * pmd ) ; if ( PageMlocked ( page ) ) clear_page_mlock ( page ) ; } else if ( ! ( pmd_devmap ( * pmd ) || is_pmd_migration_entry ( * pmd ) ) ) goto out ; __split_huge_pmd_locked ( vma , pmd , range . start , freeze ) ; out : spin_unlock ( ptl ) ; mmu_notifier_invalidate_range_only_end ( & range ) ; }
static void parse_relocation_info ( struct MACH0_ ( obj_t ) * bin , RSkipList * relocs , ut32 offset , ut32 num ) { if ( ! num || ! offset || ( st32 ) num < 0 ) { return ; } ut64 total_size = num * sizeof ( struct relocation_info ) ; if ( offset > bin -> size ) { return ; } if ( total_size > bin -> size ) { total_size = bin -> size - offset ; num = total_size /= sizeof ( struct relocation_info ) ; } struct relocation_info * info = calloc ( num , sizeof ( struct relocation_info ) ) ; if ( ! info ) { return ; } if ( r_buf_read_at ( bin -> b , offset , ( ut8 * ) info , total_size ) < total_size ) { free ( info ) ; return ; } size_t i ; for ( i = 0 ; i < num ; i ++ ) { struct relocation_info a_info = info [ i ] ; ut32 sym_num = a_info . r_symbolnum ; if ( sym_num > bin -> nsymtab ) { continue ; } ut32 stridx = bin -> symtab [ sym_num ] . n_strx ; char * sym_name = get_name ( bin , stridx , false ) ; if ( ! sym_name ) { continue ; } struct reloc_t * reloc = R_NEW0 ( struct reloc_t ) ; if ( ! reloc ) { free ( info ) ; free ( sym_name ) ; return ; } reloc -> addr = offset_to_vaddr ( bin , a_info . r_address ) ; reloc -> offset = a_info . r_address ; reloc -> ord = sym_num ; reloc -> type = a_info . r_type ; reloc -> external = a_info . r_extern ; reloc -> pc_relative = a_info . r_pcrel ; reloc -> size = a_info . r_length ; r_str_ncpy ( reloc -> name , sym_name , sizeof ( reloc -> name ) - 1 ) ; r_skiplist_insert ( relocs , reloc ) ; free ( sym_name ) ; } free ( info ) ; }
nsXBLProtoImplMethod :: InstallMember ( nsIScriptContext * aContext , nsIContent * aBoundElement , JSObject * aScriptObject , JSObject * aTargetClassObject , const nsCString & aClassStr ) { NS_PRECONDITION ( IsCompiled ( ) , "Should not be installing an uncompiled method" ) ; JSContext * cx = aContext -> GetNativeContext ( ) ; nsIScriptGlobalObject * sgo = aBoundElement -> OwnerDoc ( ) -> GetScopeObject ( ) ; if ( ! sgo ) { return NS_ERROR_UNEXPECTED ; } NS_ASSERTION ( aScriptObject , "uh-oh, script Object should NOT be null or bad things will happen" ) ; if ( ! aScriptObject ) return NS_ERROR_FAILURE ; JSObject * globalObject = sgo -> GetGlobalJSObject ( ) ; if ( mJSMethodObject ) { nsDependentString name ( mName ) ; JSAutoRequest ar ( cx ) ; JSAutoCompartment ac ( cx , globalObject ) ; JSObject * method = :: JS_CloneFunctionObject ( cx , mJSMethodObject , globalObject ) ; if ( ! method ) { return NS_ERROR_OUT_OF_MEMORY ; } if ( ! :: JS_DefineUCProperty ( cx , aTargetClassObject , static_cast < const jschar * > ( mName ) , name . Length ( ) , OBJECT_TO_JSVAL ( method ) , NULL , NULL , JSPROP_ENUMERATE ) ) { return NS_ERROR_OUT_OF_MEMORY ; } } return NS_OK ; }
int udp_sendmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct udp_sock * up = udp_sk ( sk ) ; struct flowi4 * fl4 ; int ulen = len ; struct ipcm_cookie ipc ; struct rtable * rt = NULL ; int free = 0 ; int connected = 0 ; __be32 daddr , faddr , saddr ; __be16 dport ; u8 tos ; int err , is_udplite = IS_UDPLITE ( sk ) ; int corkreq = up -> corkflag || msg -> msg_flags & MSG_MORE ; int ( * getfrag ) ( void * , char * , int , int , int , struct sk_buff * ) ; struct sk_buff * skb ; if ( len > 0xFFFF ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; ipc . opt = NULL ; ipc . tx_flags = 0 ; getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag ; if ( up -> pending ) { lock_sock ( sk ) ; if ( likely ( up -> pending ) ) { if ( unlikely ( up -> pending != AF_INET ) ) { release_sock ( sk ) ; return - EINVAL ; } goto do_append_data ; } release_sock ( sk ) ; } ulen += sizeof ( struct udphdr ) ; if ( msg -> msg_name ) { struct sockaddr_in * usin = ( struct sockaddr_in * ) msg -> msg_name ; if ( msg -> msg_namelen < sizeof ( * usin ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) { if ( usin -> sin_family != AF_UNSPEC ) return - EAFNOSUPPORT ; } daddr = usin -> sin_addr . s_addr ; dport = usin -> sin_port ; if ( dport == 0 ) return - EINVAL ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = inet -> inet_daddr ; dport = inet -> inet_dport ; connected = 1 ; } ipc . addr = inet -> inet_saddr ; ipc . oif = sk -> sk_bound_dev_if ; err = sock_tx_timestamp ( sk , & ipc . tx_flags ) ; if ( err ) return err ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sock_net ( sk ) , msg , & ipc ) ; if ( err ) return err ; if ( ipc . opt ) free = 1 ; connected = 0 ; } if ( ! ipc . opt ) ipc . opt = inet -> opt ; saddr = ipc . addr ; ipc . addr = faddr = daddr ; if ( ipc . opt && ipc . opt -> srr ) { if ( ! daddr ) return - EINVAL ; faddr = ipc . opt -> faddr ; connected = 0 ; } tos = RT_TOS ( inet -> tos ) ; if ( sock_flag ( sk , SOCK_LOCALROUTE ) || ( msg -> msg_flags & MSG_DONTROUTE ) || ( ipc . opt && ipc . opt -> is_strictroute ) ) { tos |= RTO_ONLINK ; connected = 0 ; } if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; connected = 0 ; } if ( connected ) rt = ( struct rtable * ) sk_dst_check ( sk , 0 ) ; if ( rt == NULL ) { struct flowi4 fl4 ; struct net * net = sock_net ( sk ) ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , sk -> sk_protocol , inet_sk_flowi_flags ( sk ) | FLOWI_FLAG_CAN_SLEEP , faddr , saddr , dport , inet -> inet_sport ) ; security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; if ( err == - ENETUNREACH ) IP_INC_STATS_BH ( net , IPSTATS_MIB_OUTNOROUTES ) ; goto out ; } err = - EACCES ; if ( ( rt -> rt_flags & RTCF_BROADCAST ) && ! sock_flag ( sk , SOCK_BROADCAST ) ) goto out ; if ( connected ) sk_dst_set ( sk , dst_clone ( & rt -> dst ) ) ; } if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : saddr = rt -> rt_src ; if ( ! ipc . addr ) daddr = ipc . addr = rt -> rt_dst ; if ( ! corkreq ) { skb = ip_make_skb ( sk , getfrag , msg -> msg_iov , ulen , sizeof ( struct udphdr ) , & ipc , & rt , msg -> msg_flags ) ; err = PTR_ERR ( skb ) ; if ( skb && ! IS_ERR ( skb ) ) err = udp_send_skb ( skb , daddr , dport ) ; goto out ; } lock_sock ( sk ) ; if ( unlikely ( up -> pending ) ) { release_sock ( sk ) ; LIMIT_NETDEBUG ( KERN_DEBUG "udp cork app bug 2\n" ) ; err = - EINVAL ; goto out ; } fl4 = & inet -> cork . fl . u . ip4 ; fl4 -> daddr = daddr ; fl4 -> saddr = saddr ; fl4 -> fl4_dport = dport ; fl4 -> fl4_sport = inet -> inet_sport ; up -> pending = AF_INET ; do_append_data : up -> len += ulen ; err = ip_append_data ( sk , getfrag , msg -> msg_iov , ulen , sizeof ( struct udphdr ) , & ipc , & rt , corkreq ? msg -> msg_flags | MSG_MORE : msg -> msg_flags ) ; if ( err ) udp_flush_pending_frames ( sk ) ; else if ( ! corkreq ) err = udp_push_pending_frames ( sk ) ; else if ( unlikely ( skb_queue_empty ( & sk -> sk_write_queue ) ) ) up -> pending = 0 ; release_sock ( sk ) ; out : ip_rt_put ( rt ) ; if ( free ) kfree ( ipc . opt ) ; if ( ! err ) return len ; if ( err == - ENOBUFS || test_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ) ; } return err ; do_confirm : dst_confirm ( & rt -> dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto out ; }
static int update_mv ( vp9_writer * w , const unsigned int ct [ 2 ] , vp9_prob * cur_p , vp9_prob upd_p ) { const vp9_prob new_p = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) | 1 ; const int update = cost_branch256 ( ct , * cur_p ) + vp9_cost_zero ( upd_p ) > cost_branch256 ( ct , new_p ) + vp9_cost_one ( upd_p ) + 7 * 256 ; vp9_write ( w , update , upd_p ) ; if ( update ) { * cur_p = new_p ; vp9_write_literal ( w , new_p > > 1 , 7 ) ; } return update ; }
MacroAssemblerARM :: ma_mod_mask ( Register src , Register dest , Register hold , int32_t shift ) { int32_t mask = ( 1 < < shift ) - 1 ; Label head ; as_mov ( ScratchRegister , O2Reg ( src ) , SetCond ) ; ma_mov ( Imm32 ( 0 ) , dest ) ; ma_mov ( Imm32 ( 1 ) , hold ) ; ma_mov ( Imm32 ( - 1 ) , hold , NoSetCond , Signed ) ; ma_rsb ( Imm32 ( 0 ) , ScratchRegister , SetCond , Signed ) ; bind ( & head ) ; ma_and ( Imm32 ( mask ) , ScratchRegister , secondScratchReg_ ) ; ma_add ( secondScratchReg_ , dest , dest ) ; ma_sub ( dest , Imm32 ( mask ) , secondScratchReg_ , SetCond ) ; ma_mov ( secondScratchReg_ , dest , NoSetCond , NotSigned ) ; as_mov ( ScratchRegister , lsr ( ScratchRegister , shift ) , SetCond ) ; ma_b ( & head , NonZero ) ; ma_cmp ( hold , Imm32 ( 0 ) ) ; ma_rsb ( Imm32 ( 0 ) , dest , SetCond , Signed ) ; }
nsSMILTimeContainer :: NotifyTimeChange ( ) { const MilestoneEntry * p = mMilestoneEntries . Elements ( ) ; #if DEBUG uint32_t queueLength = mMilestoneEntries . Length ( ) ; #endif while ( p < mMilestoneEntries . Elements ( ) + mMilestoneEntries . Length ( ) ) { mozilla :: dom :: SVGAnimationElement * elem = p -> mTimebase . get ( ) ; elem -> TimedElement ( ) . HandleContainerTimeChange ( ) ; MOZ_ASSERT ( queueLength == mMilestoneEntries . Length ( ) , "Call to HandleContainerTimeChange resulted in a change to the " "queue of milestones" ) ; ++ p ; } }
void nsCSSValue :: SetPercentValue ( float aValue ) { Reset ( ) ; mUnit = eCSSUnit_Percent ; mValue . mFloat = aValue ; }
void MarkingVerifier :: VerifyMarkingOnPage ( const Page * page , Address start , Address end ) { HeapObject * object ; Address next_object_must_be_here_or_later = start ; for ( Address current = start ; current < end ; ) { object = HeapObject :: FromAddress ( current ) ; if ( IsBlackOrGrey ( object ) && object -> map ( ) != ReadOnlyRoots ( heap_ ) . one_pointer_filler_map ( ) ) { CHECK ( IsMarked ( object ) ) ; CHECK ( current >= next_object_must_be_here_or_later ) ; object -> Iterate ( this ) ; next_object_must_be_here_or_later = current + object -> Size ( ) ; CHECK ( bitmap ( page ) -> AllBitsSetInRange ( page -> AddressToMarkbitIndex ( current ) , page -> AddressToMarkbitIndex ( next_object_must_be_here_or_later ) ) || bitmap ( page ) -> AllBitsClearInRange ( page -> AddressToMarkbitIndex ( current + kPointerSize * 2 ) , page -> AddressToMarkbitIndex ( next_object_must_be_here_or_later ) ) ) ; current = next_object_must_be_here_or_later ; } else { current += kPointerSize ; } } }
static void getCoverageFormat14 ( std :: vector < std :: unique_ptr < SparseBitSet > > * out , const uint8_t * data , size_t size , const SparseBitSet & baseCoverage ) { constexpr size_t kHeaderSize = 10 ; constexpr size_t kRecordSize = 11 ; constexpr size_t kLengthOffset = 2 ; constexpr size_t kNumRecordOffset = 6 ; out -> clear ( ) ; if ( size < kHeaderSize ) { return ; } const uint32_t length = readU32 ( data , kLengthOffset ) ; if ( size < length ) { return ; } uint32_t numRecords = readU32 ( data , kNumRecordOffset ) ; if ( numRecords == 0 || kHeaderSize + kRecordSize * numRecords > length ) { return ; } for ( uint32_t i = 0 ; i < numRecords ; ++ i ) { const uint32_t recordHeadOffset = kHeaderSize + kRecordSize * ( numRecords - i - 1 ) ; const uint32_t vsCodePoint = readU24 ( data , recordHeadOffset ) ; const uint32_t defaultUVSOffset = readU32 ( data , recordHeadOffset + 3 ) ; const uint32_t nonDefaultUVSOffset = readU32 ( data , recordHeadOffset + 7 ) ; if ( defaultUVSOffset > length || nonDefaultUVSOffset > length ) { continue ; } const uint16_t vsIndex = getVsIndex ( vsCodePoint ) ; if ( vsIndex == INVALID_VS_INDEX ) { continue ; } std :: vector < uint32_t > ranges ; if ( ! getVSCoverage ( & ranges , data , length , defaultUVSOffset , nonDefaultUVSOffset , baseCoverage ) ) { continue ; } if ( out -> size ( ) < vsIndex + 1 ) { out -> resize ( vsIndex + 1 ) ; } ( * out ) [ vsIndex ] . reset ( new SparseBitSet ( ranges . data ( ) , ranges . size ( ) > > 1 ) ) ; } out -> shrink_to_fit ( ) ; }
nsListControlFrame :: AboutToDropDown ( ) { NS_ASSERTION ( IsInDropDownMode ( ) , "AboutToDropDown called without being in dropdown mode" ) ; nsIFrame * comboboxFrame = do_QueryFrame ( mComboboxFrame ) ; nsStyleContext * context = comboboxFrame -> StyleContext ( ) -> GetParent ( ) ; mLastDropdownBackstopColor = NS_RGBA ( 0 , 0 , 0 , 0 ) ; while ( NS_GET_A ( mLastDropdownBackstopColor ) < 255 && context ) { mLastDropdownBackstopColor = NS_ComposeColors ( context -> StyleBackground ( ) -> mBackgroundColor , mLastDropdownBackstopColor ) ; context = context -> GetParent ( ) ; } mLastDropdownBackstopColor = NS_ComposeColors ( PresContext ( ) -> DefaultBackgroundColor ( ) , mLastDropdownBackstopColor ) ; if ( mIsAllContentHere && mIsAllFramesHere && mHasBeenInitialized ) { ScrollToIndex ( GetSelectedIndex ( ) ) ; #ifdef ACCESSIBILITY FireMenuItemActiveEvent ( ) ; #endif } mItemSelectionStarted = false ; }
status_t SampleTable :: setTimeToSampleParams ( off64_t data_offset , size_t data_size ) { if ( mTimeToSample != NULL || data_size < 8 ) { return ERROR_MALFORMED ; } uint8_t header [ 8 ] ; if ( mDataSource -> readAt ( data_offset , header , sizeof ( header ) ) < ( ssize_t ) sizeof ( header ) ) { return ERROR_IO ; } if ( U32_AT ( header ) != 0 ) { return ERROR_MALFORMED ; } mTimeToSampleCount = U32_AT ( & header [ 4 ] ) ; uint64_t allocSize = mTimeToSampleCount * 2 * sizeof ( uint32_t ) ; if ( allocSize > SIZE_MAX ) { return ERROR_OUT_OF_RANGE ; } mTimeToSample = new uint32_t [ mTimeToSampleCount * 2 ] ; size_t size = sizeof ( uint32_t ) * mTimeToSampleCount * 2 ; if ( mDataSource -> readAt ( data_offset + 8 , mTimeToSample , size ) < ( ssize_t ) size ) { return ERROR_IO ; } for ( uint32_t i = 0 ; i < mTimeToSampleCount * 2 ; ++ i ) { mTimeToSample [ i ] = ntohl ( mTimeToSample [ i ] ) ; } return OK ; }
bool Scanner :: ScanOctalDigits ( ) { if ( allow_harmony_numeric_separator ( ) ) { return ScanDigitsWithNumericSeparators ( & IsOctalDigit , true ) ; } if ( ! IsOctalDigit ( c0_ ) ) { return false ; } while ( IsOctalDigit ( c0_ ) ) { AddLiteralCharAdvance ( ) ; } return true ; }
static void read_intra_block_mode_info ( VP9_COMMON * const cm , MODE_INFO * mi , vp9_reader * r ) { MB_MODE_INFO * const mbmi = & mi -> mbmi ; const BLOCK_SIZE bsize = mi -> mbmi . sb_type ; int i ; mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; mbmi -> ref_frame [ 1 ] = NONE ; switch ( bsize ) { case BLOCK_4X4 : for ( i = 0 ; i < 4 ; ++ i ) mi -> bmi [ i ] . as_mode = read_intra_mode_y ( cm , r , 0 ) ; mbmi -> mode = mi -> bmi [ 3 ] . as_mode ; break ; case BLOCK_4X8 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 2 ] . as_mode = read_intra_mode_y ( cm , r , 0 ) ; mi -> bmi [ 1 ] . as_mode = mi -> bmi [ 3 ] . as_mode = mbmi -> mode = read_intra_mode_y ( cm , r , 0 ) ; break ; case BLOCK_8X4 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 1 ] . as_mode = read_intra_mode_y ( cm , r , 0 ) ; mi -> bmi [ 2 ] . as_mode = mi -> bmi [ 3 ] . as_mode = mbmi -> mode = read_intra_mode_y ( cm , r , 0 ) ; break ; default : mbmi -> mode = read_intra_mode_y ( cm , r , size_group_lookup [ bsize ] ) ; } mbmi -> uv_mode = read_intra_mode_uv ( cm , r , mbmi -> mode ) ; }
BUILTIN ( ArrayBufferConstructor_DoNotInitialize ) { HandleScope scope ( isolate ) ; Handle < JSFunction > target ( isolate -> native_context ( ) -> array_buffer_fun ( ) , isolate ) ; Handle < Object > length = args . atOrUndefined ( isolate , 1 ) ; return ConstructBuffer ( isolate , target , target , length , false ) ; }
explicit SharedFunctionInfoFinder ( int target_position ) : current_candidate_ ( nullptr ) , current_candidate_closure_ ( nullptr ) , current_start_position_ ( kNoSourcePosition ) , target_position_ ( target_position ) { }
static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; struct resv_map * reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma ( vma ) ; unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ; kref_put ( & reservations -> refs , resv_map_release ) ; if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; hugepage_subpool_put_pages ( spool , reserve ) ; } } }
GenerateIdFunctionCall :: evaluate ( txIEvalContext * aContext , txAExprResult * * aResult ) { * aResult = nsnull ; if ( ! requireParams ( 0 , 1 , aContext ) ) return NS_ERROR_XPATH_BAD_ARGUMENT_COUNT ; nsresult rv = NS_OK ; if ( mParams . IsEmpty ( ) ) { StringResult * strRes ; rv = aContext -> recycler ( ) -> getStringResult ( & strRes ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; txXPathNodeUtils :: getXSLTId ( aContext -> getContextNode ( ) , strRes -> mValue ) ; * aResult = strRes ; return NS_OK ; } nsRefPtr < txNodeSet > nodes ; rv = evaluateToNodeSet ( mParams [ 0 ] , aContext , getter_AddRefs ( nodes ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( nodes -> isEmpty ( ) ) { aContext -> recycler ( ) -> getEmptyStringResult ( aResult ) ; return NS_OK ; } StringResult * strRes ; rv = aContext -> recycler ( ) -> getStringResult ( & strRes ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; txXPathNodeUtils :: getXSLTId ( nodes -> get ( 0 ) , strRes -> mValue ) ; * aResult = strRes ; return NS_OK ; }
Node * JSCreateLowering :: AllocateElements ( Node * effect , Node * control , ElementsKind elements_kind , int capacity , PretenureFlag pretenure ) { DCHECK_LE ( 1 , capacity ) ; DCHECK_LE ( capacity , JSArray :: kInitialMaxFastElementArray ) ; Handle < Map > elements_map = IsDoubleElementsKind ( elements_kind ) ? factory ( ) -> fixed_double_array_map ( ) : factory ( ) -> fixed_array_map ( ) ; ElementAccess access = IsDoubleElementsKind ( elements_kind ) ? AccessBuilder :: ForFixedDoubleArrayElement ( ) : AccessBuilder :: ForFixedArrayElement ( ) ; Node * value = jsgraph ( ) -> TheHoleConstant ( ) ; AllocationBuilder a ( jsgraph ( ) , effect , control ) ; a . AllocateArray ( capacity , elements_map , pretenure ) ; for ( int i = 0 ; i < capacity ; ++ i ) { Node * index = jsgraph ( ) -> Constant ( i ) ; a . Store ( access , index , value ) ; } return a . Finish ( ) ; }
static uint8_t * add_attr ( uint8_t * p , uint8_t * p_end , tSDP_DISCOVERY_DB * p_db , tSDP_DISC_REC * p_rec , uint16_t attr_id , tSDP_DISC_ATTR * p_parent_attr , uint8_t nest_level ) { tSDP_DISC_ATTR * p_attr ; uint32_t attr_len ; uint32_t total_len ; uint16_t attr_type ; uint16_t id ; uint8_t type ; uint8_t * p_attr_end ; uint8_t is_additional_list = nest_level & SDP_ADDITIONAL_LIST_MASK ; nest_level &= ~ ( SDP_ADDITIONAL_LIST_MASK ) ; type = * p ++ ; p = sdpu_get_len_from_type ( p , type , & attr_len ) ; attr_len &= SDP_DISC_ATTR_LEN_MASK ; attr_type = ( type > > 3 ) & 0x0f ; if ( attr_len > 4 ) total_len = attr_len - 4 + ( uint16_t ) sizeof ( tSDP_DISC_ATTR ) ; else total_len = sizeof ( tSDP_DISC_ATTR ) ; p_attr_end = p + attr_len ; if ( p_attr_end > p_end ) { android_errorWriteLog ( 0x534e4554 , "115900043" ) ; SDP_TRACE_WARNING ( "%s: SDP - Attribute length beyond p_end" , __func__ ) ; return NULL ; } total_len = ( total_len + 3 ) & ~ 3 ; if ( p_db -> mem_free < total_len ) return ( NULL ) ; p_attr = ( tSDP_DISC_ATTR * ) p_db -> p_free_mem ; p_attr -> attr_id = attr_id ; p_attr -> attr_len_type = ( uint16_t ) attr_len | ( attr_type < < 12 ) ; p_attr -> p_next_attr = NULL ; switch ( attr_type ) { case UINT_DESC_TYPE : if ( ( is_additional_list != 0 ) && ( attr_len == 2 ) ) { BE_STREAM_TO_UINT16 ( id , p ) ; if ( id != ATTR_ID_PROTOCOL_DESC_LIST ) p -= 2 ; else { p_db -> p_free_mem += sizeof ( tSDP_DISC_ATTR ) ; p_db -> mem_free -= sizeof ( tSDP_DISC_ATTR ) ; total_len = 0 ; if ( nest_level >= MAX_NEST_LEVELS ) { SDP_TRACE_ERROR ( "SDP - attr nesting too deep" ) ; return p_attr_end ; } p = add_attr ( p , p_end , p_db , p_rec , ATTR_ID_PROTOCOL_DESC_LIST , p_attr , ( uint8_t ) ( nest_level + 1 ) ) ; break ; } } case TWO_COMP_INT_DESC_TYPE : switch ( attr_len ) { case 1 : p_attr -> attr_value . v . u8 = * p ++ ; break ; case 2 : BE_STREAM_TO_UINT16 ( p_attr -> attr_value . v . u16 , p ) ; break ; case 4 : BE_STREAM_TO_UINT32 ( p_attr -> attr_value . v . u32 , p ) ; break ; default : BE_STREAM_TO_ARRAY ( p , p_attr -> attr_value . v . array , ( int32_t ) attr_len ) ; break ; } break ; case UUID_DESC_TYPE : switch ( attr_len ) { case 2 : BE_STREAM_TO_UINT16 ( p_attr -> attr_value . v . u16 , p ) ; break ; case 4 : BE_STREAM_TO_UINT32 ( p_attr -> attr_value . v . u32 , p ) ; if ( p_attr -> attr_value . v . u32 < 0x10000 ) { attr_len = 2 ; p_attr -> attr_len_type = ( uint16_t ) attr_len | ( attr_type < < 12 ) ; p_attr -> attr_value . v . u16 = ( uint16_t ) p_attr -> attr_value . v . u32 ; } break ; case 16 : if ( sdpu_is_base_uuid ( p ) ) { if ( ( p [ 0 ] == 0 ) && ( p [ 1 ] == 0 ) ) { p_attr -> attr_len_type = ( p_attr -> attr_len_type & ~ SDP_DISC_ATTR_LEN_MASK ) | 2 ; p += 2 ; BE_STREAM_TO_UINT16 ( p_attr -> attr_value . v . u16 , p ) ; p += Uuid :: kNumBytes128 - 4 ; } else { p_attr -> attr_len_type = ( p_attr -> attr_len_type & ~ SDP_DISC_ATTR_LEN_MASK ) | 4 ; BE_STREAM_TO_UINT32 ( p_attr -> attr_value . v . u32 , p ) ; p += Uuid :: kNumBytes128 - 4 ; } } else { BE_STREAM_TO_ARRAY ( p , p_attr -> attr_value . v . array , ( int32_t ) attr_len ) ; } break ; default : SDP_TRACE_WARNING ( "SDP - bad len in UUID attr: %d" , attr_len ) ; return p_attr_end ; } break ; case DATA_ELE_SEQ_DESC_TYPE : case DATA_ELE_ALT_DESC_TYPE : p_db -> p_free_mem += sizeof ( tSDP_DISC_ATTR ) ; p_db -> mem_free -= sizeof ( tSDP_DISC_ATTR ) ; total_len = 0 ; if ( nest_level >= MAX_NEST_LEVELS ) { SDP_TRACE_ERROR ( "SDP - attr nesting too deep" ) ; return p_attr_end ; } if ( is_additional_list != 0 || attr_id == ATTR_ID_ADDITION_PROTO_DESC_LISTS ) nest_level |= SDP_ADDITIONAL_LIST_MASK ; while ( p < p_attr_end ) { p = add_attr ( p , p_end , p_db , p_rec , 0 , p_attr , ( uint8_t ) ( nest_level + 1 ) ) ; if ( ! p ) return ( NULL ) ; } break ; case TEXT_STR_DESC_TYPE : case URL_DESC_TYPE : BE_STREAM_TO_ARRAY ( p , p_attr -> attr_value . v . array , ( int32_t ) attr_len ) ; break ; case BOOLEAN_DESC_TYPE : switch ( attr_len ) { case 1 : p_attr -> attr_value . v . u8 = * p ++ ; break ; default : SDP_TRACE_WARNING ( "SDP - bad len in boolean attr: %d" , attr_len ) ; return p_attr_end ; } break ; default : break ; } p_db -> p_free_mem += total_len ; p_db -> mem_free -= total_len ; if ( ! p_parent_attr ) { if ( ! p_rec -> p_first_attr ) p_rec -> p_first_attr = p_attr ; else { tSDP_DISC_ATTR * p_attr1 = p_rec -> p_first_attr ; while ( p_attr1 -> p_next_attr ) p_attr1 = p_attr1 -> p_next_attr ; p_attr1 -> p_next_attr = p_attr ; } } else { if ( ! p_parent_attr -> attr_value . v . p_sub_attr ) { p_parent_attr -> attr_value . v . p_sub_attr = p_attr ; } else { tSDP_DISC_ATTR * p_attr1 = p_parent_attr -> attr_value . v . p_sub_attr ; while ( p_attr1 -> p_next_attr ) p_attr1 = p_attr1 -> p_next_attr ; p_attr1 -> p_next_attr = p_attr ; } } return ( p ) ; }
WORD32 ih264d_parse_islice_data_cabac ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; if ( ps_bitstrm -> u4_ofst & 0x07 ) { ps_bitstrm -> u4_ofst += 8 ; ps_bitstrm -> u4_ofst &= 0xFFFFFFF8 ; } ret = ih264d_init_cabac_dec_envirnoment ( & ( ps_dec -> s_cab_dec_env ) , ps_bitstrm ) ; if ( ret != OK ) return ret ; ih264d_init_cabac_contexts ( I_SLICE , ps_dec ) ; ps_dec -> i1_prev_mb_qp_delta = 0 ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice < < u1_mbaff ; do { UWORD16 u2_mbx ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { break ; } { UWORD8 u1_mb_type ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs > > u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; u2_mbx = ps_dec -> u2_mbx ; ps_cur_mb_info -> u1_tran_form8x8 = 0 ; ps_cur_mb_info -> ps_curmb -> u1_tran_form8x8 = 0 ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; u1_mb_type = ih264d_parse_mb_type_intra_cabac ( 0 , ps_dec ) ; if ( u1_mb_type > 25 ) return ERROR_MB_TYPE ; ps_cur_mb_info -> u1_mb_type = u1_mb_type ; COPYTHECONTEXT ( "u1_mb_type" , u1_mb_type ) ; if ( 25 == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = 0 ; } else { ret = ih264d_parse_imb_cabac ( ps_dec , ps_cur_mb_info , u1_mb_type ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; if ( ps_cur_mb_info -> u1_topmb && u1_mbaff ) uc_more_data_flag = 1 ; else { uc_more_data_flag = ih264d_decode_terminate ( & ps_dec -> s_cab_dec_env , ps_bitstrm ) ; uc_more_data_flag = ! uc_more_data_flag ; COPYTHECONTEXT ( "Decode Sliceterm" , ! uc_more_data_flag ) ; } { mv_pred_t * ps_mv_nmb_start = ps_dec -> ps_mv_cur + ( u1_num_mbs < < 4 ) ; mv_pred_t s_mvPred = { { 0 , 0 , 0 , 0 } , { - 1 , - 1 } , 0 , 0 } ; ih264d_rep_mv_colz ( ps_dec , & s_mvPred , ps_mv_nmb_start , 0 , ( UWORD8 ) ( ps_dec -> u1_cur_mb_fld_dec_flag < < 1 ) , 4 , 4 ) ; } if ( ps_dec -> u4_num_cores < 3 ) { if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ps_dec -> pf_compute_bs ( ps_dec , ps_cur_mb_info , ( UWORD16 ) ( u1_num_mbs > > u1_mbaff ) ) ; } u1_num_mbs ++ ; } u1_num_mbs_next = i2_pic_wdin_mbs - u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || ( ! uc_more_data_flag ) ; ps_cur_mb_info -> u1_end_of_slice = ( ! uc_more_data_flag ) ; if ( u1_tfr_n_mb || ( ! uc_more_data_flag ) ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } while ( uc_more_data_flag ) ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice < < u1_mbaff ) ; return ret ; }
const Operator * JSOperatorBuilder :: CallWithSpread ( uint32_t arity , CallFrequency const & frequency , VectorSlotPair const & feedback , SpeculationMode speculation_mode ) { DCHECK_IMPLIES ( speculation_mode == SpeculationMode :: kAllowSpeculation , feedback . IsValid ( ) ) ; CallParameters parameters ( arity , frequency , feedback , ConvertReceiverMode :: kAny , speculation_mode ) ; return new ( zone ( ) ) Operator1 < CallParameters > ( IrOpcode :: kJSCallWithSpread , Operator :: kNoProperties , "JSCallWithSpread" , parameters . arity ( ) , 1 , 1 , 1 , 1 , 2 , parameters ) ; }
DataViewObject :: getDataPointer ( JSContext * cx , Handle < DataViewObject * > obj , CallArgs args , size_t typeSize , uint8_t * * data ) { uint32_t offset ; JS_ASSERT ( args . length ( ) > 0 ) ; if ( ! ToUint32 ( cx , args [ 0 ] , & offset ) ) return false ; if ( offset > UINT32_MAX - typeSize || offset + typeSize > obj -> byteLength ( ) ) { JS_ReportErrorNumber ( cx , js_GetErrorMessage , nullptr , JSMSG_ARG_INDEX_OUT_OF_RANGE , "1" ) ; return false ; } * data = static_cast < uint8_t * > ( obj -> dataPointer ( ) ) + offset ; return true ; }
void HTMLMediaElement :: NotifyAddedSource ( ) { if ( ! HasAttr ( kNameSpaceID_None , nsGkAtoms :: src ) && mNetworkState == nsIDOMHTMLMediaElement :: NETWORK_EMPTY ) { QueueSelectResourceTask ( ) ; } if ( mLoadWaitStatus == WAITING_FOR_SOURCE ) { QueueLoadFromSourceTask ( ) ; } }
Reduction JSCreateLowering :: ReduceJSCreatePromise ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSCreatePromise , node -> opcode ( ) ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; MapRef promise_map = native_context_ref ( ) . promise_function ( ) . initial_map ( ) ; AllocationBuilder a ( jsgraph ( ) , effect , graph ( ) -> start ( ) ) ; a . Allocate ( promise_map . instance_size ( ) ) ; a . Store ( AccessBuilder :: ForMap ( ) , promise_map ) ; a . Store ( AccessBuilder :: ForJSObjectPropertiesOrHash ( ) , jsgraph ( ) -> EmptyFixedArrayConstant ( ) ) ; a . Store ( AccessBuilder :: ForJSObjectElements ( ) , jsgraph ( ) -> EmptyFixedArrayConstant ( ) ) ; a . Store ( AccessBuilder :: ForJSObjectOffset ( JSPromise :: kReactionsOrResultOffset ) , jsgraph ( ) -> ZeroConstant ( ) ) ; STATIC_ASSERT ( v8 :: Promise :: kPending == 0 ) ; a . Store ( AccessBuilder :: ForJSObjectOffset ( JSPromise :: kFlagsOffset ) , jsgraph ( ) -> ZeroConstant ( ) ) ; STATIC_ASSERT ( JSPromise :: kSize == 5 * kPointerSize ) ; for ( int i = 0 ; i < v8 :: Promise :: kEmbedderFieldCount ; ++ i ) { a . Store ( AccessBuilder :: ForJSObjectOffset ( JSPromise :: kSize + i * kPointerSize ) , jsgraph ( ) -> ZeroConstant ( ) ) ; } a . FinishAndChange ( node ) ; return Changed ( node ) ; }
URL :: SetHref ( const nsAString & aHref , ErrorResult & aRv ) { nsCString href = NS_ConvertUTF16toUTF8 ( aHref ) ; nsresult rv ; nsCOMPtr < nsIIOService > ioService ( do_GetService ( NS_IOSERVICE_CONTRACTID , & rv ) ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( rv ) ; return ; } nsCOMPtr < nsIURI > uri ; rv = ioService -> NewURI ( href , nullptr , nullptr , getter_AddRefs ( uri ) ) ; if ( NS_FAILED ( rv ) ) { nsAutoString label ( aHref ) ; aRv . ThrowTypeError ( MSG_INVALID_URL , & label ) ; return ; } aRv = mURI -> SetSpec ( href ) ; UpdateURLSearchParams ( ) ; }
void AccessorAssembler :: HandleStoreAccessor ( const StoreICParameters * p , Node * holder , Node * handler_word ) { Comment ( "accessor_store" ) ; Node * descriptor = DecodeWord < StoreHandler :: DescriptorBits > ( handler_word ) ; Node * accessor_pair = LoadDescriptorValue ( LoadMap ( holder ) , descriptor ) ; CSA_ASSERT ( this , IsAccessorPair ( accessor_pair ) ) ; Node * setter = LoadObjectField ( accessor_pair , AccessorPair :: kSetterOffset ) ; CSA_ASSERT ( this , Word32BinaryNot ( IsTheHole ( setter ) ) ) ; Callable callable = CodeFactory :: Call ( isolate ( ) ) ; Return ( CallJS ( callable , p -> context , setter , p -> receiver , p -> value ) ) ; }
PretenureFlag CompilationDependencies :: DependOnPretenureMode ( const AllocationSiteRef & site ) { PretenureFlag mode = site . GetPretenureMode ( ) ; dependencies_ . push_front ( new ( zone_ ) PretenureModeDependency ( site , mode ) ) ; return mode ; }
status_t GpuService :: getGpuStatsAppInfo ( std :: vector < GpuStatsAppInfo > * outStats ) const { ATRACE_CALL ( ) ; mGpuStats -> pullAppStats ( outStats ) ; return OK ; }
TfLiteStatus PopulatePrecomputedZPTimesWeightsWithBias ( TfLiteContext * context , OpData * op_data , TfLiteNode * node ) { const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; const TfLiteTensor * output_state = GetVariableInput ( context , node , kOutputStateTensor ) ; TF_LITE_ENSURE ( context , output_state != nullptr ) ; const int32_t input_zero_point = - input -> params . zero_point ; const int32_t output_state_zero_point = - output_state -> params . zero_point ; const TfLiteTensor * input_to_input_weights = GetOptionalInputTensor ( context , node , kInputToInputWeightsTensor ) ; const TfLiteTensor * input_to_forget_weights = GetInput ( context , node , kInputToForgetWeightsTensor ) ; const TfLiteTensor * input_to_cell_weights = GetInput ( context , node , kInputToCellWeightsTensor ) ; const TfLiteTensor * input_to_output_weights = GetInput ( context , node , kInputToOutputWeightsTensor ) ; const TfLiteTensor * recurrent_to_input_weights = GetOptionalInputTensor ( context , node , kRecurrentToInputWeightsTensor ) ; const TfLiteTensor * recurrent_to_forget_weights = GetInput ( context , node , kRecurrentToForgetWeightsTensor ) ; const TfLiteTensor * recurrent_to_cell_weights = GetInput ( context , node , kRecurrentToCellWeightsTensor ) ; const TfLiteTensor * recurrent_to_output_weights = GetInput ( context , node , kRecurrentToOutputWeightsTensor ) ; const TfLiteTensor * projection_weights = GetOptionalInputTensor ( context , node , kProjectionWeightsTensor ) ; const TfLiteTensor * projection_bias = GetOptionalInputTensor ( context , node , kProjectionBiasTensor ) ; lstm_eval :: IntegerLstmParameter * integer_lstm_params = & op_data -> integer_lstm_param ; const TfLiteTensor * intermediate = & context -> tensors [ node -> intermediates -> data [ 4 ] ] ; const auto * params = static_cast < TfLiteAffineQuantization * > ( intermediate -> quantization . params ) ; const int32_t hidden_zp = params -> zero_point -> data [ 0 ] ; const bool is_layer_norm = op_data -> use_layer_norm ; const TfLiteTensor * forget_gate_bias = is_layer_norm ? nullptr : GetInput ( context , node , kForgetGateBiasTensor ) ; TF_LITE_ENSURE_OK ( context , PrecomputeZeroPointTimesWeightWithBias ( context , input_zero_point , input_to_forget_weights , forget_gate_bias , & ( integer_lstm_params -> input_to_forget_effective_bias ) ) ) ; TF_LITE_ENSURE_OK ( context , PrecomputeZeroPointTimesWeightWithBias ( context , output_state_zero_point , recurrent_to_forget_weights , nullptr , & ( integer_lstm_params -> recurrent_to_forget_effective_bias ) ) ) ; const TfLiteTensor * cell_gate_bias = is_layer_norm ? nullptr : GetInput ( context , node , kCellGateBiasTensor ) ; TF_LITE_ENSURE_OK ( context , PrecomputeZeroPointTimesWeightWithBias ( context , input_zero_point , input_to_cell_weights , cell_gate_bias , & ( integer_lstm_params -> input_to_cell_effective_bias ) ) ) ; TF_LITE_ENSURE_OK ( context , PrecomputeZeroPointTimesWeightWithBias ( context , output_state_zero_point , recurrent_to_cell_weights , nullptr , & ( integer_lstm_params -> recurrent_to_cell_effective_bias ) ) ) ; const TfLiteTensor * output_gate_bias = is_layer_norm ? nullptr : GetInput ( context , node , kOutputGateBiasTensor ) ; TF_LITE_ENSURE_OK ( context , PrecomputeZeroPointTimesWeightWithBias ( context , input_zero_point , input_to_output_weights , output_gate_bias , & ( integer_lstm_params -> input_to_output_effective_bias ) ) ) ; TF_LITE_ENSURE_OK ( context , PrecomputeZeroPointTimesWeightWithBias ( context , output_state_zero_point , recurrent_to_output_weights , nullptr , & ( integer_lstm_params -> recurrent_to_output_effective_bias ) ) ) ; const TfLiteTensor * input_gate_bias = is_layer_norm ? nullptr : GetInput ( context , node , kInputGateBiasTensor ) ; TF_LITE_ENSURE_OK ( context , PrecomputeZeroPointTimesWeightWithBias ( context , input_zero_point , input_to_input_weights , input_gate_bias , & ( integer_lstm_params -> input_to_input_effective_bias ) ) ) ; TF_LITE_ENSURE_OK ( context , PrecomputeZeroPointTimesWeightWithBias ( context , output_state_zero_point , recurrent_to_input_weights , nullptr , & ( integer_lstm_params -> recurrent_to_input_effective_bias ) ) ) ; TF_LITE_ENSURE_OK ( context , PrecomputeZeroPointTimesWeightWithBias ( context , hidden_zp , projection_weights , projection_bias , & ( integer_lstm_params -> projection_effective_bias ) ) ) ; return kTfLiteOk ; }
void Heap :: ComputeFastPromotionMode ( ) { const size_t survived_in_new_space = survived_last_scavenge_ * 100 / new_space_ -> Capacity ( ) ; fast_promotion_mode_ = ! FLAG_optimize_for_size && FLAG_fast_promotion_new_space && ! ShouldReduceMemory ( ) && new_space_ -> IsAtMaximumCapacity ( ) && survived_in_new_space >= kMinPromotedPercentForFastPromotionMode ; if ( FLAG_trace_gc_verbose && ! FLAG_trace_gc_ignore_scavenger ) { PrintIsolate ( isolate ( ) , "Fast promotion mode: %s survival rate: %" PRIuS "%%\n" , fast_promotion_mode_ ? "true" : "false" , survived_in_new_space ) ; } }
void GenerateInternalArrayConstructorCase ( MacroAssembler * masm , ElementsKind kind ) { __ cmpli ( r3 , Operand ( 1 ) ) ; __ Jump ( CodeFactory :: InternalArrayNoArgumentConstructor ( masm -> isolate ( ) , kind ) . code ( ) , RelocInfo :: CODE_TARGET , lt ) ; __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , ArrayNArgumentsConstructor ) , RelocInfo :: CODE_TARGET , gt ) ; if ( IsFastPackedElementsKind ( kind ) ) { __ LoadP ( r6 , MemOperand ( sp , 0 ) ) ; __ cmpi ( r6 , Operand :: Zero ( ) ) ; __ Jump ( CodeFactory :: InternalArraySingleArgumentConstructor ( masm -> isolate ( ) , GetHoleyElementsKind ( kind ) ) . code ( ) , RelocInfo :: CODE_TARGET , ne ) ; } __ Jump ( CodeFactory :: InternalArraySingleArgumentConstructor ( masm -> isolate ( ) , kind ) . code ( ) , RelocInfo :: CODE_TARGET ) ; }
hugetlbfs_fill_super ( struct super_block * sb , void * data , int silent ) { struct inode * inode ; struct dentry * root ; int ret ; struct hugetlbfs_config config ; struct hugetlbfs_sb_info * sbinfo ; save_mount_options ( sb , data ) ; config . nr_blocks = - 1 ; config . nr_inodes = - 1 ; config . uid = current_fsuid ( ) ; config . gid = current_fsgid ( ) ; config . mode = 0755 ; config . hstate = & default_hstate ; ret = hugetlbfs_parse_options ( data , & config ) ; if ( ret ) return ret ; sbinfo = kmalloc ( sizeof ( struct hugetlbfs_sb_info ) , GFP_KERNEL ) ; if ( ! sbinfo ) return - ENOMEM ; sb -> s_fs_info = sbinfo ; sbinfo -> hstate = config . hstate ; spin_lock_init ( & sbinfo -> stat_lock ) ; sbinfo -> max_blocks = config . nr_blocks ; sbinfo -> free_blocks = config . nr_blocks ; sbinfo -> max_inodes = config . nr_inodes ; sbinfo -> free_inodes = config . nr_inodes ; sb -> s_maxbytes = MAX_LFS_FILESIZE ; sb -> s_blocksize = huge_page_size ( config . hstate ) ; sb -> s_blocksize_bits = huge_page_shift ( config . hstate ) ; sb -> s_magic = HUGETLBFS_MAGIC ; sb -> s_op = & hugetlbfs_ops ; sb -> s_time_gran = 1 ; inode = hugetlbfs_get_root ( sb , & config ) ; if ( ! inode ) goto out_free ; root = d_alloc_root ( inode ) ; if ( ! root ) { iput ( inode ) ; goto out_free ; } sb -> s_root = root ; return 0 ; out_free : kfree ( sbinfo ) ; return - ENOMEM ; }
UINT32 UIPC_Read ( tUIPC_CH_ID ch_id , UINT16 * p_msg_evt , UINT8 * p_buf , UINT32 len ) { int n ; int n_read = 0 ; int fd = uipc_main . ch [ ch_id ] . fd ; struct pollfd pfd ; UNUSED ( p_msg_evt ) ; if ( ch_id >= UIPC_CH_NUM ) { BTIF_TRACE_ERROR ( "UIPC_Read : invalid ch id %d" , ch_id ) ; return 0 ; } if ( fd == UIPC_DISCONNECTED ) { BTIF_TRACE_ERROR ( "UIPC_Read : channel %d closed" , ch_id ) ; return 0 ; } while ( n_read < ( int ) len ) { pfd . fd = fd ; pfd . events = POLLIN | POLLHUP ; if ( poll ( & pfd , 1 , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) == 0 ) { BTIF_TRACE_EVENT ( "poll timeout (%d ms)" , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) ; break ; } if ( pfd . revents & ( POLLHUP | POLLNVAL ) ) { BTIF_TRACE_EVENT ( "poll : channel detached remotely" ) ; UIPC_LOCK ( ) ; uipc_close_locked ( ch_id ) ; UIPC_UNLOCK ( ) ; return 0 ; } n = recv ( fd , p_buf + n_read , len - n_read , 0 ) ; if ( n == 0 ) { BTIF_TRACE_EVENT ( "UIPC_Read : channel detached remotely" ) ; UIPC_LOCK ( ) ; uipc_close_locked ( ch_id ) ; UIPC_UNLOCK ( ) ; return 0 ; } if ( n < 0 ) { BTIF_TRACE_EVENT ( "UIPC_Read : read failed (%s)" , strerror ( errno ) ) ; return 0 ; } n_read += n ; } return n_read ; }
dtls1_process_buffered_records ( SSL * s ) { pitem * item ; item = pqueue_peek ( s -> d1 -> unprocessed_rcds . q ) ; if ( item ) { if ( s -> d1 -> unprocessed_rcds . epoch != s -> d1 -> r_epoch ) return ( 1 ) ; while ( pqueue_peek ( s -> d1 -> unprocessed_rcds . q ) ) { dtls1_get_unprocessed_record ( s ) ; if ( ! dtls1_process_record ( s ) ) return ( 0 ) ; dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) , s -> s3 -> rrec . seq_num ) ; } } s -> d1 -> processed_rcds . epoch = s -> d1 -> r_epoch ; s -> d1 -> unprocessed_rcds . epoch = s -> d1 -> r_epoch + 1 ; return ( 1 ) ; }
static int init_strtab ( ELFOBJ * bin ) { r_return_val_if_fail ( ! bin -> strtab , false ) ; if ( ! bin -> shdr ) { return false ; } Elf_ ( Half ) shstrndx = bin -> ehdr . e_shstrndx ; if ( shstrndx != SHN_UNDEF && ! is_shidx_valid ( bin , shstrndx ) ) { return false ; } if ( bin -> shdr [ shstrndx ] . sh_size > UT32_MAX ) { return false ; } if ( ! bin -> shdr [ shstrndx ] . sh_size ) { return false ; } bin -> shstrtab_section = bin -> strtab_section = & bin -> shdr [ shstrndx ] ; bin -> shstrtab_size = bin -> shstrtab_section -> sh_size ; if ( bin -> shstrtab_size > bin -> size ) { return false ; } if ( bin -> shstrtab_section -> sh_offset > bin -> size ) { return false ; } if ( bin -> shstrtab_section -> sh_offset + bin -> shstrtab_section -> sh_size > bin -> size ) { return false ; } if ( ! ( bin -> shstrtab = calloc ( 1 , bin -> shstrtab_size + 1 ) ) ) { r_sys_perror ( "malloc" ) ; bin -> shstrtab = NULL ; return false ; } int res = r_buf_read_at ( bin -> b , bin -> shstrtab_section -> sh_offset , ( ut8 * ) bin -> shstrtab , bin -> shstrtab_section -> sh_size ) ; if ( res < 1 ) { R_LOG_ERROR ( "read (shstrtab) at 0x%" PFMT64x , ( ut64 ) bin -> shstrtab_section -> sh_offset ) ; R_FREE ( bin -> shstrtab ) ; return false ; } bin -> shstrtab [ bin -> shstrtab_section -> sh_size ] = '\0' ; sdb_num_set ( bin -> kv , "elf_shstrtab.offset" , bin -> shstrtab_section -> sh_offset , 0 ) ; sdb_num_set ( bin -> kv , "elf_shstrtab.size" , bin -> shstrtab_section -> sh_size , 0 ) ; return true ; }
void ProfilerEventsProcessor :: Run ( ) { while ( ! ! base :: Relaxed_Load ( & running_ ) ) { base :: TimeTicks nextSampleTime = base :: TimeTicks :: HighResolutionNow ( ) + period_ ; base :: TimeTicks now ; SampleProcessingResult result ; do { result = ProcessOneSample ( ) ; if ( result == FoundSampleForNextCodeEvent ) { ProcessCodeEvent ( ) ; } now = base :: TimeTicks :: HighResolutionNow ( ) ; } while ( result != NoSamplesInQueue && now < nextSampleTime ) ; if ( nextSampleTime > now ) { #if V8_OS_WIN if ( nextSampleTime - now < base :: TimeDelta :: FromMilliseconds ( 100 ) ) { while ( base :: TimeTicks :: HighResolutionNow ( ) < nextSampleTime ) { } } else #endif { base :: OS :: Sleep ( nextSampleTime - now ) ; } } if ( sampler_ ) sampler_ -> DoSample ( ) ; } do { SampleProcessingResult result ; do { result = ProcessOneSample ( ) ; } while ( result == OneSampleProcessed ) ; } while ( ProcessCodeEvent ( ) ) ; }
bool IsSmallInlineFunction ( Handle < SharedFunctionInfo > shared ) { if ( shared -> HasBytecodeArray ( ) && shared -> GetBytecodeArray ( ) -> length ( ) <= FLAG_max_inlined_bytecode_size_small ) { return true ; } return false ; }
get_char ( _pdfio_token_t * tb ) { ssize_t bytes ; if ( tb -> bufptr >= tb -> bufend ) { if ( tb -> bufend > tb -> buffer ) { PDFIO_DEBUG ( "get_char: Consuming %d bytes.\n" , ( int ) ( tb -> bufend - tb -> buffer ) ) ; ( tb -> consume_cb ) ( tb -> cb_data , ( size_t ) ( tb -> bufend - tb -> buffer ) ) ; } if ( ( bytes = ( tb -> peek_cb ) ( tb -> cb_data , tb -> buffer , sizeof ( tb -> buffer ) ) ) <= 0 ) { tb -> bufptr = tb -> bufend = tb -> buffer ; return ( EOF ) ; } tb -> bufptr = tb -> buffer ; tb -> bufend = tb -> buffer + bytes ; #ifdef DEBUG unsigned char * ptr ; PDFIO_DEBUG ( "get_char: Read '" ) ; for ( ptr = tb -> buffer ; ptr < tb -> bufend ; ptr ++ ) { if ( * ptr < ' ' || * ptr == 0x7f ) PDFIO_DEBUG ( "\\%03o" , * ptr ) ; else PDFIO_DEBUG ( "%c" , * ptr ) ; } PDFIO_DEBUG ( "'\n" ) ; #endif // DEBUG } return ( * ( tb -> bufptr ) ++ ) ; }
void Builtins :: Generate_DoubleToI ( MacroAssembler * masm ) { Label out_of_range , only_low , negate , done ; Register result_reg = t0 ; Register scratch = GetRegisterThatIsNotOneOf ( result_reg ) ; Register scratch2 = GetRegisterThatIsNotOneOf ( result_reg , scratch ) ; Register scratch3 = GetRegisterThatIsNotOneOf ( result_reg , scratch , scratch2 ) ; DoubleRegister double_scratch = kScratchDoubleReg ; const int kArgumentOffset = 4 * kPointerSize ; __ Push ( result_reg ) ; __ Push ( scratch , scratch2 , scratch3 ) ; __ Ldc1 ( double_scratch , MemOperand ( sp , kArgumentOffset ) ) ; __ cfc1 ( scratch2 , FCSR ) ; __ ctc1 ( zero_reg , FCSR ) ; __ Trunc_w_d ( double_scratch , double_scratch ) ; __ mfc1 ( scratch3 , double_scratch ) ; __ cfc1 ( scratch , FCSR ) ; __ ctc1 ( scratch2 , FCSR ) ; __ And ( scratch , scratch , kFCSROverflowFlagMask | kFCSRUnderflowFlagMask | kFCSRInvalidOpFlagMask ) ; Label error ; __ Branch ( & error , ne , scratch , Operand ( zero_reg ) ) ; __ Move ( result_reg , scratch3 ) ; __ Branch ( & done ) ; __ bind ( & error ) ; Register input_high = scratch2 ; Register input_low = scratch3 ; __ lw ( input_low , MemOperand ( sp , kArgumentOffset + Register :: kMantissaOffset ) ) ; __ lw ( input_high , MemOperand ( sp , kArgumentOffset + Register :: kExponentOffset ) ) ; Label normal_exponent , restore_sign ; __ Ext ( result_reg , input_high , HeapNumber :: kExponentShift , HeapNumber :: kExponentBits ) ; __ Subu ( scratch , result_reg , HeapNumber :: kExponentMask ) ; __ Movz ( result_reg , zero_reg , scratch ) ; __ Branch ( & done , eq , scratch , Operand ( zero_reg ) ) ; __ Subu ( result_reg , result_reg , Operand ( HeapNumber :: kExponentBias + HeapNumber :: kMantissaBits + 31 ) ) ; __ Branch ( & normal_exponent , le , result_reg , Operand ( zero_reg ) ) ; __ mov ( result_reg , zero_reg ) ; __ Branch ( & done ) ; __ bind ( & normal_exponent ) ; const int kShiftBase = HeapNumber :: kNonMantissaBitsInTopWord - 1 ; __ Addu ( scratch , result_reg , Operand ( kShiftBase + HeapNumber :: kMantissaBits ) ) ; Register sign = result_reg ; result_reg = no_reg ; __ And ( sign , input_high , Operand ( HeapNumber :: kSignMask ) ) ; Label high_shift_needed , high_shift_done ; __ Branch ( & high_shift_needed , lt , scratch , Operand ( 32 ) ) ; __ mov ( input_high , zero_reg ) ; __ Branch ( & high_shift_done ) ; __ bind ( & high_shift_needed ) ; __ Or ( input_high , input_high , Operand ( 1 < < HeapNumber :: kMantissaBitsInTopWord ) ) ; __ sllv ( input_high , input_high , scratch ) ; __ bind ( & high_shift_done ) ; Label pos_shift , shift_done ; __ li ( kScratchReg , 32 ) ; __ subu ( scratch , kScratchReg , scratch ) ; __ Branch ( & pos_shift , ge , scratch , Operand ( zero_reg ) ) ; __ Subu ( scratch , zero_reg , scratch ) ; __ sllv ( input_low , input_low , scratch ) ; __ Branch ( & shift_done ) ; __ bind ( & pos_shift ) ; __ srlv ( input_low , input_low , scratch ) ; __ bind ( & shift_done ) ; __ Or ( input_high , input_high , Operand ( input_low ) ) ; __ mov ( scratch , sign ) ; result_reg = sign ; sign = no_reg ; __ Subu ( result_reg , zero_reg , input_high ) ; __ Movz ( result_reg , input_high , scratch ) ; __ bind ( & done ) ; __ sw ( result_reg , MemOperand ( sp , kArgumentOffset ) ) ; __ Pop ( scratch , scratch2 , scratch3 ) ; __ Pop ( result_reg ) ; __ Ret ( ) ; }
MP4Demuxer :: GetTrackDemuxer ( TrackInfo :: TrackType aType , uint32_t aTrackNumber ) { if ( mMetadata -> GetNumberTracks ( aType ) <= aTrackNumber ) { return nullptr ; } nsRefPtr < MP4TrackDemuxer > e = new MP4TrackDemuxer ( this , aType , aTrackNumber ) ; mDemuxers . AppendElement ( e ) ; return e . forget ( ) ; }
const char * string_of_NPNVariable ( int variable ) { const char * str ; switch ( variable ) { #define _(VAL) case VAL: str = #VAL; break; _ ( NPNVxDisplay ) ; _ ( NPNVxtAppContext ) ; _ ( NPNVnetscapeWindow ) ; _ ( NPNVjavascriptEnabledBool ) ; _ ( NPNVasdEnabledBool ) ; _ ( NPNVisOfflineBool ) ; _ ( NPNVserviceManager ) ; _ ( NPNVDOMElement ) ; _ ( NPNVDOMWindow ) ; _ ( NPNVToolkit ) ; _ ( NPNVSupportsXEmbedBool ) ; _ ( NPNVWindowNPObject ) ; _ ( NPNVPluginElementNPObject ) ; _ ( NPNVSupportsWindowless ) ; #undef _ default : switch ( variable & 0xff ) { #define _(VAL, VAR) case VAL: str = #VAR; break _ ( 10 , NPNVserviceManager ) ; _ ( 11 , NPNVDOMElement ) ; _ ( 12 , NPNVDOMWindow ) ; _ ( 13 , NPNVToolkit ) ; #undef _ default : str = "<unknown variable>" ; break ; } break ; } return str ; }
void WorkerPrivate :: ClearMainEventQueue ( WorkerRanOrNot aRanOrNot ) { AssertIsOnWorkerThread ( ) ; MOZ_ASSERT ( mSyncLoopStack . IsEmpty ( ) ) ; MOZ_ASSERT ( ! mCancelAllPendingRunnables ) ; mCancelAllPendingRunnables = true ; if ( WorkerNeverRan == aRanOrNot ) { for ( uint32_t count = mPreStartRunnables . Length ( ) , index = 0 ; index < count ; index ++ ) { RefPtr < WorkerRunnable > runnable = std :: move ( mPreStartRunnables [ index ] ) ; static_cast < nsIRunnable * > ( runnable . get ( ) ) -> Run ( ) ; } } else { nsIThread * currentThread = NS_GetCurrentThread ( ) ; MOZ_ASSERT ( currentThread ) ; NS_ProcessPendingEvents ( currentThread ) ; ReportUseCounters ( ) ; } MOZ_ASSERT ( mCancelAllPendingRunnables ) ; mCancelAllPendingRunnables = false ; }
void Filter :: onUpstreamEvent ( Network :: ConnectionEvent event ) { bool connecting = connecting_ ; connecting_ = false ; if ( event == Network :: ConnectionEvent :: RemoteClose || event == Network :: ConnectionEvent :: LocalClose ) { upstream_ . reset ( ) ; disableIdleTimer ( ) ; if ( connecting ) { if ( event == Network :: ConnectionEvent :: RemoteClose ) { getStreamInfo ( ) . setResponseFlag ( StreamInfo :: ResponseFlag :: UpstreamConnectionFailure ) ; read_callbacks_ -> upstreamHost ( ) -> outlierDetector ( ) . putResult ( Upstream :: Outlier :: Result :: LocalOriginConnectFailed ) ; } initializeUpstreamConnection ( ) ; } else { if ( read_callbacks_ -> connection ( ) . state ( ) == Network :: Connection :: State :: Open ) { read_callbacks_ -> connection ( ) . close ( Network :: ConnectionCloseType :: FlushWrite ) ; } } } }
qf_jump_edit_buffer ( qf_info_T * qi , qfline_T * qf_ptr , int forceit , int prev_winid , int * opened_window ) { qf_list_T * qfl = qf_get_curlist ( qi ) ; int old_changedtick = qfl -> qf_changedtick ; qfltype_T qfl_type = qfl -> qfl_type ; int retval = OK ; int old_qf_curlist = qi -> qf_curlist ; int save_qfid = qfl -> qf_id ; if ( qf_ptr -> qf_type == 1 ) { if ( ! can_abandon ( curbuf , forceit ) ) { no_write_message ( ) ; return FAIL ; } retval = do_ecmd ( qf_ptr -> qf_fnum , NULL , NULL , NULL , ( linenr_T ) 1 , ECMD_HIDE + ECMD_SET_HELP , prev_winid == curwin -> w_id ? curwin : NULL ) ; } else retval = buflist_getfile ( qf_ptr -> qf_fnum , ( linenr_T ) 1 , GETF_SETMARK | GETF_SWITCH , forceit ) ; if ( qfl_type == QFLT_LOCATION ) { win_T * wp = win_id2wp ( prev_winid ) ; if ( wp == NULL && curwin -> w_llist != qi ) { emsg ( _ ( e_current_window_was_closed ) ) ; * opened_window = FALSE ; return NOTDONE ; } } if ( qfl_type == QFLT_QUICKFIX && ! qflist_valid ( NULL , save_qfid ) ) { emsg ( _ ( e_current_quickfix_list_was_changed ) ) ; return NOTDONE ; } if ( old_qf_curlist != qi -> qf_curlist || old_changedtick != qfl -> qf_changedtick || ! is_qf_entry_present ( qfl , qf_ptr ) ) { if ( qfl_type == QFLT_QUICKFIX ) emsg ( _ ( e_current_quickfix_list_was_changed ) ) ; else emsg ( _ ( e_current_location_list_was_changed ) ) ; return NOTDONE ; } return retval ; }
BUILTIN ( HandleApiCall ) { HandleScope scope ( isolate ) ; Handle < JSFunction > function = args . target ( ) ; Handle < Object > receiver = args . receiver ( ) ; Handle < HeapObject > new_target = args . new_target ( ) ; Handle < FunctionTemplateInfo > fun_data ( function -> shared ( ) -> get_api_func_data ( ) , isolate ) ; if ( new_target -> IsJSReceiver ( ) ) { RETURN_RESULT_OR_FAILURE ( isolate , HandleApiCallHelper < true > ( isolate , function , new_target , fun_data , receiver , args ) ) ; } else { RETURN_RESULT_OR_FAILURE ( isolate , HandleApiCallHelper < false > ( isolate , function , new_target , fun_data , receiver , args ) ) ; } }
static apr_byte_t oidc_validate_post_logout_url ( request_rec * r , const char * url , char * * err_str , char * * err_desc ) { apr_uri_t uri ; const char * c_host = NULL ; if ( apr_uri_parse ( r -> pool , url , & uri ) != APR_SUCCESS ) { * err_str = apr_pstrdup ( r -> pool , "Malformed URL" ) ; * err_desc = apr_psprintf ( r -> pool , "Logout URL malformed: %s" , url ) ; oidc_error ( r , "%s: %s" , * err_str , * err_desc ) ; return FALSE ; } c_host = oidc_get_current_url_host ( r ) ; if ( ( uri . hostname != NULL ) && ( ( strstr ( c_host , uri . hostname ) == NULL ) || ( strstr ( uri . hostname , c_host ) == NULL ) ) ) { * err_str = apr_pstrdup ( r -> pool , "Invalid Request" ) ; * err_desc = apr_psprintf ( r -> pool , "logout value \"%s\" does not match the hostname of the current request \"%s\"" , apr_uri_unparse ( r -> pool , & uri , 0 ) , c_host ) ; oidc_error ( r , "%s: %s" , * err_str , * err_desc ) ; return FALSE ; } else if ( ( uri . hostname == NULL ) && ( strstr ( url , "/" ) != url ) ) { * err_str = apr_pstrdup ( r -> pool , "Malformed URL" ) ; * err_desc = apr_psprintf ( r -> pool , "No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s" , url ) ; oidc_error ( r , "%s: %s" , * err_str , * err_desc ) ; return FALSE ; } else if ( ( uri . hostname == NULL ) && ( strstr ( url , "//" ) == url ) ) { * err_str = apr_pstrdup ( r -> pool , "Malformed URL" ) ; * err_desc = apr_psprintf ( r -> pool , "No hostname was parsed and starting with '//': %s" , url ) ; oidc_error ( r , "%s: %s" , * err_str , * err_desc ) ; return FALSE ; } if ( ( ( strstr ( url , "\n" ) != NULL ) || strstr ( url , "\r" ) != NULL ) ) { * err_str = apr_pstrdup ( r -> pool , "Invalid Request" ) ; * err_desc = apr_psprintf ( r -> pool , "logout value \"%s\" contains illegal \"\n\" or \"\r\" character(s)" , url ) ; oidc_error ( r , "%s: %s" , * err_str , * err_desc ) ; return FALSE ; } return TRUE ; }
PremultiplyData ( const uint8_t * aSrc , int32_t aSrcStride , SurfaceFormat aSrcFormat , uint8_t * aDst , int32_t aDstStride , SurfaceFormat aDstFormat , const IntSize & aSize ) { if ( aSize . IsEmpty ( ) ) { return true ; } IntSize size = CollapseSize ( aSize , aSrcStride , aDstStride ) ; int32_t srcGap = aSrcStride - BytesPerPixel ( aSrcFormat ) * aSize . width ; int32_t dstGap = aDstStride - BytesPerPixel ( aDstFormat ) * aSize . width ; MOZ_ASSERT ( srcGap >= 0 && dstGap >= 0 ) ; #define FORMAT_CASE_CALL(...) __VA_ARGS__(aSrc, srcGap, aDst, dstGap, size) #ifdef USE_SSE2 switch ( FORMAT_KEY ( aSrcFormat , aDstFormat ) ) { PREMULTIPLY_SSE2 ( SurfaceFormat :: B8G8R8A8 , SurfaceFormat :: B8G8R8A8 ) PREMULTIPLY_SSE2 ( SurfaceFormat :: B8G8R8A8 , SurfaceFormat :: B8G8R8X8 ) PREMULTIPLY_SSE2 ( SurfaceFormat :: B8G8R8A8 , SurfaceFormat :: R8G8B8A8 ) PREMULTIPLY_SSE2 ( SurfaceFormat :: B8G8R8A8 , SurfaceFormat :: R8G8B8X8 ) PREMULTIPLY_SSE2 ( SurfaceFormat :: R8G8B8A8 , SurfaceFormat :: R8G8B8A8 ) PREMULTIPLY_SSE2 ( SurfaceFormat :: R8G8B8A8 , SurfaceFormat :: R8G8B8X8 ) PREMULTIPLY_SSE2 ( SurfaceFormat :: R8G8B8A8 , SurfaceFormat :: B8G8R8A8 ) PREMULTIPLY_SSE2 ( SurfaceFormat :: R8G8B8A8 , SurfaceFormat :: B8G8R8X8 ) default : break ; } #endif #ifdef BUILD_ARM_NEON if ( mozilla :: supports_neon ( ) ) switch ( FORMAT_KEY ( aSrcFormat , aDstFormat ) ) { PREMULTIPLY_NEON ( SurfaceFormat :: B8G8R8A8 , SurfaceFormat :: B8G8R8A8 ) PREMULTIPLY_NEON ( SurfaceFormat :: B8G8R8A8 , SurfaceFormat :: B8G8R8X8 ) PREMULTIPLY_NEON ( SurfaceFormat :: B8G8R8A8 , SurfaceFormat :: R8G8B8A8 ) PREMULTIPLY_NEON ( SurfaceFormat :: B8G8R8A8 , SurfaceFormat :: R8G8B8X8 ) PREMULTIPLY_NEON ( SurfaceFormat :: R8G8B8A8 , SurfaceFormat :: R8G8B8A8 ) PREMULTIPLY_NEON ( SurfaceFormat :: R8G8B8A8 , SurfaceFormat :: R8G8B8X8 ) PREMULTIPLY_NEON ( SurfaceFormat :: R8G8B8A8 , SurfaceFormat :: B8G8R8A8 ) PREMULTIPLY_NEON ( SurfaceFormat :: R8G8B8A8 , SurfaceFormat :: B8G8R8X8 ) default : break ; } #endif switch ( FORMAT_KEY ( aSrcFormat , aDstFormat ) ) { PREMULTIPLY_FALLBACK ( SurfaceFormat :: B8G8R8A8 ) PREMULTIPLY_FALLBACK ( SurfaceFormat :: R8G8B8A8 ) PREMULTIPLY_FALLBACK ( SurfaceFormat :: A8R8G8B8 ) default : break ; } #undef FORMAT_CASE_CALL MOZ_ASSERT ( false , "Unsupported premultiply formats" ) ; return false ; }
IMPL_TIMING_ATTR ( AsyncOpen ) IMPL_TIMING_ATTR ( LaunchServiceWorkerStart ) IMPL_TIMING_ATTR ( LaunchServiceWorkerEnd ) IMPL_TIMING_ATTR ( DispatchFetchEventStart ) IMPL_TIMING_ATTR ( DispatchFetchEventEnd ) IMPL_TIMING_ATTR ( HandleFetchEventStart ) IMPL_TIMING_ATTR ( HandleFetchEventEnd ) IMPL_TIMING_ATTR ( DomainLookupStart ) IMPL_TIMING_ATTR ( DomainLookupEnd ) IMPL_TIMING_ATTR ( ConnectStart ) IMPL_TIMING_ATTR ( TcpConnectEnd ) IMPL_TIMING_ATTR ( SecureConnectionStart ) IMPL_TIMING_ATTR ( ConnectEnd ) IMPL_TIMING_ATTR ( RequestStart ) IMPL_TIMING_ATTR ( ResponseStart ) IMPL_TIMING_ATTR ( ResponseEnd ) IMPL_TIMING_ATTR ( CacheReadStart ) IMPL_TIMING_ATTR ( CacheReadEnd ) IMPL_TIMING_ATTR ( RedirectStart ) IMPL_TIMING_ATTR ( RedirectEnd ) #undef IMPL_TIMING_ATTR mozilla :: dom :: PerformanceStorage * HttpBaseChannel :: GetPerformanceStorage ( ) { if ( ! mTimingEnabled ) { return nullptr ; } if ( XRE_IsE10sParentProcess ( ) ) { return nullptr ; } if ( ! mLoadInfo ) { return nullptr ; } mozilla :: dom :: PerformanceStorage * performanceStorage = mLoadInfo -> GetPerformanceStorage ( ) ; if ( performanceStorage ) { return performanceStorage ; } nsCOMPtr < nsIDocument > loadingDocument ; mLoadInfo -> GetLoadingDocument ( getter_AddRefs ( loadingDocument ) ) ; if ( ! loadingDocument ) { return nullptr ; } if ( ! mLoadInfo -> TriggeringPrincipal ( ) -> Equals ( loadingDocument -> NodePrincipal ( ) ) ) { return nullptr ; } nsCOMPtr < nsPIDOMWindowInner > innerWindow = loadingDocument -> GetInnerWindow ( ) ; if ( ! innerWindow ) { return nullptr ; } mozilla :: dom :: Performance * performance = innerWindow -> GetPerformance ( ) ; if ( ! performance ) { return nullptr ; } return performance -> AsPerformanceStorage ( ) ; }
void impeg2d_dec_hdr ( void * pv_dec , impeg2d_video_decode_ip_t * ps_ip , impeg2d_video_decode_op_t * ps_op ) { UWORD32 u4_bits_read ; dec_state_t * ps_dec ; ps_dec = ( dec_state_t * ) pv_dec ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = 0 ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , ps_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer , ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) ; { { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_process_video_header ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read > > 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } if ( ps_op -> s_ivd_video_decode_op_t . u4_error_code == 0 ) ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; return ; } } ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_vertical_size ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_horizontal_size ; ps_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read > > 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } ps_op -> s_ivd_video_decode_op_t . u4_frame_decoded_flag = 0 ; ps_dec -> u2_header_done = 1 ; } }
std :: unique_ptr < V8ConsoleMessage > V8ConsoleMessage :: createForConsoleAPI ( v8 :: Local < v8 :: Context > v8Context , int contextId , int groupId , V8InspectorImpl * inspector , double timestamp , ConsoleAPIType type , const std :: vector < v8 :: Local < v8 :: Value > > & arguments , const String16 & consoleContext , std :: unique_ptr < V8StackTraceImpl > stackTrace ) { v8 :: Isolate * isolate = v8Context -> GetIsolate ( ) ; std :: unique_ptr < V8ConsoleMessage > message ( new V8ConsoleMessage ( V8MessageOrigin :: kConsole , timestamp , String16 ( ) ) ) ; if ( stackTrace && ! stackTrace -> isEmpty ( ) ) { message -> m_url = toString16 ( stackTrace -> topSourceURL ( ) ) ; message -> m_lineNumber = stackTrace -> topLineNumber ( ) ; message -> m_columnNumber = stackTrace -> topColumnNumber ( ) ; } message -> m_stackTrace = std :: move ( stackTrace ) ; message -> m_consoleContext = consoleContext ; message -> m_type = type ; message -> m_contextId = contextId ; for ( size_t i = 0 ; i < arguments . size ( ) ; ++ i ) { std :: unique_ptr < v8 :: Global < v8 :: Value > > argument ( new v8 :: Global < v8 :: Value > ( isolate , arguments . at ( i ) ) ) ; argument -> AnnotateStrongRetainer ( kGlobalConsoleMessageHandleLabel ) ; message -> m_arguments . push_back ( std :: move ( argument ) ) ; message -> m_v8Size += v8 :: debug :: EstimatedValueSize ( isolate , arguments . at ( i ) ) ; } if ( arguments . size ( ) ) message -> m_message = V8ValueStringBuilder :: toString ( arguments [ 0 ] , v8Context ) ; v8 :: Isolate :: MessageErrorLevel clientLevel = v8 :: Isolate :: kMessageInfo ; if ( type == ConsoleAPIType :: kDebug || type == ConsoleAPIType :: kCount || type == ConsoleAPIType :: kTimeEnd ) { clientLevel = v8 :: Isolate :: kMessageDebug ; } else if ( type == ConsoleAPIType :: kError || type == ConsoleAPIType :: kAssert ) { clientLevel = v8 :: Isolate :: kMessageError ; } else if ( type == ConsoleAPIType :: kWarning ) { clientLevel = v8 :: Isolate :: kMessageWarning ; } else if ( type == ConsoleAPIType :: kInfo || type == ConsoleAPIType :: kLog ) { clientLevel = v8 :: Isolate :: kMessageInfo ; } if ( type != ConsoleAPIType :: kClear ) { inspector -> client ( ) -> consoleAPIMessage ( groupId , clientLevel , toStringView ( message -> m_message ) , toStringView ( message -> m_url ) , message -> m_lineNumber , message -> m_columnNumber , message -> m_stackTrace . get ( ) ) ; } return message ; }
static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx , int ctr_id , va_list args ) { vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ; if ( frame != NULL ) { YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp9_set_reference_enc ( ctx -> cpi , ref_frame_to_vp9_reframe ( frame -> frame_type ) , & sd ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
void LogEvent :: parseAttributionChain ( int32_t * pos , int32_t depth , bool * last , uint8_t numAnnotations ) { const unsigned int firstUidInChainIndex = mValues . size ( ) ; const int32_t numNodes = readNextValue < uint8_t > ( ) ; for ( pos [ 1 ] = 1 ; pos [ 1 ] <= numNodes ; pos [ 1 ] ++ ) { last [ 1 ] = ( pos [ 1 ] == numNodes ) ; pos [ 2 ] = 1 ; parseInt32 ( pos , 2 , last , 0 ) ; pos [ 2 ] = 2 ; last [ 2 ] = true ; parseString ( pos , 2 , last , 0 ) ; } if ( mValues . size ( ) - 1 > firstUidInChainIndex ) { mAttributionChainStartIndex = static_cast < int8_t > ( firstUidInChainIndex ) ; mAttributionChainEndIndex = static_cast < int8_t > ( mValues . size ( ) - 1 ) ; } parseAnnotations ( numAnnotations , firstUidInChainIndex ) ; pos [ 1 ] = pos [ 2 ] = 1 ; last [ 1 ] = last [ 2 ] = false ; }
MediaDevice :: MediaDevice ( const RefPtr < MediaDevice > & aOther , const nsString & aID , const nsString & aGroupID , const nsString & aRawID , const nsString & aName ) : mSource ( aOther -> mSource ) , mSinkInfo ( aOther -> mSinkInfo ) , mKind ( aOther -> mKind ) , mScary ( aOther -> mScary ) , mIsFake ( aOther -> mIsFake ) , mType ( aOther -> mType ) , mName ( aName ) , mID ( aID ) , mGroupID ( aGroupID ) , mRawID ( aRawID ) { MOZ_ASSERT ( aOther ) ; }
void nsTableFrame :: InsertColGroups ( PRInt32 aStartColIndex , const nsFrameList :: Slice & aColGroups ) { PRInt32 colIndex = aStartColIndex ; nsFrameList :: Enumerator colGroups ( aColGroups ) ; for ( ; ! colGroups . AtEnd ( ) ; colGroups . Next ( ) ) { nsTableColGroupFrame * cgFrame = static_cast < nsTableColGroupFrame * > ( colGroups . get ( ) ) ; cgFrame -> SetStartColumnIndex ( colIndex ) ; cgFrame -> AddColsToTable ( colIndex , false , colGroups . get ( ) -> PrincipalChildList ( ) ) ; PRInt32 numCols = cgFrame -> GetColCount ( ) ; colIndex += numCols ; } nsFrameList :: Enumerator remainingColgroups = colGroups . GetUnlimitedEnumerator ( ) ; if ( ! remainingColgroups . AtEnd ( ) ) { nsTableColGroupFrame :: ResetColIndices ( static_cast < nsTableColGroupFrame * > ( remainingColgroups . get ( ) ) , colIndex ) ; } }
static int misaligned_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; srcreg = ( opcode > > 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL < < width_shift ) ) { return - 1 ; } switch ( width_shift ) { case 1 : * ( __u16 * ) & buffer = ( __u16 ) regs -> regs [ srcreg ] ; break ; case 2 : * ( __u32 * ) & buffer = ( __u32 ) regs -> regs [ srcreg ] ; break ; case 3 : buffer = regs -> regs [ srcreg ] ; break ; default : printk ( "Unexpected width_shift %d in misaligned_store, PC=%08lx\n" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 < < width_shift ) ) > 0 ) { return - 1 ; } } else { __u64 val = regs -> regs [ srcreg ] ; switch ( width_shift ) { case 1 : misaligned_kernel_word_store ( address , val ) ; break ; case 2 : asm ( "stlo.l %1, 0, %0" : : "r" ( val ) , "r" ( address ) ) ; asm ( "sthi.l %1, 3, %0" : : "r" ( val ) , "r" ( address ) ) ; break ; case 3 : asm ( "stlo.q %1, 0, %0" : : "r" ( val ) , "r" ( address ) ) ; asm ( "sthi.q %1, 7, %0" : : "r" ( val ) , "r" ( address ) ) ; break ; default : printk ( "Unexpected width_shift %d in misaligned_store, PC=%08lx\n" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } return 0 ; }
write_one_file ( Image * output , Image * image , int convert_to_8bit ) { if ( image -> opts & FAST_WRITE ) image -> image . flags |= PNG_IMAGE_FLAG_FAST ; if ( image -> opts & USE_STDIO ) { FILE * f = tmpfile ( ) ; if ( f != NULL ) { if ( png_image_write_to_stdio ( & image -> image , f , convert_to_8bit , image -> buffer + 16 , ( png_int_32 ) image -> stride , image -> colormap ) ) { if ( fflush ( f ) == 0 ) { rewind ( f ) ; initimage ( output , image -> opts , "tmpfile" , image -> stride_extra ) ; output -> input_file = f ; if ( ! checkopaque ( image ) ) return 0 ; } else return logclose ( image , f , "tmpfile" , ": flush: " ) ; } else { fclose ( f ) ; return logerror ( image , "tmpfile" , ": write failed" , "" ) ; } } else return logerror ( image , "tmpfile" , ": open: " , strerror ( errno ) ) ; } else { static int counter = 0 ; char name [ 32 ] ; sprintf ( name , "%s%d.png" , tmpf , ++ counter ) ; if ( png_image_write_to_file ( & image -> image , name , convert_to_8bit , image -> buffer + 16 , ( png_int_32 ) image -> stride , image -> colormap ) ) { initimage ( output , image -> opts , output -> tmpfile_name , image -> stride_extra ) ; strcpy ( output -> tmpfile_name , name ) ; if ( ! checkopaque ( image ) ) return 0 ; } else return logerror ( image , name , ": write failed" , "" ) ; } if ( read_file ( output , image -> image . format | FORMAT_NO_CHANGE , NULL ) ) { png_uint_32 original_format = image -> image . format ; if ( convert_to_8bit ) original_format &= ~ PNG_FORMAT_FLAG_LINEAR ; if ( ( output -> image . format & BASE_FORMATS ) != ( original_format & BASE_FORMATS ) ) return logerror ( image , image -> file_name , ": format changed on read: " , output -> file_name ) ; return compare_two_images ( image , output , 0 , NULL ) ; } else return logerror ( output , output -> tmpfile_name , ": read of new file failed" , "" ) ; }
fetch_token_in_cc ( OnigToken * tok , UChar * * src , UChar * end , ScanEnv * env ) { int num ; OnigCodePoint c , c2 ; OnigSyntaxType * syn = env -> syntax ; OnigEncoding enc = env -> enc ; UChar * prev ; UChar * p = * src ; PFETCH_READY ; if ( PEND ) { tok -> type = TK_EOT ; return tok -> type ; } PFETCH ( c ) ; tok -> type = TK_CHAR ; tok -> base = 0 ; tok -> u . c = c ; tok -> escaped = 0 ; if ( c == ']' ) { tok -> type = TK_CC_CLOSE ; } else if ( c == '-' ) { tok -> type = TK_CC_RANGE ; } else if ( c == MC_ESC ( syn ) ) { if ( ! IS_SYNTAX_BV ( syn , ONIG_SYN_BACKSLASH_ESCAPE_IN_CC ) ) goto end ; if ( PEND ) return ONIGERR_END_PATTERN_AT_ESCAPE ; PFETCH ( c ) ; tok -> escaped = 1 ; tok -> u . c = c ; switch ( c ) { case 'w' : tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 0 ; break ; case 'W' : tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 1 ; break ; case 'd' : tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 0 ; break ; case 'D' : tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 1 ; break ; case 's' : tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 0 ; break ; case 'S' : tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 1 ; break ; case 'h' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 0 ; break ; case 'H' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 1 ; break ; case 'p' : case 'P' : if ( PEND ) break ; c2 = PPEEK ; if ( c2 == '{' && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY ) ) { PINC ; tok -> type = TK_CHAR_PROPERTY ; tok -> u . prop . not = ( c == 'P' ? 1 : 0 ) ; if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT ) ) { PFETCH ( c2 ) ; if ( c2 == '^' ) { tok -> u . prop . not = ( tok -> u . prop . not == 0 ? 1 : 0 ) ; } else PUNFETCH ; } } break ; case 'x' : if ( PEND ) break ; prev = p ; if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_BRACE_HEX8 ) ) { PINC ; num = scan_unsigned_hexadecimal_number ( & p , end , 8 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ; if ( ! PEND ) { c2 = PPEEK ; if ( ONIGENC_IS_CODE_XDIGIT ( enc , c2 ) ) return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE ; } if ( p > prev + enclen ( enc , prev ) && ! PEND && ( PPEEK_IS ( '}' ) ) ) { PINC ; tok -> type = TK_CODE_POINT ; tok -> base = 16 ; tok -> u . code = ( OnigCodePoint ) num ; } else { p = prev ; } } else if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_HEX2 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 2 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 16 ; tok -> u . c = num ; } break ; case 'u' : if ( PEND ) break ; prev = p ; if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_U_HEX4 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 4 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_CODE_POINT ; tok -> base = 16 ; tok -> u . code = ( OnigCodePoint ) num ; } break ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_OCTAL3 ) ) { PUNFETCH ; prev = p ; num = scan_unsigned_octal_number ( & p , end , 3 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 8 ; tok -> u . c = num ; } break ; default : PUNFETCH ; num = fetch_escaped_value ( & p , end , env , & c2 ) ; if ( num < 0 ) return num ; if ( tok -> u . c != c2 ) { tok -> u . code = c2 ; tok -> type = TK_CODE_POINT ; } break ; } } else if ( c == '[' ) { if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_POSIX_BRACKET ) && ( PPEEK_IS ( ':' ) ) ) { OnigCodePoint send [ ] = { ( OnigCodePoint ) ':' , ( OnigCodePoint ) ']' } ; tok -> backp = p ; PINC ; if ( str_exist_check_with_esc ( send , 2 , p , end , ( OnigCodePoint ) ']' , enc , syn ) ) { tok -> type = TK_POSIX_BRACKET_OPEN ; } else { PUNFETCH ; goto cc_in_cc ; } } else { cc_in_cc : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_CCLASS_SET_OP ) ) { tok -> type = TK_CC_CC_OPEN ; } else { CC_ESC_WARN ( env , ( UChar * ) "[" ) ; } } } else if ( c == '&' ) { if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_CCLASS_SET_OP ) && ! PEND && ( PPEEK_IS ( '&' ) ) ) { PINC ; tok -> type = TK_CC_AND ; } } end : * src = p ; return tok -> type ; }
static int __socket_slurp ( RSocket * s , ut8 * buf , int bufsz ) { int i ; int chsz = 1 ; if ( r_socket_read_block ( s , ( ut8 * ) buf , 1 ) != 1 ) { return 0 ; } for ( i = 1 ; i < bufsz ; i += chsz ) { buf [ i ] = 0 ; r_socket_block_time ( s , 1 , 0 , 1000 ) ; int olen = r_socket_read_block ( s , ( ut8 * ) buf + i , chsz ) ; if ( olen != chsz ) { buf [ i ] = 0 ; break ; } } return i ; }
TryEliminateBoundsCheck ( BoundsCheckMap & checks , size_t blockIndex , MBoundsCheck * dominated , bool * eliminated ) { MOZ_ASSERT ( ! * eliminated ) ; dominated -> replaceAllUsesWith ( dominated -> index ( ) ) ; if ( ! dominated -> isMovable ( ) ) return true ; MBoundsCheck * dominating = FindDominatingBoundsCheck ( checks , dominated , blockIndex ) ; if ( ! dominating ) return false ; if ( dominating == dominated ) { return true ; } if ( dominating -> length ( ) != dominated -> length ( ) ) return true ; SimpleLinearSum sumA = ExtractLinearSum ( dominating -> index ( ) ) ; SimpleLinearSum sumB = ExtractLinearSum ( dominated -> index ( ) ) ; if ( sumA . term != sumB . term ) return true ; * eliminated = true ; int32_t minimumA , maximumA , minimumB , maximumB ; if ( ! SafeAdd ( sumA . constant , dominating -> minimum ( ) , & minimumA ) || ! SafeAdd ( sumA . constant , dominating -> maximum ( ) , & maximumA ) || ! SafeAdd ( sumB . constant , dominated -> minimum ( ) , & minimumB ) || ! SafeAdd ( sumB . constant , dominated -> maximum ( ) , & maximumB ) ) { return false ; } int32_t newMinimum , newMaximum ; if ( ! SafeSub ( Min ( minimumA , minimumB ) , sumA . constant , & newMinimum ) || ! SafeSub ( Max ( maximumA , maximumB ) , sumA . constant , & newMaximum ) ) { return false ; } dominating -> setMinimum ( newMinimum ) ; dominating -> setMaximum ( newMaximum ) ; return true ; }
void Serializer < AllocatorT > :: ObjectSerializer :: Serialize ( ) { if ( FLAG_trace_serializer ) { PrintF ( " Encoding heap object: " ) ; object_ -> ShortPrint ( ) ; PrintF ( "\n" ) ; } if ( object_ -> IsExternalString ( ) ) { SerializeExternalString ( ) ; return ; } else if ( ! serializer_ -> isolate ( ) -> heap ( ) -> InReadOnlySpace ( object_ ) ) { if ( object_ -> IsSeqOneByteString ( ) ) { SeqOneByteString :: cast ( object_ ) -> clear_padding ( ) ; } else if ( object_ -> IsSeqTwoByteString ( ) ) { SeqTwoByteString :: cast ( object_ ) -> clear_padding ( ) ; } } if ( object_ -> IsJSTypedArray ( ) ) { SerializeJSTypedArray ( ) ; return ; } if ( object_ -> IsJSArrayBuffer ( ) ) { SerializeJSArrayBuffer ( ) ; return ; } DCHECK ( ! object_ -> IsFiller ( ) ) ; if ( object_ -> IsScript ( ) ) { Object * undefined = ReadOnlyRoots ( serializer_ -> isolate ( ) ) . undefined_value ( ) ; Script :: cast ( object_ ) -> set_line_ends ( undefined ) ; } SerializeObject ( ) ; }
xmlBufAttrSerializeTxtContent ( xmlBufPtr buf , xmlDocPtr doc , xmlAttrPtr attr , const xmlChar * string ) { xmlChar * base , * cur ; if ( string == NULL ) return ; base = cur = ( xmlChar * ) string ; while ( * cur != 0 ) { if ( * cur == '\n' ) { if ( base != cur ) xmlBufAdd ( buf , base , cur - base ) ; xmlBufAdd ( buf , BAD_CAST "&#10;" , 5 ) ; cur ++ ; base = cur ; } else if ( * cur == '\r' ) { if ( base != cur ) xmlBufAdd ( buf , base , cur - base ) ; xmlBufAdd ( buf , BAD_CAST "&#13;" , 5 ) ; cur ++ ; base = cur ; } else if ( * cur == '\t' ) { if ( base != cur ) xmlBufAdd ( buf , base , cur - base ) ; xmlBufAdd ( buf , BAD_CAST "&#9;" , 4 ) ; cur ++ ; base = cur ; } else if ( * cur == '"' ) { if ( base != cur ) xmlBufAdd ( buf , base , cur - base ) ; xmlBufAdd ( buf , BAD_CAST "&quot;" , 6 ) ; cur ++ ; base = cur ; } else if ( * cur == '<' ) { if ( base != cur ) xmlBufAdd ( buf , base , cur - base ) ; xmlBufAdd ( buf , BAD_CAST "&lt;" , 4 ) ; cur ++ ; base = cur ; } else if ( * cur == '>' ) { if ( base != cur ) xmlBufAdd ( buf , base , cur - base ) ; xmlBufAdd ( buf , BAD_CAST "&gt;" , 4 ) ; cur ++ ; base = cur ; } else if ( * cur == '&' ) { if ( base != cur ) xmlBufAdd ( buf , base , cur - base ) ; xmlBufAdd ( buf , BAD_CAST "&amp;" , 5 ) ; cur ++ ; base = cur ; } else if ( ( * cur >= 0x80 ) && ( cur [ 1 ] != 0 ) && ( ( doc == NULL ) || ( doc -> encoding == NULL ) ) ) { unsigned char tmp [ 12 ] ; int val = 0 , l = 1 ; if ( base != cur ) xmlBufAdd ( buf , base , cur - base ) ; if ( * cur < 0xC0 ) { xmlSaveErr ( XML_SAVE_NOT_UTF8 , ( xmlNodePtr ) attr , NULL ) ; if ( doc != NULL ) doc -> encoding = xmlStrdup ( BAD_CAST "ISO-8859-1" ) ; xmlSerializeHexCharRef ( tmp , * cur ) ; xmlBufAdd ( buf , ( xmlChar * ) tmp , - 1 ) ; cur ++ ; base = cur ; continue ; } else if ( * cur < 0xE0 ) { val = ( cur [ 0 ] ) & 0x1F ; val <<= 6 ; val |= ( cur [ 1 ] ) & 0x3F ; l = 2 ; } else if ( ( * cur < 0xF0 ) && ( cur [ 2 ] != 0 ) ) { val = ( cur [ 0 ] ) & 0x0F ; val <<= 6 ; val |= ( cur [ 1 ] ) & 0x3F ; val <<= 6 ; val |= ( cur [ 2 ] ) & 0x3F ; l = 3 ; } else if ( ( * cur < 0xF8 ) && ( cur [ 2 ] != 0 ) && ( cur [ 3 ] != 0 ) ) { val = ( cur [ 0 ] ) & 0x07 ; val <<= 6 ; val |= ( cur [ 1 ] ) & 0x3F ; val <<= 6 ; val |= ( cur [ 2 ] ) & 0x3F ; val <<= 6 ; val |= ( cur [ 3 ] ) & 0x3F ; l = 4 ; } if ( ( l == 1 ) || ( ! IS_CHAR ( val ) ) ) { xmlSaveErr ( XML_SAVE_CHAR_INVALID , ( xmlNodePtr ) attr , NULL ) ; if ( doc != NULL ) doc -> encoding = xmlStrdup ( BAD_CAST "ISO-8859-1" ) ; xmlSerializeHexCharRef ( tmp , * cur ) ; xmlBufAdd ( buf , ( xmlChar * ) tmp , - 1 ) ; cur ++ ; base = cur ; continue ; } xmlSerializeHexCharRef ( tmp , val ) ; xmlBufAdd ( buf , ( xmlChar * ) tmp , - 1 ) ; cur += l ; base = cur ; } else { cur ++ ; } } if ( base != cur ) xmlBufAdd ( buf , base , cur - base ) ; }
[ & ] ( android :: base :: unique_fd fd , int32_t size ) { + if ( allocationSize > size ) { + android_errorWriteLog ( 0x534e4554 , "213169612" ) ; + return STATUS_BAD_VALUE ; + } int flags = PROT_READ ; if ( isMutable ) { flags |= PROT_WRITE ; } void * addr = mmap ( nullptr , size , flags , MAP_SHARED , fd . get ( ) , 0 ) ; if ( addr == MAP_FAILED ) { const int err = errno ; ALOGW ( "mmap failed, error %d (%s)" , err , strerror ( err ) ) ; - return ; + return STATUS_NO_MEMORY ; } nativeBitmap = Bitmap :: createFrom ( imageInfo , rowBytes , fd . release ( ) , addr , size , ! isMutable ) ; + return STATUS_OK ; } ) ;
add_one_chunk ( png_bytep list , unsigned int count , png_const_bytep add , int keep ) { unsigned int i ; for ( i = 0 ; i < count ; ++ i , list += 5 ) if ( memcmp ( list , add , 4 ) == 0 ) { list [ 4 ] = ( png_byte ) keep ; return count ; } if ( keep != PNG_HANDLE_CHUNK_AS_DEFAULT ) { ++ count ; memcpy ( list , add , 4 ) ; list [ 4 ] = ( png_byte ) keep ; } return count ; }
nsTreeSanitizer :: SanitizeAttributes ( mozilla :: dom :: Element * aElement , nsTHashtable < nsISupportsHashKey > * aAllowed , nsIAtom * * * aURLs , PRBool aAllowXLink , PRBool aAllowStyle , PRBool aAllowDangerousSrc ) { PRUint32 ac = aElement -> GetAttrCount ( ) ; nsresult rv ; for ( PRInt32 i = ac - 1 ; i >= 0 ; -- i ) { rv = NS_OK ; const nsAttrName * attrName = aElement -> GetAttrNameAt ( i ) ; PRInt32 attrNs = attrName -> NamespaceID ( ) ; nsIAtom * attrLocal = attrName -> LocalName ( ) ; if ( kNameSpaceID_None == attrNs ) { if ( aAllowStyle && nsGkAtoms :: style == attrLocal ) { nsCOMPtr < nsIURI > baseURI = aElement -> GetBaseURI ( ) ; nsIDocument * document = aElement -> GetOwnerDoc ( ) ; nsCSSParser parser ( document -> CSSLoader ( ) ) ; nsRefPtr < mozilla :: css :: StyleRule > rule ; nsAutoString value ; aElement -> GetAttr ( attrNs , attrLocal , value ) ; rv = parser . ParseStyleAttribute ( value , document -> GetDocumentURI ( ) , baseURI , document -> NodePrincipal ( ) , getter_AddRefs ( rule ) ) ; if ( NS_SUCCEEDED ( rv ) ) { nsAutoString cleanValue ; if ( SanitizeStyleRule ( rule , cleanValue ) ) { aElement -> SetAttr ( kNameSpaceID_None , nsGkAtoms :: style , cleanValue , PR_FALSE ) ; } } continue ; } if ( aAllowDangerousSrc && nsGkAtoms :: src == attrLocal ) { continue ; } if ( IsURL ( aURLs , attrLocal ) ) { if ( SanitizeURL ( aElement , attrNs , attrLocal ) ) { -- ac ; i = ac ; } continue ; } if ( aAllowed -> GetEntry ( attrLocal ) && ! ( attrLocal == nsGkAtoms :: rel && aElement -> IsHTML ( nsGkAtoms :: link ) ) && ! ( attrLocal == nsGkAtoms :: name && aElement -> IsHTML ( nsGkAtoms :: meta ) ) ) { continue ; } const PRUnichar * localStr = attrLocal -> GetUTF16String ( ) ; if ( * localStr == '_' || ( attrLocal -> GetLength ( ) > 5 && localStr [ 0 ] == 'd' && localStr [ 1 ] == 'a' && localStr [ 2 ] == 't' && localStr [ 3 ] == 'a' && localStr [ 4 ] == '-' ) ) { continue ; } } else if ( kNameSpaceID_XML == attrNs ) { if ( nsGkAtoms :: base == attrLocal ) { if ( SanitizeURL ( aElement , attrNs , attrLocal ) ) { -- ac ; i = ac ; } continue ; } if ( nsGkAtoms :: lang == attrLocal || nsGkAtoms :: space == attrLocal ) { continue ; } } else if ( aAllowXLink && kNameSpaceID_XLink == attrNs ) { if ( nsGkAtoms :: href == attrLocal ) { if ( SanitizeURL ( aElement , attrNs , attrLocal ) ) { -- ac ; i = ac ; } continue ; } if ( nsGkAtoms :: type == attrLocal || nsGkAtoms :: title == attrLocal || nsGkAtoms :: show == attrLocal || nsGkAtoms :: actuate == attrLocal ) { continue ; } } aElement -> UnsetAttr ( kNameSpaceID_None , attrLocal , PR_FALSE ) ; -- ac ; i = ac ; } if ( aElement -> IsHTML ( nsGkAtoms :: video ) || aElement -> IsHTML ( nsGkAtoms :: audio ) ) { aElement -> SetAttr ( kNameSpaceID_None , nsGkAtoms :: controls , EmptyString ( ) , PR_FALSE ) ; } }
BreakIterator :: BreakIterator ( Handle < DebugInfo > debug_info ) : debug_info_ ( debug_info ) , break_index_ ( - 1 ) , source_position_iterator_ ( debug_info -> DebugBytecodeArray ( ) -> SourcePositionTable ( ) ) { position_ = debug_info -> shared ( ) -> StartPosition ( ) ; statement_position_ = position_ ; DCHECK ( ! Done ( ) ) ; Next ( ) ; }
void ArrayIncludesIndexofAssembler :: GenerateHoleyDoubles ( SearchVariant variant , Node * elements , Node * search_element , Node * array_length , Node * from_index ) { VARIABLE ( index_var , MachineType :: PointerRepresentation ( ) , SmiUntag ( from_index ) ) ; Node * array_length_untagged = SmiUntag ( array_length ) ; Label nan_loop ( this , & index_var ) , not_nan_loop ( this , & index_var ) , hole_loop ( this , & index_var ) , search_notnan ( this ) , return_found ( this ) , return_not_found ( this ) ; VARIABLE ( search_num , MachineRepresentation :: kFloat64 ) ; search_num . Bind ( Float64Constant ( 0 ) ) ; GotoIfNot ( TaggedIsSmi ( search_element ) , & search_notnan ) ; search_num . Bind ( SmiToFloat64 ( search_element ) ) ; Goto ( & not_nan_loop ) ; BIND ( & search_notnan ) ; if ( variant == kIncludes ) { GotoIf ( IsUndefined ( search_element ) , & hole_loop ) ; } GotoIfNot ( IsHeapNumber ( search_element ) , & return_not_found ) ; search_num . Bind ( LoadHeapNumberValue ( search_element ) ) ; Label * nan_handling = variant == kIncludes ? & nan_loop : & return_not_found ; BranchIfFloat64IsNaN ( search_num . value ( ) , nan_handling , & not_nan_loop ) ; BIND ( & not_nan_loop ) ; { Label continue_loop ( this ) ; GotoIfNot ( UintPtrLessThan ( index_var . value ( ) , array_length_untagged ) , & return_not_found ) ; Node * element_k = LoadFixedDoubleArrayElement ( elements , index_var . value ( ) , MachineType :: Float64 ( ) ) ; Branch ( Float64Equal ( element_k , search_num . value ( ) ) , & return_found , & continue_loop ) ; BIND ( & continue_loop ) ; Increment ( & index_var ) ; Goto ( & not_nan_loop ) ; } if ( variant == kIncludes ) { BIND ( & nan_loop ) ; Label continue_loop ( this ) ; GotoIfNot ( UintPtrLessThan ( index_var . value ( ) , array_length_untagged ) , & return_not_found ) ; Node * element_k = LoadFixedDoubleArrayElement ( elements , index_var . value ( ) , MachineType :: Float64 ( ) , 0 , INTPTR_PARAMETERS , & continue_loop ) ; BranchIfFloat64IsNaN ( element_k , & return_found , & continue_loop ) ; BIND ( & continue_loop ) ; Increment ( & index_var ) ; Goto ( & nan_loop ) ; } if ( variant == kIncludes ) { BIND ( & hole_loop ) ; GotoIfNot ( UintPtrLessThan ( index_var . value ( ) , array_length_untagged ) , & return_not_found ) ; LoadFixedDoubleArrayElement ( elements , index_var . value ( ) , MachineType :: None ( ) , 0 , INTPTR_PARAMETERS , & return_found ) ; Increment ( & index_var ) ; Goto ( & hole_loop ) ; } BIND ( & return_found ) ; if ( variant == kIncludes ) { Return ( TrueConstant ( ) ) ; } else { Return ( SmiTag ( index_var . value ( ) ) ) ; } BIND ( & return_not_found ) ; if ( variant == kIncludes ) { Return ( FalseConstant ( ) ) ; } else { Return ( NumberConstant ( - 1 ) ) ; } }
void Builtins :: Generate_Call ( MacroAssembler * masm , ConvertReceiverMode mode ) { Label non_callable , non_function , non_smi ; __ JumpIfSmi ( r4 , & non_callable ) ; __ bind ( & non_smi ) ; __ CompareObjectType ( r4 , r7 , r8 , JS_FUNCTION_TYPE ) ; __ Jump ( masm -> isolate ( ) -> builtins ( ) -> CallFunction ( mode ) , RelocInfo :: CODE_TARGET , eq ) ; __ cmpi ( r8 , Operand ( JS_BOUND_FUNCTION_TYPE ) ) ; __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , CallBoundFunction ) , RelocInfo :: CODE_TARGET , eq ) ; __ lbz ( r7 , FieldMemOperand ( r7 , Map :: kBitFieldOffset ) ) ; __ TestBit ( r7 , Map :: IsCallableBit :: kShift , r0 ) ; __ beq ( & non_callable , cr0 ) ; __ cmpi ( r8 , Operand ( JS_PROXY_TYPE ) ) ; __ bne ( & non_function ) ; __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , CallProxy ) , RelocInfo :: CODE_TARGET ) ; __ bind ( & non_function ) ; __ ShiftLeftImm ( r8 , r3 , Operand ( kPointerSizeLog2 ) ) ; __ StorePX ( r4 , MemOperand ( sp , r8 ) ) ; __ LoadNativeContextSlot ( Context :: CALL_AS_FUNCTION_DELEGATE_INDEX , r4 ) ; __ Jump ( masm -> isolate ( ) -> builtins ( ) -> CallFunction ( ConvertReceiverMode :: kNotNullOrUndefined ) , RelocInfo :: CODE_TARGET ) ; __ bind ( & non_callable ) ; { FrameAndConstantPoolScope scope ( masm , StackFrame :: INTERNAL ) ; __ Push ( r4 ) ; __ CallRuntime ( Runtime :: kThrowCalledNonCallable ) ; } }
bool BreakPointInfo :: HasBreakPoint ( Isolate * isolate , Handle < BreakPointInfo > break_point_info , Handle < BreakPoint > break_point ) { if ( break_point_info -> break_points ( ) -> IsUndefined ( isolate ) ) { return false ; } if ( ! break_point_info -> break_points ( ) -> IsFixedArray ( ) ) { return IsEqual ( BreakPoint :: cast ( break_point_info -> break_points ( ) ) , * break_point ) ; } FixedArray * array = FixedArray :: cast ( break_point_info -> break_points ( ) ) ; for ( int i = 0 ; i < array -> length ( ) ; i ++ ) { if ( IsEqual ( BreakPoint :: cast ( array -> get ( i ) ) , * break_point ) ) { return true ; } } return false ; }
asocket * find_local_socket ( unsigned local_id , unsigned peer_id ) { asocket * s ; asocket * result = NULL ; adb_mutex_lock ( & socket_list_lock ) ; for ( s = local_socket_list . next ; s != & local_socket_list ; s = s -> next ) { if ( s -> id != local_id ) { continue ; } if ( peer_id == 0 || ( s -> peer && s -> peer -> id == peer_id ) ) { result = s ; } break ; } adb_mutex_unlock ( & socket_list_lock ) ; return result ; }
static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { EXRContext * s = avctx -> priv_data ; ThreadFrame frame = { . f = data } ; AVFrame * picture = data ; uint8_t * ptr ; int i , y , ret , ymax ; int planes ; int out_line_size ; int nb_blocks ; uint64_t start_offset_table ; uint64_t start_next_scanline ; PutByteContext offset_table_writer ; bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ; if ( ( ret = decode_header ( s , picture ) ) < 0 ) return ret ; switch ( s -> pixel_type ) { case EXR_FLOAT : case EXR_HALF : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_GBRAPF32 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GBRAPF32 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_GBRPF32 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GRAYF32 ; } } break ; case EXR_UINT : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_RGBA64 ; } else { avctx -> pix_fmt = AV_PIX_FMT_YA16 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_RGB48 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GRAY16 ; } } break ; default : av_log ( avctx , AV_LOG_ERROR , "Missing channel list.\n" ) ; return AVERROR_INVALIDDATA ; } if ( s -> apply_trc_type != AVCOL_TRC_UNSPECIFIED ) avctx -> color_trc = s -> apply_trc_type ; switch ( s -> compression ) { case EXR_RAW : case EXR_RLE : case EXR_ZIP1 : s -> scan_lines_per_block = 1 ; break ; case EXR_PXR24 : case EXR_ZIP16 : s -> scan_lines_per_block = 16 ; break ; case EXR_PIZ : case EXR_B44 : case EXR_B44A : s -> scan_lines_per_block = 32 ; break ; default : avpriv_report_missing_feature ( avctx , "Compression %d" , s -> compression ) ; return AVERROR_PATCHWELCOME ; } if ( s -> xmin > s -> xmax || s -> ymin > s -> ymax || s -> ydelta == 0xFFFFFFFF || s -> xdelta == 0xFFFFFFFF ) { av_log ( avctx , AV_LOG_ERROR , "Wrong or missing size information.\n" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = ff_set_dimensions ( avctx , s -> w , s -> h ) ) < 0 ) return ret ; s -> desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; if ( ! s -> desc ) return AVERROR_INVALIDDATA ; if ( s -> desc -> flags & AV_PIX_FMT_FLAG_FLOAT ) { planes = s -> desc -> nb_components ; out_line_size = avctx -> width * 4 ; } else { planes = 1 ; out_line_size = avctx -> width * 2 * s -> desc -> nb_components ; } if ( s -> is_tile ) { nb_blocks = ( ( s -> xdelta + s -> tile_attr . xSize - 1 ) / s -> tile_attr . xSize ) * ( ( s -> ydelta + s -> tile_attr . ySize - 1 ) / s -> tile_attr . ySize ) ; } else { nb_blocks = ( s -> ydelta + s -> scan_lines_per_block - 1 ) / s -> scan_lines_per_block ; } if ( ( ret = ff_thread_get_buffer ( avctx , & frame , 0 ) ) < 0 ) return ret ; if ( bytestream2_get_bytes_left ( & s -> gb ) / 8 < nb_blocks ) return AVERROR_INVALIDDATA ; if ( ! s -> is_tile && bytestream2_peek_le64 ( & s -> gb ) == 0 ) { av_log ( s -> avctx , AV_LOG_DEBUG , "recreating invalid scanline offset table\n" ) ; start_offset_table = bytestream2_tell ( & s -> gb ) ; start_next_scanline = start_offset_table + nb_blocks * 8 ; bytestream2_init_writer ( & offset_table_writer , & avpkt -> data [ start_offset_table ] , nb_blocks * 8 ) ; for ( y = 0 ; y < nb_blocks ; y ++ ) { bytestream2_put_le64 ( & offset_table_writer , start_next_scanline ) ; bytestream2_seek ( & s -> gb , start_next_scanline + 4 , SEEK_SET ) ; start_next_scanline += ( bytestream2_get_le32 ( & s -> gb ) + 8 ) ; } bytestream2_seek ( & s -> gb , start_offset_table , SEEK_SET ) ; } s -> buf = avpkt -> data ; s -> buf_size = avpkt -> size ; for ( i = 0 ; i < planes ; i ++ ) { ptr = picture -> data [ i ] ; for ( y = 0 ; y < s -> ymin ; y ++ ) { memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } s -> picture = picture ; avctx -> execute2 ( avctx , decode_block , s -> thread_data , NULL , nb_blocks ) ; ymax = FFMAX ( 0 , s -> ymax + 1 ) ; for ( i = 0 ; i < planes ; i ++ ) { ptr = picture -> data [ i ] + ( ymax * picture -> linesize [ i ] ) ; for ( y = ymax ; y < avctx -> height ; y ++ ) { memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } picture -> pict_type = AV_PICTURE_TYPE_I ; * got_frame = 1 ; return avpkt -> size ; }
static int smtp_open ( struct Connection * conn , bool esmtp ) { int rc ; if ( mutt_socket_open ( conn ) ) return - 1 ; rc = smtp_get_resp ( conn ) ; if ( rc != 0 ) return rc ; rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; #ifdef USE_SSL enum QuadOption ans = MUTT_NO ; if ( conn -> ssf ) ans = MUTT_NO ; else if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( Capabilities & SMTP_CAP_STARTTLS ) && ( ( ans = query_quadoption ( C_SslStarttls , _ ( "Secure connection with TLS?" ) ) ) == MUTT_ABORT ) ) { return - 1 ; } if ( ans == MUTT_YES ) { if ( mutt_socket_send ( conn , "STARTTLS\r\n" ) < 0 ) return SMTP_ERR_WRITE ; rc = smtp_get_resp ( conn ) ; if ( rc != 0 ) return rc ; if ( mutt_ssl_starttls ( conn ) ) { mutt_error ( _ ( "Could not negotiate TLS connection" ) ) ; return - 1 ; } rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; } #endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! ( Capabilities & SMTP_CAP_AUTH ) ) { mutt_error ( _ ( "SMTP server does not support authentication" ) ) ; return - 1 ; } return smtp_auth ( conn ) ; } return 0 ; }
AttachFinishedCompilations ( JSContext * cx ) { JitCompartment * ion = cx -> compartment ( ) -> jitCompartment ( ) ; if ( ! ion ) return ; types :: AutoEnterAnalysis enterTypes ( cx ) ; AutoLockHelperThreadState lock ; GlobalHelperThreadState :: IonBuilderVector & finished = HelperThreadState ( ) . ionFinishedList ( ) ; TraceLogger * logger = TraceLoggerForMainThread ( cx -> runtime ( ) ) ; while ( true ) { IonBuilder * builder = nullptr ; for ( size_t i = 0 ; i < finished . length ( ) ; i ++ ) { IonBuilder * testBuilder = finished [ i ] ; if ( testBuilder -> compartment == CompileCompartment :: get ( cx -> compartment ( ) ) ) { builder = testBuilder ; HelperThreadState ( ) . remove ( finished , & i ) ; break ; } } if ( ! builder ) break ; #if defined(JS_CODEGEN_X86) || defined(JS_CODEGEN_X64) if ( builder -> info ( ) . executionMode ( ) == SequentialExecution && builder -> script ( ) -> hasIonScript ( ) ) { bool onStack = false ; for ( JitActivationIterator iter ( cx -> runtime ( ) ) ; ! iter . done ( ) ; ++ iter ) { for ( JitFrameIterator it ( iter . jitTop ( ) , SequentialExecution ) ; ! it . done ( ) ; ++ it ) { if ( ! it . isIonJS ( ) ) continue ; if ( it . checkInvalidation ( ) ) continue ; JSScript * script = it . script ( ) ; if ( builder -> script ( ) == script ) { onStack = true ; break ; } } if ( onStack ) break ; } if ( onStack ) { builder -> script ( ) -> setPendingIonBuilder ( cx , builder ) ; HelperThreadState ( ) . ionLazyLinkList ( ) . insertFront ( builder ) ; continue ; } } #endif if ( CodeGenerator * codegen = builder -> backgroundCodegen ( ) ) { RootedScript script ( cx , builder -> script ( ) ) ; IonContext ictx ( cx , & builder -> alloc ( ) ) ; AutoTraceLog logScript ( logger , TraceLogCreateTextId ( logger , script ) ) ; AutoTraceLog logLink ( logger , TraceLogger :: IonLinking ) ; codegen -> masm . constructRoot ( cx ) ; bool success ; { AutoUnlockHelperThreadState unlock ; success = codegen -> link ( cx , builder -> constraints ( ) ) ; } if ( ! success ) { cx -> clearPendingException ( ) ; } } FinishOffThreadBuilder ( cx , builder ) ; } }
IDBCursor :: ~ IDBCursor ( ) { NS_ASSERTION ( NS_IsMainThread ( ) , "Wrong thread!" ) ; NS_ASSERTION ( ! mActorParent , "Actor parent owns us, how can we be dying?!" ) ; if ( mActorChild ) { NS_ASSERTION ( ! IndexedDatabaseManager :: IsMainProcess ( ) , "Wrong process!" ) ; mActorChild -> Send__delete__ ( mActorChild ) ; NS_ASSERTION ( ! mActorChild , "Should have cleared in Send__delete__!" ) ; } if ( mRooted ) { NS_DROP_JS_OBJECTS ( this , IDBCursor ) ; } IDBObjectStore :: ClearStructuredCloneBuffer ( mCloneReadInfo . mCloneBuffer ) ; }
static int xpm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { XPMDecContext * x = avctx -> priv_data ; AVFrame * p = data ; const uint8_t * end , * ptr = avpkt -> data ; int ncolors , cpp , ret , i , j ; int64_t size ; uint32_t * dst ; avctx -> pix_fmt = AV_PIX_FMT_BGRA ; end = avpkt -> data + avpkt -> size ; while ( memcmp ( ptr , "/* XPM */" , 9 ) && ptr < end - 9 ) ptr ++ ; if ( ptr >= end ) { av_log ( avctx , AV_LOG_ERROR , "missing signature\n" ) ; return AVERROR_INVALIDDATA ; } ptr += mod_strcspn ( ptr , "\"" ) ; if ( sscanf ( ptr , "\"%u %u %u %u\"," , & avctx -> width , & avctx -> height , & ncolors , & cpp ) != 4 ) { av_log ( avctx , AV_LOG_ERROR , "missing image parameters\n" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = ff_set_dimensions ( avctx , avctx -> width , avctx -> height ) ) < 0 ) return ret ; if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; if ( cpp <= 0 || cpp >= 5 ) { av_log ( avctx , AV_LOG_ERROR , "unsupported/invalid number of chars per pixel: %d\n" , cpp ) ; return AVERROR_INVALIDDATA ; } size = 1 ; for ( i = 0 ; i < cpp ; i ++ ) size *= 94 ; if ( ncolors <= 0 || ncolors > size ) { av_log ( avctx , AV_LOG_ERROR , "invalid number of colors: %d\n" , ncolors ) ; return AVERROR_INVALIDDATA ; } size *= 4 ; av_fast_padded_malloc ( & x -> pixels , & x -> pixels_size , size ) ; if ( ! x -> pixels ) return AVERROR ( ENOMEM ) ; ptr += mod_strcspn ( ptr , "," ) + 1 ; for ( i = 0 ; i < ncolors ; i ++ ) { const uint8_t * index ; int len ; ptr += mod_strcspn ( ptr , "\"" ) + 1 ; if ( ptr + cpp > end ) return AVERROR_INVALIDDATA ; index = ptr ; ptr += cpp ; ptr = strstr ( ptr , "c " ) ; if ( ptr ) { ptr += 2 ; } else { return AVERROR_INVALIDDATA ; } len = strcspn ( ptr , "\" " ) ; if ( ( ret = ascii2index ( index , cpp ) ) < 0 ) return ret ; x -> pixels [ ret ] = color_string_to_rgba ( ptr , len ) ; ptr += mod_strcspn ( ptr , "," ) + 1 ; } for ( i = 0 ; i < avctx -> height ; i ++ ) { dst = ( uint32_t * ) ( p -> data [ 0 ] + i * p -> linesize [ 0 ] ) ; ptr += mod_strcspn ( ptr , "\"" ) + 1 ; for ( j = 0 ; j < avctx -> width ; j ++ ) { if ( ptr + cpp > end ) return AVERROR_INVALIDDATA ; if ( ( ret = ascii2index ( ptr , cpp ) ) < 0 ) return ret ; * dst ++ = x -> pixels [ ret ] ; ptr += cpp ; } ptr += mod_strcspn ( ptr , "," ) + 1 ; } p -> key_frame = 1 ; p -> pict_type = AV_PICTURE_TYPE_I ; * got_frame = 1 ; return avpkt -> size ; }
void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { Jpeg2000Prec * prec = band -> prec + precno ; av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } av_freep ( & band -> prec ) ; } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }
Node * CodeAssembler :: AtomicCompareExchange ( MachineType type , Node * base , Node * offset , Node * old_value , Node * new_value ) { return raw_assembler ( ) -> AtomicCompareExchange ( type , base , offset , old_value , new_value ) ; }
void HeaderTable :: setCapacity ( uint32_t capacity ) { auto oldCapacity = capacity_ ; capacity_ = capacity ; if ( capacity_ <= oldCapacity ) { evict ( 0 ) ; } else { auto oldTail = tail ( ) ; auto oldLength = table_ . size ( ) ; uint32_t newLength = ( capacity_ > > 5 ) + 1 ; table_ . resize ( newLength ) ; if ( size_ > 0 && oldTail > head_ ) { std :: copy ( table_ . begin ( ) + oldTail , table_ . begin ( ) + oldLength , table_ . begin ( ) + newLength - ( oldLength - oldTail ) ) ; for ( auto & names_it : names_ ) { for ( auto & idx : names_it . second ) { if ( idx >= oldTail ) { DCHECK_LT ( idx + ( table_ . size ( ) - oldLength ) , table_ . size ( ) ) ; idx += ( table_ . size ( ) - oldLength ) ; } else { break ; } } } } } }
bool OutOfProcessInstance :: Init ( uint32_t argc , const char * argn [ ] , const char * argv [ ] ) { pp :: Var document_url_var = pp :: URLUtil_Dev :: Get ( ) -> GetDocumentURL ( this ) ; if ( ! document_url_var . is_string ( ) ) return false ; std :: string document_url = document_url_var . AsString ( ) ; std :: string extension_url = std :: string ( kChromeExtension ) ; std :: string print_preview_url = std :: string ( kChromePrint ) ; if ( ! base :: StringPiece ( document_url ) . starts_with ( kChromeExtension ) && ! base :: StringPiece ( document_url ) . starts_with ( kChromePrint ) ) { return false ; } for ( uint32_t i = 0 ; i < argc ; ++ i ) { if ( strcmp ( argn [ i ] , "full-frame" ) == 0 ) { full_ = true ; break ; } } if ( full_ ) SetPluginToHandleFindRequests ( ) ; pp :: VarDictionary translated_strings ; translated_strings . Set ( kType , kJSSetTranslatedStringsType ) ; translated_strings . Set ( kJSGetPasswordString , GetLocalizedString ( PP_RESOURCESTRING_PDFGETPASSWORD ) ) ; translated_strings . Set ( kJSLoadingString , GetLocalizedString ( PP_RESOURCESTRING_PDFLOADING ) ) ; translated_strings . Set ( kJSLoadFailedString , GetLocalizedString ( PP_RESOURCESTRING_PDFLOAD_FAILED ) ) ; PostMessage ( translated_strings ) ; text_input_ . reset ( new pp :: TextInput_Dev ( this ) ) ; const char * stream_url = nullptr ; const char * original_url = nullptr ; const char * headers = nullptr ; bool is_material = false ; for ( uint32_t i = 0 ; i < argc ; ++ i ) { if ( strcmp ( argn [ i ] , "src" ) == 0 ) original_url = argv [ i ] ; else if ( strcmp ( argn [ i ] , "stream-url" ) == 0 ) stream_url = argv [ i ] ; else if ( strcmp ( argn [ i ] , "headers" ) == 0 ) headers = argv [ i ] ; else if ( strcmp ( argn [ i ] , "is-material" ) == 0 ) is_material = true ; } if ( is_material ) background_color_ = kBackgroundColorMaterial ; else background_color_ = kBackgroundColor ; if ( ! original_url ) return false ; if ( ! stream_url ) stream_url = original_url ; if ( IsPrintPreviewUrl ( original_url ) ) return true ; LoadUrl ( stream_url ) ; url_ = original_url ; return engine_ -> New ( original_url , headers ) ; }
mozJSSubScriptLoader :: ReadScript ( nsIURI * uri , JSContext * cx , JSObject * targetObjArg , const nsAString & charset , const char * uriStr , nsIIOService * serv , nsIPrincipal * principal , bool reuseGlobal , JSScript * * scriptp , JSFunction * * functionp ) { RootedObject target_obj ( cx , targetObjArg ) ; * scriptp = nullptr ; * functionp = nullptr ; nsCOMPtr < nsIChannel > chan ; nsCOMPtr < nsIInputStream > instream ; nsresult rv = NS_NewChannel ( getter_AddRefs ( chan ) , uri , serv , nullptr , nullptr , nsIRequest :: LOAD_NORMAL ) ; if ( NS_SUCCEEDED ( rv ) ) { chan -> SetContentType ( NS_LITERAL_CSTRING ( "application/javascript" ) ) ; rv = chan -> Open ( getter_AddRefs ( instream ) ) ; } if ( NS_FAILED ( rv ) ) { return ReportError ( cx , LOAD_ERROR_NOSTREAM ) ; } int64_t len = - 1 ; rv = chan -> GetContentLength ( & len ) ; if ( NS_FAILED ( rv ) || len == - 1 ) { return ReportError ( cx , LOAD_ERROR_NOCONTENT ) ; } if ( len > INT32_MAX ) { return ReportError ( cx , LOAD_ERROR_CONTENTTOOBIG ) ; } nsCString buf ; rv = NS_ReadInputStreamToString ( instream , buf , len ) ; if ( NS_FAILED ( rv ) ) return rv ; JSErrorReporter er = JS_SetErrorReporter ( cx , xpc :: SystemErrorReporter ) ; JS :: CompileOptions options ( cx ) ; options . setFileAndLine ( uriStr , 1 ) ; if ( ! charset . IsVoid ( ) ) { jschar * scriptBuf = nullptr ; size_t scriptLength = 0 ; rv = nsScriptLoader :: ConvertToUTF16 ( nullptr , reinterpret_cast < const uint8_t * > ( buf . get ( ) ) , len , charset , nullptr , scriptBuf , scriptLength ) ; JS :: SourceBufferHolder srcBuf ( scriptBuf , scriptLength , JS :: SourceBufferHolder :: GiveOwnership ) ; if ( NS_FAILED ( rv ) ) { return ReportError ( cx , LOAD_ERROR_BADCHARSET ) ; } if ( ! reuseGlobal ) { * scriptp = JS :: Compile ( cx , target_obj , options , srcBuf ) ; } else { * functionp = JS :: CompileFunction ( cx , target_obj , options , nullptr , 0 , nullptr , srcBuf ) ; } } else { if ( ! reuseGlobal ) { options . setSourceIsLazy ( true ) ; * scriptp = JS :: Compile ( cx , target_obj , options , buf . get ( ) , len ) ; } else { * functionp = JS :: CompileFunction ( cx , target_obj , options , nullptr , 0 , nullptr , buf . get ( ) , len ) ; } } JS_SetErrorReporter ( cx , er ) ; return NS_OK ; }
void DeclarationScope :: AllocateParameterLocals ( ) { DCHECK ( is_function_scope ( ) ) ; bool has_mapped_arguments = false ; if ( arguments_ != nullptr ) { DCHECK ( ! is_arrow_scope ( ) ) ; if ( MustAllocate ( arguments_ ) && ! has_arguments_parameter_ ) { has_mapped_arguments = GetArgumentsType ( ) == CreateArgumentsType :: kMappedArguments ; } else { arguments_ = nullptr ; } } for ( int i = num_parameters ( ) - 1 ; i >= 0 ; -- i ) { Variable * var = params_ [ i ] ; DCHECK ( ! has_rest_ || var != rest_parameter ( ) ) ; DCHECK_EQ ( this , var -> scope ( ) ) ; if ( has_mapped_arguments ) { var -> set_is_used ( ) ; var -> set_maybe_assigned ( ) ; var -> ForceContextAllocation ( ) ; } AllocateParameter ( var , i ) ; } }
int orangefs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { struct orangefs_inode_s * orangefs_inode = ORANGEFS_I ( inode ) ; int error = 0 ; void * value = NULL ; size_t size = 0 ; const char * name = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { umode_t mode = inode -> i_mode ; error = posix_acl_equiv_mode ( acl , & mode ) ; if ( error < 0 ) { gossip_err ( "%s: posix_acl_equiv_mode err: %d\n" , __func__ , error ) ; return error ; } if ( inode -> i_mode != mode ) SetModeFlag ( orangefs_inode ) ; inode -> i_mode = mode ; mark_inode_dirty_sync ( inode ) ; if ( error == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : gossip_err ( "%s: invalid type %d!\n" , __func__ , type ) ; return - EINVAL ; } gossip_debug ( GOSSIP_ACL_DEBUG , "%s: inode %pU, key %s type %d\n" , __func__ , get_khandle_from_ino ( inode ) , name , type ) ; if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; error = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( error < 0 ) goto out ; } gossip_debug ( GOSSIP_ACL_DEBUG , "%s: name %s, value %p, size %zd, acl %p\n" , __func__ , name , value , size , acl ) ; error = orangefs_inode_setxattr ( inode , name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
void EscapeAndAppendString ( const char * value , std :: string * result ) { * result += '"' ; char number_buffer [ 10 ] ; while ( * value ) { char c = * value ++ ; switch ( c ) { case '\t' : * result += "\\t" ; break ; case '\n' : * result += "\\n" ; break ; case '\"' : * result += "\\\"" ; break ; case '\\' : * result += "\\\\" ; break ; default : if ( c < '\x20' ) { base :: OS :: SNPrintF ( number_buffer , arraysize ( number_buffer ) , "\\u%04X" , static_cast < unsigned > ( static_cast < unsigned char > ( c ) ) ) ; * result += number_buffer ; } else { * result += c ; } } } * result += '"' ; }
static uint8_t avrc_proc_far_msg ( uint8_t handle , uint8_t label , uint8_t cr , BT_HDR * * pp_pkt , tAVRC_MSG_VENDOR * p_msg ) { BT_HDR * p_pkt = * pp_pkt ; uint8_t * p_data ; uint8_t drop_code = 0 ; bool buf_overflow = false ; BT_HDR * p_rsp = NULL ; BT_HDR * p_cmd = NULL ; bool req_continue = false ; BT_HDR * p_pkt_new = NULL ; uint8_t pkt_type ; tAVRC_RASM_CB * p_rcb ; tAVRC_NEXT_CMD avrc_cmd ; tAVRC_STS status ; p_data = ( uint8_t * ) ( p_pkt + 1 ) + p_pkt -> offset ; p_data += AVRC_VENDOR_HDR_SIZE ; pkt_type = * ( p_data + 1 ) & AVRC_PKT_TYPE_MASK ; AVRC_TRACE_DEBUG ( "pkt_type %d" , pkt_type ) ; p_rcb = & avrc_cb . rcb [ handle ] ; if ( pkt_type == AVRC_PKT_SINGLE || pkt_type == AVRC_PKT_START ) { p_rcb -> rasm_offset = 0 ; osi_free_and_reset ( ( void * * ) & p_rcb -> p_rmsg ) ; } if ( pkt_type != AVRC_PKT_SINGLE && cr == AVCT_RSP ) { if ( pkt_type == AVRC_PKT_START ) { p_rcb -> rasm_pdu = * p_data ; p_rcb -> p_rmsg = ( BT_HDR * ) osi_malloc ( BT_DEFAULT_BUFFER_SIZE ) ; memcpy ( p_rcb -> p_rmsg , p_pkt , sizeof ( BT_HDR ) ) ; memcpy ( ( uint8_t * ) ( p_rcb -> p_rmsg + 1 ) , ( uint8_t * ) ( p_pkt + 1 ) + p_pkt -> offset , p_pkt -> len ) ; p_rcb -> p_rmsg -> offset = p_rcb -> rasm_offset = 0 ; osi_free ( p_pkt ) ; * pp_pkt = p_rcb -> p_rmsg ; p_rcb -> p_rmsg -> offset += p_rcb -> p_rmsg -> len ; req_continue = true ; } else if ( p_rcb -> p_rmsg == NULL ) { AVRC_TRACE_DEBUG ( "Received a CONTINUE/END without no corresponding START \  (or previous fragmented response was dropped)" ) ; drop_code = 5 ; osi_free ( p_pkt ) ; * pp_pkt = NULL ; } else { uint16_t buf_len = BT_DEFAULT_BUFFER_SIZE - sizeof ( BT_HDR ) ; p_pkt -> offset += ( AVRC_VENDOR_HDR_SIZE + AVRC_MIN_META_HDR_SIZE ) ; p_pkt -> len -= ( AVRC_VENDOR_HDR_SIZE + AVRC_MIN_META_HDR_SIZE ) ; if ( ( p_rcb -> p_rmsg -> offset + p_pkt -> len ) > buf_len ) { AVRC_TRACE_WARNING ( "Fragmented message too big! - report the partial message" ) ; p_pkt -> len = buf_len - p_rcb -> p_rmsg -> offset ; pkt_type = AVRC_PKT_END ; buf_overflow = true ; } memcpy ( ( uint8_t * ) ( p_rcb -> p_rmsg + 1 ) + p_rcb -> p_rmsg -> offset , ( uint8_t * ) ( p_pkt + 1 ) + p_pkt -> offset , p_pkt -> len ) ; if ( pkt_type == AVRC_PKT_END ) { p_rcb -> p_rmsg -> offset = p_rcb -> rasm_offset ; p_rcb -> p_rmsg -> len += p_pkt -> len ; p_pkt_new = p_rcb -> p_rmsg ; p_rcb -> rasm_offset = 0 ; p_rcb -> p_rmsg = NULL ; p_msg -> p_vendor_data = ( uint8_t * ) ( p_pkt_new + 1 ) + p_pkt_new -> offset ; p_msg -> hdr . ctype = p_msg -> p_vendor_data [ 0 ] & AVRC_CTYPE_MASK ; p_msg -> p_vendor_data += AVRC_VENDOR_HDR_SIZE ; p_msg -> vendor_len = p_pkt_new -> len - AVRC_VENDOR_HDR_SIZE ; p_data = p_msg -> p_vendor_data + 1 ; * p_data ++ = AVRC_PKT_SINGLE ; UINT16_TO_BE_STREAM ( p_data , ( p_msg -> vendor_len - AVRC_MIN_META_HDR_SIZE ) ) ; AVRC_TRACE_DEBUG ( "end frag:%d, total len:%d, offset:%d" , p_pkt -> len , p_pkt_new -> len , p_pkt_new -> offset ) ; } else { p_rcb -> p_rmsg -> offset += p_pkt -> len ; p_rcb -> p_rmsg -> len += p_pkt -> len ; p_pkt_new = NULL ; req_continue = true ; } osi_free ( p_pkt ) ; * pp_pkt = p_pkt_new ; } } if ( cr == AVCT_CMD ) { p_rsp = avrc_proc_vendor_command ( handle , label , * pp_pkt , p_msg ) ; if ( p_rsp ) { AVCT_MsgReq ( handle , label , AVCT_RSP , p_rsp ) ; osi_free_and_reset ( ( void * * ) pp_pkt ) ; drop_code = 3 ; } else if ( p_msg -> hdr . opcode == AVRC_OP_DROP ) { drop_code = 1 ; } else if ( p_msg -> hdr . opcode == AVRC_OP_DROP_N_FREE ) drop_code = 4 ; } else if ( cr == AVCT_RSP ) { if ( req_continue ) { avrc_cmd . pdu = AVRC_PDU_REQUEST_CONTINUATION_RSP ; drop_code = 2 ; } else if ( buf_overflow ) { avrc_cmd . pdu = AVRC_PDU_ABORT_CONTINUATION_RSP ; drop_code = 4 ; } else { return drop_code ; } avrc_cmd . status = AVRC_STS_NO_ERROR ; avrc_cmd . target_pdu = p_rcb -> rasm_pdu ; tAVRC_COMMAND avrc_command ; avrc_command . continu = avrc_cmd ; status = AVRC_BldCommand ( & avrc_command , & p_cmd ) ; if ( status == AVRC_STS_NO_ERROR ) { AVRC_MsgReq ( handle , ( uint8_t ) ( label ) , AVRC_CMD_CTRL , p_cmd ) ; } } return drop_code ; }
IGNITION_HANDLER ( CollectTypeProfile , InterpreterAssembler ) { Node * position = BytecodeOperandImmSmi ( 0 ) ; Node * value = GetAccumulator ( ) ; Node * feedback_vector = LoadFeedbackVector ( ) ; Node * context = GetContext ( ) ; CallRuntime ( Runtime :: kCollectTypeProfile , context , position , value , feedback_vector ) ; Dispatch ( ) ; }
Navigator :: SendBeacon ( const nsAString & aUrl , const Nullable < ArrayBufferViewOrBlobOrStringOrFormData > & aData , ErrorResult & aRv ) { if ( ! mWindow ) { aRv . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return false ; } nsCOMPtr < nsIDocument > doc = mWindow -> GetDoc ( ) ; if ( ! doc ) { aRv . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return false ; } nsIURI * documentURI = doc -> GetDocumentURI ( ) ; if ( ! documentURI ) { aRv . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return false ; } nsCOMPtr < nsIURI > uri ; nsresult rv = nsContentUtils :: NewURIWithDocumentCharset ( getter_AddRefs ( uri ) , aUrl , doc , doc -> GetDocBaseURI ( ) ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_DOM_URL_MISMATCH_ERR ) ; return false ; } nsCOMPtr < nsIPrincipal > principal = doc -> NodePrincipal ( ) ; nsCOMPtr < nsIScriptSecurityManager > secMan = nsContentUtils :: GetSecurityManager ( ) ; uint32_t flags = nsIScriptSecurityManager :: DISALLOW_INHERIT_PRINCIPAL & nsIScriptSecurityManager :: DISALLOW_SCRIPT ; rv = secMan -> CheckLoadURIWithPrincipal ( principal , uri , flags ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( rv ) ; return false ; } int16_t shouldLoad = nsIContentPolicy :: ACCEPT ; rv = NS_CheckContentLoadPolicy ( nsIContentPolicy :: TYPE_BEACON , uri , principal , doc , EmptyCString ( ) , nullptr , & shouldLoad , nsContentUtils :: GetContentPolicy ( ) , nsContentUtils :: GetSecurityManager ( ) ) ; if ( NS_FAILED ( rv ) || NS_CP_REJECTED ( shouldLoad ) ) { aRv . Throw ( NS_ERROR_CONTENT_BLOCKED ) ; return false ; } nsCOMPtr < nsIChannel > channel ; rv = NS_NewChannel ( getter_AddRefs ( channel ) , uri , doc , nsILoadInfo :: SEC_NORMAL , nsIContentPolicy :: TYPE_BEACON ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( rv ) ; return false ; } nsCOMPtr < nsIPrivateBrowsingChannel > pbChannel = do_QueryInterface ( channel ) ; if ( pbChannel ) { nsIDocShell * docShell = mWindow -> GetDocShell ( ) ; nsCOMPtr < nsILoadContext > loadContext = do_QueryInterface ( docShell ) ; if ( loadContext ) { rv = pbChannel -> SetPrivate ( loadContext -> UsePrivateBrowsing ( ) ) ; if ( NS_FAILED ( rv ) ) { NS_WARNING ( "Setting the privacy status on the beacon channel failed" ) ; } } } nsCOMPtr < nsIHttpChannel > httpChannel = do_QueryInterface ( channel ) ; if ( ! httpChannel ) { aRv . Throw ( NS_ERROR_DOM_BAD_URI ) ; return false ; } httpChannel -> SetReferrer ( documentURI ) ; nsCOMPtr < nsIHttpChannelInternal > httpChannelInternal ( do_QueryInterface ( channel ) ) ; nsCOMPtr < mozIThirdPartyUtil > thirdPartyUtil = do_GetService ( THIRDPARTYUTIL_CONTRACTID ) ; if ( ! httpChannelInternal ) { aRv . Throw ( NS_ERROR_DOM_BAD_URI ) ; return false ; } bool isForeign = true ; thirdPartyUtil -> IsThirdPartyWindow ( mWindow , uri , & isForeign ) ; uint32_t thirdPartyFlags = isForeign ? 0 : nsIHttpChannelInternal :: THIRD_PARTY_FORCE_ALLOW ; httpChannelInternal -> SetThirdPartyFlags ( thirdPartyFlags ) ; nsCString mimeType ; if ( ! aData . IsNull ( ) ) { nsCOMPtr < nsIInputStream > in ; if ( aData . Value ( ) . IsString ( ) ) { nsCString stringData = NS_ConvertUTF16toUTF8 ( aData . Value ( ) . GetAsString ( ) ) ; nsCOMPtr < nsIStringInputStream > strStream = do_CreateInstance ( NS_STRINGINPUTSTREAM_CONTRACTID , & rv ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } rv = strStream -> SetData ( stringData . BeginReading ( ) , stringData . Length ( ) ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } mimeType . AssignLiteral ( "text/plain;charset=UTF-8" ) ; in = strStream ; } else if ( aData . Value ( ) . IsArrayBufferView ( ) ) { nsCOMPtr < nsIStringInputStream > strStream = do_CreateInstance ( NS_STRINGINPUTSTREAM_CONTRACTID , & rv ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } const ArrayBufferView & view = aData . Value ( ) . GetAsArrayBufferView ( ) ; view . ComputeLengthAndData ( ) ; rv = strStream -> SetData ( reinterpret_cast < char * > ( view . Data ( ) ) , view . Length ( ) ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } mimeType . AssignLiteral ( "application/octet-stream" ) ; in = strStream ; } else if ( aData . Value ( ) . IsBlob ( ) ) { File & blob = aData . Value ( ) . GetAsBlob ( ) ; rv = blob . GetInternalStream ( getter_AddRefs ( in ) ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } nsAutoString type ; rv = blob . GetType ( type ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } mimeType = NS_ConvertUTF16toUTF8 ( type ) ; } else if ( aData . Value ( ) . IsFormData ( ) ) { nsFormData & form = aData . Value ( ) . GetAsFormData ( ) ; uint64_t len ; nsAutoCString charset ; form . GetSendInfo ( getter_AddRefs ( in ) , & len , mimeType , charset ) ; } else { MOZ_ASSERT ( false , "switch statements not in sync" ) ; aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } nsCOMPtr < nsIUploadChannel2 > uploadChannel = do_QueryInterface ( channel ) ; if ( ! uploadChannel ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } uploadChannel -> ExplicitSetUploadStream ( in , mimeType , - 1 , NS_LITERAL_CSTRING ( "POST" ) , false ) ; } else { httpChannel -> SetRequestMethod ( NS_LITERAL_CSTRING ( "POST" ) ) ; } nsCOMPtr < nsISupportsPriority > p = do_QueryInterface ( channel ) ; if ( p ) { p -> SetPriority ( nsISupportsPriority :: PRIORITY_LOWEST ) ; } nsCOMPtr < nsIClassOfService > cos ( do_QueryInterface ( channel ) ) ; if ( cos ) { cos -> AddClassFlags ( nsIClassOfService :: Background ) ; } nsRefPtr < nsCORSListenerProxy > cors = new nsCORSListenerProxy ( new BeaconStreamListener ( ) , principal , true ) ; rv = cors -> Init ( channel , true ) ; NS_ENSURE_SUCCESS ( rv , false ) ; rv = secMan -> CheckSameOriginURI ( documentURI , uri , false ) ; bool crossOrigin = NS_FAILED ( rv ) ; nsAutoCString contentType , parsedCharset ; rv = NS_ParseContentType ( mimeType , contentType , parsedCharset ) ; if ( crossOrigin && contentType . Length ( ) > 0 && ! contentType . Equals ( APPLICATION_WWW_FORM_URLENCODED ) && ! contentType . Equals ( MULTIPART_FORM_DATA ) && ! contentType . Equals ( TEXT_PLAIN ) ) { nsCOMPtr < nsIChannel > preflightChannel ; nsTArray < nsCString > unsafeHeaders ; unsafeHeaders . AppendElement ( NS_LITERAL_CSTRING ( "Content-Type" ) ) ; rv = NS_StartCORSPreflight ( channel , cors , principal , true , unsafeHeaders , getter_AddRefs ( preflightChannel ) ) ; } else { rv = channel -> AsyncOpen ( cors , nullptr ) ; } if ( NS_FAILED ( rv ) ) { aRv . Throw ( rv ) ; return false ; } return true ; }
LUA_API void * lua_upvalueid ( lua_State * L , int fidx , int n ) { StkId fi = index2addr ( L , fidx ) ; switch ( ttype ( fi ) ) { case LUA_TLCL : { return * getupvalref ( L , fidx , n , NULL ) ; } case LUA_TCCL : { CClosure * f = clCvalue ( fi ) ; api_check ( L , 1 <= n && n <= f -> nupvalues , "invalid upvalue index" ) ; return & f -> upvalue [ n - 1 ] ; } default : { api_check ( L , 0 , "closure expected" ) ; return NULL ; } } }
void StartupSerializer :: SerializeStrongReferences ( ) { Isolate * isolate = this -> isolate ( ) ; CHECK_NULL ( isolate -> thread_manager ( ) -> FirstThreadStateInUse ( ) ) ; CHECK ( isolate -> handle_scope_implementer ( ) -> blocks ( ) -> empty ( ) ) ; isolate -> heap ( ) -> ClearStackLimits ( ) ; isolate -> heap ( ) -> IterateSmiRoots ( this ) ; isolate -> heap ( ) -> SetStackLimits ( ) ; isolate -> heap ( ) -> IterateStrongRoots ( this , VISIT_FOR_SERIALIZATION ) ; }
static T & frame_entry ( Address re_frame , int frame_offset ) { DCHECK_EQ ( kPointerSize , sizeof ( T ) ) ; #ifdef V8_TARGET_ARCH_S390X return reinterpret_cast < T & > ( Memory < uint64_t > ( re_frame + frame_offset ) ) ; #else return reinterpret_cast < T & > ( Memory < uint32_t > ( re_frame + frame_offset ) ) ; #endif }
static int jp2_cdef_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cdef_t * cdef = & box -> data . cdef ; jp2_cdefchan_t * chan ; unsigned int channo ; if ( jp2_getuint16 ( in , & cdef -> numchans ) ) { return - 1 ; } if ( ! ( cdef -> ents = jas_alloc2 ( cdef -> numchans , sizeof ( jp2_cdefchan_t ) ) ) ) { return - 1 ; } for ( channo = 0 ; channo < cdef -> numchans ; ++ channo ) { chan = & cdef -> ents [ channo ] ; if ( jp2_getuint16 ( in , & chan -> channo ) || jp2_getuint16 ( in , & chan -> type ) || jp2_getuint16 ( in , & chan -> assoc ) ) { return - 1 ; } } return 0 ; }
Node * StringBuiltinsAssembler :: CallSearchStringRaw ( Node * const subject_ptr , Node * const subject_length , Node * const search_ptr , Node * const search_length , Node * const start_position ) { Node * const function_addr = ExternalConstant ( ExternalReference :: search_string_raw < SubjectChar , PatternChar > ( ) ) ; Node * const isolate_ptr = ExternalConstant ( ExternalReference :: isolate_address ( isolate ( ) ) ) ; MachineType type_ptr = MachineType :: Pointer ( ) ; MachineType type_intptr = MachineType :: IntPtr ( ) ; Node * const result = CallCFunction6 ( type_intptr , type_ptr , type_ptr , type_intptr , type_ptr , type_intptr , type_intptr , function_addr , isolate_ptr , subject_ptr , subject_length , search_ptr , search_length , start_position ) ; return result ; }
TEST_P ( VP8PostProcessingFilterTest , FilterOutputCheck ) { const int block_width = 16 ; const int block_height = 16 ; const int input_width = block_width ; const int input_height = block_height + 4 ; const int input_stride = input_width ; const int input_size = input_width * input_height ; const int output_width = block_width + 16 ; const int output_height = block_height ; const int output_stride = output_width ; const int output_size = output_width * output_height ; uint8_t * const src_image = reinterpret_cast < uint8_t * > ( vpx_calloc ( input_size , 1 ) ) ; uint8_t * const dst_image = reinterpret_cast < uint8_t * > ( vpx_calloc ( output_size , 1 ) ) ; uint8_t * const src_image_ptr = src_image + ( input_stride < < 1 ) ; uint8_t * const dst_image_ptr = dst_image + 8 ; uint8_t * const flimits = reinterpret_cast < uint8_t * > ( vpx_memalign ( 16 , block_width ) ) ; ( void ) vpx_memset ( flimits , 255 , block_width ) ; ( void ) vpx_memset ( src_image , 10 , input_size ) ; uint8_t * pixel_ptr = src_image_ptr ; for ( int i = 0 ; i < block_height ; ++ i ) { for ( int j = 0 ; j < block_width ; ++ j ) { pixel_ptr [ j ] = 1 ; } pixel_ptr += input_stride ; } ( void ) vpx_memset ( dst_image , 99 , output_size ) ; REGISTER_STATE_CHECK ( GetParam ( ) ( src_image_ptr , dst_image_ptr , input_stride , output_stride , block_width , flimits , 16 ) ) ; static const uint8_t expected_data [ block_height ] = { 4 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 4 } ; pixel_ptr = dst_image_ptr ; for ( int i = 0 ; i < block_height ; ++ i ) { for ( int j = 0 ; j < block_width ; ++ j ) { EXPECT_EQ ( expected_data [ i ] , pixel_ptr [ j ] ) < < "VP8PostProcessingFilterTest failed with invalid filter output" ; } pixel_ptr += output_stride ; } vpx_free ( src_image ) ; vpx_free ( dst_image ) ; vpx_free ( flimits ) ; } ;
movemark ( int count ) { pos_T * pos ; xfmark_T * jmp ; cleanup_jumplist ( curwin , TRUE ) ; if ( curwin -> w_jumplistlen == 0 ) return ( pos_T * ) NULL ; for ( ; ; ) { if ( curwin -> w_jumplistidx + count < 0 || curwin -> w_jumplistidx + count >= curwin -> w_jumplistlen ) return ( pos_T * ) NULL ; if ( curwin -> w_jumplistidx == curwin -> w_jumplistlen ) { setpcmark ( ) ; -- curwin -> w_jumplistidx ; if ( curwin -> w_jumplistidx + count < 0 ) return ( pos_T * ) NULL ; } curwin -> w_jumplistidx += count ; jmp = curwin -> w_jumplist + curwin -> w_jumplistidx ; if ( jmp -> fmark . fnum == 0 ) fname2fnum ( jmp ) ; if ( jmp -> fmark . fnum != curbuf -> b_fnum ) { if ( buflist_findnr ( jmp -> fmark . fnum ) == NULL ) { count += count < 0 ? - 1 : 1 ; continue ; } if ( buflist_getfile ( jmp -> fmark . fnum , jmp -> fmark . mark . lnum , 0 , FALSE ) == FAIL ) return ( pos_T * ) NULL ; curwin -> w_cursor = jmp -> fmark . mark ; pos = ( pos_T * ) - 1 ; } else pos = & ( jmp -> fmark . mark ) ; return pos ; } }
bool Code :: CanDeoptAt ( Address pc ) { DeoptimizationInputData * deopt_data = DeoptimizationInputData :: cast ( deoptimization_data ( ) ) ; Address code_start_address = instruction_start ( ) ; for ( int i = 0 ; i < deopt_data -> DeoptCount ( ) ; i ++ ) { if ( deopt_data -> Pc ( i ) -> value ( ) == - 1 ) continue ; Address address = code_start_address + deopt_data -> Pc ( i ) -> value ( ) ; if ( address == pc && deopt_data -> AstId ( i ) != BailoutId :: None ( ) ) { return true ; } } return false ; }
std :: ostream & operator < < ( std :: ostream & os , const RuntimeFunction & b ) { os < < "runtime function " < < * b . signature ( ) . return_type < < " " < < b . name ( ) < < b . signature ( ) . parameter_types ; return os ; }
void CompilerDispatcher :: MemoryPressureNotification ( v8 :: MemoryPressureLevel level , bool is_isolate_locked ) { MemoryPressureLevel previous = memory_pressure_level_ . Value ( ) ; memory_pressure_level_ . SetValue ( level ) ; if ( previous != MemoryPressureLevel :: kNone || level == MemoryPressureLevel :: kNone ) { return ; } if ( trace_compiler_dispatcher_ ) { PrintF ( "CompilerDispatcher: received memory pressure notification\n" ) ; } if ( is_isolate_locked ) { AbortAll ( BlockingBehavior :: kDontBlock ) ; } else { { base :: LockGuard < base :: Mutex > lock ( & mutex_ ) ; if ( abort_ ) return ; abort_ = true ; pending_background_jobs_ . clear ( ) ; } platform_ -> CallOnForegroundThread ( reinterpret_cast < v8 :: Isolate * > ( isolate_ ) , new MemoryPressureTask ( task_manager_ . get ( ) , this ) ) ; } }
static void cp2112_gpio_set ( struct gpio_chip * chip , unsigned offset , int value ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; unsigned long flags ; int ret ; spin_lock_irqsave ( & dev -> lock , flags ) ; buf [ 0 ] = CP2112_GPIO_SET ; buf [ 1 ] = value ? 0xff : 0 ; buf [ 2 ] = 1 < < offset ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_SET , buf , CP2112_GPIO_SET_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) hid_err ( hdev , "error setting GPIO values: %d\n" , ret ) ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; }
RUNTIME_FUNCTION ( Runtime_NumberToString ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 1 , args . length ( ) ) ; CONVERT_NUMBER_ARG_HANDLE_CHECKED ( number , 0 ) ; return * isolate -> factory ( ) -> NumberToString ( number ) ; }
void offload_vendor_callback ( tBTM_VSC_CMPL * param ) { uint8_t status = 0 ; uint8_t sub_opcode = 0 ; if ( param -> param_len ) { APPL_TRACE_DEBUG ( "%s: param_len = %d status = %d" , __func__ , param -> param_len , param -> p_param_buf [ 0 ] ) ; status = param -> p_param_buf [ 0 ] ; } if ( status == 0 ) { sub_opcode = param -> p_param_buf [ 1 ] ; APPL_TRACE_DEBUG ( "%s: subopcode = %d" , __func__ , sub_opcode ) ; switch ( sub_opcode ) { case VS_HCI_A2DP_OFFLOAD_STOP : APPL_TRACE_DEBUG ( "%s: VS_HCI_STOP_A2DP_MEDIA successful" , __func__ ) ; break ; case VS_HCI_A2DP_OFFLOAD_START : ( * bta_av_cb . p_cback ) ( BTA_AV_OFFLOAD_START_RSP_EVT , ( tBTA_AV * ) & status ) ; break ; default : break ; } } else { APPL_TRACE_DEBUG ( "%s: Offload failed for subopcode= %d" , __func__ , sub_opcode ) ; if ( param -> opcode != VS_HCI_A2DP_OFFLOAD_STOP ) ( * bta_av_cb . p_cback ) ( BTA_AV_OFFLOAD_START_RSP_EVT , ( tBTA_AV * ) & status ) ; } }
long AudioTrack :: Parse ( Segment * pSegment , const Info & info , long long element_start , long long element_size , AudioTrack * & pResult ) { if ( pResult ) return - 1 ; if ( info . type != Track :: kAudio ) return - 1 ; IMkvReader * const pReader = pSegment -> m_pReader ; const Settings & s = info . settings ; assert ( s . start >= 0 ) ; assert ( s . size >= 0 ) ; long long pos = s . start ; assert ( pos >= 0 ) ; const long long stop = pos + s . size ; double rate = 8000.0 ; long long channels = 1 ; long long bit_depth = 0 ; while ( pos < stop ) { long long id , size ; long status = ParseElementHeader ( pReader , pos , stop , id , size ) ; if ( status < 0 ) return status ; if ( id == 0x35 ) { status = UnserializeFloat ( pReader , pos , size , rate ) ; if ( status < 0 ) return status ; if ( rate <= 0 ) return E_FILE_FORMAT_INVALID ; } else if ( id == 0x1F ) { channels = UnserializeUInt ( pReader , pos , size ) ; if ( channels <= 0 ) return E_FILE_FORMAT_INVALID ; } else if ( id == 0x2264 ) { bit_depth = UnserializeUInt ( pReader , pos , size ) ; if ( bit_depth <= 0 ) return E_FILE_FORMAT_INVALID ; } pos += size ; assert ( pos <= stop ) ; } assert ( pos == stop ) ; AudioTrack * const pTrack = new ( std :: nothrow ) AudioTrack ( pSegment , element_start , element_size ) ; if ( pTrack == NULL ) return - 1 ; const int status = info . Copy ( pTrack -> m_info ) ; if ( status ) { delete pTrack ; return status ; } pTrack -> m_rate = rate ; pTrack -> m_channels = channels ; pTrack -> m_bitDepth = bit_depth ; pResult = pTrack ; return 0 ; }
PresShell :: RestoreRootScrollPosition ( ) { nsCOMPtr < nsILayoutHistoryState > historyState = mDocument -> GetLayoutHistoryState ( ) ; nsAutoScriptBlocker scriptBlocker ; if ( historyState ) { nsIFrame * scrollFrame = GetRootScrollFrame ( ) ; if ( scrollFrame ) { nsIScrollableFrame * scrollableFrame = do_QueryFrame ( scrollFrame ) ; if ( scrollableFrame ) { FrameManager ( ) -> RestoreFrameStateFor ( scrollFrame , historyState , nsIStatefulFrame :: eDocumentScrollState ) ; scrollableFrame -> ScrollToRestoredPosition ( ) ; } } } }
FrameIter :: callee ( ) const { switch ( data_ . state_ ) { case DONE : case ASMJS : break ; case INTERP : MOZ_ASSERT ( isFunctionFrame ( ) ) ; return & interpFrame ( ) -> callee ( ) ; case JIT : if ( data_ . jitFrames_ . isBaselineJS ( ) ) return data_ . jitFrames_ . callee ( ) ; MOZ_ASSERT ( data_ . jitFrames_ . isIonJS ( ) ) ; return ionInlineFrames_ . callee ( ) ; } MOZ_CRASH ( "Unexpected state" ) ; }
fromBufferWithProto ( JSContext * cx , HandleObject bufobj , uint32_t byteOffset , int32_t lengthInt , HandleObject proto ) { ESClassValue cls ; if ( ! GetBuiltinClass ( cx , bufobj , & cls ) ) return nullptr ; if ( cls != ESClass_ArrayBuffer && cls != ESClass_SharedArrayBuffer ) { JS_ReportErrorNumber ( cx , GetErrorMessage , nullptr , JSMSG_TYPED_ARRAY_BAD_ARGS ) ; return nullptr ; } MOZ_ASSERT ( IsArrayBuffer ( bufobj ) || IsSharedArrayBuffer ( bufobj ) || bufobj -> is < ProxyObject > ( ) ) ; if ( bufobj -> is < ProxyObject > ( ) ) { JSObject * wrapped = CheckedUnwrap ( bufobj ) ; if ( ! wrapped ) { JS_ReportError ( cx , "Permission denied to access object" ) ; return nullptr ; } if ( IsArrayBuffer ( wrapped ) || IsSharedArrayBuffer ( wrapped ) ) { RootedObject protoRoot ( cx , proto ) ; if ( ! protoRoot ) { if ( ! GetBuiltinPrototype ( cx , JSCLASS_CACHED_PROTO_KEY ( instanceClass ( ) ) , & protoRoot ) ) return nullptr ; } FixedInvokeArgs < 3 > args ( cx ) ; args [ 0 ] . setNumber ( byteOffset ) ; args [ 1 ] . setInt32 ( lengthInt ) ; args [ 2 ] . setObject ( * protoRoot ) ; RootedValue fval ( cx , cx -> global ( ) -> createArrayFromBuffer < NativeType > ( ) ) ; RootedValue thisv ( cx , ObjectValue ( * bufobj ) ) ; RootedValue rval ( cx ) ; if ( ! js :: Call ( cx , fval , thisv , args , & rval ) ) return nullptr ; return & rval . toObject ( ) ; } } if ( ! IsArrayBuffer ( bufobj ) && ! IsSharedArrayBuffer ( bufobj ) ) { JS_ReportErrorNumber ( cx , GetErrorMessage , nullptr , JSMSG_TYPED_ARRAY_BAD_ARGS ) ; return nullptr ; } Rooted < ArrayBufferObjectMaybeShared * > buffer ( cx ) ; if ( IsArrayBuffer ( bufobj ) ) { ArrayBufferObject & buf = AsArrayBuffer ( bufobj ) ; if ( buf . isDetached ( ) ) { JS_ReportErrorNumber ( cx , GetErrorMessage , nullptr , JSMSG_TYPED_ARRAY_DETACHED ) ; return nullptr ; } buffer = static_cast < ArrayBufferObjectMaybeShared * > ( & buf ) ; } else { buffer = static_cast < ArrayBufferObjectMaybeShared * > ( & AsSharedArrayBuffer ( bufobj ) ) ; } if ( byteOffset > buffer -> byteLength ( ) || byteOffset % sizeof ( NativeType ) != 0 ) { JS_ReportErrorNumber ( cx , GetErrorMessage , nullptr , JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS ) ; return nullptr ; } uint32_t len ; if ( lengthInt == - 1 ) { len = ( buffer -> byteLength ( ) - byteOffset ) / sizeof ( NativeType ) ; if ( len * sizeof ( NativeType ) != buffer -> byteLength ( ) - byteOffset ) { JS_ReportErrorNumber ( cx , GetErrorMessage , nullptr , JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS ) ; return nullptr ; } } else { len = uint32_t ( lengthInt ) ; } uint32_t arrayByteLength = len * sizeof ( NativeType ) ; if ( len >= INT32_MAX / sizeof ( NativeType ) || byteOffset >= INT32_MAX - arrayByteLength ) { JS_ReportErrorNumber ( cx , GetErrorMessage , nullptr , JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS ) ; return nullptr ; } if ( arrayByteLength + byteOffset > buffer -> byteLength ( ) ) { JS_ReportErrorNumber ( cx , GetErrorMessage , nullptr , JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS ) ; return nullptr ; } return makeInstance ( cx , buffer , byteOffset , len , proto ) ; }
nsSecureBrowserUIImpl :: nsSecureBrowserUIImpl ( ) : mReentrantMonitor ( "nsSecureBrowserUIImpl.mReentrantMonitor" ) , mNotifiedSecurityState ( lis_no_security ) , mNotifiedToplevelIsEV ( false ) , mNewToplevelSecurityState ( STATE_IS_INSECURE ) , mNewToplevelIsEV ( false ) , mNewToplevelSecurityStateKnown ( true ) , mIsViewSource ( false ) , mSubRequestsHighSecurity ( 0 ) , mSubRequestsLowSecurity ( 0 ) , mSubRequestsBrokenSecurity ( 0 ) , mSubRequestsNoSecurity ( 0 ) #ifdef DEBUG , mOnStateLocationChangeReentranceDetection ( 0 ) #endif { mTransferringRequests . ops = nsnull ; ResetStateTracking ( ) ; #if defined(PR_LOGGING) if ( ! gSecureDocLog ) gSecureDocLog = PR_NewLogModule ( "nsSecureBrowserUI" ) ; #endif /* PR_LOGGING */ }
njs_promise_perform_all_handler ( njs_vm_t * vm , njs_iterator_args_t * args , njs_value_t * value , int64_t index ) { njs_int_t ret ; njs_array_t * array ; njs_value_t arguments [ 2 ] , next ; njs_function_t * on_fulfilled ; njs_promise_capability_t * capability ; njs_promise_all_context_t * context ; njs_promise_iterator_args_t * pargs ; pargs = ( njs_promise_iterator_args_t * ) args ; capability = pargs -> capability ; array = args -> data ; njs_set_undefined ( & array -> start [ index ] ) ; ret = njs_function_call ( vm , pargs -> function , pargs -> constructor , value , 1 , & next ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return ret ; } on_fulfilled = njs_promise_create_function ( vm , sizeof ( njs_promise_all_context_t ) ) ; if ( njs_slow_path ( on_fulfilled == NULL ) ) { return NJS_ERROR ; } on_fulfilled -> u . native = njs_promise_all_resolve_element_functions ; on_fulfilled -> args_count = 1 ; context = on_fulfilled -> context ; context -> already_called = 0 ; context -> index = ( uint32_t ) index ; context -> values = pargs -> args . data ; context -> capability = capability ; context -> remaining_elements = pargs -> remaining ; ( * pargs -> remaining ) ++ ; njs_set_function ( & arguments [ 0 ] , on_fulfilled ) ; arguments [ 1 ] = capability -> reject ; ret = njs_promise_invoke_then ( vm , & next , arguments , 2 ) ; if ( njs_slow_path ( ret == NJS_ERROR ) ) { return ret ; } return NJS_OK ; }
bool ProcessComposite ( Buffer * composite_stream , uint8_t * dst , size_t dst_size , size_t * glyph_size , bool * have_instructions ) { size_t start_offset = composite_stream -> offset ( ) ; bool we_have_instructions = false ; uint16_t flags = FLAG_MORE_COMPONENTS ; while ( flags & FLAG_MORE_COMPONENTS ) { if ( PREDICT_FALSE ( ! composite_stream -> ReadU16 ( & flags ) ) ) { return FONT_COMPRESSION_FAILURE ( ) ; } we_have_instructions |= ( flags & FLAG_WE_HAVE_INSTRUCTIONS ) != 0 ; size_t arg_size = 2 ; if ( flags & FLAG_ARG_1_AND_2_ARE_WORDS ) { arg_size += 4 ; } else { arg_size += 2 ; } if ( flags & FLAG_WE_HAVE_A_SCALE ) { arg_size += 2 ; } else if ( flags & FLAG_WE_HAVE_AN_X_AND_Y_SCALE ) { arg_size += 4 ; } else if ( flags & FLAG_WE_HAVE_A_TWO_BY_TWO ) { arg_size += 8 ; } if ( PREDICT_FALSE ( ! composite_stream -> Skip ( arg_size ) ) ) { return FONT_COMPRESSION_FAILURE ( ) ; } } size_t composite_glyph_size = composite_stream -> offset ( ) - start_offset ; if ( PREDICT_FALSE ( composite_glyph_size + kCompositeGlyphBegin > dst_size ) ) { return FONT_COMPRESSION_FAILURE ( ) ; } Store16 ( dst , 0 , 0xffff ) ; std :: memcpy ( dst + kCompositeGlyphBegin , composite_stream -> buffer ( ) + start_offset , composite_glyph_size ) ; * glyph_size = kCompositeGlyphBegin + composite_glyph_size ; * have_instructions = we_have_instructions ; return true ; }
Win32MemoryMappedFile :: ~ Win32MemoryMappedFile ( ) { if ( memory_ ) UnmapViewOfFile ( memory_ ) ; CloseHandle ( file_mapping_ ) ; CloseHandle ( file_ ) ; }
NS_IMPL_ISUPPORTS ( ServiceWorkerInterceptController , nsINetworkInterceptController ) NS_IMETHODIMP ServiceWorkerInterceptController :: ShouldPrepareForIntercept ( nsIURI * aURI , nsIChannel * aChannel , bool * aShouldIntercept ) { * aShouldIntercept = false ; nsCOMPtr < nsILoadInfo > loadInfo = aChannel -> LoadInfo ( ) ; RefPtr < ServiceWorkerManager > swm = ServiceWorkerManager :: GetInstance ( ) ; if ( ! nsContentUtils :: IsNonSubresourceRequest ( aChannel ) ) { const Maybe < ServiceWorkerDescriptor > & controller = loadInfo -> GetController ( ) ; if ( controller . isSome ( ) ) { * aShouldIntercept = controller . ref ( ) . HandlesFetch ( ) ; if ( ! * aShouldIntercept && swm ) { nsCOMPtr < nsIPrincipal > principal = controller . ref ( ) . GetPrincipal ( ) . unwrap ( ) ; RefPtr < ServiceWorkerRegistrationInfo > registration = swm -> GetRegistration ( principal , controller . ref ( ) . Scope ( ) ) ; if ( NS_WARN_IF ( ! registration ) ) { return NS_OK ; } registration -> MaybeScheduleTimeCheckAndUpdate ( ) ; } } else { * aShouldIntercept = false ; } return NS_OK ; } nsCOMPtr < nsIPrincipal > principal ; nsresult rv = StoragePrincipalHelper :: GetPrincipal ( aChannel , StaticPrefs :: privacy_partition_serviceWorkers ( ) ? StoragePrincipalHelper :: eForeignPartitionedPrincipal : StoragePrincipalHelper :: eRegularPrincipal , getter_AddRefs ( principal ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! swm || ! swm -> IsAvailable ( principal , aURI , aChannel ) ) { return NS_OK ; } if ( ! nsContentUtils :: ComputeIsSecureContext ( aChannel ) && ! StaticPrefs :: dom_serviceWorkers_testing_enabled ( ) ) { return NS_OK ; } auto storageAccess = StorageAllowedForChannel ( aChannel ) ; if ( storageAccess != StorageAccess :: eAllow ) { if ( ! StaticPrefs :: privacy_partition_serviceWorkers ( ) ) { return NS_OK ; } nsCOMPtr < nsICookieJarSettings > cookieJarSettings ; loadInfo -> GetCookieJarSettings ( getter_AddRefs ( cookieJarSettings ) ) ; if ( ! StoragePartitioningEnabled ( storageAccess , cookieJarSettings ) ) { return NS_OK ; } } * aShouldIntercept = true ; return NS_OK ; }
TNode < JSArray > IntlBuiltinsAssembler :: AllocateEmptyJSArray ( TNode < Context > context ) { return CAST ( CodeStubAssembler :: AllocateJSArray ( PACKED_ELEMENTS , LoadJSArrayElementsMap ( PACKED_ELEMENTS , LoadNativeContext ( context ) ) , SmiConstant ( 0 ) , SmiConstant ( 0 ) ) ) ; }
TRANSPORTDEC_ERROR AudioSpecificConfig_Parse ( CSAudioSpecificConfig * self , HANDLE_FDK_BITSTREAM bs , int fExplicitBackwardCompatible , CSTpCallBacks * cb , UCHAR configMode , UCHAR configChanged , AUDIO_OBJECT_TYPE m_aot ) { TRANSPORTDEC_ERROR ErrorStatus = TRANSPORTDEC_OK ; UINT ascStartAnchor = FDKgetValidBits ( bs ) ; int frameLengthFlag = - 1 ; AudioSpecificConfig_Init ( self ) ; self -> configMode = configMode ; self -> AacConfigChanged = configChanged ; self -> SbrConfigChanged = configChanged ; self -> SacConfigChanged = configChanged ; if ( m_aot != AOT_NULL_OBJECT ) { self -> m_aot = m_aot ; } else { self -> m_aot = getAOT ( bs ) ; self -> m_samplingFrequency = getSampleRate ( bs , & self -> m_samplingFrequencyIndex , 4 ) ; if ( self -> m_samplingFrequency <= 0 ) { return TRANSPORTDEC_PARSE_ERROR ; } self -> m_channelConfiguration = FDKreadBits ( bs , 4 ) ; self -> m_sbrPresentFlag = 0 ; self -> m_psPresentFlag = 0 ; if ( self -> m_aot == AOT_SBR || self -> m_aot == AOT_PS ) { self -> m_extensionAudioObjectType = AOT_SBR ; self -> m_sbrPresentFlag = 1 ; if ( self -> m_aot == AOT_PS ) { self -> m_psPresentFlag = 1 ; } self -> m_extensionSamplingFrequency = getSampleRate ( bs , & self -> m_extensionSamplingFrequencyIndex , 4 ) ; self -> m_aot = getAOT ( bs ) ; switch ( self -> m_aot ) { case AOT_AAC_LC : break ; case AOT_ER_BSAC : break ; default : return TRANSPORTDEC_UNSUPPORTED_FORMAT ; } if ( self -> m_aot == AOT_ER_BSAC ) { self -> m_extensionChannelConfiguration = FDKreadBits ( bs , 4 ) ; } } else { self -> m_extensionAudioObjectType = AOT_NULL_OBJECT ; } } switch ( self -> m_aot ) { case AOT_AAC_LC : case AOT_AAC_SCAL : case AOT_ER_AAC_LC : case AOT_ER_AAC_LD : case AOT_ER_AAC_SCAL : case AOT_ER_BSAC : if ( ( ErrorStatus = GaSpecificConfig_Parse ( & self -> m_sc . m_gaSpecificConfig , self , bs , ascStartAnchor ) ) != TRANSPORTDEC_OK ) { return ( ErrorStatus ) ; } frameLengthFlag = self -> m_sc . m_gaSpecificConfig . m_frameLengthFlag ; break ; case AOT_MPEGS : if ( cb -> cbSsc != NULL ) { if ( cb -> cbSsc ( cb -> cbSscData , bs , self -> m_aot , self -> m_samplingFrequency , 1 , - 1 , 0 , self -> configMode , & self -> SacConfigChanged ) ) { return TRANSPORTDEC_UNSUPPORTED_FORMAT ; } } else { return TRANSPORTDEC_UNSUPPORTED_FORMAT ; } break ; case AOT_ER_AAC_ELD : if ( ( ErrorStatus = EldSpecificConfig_Parse ( self , bs , cb ) ) != TRANSPORTDEC_OK ) { return ( ErrorStatus ) ; } frameLengthFlag = self -> m_sc . m_eldSpecificConfig . m_frameLengthFlag ; self -> m_sbrPresentFlag = self -> m_sc . m_eldSpecificConfig . m_sbrPresentFlag ; self -> m_extensionSamplingFrequency = ( self -> m_sc . m_eldSpecificConfig . m_sbrSamplingRate + 1 ) * self -> m_samplingFrequency ; break ; case AOT_USAC : if ( ( ErrorStatus = UsacConfig_Parse ( self , bs , cb ) ) != TRANSPORTDEC_OK ) { return ( ErrorStatus ) ; } break ; default : return TRANSPORTDEC_UNSUPPORTED_FORMAT ; } switch ( self -> m_aot ) { case AOT_AAC_LC : case AOT_AAC_SCAL : case AOT_ER_AAC_LC : case AOT_ER_AAC_SCAL : case AOT_ER_BSAC : if ( ! frameLengthFlag ) self -> m_samplesPerFrame = 1024 ; else self -> m_samplesPerFrame = 960 ; break ; case AOT_ER_AAC_LD : if ( ! frameLengthFlag ) self -> m_samplesPerFrame = 512 ; else self -> m_samplesPerFrame = 480 ; break ; default : break ; } switch ( self -> m_aot ) { case AOT_ER_AAC_LC : case AOT_ER_AAC_LD : case AOT_ER_AAC_ELD : case AOT_ER_AAC_SCAL : case AOT_ER_CELP : case AOT_ER_HVXC : case AOT_ER_BSAC : self -> m_epConfig = FDKreadBits ( bs , 2 ) ; if ( self -> m_epConfig > 1 ) { return TRANSPORTDEC_UNSUPPORTED_FORMAT ; } break ; default : break ; } if ( fExplicitBackwardCompatible && ( self -> m_aot == AOT_AAC_LC || self -> m_aot == AOT_ER_AAC_LD || self -> m_aot == AOT_ER_BSAC ) ) { ErrorStatus = AudioSpecificConfig_ExtensionParse ( self , bs , cb ) ; } if ( ( ErrorStatus == TRANSPORTDEC_OK ) && ( self -> m_aot == AOT_USAC ) ) { INT configSize_bits = ( INT ) FDKgetValidBits ( bs ) - ( INT ) ascStartAnchor ; StoreConfigAsBitstream ( bs , configSize_bits , self -> config , TP_USAC_MAX_CONFIG_LEN ) ; self -> configBits = fAbs ( configSize_bits ) ; } return ( ErrorStatus ) ; }
initialise_banding ( fz_context * ctx , render_details * render , int color ) { size_t min_band_mem ; int bpp , h , w , reps ; render -> colorspace = output_cs ; render -> format = output_format ; #if GREY_FALLBACK != 0 if ( color == 0 ) { if ( render -> colorspace == CS_RGB ) { render -> colorspace = CS_GRAY ; render -> format = OUT_PGM ; } else if ( render -> colorspace == CS_CMYK ) { render -> colorspace = CS_GRAY ; if ( render -> format == OUT_PKM ) render -> format = OUT_PBM ; else render -> format = OUT_PGM ; } } #endif switch ( render -> colorspace ) { case CS_GRAY : bpp = 1 ; break ; case CS_RGB : bpp = 2 ; break ; default : case CS_CMYK : bpp = 3 ; break ; } w = render -> ibounds . x1 - render -> ibounds . x0 ; min_band_mem = ( size_t ) bpp * w * min_band_height ; reps = ( int ) ( max_band_memory / min_band_mem ) ; if ( reps < 1 ) reps = 1 ; if ( render -> num_workers > 0 ) { int runs , num_bands ; h = render -> ibounds . y1 - render -> ibounds . y0 ; num_bands = ( h + min_band_height - 1 ) / min_band_height ; runs = ( num_bands + reps - 1 ) / reps ; runs = ( ( runs + render -> num_workers - 1 ) / render -> num_workers ) * render -> num_workers ; reps = ( num_bands + runs - 1 ) / runs ; } render -> band_height_multiple = reps ; render -> bands_rendered = 0 ; if ( output_format == OUT_PGM || output_format == OUT_PPM ) { render -> bander = fz_new_pnm_band_writer ( ctx , out ) ; render -> n = output_format == OUT_PGM ? 1 : 3 ; } else if ( output_format == OUT_PAM ) { render -> bander = fz_new_pam_band_writer ( ctx , out ) ; render -> n = 4 ; } else if ( output_format == OUT_PBM ) { render -> bander = fz_new_pbm_band_writer ( ctx , out ) ; render -> n = 1 ; } else if ( output_format == OUT_PKM ) { render -> bander = fz_new_pkm_band_writer ( ctx , out ) ; render -> n = 4 ; } }
Run ( ) override { #ifndef ANDROID MOZ_ASSERT ( mTriggeringPrincipal , "InternalLoadEvent: Should always have a principal here" ) ; #endif return mDocShell -> InternalLoad ( mURI , mOriginalURI , mResultPrincipalURI , mKeepResultPrincipalURIIfSet , mLoadReplace , mReferrer , mReferrerPolicy , mTriggeringPrincipal , mPrincipalToInherit , mFlags , EmptyString ( ) , mTypeHint , VoidString ( ) , mPostData , mHeadersData , mLoadType , mSHEntry , mFirstParty , mSrcdoc , mSourceDocShell , mBaseURI , nullptr , nullptr ) ; }
GenerateFFIIonExit ( ModuleCompiler & m , const ModuleCompiler :: ExitDescriptor & exit , unsigned exitIndex , Label * throwLabel ) { MacroAssembler & masm = m . masm ( ) ; masm . align ( CodeAlignment ) ; m . setIonExitOffset ( exitIndex ) ; masm . setFramePushed ( 0 ) ; RegisterSet restoreSet = RegisterSet :: Intersect ( RegisterSet :: All ( ) , RegisterSet :: Not ( RegisterSet :: Volatile ( ) ) ) ; #if defined(JS_CPU_ARM) masm . Push ( lr ) ; #endif masm . PushRegsInMask ( restoreSet ) ; MIRTypeVector emptyVector ( m . cx ( ) ) ; unsigned argBytes = 3 * sizeof ( size_t ) + ( 1 + exit . sig ( ) . args ( ) . length ( ) ) * sizeof ( Value ) ; unsigned extraBytes = 0 ; #if defined(JS_CPU_ARM) extraBytes += sizeof ( size_t ) ; #endif unsigned stackDec = StackDecrementForCall ( masm , emptyVector , argBytes + extraBytes ) ; masm . reserveStack ( stackDec - extraBytes ) ; uint32_t descriptor = MakeFrameDescriptor ( masm . framePushed ( ) + extraBytes , IonFrame_Entry ) ; masm . storePtr ( ImmWord ( uintptr_t ( descriptor ) ) , Address ( StackPointer , 0 ) ) ; Register callee = ABIArgGenerator :: NonArgReturnVolatileReg0 ; Register scratch = ABIArgGenerator :: NonArgReturnVolatileReg1 ; unsigned globalDataOffset = m . module ( ) . exitIndexToGlobalDataOffset ( exitIndex ) ; #if defined(JS_CPU_X64) CodeOffsetLabel label2 = masm . leaRipRelative ( callee ) ; m . addGlobalAccess ( AsmJSGlobalAccess ( label2 . offset ( ) , globalDataOffset ) ) ; #elif defined(JS_CPU_X86) CodeOffsetLabel label2 = masm . movlWithPatch ( Imm32 ( 0 ) , callee ) ; m . addGlobalAccess ( AsmJSGlobalAccess ( label2 . offset ( ) , globalDataOffset ) ) ; #else masm . lea ( Operand ( GlobalReg , globalDataOffset ) , callee ) ; #endif masm . loadPtr ( Address ( callee , offsetof ( AsmJSModule :: ExitDatum , fun ) ) , callee ) ; masm . storePtr ( callee , Address ( StackPointer , sizeof ( size_t ) ) ) ; unsigned argc = exit . sig ( ) . args ( ) . length ( ) ; masm . storePtr ( ImmWord ( uintptr_t ( argc ) ) , Address ( StackPointer , 2 * sizeof ( size_t ) ) ) ; masm . storeValue ( UndefinedValue ( ) , Address ( StackPointer , 3 * sizeof ( size_t ) ) ) ; unsigned offsetToArgs = 3 * sizeof ( size_t ) + sizeof ( Value ) ; unsigned offsetToCallerStackArgs = masm . framePushed ( ) ; #if defined(JS_CPU_X86) || defined(JS_CPU_X64) offsetToCallerStackArgs += NativeFrameSize ; #else offsetToCallerStackArgs += ShadowStackSpace ; #endif FillArgumentArray ( m , exit . sig ( ) . args ( ) , offsetToArgs , offsetToCallerStackArgs , scratch ) ; Label done , oolConvert ; Label * maybeDebugBreakpoint = nullptr ; #ifdef DEBUG Label ionFailed ; maybeDebugBreakpoint = & ionFailed ; masm . branchIfFunctionHasNoScript ( callee , & ionFailed ) ; #endif masm . loadPtr ( Address ( callee , JSFunction :: offsetOfNativeOrScript ( ) ) , scratch ) ; masm . loadBaselineOrIonNoArgCheck ( scratch , scratch , SequentialExecution , maybeDebugBreakpoint ) ; LoadAsmJSActivationIntoRegister ( masm , callee ) ; masm . push ( scratch ) ; masm . setupUnalignedABICall ( 1 , scratch ) ; masm . passABIArg ( callee ) ; masm . callWithABI ( AsmJSImm_EnableActivationFromAsmJS ) ; masm . pop ( scratch ) ; #if defined(JS_CPU_ARM) && defined(DEBUG) masm . Push ( scratch ) ; #endif AssertStackAlignment ( masm ) ; #if defined(JS_CPU_ARM) && defined(DEBUG) masm . freeStack ( sizeof ( size_t ) ) ; #endif masm . callIon ( scratch ) ; masm . freeStack ( stackDec - extraBytes ) ; masm . push ( JSReturnReg_Type ) ; masm . push ( JSReturnReg_Data ) ; LoadAsmJSActivationIntoRegister ( masm , callee ) ; masm . setupUnalignedABICall ( 1 , scratch ) ; masm . passABIArg ( callee ) ; masm . callWithABI ( AsmJSImm_DisableActivationFromAsmJS ) ; masm . pop ( JSReturnReg_Data ) ; masm . pop ( JSReturnReg_Type ) ; #ifdef DEBUG masm . branchTestMagicValue ( Assembler :: Equal , JSReturnOperand , JS_ION_ERROR , throwLabel ) ; masm . branchTestMagic ( Assembler :: Equal , JSReturnOperand , & ionFailed ) ; #else masm . branchTestMagic ( Assembler :: Equal , JSReturnOperand , throwLabel ) ; #endif switch ( exit . sig ( ) . retType ( ) . which ( ) ) { case RetType :: Void : break ; case RetType :: Signed : masm . convertValueToInt32 ( JSReturnOperand , ReturnFloatReg , ReturnReg , & oolConvert , false ) ; break ; case RetType :: Double : masm . convertValueToDouble ( JSReturnOperand , ReturnFloatReg , & oolConvert ) ; #if defined(JS_CPU_ARM) && !defined(JS_CPU_ARM_HARDFP) masm . boxDouble ( ReturnFloatReg , softfpReturnOperand ) ; #endif break ; } masm . bind ( & done ) ; masm . PopRegsInMask ( restoreSet ) ; masm . ret ( ) ; if ( oolConvert . used ( ) ) { masm . bind ( & oolConvert ) ; GenerateOOLConvert ( m , exit . sig ( ) . retType ( ) , throwLabel ) ; masm . jump ( & done ) ; } #ifdef DEBUG masm . bind ( & ionFailed ) ; masm . assume_unreachable ( "AsmJS to IonMonkey call failed." ) ; #endif }
Block * Parser :: BuildInitializationBlock ( DeclarationParsingResult * parsing_result , ZonePtrList < const AstRawString > * names , bool * ok ) { Block * result = factory ( ) -> NewBlock ( 1 , true ) ; for ( const auto & declaration : parsing_result -> declarations ) { DeclareAndInitializeVariables ( result , & ( parsing_result -> descriptor ) , & declaration , names , CHECK_OK ) ; } return result ; }
RUNTIME_FUNCTION ( Runtime_DeclareGlobals ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 3 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( FixedArray , declarations , 0 ) ; CONVERT_SMI_ARG_CHECKED ( flags , 1 ) ; CONVERT_ARG_HANDLE_CHECKED ( JSFunction , closure , 2 ) ; Handle < FeedbackVector > feedback_vector ( closure -> feedback_vector ( ) , isolate ) ; return DeclareGlobals ( isolate , declarations , flags , feedback_vector ) ; }
static void send_auth ( char * username , char * password ) { struct mt_packet data ; unsigned short width = 0 ; unsigned short height = 0 ; char * terminal = getenv ( "TERM" ) ; char md5data [ 100 ] ; unsigned char md5sum [ 17 ] ; int plen ; md5_state_t state ; #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE) mlock ( md5data , sizeof ( md5data ) ) ; mlock ( md5sum , sizeof ( md5data ) ) ; #endif md5data [ 0 ] = 0 ; strncpy ( md5data + 1 , password , 82 ) ; md5data [ 83 ] = '\0' ; memcpy ( md5data + 1 + strlen ( password ) , pass_salt , 16 ) ; md5_init ( & state ) ; md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( password ) + 17 ) ; md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ; md5sum [ 0 ] = 0 ; init_packet ( & data , MT_PTYPE_DATA , srcmac , dstmac , sessionkey , outcounter ) ; plen = add_control_packet ( & data , MT_CPTYPE_PASSWORD , md5sum , 17 ) ; plen += add_control_packet ( & data , MT_CPTYPE_USERNAME , username , strlen ( username ) ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_TYPE , terminal , strlen ( terminal ) ) ; if ( is_a_tty && get_terminal_size ( & width , & height ) != - 1 ) { width = htole16 ( width ) ; height = htole16 ( height ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_WIDTH , & width , 2 ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_HEIGHT , & height , 2 ) ; } outcounter += plen ; send_udp ( & data , 1 ) ; }
xmlParseExternalID ( xmlParserCtxtPtr ctxt , xmlChar * * publicID , int strict ) { xmlChar * URI = NULL ; SHRINK ; * publicID = NULL ; if ( CMP6 ( CUR_PTR , 'S' , 'Y' , 'S' , 'T' , 'E' , 'M' ) ) { SKIP ( 6 ) ; if ( ! IS_BLANK_CH ( CUR ) ) { xmlFatalErrMsg ( ctxt , XML_ERR_SPACE_REQUIRED , "Space required after 'SYSTEM'\n" ) ; } SKIP_BLANKS ; URI = xmlParseSystemLiteral ( ctxt ) ; if ( URI == NULL ) { xmlFatalErr ( ctxt , XML_ERR_URI_REQUIRED , NULL ) ; } } else if ( CMP6 ( CUR_PTR , 'P' , 'U' , 'B' , 'L' , 'I' , 'C' ) ) { SKIP ( 6 ) ; if ( ! IS_BLANK_CH ( CUR ) ) { xmlFatalErrMsg ( ctxt , XML_ERR_SPACE_REQUIRED , "Space required after 'PUBLIC'\n" ) ; } SKIP_BLANKS ; * publicID = xmlParsePubidLiteral ( ctxt ) ; if ( * publicID == NULL ) { xmlFatalErr ( ctxt , XML_ERR_PUBID_REQUIRED , NULL ) ; } if ( strict ) { if ( ! IS_BLANK_CH ( CUR ) ) { xmlFatalErrMsg ( ctxt , XML_ERR_SPACE_REQUIRED , "Space required after the Public Identifier\n" ) ; } } else { const xmlChar * ptr ; GROW ; ptr = CUR_PTR ; if ( ! IS_BLANK_CH ( * ptr ) ) return ( NULL ) ; while ( IS_BLANK_CH ( * ptr ) ) ptr ++ ; if ( ( * ptr != '\'' ) && ( * ptr != '"' ) ) return ( NULL ) ; } SKIP_BLANKS ; URI = xmlParseSystemLiteral ( ctxt ) ; if ( URI == NULL ) { xmlFatalErr ( ctxt , XML_ERR_URI_REQUIRED , NULL ) ; } } return ( URI ) ; }
TfLiteStatus CalculateArithmeticOpData ( TfLiteContext * context , TfLiteNode * node , OpData * data ) { TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 1 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; TF_LITE_ENSURE_TYPES_EQ ( context , input -> type , output -> type ) ; if ( input -> type == kTfLiteUInt8 || input -> type == kTfLiteInt8 ) { static constexpr int kInputIntegerBits = 4 ; const double input_real_multiplier = static_cast < double > ( input -> params . scale ) * static_cast < double > ( 1 < < ( 31 - kInputIntegerBits ) ) ; const double q = std :: frexp ( input_real_multiplier , & data -> input_left_shift ) ; data -> input_multiplier = static_cast < int32_t > ( TfLiteRound ( q * ( 1ll < < 31 ) ) ) ; data -> input_range_radius = CalculateInputRadius ( kInputIntegerBits , data -> input_left_shift , 31 ) ; } return kTfLiteOk ; }
static inline const MDefinition * GetObject ( const MDefinition * ins ) { if ( ! ins -> getAliasSet ( ) . isStore ( ) && ! ins -> getAliasSet ( ) . isLoad ( ) ) { return nullptr ; } const MDefinition * object = nullptr ; switch ( ins -> op ( ) ) { case MDefinition :: Opcode :: InitializedLength : case MDefinition :: Opcode :: LoadElement : case MDefinition :: Opcode :: LoadUnboxedScalar : case MDefinition :: Opcode :: LoadUnboxedObjectOrNull : case MDefinition :: Opcode :: LoadUnboxedString : case MDefinition :: Opcode :: StoreElement : case MDefinition :: Opcode :: StoreUnboxedObjectOrNull : case MDefinition :: Opcode :: StoreUnboxedString : case MDefinition :: Opcode :: StoreUnboxedScalar : case MDefinition :: Opcode :: SetInitializedLength : case MDefinition :: Opcode :: ArrayLength : case MDefinition :: Opcode :: SetArrayLength : case MDefinition :: Opcode :: StoreElementHole : case MDefinition :: Opcode :: FallibleStoreElement : case MDefinition :: Opcode :: TypedObjectDescr : case MDefinition :: Opcode :: Slots : case MDefinition :: Opcode :: Elements : case MDefinition :: Opcode :: MaybeCopyElementsForWrite : case MDefinition :: Opcode :: MaybeToDoubleElement : case MDefinition :: Opcode :: TypedArrayLength : case MDefinition :: Opcode :: TypedArrayByteOffset : case MDefinition :: Opcode :: ArrayPopShift : case MDefinition :: Opcode :: ArrayPush : case MDefinition :: Opcode :: LoadTypedArrayElementHole : case MDefinition :: Opcode :: StoreTypedArrayElementHole : case MDefinition :: Opcode :: LoadFixedSlot : case MDefinition :: Opcode :: LoadFixedSlotAndUnbox : case MDefinition :: Opcode :: StoreFixedSlot : case MDefinition :: Opcode :: GetPropertyPolymorphic : case MDefinition :: Opcode :: SetPropertyPolymorphic : case MDefinition :: Opcode :: GuardShape : case MDefinition :: Opcode :: GuardReceiverPolymorphic : case MDefinition :: Opcode :: GuardObjectGroup : case MDefinition :: Opcode :: GuardObjectIdentity : case MDefinition :: Opcode :: LoadSlot : case MDefinition :: Opcode :: StoreSlot : case MDefinition :: Opcode :: InArray : case MDefinition :: Opcode :: LoadElementHole : case MDefinition :: Opcode :: TypedArrayElements : case MDefinition :: Opcode :: TypedObjectElements : case MDefinition :: Opcode :: CopyLexicalEnvironmentObject : case MDefinition :: Opcode :: IsPackedArray : object = ins -> getOperand ( 0 ) ; break ; case MDefinition :: Opcode :: GetPropertyCache : case MDefinition :: Opcode :: CallGetProperty : case MDefinition :: Opcode :: GetDOMProperty : case MDefinition :: Opcode :: GetDOMMember : case MDefinition :: Opcode :: Call : case MDefinition :: Opcode :: Compare : case MDefinition :: Opcode :: GetArgumentsObjectArg : case MDefinition :: Opcode :: SetArgumentsObjectArg : case MDefinition :: Opcode :: GetFrameArgument : case MDefinition :: Opcode :: SetFrameArgument : case MDefinition :: Opcode :: CompareExchangeTypedArrayElement : case MDefinition :: Opcode :: AtomicExchangeTypedArrayElement : case MDefinition :: Opcode :: AtomicTypedArrayElementBinop : case MDefinition :: Opcode :: AsmJSLoadHeap : case MDefinition :: Opcode :: AsmJSStoreHeap : case MDefinition :: Opcode :: WasmHeapBase : case MDefinition :: Opcode :: WasmLoadTls : case MDefinition :: Opcode :: WasmLoad : case MDefinition :: Opcode :: WasmStore : case MDefinition :: Opcode :: WasmCompareExchangeHeap : case MDefinition :: Opcode :: WasmAtomicBinopHeap : case MDefinition :: Opcode :: WasmAtomicExchangeHeap : case MDefinition :: Opcode :: WasmLoadGlobalVar : case MDefinition :: Opcode :: WasmLoadGlobalCell : case MDefinition :: Opcode :: WasmStoreGlobalVar : case MDefinition :: Opcode :: WasmStoreGlobalCell : case MDefinition :: Opcode :: WasmStoreRef : case MDefinition :: Opcode :: ArrayJoin : case MDefinition :: Opcode :: ArraySlice : return nullptr ; default : #ifdef DEBUG if ( ! ins -> getAliasSet ( ) . isStore ( ) || ins -> getAliasSet ( ) . flags ( ) != AliasSet :: Flag :: Any ) { MOZ_CRASH ( "Overridden getAliasSet without updating AliasAnalysis GetObject" ) ; } #endif return nullptr ; } MOZ_ASSERT ( ! ins -> getAliasSet ( ) . isStore ( ) || ins -> getAliasSet ( ) . flags ( ) != AliasSet :: Flag :: Any ) ; object = MaybeUnwrap ( object ) ; MOZ_ASSERT_IF ( object , object -> type ( ) == MIRType :: Object ) ; return object ; }
Reduction JSTypedLowering :: ReduceJSStoreMessage ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSStoreMessage , node -> opcode ( ) ) ; ExternalReference const ref = ExternalReference :: address_of_pending_message_obj ( isolate ( ) ) ; Node * value = NodeProperties :: GetValueInput ( node , 0 ) ; node -> ReplaceInput ( 0 , jsgraph ( ) -> ExternalConstant ( ref ) ) ; node -> ReplaceInput ( 1 , value ) ; NodeProperties :: ChangeOp ( node , simplified ( ) -> StoreField ( AccessBuilder :: ForExternalTaggedValue ( ) ) ) ; return Changed ( node ) ; }
Reduction JSContextSpecialization :: ReduceParameter ( Node * node ) { DCHECK_EQ ( IrOpcode :: kParameter , node -> opcode ( ) ) ; int const index = ParameterIndexOf ( node -> op ( ) ) ; if ( index == Linkage :: kJSCallClosureParamIndex ) { Handle < JSFunction > function ; if ( closure ( ) . ToHandle ( & function ) ) { Node * value = jsgraph ( ) -> HeapConstant ( function ) ; return Replace ( value ) ; } } return NoChange ( ) ; }
nsEventListenerManager :: SetEventHandler ( nsIAtom * aName , const nsAString & aBody , uint32_t aLanguage , bool aDeferCompilation , bool aPermitUntrustedEvents ) { NS_PRECONDITION ( aLanguage != nsIProgrammingLanguage :: UNKNOWN , "Must know the language for the script event listener" ) ; if ( aPermitUntrustedEvents && aLanguage != nsIProgrammingLanguage :: JAVASCRIPT ) { NS_WARNING ( "Discarding non-JS event listener from untrusted source" ) ; return NS_ERROR_FAILURE ; } nsCOMPtr < nsINode > node ( do_QueryInterface ( mTarget ) ) ; nsCOMPtr < nsIDocument > doc ; nsCOMPtr < nsIScriptGlobalObject > global ; if ( node ) { doc = node -> OwnerDoc ( ) ; MOZ_ASSERT ( ! doc -> IsLoadedAsData ( ) , "Should not get in here at all" ) ; global = do_QueryInterface ( doc -> GetScopeObject ( ) ) ; } else { nsCOMPtr < nsPIDOMWindow > win = GetTargetAsInnerWindow ( ) ; if ( win ) { nsCOMPtr < nsIDOMDocument > domdoc ; win -> GetDocument ( getter_AddRefs ( domdoc ) ) ; doc = do_QueryInterface ( domdoc ) ; global = do_QueryInterface ( win ) ; } else { global = do_QueryInterface ( mTarget ) ; } } if ( ! global ) { return NS_OK ; } #ifdef DEBUG nsCOMPtr < nsPIDOMWindow > win = do_QueryInterface ( global ) ; if ( win ) { MOZ_ASSERT ( win -> IsInnerWindow ( ) , "We should not have an outer window here!" ) ; } #endif nsresult rv = NS_OK ; if ( doc ) { if ( doc -> GetSandboxFlags ( ) & SANDBOXED_SCRIPTS ) { return NS_ERROR_DOM_SECURITY_ERR ; } nsCOMPtr < nsIContentSecurityPolicy > csp ; rv = doc -> NodePrincipal ( ) -> GetCsp ( getter_AddRefs ( csp ) ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( csp ) { bool inlineOK = true ; bool reportViolations = false ; rv = csp -> GetAllowsInlineScript ( & reportViolations , & inlineOK ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( reportViolations ) { nsIURI * uri = doc -> GetDocumentURI ( ) ; nsAutoCString asciiSpec ; if ( uri ) uri -> GetAsciiSpec ( asciiSpec ) ; nsAutoString scriptSample , attr , tagName ( NS_LITERAL_STRING ( "UNKNOWN" ) ) ; aName -> ToString ( attr ) ; nsCOMPtr < nsIDOMNode > domNode ( do_QueryInterface ( mTarget ) ) ; if ( domNode ) domNode -> GetNodeName ( tagName ) ; scriptSample . Assign ( attr ) ; scriptSample . AppendLiteral ( " attribute on " ) ; scriptSample . Append ( tagName ) ; scriptSample . AppendLiteral ( " element" ) ; csp -> LogViolationDetails ( nsIContentSecurityPolicy :: VIOLATION_TYPE_INLINE_SCRIPT , NS_ConvertUTF8toUTF16 ( asciiSpec ) , scriptSample , 0 ) ; } if ( ! inlineOK ) { return NS_OK ; } } } if ( NS_FAILED ( global -> EnsureScriptEnvironment ( ) ) ) { NS_WARNING ( "Failed to setup script environment for this language" ) ; } nsIScriptContext * context = global -> GetScriptContext ( ) ; NS_ENSURE_TRUE ( context , NS_ERROR_FAILURE ) ; JS :: Rooted < JSObject * > scope ( context -> GetNativeContext ( ) , global -> GetGlobalJSObject ( ) ) ; nsListenerStruct * ls ; rv = SetEventHandlerInternal ( context , scope , aName , nsEventHandler ( ) , aPermitUntrustedEvents , & ls ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! aDeferCompilation ) { return CompileEventHandlerInternal ( ls , true , & aBody ) ; } return NS_OK ; }
long dd_get_item_size ( struct dump_dir * dd , const char * name ) { if ( ! str_is_correct_filename ( name ) ) error_msg_and_die ( "Cannot get item size. '%s' is not a valid file name" , name ) ; long size = - 1 ; char * iname = concat_path_file ( dd -> dd_dirname , name ) ; struct stat statbuf ; if ( lstat ( iname , & statbuf ) == 0 && S_ISREG ( statbuf . st_mode ) ) size = statbuf . st_size ; else { if ( errno == ENOENT ) size = 0 ; else perror_msg ( "Can't get size of file '%s'" , iname ) ; } free ( iname ) ; return size ; }
int vp9_is_skippable_in_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) { int result = 1 ; struct is_skippable_args args = { x , & result } ; vp9_foreach_transformed_block_in_plane ( & x -> e_mbd , bsize , plane , is_skippable , & args ) ; return result ; }
NS_IMPL_ISUPPORTS ( nsCORSPreflightListener , nsIStreamListener , nsIRequestObserver , nsIInterfaceRequestor , nsIChannelEventSink ) void nsCORSPreflightListener :: AddResultToCache ( nsIRequest * aRequest ) { nsCOMPtr < nsIHttpChannel > http = do_QueryInterface ( aRequest ) ; NS_ASSERTION ( http , "Request was not http" ) ; nsAutoCString headerVal ; http -> GetResponseHeader ( NS_LITERAL_CSTRING ( "Access-Control-Max-Age" ) , headerVal ) ; if ( headerVal . IsEmpty ( ) ) { return ; } uint32_t age = 0 ; nsCSubstring :: const_char_iterator iter , end ; headerVal . BeginReading ( iter ) ; headerVal . EndReading ( end ) ; while ( iter != end ) { if ( * iter < '0' || * iter > '9' ) { return ; } age = age * 10 + ( * iter - '0' ) ; age = std :: min ( age , 86400U ) ; ++ iter ; } if ( ! age || ! EnsurePreflightCache ( ) ) { return ; } nsCOMPtr < nsIURI > uri ; NS_GetFinalChannelURI ( http , getter_AddRefs ( uri ) ) ; TimeStamp expirationTime = TimeStamp :: NowLoRes ( ) + TimeDuration :: FromSeconds ( age ) ; nsPreflightCache :: CacheEntry * entry = sPreflightCache -> GetEntry ( uri , mReferrerPrincipal , mWithCredentials , true ) ; if ( ! entry ) { return ; } http -> GetResponseHeader ( NS_LITERAL_CSTRING ( "Access-Control-Allow-Methods" ) , headerVal ) ; nsCCharSeparatedTokenizer methods ( headerVal , ',' ) ; while ( methods . hasMoreTokens ( ) ) { const nsDependentCSubstring & method = methods . nextToken ( ) ; if ( method . IsEmpty ( ) ) { continue ; } uint32_t i ; for ( i = 0 ; i < entry -> mMethods . Length ( ) ; ++ i ) { if ( entry -> mMethods [ i ] . token . Equals ( method ) ) { entry -> mMethods [ i ] . expirationTime = expirationTime ; break ; } } if ( i == entry -> mMethods . Length ( ) ) { nsPreflightCache :: TokenTime * newMethod = entry -> mMethods . AppendElement ( ) ; if ( ! newMethod ) { return ; } newMethod -> token = method ; newMethod -> expirationTime = expirationTime ; } } http -> GetResponseHeader ( NS_LITERAL_CSTRING ( "Access-Control-Allow-Headers" ) , headerVal ) ; nsCCharSeparatedTokenizer headers ( headerVal , ',' ) ; while ( headers . hasMoreTokens ( ) ) { const nsDependentCSubstring & header = headers . nextToken ( ) ; if ( header . IsEmpty ( ) ) { continue ; } uint32_t i ; for ( i = 0 ; i < entry -> mHeaders . Length ( ) ; ++ i ) { if ( entry -> mHeaders [ i ] . token . Equals ( header ) ) { entry -> mHeaders [ i ] . expirationTime = expirationTime ; break ; } } if ( i == entry -> mHeaders . Length ( ) ) { nsPreflightCache :: TokenTime * newHeader = entry -> mHeaders . AppendElement ( ) ; if ( ! newHeader ) { return ; } newHeader -> token = header ; newHeader -> expirationTime = expirationTime ; } } }
int btsock_thread_post_cmd ( int h , int type , const unsigned char * data , int size , uint32_t user_id ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( "invalid bt thread handle:%d" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( "cmd socket is not created. socket thread may not initialized" ) ; return FALSE ; } sock_cmd_t cmd = { CMD_USER_PRIVATE , 0 , type , size , user_id } ; APPL_TRACE_DEBUG ( "post cmd type:%d, size:%d, h:%d, " , type , size , h ) ; sock_cmd_t * cmd_send = & cmd ; int size_send = sizeof ( cmd ) ; if ( data && size ) { size_send = sizeof ( cmd ) + size ; cmd_send = ( sock_cmd_t * ) alloca ( size_send ) ; if ( cmd_send ) { * cmd_send = cmd ; memcpy ( cmd_send + 1 , data , size ) ; } else { APPL_TRACE_ERROR ( "alloca failed at h:%d, cmd type:%d, size:%d" , h , type , size_send ) ; return FALSE ; } } return send ( ts [ h ] . cmd_fdw , cmd_send , size_send , 0 ) == size_send ; }
kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_int32 now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ; if ( entry == NULL ) return EINVAL ; ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = krb5_db_alloc ( handle -> context , NULL , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( kdb , 0 , sizeof ( * kdb ) ) ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = now + polent . pw_max_life ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; if ( ( ret = kadm5_copy_principal ( handle -> context , entry -> principal , & ( kdb -> princ ) ) ) ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }
const Operator * MachineOperatorBuilder :: Word32AtomicAnd ( MachineType type ) { #define AND(kType)                          \  if (type == MachineType::kType()) {       \  return &cache_.kWord32AtomicAnd##kType; \  } ATOMIC_TYPE_LIST ( AND ) #undef AND UNREACHABLE ( ) ; }
void QuickTimeVideo :: userDataDecoder ( size_t size_external ) { size_t cur_pos = io_ -> tell ( ) ; const TagVocabulary * td ; const TagVocabulary * tv , * tv_internal ; const long bufMinSize = 100 ; DataBuf buf ( bufMinSize ) ; size_t size = 0 , size_internal = size_external ; std :: memset ( buf . data ( ) , 0x0 , buf . size ( ) ) ; while ( ( size_internal / 4 != 0 ) && ( size_internal > 0 ) ) { buf . data ( ) [ 4 ] = '\0' ; io_ -> readOrThrow ( buf . data ( ) , 4 ) ; size = buf . read_uint32 ( 0 , bigEndian ) ; if ( size > size_internal ) break ; size_internal -= size ; io_ -> readOrThrow ( buf . data ( ) , 4 ) ; if ( buf . data ( ) [ 0 ] == 169 ) buf . data ( ) [ 0 ] = ' ' ; td = find ( userDatatags , Exiv2 :: toString ( buf . data ( ) ) ) ; tv = find ( userDataReferencetags , Exiv2 :: toString ( buf . data ( ) ) ) ; if ( size == 0 || ( size - 12 ) <= 0 ) break ; else if ( equalsQTimeTag ( buf , "DcMD" ) || equalsQTimeTag ( buf , "NCDT" ) ) userDataDecoder ( size - 8 ) ; else if ( equalsQTimeTag ( buf , "NCTG" ) ) NikonTagsDecoder ( size - 8 ) ; else if ( equalsQTimeTag ( buf , "TAGS" ) ) CameraTagsDecoder ( size - 8 ) ; else if ( equalsQTimeTag ( buf , "CNCV" ) || equalsQTimeTag ( buf , "CNFV" ) || equalsQTimeTag ( buf , "CNMN" ) || equalsQTimeTag ( buf , "NCHD" ) || equalsQTimeTag ( buf , "FFMV" ) ) { io_ -> readOrThrow ( buf . data ( ) , size - 8 ) ; xmpData_ [ exvGettext ( tv -> label_ ) ] = Exiv2 :: toString ( buf . data ( ) ) ; } else if ( equalsQTimeTag ( buf , "CMbo" ) || equalsQTimeTag ( buf , "Cmbo" ) ) { io_ -> readOrThrow ( buf . data ( ) , 2 ) ; buf . data ( ) [ 2 ] = '\0' ; tv_internal = find ( cameraByteOrderTags , Exiv2 :: toString ( buf . data ( ) ) ) ; if ( tv_internal ) xmpData_ [ exvGettext ( tv -> label_ ) ] = exvGettext ( tv_internal -> label_ ) ; else xmpData_ [ exvGettext ( tv -> label_ ) ] = Exiv2 :: toString ( buf . data ( ) ) ; } else if ( tv ) { io_ -> readOrThrow ( buf . data ( ) , 4 ) ; io_ -> readOrThrow ( buf . data ( ) , size - 12 ) ; xmpData_ [ exvGettext ( tv -> label_ ) ] = Exiv2 :: toString ( buf . data ( ) ) ; } else if ( td ) tagDecoder ( buf , size - 8 ) ; } io_ -> seek ( cur_pos + size_external , BasicIo :: beg ) ; }
lyd_new_anydata ( struct lyd_node * parent , const struct lys_module * module , const char * name , void * value , LYD_ANYDATA_VALUETYPE value_type ) { const struct lys_node * siblings , * snode ; if ( ( ! parent && ! module ) || ! name ) { LOGARG ; return NULL ; } siblings = lyd_new_find_schema ( parent , module , 0 ) ; if ( ! siblings ) { LOGARG ; return NULL ; } if ( lys_getnext_data ( module , lys_parent ( siblings ) , name , strlen ( name ) , LYS_ANYDATA , & snode ) || ! snode ) { LOGERR ( siblings -> module -> ctx , LY_EINVAL , "Failed to find \"%s\" as a sibling to \"%s:%s\"." , name , lys_node_module ( siblings ) -> name , siblings -> name ) ; return NULL ; } return lyd_create_anydata ( parent , snode , value , value_type ) ; }
void nsHtml5TreeBuilder :: endTokenization ( ) { formPointer = nullptr ; headPointer = nullptr ; templateModeStack = nullptr ; if ( stack ) { while ( currentPtr > - 1 ) { stack [ currentPtr ] -> release ( this ) ; currentPtr -- ; } stack = nullptr ; } if ( listOfActiveFormattingElements ) { while ( listPtr > - 1 ) { if ( listOfActiveFormattingElements [ listPtr ] ) { listOfActiveFormattingElements [ listPtr ] -> release ( this ) ; } listPtr -- ; } listOfActiveFormattingElements = nullptr ; } if ( stackNodes ) { for ( int32_t i = 0 ; i < numStackNodes ; i ++ ) { MOZ_ASSERT ( stackNodes [ i ] -> isUnused ( ) ) ; delete stackNodes [ i ] ; } numStackNodes = 0 ; stackNodesIdx = 0 ; stackNodes = nullptr ; } charBuffer = nullptr ; end ( ) ; }
const char * Heap :: GarbageCollectionReasonToString ( GarbageCollectionReason gc_reason ) { switch ( gc_reason ) { case GarbageCollectionReason :: kAllocationFailure : return "allocation failure" ; case GarbageCollectionReason :: kAllocationLimit : return "allocation limit" ; case GarbageCollectionReason :: kContextDisposal : return "context disposal" ; case GarbageCollectionReason :: kCountersExtension : return "counters extension" ; case GarbageCollectionReason :: kDebugger : return "debugger" ; case GarbageCollectionReason :: kDeserializer : return "deserialize" ; case GarbageCollectionReason :: kExternalMemoryPressure : return "external memory pressure" ; case GarbageCollectionReason :: kFinalizeMarkingViaStackGuard : return "finalize incremental marking via stack guard" ; case GarbageCollectionReason :: kFinalizeMarkingViaTask : return "finalize incremental marking via task" ; case GarbageCollectionReason :: kFullHashtable : return "full hash-table" ; case GarbageCollectionReason :: kHeapProfiler : return "heap profiler" ; case GarbageCollectionReason :: kIdleTask : return "idle task" ; case GarbageCollectionReason :: kLastResort : return "last resort" ; case GarbageCollectionReason :: kLowMemoryNotification : return "low memory notification" ; case GarbageCollectionReason :: kMakeHeapIterable : return "make heap iterable" ; case GarbageCollectionReason :: kMemoryPressure : return "memory pressure" ; case GarbageCollectionReason :: kMemoryReducer : return "memory reducer" ; case GarbageCollectionReason :: kRuntime : return "runtime" ; case GarbageCollectionReason :: kSamplingProfiler : return "sampling profiler" ; case GarbageCollectionReason :: kSnapshotCreator : return "snapshot creator" ; case GarbageCollectionReason :: kTesting : return "testing" ; case GarbageCollectionReason :: kExternalFinalize : return "external finalize" ; case GarbageCollectionReason :: kUnknown : return "unknown" ; } UNREACHABLE ( ) ; }
static int __pyx_pw_17clickhouse_driver_14bufferedwriter_14BufferedWriter_1__init__ ( PyObject * __pyx_v_self , PyObject * __pyx_args , PyObject * __pyx_kwds ) { Py_ssize_t __pyx_v_bufsize ; int __pyx_r ; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext ( "__init__ (wrapper)" , 0 ) ; { static PyObject * * __pyx_pyargnames [ ] = { & __pyx_n_s_bufsize , 0 } ; PyObject * values [ 1 ] = { 0 } ; if ( unlikely ( __pyx_kwds ) ) { Py_ssize_t kw_args ; const Py_ssize_t pos_args = PyTuple_GET_SIZE ( __pyx_args ) ; switch ( pos_args ) { case 1 : values [ 0 ] = PyTuple_GET_ITEM ( __pyx_args , 0 ) ; CYTHON_FALLTHROUGH ; case 0 : break ; default : goto __pyx_L5_argtuple_error ; } kw_args = PyDict_Size ( __pyx_kwds ) ; switch ( pos_args ) { case 0 : if ( likely ( ( values [ 0 ] = __Pyx_PyDict_GetItemStr ( __pyx_kwds , __pyx_n_s_bufsize ) ) != 0 ) ) kw_args -- ; else goto __pyx_L5_argtuple_error ; } if ( unlikely ( kw_args > 0 ) ) { if ( unlikely ( __Pyx_ParseOptionalKeywords ( __pyx_kwds , __pyx_pyargnames , 0 , values , pos_args , "__init__" ) < 0 ) ) __PYX_ERR ( 0 , 12 , __pyx_L3_error ) } } else if ( PyTuple_GET_SIZE ( __pyx_args ) != 1 ) { goto __pyx_L5_argtuple_error ; } else { values [ 0 ] = PyTuple_GET_ITEM ( __pyx_args , 0 ) ; } __pyx_v_bufsize = __Pyx_PyIndex_AsSsize_t ( values [ 0 ] ) ; if ( unlikely ( ( __pyx_v_bufsize == ( Py_ssize_t ) - 1 ) && PyErr_Occurred ( ) ) ) __PYX_ERR ( 0 , 12 , __pyx_L3_error ) } goto __pyx_L4_argument_unpacking_done ; __pyx_L5_argtuple_error : ; __Pyx_RaiseArgtupleInvalid ( "__init__" , 1 , 1 , 1 , PyTuple_GET_SIZE ( __pyx_args ) ) ; __PYX_ERR ( 0 , 12 , __pyx_L3_error ) __pyx_L3_error : ; __Pyx_AddTraceback ( "clickhouse_driver.bufferedwriter.BufferedWriter.__init__" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __Pyx_RefNannyFinishContext ( ) ; return - 1 ; __pyx_L4_argument_unpacking_done : ; __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter___init__ ( ( ( struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter * ) __pyx_v_self ) , __pyx_v_bufsize ) ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
WORD32 ih264d_insert_st_node ( dpb_manager_t * ps_dpb_mgr , struct pic_buffer_t * ps_pic_buf , UWORD8 u1_buf_id , UWORD32 u4_cur_pic_num ) { WORD32 i ; struct dpb_info_t * ps_dpb_info = ps_dpb_mgr -> as_dpb_info ; UWORD8 u1_picture_type = ps_pic_buf -> u1_picturetype ; for ( i = 0 ; i < MAX_REF_BUFS ; i ++ ) { if ( ( ps_dpb_info [ i ] . ps_pic_buf == ps_pic_buf ) && ps_dpb_info [ i ] . u1_used_as_ref ) { ps_dpb_info [ i ] . s_bot_field . u1_reference_info = IS_SHORT_TERM ; return 0 ; } if ( ( ps_dpb_info [ i ] . u1_used_as_ref == UNUSED_FOR_REF ) && ( ps_dpb_info [ i ] . s_top_field . u1_reference_info == UNUSED_FOR_REF ) && ( ps_dpb_info [ i ] . s_bot_field . u1_reference_info == UNUSED_FOR_REF ) ) break ; } if ( i == MAX_REF_BUFS ) { UWORD32 i4_error_code ; i4_error_code = ERROR_DBP_MANAGER_T ; return i4_error_code ; } ps_dpb_info [ i ] . ps_pic_buf = ps_pic_buf ; ps_dpb_info [ i ] . ps_prev_short = ps_dpb_mgr -> ps_dpb_st_head ; ps_dpb_info [ i ] . u1_buf_id = u1_buf_id ; ps_dpb_info [ i ] . u1_used_as_ref = TRUE ; ps_dpb_info [ i ] . u1_lt_idx = MAX_REF_BUFS + 1 ; ps_dpb_info [ i ] . i4_frame_num = u4_cur_pic_num ; ps_dpb_info [ i ] . ps_pic_buf -> i4_frame_num = u4_cur_pic_num ; ps_dpb_mgr -> ps_dpb_st_head = ps_dpb_info + i ; ps_dpb_mgr -> u1_num_st_ref_bufs ++ ; ps_pic_buf -> u1_is_short = IS_SHORT_TERM ; if ( ( u1_picture_type & 0x03 ) == FRM_PIC ) { ps_dpb_info [ i ] . u1_used_as_ref = IS_SHORT_TERM ; ps_dpb_info [ i ] . s_top_field . u1_reference_info = IS_SHORT_TERM ; ps_dpb_info [ i ] . s_bot_field . u1_reference_info = IS_SHORT_TERM ; } if ( ( u1_picture_type & 0x03 ) == TOP_FLD ) ps_dpb_info [ i ] . s_top_field . u1_reference_info = IS_SHORT_TERM ; if ( ( u1_picture_type & 0x03 ) == BOT_FLD ) ps_dpb_info [ i ] . s_bot_field . u1_reference_info = IS_SHORT_TERM ; return OK ; }
nsFrameLoader :: Show ( int32_t marginWidth , int32_t marginHeight , int32_t scrollbarPrefX , int32_t scrollbarPrefY , nsSubDocumentFrame * frame ) { if ( mInShow ) { return false ; } AutoResetInShow resetInShow ( this ) ; mInShow = true ; nsresult rv = MaybeCreateDocShell ( ) ; if ( NS_FAILED ( rv ) ) { return false ; } if ( ! mRemoteFrame ) { if ( ! mDocShell ) return false ; mDocShell -> SetMarginWidth ( marginWidth ) ; mDocShell -> SetMarginHeight ( marginHeight ) ; nsCOMPtr < nsIScrollable > sc = do_QueryInterface ( mDocShell ) ; if ( sc ) { sc -> SetDefaultScrollbarPreferences ( nsIScrollable :: ScrollOrientation_X , scrollbarPrefX ) ; sc -> SetDefaultScrollbarPreferences ( nsIScrollable :: ScrollOrientation_Y , scrollbarPrefY ) ; } nsCOMPtr < nsIPresShell > presShell = mDocShell -> GetPresShell ( ) ; if ( presShell ) { nsIFrame * rootScrollFrame = presShell -> GetRootScrollFrame ( ) ; if ( rootScrollFrame ) { presShell -> FrameNeedsReflow ( rootScrollFrame , nsIPresShell :: eResize , NS_FRAME_IS_DIRTY ) ; } return true ; } } nsIntSize size = frame -> GetSubdocumentSize ( ) ; if ( mRemoteFrame ) { return ShowRemoteFrame ( size , frame ) ; } nsView * view = frame -> EnsureInnerView ( ) ; if ( ! view ) return false ; nsCOMPtr < nsIBaseWindow > baseWindow = do_QueryInterface ( mDocShell ) ; NS_ASSERTION ( baseWindow , "Found a nsIDocShell that isn't a nsIBaseWindow." ) ; baseWindow -> InitWindow ( nullptr , view -> GetWidget ( ) , 0 , 0 , size . width , size . height ) ; baseWindow -> Create ( ) ; baseWindow -> SetVisibility ( true ) ; nsCOMPtr < nsIPresShell > presShell = mDocShell -> GetPresShell ( ) ; if ( presShell ) { nsCOMPtr < nsIDOMHTMLDocument > doc = do_QueryInterface ( presShell -> GetDocument ( ) ) ; if ( doc ) { nsAutoString designMode ; doc -> GetDesignMode ( designMode ) ; if ( designMode . EqualsLiteral ( "on" ) ) { nsCOMPtr < nsIEditor > editor ; nsresult rv = mDocShell -> GetEditor ( getter_AddRefs ( editor ) ) ; NS_ENSURE_SUCCESS ( rv , false ) ; doc -> SetDesignMode ( NS_LITERAL_STRING ( "off" ) ) ; doc -> SetDesignMode ( NS_LITERAL_STRING ( "on" ) ) ; } else { bool editable = false , hasEditingSession = false ; mDocShell -> GetEditable ( & editable ) ; mDocShell -> GetHasEditingSession ( & hasEditingSession ) ; nsCOMPtr < nsIEditor > editor ; mDocShell -> GetEditor ( getter_AddRefs ( editor ) ) ; if ( editable && hasEditingSession && editor ) { editor -> PostCreate ( ) ; } } } } mInShow = false ; if ( mHideCalled ) { mHideCalled = false ; Hide ( ) ; return false ; } return true ; }
sctp_handle_str_reset_request_in ( struct sctp_tcb * stcb , struct sctp_tmit_chunk * chk , struct sctp_stream_reset_in_request * req , int trunc ) { uint32_t seq ; int len , i ; int number_entries ; uint16_t temp ; struct sctp_association * asoc = & stcb -> asoc ; seq = ntohl ( req -> request_seq ) ; if ( asoc -> str_reset_seq_in == seq ) { asoc -> last_reset_action [ 1 ] = asoc -> last_reset_action [ 0 ] ; if ( ! ( asoc -> local_strreset_support & SCTP_ENABLE_RESET_STREAM_REQ ) ) { asoc -> last_reset_action [ 0 ] = SCTP_STREAM_RESET_RESULT_DENIED ; } else if ( trunc ) { asoc -> last_reset_action [ 0 ] = SCTP_STREAM_RESET_RESULT_DENIED ; } else if ( stcb -> asoc . stream_reset_out_is_outstanding == 0 ) { len = ntohs ( req -> ph . param_length ) ; number_entries = ( ( len - sizeof ( struct sctp_stream_reset_in_request ) ) / sizeof ( uint16_t ) ) ; if ( number_entries ) { for ( i = 0 ; i < number_entries ; i ++ ) { temp = ntohs ( req -> list_of_streams [ i ] ) ; if ( temp >= stcb -> asoc . streamoutcnt ) { asoc -> last_reset_action [ 0 ] = SCTP_STREAM_RESET_RESULT_DENIED ; goto bad_boy ; } req -> list_of_streams [ i ] = temp ; } for ( i = 0 ; i < number_entries ; i ++ ) { if ( stcb -> asoc . strmout [ req -> list_of_streams [ i ] ] . state == SCTP_STREAM_OPEN ) { stcb -> asoc . strmout [ req -> list_of_streams [ i ] ] . state = SCTP_STREAM_RESET_PENDING ; } } } else { for ( i = 0 ; i < stcb -> asoc . streamoutcnt ; i ++ ) { if ( stcb -> asoc . strmout [ i ] . state == SCTP_STREAM_OPEN ) stcb -> asoc . strmout [ i ] . state = SCTP_STREAM_RESET_PENDING ; } } asoc -> last_reset_action [ 0 ] = SCTP_STREAM_RESET_RESULT_PERFORMED ; } else { asoc -> last_reset_action [ 0 ] = SCTP_STREAM_RESET_RESULT_ERR_IN_PROGRESS ; } bad_boy : sctp_add_stream_reset_result ( chk , seq , asoc -> last_reset_action [ 0 ] ) ; asoc -> str_reset_seq_in ++ ; } else if ( asoc -> str_reset_seq_in - 1 == seq ) { sctp_add_stream_reset_result ( chk , seq , asoc -> last_reset_action [ 0 ] ) ; } else if ( asoc -> str_reset_seq_in - 2 == seq ) { sctp_add_stream_reset_result ( chk , seq , asoc -> last_reset_action [ 1 ] ) ; } else { sctp_add_stream_reset_result ( chk , seq , SCTP_STREAM_RESET_RESULT_ERR_BAD_SEQNO ) ; } sctp_send_stream_reset_out_if_possible ( stcb , SCTP_SO_NOT_LOCKED ) ; }
ZoneChunkList < Parser :: ExportClauseData > * Parser :: ParseExportClause ( Scanner :: Location * reserved_loc , bool * ok ) { ZoneChunkList < ExportClauseData > * export_data = new ( zone ( ) ) ZoneChunkList < ExportClauseData > ( zone ( ) ) ; Expect ( Token :: LBRACE , CHECK_OK ) ; Token :: Value name_tok ; while ( ( name_tok = peek ( ) ) != Token :: RBRACE ) { if ( ! reserved_loc -> IsValid ( ) && ! Token :: IsIdentifier ( name_tok , LanguageMode :: kStrict , false , parsing_module_ ) ) { * reserved_loc = scanner ( ) -> location ( ) ; } const AstRawString * local_name = ParseIdentifierName ( CHECK_OK ) ; const AstRawString * export_name = nullptr ; Scanner :: Location location = scanner ( ) -> location ( ) ; if ( CheckContextualKeyword ( Token :: AS ) ) { export_name = ParseIdentifierName ( CHECK_OK ) ; location . end_pos = scanner ( ) -> location ( ) . end_pos ; } if ( export_name == nullptr ) { export_name = local_name ; } export_data -> push_back ( { export_name , local_name , location } ) ; if ( peek ( ) == Token :: RBRACE ) break ; Expect ( Token :: COMMA , CHECK_OK ) ; } Expect ( Token :: RBRACE , CHECK_OK ) ; return export_data ; }
Utf16CharacterStream * ScannerStream :: For ( Isolate * isolate , Handle < String > data , int start_pos , int end_pos ) { DCHECK_GE ( start_pos , 0 ) ; DCHECK_LE ( start_pos , end_pos ) ; DCHECK_LE ( end_pos , data -> length ( ) ) ; size_t start_offset = 0 ; if ( data -> IsSlicedString ( ) ) { SlicedString * string = SlicedString :: cast ( * data ) ; start_offset = string -> offset ( ) ; String * parent = string -> parent ( ) ; if ( parent -> IsThinString ( ) ) parent = ThinString :: cast ( parent ) -> actual ( ) ; data = handle ( parent , isolate ) ; } else { data = String :: Flatten ( isolate , data ) ; } if ( data -> IsExternalOneByteString ( ) ) { return new BufferedCharacterStream < ExternalStringStream > ( static_cast < size_t > ( start_pos ) , ExternalOneByteString :: cast ( * data ) -> GetChars ( ) + start_offset , static_cast < size_t > ( end_pos ) ) ; } else if ( data -> IsExternalTwoByteString ( ) ) { return new UnbufferedCharacterStream < ExternalStringStream > ( static_cast < size_t > ( start_pos ) , ExternalTwoByteString :: cast ( * data ) -> GetChars ( ) + start_offset , static_cast < size_t > ( end_pos ) ) ; } else if ( data -> IsSeqOneByteString ( ) ) { return new BufferedCharacterStream < OnHeapStream > ( static_cast < size_t > ( start_pos ) , Handle < SeqOneByteString > :: cast ( data ) , start_offset , static_cast < size_t > ( end_pos ) ) ; } else if ( data -> IsSeqTwoByteString ( ) ) { return new RelocatingCharacterStream ( isolate , static_cast < size_t > ( start_pos ) , Handle < SeqTwoByteString > :: cast ( data ) , start_offset , static_cast < size_t > ( end_pos ) ) ; } else { UNREACHABLE ( ) ; } }
std :: unique_ptr < BytecodeModule > hbc :: generateBytecode ( Module * M , raw_ostream & OS , const BytecodeGenerationOptions & options , const SHA1 & sourceHash , hermes :: OptValue < uint32_t > segment , SourceMapGenerator * sourceMapGen , std :: unique_ptr < BCProviderBase > baseBCProvider ) { auto BM = generateBytecodeModule ( M , M -> getTopLevelFunction ( ) , options , segment , sourceMapGen , std :: move ( baseBCProvider ) ) ; if ( options . format == OutputFormatKind :: EmitBundle ) { assert ( BM != nullptr ) ; BytecodeSerializer BS { OS , options } ; BS . serialize ( * BM , sourceHash ) ; } if ( sourceMapGen ) BM -> populateSourceMap ( sourceMapGen ) ; return BM ; }
static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) { UINT16 i ; BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; rle = context -> Planes ; for ( i = 0 ; i < 4 ; i ++ ) { originalSize = context -> OrgByteCount [ i ] ; planeSize = context -> PlaneByteCount [ i ] ; if ( planeSize == 0 ) FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; else if ( planeSize < originalSize ) nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ; rle += planeSize ; } }
RUNTIME_FUNCTION ( Runtime_UnblockConcurrentRecompilation ) { DCHECK_EQ ( 0 , args . length ( ) ) ; if ( FLAG_block_concurrent_recompilation && isolate -> concurrent_recompilation_enabled ( ) ) { isolate -> optimizing_compile_dispatcher ( ) -> Unblock ( ) ; } return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
nsFormFillController :: AttributeChanged ( nsIDocument * aDocument , mozilla :: dom :: Element * aElement , int32_t aNameSpaceID , nsIAtom * aAttribute , int32_t aModType ) { if ( mListNode && mListNode -> Contains ( aElement ) ) { RevalidateDataList ( ) ; } }
static int rd_build_device_space ( struct rd_dev * rd_dev ) { u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ; u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / sizeof ( struct scatterlist ) ) ; struct rd_dev_sg_table * sg_table ; struct page * pg ; struct scatterlist * sg ; if ( rd_dev -> rd_page_count <= 0 ) { pr_err ( "Illegal page count: %u for Ramdisk device\n" , rd_dev -> rd_page_count ) ; return - EINVAL ; } if ( rd_dev -> rd_flags & RDF_NULLIO ) return 0 ; total_sg_needed = rd_dev -> rd_page_count ; sg_tables = ( total_sg_needed / max_sg_per_table ) + 1 ; sg_table = kzalloc ( sg_tables * sizeof ( struct rd_dev_sg_table ) , GFP_KERNEL ) ; if ( ! sg_table ) { pr_err ( "Unable to allocate memory for Ramdisk" " scatterlist tables\n" ) ; return - ENOMEM ; } rd_dev -> sg_table_array = sg_table ; rd_dev -> sg_table_count = sg_tables ; while ( total_sg_needed ) { sg_per_table = ( total_sg_needed > max_sg_per_table ) ? max_sg_per_table : total_sg_needed ; sg = kzalloc ( sg_per_table * sizeof ( struct scatterlist ) , GFP_KERNEL ) ; if ( ! sg ) { pr_err ( "Unable to allocate scatterlist array" " for struct rd_dev\n" ) ; return - ENOMEM ; } sg_init_table ( sg , sg_per_table ) ; sg_table [ i ] . sg_table = sg ; sg_table [ i ] . rd_sg_count = sg_per_table ; sg_table [ i ] . page_start_offset = page_offset ; sg_table [ i ++ ] . page_end_offset = ( page_offset + sg_per_table ) - 1 ; for ( j = 0 ; j < sg_per_table ; j ++ ) { pg = alloc_pages ( GFP_KERNEL , 0 ) ; if ( ! pg ) { pr_err ( "Unable to allocate scatterlist" " pages for struct rd_dev_sg_table\n" ) ; return - ENOMEM ; } sg_assign_page ( & sg [ j ] , pg ) ; sg [ j ] . length = PAGE_SIZE ; } page_offset += sg_per_table ; total_sg_needed -= sg_per_table ; } pr_debug ( "CORE_RD[%u] - Built Ramdisk Device ID: %u space of" " %u pages in %u tables\n" , rd_dev -> rd_host -> rd_host_id , rd_dev -> rd_dev_id , rd_dev -> rd_page_count , rd_dev -> sg_table_count ) ; return 0 ; }
struct dump_dir * create_dump_dir_from_problem_data ( problem_data_t * problem_data , const char * base_dir_name ) { INITIALIZE_LIBREPORT ( ) ; char * type = problem_data_get_content_or_NULL ( problem_data , FILENAME_ANALYZER ) ; if ( ! type ) { error_msg ( _ ( "Missing required item: '%s'" ) , FILENAME_ANALYZER ) ; return NULL ; } uid_t uid = ( uid_t ) - 1L ; char * uid_str = problem_data_get_content_or_NULL ( problem_data , FILENAME_UID ) ; if ( uid_str ) { char * endptr ; errno = 0 ; long val = strtol ( uid_str , & endptr , 10 ) ; if ( errno != 0 || endptr == uid_str || * endptr != '\0' || INT_MAX < val ) { error_msg ( _ ( "uid value is not valid: '%s'" ) , uid_str ) ; return NULL ; } uid = ( uid_t ) val ; } struct timeval tv ; if ( gettimeofday ( & tv , NULL ) < 0 ) { perror_msg ( "gettimeofday()" ) ; return NULL ; } char * problem_id = xasprintf ( "%s-%s.%ld-%lu"NEW_PD_SUFFIX , type , iso_date_string ( & ( tv . tv_sec ) ) , ( long ) tv . tv_usec , ( long ) getpid ( ) ) ; log_info ( "Saving to %s/%s with uid %d" , base_dir_name , problem_id , uid ) ; struct dump_dir * dd ; if ( base_dir_name ) dd = try_dd_create ( base_dir_name , problem_id , uid ) ; else { dd = try_dd_create ( LOCALSTATEDIR "/run/abrt" , problem_id , uid ) ; if ( ! dd ) { char * home = getenv ( "HOME" ) ; if ( home && home [ 0 ] ) { home = concat_path_file ( home , "tmp" ) ; dd = try_dd_create ( home , problem_id , uid ) ; free ( home ) ; } } if ( ! dd ) dd = try_dd_create ( LARGE_DATA_TMP_DIR , problem_id , uid ) ; } if ( ! dd ) goto ret ; GHashTableIter iter ; char * name ; struct problem_item * value ; g_hash_table_iter_init ( & iter , problem_data ) ; while ( g_hash_table_iter_next ( & iter , ( void * * ) & name , ( void * * ) & value ) ) { if ( value -> flags & CD_FLAG_BIN ) { char * dest = concat_path_file ( dd -> dd_dirname , name ) ; log_info ( "copying '%s' to '%s'" , value -> content , dest ) ; off_t copied = copy_file ( value -> content , dest , DEFAULT_DUMP_DIR_MODE | S_IROTH ) ; if ( copied < 0 ) error_msg ( "Can't copy %s to %s" , value -> content , dest ) ; else log_info ( "copied %li bytes" , ( unsigned long ) copied ) ; free ( dest ) ; continue ; } if ( name [ 0 ] == '.' || strchr ( name , '/' ) ) { error_msg ( "Problem data field name contains disallowed chars: '%s'" , name ) ; continue ; } dd_save_text ( dd , name , value -> content ) ; } dd_create_basic_files ( dd , uid , NULL ) ; problem_id [ strlen ( problem_id ) - strlen ( NEW_PD_SUFFIX ) ] = '\0' ; char * new_path = concat_path_file ( base_dir_name , problem_id ) ; log_info ( "Renaming from '%s' to '%s'" , dd -> dd_dirname , new_path ) ; dd_rename ( dd , new_path ) ; ret : free ( problem_id ) ; return dd ; }
int ObjectRef :: AsSmi ( ) const { DCHECK ( IsSmi ( ) ) ; return object < Smi > ( ) -> value ( ) ; }
Node * IntrinsicsGenerator :: AsyncGeneratorResolve ( const InterpreterAssembler :: RegListNodePair & args , Node * context ) { return IntrinsicAsBuiltinCall ( args , context , Builtins :: kAsyncGeneratorResolve ) ; }
ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags , unsigned int allocated , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = ext4_inode_aio ( inode ) ; ext_debug ( "ext4_ext_handle_uninitialized_extents: inode %lu, logical " "block %llu, max_blocks %u, flags %x, allocated %u\n" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; trace_ext4_ext_handle_uninitialized_extents ( inode , map , allocated , newblock ) ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) { ret = ext4_split_unwritten_extents ( handle , inode , map , path , flags ) ; if ( ret <= 0 ) goto out ; if ( io ) ext4_set_io_unwritten_flag ( inode , io ) ; else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) map -> m_flags |= EXT4_MAP_UNINIT ; goto out ; } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) { ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ; if ( ret >= 0 ) { ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; } else err = ret ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { map -> m_flags |= EXT4_MAP_UNWRITTEN ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , map , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; map -> m_flags |= EXT4_MAP_NEW ; if ( allocated > map -> m_len ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + map -> m_len , allocated - map -> m_len ) ; allocated = map -> m_len ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) { unsigned int reserved_clusters ; reserved_clusters = get_reserved_cluster_alloc ( inode , map -> m_lblk , map -> m_len ) ; if ( reserved_clusters ) ext4_da_update_reserve_space ( inode , reserved_clusters , 0 ) ; } map_out : map -> m_flags |= EXT4_MAP_MAPPED ; if ( ( flags & EXT4_GET_BLOCKS_KEEP_SIZE ) == 0 ) { err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; if ( err < 0 ) goto out2 ; } out1 : if ( allocated > map -> m_len ) allocated = map -> m_len ; ext4_ext_show_leaf ( inode , path ) ; map -> m_pblk = newblock ; map -> m_len = allocated ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }
Reduction JSTypedLowering :: ReduceJSParseInt ( Node * node ) { Node * value = NodeProperties :: GetValueInput ( node , 0 ) ; Type value_type = NodeProperties :: GetType ( value ) ; Node * radix = NodeProperties :: GetValueInput ( node , 1 ) ; Type radix_type = NodeProperties :: GetType ( radix ) ; if ( value_type . Is ( type_cache_ . kSafeInteger ) && ( radix_type . Is ( type_cache_ . kTenOrUndefined ) || radix_type . Is ( type_cache_ . kZeroOrUndefined ) ) ) { ReplaceWithValue ( node , value ) ; return Replace ( value ) ; } return NoChange ( ) ; }
void QuickTimeVideo :: multipleEntriesDecoder ( ) { DataBuf buf ( 4 + 1 ) ; io_ -> readOrThrow ( buf . data ( ) , 4 ) ; io_ -> readOrThrow ( buf . data ( ) , 4 ) ; size_t noOfEntries ; noOfEntries = buf . read_uint32 ( 0 , bigEndian ) ; for ( unsigned long i = 1 ; i <= noOfEntries ; i ++ ) decodeBlock ( ) ; }
static int hci_sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct hci_ufilter uf ; struct sock * sk = sock -> sk ; int len , opt , err = 0 ; BT_DBG ( "sk %p, opt %d" , sk , optname ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; if ( hci_pi ( sk ) -> channel != HCI_CHANNEL_RAW ) { err = - EINVAL ; goto done ; } switch ( optname ) { case HCI_DATA_DIR : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_DIR ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_TIME_STAMP : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_TSTAMP ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_FILTER : { struct hci_filter * f = & hci_pi ( sk ) -> filter ; uf . type_mask = f -> type_mask ; uf . opcode = f -> opcode ; uf . event_mask [ 0 ] = * ( ( u32 * ) f -> event_mask + 0 ) ; uf . event_mask [ 1 ] = * ( ( u32 * ) f -> event_mask + 1 ) ; } len = min_t ( unsigned int , len , sizeof ( uf ) ) ; if ( copy_to_user ( optval , & uf , len ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } done : release_sock ( sk ) ; return err ; }
static int sd_compat_ioctl ( struct block_device * bdev , fmode_t mode , unsigned int cmd , unsigned long arg ) { struct scsi_device * sdev = scsi_disk ( bdev -> bd_disk ) -> device ; if ( ! scsi_block_when_processing_errors ( sdev ) ) return - ENODEV ; if ( sdev -> host -> hostt -> compat_ioctl ) { int ret ; ret = sdev -> host -> hostt -> compat_ioctl ( sdev , cmd , ( void __user * ) arg ) ; return ret ; } return - ENOIOCTLCMD ; }
status_t AudioPolicyManager :: stopOutput ( audio_io_handle_t output , audio_stream_type_t stream , audio_session_t session ) { ALOGV ( "stopOutput() output %d, stream %d, session %d" , output , stream , session ) ; ssize_t index = mOutputs . indexOfKey ( output ) ; if ( index < 0 ) { ALOGW ( "stopOutput() unknown output %d" , output ) ; return BAD_VALUE ; } sp < SwAudioOutputDescriptor > outputDesc = mOutputs . valueAt ( index ) ; if ( outputDesc -> mRefCount [ stream ] == 1 ) { if ( audio_is_remote_submix_device ( outputDesc -> mDevice ) && outputDesc -> mPolicyMix != NULL && outputDesc -> mPolicyMix -> mMixType == MIX_TYPE_RECORDERS ) { setDeviceConnectionStateInt ( AUDIO_DEVICE_IN_REMOTE_SUBMIX , AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE , outputDesc -> mPolicyMix -> mDeviceAddress , "remote-submix" ) ; } } bool forceDeviceUpdate = false ; if ( outputDesc -> mRefCount [ stream ] > 0 ) { int activityCount = mOutputRoutes . decRouteActivity ( session ) ; forceDeviceUpdate = ( mOutputRoutes . hasRoute ( session ) && ( activityCount == 0 ) ) ; if ( forceDeviceUpdate ) { checkStrategyRoute ( getStrategy ( stream ) , AUDIO_IO_HANDLE_NONE ) ; } } status_t status = stopSource ( outputDesc , stream , forceDeviceUpdate ) ; if ( status == NO_ERROR ) { outputDesc -> stop ( ) ; } return status ; }
static void show_object ( struct object * obj , struct strbuf * path , const char * last , void * data ) { char * name = path_name ( path , last ) ; add_preferred_base_object ( name ) ; add_object_entry ( obj -> oid . hash , obj -> type , name , 0 ) ; obj -> flags |= OBJECT_ADDED ; free ( ( char * ) name ) ; }
iakerb_gss_export_sec_context ( OM_uint32 * minor_status , gss_ctx_id_t * context_handle , gss_buffer_t interprocess_token ) { OM_uint32 maj ; iakerb_ctx_id_t ctx = ( iakerb_ctx_id_t ) context_handle ; if ( ! ctx -> established ) return GSS_S_UNAVAILABLE ; maj = krb5_gss_export_sec_context ( minor_status , & ctx -> gssc , interprocess_token ) ; if ( ctx -> gssc == GSS_C_NO_CONTEXT ) { iakerb_release_context ( ctx ) ; * context_handle = GSS_C_NO_CONTEXT ; } return maj ; }
void Generate_JSBuiltinsConstructStubHelper ( MacroAssembler * masm ) { { FrameScope scope ( masm , StackFrame :: CONSTRUCT ) ; __ SmiTag ( a0 ) ; __ Push ( cp , a0 ) ; __ SmiUntag ( a0 ) ; __ PushRoot ( Heap :: kTheHoleValueRootIndex ) ; __ Daddu ( t2 , fp , Operand ( StandardFrameConstants :: kCallerSPOffset ) ) ; Label loop , entry ; __ mov ( t3 , a0 ) ; __ jmp ( & entry ) ; __ bind ( & loop ) ; __ Dlsa ( t0 , t2 , t3 , kPointerSizeLog2 ) ; __ Ld ( t1 , MemOperand ( t0 ) ) ; __ push ( t1 ) ; __ bind ( & entry ) ; __ Daddu ( t3 , t3 , Operand ( - 1 ) ) ; __ Branch ( & loop , greater_equal , t3 , Operand ( zero_reg ) ) ; ParameterCount actual ( a0 ) ; __ InvokeFunction ( a1 , a3 , actual , CALL_FUNCTION ) ; __ Ld ( cp , MemOperand ( fp , ConstructFrameConstants :: kContextOffset ) ) ; __ Ld ( a1 , MemOperand ( fp , ConstructFrameConstants :: kLengthOffset ) ) ; } __ SmiScale ( a4 , a1 , kPointerSizeLog2 ) ; __ Daddu ( sp , sp , a4 ) ; __ Daddu ( sp , sp , kPointerSize ) ; __ Ret ( ) ; }
SVGFETurbulenceElement :: GetPrimitiveDescription ( nsSVGFilterInstance * aInstance , const IntRect & aFilterSubregion , nsTArray < RefPtr < SourceSurface > > & aInputImages ) { float fX = mNumberPairAttributes [ BASE_FREQ ] . GetAnimValue ( nsSVGNumberPair :: eFirst ) ; float fY = mNumberPairAttributes [ BASE_FREQ ] . GetAnimValue ( nsSVGNumberPair :: eSecond ) ; float seed = mNumberAttributes [ OCTAVES ] . GetAnimValue ( ) ; uint32_t octaves = clamped ( mIntegerAttributes [ OCTAVES ] . GetAnimValue ( ) , 0 , MAX_OCTAVES ) ; uint32_t type = mEnumAttributes [ TYPE ] . GetAnimValue ( ) ; uint16_t stitch = mEnumAttributes [ STITCHTILES ] . GetAnimValue ( ) ; if ( fX == 0 || fY == 0 ) { return FilterPrimitiveDescription ( FilterPrimitiveDescription :: eNone ) ; } gfxRect firstPeriodInUserSpace ( 0 , 0 , 1 / fX , 1 / fY ) ; gfxMatrix m = aInstance -> GetUserSpaceToFilterSpaceTransform ( ) ; gfxRect firstPeriodInFilterSpace = m . TransformBounds ( firstPeriodInUserSpace ) ; Size frequencyInFilterSpace ( 1 / firstPeriodInFilterSpace . width , 1 / firstPeriodInFilterSpace . height ) ; gfxPoint offset = firstPeriodInFilterSpace . TopLeft ( ) ; FilterPrimitiveDescription descr ( FilterPrimitiveDescription :: eTurbulence ) ; descr . Attributes ( ) . Set ( eTurbulenceOffset , IntPoint ( offset . x , offset . y ) ) ; descr . Attributes ( ) . Set ( eTurbulenceBaseFrequency , frequencyInFilterSpace ) ; descr . Attributes ( ) . Set ( eTurbulenceSeed , seed ) ; descr . Attributes ( ) . Set ( eTurbulenceNumOctaves , octaves ) ; descr . Attributes ( ) . Set ( eTurbulenceStitchable , stitch == SVG_STITCHTYPE_STITCH ) ; descr . Attributes ( ) . Set ( eTurbulenceType , type ) ; return descr ; }
static void mincore_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , unsigned char * vec ) { unsigned long next ; pmd_t * pmd ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( pmd_trans_huge ( * pmd ) ) { if ( mincore_huge_pmd ( vma , pmd , addr , next , vec ) ) { vec += ( next - addr ) > > PAGE_SHIFT ; continue ; } } if ( pmd_none_or_clear_bad ( pmd ) ) mincore_unmapped_range ( vma , addr , next , vec ) ; else mincore_pte_range ( vma , pmd , addr , next , vec ) ; vec += ( next - addr ) > > PAGE_SHIFT ; } while ( pmd ++ , addr = next , addr != end ) ; }
static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; if ( ret < 0 ) { ops -> destroy ( dev ) ; mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; return ret ; } kvm_get_kvm ( kvm ) ; cd -> fd = ret ; return 0 ; }
long ContentEncoding :: ParseContentEncAESSettingsEntry ( long long start , long long size , IMkvReader * pReader , ContentEncAESSettings * aes ) { assert ( pReader ) ; assert ( aes ) ; long long pos = start ; const long long stop = start + size ; while ( pos < stop ) { long long id , size ; const long status = ParseElementHeader ( pReader , pos , stop , id , size ) ; if ( status < 0 ) return status ; if ( id == 0x7E8 ) { aes -> cipher_mode = UnserializeUInt ( pReader , pos , size ) ; if ( aes -> cipher_mode != 1 ) return E_FILE_FORMAT_INVALID ; } pos += size ; assert ( pos <= stop ) ; } return 0 ; }
explicit AutoHoldZone ( Zone * zone MOZ_GUARD_OBJECT_NOTIFIER_PARAM ) : holdp ( & zone -> hold ) { MOZ_GUARD_OBJECT_NOTIFIER_INIT ; * holdp = true ; }
TF_BUILTIN ( CreateIterResultObject , ObjectBuiltinsAssembler ) { Node * const value = Parameter ( Descriptor :: kValue ) ; Node * const done = Parameter ( Descriptor :: kDone ) ; Node * const context = Parameter ( Descriptor :: kContext ) ; Node * const native_context = LoadNativeContext ( context ) ; Node * const map = LoadContextElement ( native_context , Context :: ITERATOR_RESULT_MAP_INDEX ) ; Node * const result = AllocateJSObjectFromMap ( map ) ; StoreObjectFieldNoWriteBarrier ( result , JSIteratorResult :: kValueOffset , value ) ; StoreObjectFieldNoWriteBarrier ( result , JSIteratorResult :: kDoneOffset , done ) ; Return ( result ) ; }
intrinsic_ConstructFunction ( JSContext * cx , unsigned argc , Value * vp ) { CallArgs args = CallArgsFromVp ( argc , vp ) ; MOZ_ASSERT ( args . length ( ) == 3 ) ; MOZ_ASSERT ( IsConstructor ( args [ 0 ] ) ) ; MOZ_ASSERT ( IsConstructor ( args [ 1 ] ) ) ; MOZ_ASSERT ( args [ 2 ] . toObject ( ) . is < ArrayObject > ( ) ) ; RootedArrayObject argsList ( cx , & args [ 2 ] . toObject ( ) . as < ArrayObject > ( ) ) ; uint32_t len = argsList -> length ( ) ; ConstructArgs constructArgs ( cx ) ; if ( ! constructArgs . init ( len ) ) return false ; for ( uint32_t index = 0 ; index < len ; index ++ ) constructArgs [ index ] . set ( argsList -> getDenseElement ( index ) ) ; RootedObject res ( cx ) ; if ( ! Construct ( cx , args [ 0 ] , constructArgs , args [ 1 ] , & res ) ) return false ; args . rval ( ) . setObject ( * res ) ; return true ; }
bool Cues :: Find ( long long time_ns , const Track * pTrack , const CuePoint * & pCP , const CuePoint :: TrackPosition * & pTP ) const { assert ( time_ns >= 0 ) ; assert ( pTrack ) ; #if 0 LoadCuePoint ( ) ; assert ( m_cue_points ) ; assert ( m_count > 0 ) ; CuePoint * * const ii = m_cue_points ; CuePoint * * i = ii ; CuePoint * * const jj = ii + m_count + m_preload_count ; CuePoint * * j = jj ; pCP = * i ; assert ( pCP ) ; if ( time_ns <= pCP -> GetTime ( m_pSegment ) ) { pTP = pCP -> Find ( pTrack ) ; return ( pTP != NULL ) ; } IMkvReader * const pReader = m_pSegment -> m_pReader ; while ( i < j ) { CuePoint * * const k = i + ( j - i ) / 2 ; assert ( k < jj ) ; CuePoint * const pCP = * k ; assert ( pCP ) ; pCP -> Load ( pReader ) ; const long long t = pCP -> GetTime ( m_pSegment ) ; if ( t <= time_ns ) i = k + 1 ; else j = k ; assert ( i <= j ) ; } assert ( i == j ) ; assert ( i <= jj ) ; assert ( i > ii ) ; pCP = * -- i ; assert ( pCP ) ; assert ( pCP -> GetTime ( m_pSegment ) <= time_ns ) ; #else if ( m_cue_points == NULL ) return false ; if ( m_count == 0 ) return false ; CuePoint * * const ii = m_cue_points ; CuePoint * * i = ii ; CuePoint * * const jj = ii + m_count ; CuePoint * * j = jj ; pCP = * i ; assert ( pCP ) ; if ( time_ns <= pCP -> GetTime ( m_pSegment ) ) { pTP = pCP -> Find ( pTrack ) ; return ( pTP != NULL ) ; } while ( i < j ) { CuePoint * * const k = i + ( j - i ) / 2 ; assert ( k < jj ) ; CuePoint * const pCP = * k ; assert ( pCP ) ; const long long t = pCP -> GetTime ( m_pSegment ) ; if ( t <= time_ns ) i = k + 1 ; else j = k ; assert ( i <= j ) ; } assert ( i == j ) ; assert ( i <= jj ) ; assert ( i > ii ) ; pCP = * -- i ; assert ( pCP ) ; assert ( pCP -> GetTime ( m_pSegment ) <= time_ns ) ; #endif pTP = pCP -> Find ( pTrack ) ; return ( pTP != NULL ) ; }
static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env , int insn_idx , int prev_insn_idx ) { struct bpf_verifier_state * cur = env -> cur_state ; struct bpf_verifier_stack_elem * elem ; int err ; elem = kzalloc ( sizeof ( struct bpf_verifier_stack_elem ) , GFP_KERNEL ) ; if ( ! elem ) goto err ; elem -> insn_idx = insn_idx ; elem -> prev_insn_idx = prev_insn_idx ; elem -> next = env -> head ; env -> head = elem ; env -> stack_size ++ ; err = copy_verifier_state ( & elem -> st , cur ) ; if ( err ) goto err ; if ( env -> stack_size > BPF_COMPLEXITY_LIMIT_STACK ) { verbose ( env , "BPF program is too complex\n" ) ; goto err ; } return & elem -> st ; err : free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; while ( ! pop_stack ( env , NULL , NULL ) ) ; return NULL ; }
void Sweeper :: EnsureIterabilityCompleted ( ) { if ( ! iterability_in_progress_ ) return ; if ( FLAG_concurrent_sweeping && iterability_task_started_ ) { if ( heap_ -> isolate ( ) -> cancelable_task_manager ( ) -> TryAbort ( iterability_task_id_ ) != CancelableTaskManager :: kTaskAborted ) { iterability_task_semaphore_ . Wait ( ) ; } iterability_task_started_ = false ; } for ( Page * page : iterability_list_ ) { MakeIterable ( page ) ; } iterability_list_ . clear ( ) ; iterability_in_progress_ = false ; }
static void inter_predictor ( const uint8_t * src , int src_stride , uint8_t * dst , int dst_stride , const int subpel_x , const int subpel_y , const struct scale_factors * sf , int w , int h , int ref , const InterpKernel * kernel , int xs , int ys ) { sf -> predict [ subpel_x != 0 ] [ subpel_y != 0 ] [ ref ] ( src , src_stride , dst , dst_stride , kernel [ subpel_x ] , xs , kernel [ subpel_y ] , ys , w , h ) ; }
int PreProcessingFx_ProcessReverse ( effect_handle_t self , audio_buffer_t * inBuffer , audio_buffer_t * outBuffer ) { preproc_effect_t * effect = ( preproc_effect_t * ) self ; int status = 0 ; if ( effect == NULL ) { ALOGW ( "PreProcessingFx_ProcessReverse() ERROR effect == NULL" ) ; return - EINVAL ; } preproc_session_t * session = ( preproc_session_t * ) effect -> session ; if ( inBuffer == NULL || inBuffer -> raw == NULL ) { ALOGW ( "PreProcessingFx_ProcessReverse() ERROR bad pointer" ) ; return - EINVAL ; } session -> revProcessedMsk |= ( 1 < < effect -> procId ) ; if ( ( session -> revProcessedMsk & session -> revEnabledMsk ) == session -> revEnabledMsk ) { effect -> session -> revProcessedMsk = 0 ; if ( session -> revResampler != NULL ) { size_t fr = session -> frameCount - session -> framesRev ; if ( inBuffer -> frameCount < fr ) { fr = inBuffer -> frameCount ; } if ( session -> revBufSize < session -> framesRev + fr ) { session -> revBufSize = session -> framesRev + fr ; session -> revBuf = ( int16_t * ) realloc ( session -> revBuf , session -> revBufSize * session -> inChannelCount * sizeof ( int16_t ) ) ; } memcpy ( session -> revBuf + session -> framesRev * session -> inChannelCount , inBuffer -> s16 , fr * session -> inChannelCount * sizeof ( int16_t ) ) ; session -> framesRev += fr ; inBuffer -> frameCount = fr ; if ( session -> framesRev < session -> frameCount ) { return 0 ; } spx_uint32_t frIn = session -> framesRev ; spx_uint32_t frOut = session -> apmFrameCount ; if ( session -> inChannelCount == 1 ) { speex_resampler_process_int ( session -> revResampler , 0 , session -> revBuf , & frIn , session -> revFrame -> _payloadData , & frOut ) ; } else { speex_resampler_process_interleaved_int ( session -> revResampler , session -> revBuf , & frIn , session -> revFrame -> _payloadData , & frOut ) ; } memcpy ( session -> revBuf , session -> revBuf + frIn * session -> inChannelCount , ( session -> framesRev - frIn ) * session -> inChannelCount * sizeof ( int16_t ) ) ; session -> framesRev -= frIn ; } else { size_t fr = session -> frameCount - session -> framesRev ; if ( inBuffer -> frameCount < fr ) { fr = inBuffer -> frameCount ; } memcpy ( session -> revFrame -> _payloadData + session -> framesRev * session -> inChannelCount , inBuffer -> s16 , fr * session -> inChannelCount * sizeof ( int16_t ) ) ; session -> framesRev += fr ; inBuffer -> frameCount = fr ; if ( session -> framesRev < session -> frameCount ) { return 0 ; } session -> framesRev = 0 ; } session -> revFrame -> _payloadDataLengthInSamples = session -> apmFrameCount * session -> inChannelCount ; effect -> session -> apm -> AnalyzeReverseStream ( session -> revFrame ) ; return 0 ; } else { return - ENODATA ; } }
mrb_obj_clone ( mrb_state * mrb , mrb_value self ) { struct RObject * p ; mrb_value clone ; if ( mrb_immediate_p ( self ) ) { mrb_raisef ( mrb , E_TYPE_ERROR , "can't clone %S" , self ) ; } if ( mrb_type ( self ) == MRB_TT_SCLASS ) { mrb_raise ( mrb , E_TYPE_ERROR , "can't clone singleton class" ) ; } p = ( struct RObject * ) mrb_obj_alloc ( mrb , mrb_type ( self ) , mrb_obj_class ( mrb , self ) ) ; p -> c = mrb_singleton_class_clone ( mrb , self ) ; mrb_field_write_barrier ( mrb , ( struct RBasic * ) p , ( struct RBasic * ) p -> c ) ; clone = mrb_obj_value ( p ) ; init_copy ( mrb , clone , self ) ; p -> flags = mrb_obj_ptr ( self ) -> flags ; return clone ; }
void Chapter :: Init ( unsigned int * seed ) { id_ = NULL ; displays_ = NULL ; displays_size_ = 0 ; displays_count_ = 0 ; uid_ = MakeUID ( seed ) ; }
DNSInfo DNSRequest :: ResultIsReady ( DNSHeader & header , int length ) { int i = 0 ; int q = 0 ; int curanswer , o ; ResourceRecord rr ; unsigned short ptr ; rr . type = DNS_QUERY_NONE ; rr . rdlength = 0 ; rr . ttl = 1 ; rr . rr_class = 0 ; if ( ! ( header . flags1 & FLAGS_MASK_QR ) ) return std :: make_pair ( ( unsigned char * ) NULL , "Not a query result" ) ; if ( header . flags1 & FLAGS_MASK_OPCODE ) return std :: make_pair ( ( unsigned char * ) NULL , "Unexpected value in DNS reply packet" ) ; if ( header . flags2 & FLAGS_MASK_RCODE ) return std :: make_pair ( ( unsigned char * ) NULL , "Domain name not found" ) ; if ( header . ancount < 1 ) return std :: make_pair ( ( unsigned char * ) NULL , "No resource records returned" ) ; length -= 12 ; while ( ( unsigned int ) q < header . qdcount && i < length ) { if ( header . payload [ i ] > 63 ) { i += 6 ; q ++ ; } else { if ( header . payload [ i ] == 0 ) { q ++ ; i += 5 ; } else i += header . payload [ i ] + 1 ; } } curanswer = 0 ; while ( ( unsigned ) curanswer < header . ancount ) { q = 0 ; while ( q == 0 && i < length ) { if ( header . payload [ i ] > 63 ) { i += 2 ; q = 1 ; } else { if ( header . payload [ i ] == 0 ) { i ++ ; q = 1 ; } else i += header . payload [ i ] + 1 ; } } if ( length - i < 10 ) return std :: make_pair ( ( unsigned char * ) NULL , "Incorrectly sized DNS reply" ) ; DNS :: FillResourceRecord ( & rr , & header . payload [ i ] ) ; i += 10 ; ServerInstance -> Logs -> Log ( "RESOLVER" , DEBUG , "Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d" , rr . type , this -> type , rr . rr_class , this -> rr_class ) ; if ( rr . type != this -> type ) { curanswer ++ ; i += rr . rdlength ; continue ; } if ( rr . rr_class != this -> rr_class ) { curanswer ++ ; i += rr . rdlength ; continue ; } break ; } if ( ( unsigned int ) curanswer == header . ancount ) return std :: make_pair ( ( unsigned char * ) NULL , "No A, AAAA or PTR type answers (" + ConvToStr ( header . ancount ) + " answers)" ) ; if ( i + rr . rdlength > ( unsigned int ) length ) return std :: make_pair ( ( unsigned char * ) NULL , "Resource record larger than stated" ) ; if ( rr . rdlength > 1023 ) return std :: make_pair ( ( unsigned char * ) NULL , "Resource record too large" ) ; this -> ttl = rr . ttl ; switch ( rr . type ) { case DNS_QUERY_CNAME : case DNS_QUERY_PTR : o = 0 ; q = 0 ; while ( q == 0 && i < length && o + 256 < 1023 ) { if ( header . payload [ i ] > 63 ) { memcpy ( & ptr , & header . payload [ i ] , 2 ) ; i = ntohs ( ptr ) - 0xC000 - 12 ; } else { if ( header . payload [ i ] == 0 ) { q = 1 ; } else { res [ o ] = 0 ; if ( o != 0 ) res [ o ++ ] = '.' ; memcpy ( & res [ o ] , & header . payload [ i + 1 ] , header . payload [ i ] ) ; o += header . payload [ i ] ; i += header . payload [ i ] + 1 ; } } } res [ o ] = 0 ; break ; case DNS_QUERY_AAAA : memcpy ( res , & header . payload [ i ] , rr . rdlength ) ; res [ rr . rdlength ] = 0 ; break ; case DNS_QUERY_A : memcpy ( res , & header . payload [ i ] , rr . rdlength ) ; res [ rr . rdlength ] = 0 ; break ; default : memcpy ( res , & header . payload [ i ] , rr . rdlength ) ; res [ rr . rdlength ] = 0 ; break ; } return std :: make_pair ( res , "No error" ) ; }
Reduction JSNativeContextSpecialization :: ReduceJSGetSuperConstructor ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSGetSuperConstructor , node -> opcode ( ) ) ; Node * constructor = NodeProperties :: GetValueInput ( node , 0 ) ; HeapObjectMatcher m ( constructor ) ; if ( ! m . HasValue ( ) ) return NoChange ( ) ; Handle < JSFunction > function = Handle < JSFunction > :: cast ( m . Value ( ) ) ; Handle < Map > function_map ( function -> map ( ) , isolate ( ) ) ; Handle < Object > function_prototype ( function_map -> prototype ( ) , isolate ( ) ) ; if ( function_map -> is_stable ( ) && function_prototype -> IsConstructor ( ) ) { dependencies ( ) -> DependOnStableMap ( MapRef ( js_heap_broker ( ) , function_map ) ) ; Node * value = jsgraph ( ) -> Constant ( function_prototype ) ; ReplaceWithValue ( node , value ) ; return Replace ( value ) ; } return NoChange ( ) ; }
static bool IsInEagerLiterals ( FunctionLiteral * literal , const ZoneVector < FunctionLiteral * > & eager_literals ) { for ( FunctionLiteral * eager_literal : eager_literals ) { if ( literal == eager_literal ) return true ; } return false ; }
nsXMLHttpRequest :: GetRequestBody ( nsIVariant * aVariant , const Nullable < RequestBody > & aBody , nsIInputStream * * aResult , uint64_t * aContentLength , nsACString & aContentType , nsACString & aCharset ) { if ( aVariant ) { return :: GetRequestBody ( aVariant , aResult , aContentLength , aContentType , aCharset ) ; } const RequestBody & body = aBody . Value ( ) ; RequestBody :: Value value = body . GetValue ( ) ; switch ( body . GetType ( ) ) { case nsXMLHttpRequest :: RequestBody :: ArrayBuffer : { return :: GetRequestBody ( value . mArrayBuffer -> Data ( ) , value . mArrayBuffer -> Length ( ) , aResult , aContentLength , aContentType , aCharset ) ; } case nsXMLHttpRequest :: RequestBody :: ArrayBufferView : { return :: GetRequestBody ( value . mArrayBufferView -> Data ( ) , value . mArrayBufferView -> Length ( ) , aResult , aContentLength , aContentType , aCharset ) ; } case nsXMLHttpRequest :: RequestBody :: Blob : { nsresult rv ; nsCOMPtr < nsIXHRSendable > sendable = do_QueryInterface ( value . mBlob , & rv ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; return :: GetRequestBody ( sendable , aResult , aContentLength , aContentType , aCharset ) ; } case nsXMLHttpRequest :: RequestBody :: Document : { nsCOMPtr < nsIDOMDocument > document = do_QueryInterface ( value . mDocument ) ; return :: GetRequestBody ( document , aResult , aContentLength , aContentType , aCharset ) ; } case nsXMLHttpRequest :: RequestBody :: DOMString : { return :: GetRequestBody ( * value . mString , aResult , aContentLength , aContentType , aCharset ) ; } case nsXMLHttpRequest :: RequestBody :: FormData : { MOZ_ASSERT ( value . mFormData ) ; return :: GetRequestBody ( value . mFormData , aResult , aContentLength , aContentType , aCharset ) ; } case nsXMLHttpRequest :: RequestBody :: InputStream : { return :: GetRequestBody ( value . mStream , aResult , aContentLength , aContentType , aCharset ) ; } default : { return NS_ERROR_FAILURE ; } } NS_NOTREACHED ( "Default cases exist for a reason" ) ; return NS_OK ; }
nsMultiplexInputStream :: GetStream ( uint32_t aIndex , nsIInputStream * * aResult ) { * aResult = mStreams . SafeElementAt ( aIndex , nullptr ) ; if ( NS_WARN_IF ( ! * aResult ) ) { return NS_ERROR_NOT_AVAILABLE ; } NS_ADDREF ( * aResult ) ; return NS_OK ; }
HandleException ( ResumeFromException * rfe ) { JSContext * cx = GetIonContext ( ) -> cx ; rfe -> kind = ResumeFromException :: RESUME_ENTRY_FRAME ; IonSpew ( IonSpew_Invalidate , "handling exception" ) ; if ( cx -> runtime ( ) -> hasIonReturnOverride ( ) ) cx -> runtime ( ) -> takeIonReturnOverride ( ) ; IonFrameIterator iter ( cx ) ; while ( ! iter . isEntry ( ) ) { bool overrecursed = false ; if ( iter . isOptimizedJS ( ) ) { InlineFrameIterator frames ( cx , & iter ) ; for ( ; ; ) { HandleExceptionIon ( cx , frames , rfe , & overrecursed ) ; if ( rfe -> kind == ResumeFromException :: RESUME_BAILOUT ) { IonScript * ionScript = nullptr ; if ( iter . checkInvalidation ( & ionScript ) ) ionScript -> decref ( cx -> runtime ( ) -> defaultFreeOp ( ) ) ; return ; } JS_ASSERT ( rfe -> kind == ResumeFromException :: RESUME_ENTRY_FRAME ) ; JSScript * script = frames . script ( ) ; probes :: ExitScript ( cx , script , script -> function ( ) , nullptr ) ; if ( ! frames . more ( ) ) break ; ++ frames ; } IonScript * ionScript = nullptr ; if ( iter . checkInvalidation ( & ionScript ) ) ionScript -> decref ( cx -> runtime ( ) -> defaultFreeOp ( ) ) ; } else if ( iter . isBaselineJS ( ) ) { bool calledDebugEpilogue = false ; HandleExceptionBaseline ( cx , iter , rfe , & calledDebugEpilogue ) ; if ( rfe -> kind != ResumeFromException :: RESUME_ENTRY_FRAME ) return ; JSScript * script = iter . script ( ) ; probes :: ExitScript ( cx , script , script -> function ( ) , iter . baselineFrame ( ) ) ; iter . baselineFrame ( ) -> unsetPushedSPSFrame ( ) ; if ( cx -> compartment ( ) -> debugMode ( ) && ! calledDebugEpilogue ) { BaselineFrame * frame = iter . baselineFrame ( ) ; if ( jit :: DebugEpilogue ( cx , frame , false ) ) { JS_ASSERT ( frame -> hasReturnValue ( ) ) ; rfe -> kind = ResumeFromException :: RESUME_FORCED_RETURN ; rfe -> framePointer = iter . fp ( ) - BaselineFrame :: FramePointerOffset ; rfe -> stackPointer = reinterpret_cast < uint8_t * > ( frame ) ; return ; } } } IonJSFrameLayout * current = iter . isScripted ( ) ? iter . jsFrame ( ) : nullptr ; ++ iter ; if ( current ) { EnsureExitFrame ( current ) ; cx -> mainThread ( ) . ionTop = ( uint8_t * ) current ; } if ( overrecursed ) { js_ReportOverRecursed ( cx ) ; } } rfe -> stackPointer = iter . fp ( ) ; }
- [ sourceListener ] ( RefPtr < MediaMgrError > && aError ) { + [ placeholderListener ] ( RefPtr < MediaMgrError > && aError ) { - MOZ_ASSERT ( sourceListener -> Stopped ( ) ) ; + MOZ_ASSERT ( placeholderListener -> Stopped ( ) ) ; return MgrPromise :: CreateAndReject ( std :: move ( aError ) , __func__ ) ; } ) ;
void Serializer < AllocatorT > :: PrintStack ( ) { for ( const auto o : stack_ ) { o -> Print ( ) ; PrintF ( "\n" ) ; } }
static double calculate_modified_err ( const VP9_COMP * cpi , const FIRSTPASS_STATS * this_frame ) { const struct twopass_rc * twopass = & cpi -> twopass ; const SVC * const svc = & cpi -> svc ; const FIRSTPASS_STATS * stats ; double av_err ; double modified_error ; if ( svc -> number_spatial_layers > 1 && svc -> number_temporal_layers == 1 ) { twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass ; } stats = & twopass -> total_stats ; av_err = stats -> ssim_weighted_pred_err / stats -> count ; modified_error = av_err * pow ( this_frame -> ssim_weighted_pred_err / DOUBLE_DIVIDE_CHECK ( av_err ) , cpi -> oxcf . two_pass_vbrbias / 100.0 ) ; return fclamp ( modified_error , twopass -> modified_error_min , twopass -> modified_error_max ) ; }
void BytecodeGraphBuilder :: UpdateSourcePosition ( SourcePositionTableIterator * it , int offset ) { if ( it -> done ( ) ) return ; if ( it -> code_offset ( ) == offset ) { source_positions_ -> SetCurrentPosition ( SourcePosition ( it -> source_position ( ) . ScriptOffset ( ) , start_position_ . InliningId ( ) ) ) ; it -> Advance ( ) ; } else { DCHECK_GT ( it -> code_offset ( ) , offset ) ; } }
static MagickBooleanType ReadUncompressedRGB ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { PixelPacket * q ; ssize_t x , y ; unsigned short color ; if ( dds_info -> pixelformat . rgb_bitcount == 8 ) ( void ) SetImageType ( image , GrayscaleType ) ; else if ( dds_info -> pixelformat . rgb_bitcount == 16 && ! IsBitMask ( dds_info -> pixelformat , 0xf800 , 0x07e0 , 0x001f , 0x0000 ) ) ThrowBinaryException ( CorruptImageError , "ImageTypeNotSupported" , image -> filename ) ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , dds_info -> width , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x ++ ) { if ( dds_info -> pixelformat . rgb_bitcount == 8 ) SetPixelGray ( q , ScaleCharToQuantum ( ReadBlobByte ( image ) ) ) ; else if ( dds_info -> pixelformat . rgb_bitcount == 16 ) { color = ReadBlobShort ( image ) ; SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( color > > 11 ) / 31.0 ) * 255 ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( ( unsigned short ) ( color < < 5 ) > > 10 ) / 63.0 ) * 255 ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( ( unsigned short ) ( color < < 11 ) > > 11 ) / 31.0 ) * 255 ) ) ) ; } else { SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ) ; if ( dds_info -> pixelformat . rgb_bitcount == 32 ) ( void ) ReadBlobByte ( image ) ; } SetPixelAlpha ( q , QuantumRange ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } SkipRGBMipmaps ( image , dds_info , 3 ) ; return MagickTrue ;
static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) { kfree ( mixer -> id_elems ) ; if ( mixer -> urb ) { kfree ( mixer -> urb -> transfer_buffer ) ; usb_free_urb ( mixer -> urb ) ; } usb_free_urb ( mixer -> rc_urb ) ; kfree ( mixer -> rc_setup_packet ) ; kfree ( mixer ) ; }
void vp9_lookahead_destroy ( struct lookahead_ctx * ctx ) { if ( ctx ) { if ( ctx -> buf ) { unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ ) vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; free ( ctx -> buf ) ; } free ( ctx ) ; } }
WORD32 impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) { stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_mb_addr_incr ; UWORD16 u2_total_len ; UWORD16 u2_len ; UWORD16 u2_mb_type ; UWORD32 u4_next_word ; const dec_mb_params_t * ps_dec_mb_params ; if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) { impeg2d_bit_stream_flush ( ps_stream , 1 ) ; } else { u2_mb_addr_incr = impeg2d_get_mb_addr_incr ( ps_stream ) ; if ( ps_dec -> u2_first_mb ) { ps_dec -> u2_mb_x = u2_mb_addr_incr - 1 ; ps_dec -> u2_mb_x = MIN ( ps_dec -> u2_mb_x , ( ps_dec -> u2_num_horiz_mb - 1 ) ) ; u2_mb_addr_incr = 1 ; ps_dec -> u2_first_mb = 0 ; } else { if ( ps_dec -> u2_is_mpeg2 && ( ( ps_dec -> u2_mb_x + u2_mb_addr_incr ) > ps_dec -> u2_num_horiz_mb ) ) { u2_mb_addr_incr = ps_dec -> u2_num_horiz_mb - ps_dec -> u2_mb_x ; } impeg2d_dec_skip_mbs ( ps_dec , ( UWORD16 ) ( u2_mb_addr_incr - 1 ) ) ; } } u4_next_word = ( UWORD16 ) impeg2d_bit_stream_nxt ( ps_stream , 16 ) ; { u2_mb_type = ps_dec -> pu2_mb_type [ BITS ( ( UWORD16 ) u4_next_word , 15 , 10 ) ] ; u2_len = BITS ( u2_mb_type , 15 , 8 ) ; u2_total_len = u2_len ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word < < u2_len ) ; } { WORD32 i4_motion_type = ps_dec -> u2_motion_type ; if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ps_dec -> u2_read_motion_type ) { ps_dec -> u2_motion_type = BITS ( ( UWORD16 ) u4_next_word , 15 , 14 ) ; u2_total_len += MB_MOTION_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word < < MB_MOTION_TYPE_LEN ) ; i4_motion_type = ps_dec -> u2_motion_type ; } if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ( ( i4_motion_type == 0 ) || ( i4_motion_type == 3 ) || ( i4_motion_type == 4 ) || ( i4_motion_type >= 7 ) ) ) { i4_motion_type = 1 ; } } { if ( ( u2_mb_type & MB_CODED ) && ps_dec -> u2_read_dct_type ) { ps_dec -> u2_field_dct = BIT ( ( UWORD16 ) u4_next_word , 15 ) ; u2_total_len += MB_DCT_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word < < MB_DCT_TYPE_LEN ) ; } } if ( u2_mb_type & MB_QUANT ) { UWORD16 u2_quant_scale_code ; u2_quant_scale_code = BITS ( ( UWORD16 ) u4_next_word , 15 , 11 ) ; ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code < < 1 ) ; u2_total_len += MB_QUANT_SCALE_CODE_LEN ; } impeg2d_bit_stream_flush ( ps_stream , u2_total_len ) ; ps_dec -> u2_coded_mb = ( UWORD16 ) ( u2_mb_type & MB_CODED ) ; if ( u2_mb_type & MB_BIDRECT ) { UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = BIDIRECT ; ps_dec_mb_params = & ps_dec -> ps_func_bi_direct [ u2_index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; } else if ( u2_mb_type & MB_FORW_OR_BACK ) { UWORD16 u2_refPic = ! ( u2_mb_type & MB_MV_FORW ) ; UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = ( e_pred_direction_t ) u2_refPic ; ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ u2_index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; } else if ( u2_mb_type & MB_TYPE_INTRA ) { ps_dec -> u2_prev_intra_mb = 1 ; impeg2d_dec_intra_mb ( ps_dec ) ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = FORW ; ps_dec -> u2_motion_type = 0 ; impeg2d_dec_0mv_coded_mb ( ps_dec ) ; } if ( ( u2_mb_type & MB_TYPE_INTRA ) ) { ps_dec -> u2_cbp = 0x3f ; ps_dec -> u2_prev_intra_mb = 1 ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 < < ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 < < ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 < < ps_dec -> u2_intra_dc_precision ; if ( ( ps_dec -> u2_coded_mb ) ) { UWORD16 cbpValue ; cbpValue = gau2_impeg2d_cbp_code [ impeg2d_bit_stream_nxt ( ps_stream , MB_CBP_LEN ) ] ; ps_dec -> u2_cbp = cbpValue & 0xFF ; impeg2d_bit_stream_flush ( ps_stream , ( cbpValue > > 8 ) & 0x0FF ) ; } else { ps_dec -> u2_cbp = 0 ; } } return 0 ; }
ContentEventHandler :: InitCommon ( ) { if ( mSelection ) { return NS_OK ; } NS_ENSURE_TRUE ( mPresShell , NS_ERROR_NOT_AVAILABLE ) ; mPresShell -> FlushPendingNotifications ( Flush_Layout ) ; NS_ENSURE_TRUE ( ! mPresShell -> IsDestroying ( ) , NS_ERROR_FAILURE ) ; nsCopySupport :: GetSelectionForCopy ( mPresShell -> GetDocument ( ) , getter_AddRefs ( mSelection ) ) ; nsCOMPtr < nsIDOMRange > firstRange ; nsresult rv = mSelection -> GetRangeAt ( 0 , getter_AddRefs ( firstRange ) ) ; if ( NS_FAILED ( rv ) ) { return NS_ERROR_NOT_AVAILABLE ; } mFirstSelectedRange = static_cast < nsRange * > ( firstRange . get ( ) ) ; nsINode * startNode = mFirstSelectedRange -> GetStartParent ( ) ; NS_ENSURE_TRUE ( startNode , NS_ERROR_FAILURE ) ; nsINode * endNode = mFirstSelectedRange -> GetEndParent ( ) ; NS_ENSURE_TRUE ( endNode , NS_ERROR_FAILURE ) ; NS_ENSURE_TRUE ( startNode -> GetCurrentDoc ( ) == mPresShell -> GetDocument ( ) , NS_ERROR_NOT_AVAILABLE ) ; NS_ASSERTION ( startNode -> GetCurrentDoc ( ) == endNode -> GetCurrentDoc ( ) , "mFirstSelectedRange crosses the document boundary" ) ; mRootContent = startNode -> GetSelectionRootContent ( mPresShell ) ; NS_ENSURE_TRUE ( mRootContent , NS_ERROR_FAILURE ) ; return NS_OK ; }
Normalize ( FT_F26Dot6 Vx , FT_F26Dot6 Vy , FT_UnitVector * R ) { FT_F26Dot6 W ; if ( FT_ABS ( Vx ) < 0x4000L && FT_ABS ( Vy ) < 0x4000L ) { if ( Vx == 0 && Vy == 0 ) { return SUCCESS ; } Vx *= 0x4000 ; Vy *= 0x4000 ; } W = FT_Hypot ( Vx , Vy ) ; R -> x = ( FT_F2Dot14 ) TT_DivFix14 ( Vx , W ) ; R -> y = ( FT_F2Dot14 ) TT_DivFix14 ( Vy , W ) ; return SUCCESS ; }
static void * OGRExpatRealloc ( void * ptr , size_t size ) { if ( CanAlloc ( size ) ) return realloc ( ptr , size ) ; free ( ptr ) ; return nullptr ; }
GetNavigator ( JSContext * aCx , JS :: Handle < JSObject * > aObj , JS :: Handle < jsid > aIdval , JS :: MutableHandle < JS :: Value > aVp ) { WorkerGlobalScope * scope = GetInstancePrivate ( aCx , aObj , sProperties [ SLOT_navigator ] . name ) ; if ( ! scope ) { return false ; } if ( JSVAL_IS_VOID ( scope -> mSlots [ SLOT_navigator ] ) ) { nsRefPtr < WorkerNavigator > navigator = WorkerNavigator :: Create ( aCx , aObj ) ; if ( ! navigator ) { return false ; } scope -> mSlots [ SLOT_navigator ] = OBJECT_TO_JSVAL ( navigator -> GetJSObject ( ) ) ; } aVp . set ( scope -> mSlots [ SLOT_navigator ] ) ; return true ; }
int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , int flen ) { struct ustr * filename , * unifilename ; int len = 0 ; filename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! filename ) return 0 ; unifilename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! unifilename ) goto out1 ; if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) goto out2 ; if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_UTF8 ) ) { if ( ! udf_CS0toUTF8 ( filename , unifilename ) ) { udf_debug ( "Failed in udf_get_filename: sname = %s\n" , sname ) ; goto out2 ; } } else if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_NLS_MAP ) ) { if ( ! udf_CS0toNLS ( UDF_SB ( sb ) -> s_nls_map , filename , unifilename ) ) { udf_debug ( "Failed in udf_get_filename: sname = %s\n" , sname ) ; goto out2 ; } } else goto out2 ; len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , unifilename -> u_name , unifilename -> u_len ) ; out2 : kfree ( unifilename ) ; out1 : kfree ( filename ) ; return len ; }
NS_IMETHODIMP nsPlaintextEditor :: PasteTransferable ( nsITransferable * aTransferable ) { if ( ! FireClipboardEvent ( NS_PASTE ) ) return NS_OK ; if ( ! IsModifiable ( ) ) return NS_OK ; nsCOMPtr < nsIDOMDocument > domdoc = GetDOMDocument ( ) ; if ( ! nsEditorHookUtils :: DoInsertionHook ( domdoc , nullptr , aTransferable ) ) return NS_OK ; return InsertTextFromTransferable ( aTransferable , nullptr , 0 , true ) ; }
status_t OMXNodeInstance :: allocateSecureBuffer ( OMX_U32 portIndex , size_t size , OMX :: buffer_id * buffer , void * * buffer_data , sp < NativeHandle > * native_handle ) { if ( buffer == NULL || buffer_data == NULL || native_handle == NULL ) { ALOGE ( "b/25884056" ) ; return BAD_VALUE ; } if ( portIndex >= NELEM ( mSecureBufferType ) ) { ALOGE ( "b/31385713, portIndex(%u)" , portIndex ) ; android_errorWriteLog ( 0x534e4554 , "31385713" ) ; return BAD_VALUE ; } Mutex :: Autolock autoLock ( mLock ) ; BufferMeta * buffer_meta = new BufferMeta ( size , portIndex ) ; OMX_BUFFERHEADERTYPE * header ; OMX_ERRORTYPE err = OMX_AllocateBuffer ( mHandle , & header , portIndex , buffer_meta , size ) ; if ( err != OMX_ErrorNone ) { CLOG_ERROR ( allocateBuffer , err , BUFFER_FMT ( portIndex , "%zu@" , size ) ) ; delete buffer_meta ; buffer_meta = NULL ; * buffer = 0 ; return StatusFromOMXError ( err ) ; } CHECK_EQ ( header -> pAppPrivate , buffer_meta ) ; * buffer = makeBufferID ( header ) ; if ( mSecureBufferType [ portIndex ] == kSecureBufferTypeNativeHandle ) { * buffer_data = NULL ; * native_handle = NativeHandle :: create ( ( native_handle_t * ) header -> pBuffer , false ) ; } else { * buffer_data = header -> pBuffer ; * native_handle = NULL ; } addActiveBuffer ( portIndex , * buffer ) ; sp < GraphicBufferSource > bufferSource ( getGraphicBufferSource ( ) ) ; if ( bufferSource != NULL && portIndex == kPortIndexInput ) { bufferSource -> addCodecBuffer ( header ) ; } CLOG_BUFFER ( allocateSecureBuffer , NEW_BUFFER_FMT ( * buffer , portIndex , "%zu@%p:%p" , size , * buffer_data , * native_handle == NULL ? NULL : ( * native_handle ) -> handle ( ) ) ) ; return OK ; }
void Compute ( OpKernelContext * const context ) override { core :: RefCountPtr < BoostedTreesEnsembleResource > resource ; OP_REQUIRES_OK ( context , LookupResource ( context , HandleFromInput ( context , 0 ) , & resource ) ) ; OpInputList bucketized_features_list ; OP_REQUIRES_OK ( context , context -> input_list ( "bucketized_features" , & bucketized_features_list ) ) ; std :: vector < tensorflow :: TTypes < int32 > :: ConstMatrix > bucketized_features ; bucketized_features . reserve ( bucketized_features_list . size ( ) ) ; ConvertVectorsToMatrices ( bucketized_features_list , bucketized_features ) ; const int batch_size = bucketized_features [ 0 ] . dimension ( 0 ) ; const Tensor * cached_tree_ids_t ; OP_REQUIRES_OK ( context , context -> input ( "cached_tree_ids" , & cached_tree_ids_t ) ) ; const auto cached_tree_ids = cached_tree_ids_t -> vec < int32 > ( ) ; const Tensor * cached_node_ids_t ; OP_REQUIRES_OK ( context , context -> input ( "cached_node_ids" , & cached_node_ids_t ) ) ; const auto cached_node_ids = cached_node_ids_t -> vec < int32 > ( ) ; Tensor * output_partial_logits_t = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( "partial_logits" , { batch_size , logits_dimension_ } , & output_partial_logits_t ) ) ; auto output_partial_logits = output_partial_logits_t -> matrix < float > ( ) ; Tensor * output_tree_ids_t = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( "tree_ids" , { batch_size } , & output_tree_ids_t ) ) ; auto output_tree_ids = output_tree_ids_t -> vec < int32 > ( ) ; Tensor * output_node_ids_t = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( "node_ids" , { batch_size } , & output_node_ids_t ) ) ; auto output_node_ids = output_node_ids_t -> vec < int32 > ( ) ; const int32 latest_tree = resource -> num_trees ( ) - 1 ; if ( latest_tree < 0 ) { output_node_ids . setZero ( ) ; output_tree_ids = cached_tree_ids ; output_partial_logits . setZero ( ) ; } else { output_tree_ids . setConstant ( latest_tree ) ; auto do_work = [ & resource , & bucketized_features , & cached_tree_ids , & cached_node_ids , & output_partial_logits , & output_node_ids , latest_tree , this ] ( int32 start , int32 end ) { for ( int32 i = start ; i < end ; ++ i ) { int32 tree_id = cached_tree_ids ( i ) ; int32 node_id = cached_node_ids ( i ) ; std :: vector < float > partial_tree_logits ( logits_dimension_ , 0.0 ) ; if ( node_id >= 0 ) { resource -> GetPostPruneCorrection ( tree_id , node_id , & node_id , & partial_tree_logits ) ; const auto & node_logits = resource -> node_value ( tree_id , node_id ) ; if ( ! node_logits . empty ( ) ) { DCHECK_EQ ( node_logits . size ( ) , logits_dimension_ ) ; for ( int32 j = 0 ; j < logits_dimension_ ; ++ j ) { partial_tree_logits [ j ] -= node_logits [ j ] ; } } } else { node_id = 0 ; } std :: vector < float > partial_all_logits ( logits_dimension_ , 0.0 ) ; while ( true ) { if ( resource -> is_leaf ( tree_id , node_id ) ) { const auto & leaf_logits = resource -> node_value ( tree_id , node_id ) ; DCHECK_EQ ( leaf_logits . size ( ) , logits_dimension_ ) ; const float tree_weight = resource -> GetTreeWeight ( tree_id ) ; for ( int32 j = 0 ; j < logits_dimension_ ; ++ j ) { partial_all_logits [ j ] += tree_weight * ( partial_tree_logits [ j ] + leaf_logits [ j ] ) ; partial_tree_logits [ j ] = 0 ; } if ( tree_id == latest_tree ) { break ; } ++ tree_id ; node_id = 0 ; } else { node_id = resource -> next_node ( tree_id , node_id , i , bucketized_features ) ; } } output_node_ids ( i ) = node_id ; for ( int32 j = 0 ; j < logits_dimension_ ; ++ j ) { output_partial_logits ( i , j ) = partial_all_logits [ j ] ; } } } ; const int64 cost = 30 ; thread :: ThreadPool * const worker_threads = context -> device ( ) -> tensorflow_cpu_worker_threads ( ) -> workers ; Shard ( worker_threads -> NumThreads ( ) , worker_threads , batch_size , cost , do_work ) ; } }
int dd_delete ( struct dump_dir * dd ) { if ( ! dd -> locked ) { error_msg ( "unlocked problem directory %s cannot be deleted" , dd -> dd_dirname ) ; return - 1 ; } int r = delete_file_dir ( dd -> dd_dirname , true ) ; dd -> locked = 0 ; dd_close ( dd ) ; return r ; }
static OPJ_BOOL opj_j2k_write_first_tile_part ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , opj_stream_private_t * p_stream , struct opj_event_mgr * p_manager ) { OPJ_UINT32 l_nb_bytes_written = 0 ; OPJ_UINT32 l_current_nb_bytes_written ; OPJ_BYTE * l_begin_data = 00 ; opj_tcd_t * l_tcd = 00 ; opj_cp_t * l_cp = 00 ; l_tcd = p_j2k -> m_tcd ; l_cp = & ( p_j2k -> m_cp ) ; l_tcd -> cur_pino = 0 ; p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number = 0 ; l_current_nb_bytes_written = 0 ; l_begin_data = p_data ; if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , p_manager ) ) { return OPJ_FALSE ; } l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; if ( ! OPJ_IS_CINEMA ( l_cp -> rsiz ) ) { #if 0 for ( compno = 1 ; compno < p_j2k -> m_private_image -> numcomps ; compno ++ ) { l_current_nb_bytes_written = 0 ; opj_j2k_write_coc_in_memory ( p_j2k , compno , p_data , & l_current_nb_bytes_written , p_manager ) ; l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; l_current_nb_bytes_written = 0 ; opj_j2k_write_qcc_in_memory ( p_j2k , compno , p_data , & l_current_nb_bytes_written , p_manager ) ; l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; } #endif if ( l_cp -> tcps [ p_j2k -> m_current_tile_number ] . numpocs ) { l_current_nb_bytes_written = 0 ; opj_j2k_write_poc_in_memory ( p_j2k , p_data , & l_current_nb_bytes_written , p_manager ) ; l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; } } l_current_nb_bytes_written = 0 ; if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) { return OPJ_FALSE ; } l_nb_bytes_written += l_current_nb_bytes_written ; * p_data_written = l_nb_bytes_written ; opj_write_bytes ( l_begin_data + 6 , l_nb_bytes_written , 4 ) ; if ( OPJ_IS_CINEMA ( l_cp -> rsiz ) ) { opj_j2k_update_tlm ( p_j2k , l_nb_bytes_written ) ; } return OPJ_TRUE ; }
static int aio_poll_wake ( struct wait_queue_entry * wait , unsigned mode , int sync , void * key ) { struct poll_iocb * req = container_of ( wait , struct poll_iocb , wait ) ; struct aio_kiocb * iocb = container_of ( req , struct aio_kiocb , poll ) ; __poll_t mask = key_to_poll ( key ) ; unsigned long flags ; if ( mask && ! ( mask & req -> events ) ) return 0 ; if ( mask && ! req -> work_scheduled && spin_trylock_irqsave ( & iocb -> ki_ctx -> ctx_lock , flags ) ) { struct kioctx * ctx = iocb -> ki_ctx ; list_del_init ( & req -> wait . entry ) ; list_del ( & iocb -> ki_list ) ; iocb -> ki_res . res = mangle_poll ( mask ) ; if ( iocb -> ki_eventfd && eventfd_signal_allowed ( ) ) { iocb = NULL ; INIT_WORK ( & req -> work , aio_poll_put_work ) ; schedule_work ( & req -> work ) ; } spin_unlock_irqrestore ( & ctx -> ctx_lock , flags ) ; if ( iocb ) iocb_put ( iocb ) ; } else { if ( req -> work_scheduled ) { req -> work_need_resched = true ; } else { schedule_work ( & req -> work ) ; req -> work_scheduled = true ; } } return 1 ; }
status_t OMXNodeInstance :: useBuffer ( OMX_U32 portIndex , const OMXBuffer & omxBuffer , IOMX :: buffer_id * buffer ) { if ( buffer == NULL ) { ALOGE ( "b/25884056" ) ; return BAD_VALUE ; } if ( portIndex >= NELEM ( mNumPortBuffers ) ) { return BAD_VALUE ; } Mutex :: Autolock autoLock ( mLock ) ; if ( ! mSailed ) { ALOGE ( "b/35467458" ) ; android_errorWriteLog ( 0x534e4554 , "35467458" ) ; return BAD_VALUE ; } switch ( omxBuffer . mBufferType ) { case OMXBuffer :: kBufferTypePreset : return useBuffer_l ( portIndex , NULL , NULL , buffer ) ; case OMXBuffer :: kBufferTypeSharedMem : return useBuffer_l ( portIndex , omxBuffer . mMem , NULL , buffer ) ; case OMXBuffer :: kBufferTypeANWBuffer : return useGraphicBuffer_l ( portIndex , omxBuffer . mGraphicBuffer , buffer ) ; case OMXBuffer :: kBufferTypeHidlMemory : { sp < IHidlMemory > hidlMemory = mapMemory ( omxBuffer . mHidlMemory ) ; if ( hidlMemory == nullptr ) { ALOGE ( "OMXNodeInstance useBuffer() failed to map memory" ) ; return NO_MEMORY ; } return useBuffer_l ( portIndex , NULL , hidlMemory , buffer ) ; } default : break ; } return BAD_VALUE ; }
Return < Status > CasImpl :: sendEvent ( int32_t event , int32_t arg , const HidlCasData & eventData ) { ALOGV ( "%s" , __FUNCTION__ ) ; sp < PluginHolder > holder = mPluginHolder ; if ( holder == NULL ) { return toStatus ( INVALID_OPERATION ) ; } status_t err = holder -> get ( ) -> sendEvent ( event , arg , eventData ) ; return toStatus ( err ) ; }
irc_server_set_prefix_modes_chars ( struct t_irc_server * server , const char * prefix ) { char * pos ; int i , length_modes , length_chars ; if ( ! server || ! prefix ) return ; if ( server -> prefix_modes ) { free ( server -> prefix_modes ) ; server -> prefix_modes = NULL ; } if ( server -> prefix_chars ) { free ( server -> prefix_chars ) ; server -> prefix_chars = NULL ; } pos = strchr ( prefix , ')' ) ; if ( pos ) { server -> prefix_modes = weechat_strndup ( prefix + 1 , pos - prefix - 1 ) ; if ( server -> prefix_modes ) { pos ++ ; length_modes = strlen ( server -> prefix_modes ) ; length_chars = strlen ( pos ) ; server -> prefix_chars = malloc ( length_modes + 1 ) ; if ( server -> prefix_chars ) { for ( i = 0 ; i < length_modes ; i ++ ) { server -> prefix_chars [ i ] = ( i < length_chars ) ? pos [ i ] : ' ' ; } server -> prefix_chars [ length_modes ] = '\0' ; } else { free ( server -> prefix_modes ) ; server -> prefix_modes = NULL ; } } } }
static void encode_share_access ( struct xdr_stream * xdr , int open_flags ) { __be32 * p ; RESERVE_SPACE ( 8 ) ; switch ( open_flags & ( FMODE_READ | FMODE_WRITE ) ) { case FMODE_READ : WRITE32 ( NFS4_SHARE_ACCESS_READ ) ; break ; case FMODE_WRITE : WRITE32 ( NFS4_SHARE_ACCESS_WRITE ) ; break ; case FMODE_READ | FMODE_WRITE : WRITE32 ( NFS4_SHARE_ACCESS_BOTH ) ; break ; default : BUG ( ) ; } WRITE32 ( 0 ) ; }
static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | MSR_PMM ) ; mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
nsXBLDocGlobalObject :: EnsureScriptEnvironment ( ) { if ( mScriptContext ) { return NS_OK ; } nsCOMPtr < nsIScriptRuntime > scriptRuntime ; NS_GetJSRuntime ( getter_AddRefs ( scriptRuntime ) ) ; NS_ENSURE_TRUE ( scriptRuntime , NS_OK ) ; nsCOMPtr < nsIScriptContext > newCtx = scriptRuntime -> CreateContext ( false , nullptr ) ; MOZ_ASSERT ( newCtx ) ; newCtx -> WillInitializeContext ( ) ; DebugOnly < nsresult > rv = newCtx -> InitContext ( ) ; NS_WARN_IF_FALSE ( NS_SUCCEEDED ( rv ) , "Script Language's InitContext failed" ) ; newCtx -> DidInitializeContext ( ) ; mScriptContext = newCtx ; JSContext * cx = mScriptContext -> GetNativeContext ( ) ; JSAutoRequest ar ( cx ) ; JS_SetErrorReporter ( cx , XBL_ProtoErrorReporter ) ; mJSObject = JS_NewGlobalObject ( cx , & gSharedGlobalClass , nsJSPrincipals :: get ( GetPrincipal ( ) ) ) ; if ( ! mJSObject ) return NS_OK ; nsIURI * ownerURI = mGlobalObjectOwner -> DocumentURI ( ) ; xpc :: SetLocationForGlobal ( mJSObject , ownerURI ) ; :: JS_SetGlobalObject ( cx , mJSObject ) ; :: JS_SetPrivate ( mJSObject , this ) ; NS_ADDREF ( this ) ; return NS_OK ; }
static const char * parse_attr ( const char * src , int lineno , const char * cp , struct attr_state * e ) { const char * ep , * equals ; int len ; ep = cp + strcspn ( cp , blank ) ; equals = strchr ( cp , '=' ) ; if ( equals && ep < equals ) equals = NULL ; if ( equals ) len = equals - cp ; else len = ep - cp ; if ( ! e ) { if ( * cp == '-' || * cp == '!' ) { cp ++ ; len -- ; } if ( ! attr_name_valid ( cp , len ) ) { report_invalid_attr ( cp , len , src , lineno ) ; return NULL ; } } else { if ( * cp == '-' || * cp == '!' ) { e -> setto = ( * cp == '-' ) ? ATTR__FALSE : ATTR__UNSET ; cp ++ ; len -- ; } else if ( ! equals ) e -> setto = ATTR__TRUE ; else { e -> setto = xmemdupz ( equals + 1 , ep - equals - 1 ) ; } e -> attr = git_attr_internal ( cp , len ) ; } return ep + strspn ( ep , blank ) ; }
void nsBlockFrame :: CollectFloats ( nsIFrame * aFrame , nsFrameList & aList , bool aFromOverflow , bool aCollectSiblings ) { while ( aFrame ) { if ( ! aFrame -> IsFloatContainingBlock ( ) ) { nsIFrame * outOfFlowFrame = aFrame -> GetType ( ) == nsGkAtoms :: placeholderFrame ? nsLayoutUtils :: GetFloatFromPlaceholder ( aFrame ) : nullptr ; if ( outOfFlowFrame ) { if ( outOfFlowFrame -> GetStateBits ( ) & NS_FRAME_IS_PUSHED_FLOAT ) { if ( outOfFlowFrame -> GetParent ( ) == this ) { nsFrameList * list = GetPushedFloats ( ) ; if ( ! list || ! list -> RemoveFrameIfPresent ( outOfFlowFrame ) ) { if ( aFromOverflow ) { nsAutoOOFFrameList oofs ( this ) ; oofs . mList . RemoveFrame ( outOfFlowFrame ) ; } else { mFloats . RemoveFrame ( outOfFlowFrame ) ; } } aList . AppendFrame ( nullptr , outOfFlowFrame ) ; } } else { NS_ASSERTION ( outOfFlowFrame -> GetParent ( ) == this , "Out of flow frame doesn't have the expected parent" ) ; if ( aFromOverflow ) { nsAutoOOFFrameList oofs ( this ) ; oofs . mList . RemoveFrame ( outOfFlowFrame ) ; } else { mFloats . RemoveFrame ( outOfFlowFrame ) ; } aList . AppendFrame ( nullptr , outOfFlowFrame ) ; } } CollectFloats ( aFrame -> GetFirstPrincipalChild ( ) , aList , aFromOverflow , true ) ; CollectFloats ( aFrame -> GetFirstChild ( kOverflowList ) , aList , aFromOverflow , true ) ; } if ( ! aCollectSiblings ) break ; aFrame = aFrame -> GetNextSibling ( ) ; } }
int lpEncodeGetType ( unsigned char * ele , uint32_t size , unsigned char * intenc , uint64_t * enclen ) { int64_t v ; if ( lpStringToInt64 ( ( const char * ) ele , size , & v ) ) { if ( v >= 0 && v <= 127 ) { intenc [ 0 ] = v ; * enclen = 1 ; } else if ( v >= - 4096 && v <= 4095 ) { if ( v < 0 ) v = ( ( int64_t ) 1 < < 13 ) + v ; intenc [ 0 ] = ( v > > 8 ) | LP_ENCODING_13BIT_INT ; intenc [ 1 ] = v & 0xff ; * enclen = 2 ; } else if ( v >= - 32768 && v <= 32767 ) { if ( v < 0 ) v = ( ( int64_t ) 1 < < 16 ) + v ; intenc [ 0 ] = LP_ENCODING_16BIT_INT ; intenc [ 1 ] = v & 0xff ; intenc [ 2 ] = v > > 8 ; * enclen = 3 ; } else if ( v >= - 8388608 && v <= 8388607 ) { if ( v < 0 ) v = ( ( int64_t ) 1 < < 24 ) + v ; intenc [ 0 ] = LP_ENCODING_24BIT_INT ; intenc [ 1 ] = v & 0xff ; intenc [ 2 ] = ( v > > 8 ) & 0xff ; intenc [ 3 ] = v > > 16 ; * enclen = 4 ; } else if ( v >= - 2147483648 && v <= 2147483647 ) { if ( v < 0 ) v = ( ( int64_t ) 1 < < 32 ) + v ; intenc [ 0 ] = LP_ENCODING_32BIT_INT ; intenc [ 1 ] = v & 0xff ; intenc [ 2 ] = ( v > > 8 ) & 0xff ; intenc [ 3 ] = ( v > > 16 ) & 0xff ; intenc [ 4 ] = v > > 24 ; * enclen = 5 ; } else { uint64_t uv = v ; intenc [ 0 ] = LP_ENCODING_64BIT_INT ; intenc [ 1 ] = uv & 0xff ; intenc [ 2 ] = ( uv > > 8 ) & 0xff ; intenc [ 3 ] = ( uv > > 16 ) & 0xff ; intenc [ 4 ] = ( uv > > 24 ) & 0xff ; intenc [ 5 ] = ( uv > > 32 ) & 0xff ; intenc [ 6 ] = ( uv > > 40 ) & 0xff ; intenc [ 7 ] = ( uv > > 48 ) & 0xff ; intenc [ 8 ] = uv > > 56 ; * enclen = 9 ; } return LP_ENCODING_INT ; } else { if ( size < 64 ) * enclen = 1 + size ; else if ( size < 4096 ) * enclen = 2 + size ; else * enclen = 5 + size ; return LP_ENCODING_STRING ; } }
int read_filesystem_tables_4 ( ) { long long directory_table_end , table_start ; if ( read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 ) return FALSE ; if ( read_uids_guids ( & table_start ) == FALSE ) return FALSE ; if ( parse_exports_table ( & table_start ) == FALSE ) return FALSE ; if ( read_fragment_table ( & directory_table_end ) == FALSE ) return FALSE ; if ( read_inode_table ( sBlk . s . inode_table_start , sBlk . s . directory_table_start ) == FALSE ) return FALSE ; if ( read_directory_table ( sBlk . s . directory_table_start , directory_table_end ) == FALSE ) return FALSE ; if ( no_xattrs ) sBlk . s . xattr_id_table_start = SQUASHFS_INVALID_BLK ; return TRUE ; }
status_t Parcel :: write ( const FlattenableHelperInterface & val ) { status_t err ; const size_t len = val . getFlattenedSize ( ) ; const size_t fd_count = val . getFdCount ( ) ; if ( ( len > INT32_MAX ) || ( fd_count >= gMaxFds ) ) { return BAD_VALUE ; } err = this -> writeInt32 ( len ) ; if ( err ) return err ; err = this -> writeInt32 ( fd_count ) ; if ( err ) return err ; void * const buf = this -> writeInplace ( pad_size ( len ) ) ; if ( buf == NULL ) return BAD_VALUE ; int * fds = NULL ; if ( fd_count ) { fds = new ( std :: nothrow ) int [ fd_count ] ; if ( fds == nullptr ) { ALOGE ( "write: failed to allocate requested %zu fds" , fd_count ) ; return BAD_VALUE ; } } err = val . flatten ( buf , len , fds , fd_count ) ; for ( size_t i = 0 ; i < fd_count && err == NO_ERROR ; i ++ ) { err = this -> writeDupFileDescriptor ( fds [ i ] ) ; } if ( fd_count ) { delete [ ] fds ; } return err ; }
static OPJ_BOOL opj_pi_next_rpcl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u < < ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u < < ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < pi -> poc . resno1 ; pi -> resno ++ ) { for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; comp = & pi -> comps [ pi -> compno ] ; if ( pi -> resno >= comp -> numresolutions ) { continue ; } res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx < < levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy < < levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx < < levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy < < levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy < < rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 < < levelno ) % ( 1 < < rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx < < rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 < < levelno ) % ( 1 < < rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) continue ; if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) continue ; prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx < < levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy < < levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; if ( pi -> precno >= res -> pw * res -> ph ) { return OPJ_FALSE ; } for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
RegExpCompartment :: sweep ( JSRuntime * rt ) { for ( Map :: Enum e ( map_ ) ; ! e . empty ( ) ; e . popFront ( ) ) { RegExpShared * shared = e . front ( ) . value ; if ( shared -> activeUseCount == 0 && shared -> gcNumberWhenUsed < rt -> gcStartNumber ) { js_delete ( shared ) ; e . removeFront ( ) ; } } }
void EscapeAnalysisReducer :: Finalize ( ) { for ( Node * node : arguments_elements_ ) { int mapped_count = NewArgumentsElementsMappedCountOf ( node -> op ( ) ) ; Node * arguments_frame = NodeProperties :: GetValueInput ( node , 0 ) ; if ( arguments_frame -> opcode ( ) != IrOpcode :: kArgumentsFrame ) continue ; Node * arguments_length = NodeProperties :: GetValueInput ( node , 1 ) ; if ( arguments_length -> opcode ( ) != IrOpcode :: kArgumentsLength ) continue ; DCHECK_IMPLIES ( mapped_count != 0 , mapped_count == FormalParameterCountOf ( arguments_length -> op ( ) ) ) ; ArgumentsStateType type = IsRestLengthOf ( arguments_length -> op ( ) ) ? ArgumentsStateType :: kRestParameter : ( mapped_count == 0 ) ? ArgumentsStateType :: kUnmappedArguments : ArgumentsStateType :: kMappedArguments ; Node * arguments_length_state = nullptr ; for ( Edge edge : arguments_length -> use_edges ( ) ) { Node * use = edge . from ( ) ; switch ( use -> opcode ( ) ) { case IrOpcode :: kObjectState : case IrOpcode :: kTypedObjectState : case IrOpcode :: kStateValues : case IrOpcode :: kTypedStateValues : if ( ! arguments_length_state ) { arguments_length_state = jsgraph ( ) -> graph ( ) -> NewNode ( jsgraph ( ) -> common ( ) -> ArgumentsLengthState ( type ) ) ; NodeProperties :: SetType ( arguments_length_state , Type :: OtherInternal ( ) ) ; } edge . UpdateTo ( arguments_length_state ) ; break ; default : break ; } } bool escaping_use = false ; ZoneVector < Node * > loads ( zone ( ) ) ; for ( Edge edge : node -> use_edges ( ) ) { Node * use = edge . from ( ) ; if ( ! NodeProperties :: IsValueEdge ( edge ) ) continue ; if ( use -> use_edges ( ) . empty ( ) ) { continue ; } switch ( use -> opcode ( ) ) { case IrOpcode :: kStateValues : case IrOpcode :: kTypedStateValues : case IrOpcode :: kObjectState : case IrOpcode :: kTypedObjectState : break ; case IrOpcode :: kLoadElement : if ( mapped_count == 0 ) { loads . push_back ( use ) ; } else { escaping_use = true ; } break ; case IrOpcode :: kLoadField : if ( FieldAccessOf ( use -> op ( ) ) . offset == FixedArray :: kLengthOffset ) { loads . push_back ( use ) ; } else { escaping_use = true ; } break ; default : escaping_use = true ; break ; } if ( escaping_use ) break ; } if ( ! escaping_use ) { Node * arguments_elements_state = jsgraph ( ) -> graph ( ) -> NewNode ( jsgraph ( ) -> common ( ) -> ArgumentsElementsState ( type ) ) ; NodeProperties :: SetType ( arguments_elements_state , Type :: OtherInternal ( ) ) ; ReplaceWithValue ( node , arguments_elements_state ) ; ElementAccess stack_access ; stack_access . base_is_tagged = BaseTaggedness :: kUntaggedBase ; stack_access . header_size = CommonFrameConstants :: kFixedFrameSizeAboveFp - kPointerSize ; stack_access . type = Type :: NonInternal ( ) ; stack_access . machine_type = MachineType :: AnyTagged ( ) ; stack_access . write_barrier_kind = WriteBarrierKind :: kNoWriteBarrier ; const Operator * load_stack_op = jsgraph ( ) -> simplified ( ) -> LoadElement ( stack_access ) ; for ( Node * load : loads ) { switch ( load -> opcode ( ) ) { case IrOpcode :: kLoadElement : { Node * index = NodeProperties :: GetValueInput ( load , 1 ) ; Node * offset = jsgraph ( ) -> graph ( ) -> NewNode ( jsgraph ( ) -> simplified ( ) -> NumberSubtract ( ) , arguments_length , index ) ; NodeProperties :: SetType ( offset , TypeCache :: Get ( ) . kArgumentsLengthType ) ; NodeProperties :: ReplaceValueInput ( load , arguments_frame , 0 ) ; NodeProperties :: ReplaceValueInput ( load , offset , 1 ) ; NodeProperties :: ChangeOp ( load , load_stack_op ) ; break ; } case IrOpcode :: kLoadField : { DCHECK_EQ ( FieldAccessOf ( load -> op ( ) ) . offset , FixedArray :: kLengthOffset ) ; Node * length = NodeProperties :: GetValueInput ( node , 1 ) ; ReplaceWithValue ( load , length ) ; break ; } default : UNREACHABLE ( ) ; } } } } }
native_handle * Parcel :: readNativeHandle ( ) const { int numFds , numInts ; status_t err ; err = readInt32 ( & numFds ) ; if ( err != NO_ERROR ) return 0 ; err = readInt32 ( & numInts ) ; if ( err != NO_ERROR ) return 0 ; native_handle * h = native_handle_create ( numFds , numInts ) ; if ( ! h ) { return 0 ; } for ( int i = 0 ; err == NO_ERROR && i < numFds ; i ++ ) { h -> data [ i ] = dup ( readFileDescriptor ( ) ) ; if ( h -> data [ i ] < 0 ) err = BAD_VALUE ; } err = read ( h -> data + numFds , sizeof ( int ) * numInts ) ; if ( err != NO_ERROR ) { native_handle_close ( h ) ; native_handle_delete ( h ) ; h = 0 ; } return h ; }
static int ras_putdatastd ( jas_stream_t * out , ras_hdr_t * hdr , jas_image_t * image , int numcmpts , int * cmpts ) { int rowsize ; int pad ; unsigned int z ; int nz ; int c ; int x ; int y ; int v ; jas_matrix_t * data [ 3 ] ; int i ; for ( i = 0 ; i < numcmpts ; ++ i ) { data [ i ] = jas_matrix_create ( jas_image_height ( image ) , jas_image_width ( image ) ) ; assert ( data [ i ] ) ; } rowsize = RAS_ROWSIZE ( hdr ) ; pad = rowsize - ( hdr -> width * hdr -> depth + 7 ) / 8 ; hdr -> length = hdr -> height * rowsize ; for ( y = 0 ; y < hdr -> height ; y ++ ) { for ( i = 0 ; i < numcmpts ; ++ i ) { if ( jas_image_readcmpt ( image , cmpts [ i ] , 0 , y , jas_image_width ( image ) , 1 , data [ i ] ) ) { return - 1 ; } } z = 0 ; nz = 0 ; for ( x = 0 ; x < hdr -> width ; x ++ ) { z <<= hdr -> depth ; if ( RAS_ISRGB ( hdr ) ) { v = RAS_RED ( ( jas_matrix_getv ( data [ 0 ] , x ) ) ) | RAS_GREEN ( ( jas_matrix_getv ( data [ 1 ] , x ) ) ) | RAS_BLUE ( ( jas_matrix_getv ( data [ 2 ] , x ) ) ) ; } else { v = ( jas_matrix_getv ( data [ 0 ] , x ) ) ; } z |= v & RAS_ONES ( hdr -> depth ) ; nz += hdr -> depth ; while ( nz >= 8 ) { c = ( z > > ( nz - 8 ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) { return - 1 ; } nz -= 8 ; z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z > > ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { return - 1 ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { return - 1 ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; } return 0 ; }
Response V8DebuggerAgentImpl :: stepOut ( ) { if ( ! isPaused ( ) ) return Response :: Error ( kDebuggerNotPaused ) ; m_session -> releaseObjectGroup ( kBacktraceObjectGroup ) ; m_debugger -> stepOutOfFunction ( m_session -> contextGroupId ( ) ) ; return Response :: OK ( ) ; }
InstallXBLField ( JSContext * cx , JS :: Handle < JSObject * > callee , JS :: Handle < JSObject * > thisObj , jsid * idp , bool * installed ) { * installed = false ; MOZ_ASSERT ( ValueHasISupportsPrivate ( JS :: ObjectValue ( * thisObj ) ) ) ; nsISupports * native = nsContentUtils :: XPConnect ( ) -> GetNativeOfWrapper ( cx , thisObj ) ; if ( ! native ) { return true ; } nsCOMPtr < nsIContent > xblNode = do_QueryInterface ( native ) ; if ( ! xblNode ) { xpc :: Throw ( cx , NS_ERROR_UNEXPECTED ) ; return false ; } nsXBLPrototypeBinding * protoBinding ; nsDependentJSString fieldName ; { JSAutoCompartment ac ( cx , callee ) ; js :: Rooted < JSObject * > xblProto ( cx ) ; xblProto = & js :: GetFunctionNativeReserved ( callee , XBLPROTO_SLOT ) . toObject ( ) ; JS :: Value name = js :: GetFunctionNativeReserved ( callee , FIELD_SLOT ) ; JSFlatString * fieldStr = JS_ASSERT_STRING_IS_FLAT ( name . toString ( ) ) ; fieldName . init ( fieldStr ) ; MOZ_ALWAYS_TRUE ( JS_ValueToId ( cx , name , idp ) ) ; JS :: Value slotVal = :: JS_GetReservedSlot ( xblProto , 0 ) ; protoBinding = static_cast < nsXBLPrototypeBinding * > ( slotVal . toPrivate ( ) ) ; MOZ_ASSERT ( protoBinding ) ; } nsXBLProtoImplField * field = protoBinding -> FindField ( fieldName ) ; MOZ_ASSERT ( field ) ; nsIScriptGlobalObject * global = xblNode -> OwnerDoc ( ) -> GetScriptGlobalObject ( ) ; if ( ! global ) { return true ; } nsCOMPtr < nsIScriptContext > context = global -> GetContext ( ) ; if ( ! context ) { return true ; } nsresult rv = field -> InstallField ( context , thisObj , protoBinding -> DocURI ( ) , installed ) ; if ( NS_SUCCEEDED ( rv ) ) { return true ; } if ( ! :: JS_IsExceptionPending ( cx ) ) { xpc :: Throw ( cx , rv ) ; } return false ; }
void AccessorAssembler :: EmitAccessCheck ( Node * expected_native_context , Node * context , Node * receiver , Label * can_access , Label * miss ) { CSA_ASSERT ( this , IsNativeContext ( expected_native_context ) ) ; Node * native_context = LoadNativeContext ( context ) ; GotoIf ( WordEqual ( expected_native_context , native_context ) , can_access ) ; GotoIfNot ( IsJSGlobalProxy ( receiver ) , miss ) ; Node * expected_token = LoadContextElement ( expected_native_context , Context :: SECURITY_TOKEN_INDEX ) ; Node * current_token = LoadContextElement ( native_context , Context :: SECURITY_TOKEN_INDEX ) ; Branch ( WordEqual ( expected_token , current_token ) , can_access , miss ) ; }
bool Parcel :: verifyBufferObject ( const binder_buffer_object * buffer_obj , size_t size , uint32_t flags , size_t parent , size_t parentOffset ) const { if ( buffer_obj -> length != size ) { ALOGE ( "Buffer length %" PRIu64 " does not match expected size %zu." , static_cast < uint64_t > ( buffer_obj -> length ) , size ) ; return false ; } if ( buffer_obj -> flags != flags ) { ALOGE ( "Buffer flags 0x%02X do not match expected flags 0x%02X." , buffer_obj -> flags , flags ) ; return false ; } if ( flags & BINDER_BUFFER_FLAG_HAS_PARENT ) { if ( buffer_obj -> parent != parent ) { ALOGE ( "Buffer parent %" PRIu64 " does not match expected parent %zu." , static_cast < uint64_t > ( buffer_obj -> parent ) , parent ) ; return false ; } if ( buffer_obj -> parent_offset != parentOffset ) { ALOGE ( "Buffer parent offset %" PRIu64 " does not match expected offset %zu." , static_cast < uint64_t > ( buffer_obj -> parent_offset ) , parentOffset ) ; return false ; } } return true ; }
already_AddRefed < ImageBitmap > ImageBitmap :: CreateInternal ( nsIGlobalObject * aGlobal , HTMLVideoElement & aVideoEl , const Maybe < IntRect > & aCropRect , ErrorResult & aRv ) { aVideoEl . MarkAsContentSource ( mozilla :: dom :: HTMLVideoElement :: CallerAPI :: CREATE_IMAGEBITMAP ) ; if ( aVideoEl . NetworkState ( ) == NETWORK_EMPTY ) { aRv . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return nullptr ; } if ( aVideoEl . ReadyState ( ) <= HAVE_METADATA ) { aRv . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return nullptr ; } nsCOMPtr < nsIPrincipal > principal = aVideoEl . GetCurrentVideoPrincipal ( ) ; bool CORSUsed = aVideoEl . GetCORSMode ( ) != CORS_NONE ; bool writeOnly = ! CheckSecurityForElements ( false , CORSUsed , principal ) ; RefPtr < layers :: Image > data = aVideoEl . GetCurrentImage ( ) ; if ( ! data ) { aRv . Throw ( NS_ERROR_NOT_AVAILABLE ) ; return nullptr ; } RefPtr < ImageBitmap > ret = new ImageBitmap ( aGlobal , data , writeOnly ) ; if ( ret && aCropRect . isSome ( ) ) { ret -> SetPictureRect ( aCropRect . ref ( ) , aRv ) ; } return ret . forget ( ) ; }
Crypto :: GetRandomValues ( JSContext * aCx , const ArrayBufferView & aArray , ErrorResult & aRv ) { NS_ABORT_IF_FALSE ( NS_IsMainThread ( ) , "Called on the wrong thread" ) ; JS :: Rooted < JSObject * > view ( aCx , aArray . Obj ( ) ) ; switch ( JS_GetArrayBufferViewType ( view ) ) { case TYPE_INT8 : case TYPE_UINT8 : case TYPE_UINT8_CLAMPED : case TYPE_INT16 : case TYPE_UINT16 : case TYPE_INT32 : case TYPE_UINT32 : break ; default : aRv . Throw ( NS_ERROR_DOM_TYPE_MISMATCH_ERR ) ; return nullptr ; } uint32_t dataLen = aArray . Length ( ) ; if ( dataLen == 0 ) { NS_WARNING ( "ArrayBufferView length is 0, cannot continue" ) ; return view ; } else if ( dataLen > 65536 ) { aRv . Throw ( NS_ERROR_DOM_QUOTA_EXCEEDED_ERR ) ; return nullptr ; } uint8_t * data = aArray . Data ( ) ; if ( XRE_GetProcessType ( ) != GeckoProcessType_Default ) { InfallibleTArray < uint8_t > randomValues ; ContentChild * cc = ContentChild :: GetSingleton ( ) ; if ( ! cc -> SendGetRandomValues ( dataLen , & randomValues ) || randomValues . Length ( ) == 0 ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return nullptr ; } NS_ASSERTION ( dataLen == randomValues . Length ( ) , "Invalid length returned from parent process!" ) ; memcpy ( data , randomValues . Elements ( ) , dataLen ) ; } else { uint8_t * buf = GetRandomValues ( dataLen ) ; if ( ! buf ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return nullptr ; } memcpy ( data , buf , dataLen ) ; NS_Free ( buf ) ; } return view ; }
mrb_f_send ( mrb_state * mrb , mrb_value self ) { mrb_sym name ; mrb_value block , * regs ; mrb_method_t m ; struct RClass * c ; mrb_callinfo * ci = mrb -> c -> ci ; int n = ci -> n ; if ( ci -> cci > CINFO_NONE ) { funcall : ; const mrb_value * argv ; mrb_int argc ; mrb_get_args ( mrb , "n*&" , & name , & argv , & argc , & block ) ; return mrb_funcall_with_block ( mrb , self , name , argc , argv , block ) ; } regs = mrb -> c -> ci -> stack + 1 ; if ( n == 0 ) { mrb_argnum_error ( mrb , 0 , 1 , - 1 ) ; } else if ( n == 15 ) { name = mrb_obj_to_sym ( mrb , RARRAY_PTR ( regs [ 0 ] ) [ 0 ] ) ; } else { name = mrb_obj_to_sym ( mrb , regs [ 0 ] ) ; } c = mrb_class ( mrb , self ) ; m = mrb_method_search_vm ( mrb , & c , name ) ; if ( MRB_METHOD_UNDEF_P ( m ) ) { goto funcall ; } ci -> mid = name ; ci -> u . target_class = c ; if ( n == 15 ) { regs [ 0 ] = mrb_ary_subseq ( mrb , regs [ 0 ] , 1 , RARRAY_LEN ( regs [ 0 ] ) - 1 ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { regs [ i ] = regs [ i + 1 ] ; } regs [ n ] = regs [ n + 1 ] ; if ( ci -> nk > 0 ) { regs [ n + 1 ] = regs [ n + 2 ] ; } ci -> n -- ; } if ( MRB_METHOD_CFUNC_P ( m ) ) { if ( MRB_METHOD_NOARG_P ( m ) ) { check_method_noarg ( mrb , ci ) ; } if ( MRB_METHOD_PROC_P ( m ) ) { mrb_vm_ci_proc_set ( ci , MRB_METHOD_PROC ( m ) ) ; } return MRB_METHOD_CFUNC ( m ) ( mrb , self ) ; } return exec_irep ( mrb , self , MRB_METHOD_PROC ( m ) ) ; }
static BT_HDR * avrc_vendor_msg ( tAVRC_MSG_VENDOR * p_msg ) { BT_HDR * p_cmd ; uint8_t * p_data ; CHECK ( p_msg != NULL ) ; CHECK ( AVRC_META_CMD_BUF_SIZE > ( AVRC_MIN_CMD_LEN + p_msg -> vendor_len ) ) ; p_cmd = ( BT_HDR * ) osi_malloc ( AVRC_META_CMD_BUF_SIZE ) ; p_cmd -> offset = AVCT_MSG_OFFSET ; p_data = ( uint8_t * ) ( p_cmd + 1 ) + p_cmd -> offset ; * p_data ++ = ( p_msg -> hdr . ctype & AVRC_CTYPE_MASK ) ; * p_data ++ = ( p_msg -> hdr . subunit_type < < AVRC_SUBTYPE_SHIFT ) | p_msg -> hdr . subunit_id ; * p_data ++ = AVRC_OP_VENDOR ; AVRC_CO_ID_TO_BE_STREAM ( p_data , p_msg -> company_id ) ; if ( p_msg -> vendor_len && p_msg -> p_vendor_data ) memcpy ( p_data , p_msg -> p_vendor_data , p_msg -> vendor_len ) ; p_cmd -> len = ( uint16_t ) ( p_data + p_msg -> vendor_len - ( uint8_t * ) ( p_cmd + 1 ) - p_cmd -> offset ) ; p_cmd -> layer_specific = AVCT_DATA_CTRL ; return p_cmd ; }
Handle < BigInt > MutableBigInt :: TruncateAndSubFromPowerOfTwo ( Isolate * isolate , int n , Handle < BigInt > x , bool result_sign ) { DCHECK_NE ( n , 0 ) ; DCHECK_LE ( n , kMaxLengthBits ) ; int needed_digits = ( n + ( kDigitBits - 1 ) ) / kDigitBits ; DCHECK_LE ( needed_digits , kMaxLength ) ; Handle < MutableBigInt > result = New ( isolate , needed_digits ) . ToHandleChecked ( ) ; int i = 0 ; int last = needed_digits - 1 ; int x_length = x -> length ( ) ; digit_t borrow = 0 ; int limit = Min ( last , x_length ) ; for ( ; i < limit ; i ++ ) { digit_t new_borrow = 0 ; digit_t difference = digit_sub ( 0 , x -> digit ( i ) , & new_borrow ) ; difference = digit_sub ( difference , borrow , & new_borrow ) ; result -> set_digit ( i , difference ) ; borrow = new_borrow ; } for ( ; i < last ; i ++ ) { digit_t new_borrow = 0 ; digit_t difference = digit_sub ( 0 , borrow , & new_borrow ) ; result -> set_digit ( i , difference ) ; borrow = new_borrow ; } digit_t msd = last < x_length ? x -> digit ( last ) : 0 ; int msd_bits_consumed = n % kDigitBits ; digit_t result_msd ; if ( msd_bits_consumed == 0 ) { digit_t new_borrow = 0 ; result_msd = digit_sub ( 0 , msd , & new_borrow ) ; result_msd = digit_sub ( result_msd , borrow , & new_borrow ) ; } else { int drop = kDigitBits - msd_bits_consumed ; msd = ( msd < < drop ) > > drop ; digit_t minuend_msd = static_cast < digit_t > ( 1 ) < < ( kDigitBits - drop ) ; digit_t new_borrow = 0 ; result_msd = digit_sub ( minuend_msd , msd , & new_borrow ) ; result_msd = digit_sub ( result_msd , borrow , & new_borrow ) ; DCHECK_EQ ( new_borrow , 0 ) ; result_msd &= ( minuend_msd - 1 ) ; } result -> set_digit ( last , result_msd ) ; result -> set_sign ( result_sign ) ; return MakeImmutable ( result ) ; }
static int pfkey_register ( struct sock * sk , struct sk_buff * skb , const struct sadb_msg * hdr , void * const * ext_hdrs ) { struct pfkey_sock * pfk = pfkey_sk ( sk ) ; struct sk_buff * supp_skb ; if ( hdr -> sadb_msg_satype > SADB_SATYPE_MAX ) return - EINVAL ; if ( hdr -> sadb_msg_satype != SADB_SATYPE_UNSPEC ) { if ( pfk -> registered & ( 1 < < hdr -> sadb_msg_satype ) ) return - EEXIST ; pfk -> registered |= ( 1 < < hdr -> sadb_msg_satype ) ; } xfrm_probe_algs ( ) ; supp_skb = compose_sadb_supported ( hdr , GFP_KERNEL | __GFP_ZERO ) ; if ( ! supp_skb ) { if ( hdr -> sadb_msg_satype != SADB_SATYPE_UNSPEC ) pfk -> registered &= ~ ( 1 < < hdr -> sadb_msg_satype ) ; return - ENOBUFS ; } pfkey_broadcast ( supp_skb , GFP_KERNEL , BROADCAST_REGISTERED , sk , sock_net ( sk ) ) ; return 0 ; }
xmlSchemaElementDump ( xmlSchemaElementPtr elem , FILE * output , const xmlChar * name ATTRIBUTE_UNUSED , const xmlChar * namespace ATTRIBUTE_UNUSED , const xmlChar * context ATTRIBUTE_UNUSED ) { if ( elem == NULL ) return ; fprintf ( output , "Element" ) ; if ( elem -> flags & XML_SCHEMAS_ELEM_GLOBAL ) fprintf ( output , " (global)" ) ; fprintf ( output , ": '%s' " , elem -> name ) ; if ( namespace != NULL ) fprintf ( output , "ns '%s'" , namespace ) ; fprintf ( output , "\n" ) ; #if 0 if ( ( elem -> minOccurs != 1 ) || ( elem -> maxOccurs != 1 ) ) { fprintf ( output , "  min %d " , elem -> minOccurs ) ; if ( elem -> maxOccurs >= UNBOUNDED ) fprintf ( output , "max: unbounded\n" ) ; else if ( elem -> maxOccurs != 1 ) fprintf ( output , "max: %d\n" , elem -> maxOccurs ) ; else fprintf ( output , "\n" ) ; } #endif if ( ( elem -> flags & XML_SCHEMAS_ELEM_NILLABLE ) || ( elem -> flags & XML_SCHEMAS_ELEM_ABSTRACT ) || ( elem -> flags & XML_SCHEMAS_ELEM_FIXED ) || ( elem -> flags & XML_SCHEMAS_ELEM_DEFAULT ) ) { fprintf ( output , "  props: " ) ; if ( elem -> flags & XML_SCHEMAS_ELEM_FIXED ) fprintf ( output , "[fixed] " ) ; if ( elem -> flags & XML_SCHEMAS_ELEM_DEFAULT ) fprintf ( output , "[default] " ) ; if ( elem -> flags & XML_SCHEMAS_ELEM_ABSTRACT ) fprintf ( output , "[abstract] " ) ; if ( elem -> flags & XML_SCHEMAS_ELEM_NILLABLE ) fprintf ( output , "[nillable] " ) ; fprintf ( output , "\n" ) ; } if ( elem -> value != NULL ) fprintf ( output , "  value: '%s'\n" , elem -> value ) ; if ( elem -> namedType != NULL ) { fprintf ( output , "  type: '%s' " , elem -> namedType ) ; if ( elem -> namedTypeNs != NULL ) fprintf ( output , "ns '%s'\n" , elem -> namedTypeNs ) ; else fprintf ( output , "\n" ) ; } else if ( elem -> subtypes != NULL ) { xmlSchemaTypeDump ( elem -> subtypes , output ) ; } if ( elem -> substGroup != NULL ) { fprintf ( output , "  substitutionGroup: '%s' " , elem -> substGroup ) ; if ( elem -> substGroupNs != NULL ) fprintf ( output , "ns '%s'\n" , elem -> substGroupNs ) ; else fprintf ( output , "\n" ) ; } }
sctp_audit_stream_queues_for_size ( struct sctp_inpcb * inp , struct sctp_tcb * stcb ) { struct sctp_stream_queue_pending * sp ; unsigned int i , chks_in_queue = 0 ; int being_filled = 0 ; if ( ( stcb == NULL ) || ( inp == NULL ) ) return ; if ( stcb -> asoc . sent_queue_retran_cnt ) { SCTP_PRINTF ( "Hmm, sent_queue_retran_cnt is non-zero %d\n" , stcb -> asoc . sent_queue_retran_cnt ) ; stcb -> asoc . sent_queue_retran_cnt = 0 ; } if ( stcb -> asoc . ss_functions . sctp_ss_is_empty ( stcb , & stcb -> asoc ) ) { stcb -> asoc . ss_functions . sctp_ss_init ( stcb , & stcb -> asoc , 0 ) ; if ( ! stcb -> asoc . ss_functions . sctp_ss_is_empty ( stcb , & stcb -> asoc ) ) { SCTP_PRINTF ( "Found additional streams NOT managed by scheduler, corrected\n" ) ; } else { stcb -> asoc . total_output_queue_size = 0 ; } } for ( i = 0 ; i < stcb -> asoc . streamoutcnt ; i ++ ) { if ( ! TAILQ_EMPTY ( & stcb -> asoc . strmout [ i ] . outqueue ) ) { TAILQ_FOREACH ( sp , & stcb -> asoc . strmout [ i ] . outqueue , next ) { if ( sp -> msg_is_complete ) being_filled ++ ; chks_in_queue ++ ; } } } if ( chks_in_queue != stcb -> asoc . stream_queue_cnt ) { SCTP_PRINTF ( "Hmm, stream queue cnt at %d I counted %d in stream out wheel\n" , stcb -> asoc . stream_queue_cnt , chks_in_queue ) ; } if ( chks_in_queue ) { sctp_chunk_output ( inp , stcb , SCTP_OUTPUT_FROM_T3 , SCTP_SO_NOT_LOCKED ) ; if ( ( TAILQ_EMPTY ( & stcb -> asoc . send_queue ) ) && ( TAILQ_EMPTY ( & stcb -> asoc . sent_queue ) ) ) { if ( being_filled == 0 ) { SCTP_PRINTF ( "Still nothing moved %d chunks are stuck\n" , chks_in_queue ) ; } } } else { SCTP_PRINTF ( "Found no chunks on any queue tot:%lu\n" , ( u_long ) stcb -> asoc . total_output_queue_size ) ; stcb -> asoc . total_output_queue_size = 0 ; } }
int random_get_bytes ( void * buf , size_t len ) { int ret ; u8 * bytes = buf ; size_t left ; wpa_printf ( MSG_MSGDUMP , "Get randomness: len=%u entropy=%u" , ( unsigned int ) len , entropy ) ; ret = os_get_random ( buf , len ) ; wpa_hexdump_key ( MSG_EXCESSIVE , "random from os_get_random" , buf , len ) ; left = len ; while ( left ) { size_t siz , i ; u8 tmp [ EXTRACT_LEN ] ; random_extract ( tmp ) ; wpa_hexdump_key ( MSG_EXCESSIVE , "random from internal pool" , tmp , sizeof ( tmp ) ) ; siz = left > EXTRACT_LEN ? EXTRACT_LEN : left ; for ( i = 0 ; i < siz ; i ++ ) * bytes ++ ^= tmp [ i ] ; left -= siz ; } #ifdef CONFIG_FIPS bytes = buf ; left = len ; while ( left ) { size_t siz , i ; u8 tmp [ EXTRACT_LEN ] ; if ( crypto_get_random ( tmp , sizeof ( tmp ) ) < 0 ) { wpa_printf ( MSG_ERROR , "random: No entropy available " "for generating strong random bytes" ) ; return - 1 ; } wpa_hexdump_key ( MSG_EXCESSIVE , "random from crypto module" , tmp , sizeof ( tmp ) ) ; siz = left > EXTRACT_LEN ? EXTRACT_LEN : left ; for ( i = 0 ; i < siz ; i ++ ) * bytes ++ ^= tmp [ i ] ; left -= siz ; } #endif /* CONFIG_FIPS */ wpa_hexdump_key ( MSG_EXCESSIVE , "mixed random" , buf , len ) ; if ( entropy < len ) entropy = 0 ; else entropy -= len ; return ret ; }
static OPJ_BOOL opj_j2k_decode_one_tile ( opj_j2k_t * p_j2k , opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { OPJ_BOOL l_go_on = OPJ_TRUE ; OPJ_UINT32 l_current_tile_no ; OPJ_UINT32 l_tile_no_to_dec ; OPJ_UINT32 l_data_size , l_max_data_size ; OPJ_INT32 l_tile_x0 , l_tile_y0 , l_tile_x1 , l_tile_y1 ; OPJ_UINT32 l_nb_comps ; OPJ_BYTE * l_current_data ; l_current_data = ( OPJ_BYTE * ) opj_malloc ( 1000 ) ; if ( ! l_current_data ) { opj_event_msg ( p_manager , EVT_ERROR , "Not enough memory to decode one tile\n" ) ; return OPJ_FALSE ; } l_max_data_size = 1000 ; if ( ! p_j2k -> cstr_index -> tile_index ) { if ( ! opj_j2k_allocate_tile_element_cstr_index ( p_j2k ) ) { opj_free ( l_current_data ) ; return OPJ_FALSE ; } } l_tile_no_to_dec = ( OPJ_UINT32 ) p_j2k -> m_specific_param . m_decoder . m_tile_ind_to_dec ; if ( p_j2k -> cstr_index -> tile_index ) if ( p_j2k -> cstr_index -> tile_index -> tp_index ) { if ( ! p_j2k -> cstr_index -> tile_index [ l_tile_no_to_dec ] . nb_tps ) { if ( ! ( opj_stream_read_seek ( p_stream , p_j2k -> m_specific_param . m_decoder . m_last_sot_read_pos + 2 , p_manager ) ) ) { opj_event_msg ( p_manager , EVT_ERROR , "Problem with seek function\n" ) ; opj_free ( l_current_data ) ; return OPJ_FALSE ; } } else { if ( ! ( opj_stream_read_seek ( p_stream , p_j2k -> cstr_index -> tile_index [ l_tile_no_to_dec ] . tp_index [ 0 ] . start_pos + 2 , p_manager ) ) ) { opj_event_msg ( p_manager , EVT_ERROR , "Problem with seek function\n" ) ; opj_free ( l_current_data ) ; return OPJ_FALSE ; } } if ( p_j2k -> m_specific_param . m_decoder . m_state == J2K_STATE_EOC ) p_j2k -> m_specific_param . m_decoder . m_state = J2K_STATE_TPHSOT ; } for ( ; ; ) { if ( ! opj_j2k_read_tile_header ( p_j2k , & l_current_tile_no , & l_data_size , & l_tile_x0 , & l_tile_y0 , & l_tile_x1 , & l_tile_y1 , & l_nb_comps , & l_go_on , p_stream , p_manager ) ) { opj_free ( l_current_data ) ; return OPJ_FALSE ; } if ( ! l_go_on ) { break ; } if ( l_data_size > l_max_data_size ) { OPJ_BYTE * l_new_current_data = ( OPJ_BYTE * ) opj_realloc ( l_current_data , l_data_size ) ; if ( ! l_new_current_data ) { opj_free ( l_current_data ) ; l_current_data = NULL ; opj_event_msg ( p_manager , EVT_ERROR , "Not enough memory to decode tile %d/%d\n" , l_current_tile_no , ( p_j2k -> m_cp . th * p_j2k -> m_cp . tw ) - 1 ) ; return OPJ_FALSE ; } l_current_data = l_new_current_data ; l_max_data_size = l_data_size ; } if ( ! opj_j2k_decode_tile ( p_j2k , l_current_tile_no , l_current_data , l_data_size , p_stream , p_manager ) ) { opj_free ( l_current_data ) ; return OPJ_FALSE ; } opj_event_msg ( p_manager , EVT_INFO , "Tile %d/%d has been decoded.\n" , l_current_tile_no , ( p_j2k -> m_cp . th * p_j2k -> m_cp . tw ) - 1 ) ; if ( ! opj_j2k_update_image_data ( p_j2k -> m_tcd , l_current_data , p_j2k -> m_output_image ) ) { opj_free ( l_current_data ) ; return OPJ_FALSE ; } opj_event_msg ( p_manager , EVT_INFO , "Image data has been updated with tile %d.\n\n" , l_current_tile_no ) ; if ( l_current_tile_no == l_tile_no_to_dec ) { if ( ! ( opj_stream_read_seek ( p_stream , p_j2k -> cstr_index -> main_head_end + 2 , p_manager ) ) ) { opj_event_msg ( p_manager , EVT_ERROR , "Problem with seek function\n" ) ; opj_free ( l_current_data ) ; return OPJ_FALSE ; } break ; } else { opj_event_msg ( p_manager , EVT_WARNING , "Tile read, decode and updated is not the desired (%d vs %d).\n" , l_current_tile_no , l_tile_no_to_dec ) ; } } opj_free ( l_current_data ) ; return OPJ_TRUE ; }
void * arm_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) ) return memory ; return __dma_alloc ( dev , size , handle , gfp , prot , false , __builtin_return_address ( 0 ) ) ; }
nsXBLProtoImpl :: Read ( nsIScriptContext * aContext , nsIObjectInputStream * aStream , nsXBLPrototypeBinding * aBinding , nsIScriptGlobalObject * aGlobal ) { JSContext * cx = aContext -> GetNativeContext ( ) ; JSObject * global = aGlobal -> GetGlobalJSObject ( ) ; JSObject * classObject ; bool classObjectIsNew = false ; nsresult rv = aBinding -> InitClass ( mClassName , cx , global , global , & classObject , & classObjectIsNew ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; MOZ_ASSERT ( classObject ) ; MOZ_ASSERT ( classObjectIsNew ) ; mClassObject = classObject ; nsXBLProtoImplField * previousField = nullptr ; nsXBLProtoImplMember * previousMember = nullptr ; do { XBLBindingSerializeDetails type ; rv = aStream -> Read8 ( & type ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( type == XBLBinding_Serialize_NoMoreItems ) break ; switch ( type & XBLBinding_Serialize_Mask ) { case XBLBinding_Serialize_Field : { nsXBLProtoImplField * field = new nsXBLProtoImplField ( type & XBLBinding_Serialize_ReadOnly ) ; rv = field -> Read ( aContext , aStream ) ; if ( NS_FAILED ( rv ) ) { delete field ; return rv ; } if ( previousField ) { previousField -> SetNext ( field ) ; } else { mFields = field ; } previousField = field ; break ; } case XBLBinding_Serialize_GetterProperty : case XBLBinding_Serialize_SetterProperty : case XBLBinding_Serialize_GetterSetterProperty : { nsAutoString name ; nsresult rv = aStream -> ReadString ( name ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsXBLProtoImplProperty * prop = new nsXBLProtoImplProperty ( name . get ( ) , type & XBLBinding_Serialize_ReadOnly ) ; rv = prop -> Read ( aContext , aStream , type & XBLBinding_Serialize_Mask ) ; if ( NS_FAILED ( rv ) ) { delete prop ; return rv ; } previousMember = AddMember ( prop , previousMember ) ; break ; } case XBLBinding_Serialize_Method : { nsAutoString name ; rv = aStream -> ReadString ( name ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; nsXBLProtoImplMethod * method = new nsXBLProtoImplMethod ( name . get ( ) ) ; rv = method -> Read ( aContext , aStream ) ; if ( NS_FAILED ( rv ) ) { delete method ; return rv ; } previousMember = AddMember ( method , previousMember ) ; break ; } case XBLBinding_Serialize_Constructor : { mConstructor = new nsXBLProtoImplAnonymousMethod ( ) ; rv = mConstructor -> Read ( aContext , aStream ) ; if ( NS_FAILED ( rv ) ) { delete mConstructor ; mConstructor = nullptr ; return rv ; } previousMember = AddMember ( mConstructor , previousMember ) ; break ; } case XBLBinding_Serialize_Destructor : { mDestructor = new nsXBLProtoImplAnonymousMethod ( ) ; rv = mDestructor -> Read ( aContext , aStream ) ; if ( NS_FAILED ( rv ) ) { delete mDestructor ; mDestructor = nullptr ; return rv ; } previousMember = AddMember ( mDestructor , previousMember ) ; break ; } default : NS_ERROR ( "Unexpected binding member type" ) ; break ; } } while ( 1 ) ; return NS_OK ; }
void nsViewManager :: Refresh ( nsView * aView , const nsIntRegion & aRegion , bool aWillSendDidPaint ) { NS_ASSERTION ( aView -> GetViewManager ( ) == this , "wrong view manager" ) ; nsRegion damageRegion = aRegion . ToAppUnits ( AppUnitsPerDevPixel ( ) ) ; damageRegion . MoveBy ( - aView -> ViewToWidgetOffset ( ) ) ; if ( damageRegion . IsEmpty ( ) ) { #ifdef DEBUG_roc nsRect viewRect = aView -> GetDimensions ( ) ; nsRect damageRect = damageRegion . GetBounds ( ) ; printf ( "XXX Damage rectangle (%d,%d,%d,%d) does not intersect the widget's view (%d,%d,%d,%d)!\n" , damageRect . x , damageRect . y , damageRect . width , damageRect . height , viewRect . x , viewRect . y , viewRect . width , viewRect . height ) ; #endif return ; } if ( aView -> ForcedRepaint ( ) && IsRefreshDriverPaintingEnabled ( ) ) { ProcessPendingUpdates ( ) ; aView -> SetForcedRepaint ( false ) ; } nsIWidget * widget = aView -> GetWidget ( ) ; if ( ! widget ) { return ; } NS_ASSERTION ( ! IsPainting ( ) , "recursive painting not permitted" ) ; if ( IsPainting ( ) ) { RootViewManager ( ) -> mRecursiveRefreshPending = true ; return ; } { nsAutoScriptBlocker scriptBlocker ; SetPainting ( true ) ; NS_ASSERTION ( GetDisplayRootFor ( aView ) == aView , "Widgets that we paint must all be display roots" ) ; if ( mPresShell ) { #ifdef DEBUG_INVALIDATIONS printf ( "--COMPOSITE-- %p\n" , mPresShell ) ; #endif mPresShell -> Paint ( aView , damageRegion , ( IsRefreshDriverPaintingEnabled ( ) ? 0 : nsIPresShell :: PAINT_LAYERS ) | nsIPresShell :: PAINT_COMPOSITE | ( aWillSendDidPaint ? nsIPresShell :: PAINT_WILL_SEND_DID_PAINT : 0 ) ) ; #ifdef DEBUG_INVALIDATIONS printf ( "--ENDCOMPOSITE--\n" ) ; #endif mozilla :: StartupTimeline :: RecordOnce ( mozilla :: StartupTimeline :: FIRST_PAINT ) ; } SetPainting ( false ) ; } if ( RootViewManager ( ) -> mRecursiveRefreshPending ) { RootViewManager ( ) -> mRecursiveRefreshPending = false ; InvalidateAllViews ( ) ; } }
nfs4_state_set_mode_locked ( struct nfs4_state * state , mode_t mode ) { if ( state -> state == mode ) return ; if ( ( mode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) { if ( mode & FMODE_WRITE ) list_move ( & state -> open_states , & state -> owner -> so_states ) ; else list_move_tail ( & state -> open_states , & state -> owner -> so_states ) ; } state -> state = mode ; }
Node * WasmGraphBuilder :: BranchExpectFalse ( Node * cond , Node * * true_node , Node * * false_node ) { return Branch ( mcgraph ( ) , cond , true_node , false_node , Control ( ) , BranchHint :: kFalse ) ; }
void RemoveProfiler ( Isolate * isolate , CpuProfiler * profiler ) { base :: LockGuard < base :: Mutex > lock ( & mutex_ ) ; auto range = profilers_ . equal_range ( isolate ) ; for ( auto it = range . first ; it != range . second ; ++ it ) { if ( it -> second != profiler ) continue ; profilers_ . erase ( it ) ; return ; } UNREACHABLE ( ) ; }
bool GifTranscoder :: renderImage ( GifFileType * gifIn , GifByteType * rasterBits , int imageIndex , int transparentColorIndex , ColorARGB * renderBuffer , ColorARGB bgColor , GifImageDesc prevImageDimens , int prevImageDisposalMode ) { ASSERT ( imageIndex < gifIn -> ImageCount , "Image index %d is out of bounds (count=%d)" , imageIndex , gifIn -> ImageCount ) ; ColorMapObject * colorMap = getColorMap ( gifIn ) ; if ( colorMap == NULL ) { LOGE ( "No GIF color map found" ) ; return false ; } if ( imageIndex == 0 ) { fillRect ( renderBuffer , gifIn -> SWidth , gifIn -> SHeight , 0 , 0 , gifIn -> SWidth , gifIn -> SHeight , bgColor ) ; } else if ( prevImageDisposalMode == DISPOSE_BACKGROUND ) { fillRect ( renderBuffer , gifIn -> SWidth , gifIn -> SHeight , prevImageDimens . Left , prevImageDimens . Top , prevImageDimens . Width , prevImageDimens . Height , TRANSPARENT ) ; } for ( int y = 0 ; y < gifIn -> Image . Height ; y ++ ) { for ( int x = 0 ; x < gifIn -> Image . Width ; x ++ ) { GifByteType colorIndex = * getPixel ( rasterBits , gifIn -> Image . Width , x , y ) ; int renderX = x + gifIn -> Image . Left ; int renderY = y + gifIn -> Image . Top ; if ( imageIndex > 0 && prevImageDisposalMode == DISPOSE_DO_NOT && colorIndex == transparentColorIndex ) { continue ; } ColorARGB * renderPixel = getPixel ( renderBuffer , gifIn -> SWidth , renderX , renderY ) ; * renderPixel = getColorARGB ( colorMap , transparentColorIndex , colorIndex ) ; } } return true ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { TfLiteTensor * output = GetOutput ( context , node , 0 ) ; TfLiteTensor * hits = GetOutput ( context , node , 1 ) ; const TfLiteTensor * lookup = GetInput ( context , node , 0 ) ; const TfLiteTensor * key = GetInput ( context , node , 1 ) ; const TfLiteTensor * value = GetInput ( context , node , 2 ) ; const int num_rows = SizeOfDimension ( value , 0 ) ; const int row_bytes = value -> bytes / num_rows ; void * pointer = nullptr ; DynamicBuffer buf ; for ( int i = 0 ; i < SizeOfDimension ( lookup , 0 ) ; i ++ ) { int idx = - 1 ; pointer = bsearch ( & ( lookup -> data . i32 [ i ] ) , key -> data . i32 , num_rows , sizeof ( int32_t ) , greater ) ; if ( pointer != nullptr ) { idx = ( reinterpret_cast < char * > ( pointer ) - ( key -> data . raw ) ) / sizeof ( int32_t ) ; } if ( idx >= num_rows || idx < 0 ) { if ( output -> type == kTfLiteString ) { buf . AddString ( nullptr , 0 ) ; } else { memset ( output -> data . raw + i * row_bytes , 0 , row_bytes ) ; } hits -> data . uint8 [ i ] = 0 ; } else { if ( output -> type == kTfLiteString ) { buf . AddString ( GetString ( value , idx ) ) ; } else { memcpy ( output -> data . raw + i * row_bytes , value -> data . raw + idx * row_bytes , row_bytes ) ; } hits -> data . uint8 [ i ] = 1 ; } } if ( output -> type == kTfLiteString ) { buf . WriteToTensorAsVector ( output ) ; } return kTfLiteOk ; }
static int ecdsa_sign_setup ( EC_KEY * eckey , BN_CTX * ctx_in , BIGNUM * * kinvp , BIGNUM * * rp , const uint8_t * digest , size_t digest_len ) { BN_CTX * ctx = NULL ; BIGNUM * k = NULL , * r = NULL , * X = NULL ; EC_POINT * tmp_point = NULL ; const EC_GROUP * group ; int ret = 0 ; if ( eckey == NULL || ( group = EC_KEY_get0_group ( eckey ) ) == NULL ) { OPENSSL_PUT_ERROR ( ECDSA , ERR_R_PASSED_NULL_PARAMETER ) ; return 0 ; } if ( ctx_in == NULL ) { if ( ( ctx = BN_CTX_new ( ) ) == NULL ) { OPENSSL_PUT_ERROR ( ECDSA , ERR_R_MALLOC_FAILURE ) ; return 0 ; } } else { ctx = ctx_in ; } k = BN_new ( ) ; r = BN_new ( ) ; X = BN_new ( ) ; if ( k == NULL || r == NULL || X == NULL ) { OPENSSL_PUT_ERROR ( ECDSA , ERR_R_MALLOC_FAILURE ) ; goto err ; } tmp_point = EC_POINT_new ( group ) ; if ( tmp_point == NULL ) { OPENSSL_PUT_ERROR ( ECDSA , ERR_R_EC_LIB ) ; goto err ; } const BIGNUM * order = EC_GROUP_get0_order ( group ) ; do { do { int ok ; if ( digest_len > 0 ) { ok = BN_generate_dsa_nonce ( k , order , EC_KEY_get0_private_key ( eckey ) , digest , digest_len , ctx ) ; } else { ok = BN_rand_range ( k , order ) ; } if ( ! ok ) { OPENSSL_PUT_ERROR ( ECDSA , ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED ) ; goto err ; } } while ( BN_is_zero ( k ) ) ; if ( ! BN_add ( k , k , order ) ) { goto err ; } if ( BN_num_bits ( k ) <= BN_num_bits ( order ) ) { if ( ! BN_add ( k , k , order ) ) { goto err ; } } if ( ! EC_POINT_mul ( group , tmp_point , k , NULL , NULL , ctx ) ) { OPENSSL_PUT_ERROR ( ECDSA , ERR_R_EC_LIB ) ; goto err ; } if ( ! EC_POINT_get_affine_coordinates_GFp ( group , tmp_point , X , NULL , ctx ) ) { OPENSSL_PUT_ERROR ( ECDSA , ERR_R_EC_LIB ) ; goto err ; } if ( ! BN_nnmod ( r , X , order , ctx ) ) { OPENSSL_PUT_ERROR ( ECDSA , ERR_R_BN_LIB ) ; goto err ; } } while ( BN_is_zero ( r ) ) ; if ( ec_group_get_mont_data ( group ) != NULL ) { if ( ! BN_set_word ( X , 2 ) || ! BN_sub ( X , order , X ) ) { OPENSSL_PUT_ERROR ( ECDSA , ERR_R_BN_LIB ) ; goto err ; } BN_set_flags ( X , BN_FLG_CONSTTIME ) ; if ( ! BN_mod_exp_mont_consttime ( k , k , X , order , ctx , ec_group_get_mont_data ( group ) ) ) { OPENSSL_PUT_ERROR ( ECDSA , ERR_R_BN_LIB ) ; goto err ; } } else if ( ! BN_mod_inverse ( k , k , order , ctx ) ) { OPENSSL_PUT_ERROR ( ECDSA , ERR_R_BN_LIB ) ; goto err ; } BN_clear_free ( * rp ) ; BN_clear_free ( * kinvp ) ; * rp = r ; * kinvp = k ; ret = 1 ; err : if ( ! ret ) { BN_clear_free ( k ) ; BN_clear_free ( r ) ; } if ( ctx_in == NULL ) { BN_CTX_free ( ctx ) ; } EC_POINT_free ( tmp_point ) ; BN_clear_free ( X ) ; return ret ; }
void IMEHandler :: OnDestroyWindow ( nsWindow * aWindow ) { if ( sFocusedWindow == aWindow ) { MOZ_ASSERT ( aWindow -> GetInputContext ( ) . IsOriginContentProcess ( ) , "input context of focused widget should've been set by a remote " "process " "if IME focus isn't cleared before destroying the widget" ) ; NotifyIME ( aWindow , IMENotification ( NOTIFY_IME_OF_BLUR ) ) ; } #ifdef NS_ENABLE_TSF if ( ! sIsInTSFMode ) { SetInputScopeForIMM32 ( aWindow , EmptyString ( ) , EmptyString ( ) ) ; } #endif  // #ifdef NS_ENABLE_TSF AssociateIMEContext ( aWindow , true ) ; }
static ScreenCell * realloc_buffer ( VTermScreen * screen , ScreenCell * buffer , int new_rows , int new_cols ) { ScreenCell * new_buffer = vterm_allocator_malloc ( screen -> vt , sizeof ( ScreenCell ) * new_rows * new_cols ) ; int row , col ; for ( row = 0 ; row < new_rows ; row ++ ) { for ( col = 0 ; col < new_cols ; col ++ ) { ScreenCell * new_cell = new_buffer + row * new_cols + col ; if ( buffer && row < screen -> rows && col < screen -> cols ) * new_cell = buffer [ row * screen -> cols + col ] ; else { new_cell -> chars [ 0 ] = 0 ; new_cell -> pen = screen -> pen ; } } } if ( buffer ) vterm_allocator_free ( screen -> vt , buffer ) ; return new_buffer ; }
WORD32 ih264d_get_buf_info ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec ; UWORD8 i = 0 ; UWORD16 pic_wd , pic_ht ; ivd_ctl_getbufinfo_op_t * ps_ctl_op = ( ivd_ctl_getbufinfo_op_t * ) pv_api_op ; UNUSED ( pv_api_ip ) ; ps_ctl_op -> u4_error_code = 0 ; ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; ps_ctl_op -> u4_min_num_in_bufs = MIN_IN_BUFS ; if ( ps_dec -> u1_chroma_format == IV_YUV_420P ) ps_ctl_op -> u4_min_num_out_bufs = MIN_OUT_BUFS_420 ; else if ( ps_dec -> u1_chroma_format == IV_YUV_422ILE ) ps_ctl_op -> u4_min_num_out_bufs = MIN_OUT_BUFS_422ILE ; else if ( ps_dec -> u1_chroma_format == IV_RGB_565 ) ps_ctl_op -> u4_min_num_out_bufs = MIN_OUT_BUFS_RGB565 ; else if ( ( ps_dec -> u1_chroma_format == IV_YUV_420SP_UV ) || ( ps_dec -> u1_chroma_format == IV_YUV_420SP_VU ) ) ps_ctl_op -> u4_min_num_out_bufs = MIN_OUT_BUFS_420SP ; else { return IV_FAIL ; } ps_ctl_op -> u4_num_disp_bufs = 1 ; pic_wd = 0 ; pic_ht = 0 ; if ( ps_dec -> i4_header_decoded == 3 ) { if ( 0 == ps_dec -> u4_share_disp_buf ) { pic_wd = ps_dec -> u2_disp_width ; pic_ht = ps_dec -> u2_disp_height ; } else { pic_wd = ps_dec -> u2_frm_wd_y ; pic_ht = ps_dec -> u2_frm_ht_y ; } } for ( i = 0 ; i < ps_ctl_op -> u4_min_num_in_bufs ; i ++ ) { ps_ctl_op -> u4_min_in_buf_size [ i ] = MAX ( 256000 , pic_wd * pic_ht * 3 / 2 ) ; } if ( ( WORD32 ) ps_dec -> u4_app_disp_width > pic_wd ) pic_wd = ps_dec -> u4_app_disp_width ; if ( 0 == ps_dec -> u4_share_disp_buf ) ps_ctl_op -> u4_num_disp_bufs = 1 ; else { if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( ps_dec -> ps_cur_sps -> u1_vui_parameters_present_flag == 1 ) && ( 1 == ps_dec -> ps_cur_sps -> s_vui . u1_bitstream_restriction_flag ) ) { ps_ctl_op -> u4_num_disp_bufs = ps_dec -> ps_cur_sps -> s_vui . u4_num_reorder_frames + 1 ; } else { ps_ctl_op -> u4_num_disp_bufs = ih264d_get_dpb_size ( ps_dec -> ps_cur_sps ) ; } ps_ctl_op -> u4_num_disp_bufs += ps_dec -> ps_cur_sps -> u1_num_ref_frames + 1 ; } else { ps_ctl_op -> u4_num_disp_bufs = 32 ; } ps_ctl_op -> u4_num_disp_bufs = MAX ( ps_ctl_op -> u4_num_disp_bufs , 6 ) ; ps_ctl_op -> u4_num_disp_bufs = MIN ( ps_ctl_op -> u4_num_disp_bufs , 32 ) ; } if ( ps_dec -> u1_chroma_format == IV_YUV_420P ) { ps_ctl_op -> u4_min_out_buf_size [ 0 ] = ( pic_wd * pic_ht ) ; ps_ctl_op -> u4_min_out_buf_size [ 1 ] = ( pic_wd * pic_ht ) > > 2 ; ps_ctl_op -> u4_min_out_buf_size [ 2 ] = ( pic_wd * pic_ht ) > > 2 ; } else if ( ps_dec -> u1_chroma_format == IV_YUV_422ILE ) { ps_ctl_op -> u4_min_out_buf_size [ 0 ] = ( pic_wd * pic_ht ) * 2 ; ps_ctl_op -> u4_min_out_buf_size [ 1 ] = ps_ctl_op -> u4_min_out_buf_size [ 2 ] = 0 ; } else if ( ps_dec -> u1_chroma_format == IV_RGB_565 ) { ps_ctl_op -> u4_min_out_buf_size [ 0 ] = ( pic_wd * pic_ht ) * 2 ; ps_ctl_op -> u4_min_out_buf_size [ 1 ] = ps_ctl_op -> u4_min_out_buf_size [ 2 ] = 0 ; } else if ( ( ps_dec -> u1_chroma_format == IV_YUV_420SP_UV ) || ( ps_dec -> u1_chroma_format == IV_YUV_420SP_VU ) ) { ps_ctl_op -> u4_min_out_buf_size [ 0 ] = ( pic_wd * pic_ht ) ; ps_ctl_op -> u4_min_out_buf_size [ 1 ] = ( pic_wd * pic_ht ) > > 1 ; ps_ctl_op -> u4_min_out_buf_size [ 2 ] = 0 ; } ps_dec -> u4_num_disp_bufs_requested = ps_ctl_op -> u4_num_disp_bufs ; return IV_SUCCESS ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; switch ( input -> type ) { case kTfLiteFloat32 : return EvalImpl < kernel_type , kTfLiteFloat32 > ( context , node ) ; case kTfLiteUInt8 : return EvalImpl < kernel_type , kTfLiteUInt8 > ( context , node ) ; case kTfLiteInt8 : return EvalImpl < kernel_type , kTfLiteInt8 > ( context , node ) ; case kTfLiteInt16 : return EvalImpl < kernel_type , kTfLiteInt16 > ( context , node ) ; default : context -> ReportError ( context , "Type %d not currently supported." , input -> type ) ; return kTfLiteError ; } }
void jbd2_journal_lock_updates ( journal_t * journal ) { DEFINE_WAIT ( wait ) ; jbd2_might_wait_for_commit ( journal ) ; write_lock ( & journal -> j_state_lock ) ; ++ journal -> j_barrier_count ; if ( atomic_read ( & journal -> j_reserved_credits ) ) { write_unlock ( & journal -> j_state_lock ) ; wait_event ( journal -> j_wait_reserved , atomic_read ( & journal -> j_reserved_credits ) == 0 ) ; write_lock ( & journal -> j_state_lock ) ; } jbd2_journal_wait_updates ( journal ) ; write_unlock ( & journal -> j_state_lock ) ; mutex_lock ( & journal -> j_barrier ) ; }
void GetGlobal ( FullDecoder * decoder , Value * result , const GlobalIndexImmediate < validate > & imm ) { const auto * global = & env_ -> module -> globals [ imm . index ] ; if ( ! CheckSupportedType ( decoder , kTypes_ilfd , global -> type , "global" ) ) return ; LiftoffRegList pinned ; uint32_t offset = 0 ; LiftoffRegister addr = GetGlobalBaseAndOffset ( global , pinned , & offset ) ; LiftoffRegister value = pinned . set ( __ GetUnusedRegister ( reg_class_for ( global -> type ) , pinned ) ) ; LoadType type = LoadType :: ForValueType ( global -> type ) ; __ Load ( value , addr . gp ( ) , no_reg , offset , type , pinned ) ; __ PushRegister ( global -> type , value ) ; }
PJ_DEF ( pj_status_t ) pjsip_ua_register_dlg ( pjsip_user_agent * ua , pjsip_dialog * dlg ) { PJ_ASSERT_RETURN ( ua && dlg , PJ_EINVAL ) ; PJ_ASSERT_RETURN ( dlg -> local . info && dlg -> local . info -> tag . slen && dlg -> local . tag_hval != 0 , PJ_EBUG ) ; pj_mutex_lock ( mod_ua . mutex ) ; if ( dlg -> role == PJSIP_ROLE_UAC ) { struct dlg_set * dlg_set ; dlg_set = ( struct dlg_set * ) pj_hash_get_lower ( mod_ua . dlg_table , dlg -> local . info -> tag . ptr , ( unsigned ) dlg -> local . info -> tag . slen , & dlg -> local . tag_hval ) ; if ( dlg_set ) { pj_assert ( dlg_set -> dlg_list . next != ( void * ) & dlg_set -> dlg_list ) ; pj_list_push_back ( & dlg_set -> dlg_list , dlg ) ; dlg -> dlg_set = dlg_set ; } else { dlg_set = alloc_dlgset_node ( ) ; pj_list_init ( & dlg_set -> dlg_list ) ; pj_list_push_back ( & dlg_set -> dlg_list , dlg ) ; dlg -> dlg_set = dlg_set ; pj_hash_set_np_lower ( mod_ua . dlg_table , dlg -> local . info -> tag . ptr , ( unsigned ) dlg -> local . info -> tag . slen , dlg -> local . tag_hval , dlg_set -> ht_entry , dlg_set ) ; } } else { struct dlg_set * dlg_set ; dlg_set = alloc_dlgset_node ( ) ; pj_list_init ( & dlg_set -> dlg_list ) ; pj_list_push_back ( & dlg_set -> dlg_list , dlg ) ; dlg -> dlg_set = dlg_set ; pj_hash_set_np_lower ( mod_ua . dlg_table , dlg -> local . info -> tag . ptr , ( unsigned ) dlg -> local . info -> tag . slen , dlg -> local . tag_hval , dlg_set -> ht_entry , dlg_set ) ; } pj_mutex_unlock ( mod_ua . mutex ) ; return PJ_SUCCESS ; }
static int irda_recvmsg_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; size_t copied = 0 ; int target , err ; long timeo ; IRDA_DEBUG ( 3 , "%s()\n" , __func__ ) ; if ( ( err = sock_error ( sk ) ) < 0 ) return err ; if ( sock -> flags & __SO_ACCEPTCON ) return - EINVAL ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; err = 0 ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , noblock ) ; msg -> msg_namelen = 0 ; do { int chunk ; struct sk_buff * skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( skb == NULL ) { DEFINE_WAIT ( wait ) ; err = 0 ; if ( copied >= target ) break ; prepare_to_wait_exclusive ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; err = sock_error ( sk ) ; if ( err ) ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) ; else if ( noblock ) err = - EAGAIN ; else if ( signal_pending ( current ) ) err = sock_intr_errno ( timeo ) ; else if ( sk -> sk_state != TCP_ESTABLISHED ) err = - ENOTCONN ; else if ( skb_peek ( & sk -> sk_receive_queue ) == NULL ) schedule ( ) ; finish_wait ( sk_sleep ( sk ) , & wait ) ; if ( err ) return err ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( memcpy_toiovec ( msg -> msg_iov , skb -> data , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( copied == 0 ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; if ( ! ( flags & MSG_PEEK ) ) { skb_pull ( skb , chunk ) ; if ( skb -> len ) { IRDA_DEBUG ( 1 , "%s(), back on q!\n" , __func__ ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { IRDA_DEBUG ( 0 , "%s() questionable!?\n" , __func__ ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) < < 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , "%s(), Starting IrTTP\n" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }
list_table_status ( MYSQL * mysql , const char * db , const char * wild ) { char query [ 1024 ] , * end ; MYSQL_RES * result ; MYSQL_ROW row ; end = strxmov ( query , "show table status from `" , db , "`" , NullS ) ; if ( wild && wild [ 0 ] ) strxmov ( end , " like '" , wild , "'" , NullS ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , "%s: Cannot get status for db: %s, table: %s: %s\n" , my_progname , db , wild ? wild : "" , mysql_error ( mysql ) ) ; if ( mysql_errno ( mysql ) == ER_PARSE_ERROR ) fprintf ( stderr , "This error probably means that your MySQL server doesn't support the\n\'show table status' command.\n" ) ; return 1 ; } printf ( "Database: %s" , db ) ; if ( wild ) printf ( "  Wildcard: %s" , wild ) ; putchar ( '\n' ) ; print_res_header ( result ) ; while ( ( row = mysql_fetch_row ( result ) ) ) print_res_row ( result , row ) ; print_res_top ( result ) ; mysql_free_result ( result ) ; return 0 ; }
static int svc_can_register ( const uint16_t * name , size_t name_len , pid_t spid , uid_t uid ) { const char * perm = "add" ; return check_mac_perms_from_lookup ( spid , uid , perm , str8 ( name , name_len ) ) ? 1 : 0 ; }
static pj_status_t codec_open ( pjmedia_codec * codec , pjmedia_codec_param * attr ) { struct opus_data * opus_data = ( struct opus_data * ) codec -> codec_data ; int idx , err ; pj_bool_t auto_bit_rate = PJ_TRUE ; PJ_ASSERT_RETURN ( codec && attr && opus_data , PJ_EINVAL ) ; pj_mutex_lock ( opus_data -> mutex ) ; TRACE_ ( ( THIS_FILE , "%s:%d: - TRACE" , __FUNCTION__ , __LINE__ ) ) ; opus_data -> cfg . sample_rate = attr -> info . clock_rate ; opus_data -> cfg . channel_cnt = attr -> info . channel_cnt ; opus_data -> enc_ptime = opus_data -> dec_ptime = attr -> info . frm_ptime ; if ( ! opus_data -> enc ) { opus_data -> enc = pj_pool_zalloc ( opus_data -> pool , opus_encoder_get_size ( 2 ) ) ; } if ( ! opus_data -> dec ) { opus_data -> dec = pj_pool_zalloc ( opus_data -> pool , opus_decoder_get_size ( 2 ) ) ; } if ( ! opus_data -> enc_packer ) { opus_data -> enc_packer = pj_pool_zalloc ( opus_data -> pool , opus_repacketizer_get_size ( ) ) ; } if ( ! opus_data -> dec_packer ) { opus_data -> dec_packer = pj_pool_zalloc ( opus_data -> pool , opus_repacketizer_get_size ( ) ) ; } if ( ! opus_data -> enc || ! opus_data -> dec || ! opus_data -> enc_packer || ! opus_data -> dec_packer ) { PJ_LOG ( 2 , ( THIS_FILE , "Unable to allocate memory for the codec" ) ) ; pj_mutex_unlock ( opus_data -> mutex ) ; return PJ_ENOMEM ; } idx = find_fmtp ( & attr -> setting . enc_fmtp , & STR_MAX_BIT_RATE , PJ_FALSE ) ; if ( idx >= 0 ) { unsigned rate ; auto_bit_rate = PJ_FALSE ; rate = ( unsigned ) pj_strtoul ( & attr -> setting . enc_fmtp . param [ idx ] . val ) ; if ( rate < attr -> info . avg_bps ) attr -> info . avg_bps = rate ; } idx = find_fmtp ( & attr -> setting . enc_fmtp , & STR_INBAND_FEC , PJ_FALSE ) ; if ( idx >= 0 ) { unsigned plc ; plc = ( unsigned ) pj_strtoul ( & attr -> setting . enc_fmtp . param [ idx ] . val ) ; attr -> setting . plc = plc > 0 ? PJ_TRUE : PJ_FALSE ; } idx = find_fmtp ( & attr -> setting . enc_fmtp , & STR_DTX , PJ_FALSE ) ; if ( idx >= 0 ) { unsigned vad ; vad = ( unsigned ) pj_strtoul ( & attr -> setting . enc_fmtp . param [ idx ] . val ) ; attr -> setting . vad = vad > 0 ? PJ_TRUE : PJ_FALSE ; } idx = find_fmtp ( & attr -> setting . enc_fmtp , & STR_CBR , PJ_FALSE ) ; if ( idx >= 0 ) { unsigned cbr ; cbr = ( unsigned ) pj_strtoul ( & attr -> setting . enc_fmtp . param [ idx ] . val ) ; opus_data -> cfg . cbr = cbr > 0 ? PJ_TRUE : PJ_FALSE ; } idx = find_fmtp ( & attr -> setting . dec_fmtp , & STR_MAX_BIT_RATE , PJ_FALSE ) ; if ( idx >= 0 ) { unsigned rate ; rate = ( unsigned ) pj_strtoul ( & attr -> setting . dec_fmtp . param [ idx ] . val ) ; if ( rate < attr -> info . avg_bps ) attr -> info . avg_bps = rate ; } TRACE_ ( ( THIS_FILE , "%s:%d: sample_rate: %u" , __FUNCTION__ , __LINE__ , opus_data -> cfg . sample_rate ) ) ; err = opus_encoder_init ( opus_data -> enc , opus_data -> cfg . sample_rate , attr -> info . channel_cnt , OPUS_APPLICATION_VOIP ) ; if ( err != OPUS_OK ) { PJ_LOG ( 2 , ( THIS_FILE , "Unable to create encoder" ) ) ; return PJMEDIA_CODEC_EFAILED ; } opus_encoder_ctl ( opus_data -> enc , OPUS_SET_SIGNAL ( OPUS_SIGNAL_VOICE ) ) ; opus_encoder_ctl ( opus_data -> enc , OPUS_SET_BITRATE ( auto_bit_rate ? OPUS_AUTO : attr -> info . avg_bps ) ) ; opus_encoder_ctl ( opus_data -> enc , OPUS_SET_DTX ( attr -> setting . vad ? 1 : 0 ) ) ; opus_encoder_ctl ( opus_data -> enc , OPUS_SET_INBAND_FEC ( attr -> setting . plc ? 1 : 0 ) ) ; opus_encoder_ctl ( opus_data -> enc , OPUS_SET_MAX_BANDWIDTH ( get_opus_bw_constant ( opus_data -> cfg . sample_rate ) ) ) ; opus_encoder_ctl ( opus_data -> enc , OPUS_SET_PACKET_LOSS_PERC ( opus_data -> cfg . packet_loss ) ) ; opus_encoder_ctl ( opus_data -> enc , OPUS_SET_COMPLEXITY ( opus_data -> cfg . complexity ) ) ; opus_encoder_ctl ( opus_data -> enc , OPUS_SET_VBR ( opus_data -> cfg . cbr ? 0 : 1 ) ) ; PJ_LOG ( 5 , ( THIS_FILE , "Initialize Opus encoder, sample rate: %d, " "avg bitrate: %d, vad: %d, plc: %d, pkt loss: %d, " "complexity: %d, constant bit rate: %d" , opus_data -> cfg . sample_rate , attr -> info . avg_bps , attr -> setting . vad ? 1 : 0 , attr -> setting . plc ? 1 : 0 , opus_data -> cfg . packet_loss , opus_data -> cfg . complexity , opus_data -> cfg . cbr ? 1 : 0 ) ) ; err = opus_decoder_init ( opus_data -> dec , opus_data -> cfg . sample_rate , attr -> info . channel_cnt ) ; if ( err != OPUS_OK ) { PJ_LOG ( 2 , ( THIS_FILE , "Unable to initialize decoder" ) ) ; return PJMEDIA_CODEC_EFAILED ; } opus_data -> dec_frame [ 0 ] . type = PJMEDIA_FRAME_TYPE_NONE ; opus_data -> dec_frame [ 0 ] . buf = pj_pool_zalloc ( opus_data -> pool , ( opus_data -> cfg . sample_rate / 1000 ) * 60 * attr -> info . channel_cnt * 2 ) ; opus_data -> dec_frame [ 1 ] . type = PJMEDIA_FRAME_TYPE_NONE ; opus_data -> dec_frame [ 1 ] . buf = pj_pool_zalloc ( opus_data -> pool , ( opus_data -> cfg . sample_rate / 1000 ) * 60 * attr -> info . channel_cnt * 2 ) ; opus_data -> dec_frame_index = - 1 ; opus_repacketizer_init ( opus_data -> enc_packer ) ; opus_repacketizer_init ( opus_data -> dec_packer ) ; pj_mutex_unlock ( opus_data -> mutex ) ; return PJ_SUCCESS ; }
void sas_init_disc ( struct sas_discovery * disc , struct asd_sas_port * port ) { int i ; static const work_func_t sas_event_fns [ DISC_NUM_EVENTS ] = { [ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , [ DISCE_PROBE ] = sas_probe_devices , [ DISCE_SUSPEND ] = sas_suspend_devices , [ DISCE_RESUME ] = sas_resume_devices , [ DISCE_DESTRUCT ] = sas_destruct_devices , } ; disc -> pending = 0 ; for ( i = 0 ; i < DISC_NUM_EVENTS ; i ++ ) { INIT_SAS_WORK ( & disc -> disc_work [ i ] . work , sas_event_fns [ i ] ) ; disc -> disc_work [ i ] . port = port ; } }
CURLcode Curl_close ( struct Curl_easy * data ) { struct Curl_multi * m ; if ( ! data ) return CURLE_OK ; Curl_expire_clear ( data ) ; m = data -> multi ; if ( m ) curl_multi_remove_handle ( data -> multi , data ) ; if ( data -> multi_easy ) curl_multi_cleanup ( data -> multi_easy ) ; Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; data -> magic = 0 ; if ( data -> state . rangestringalloc ) free ( data -> state . range ) ; Curl_free_request_state ( data ) ; Curl_ssl_close_all ( data ) ; Curl_safefree ( data -> state . first_host ) ; Curl_safefree ( data -> state . scratch ) ; Curl_ssl_free_certinfo ( data ) ; free ( data -> req . newurl ) ; data -> req . newurl = NULL ; if ( data -> change . referer_alloc ) { Curl_safefree ( data -> change . referer ) ; data -> change . referer_alloc = FALSE ; } data -> change . referer = NULL ; Curl_up_free ( data ) ; Curl_safefree ( data -> state . buffer ) ; Curl_safefree ( data -> state . headerbuff ) ; Curl_safefree ( data -> state . ulbuf ) ; Curl_flush_cookies ( data , 1 ) ; Curl_digest_cleanup ( data ) ; Curl_safefree ( data -> info . contenttype ) ; Curl_safefree ( data -> info . wouldredirect ) ; Curl_resolver_cleanup ( data -> state . resolver ) ; Curl_http2_cleanup_dependencies ( data ) ; Curl_convert_close ( data ) ; if ( data -> share ) { Curl_share_lock ( data , CURL_LOCK_DATA_SHARE , CURL_LOCK_ACCESS_SINGLE ) ; data -> share -> dirty -- ; Curl_share_unlock ( data , CURL_LOCK_DATA_SHARE ) ; } Curl_wildcard_dtor ( & data -> wildcard ) ; Curl_freeset ( data ) ; free ( data ) ; return CURLE_OK ; }
static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 * p_data_written , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; OPJ_UNUSED ( p_manager ) ; if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not enough bytes in output buffer to write SOT marker\n" ) ; return OPJ_FALSE ; } opj_write_bytes ( p_data , J2K_MS_SOT , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , 10 , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , 2 ) ; p_data += 2 ; p_data += 4 ; opj_write_bytes ( p_data , p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , 1 ) ; ++ p_data ; opj_write_bytes ( p_data , p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , 1 ) ; ++ p_data ; #ifdef USE_JPWL assert ( 0 && "TODO" ) ; #endif /* USE_JPWL */ * p_data_written = 12 ; return OPJ_TRUE ; }
static void cleanup ( const v8 :: WeakCallbackInfo < ProtocolPromiseHandler > & data ) { if ( ! data . GetParameter ( ) -> m_wrapper . IsEmpty ( ) ) { data . GetParameter ( ) -> m_wrapper . Reset ( ) ; data . SetSecondPassCallback ( cleanup ) ; } else { data . GetParameter ( ) -> sendPromiseCollected ( ) ; delete data . GetParameter ( ) ; } }
TF_BUILTIN ( AsyncFunctionAwaitUncaught , AsyncFunctionBuiltinsAssembler ) { CSA_ASSERT_JS_ARGC_EQ ( this , 3 ) ; Node * const generator = Parameter ( Descriptor :: kGenerator ) ; Node * const awaited = Parameter ( Descriptor :: kAwaited ) ; Node * const outer_promise = Parameter ( Descriptor :: kOuterPromise ) ; Node * const context = Parameter ( Descriptor :: kContext ) ; static const bool kIsPredictedAsCaught = false ; AsyncFunctionAwait ( context , generator , awaited , outer_promise , kIsPredictedAsCaught ) ; }
bool FontData :: Bound ( int32_t offset , int32_t length ) { if ( offset + length > Size ( ) || offset < 0 || length < 0 ) return false ; bound_offset_ += offset ; bound_length_ = length ; return true ; }
fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , "f-string: single '}' is not allowed" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
void AsmJsParser :: Loop ( AsmJsScanner :: token_t label ) { BareBegin ( BlockKind :: kLoop , label ) ; size_t position = scanner_ . Position ( ) ; current_function_builder_ -> AddAsmWasmOffset ( position , position ) ; current_function_builder_ -> EmitWithU8 ( kExprLoop , kLocalVoid ) ; }
make_errors ( png_modifier * PNG_CONST pm , png_byte PNG_CONST colour_type , int bdlo , int PNG_CONST bdhi ) { for ( ; bdlo <= bdhi ; ++ bdlo ) { int interlace_type ; for ( interlace_type = PNG_INTERLACE_NONE ; interlace_type < INTERLACE_LAST ; ++ interlace_type ) { unsigned int test ; char name [ FILE_NAME_SIZE ] ; standard_name ( name , sizeof name , 0 , colour_type , 1 < < bdlo , 0 , interlace_type , 0 , 0 , 0 ) ; for ( test = 0 ; test < ( sizeof error_test ) / ( sizeof error_test [ 0 ] ) ; ++ test ) { make_error ( & pm -> this , colour_type , DEPTH ( bdlo ) , interlace_type , test , name ) ; if ( fail ( pm ) ) return 0 ; } } } return 1 ; }
local block_state deflate_fast ( s , flush ) deflate_state * s ; int flush ; { IPos hash_head ; int bflush ; for ( ; ; ) { if ( s -> lookahead < MIN_LOOKAHEAD ) { fill_window ( s ) ; if ( s -> lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH ) { return need_more ; } if ( s -> lookahead == 0 ) break ; } hash_head = NIL ; if ( s -> lookahead >= MIN_MATCH ) { INSERT_STRING ( s , s -> strstart , hash_head ) ; } if ( hash_head != NIL && s -> strstart - hash_head <= MAX_DIST ( s ) ) { s -> match_length = longest_match ( s , hash_head ) ; } if ( s -> match_length >= MIN_MATCH ) { check_match ( s , s -> strstart , s -> match_start , s -> match_length ) ; _tr_tally_dist ( s , s -> strstart - s -> match_start , s -> match_length - MIN_MATCH , bflush ) ; s -> lookahead -= s -> match_length ; #ifndef FASTEST if ( s -> match_length <= s -> max_insert_length && s -> lookahead >= MIN_MATCH ) { s -> match_length -- ; do { s -> strstart ++ ; INSERT_STRING ( s , s -> strstart , hash_head ) ; } while ( -- s -> match_length != 0 ) ; s -> strstart ++ ; } else #endif { s -> strstart += s -> match_length ; s -> match_length = 0 ; s -> ins_h = s -> window [ s -> strstart ] ; UPDATE_HASH ( s , s -> ins_h , s -> window [ s -> strstart + 1 ] ) ; #if MIN_MATCH != 3 Call UPDATE_HASH ( ) MIN_MATCH - 3 more times #endif } } else { Tracevv ( ( stderr , "%c" , s -> window [ s -> strstart ] ) ) ; _tr_tally_lit ( s , s -> window [ s -> strstart ] , bflush ) ; s -> lookahead -- ; s -> strstart ++ ; } if ( bflush ) FLUSH_BLOCK ( s , 0 ) ; } s -> insert = s -> strstart < MIN_MATCH - 1 ? s -> strstart : MIN_MATCH - 1 ; if ( flush == Z_FINISH ) { FLUSH_BLOCK ( s , 1 ) ; return finish_done ; } if ( s -> last_lit ) FLUSH_BLOCK ( s , 0 ) ; return block_done ; }
uint32_t word32_ror_wrapper ( Address data ) { uint32_t input = ReadUnalignedValue < uint32_t > ( data ) ; uint32_t shift = ReadUnalignedValue < uint32_t > ( data + sizeof ( input ) ) & 31 ; return ( input > > shift ) | ( input < < ( 32 - shift ) ) ; }
void Compute ( OpKernelContext * context ) override { CHECK_EQ ( 3 , context -> num_inputs ( ) ) ; const Tensor & input = context -> input ( 0 ) ; const Tensor & min = context -> input ( 1 ) ; const Tensor & max = context -> input ( 2 ) ; Tensor * output ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , input . shape ( ) , & output ) ) ; FakeQuantWithMinMaxVarsFunctor < Device > functor ; functor ( context -> eigen_device < Device > ( ) , input . flat < float > ( ) , min . scalar < float > ( ) , max . scalar < float > ( ) , quant_min_ , quant_max_ , output -> flat < float > ( ) ) ; }
static int StreamTcpValidateRst ( TcpSession * ssn , Packet * p ) { uint8_t os_policy ; if ( ssn -> flags & STREAMTCP_FLAG_TIMESTAMP ) { if ( ! StreamTcpValidateTimestamp ( ssn , p ) ) { SCReturnInt ( 0 ) ; } } if ( PKT_IS_TOSERVER ( p ) ) { if ( ssn -> server . os_policy == 0 ) StreamTcpSetOSPolicy ( & ssn -> server , p ) ; os_policy = ssn -> server . os_policy ; if ( p -> tcph -> th_flags & TH_ACK && TCP_GET_ACK ( p ) && StreamTcpValidateAck ( ssn , & ssn -> server , p ) == - 1 ) { SCLogDebug ( "ssn %p: rejecting because of invalid ack value" , ssn ) ; StreamTcpSetEvent ( p , STREAM_RST_INVALID_ACK ) ; SCReturnInt ( 0 ) ; } } else { if ( ssn -> client . os_policy == 0 ) StreamTcpSetOSPolicy ( & ssn -> client , p ) ; os_policy = ssn -> client . os_policy ; if ( p -> tcph -> th_flags & TH_ACK && TCP_GET_ACK ( p ) && StreamTcpValidateAck ( ssn , & ssn -> client , p ) == - 1 ) { SCLogDebug ( "ssn %p: rejecting because of invalid ack value" , ssn ) ; StreamTcpSetEvent ( p , STREAM_RST_INVALID_ACK ) ; SCReturnInt ( 0 ) ; } } if ( ssn -> flags & STREAMTCP_FLAG_ASYNC ) { if ( PKT_IS_TOSERVER ( p ) ) { if ( SEQ_GEQ ( TCP_GET_SEQ ( p ) , ssn -> client . next_seq ) ) { SCLogDebug ( "ssn %p: ASYNC accept RST" , ssn ) ; return 1 ; } } else { if ( SEQ_GEQ ( TCP_GET_SEQ ( p ) , ssn -> server . next_seq ) ) { SCLogDebug ( "ssn %p: ASYNC accept RST" , ssn ) ; return 1 ; } } SCLogDebug ( "ssn %p: ASYNC reject RST" , ssn ) ; return 0 ; } switch ( os_policy ) { case OS_POLICY_HPUX11 : if ( PKT_IS_TOSERVER ( p ) ) { if ( SEQ_GEQ ( TCP_GET_SEQ ( p ) , ssn -> client . next_seq ) ) { SCLogDebug ( "reset is Valid! Packet SEQ: %" PRIu32 "" , TCP_GET_SEQ ( p ) ) ; return 1 ; } else { SCLogDebug ( "reset is not Valid! Packet SEQ: %" PRIu32 " " "and server SEQ: %" PRIu32 "" , TCP_GET_SEQ ( p ) , ssn -> client . next_seq ) ; return 0 ; } } else { if ( SEQ_GEQ ( TCP_GET_SEQ ( p ) , ssn -> server . next_seq ) ) { SCLogDebug ( "reset is valid! Packet SEQ: %" PRIu32 "" , TCP_GET_SEQ ( p ) ) ; return 1 ; } else { SCLogDebug ( "reset is not valid! Packet SEQ: %" PRIu32 " " "and client SEQ: %" PRIu32 "" , TCP_GET_SEQ ( p ) , ssn -> server . next_seq ) ; return 0 ; } } break ; case OS_POLICY_OLD_LINUX : case OS_POLICY_LINUX : case OS_POLICY_SOLARIS : if ( PKT_IS_TOSERVER ( p ) ) { if ( SEQ_GEQ ( ( TCP_GET_SEQ ( p ) + p -> payload_len ) , ssn -> client . last_ack ) ) { if ( SEQ_LT ( TCP_GET_SEQ ( p ) , ( ssn -> client . next_seq + ssn -> client . window ) ) ) { SCLogDebug ( "reset is Valid! Packet SEQ: %" PRIu32 "" , TCP_GET_SEQ ( p ) ) ; return 1 ; } } else { SCLogDebug ( "reset is not valid! Packet SEQ: %" PRIu32 " and" " server SEQ: %" PRIu32 "" , TCP_GET_SEQ ( p ) , ssn -> client . next_seq ) ; return 0 ; } } else { if ( SEQ_GEQ ( ( TCP_GET_SEQ ( p ) + p -> payload_len ) , ssn -> server . last_ack ) ) { if ( SEQ_LT ( TCP_GET_SEQ ( p ) , ( ssn -> server . next_seq + ssn -> server . window ) ) ) { SCLogDebug ( "reset is Valid! Packet SEQ: %" PRIu32 "" , TCP_GET_SEQ ( p ) ) ; return 1 ; } } else { SCLogDebug ( "reset is not valid! Packet SEQ: %" PRIu32 " and" " client SEQ: %" PRIu32 "" , TCP_GET_SEQ ( p ) , ssn -> server . next_seq ) ; return 0 ; } } break ; default : case OS_POLICY_BSD : case OS_POLICY_FIRST : case OS_POLICY_HPUX10 : case OS_POLICY_IRIX : case OS_POLICY_MACOS : case OS_POLICY_LAST : case OS_POLICY_WINDOWS : case OS_POLICY_WINDOWS2K3 : case OS_POLICY_VISTA : if ( PKT_IS_TOSERVER ( p ) ) { if ( SEQ_EQ ( TCP_GET_SEQ ( p ) , ssn -> client . next_seq ) ) { SCLogDebug ( "reset is valid! Packet SEQ: %" PRIu32 "" , TCP_GET_SEQ ( p ) ) ; return 1 ; } else { SCLogDebug ( "reset is not valid! Packet SEQ: %" PRIu32 " " "and server SEQ: %" PRIu32 "" , TCP_GET_SEQ ( p ) , ssn -> client . next_seq ) ; return 0 ; } } else { if ( SEQ_EQ ( TCP_GET_SEQ ( p ) , ssn -> server . next_seq ) ) { SCLogDebug ( "reset is valid! Packet SEQ: %" PRIu32 " Stream %u" , TCP_GET_SEQ ( p ) , ssn -> server . next_seq ) ; return 1 ; } else { SCLogDebug ( "reset is not valid! Packet SEQ: %" PRIu32 " and" " client SEQ: %" PRIu32 "" , TCP_GET_SEQ ( p ) , ssn -> server . next_seq ) ; return 0 ; } } break ; } return 0 ; }
void recovery_character ( const char * character ) { if ( ! awaiting_character ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , "Not in Recovery mode" ) ; layoutHome ( ) ; return ; } if ( strlen ( mnemonic ) + 1 > MNEMONIC_BUF - 1 ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , "Too many characters attempted during recovery" ) ; layoutHome ( ) ; return ; } char * pos = strchr ( cipher , character [ 0 ] ) ; if ( character [ 0 ] != ' ' && pos == NULL ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_SyntaxError , "Character must be from a to z" ) ; layoutHome ( ) ; return ; } static int uncyphered_word_count = 0 ; static bool definitely_using_cipher = false ; static CONFIDENTIAL char coded_word [ 12 ] ; static CONFIDENTIAL char decoded_word [ 12 ] ; if ( ! mnemonic [ 0 ] ) { uncyphered_word_count = 0 ; definitely_using_cipher = false ; memzero ( coded_word , sizeof ( coded_word ) ) ; memzero ( decoded_word , sizeof ( decoded_word ) ) ; } char decoded_character [ 2 ] = " " ; if ( character [ 0 ] != ' ' ) { decoded_character [ 0 ] = english_alphabet [ ( int ) ( pos - cipher ) ] ; strlcat ( coded_word , character , sizeof ( coded_word ) ) ; strlcat ( decoded_word , decoded_character , sizeof ( decoded_word ) ) ; if ( enforce_wordlist && 4 <= strlen ( coded_word ) ) { bool maybe_not_using_cipher = attempt_auto_complete ( coded_word ) ; bool maybe_using_cipher = attempt_auto_complete ( decoded_word ) ; if ( ! maybe_not_using_cipher && maybe_using_cipher ) { definitely_using_cipher = true ; } else if ( maybe_not_using_cipher && ! definitely_using_cipher && MAX_UNCYPHERED_WORDS < uncyphered_word_count ++ ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_SyntaxError , "Words were not entered correctly. Make sure you are using the substition cipher." ) ; layoutHome ( ) ; return ; } } } else { memzero ( coded_word , sizeof ( coded_word ) ) ; memzero ( decoded_word , sizeof ( decoded_word ) ) ; } strlcat ( mnemonic , decoded_character , MNEMONIC_BUF ) ; next_character ( ) ; }
void FillRandom ( uint8_t * data , int stride ) { for ( int h = 0 ; h < height_ ; ++ h ) { for ( int w = 0 ; w < width_ ; ++ w ) { data [ h * stride + w ] = rnd_ . Rand8 ( ) ; } } }
IGNITION_HANDLER ( LdaZero , InterpreterAssembler ) { Node * zero_value = NumberConstant ( 0.0 ) ; SetAccumulator ( zero_value ) ; Dispatch ( ) ; }
JS_EvaluateUCScriptForPrincipals ( JSContext * cx , JSObject * obj , JSPrincipals * principals , const jschar * chars , uintN length , const char * filename , uintN lineno , jsval * rval ) { return EvaluateUCScriptForPrincipalsCommon ( cx , obj , principals , chars , length , filename , lineno , rval , cx -> findVersion ( ) ) ; }
inline bool EnsureJSArrayWithWritableFastElements ( Isolate * isolate , Handle < Object > receiver , BuiltinArguments * args , int first_arg_index , int num_arguments ) { if ( ! receiver -> IsJSArray ( ) ) return false ; Handle < JSArray > array = Handle < JSArray > :: cast ( receiver ) ; ElementsKind origin_kind = array -> GetElementsKind ( ) ; if ( IsDictionaryElementsKind ( origin_kind ) ) return false ; if ( ! array -> map ( ) -> is_extensible ( ) ) return false ; if ( args == nullptr ) return true ; if ( ! IsJSArrayFastElementMovingAllowed ( isolate , * array ) ) return false ; if ( isolate -> IsAnyInitialArrayPrototype ( array ) ) return false ; int args_length = args -> length ( ) ; if ( first_arg_index >= args_length ) return true ; if ( IsObjectElementsKind ( origin_kind ) ) return true ; ElementsKind target_kind = origin_kind ; { DisallowHeapAllocation no_gc ; int last_arg_index = std :: min ( first_arg_index + num_arguments , args_length ) ; for ( int i = first_arg_index ; i < last_arg_index ; i ++ ) { Object * arg = ( * args ) [ i ] ; if ( arg -> IsHeapObject ( ) ) { if ( arg -> IsHeapNumber ( ) ) { target_kind = PACKED_DOUBLE_ELEMENTS ; } else { target_kind = PACKED_ELEMENTS ; break ; } } } } if ( target_kind != origin_kind ) { HandleScope scope ( isolate ) ; JSObject :: TransitionElementsKind ( array , target_kind ) ; } return true ; }
JSStructuredCloneWriter :: startWrite ( HandleValue v ) { assertSameCompartment ( context ( ) , v ) ; if ( v . isString ( ) ) { return writeString ( SCTAG_STRING , v . toString ( ) ) ; } else if ( v . isInt32 ( ) ) { return out . writePair ( SCTAG_INT32 , v . toInt32 ( ) ) ; } else if ( v . isDouble ( ) ) { return out . writeDouble ( v . toDouble ( ) ) ; } else if ( v . isBoolean ( ) ) { return out . writePair ( SCTAG_BOOLEAN , v . toBoolean ( ) ) ; } else if ( v . isNull ( ) ) { return out . writePair ( SCTAG_NULL , 0 ) ; } else if ( v . isUndefined ( ) ) { return out . writePair ( SCTAG_UNDEFINED , 0 ) ; } else if ( v . isObject ( ) ) { RootedObject obj ( context ( ) , & v . toObject ( ) ) ; obj = CheckedUnwrap ( obj ) ; if ( ! obj ) { JS_ReportErrorNumber ( context ( ) , js_GetErrorMessage , nullptr , JSMSG_UNWRAP_DENIED ) ; return false ; } AutoCompartment ac ( context ( ) , obj ) ; bool backref ; if ( ! startObject ( obj , & backref ) ) return false ; if ( backref ) return true ; if ( ObjectClassIs ( obj , ESClass_RegExp , context ( ) ) ) { RegExpGuard re ( context ( ) ) ; if ( ! RegExpToShared ( context ( ) , obj , & re ) ) return false ; return out . writePair ( SCTAG_REGEXP_OBJECT , re -> getFlags ( ) ) && writeString ( SCTAG_STRING , re -> getSource ( ) ) ; } else if ( obj -> is < DateObject > ( ) ) { double d = js_DateGetMsecSinceEpoch ( obj ) ; return out . writePair ( SCTAG_DATE_OBJECT , 0 ) && out . writeDouble ( d ) ; } else if ( obj -> is < TypedArrayObject > ( ) ) { return writeTypedArray ( obj ) ; } else if ( obj -> is < ArrayBufferObject > ( ) && obj -> as < ArrayBufferObject > ( ) . hasData ( ) ) { return writeArrayBuffer ( obj ) ; } else if ( obj -> is < JSObject > ( ) || obj -> is < ArrayObject > ( ) ) { return traverseObject ( obj ) ; } else if ( obj -> is < BooleanObject > ( ) ) { return out . writePair ( SCTAG_BOOLEAN_OBJECT , obj -> as < BooleanObject > ( ) . unbox ( ) ) ; } else if ( obj -> is < NumberObject > ( ) ) { return out . writePair ( SCTAG_NUMBER_OBJECT , 0 ) && out . writeDouble ( obj -> as < NumberObject > ( ) . unbox ( ) ) ; } else if ( obj -> is < StringObject > ( ) ) { return writeString ( SCTAG_STRING_OBJECT , obj -> as < StringObject > ( ) . unbox ( ) ) ; } else if ( obj -> is < MapObject > ( ) ) { return traverseMap ( obj ) ; } else if ( obj -> is < SetObject > ( ) ) { return traverseSet ( obj ) ; } if ( callbacks && callbacks -> write ) return callbacks -> write ( context ( ) , this , obj , closure ) ; } JS_ReportErrorNumber ( context ( ) , js_GetErrorMessage , nullptr , JSMSG_SC_UNSUPPORTED_TYPE ) ; return false ; }
int mndp_add_attribute ( struct mt_packet * packet , enum mt_mndp_attrtype attrtype , void * attrdata , unsigned short data_len ) { unsigned char * data = packet -> data + packet -> size ; unsigned short type = attrtype ; unsigned short len = data_len ; if ( packet -> size + 4 + data_len > MT_PACKET_LEN ) { fprintf ( stderr , _ ( "mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\n" ) , MT_PACKET_LEN ) ; return - 1 ; } type = htons ( type ) ; memcpy ( data , & type , sizeof ( type ) ) ; len = htons ( len ) ; memcpy ( data + 2 , & len , sizeof ( len ) ) ; memcpy ( data + 4 , attrdata , data_len ) ; packet -> size += 4 + data_len ; return 4 + data_len ; }
TF_BUILTIN ( ArrayIncludesHoleyDoubles , ArrayIncludesIndexofAssembler ) { Node * elements = Parameter ( Descriptor :: kElements ) ; Node * search_element = Parameter ( Descriptor :: kSearchElement ) ; Node * array_length = Parameter ( Descriptor :: kLength ) ; Node * from_index = Parameter ( Descriptor :: kFromIndex ) ; GenerateHoleyDoubles ( kIncludes , elements , search_element , array_length , from_index ) ; }
static void create_layer_surface ( struct swaylock_surface * surface ) { struct swaylock_state * state = surface -> state ; surface -> image = select_image ( state , surface ) ; surface -> surface = wl_compositor_create_surface ( state -> compositor ) ; assert ( surface -> surface ) ; surface -> child = wl_compositor_create_surface ( state -> compositor ) ; assert ( surface -> child ) ; surface -> subsurface = wl_subcompositor_get_subsurface ( state -> subcompositor , surface -> child , surface -> surface ) ; assert ( surface -> subsurface ) ; wl_subsurface_set_sync ( surface -> subsurface ) ; surface -> layer_surface = zwlr_layer_shell_v1_get_layer_surface ( state -> layer_shell , surface -> surface , surface -> output , ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY , "lockscreen" ) ; assert ( surface -> layer_surface ) ; zwlr_layer_surface_v1_set_size ( surface -> layer_surface , 0 , 0 ) ; zwlr_layer_surface_v1_set_anchor ( surface -> layer_surface , ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP | ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT | ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM | ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT ) ; zwlr_layer_surface_v1_set_exclusive_zone ( surface -> layer_surface , - 1 ) ; zwlr_layer_surface_v1_set_keyboard_interactivity ( surface -> layer_surface , true ) ; zwlr_layer_surface_v1_add_listener ( surface -> layer_surface , & layer_surface_listener , surface ) ; if ( surface_is_opaque ( surface ) && surface -> state -> args . mode != BACKGROUND_MODE_CENTER && surface -> state -> args . mode != BACKGROUND_MODE_FIT ) { struct wl_region * region = wl_compositor_create_region ( surface -> state -> compositor ) ; wl_region_add ( region , 0 , 0 , INT32_MAX , INT32_MAX ) ; wl_surface_set_opaque_region ( surface -> surface , region ) ; wl_region_destroy ( region ) ; } wl_surface_commit ( surface -> surface ) ; }
Expression * Parser :: NewThrowError ( Runtime :: FunctionId id , MessageTemplate :: Template message , const AstRawString * arg , int pos ) { ZonePtrList < Expression > * args = new ( zone ( ) ) ZonePtrList < Expression > ( 2 , zone ( ) ) ; args -> Add ( factory ( ) -> NewSmiLiteral ( message , pos ) , zone ( ) ) ; args -> Add ( factory ( ) -> NewStringLiteral ( arg , pos ) , zone ( ) ) ; CallRuntime * call_constructor = factory ( ) -> NewCallRuntime ( id , args , pos ) ; return factory ( ) -> NewThrow ( call_constructor , pos ) ; }
htc_request_check_host_hdr ( struct http * hp ) { int u ; int seen_host = 0 ; for ( u = HTTP_HDR_FIRST ; u < hp -> nhd ; u ++ ) { if ( hp -> hd [ u ] . b == NULL ) continue ; AN ( hp -> hd [ u ] . b ) ; AN ( hp -> hd [ u ] . e ) ; if ( http_IsHdr ( & hp -> hd [ u ] , H_Host ) ) { if ( seen_host ) { return ( 400 ) ; } seen_host = 1 ; } } return ( 0 ) ; }
void NetworkUtils :: addRouteToSecondaryTable ( CommandChain * aChain , CommandCallback aCallback , NetworkResultOptions & aResult ) { char command [ MAX_COMMAND_SIZE ] ; if ( SDK_VERSION >= 20 ) { snprintf ( command , MAX_COMMAND_SIZE - 1 , "network route add %d %s %s/%s %s" , GET_FIELD ( mNetId ) , GET_CHAR ( mIfname ) , GET_CHAR ( mIp ) , GET_CHAR ( mPrefix ) , GET_CHAR ( mGateway ) ) ; } else { snprintf ( command , MAX_COMMAND_SIZE - 1 , "interface route add %s secondary %s %s %s" , GET_CHAR ( mIfname ) , GET_CHAR ( mIp ) , GET_CHAR ( mPrefix ) , GET_CHAR ( mGateway ) ) ; } doCommand ( command , aChain , aCallback ) ; }
virtual ~ Impl ( ) { if ( ! mMappings . empty ( ) ) { ALOGD ( "Dangling mappings!" ) ; for ( const Mapping & map : mMappings ) { ( void ) munmap ( map . addr , map . size ) ; } } if ( mMapFd >= 0 ) { close ( mMapFd ) ; mMapFd = - 1 ; } if ( mInit == C2_OK ) { if ( mBuffer >= 0 ) { ( void ) ion_free ( mIonFd , mBuffer ) ; } native_handle_close ( & mHandle ) ; } if ( mIonFd >= 0 ) { close ( mIonFd ) ; } }
static int io_timeout_prep ( struct io_kiocb * req , const struct io_uring_sqe * sqe , bool is_timeout_link ) { struct io_timeout_data * data ; unsigned flags ; u32 off = READ_ONCE ( sqe -> off ) ; if ( unlikely ( req -> ctx -> flags & IORING_SETUP_IOPOLL ) ) return - EINVAL ; if ( sqe -> ioprio || sqe -> buf_index || sqe -> len != 1 || sqe -> splice_fd_in ) return - EINVAL ; if ( off && is_timeout_link ) return - EINVAL ; flags = READ_ONCE ( sqe -> timeout_flags ) ; if ( flags & ~ ( IORING_TIMEOUT_ABS | IORING_TIMEOUT_CLOCK_MASK | IORING_TIMEOUT_ETIME_SUCCESS ) ) return - EINVAL ; if ( hweight32 ( flags & IORING_TIMEOUT_CLOCK_MASK ) > 1 ) return - EINVAL ; INIT_LIST_HEAD ( & req -> timeout . list ) ; req -> timeout . off = off ; if ( unlikely ( off && ! req -> ctx -> off_timeout_used ) ) req -> ctx -> off_timeout_used = true ; if ( WARN_ON_ONCE ( req_has_async_data ( req ) ) ) return - EFAULT ; if ( io_alloc_async_data ( req ) ) return - ENOMEM ; data = req -> async_data ; data -> req = req ; data -> flags = flags ; if ( get_timespec64 ( & data -> ts , u64_to_user_ptr ( sqe -> addr ) ) ) return - EFAULT ; if ( data -> ts . tv_sec < 0 || data -> ts . tv_nsec < 0 ) return - EINVAL ; data -> mode = io_translate_timeout_mode ( flags ) ; hrtimer_init ( & data -> timer , io_timeout_get_clock ( data ) , data -> mode ) ; if ( is_timeout_link ) { struct io_submit_link * link = & req -> ctx -> submit_state . link ; if ( ! link -> head ) return - EINVAL ; if ( link -> last -> opcode == IORING_OP_LINK_TIMEOUT ) return - EINVAL ; req -> timeout . head = link -> last ; link -> last -> flags |= REQ_F_ARM_LTIMEOUT ; } return 0 ; }
void RawMachineAssembler :: Return ( int count , Node * vs [ ] ) { typedef Node * Node_ptr ; Node * * values = new Node_ptr [ count + 1 ] ; values [ 0 ] = Int32Constant ( 0 ) ; for ( int i = 0 ; i < count ; ++ i ) values [ i + 1 ] = vs [ i ] ; Node * ret = MakeNode ( common ( ) -> Return ( count ) , count + 1 , values ) ; schedule ( ) -> AddReturn ( CurrentBlock ( ) , ret ) ; current_block_ = nullptr ; delete [ ] values ; }
feed_table_block_tag ( struct table * tbl , char * line , struct table_mode * mode , int indent , int cmd ) { int offset ; if ( mode -> indent_level <= 0 && indent == - 1 ) return ; if ( mode -> indent_level >= CHAR_MAX && indent == 1 ) return ; setwidth ( tbl , mode ) ; feed_table_inline_tag ( tbl , line , mode , - 1 ) ; clearcontentssize ( tbl , mode ) ; if ( indent == 1 ) { mode -> indent_level ++ ; if ( mode -> indent_level <= MAX_INDENT_LEVEL ) tbl -> indent += INDENT_INCR ; } else if ( indent == - 1 ) { mode -> indent_level -- ; if ( mode -> indent_level < MAX_INDENT_LEVEL ) tbl -> indent -= INDENT_INCR ; } offset = tbl -> indent ; if ( cmd == HTML_DT ) { if ( mode -> indent_level > 0 && mode -> indent_level <= MAX_INDENT_LEVEL ) offset -= INDENT_INCR ; } if ( tbl -> indent > 0 ) { check_minimum0 ( tbl , 0 ) ; addcontentssize ( tbl , offset ) ; } }
static int do_new_mount ( struct path * path , const char * fstype , int flags , int mnt_flags , const char * name , void * data ) { struct file_system_type * type ; struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct vfsmount * mnt ; int err ; if ( ! fstype ) return - EINVAL ; type = get_fs_type ( fstype ) ; if ( ! type ) return - ENODEV ; if ( user_ns != & init_user_ns ) { if ( ! ( type -> fs_flags & FS_USERNS_MOUNT ) ) { put_filesystem ( type ) ; return - EPERM ; } if ( ! ( type -> fs_flags & FS_USERNS_DEV_MOUNT ) ) { flags |= MS_NODEV ; mnt_flags |= MNT_NODEV ; } } mnt = vfs_kern_mount ( type , flags , name , data ) ; if ( ! IS_ERR ( mnt ) && ( type -> fs_flags & FS_HAS_SUBTYPE ) && ! mnt -> mnt_sb -> s_subtype ) mnt = fs_set_subtype ( mnt , fstype ) ; put_filesystem ( type ) ; if ( IS_ERR ( mnt ) ) return PTR_ERR ( mnt ) ; err = do_add_mount ( real_mount ( mnt ) , path , mnt_flags ) ; if ( err ) mntput ( mnt ) ; return err ; }
OMX_ERRORTYPE SoftRaw :: internalSetParameter ( OMX_INDEXTYPE index , const OMX_PTR params ) { switch ( index ) { case OMX_IndexParamStandardComponentRole : { const OMX_PARAM_COMPONENTROLETYPE * roleParams = ( const OMX_PARAM_COMPONENTROLETYPE * ) params ; if ( strncmp ( ( const char * ) roleParams -> cRole , "audio_decoder.raw" , OMX_MAX_STRINGNAME_SIZE - 1 ) ) { return OMX_ErrorUndefined ; } return OMX_ErrorNone ; } case OMX_IndexParamAudioPcm : { const OMX_AUDIO_PARAM_PCMMODETYPE * pcmParams = ( OMX_AUDIO_PARAM_PCMMODETYPE * ) params ; if ( pcmParams -> nPortIndex != 0 ) { return OMX_ErrorUndefined ; } mChannelCount = pcmParams -> nChannels ; mSampleRate = pcmParams -> nSamplingRate ; return OMX_ErrorNone ; } default : return SimpleSoftOMXComponent :: internalSetParameter ( index , params ) ; } }
bool llcp_util_parse_link_params ( uint16_t length , uint8_t * p_bytes ) { uint8_t param_type , param_len , * p = p_bytes ; while ( length ) { BE_STREAM_TO_UINT8 ( param_type , p ) ; length -- ; switch ( param_type ) { case LLCP_VERSION_TYPE : BE_STREAM_TO_UINT8 ( param_len , p ) ; BE_STREAM_TO_UINT8 ( llcp_cb . lcb . peer_version , p ) ; DLOG_IF ( INFO , nfc_debug_enabled ) < < StringPrintf ( "Peer Version - 0x%02X" , llcp_cb . lcb . peer_version ) ; break ; case LLCP_MIUX_TYPE : BE_STREAM_TO_UINT8 ( param_len , p ) ; BE_STREAM_TO_UINT16 ( llcp_cb . lcb . peer_miu , p ) ; llcp_cb . lcb . peer_miu &= LLCP_MIUX_MASK ; llcp_cb . lcb . peer_miu += LLCP_DEFAULT_MIU ; DLOG_IF ( INFO , nfc_debug_enabled ) < < StringPrintf ( "Peer MIU - %d bytes" , llcp_cb . lcb . peer_miu ) ; break ; case LLCP_WKS_TYPE : BE_STREAM_TO_UINT8 ( param_len , p ) ; BE_STREAM_TO_UINT16 ( llcp_cb . lcb . peer_wks , p ) ; DLOG_IF ( INFO , nfc_debug_enabled ) < < StringPrintf ( "Peer WKS - 0x%04X" , llcp_cb . lcb . peer_wks ) ; break ; case LLCP_LTO_TYPE : BE_STREAM_TO_UINT8 ( param_len , p ) ; BE_STREAM_TO_UINT8 ( llcp_cb . lcb . peer_lto , p ) ; llcp_cb . lcb . peer_lto *= LLCP_LTO_UNIT ; DLOG_IF ( INFO , nfc_debug_enabled ) < < StringPrintf ( "Peer LTO - %d ms" , llcp_cb . lcb . peer_lto ) ; break ; case LLCP_OPT_TYPE : BE_STREAM_TO_UINT8 ( param_len , p ) ; BE_STREAM_TO_UINT8 ( llcp_cb . lcb . peer_opt , p ) ; DLOG_IF ( INFO , nfc_debug_enabled ) < < StringPrintf ( "Peer OPT - 0x%02X" , llcp_cb . lcb . peer_opt ) ; break ; default : LOG ( ERROR ) < < StringPrintf ( "Unexpected type 0x%x" , param_type ) ; BE_STREAM_TO_UINT8 ( param_len , p ) ; p += param_len ; break ; } if ( length >= param_len + 1 ) length -= param_len + 1 ; else { LOG ( ERROR ) < < StringPrintf ( "Bad LTV's" ) ; return false ; } } return true ; }
void InterpreterAssembler :: MaybeDropFrames ( Node * context ) { Node * restart_fp_address = ExternalConstant ( ExternalReference :: debug_restart_fp_address ( isolate ( ) ) ) ; Node * restart_fp = Load ( MachineType :: Pointer ( ) , restart_fp_address ) ; Node * null = IntPtrConstant ( 0 ) ; Label ok ( this ) , drop_frames ( this ) ; Branch ( IntPtrEqual ( restart_fp , null ) , & ok , & drop_frames ) ; BIND ( & drop_frames ) ; CallStub ( CodeFactory :: FrameDropperTrampoline ( isolate ( ) ) , context , restart_fp ) ; Abort ( AbortReason :: kUnexpectedReturnFromFrameDropper ) ; Goto ( & ok ) ; BIND ( & ok ) ; }
RUNTIME_FUNCTION ( Runtime_IsArray ) { SealHandleScope shs ( isolate ) ; DCHECK_EQ ( 1 , args . length ( ) ) ; CONVERT_ARG_CHECKED ( Object , obj , 0 ) ; return isolate -> heap ( ) -> ToBoolean ( obj -> IsJSArray ( ) ) ; }
Reduction MachineOperatorReducer :: ReduceWord32Sar ( Node * node ) { Int32BinopMatcher m ( node ) ; if ( m . right ( ) . Is ( 0 ) ) return Replace ( m . left ( ) . node ( ) ) ; if ( m . IsFoldable ( ) ) { return ReplaceInt32 ( m . left ( ) . Value ( ) > > m . right ( ) . Value ( ) ) ; } if ( m . left ( ) . IsWord32Shl ( ) ) { Int32BinopMatcher mleft ( m . left ( ) . node ( ) ) ; if ( mleft . left ( ) . IsComparison ( ) ) { if ( m . right ( ) . Is ( 31 ) && mleft . right ( ) . Is ( 31 ) ) { node -> ReplaceInput ( 0 , Int32Constant ( 0 ) ) ; node -> ReplaceInput ( 1 , mleft . left ( ) . node ( ) ) ; NodeProperties :: ChangeOp ( node , machine ( ) -> Int32Sub ( ) ) ; Reduction const reduction = ReduceInt32Sub ( node ) ; return reduction . Changed ( ) ? reduction : Changed ( node ) ; } } else if ( mleft . left ( ) . IsLoad ( ) ) { LoadRepresentation const rep = LoadRepresentationOf ( mleft . left ( ) . node ( ) -> op ( ) ) ; if ( m . right ( ) . Is ( 24 ) && mleft . right ( ) . Is ( 24 ) && rep == MachineType :: Int8 ( ) ) { return Replace ( mleft . left ( ) . node ( ) ) ; } if ( m . right ( ) . Is ( 16 ) && mleft . right ( ) . Is ( 16 ) && rep == MachineType :: Int16 ( ) ) { return Replace ( mleft . left ( ) . node ( ) ) ; } } } return ReduceWord32Shifts ( node ) ; }
const char * jsi_GetHomeDir ( Jsi_Interp * interp ) { const char * str = NULL ; if ( interp -> homeDir ) return interp -> homeDir ; #ifdef __WIN32 str = getenv ( "USERPROFILE" ) ; #else if ( ( str = getenv ( "HOME" ) ) == NULL ) { struct passwd pwd , * pw ; char buf [ 20000 ] ; if ( getpwuid_r ( getuid ( ) , & pwd , buf , sizeof ( buf ) , & pw ) == 0 && pw -> pw_dir ) str = pw -> pw_dir ; } #endif if ( ! str ) { Jsi_LogBug ( "no home dir" ) ; str = "/" ; } #ifdef JSI_LITE_ONLY return str ; #else return ( interp -> homeDir = Jsi_KeyAdd ( interp , str ) ) ; #endif }
void RunUnquickenMultiDex ( ) { std :: string dex_location = GetScratchDir ( ) + "/UnquickenMultiDex.jar" ; std :: string odex_location = GetOdexDir ( ) + "/UnquickenMultiDex.odex" ; std :: string vdex_location = GetOdexDir ( ) + "/UnquickenMultiDex.vdex" ; Copy ( GetTestDexFileName ( "MultiDex" ) , dex_location ) ; std :: unique_ptr < File > vdex_file1 ( OS :: CreateEmptyFile ( vdex_location . c_str ( ) ) ) ; CHECK ( vdex_file1 != nullptr ) < < vdex_location ; { std :: string input_vdex = "--input-vdex-fd=-1" ; std :: string output_vdex = StringPrintf ( "--output-vdex-fd=%d" , vdex_file1 -> Fd ( ) ) ; ASSERT_TRUE ( GenerateOdexForTest ( dex_location , odex_location , CompilerFilter :: kQuicken , { input_vdex , output_vdex } , true , true ) ) ; EXPECT_GT ( vdex_file1 -> GetLength ( ) , 0u ) ; } std :: vector < uint32_t > checksums1 ; GetDexFileChecksums ( dex_location , odex_location , & checksums1 ) ; { std :: string input_vdex = StringPrintf ( "--input-vdex-fd=%d" , vdex_file1 -> Fd ( ) ) ; std :: string output_vdex = StringPrintf ( "--output-vdex-fd=%d" , vdex_file1 -> Fd ( ) ) ; ASSERT_TRUE ( GenerateOdexForTest ( dex_location , odex_location , CompilerFilter :: kVerify , { input_vdex , output_vdex , kDisableCompactDex } , true , true ) ) ; } ASSERT_EQ ( vdex_file1 -> FlushCloseOrErase ( ) , 0 ) < < "Could not flush and close vdex file" ; CheckResult ( dex_location , odex_location ) ; std :: vector < uint32_t > checksums2 ; GetDexFileChecksums ( dex_location , odex_location , & checksums2 ) ; ASSERT_EQ ( checksums1 . size ( ) , checksums2 . size ( ) ) ; for ( size_t i = 0 ; i != checksums1 . size ( ) ; ++ i ) { EXPECT_EQ ( checksums1 [ i ] , checksums2 [ i ] ) < < i ; } ASSERT_TRUE ( success_ ) ; }
void VisitPhi ( Node * node , Truncation truncation , SimplifiedLowering * lowering ) { MachineRepresentation output = GetOutputInfoForPhi ( node , TypeOf ( node ) , truncation ) ; SetOutput ( node , output ) ; int values = node -> op ( ) -> ValueInputCount ( ) ; if ( lower ( ) ) { if ( output != PhiRepresentationOf ( node -> op ( ) ) ) { NodeProperties :: ChangeOp ( node , lowering -> common ( ) -> Phi ( output , values ) ) ; } } UseInfo input_use ( output , truncation ) ; for ( int i = 0 ; i < node -> InputCount ( ) ; i ++ ) { ProcessInput ( node , i , i < values ? input_use : UseInfo :: None ( ) ) ; } }
void Scope :: AllocateNonParameterLocal ( Variable * var ) { DCHECK ( var -> scope ( ) == this ) ; if ( var -> IsUnallocated ( ) && MustAllocate ( var ) ) { if ( MustAllocateInContext ( var ) ) { AllocateHeapSlot ( var ) ; DCHECK_IMPLIES ( is_catch_scope ( ) , var -> index ( ) == Context :: THROWN_OBJECT_INDEX ) ; } else { AllocateStackSlot ( var ) ; } } }
asmlinkage long sys_oabi_fcntl64 ( unsigned int fd , unsigned int cmd , unsigned long arg ) { struct oabi_flock64 user ; struct flock64 kernel ; mm_segment_t fs = USER_DS ; unsigned long local_arg = arg ; int ret ; switch ( cmd ) { case F_OFD_GETLK : case F_OFD_SETLK : case F_OFD_SETLKW : case F_GETLK64 : case F_SETLK64 : case F_SETLKW64 : if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , sizeof ( user ) ) ) return - EFAULT ; kernel . l_type = user . l_type ; kernel . l_whence = user . l_whence ; kernel . l_start = user . l_start ; kernel . l_len = user . l_len ; kernel . l_pid = user . l_pid ; local_arg = ( unsigned long ) & kernel ; fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; } ret = sys_fcntl64 ( fd , cmd , local_arg ) ; switch ( cmd ) { case F_GETLK64 : if ( ! ret ) { user . l_type = kernel . l_type ; user . l_whence = kernel . l_whence ; user . l_start = kernel . l_start ; user . l_len = kernel . l_len ; user . l_pid = kernel . l_pid ; if ( copy_to_user ( ( struct oabi_flock64 __user * ) arg , & user , sizeof ( user ) ) ) ret = - EFAULT ; } case F_SETLK64 : case F_SETLKW64 : set_fs ( fs ) ; } return ret ; }
GF_Err gf_isom_oinf_read_entry ( void * entry , GF_BitStream * bs ) { GF_OperatingPointsInformation * ptr = ( GF_OperatingPointsInformation * ) entry ; u32 i , j , count ; if ( ! ptr ) return GF_BAD_PARAM ; ptr -> scalability_mask = gf_bs_read_u16 ( bs ) ; gf_bs_read_int ( bs , 2 ) ; count = gf_bs_read_int ( bs , 6 ) ; for ( i = 0 ; i < count ; i ++ ) { LHEVC_ProfileTierLevel * ptl ; GF_SAFEALLOC ( ptl , LHEVC_ProfileTierLevel ) ; if ( ! ptl ) return GF_OUT_OF_MEM ; ptl -> general_profile_space = gf_bs_read_int ( bs , 2 ) ; ptl -> general_tier_flag = gf_bs_read_int ( bs , 1 ) ; ptl -> general_profile_idc = gf_bs_read_int ( bs , 5 ) ; ptl -> general_profile_compatibility_flags = gf_bs_read_u32 ( bs ) ; ptl -> general_constraint_indicator_flags = gf_bs_read_long_int ( bs , 48 ) ; ptl -> general_level_idc = gf_bs_read_u8 ( bs ) ; gf_list_add ( ptr -> profile_tier_levels , ptl ) ; } count = gf_bs_read_u16 ( bs ) ; for ( i = 0 ; i < count ; i ++ ) { LHEVC_OperatingPoint * op ; GF_SAFEALLOC ( op , LHEVC_OperatingPoint ) ; if ( ! op ) return GF_OUT_OF_MEM ; op -> output_layer_set_idx = gf_bs_read_u16 ( bs ) ; op -> max_temporal_id = gf_bs_read_u8 ( bs ) ; op -> layer_count = gf_bs_read_u8 ( bs ) ; if ( op -> layer_count > GF_ARRAY_LENGTH ( op -> layers_info ) ) { gf_free ( op ) ; return GF_NON_COMPLIANT_BITSTREAM ; } for ( j = 0 ; j < op -> layer_count ; j ++ ) { op -> layers_info [ j ] . ptl_idx = gf_bs_read_u8 ( bs ) ; op -> layers_info [ j ] . layer_id = gf_bs_read_int ( bs , 6 ) ; op -> layers_info [ j ] . is_outputlayer = gf_bs_read_int ( bs , 1 ) ? GF_TRUE : GF_FALSE ; op -> layers_info [ j ] . is_alternate_outputlayer = gf_bs_read_int ( bs , 1 ) ? GF_TRUE : GF_FALSE ; } op -> minPicWidth = gf_bs_read_u16 ( bs ) ; op -> minPicHeight = gf_bs_read_u16 ( bs ) ; op -> maxPicWidth = gf_bs_read_u16 ( bs ) ; op -> maxPicHeight = gf_bs_read_u16 ( bs ) ; op -> maxChromaFormat = gf_bs_read_int ( bs , 2 ) ; op -> maxBitDepth = gf_bs_read_int ( bs , 3 ) + 8 ; gf_bs_read_int ( bs , 1 ) ; op -> frame_rate_info_flag = gf_bs_read_int ( bs , 1 ) ? GF_TRUE : GF_FALSE ; op -> bit_rate_info_flag = gf_bs_read_int ( bs , 1 ) ? GF_TRUE : GF_FALSE ; if ( op -> frame_rate_info_flag ) { op -> avgFrameRate = gf_bs_read_u16 ( bs ) ; gf_bs_read_int ( bs , 6 ) ; op -> constantFrameRate = gf_bs_read_int ( bs , 2 ) ; } if ( op -> bit_rate_info_flag ) { op -> maxBitRate = gf_bs_read_u32 ( bs ) ; op -> avgBitRate = gf_bs_read_u32 ( bs ) ; } gf_list_add ( ptr -> operating_points , op ) ; } count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < count ; i ++ ) { LHEVC_DependentLayer * dep ; GF_SAFEALLOC ( dep , LHEVC_DependentLayer ) ; if ( ! dep ) return GF_OUT_OF_MEM ; dep -> dependent_layerID = gf_bs_read_u8 ( bs ) ; dep -> num_layers_dependent_on = gf_bs_read_u8 ( bs ) ; if ( dep -> num_layers_dependent_on > GF_ARRAY_LENGTH ( dep -> dependent_on_layerID ) ) { gf_free ( dep ) ; return GF_NON_COMPLIANT_BITSTREAM ; } for ( j = 0 ; j < dep -> num_layers_dependent_on ; j ++ ) dep -> dependent_on_layerID [ j ] = gf_bs_read_u8 ( bs ) ; for ( j = 0 ; j < 16 ; j ++ ) { if ( ptr -> scalability_mask & ( 1 < < j ) ) dep -> dimension_identifier [ j ] = gf_bs_read_u8 ( bs ) ; } gf_list_add ( ptr -> dependency_layers , dep ) ; } return GF_OK ; }
WebGLContext :: BufferSubData ( GLenum target , WebGLsizeiptr byteOffset , const Nullable < ArrayBuffer > & maybeData ) { if ( IsContextLost ( ) ) return ; if ( maybeData . IsNull ( ) ) { return ; } WebGLRefPtr < WebGLBuffer > * bufferSlot = GetBufferSlotByTarget ( target , "bufferSubData" ) ; if ( ! bufferSlot ) { return ; } const ArrayBuffer & data = maybeData . Value ( ) ; if ( byteOffset < 0 ) return ErrorInvalidValue ( "bufferSubData: negative offset" ) ; WebGLBuffer * boundBuffer = bufferSlot -> get ( ) ; if ( ! boundBuffer ) return ErrorInvalidOperation ( "bufferData: no buffer bound!" ) ; CheckedInt < WebGLsizeiptr > checked_neededByteLength = CheckedInt < WebGLsizeiptr > ( byteOffset ) + data . Length ( ) ; if ( ! checked_neededByteLength . isValid ( ) ) return ErrorInvalidValue ( "bufferSubData: integer overflow computing the needed byte length" ) ; if ( checked_neededByteLength . value ( ) > boundBuffer -> ByteLength ( ) ) return ErrorInvalidValue ( "bufferSubData: not enough data - operation requires %d bytes, but buffer only has %d bytes" , checked_neededByteLength . value ( ) , boundBuffer -> ByteLength ( ) ) ; MakeContextCurrent ( ) ; boundBuffer -> ElementArrayCacheBufferSubData ( byteOffset , data . Data ( ) , data . Length ( ) ) ; gl -> fBufferSubData ( target , byteOffset , data . Length ( ) , data . Data ( ) ) ; }
bool InterpreterAssembler :: TargetSupportsUnalignedAccess ( ) { #if V8_TARGET_ARCH_MIPS || V8_TARGET_ARCH_MIPS64 return false ; #elif V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_S390 || \     V8_TARGET_ARCH_ARM || V8_TARGET_ARCH_ARM64 || V8_TARGET_ARCH_PPC return true ; #else #error "Unknown Architecture" #endif }
X4TypeDescr :: call ( JSContext * cx , unsigned argc , Value * vp ) { CallArgs args = CallArgsFromVp ( argc , vp ) ; const unsigned LANES = 4 ; if ( args . length ( ) < LANES ) { JS_ReportErrorNumber ( cx , js_GetErrorMessage , nullptr , JSMSG_MORE_ARGS_NEEDED , args . callee ( ) . getClass ( ) -> name , "3" , "s" ) ; return false ; } double values [ LANES ] ; for ( unsigned i = 0 ; i < LANES ; i ++ ) { if ( ! ToNumber ( cx , args [ i ] , & values [ i ] ) ) return false ; } Rooted < X4TypeDescr * > descr ( cx , & args . callee ( ) . as < X4TypeDescr > ( ) ) ; Rooted < TypedObject * > result ( cx , TypedObject :: createZeroed ( cx , descr , 0 ) ) ; if ( ! result ) return false ; switch ( descr -> type ( ) ) { #define STORE_LANES(_constant, _type, _name)                                  \       case _constant:                                                         \       {                                                                       \         _type *mem = reinterpret_cast<_type*>(result->typedMem());            \         for (unsigned i = 0; i < LANES; i++)                                  \             mem[i] = ConvertScalar<_type>(values[i]);                         \         break;                                                                \       } JS_FOR_EACH_X4_TYPE_REPR ( STORE_LANES ) #undef STORE_LANES } args . rval ( ) . setObject ( * result ) ; return true ; }
f_assert_fails ( typval_T * argvars , typval_T * rettv ) { char_u * cmd ; garray_T ga ; int save_trylevel = trylevel ; int called_emsg_before = called_emsg ; char * wrong_arg_msg = NULL ; char_u * tofree = NULL ; if ( check_for_string_or_number_arg ( argvars , 0 ) == FAIL || check_for_opt_string_or_list_arg ( argvars , 1 ) == FAIL || ( argvars [ 1 ] . v_type != VAR_UNKNOWN && ( argvars [ 2 ] . v_type != VAR_UNKNOWN && ( check_for_opt_number_arg ( argvars , 3 ) == FAIL || ( argvars [ 3 ] . v_type != VAR_UNKNOWN && check_for_opt_string_arg ( argvars , 4 ) == FAIL ) ) ) ) ) return ; cmd = tv_get_string_chk ( & argvars [ 0 ] ) ; trylevel = 0 ; suppress_errthrow = TRUE ; in_assert_fails = TRUE ; do_cmdline_cmd ( cmd ) ; if ( called_emsg == called_emsg_before ) { prepare_assert_error ( & ga ) ; ga_concat ( & ga , ( char_u * ) "command did not fail: " ) ; assert_append_cmd_or_arg ( & ga , argvars , cmd ) ; assert_error ( & ga ) ; ga_clear ( & ga ) ; rettv -> vval . v_number = 1 ; } else if ( argvars [ 1 ] . v_type != VAR_UNKNOWN ) { char_u buf [ NUMBUFLEN ] ; char_u * expected ; char_u * expected_str = NULL ; int error_found = FALSE ; int error_found_index = 1 ; char_u * actual = emsg_assert_fails_msg == NULL ? ( char_u * ) "[unknown]" : emsg_assert_fails_msg ; if ( argvars [ 1 ] . v_type == VAR_STRING ) { expected = tv_get_string_buf_chk ( & argvars [ 1 ] , buf ) ; error_found = expected == NULL || strstr ( ( char * ) actual , ( char * ) expected ) == NULL ; } else if ( argvars [ 1 ] . v_type == VAR_LIST ) { list_T * list = argvars [ 1 ] . vval . v_list ; typval_T * tv ; if ( list == NULL || list -> lv_len < 1 || list -> lv_len > 2 ) { wrong_arg_msg = e_assert_fails_second_arg ; goto theend ; } CHECK_LIST_MATERIALIZE ( list ) ; tv = & list -> lv_first -> li_tv ; expected = tv_get_string_buf_chk ( tv , buf ) ; if ( ! pattern_match ( expected , actual , FALSE ) ) { error_found = TRUE ; expected_str = expected ; } else if ( list -> lv_len == 2 ) { tofree = actual = vim_strsave ( get_vim_var_str ( VV_ERRMSG ) ) ; if ( actual != NULL ) { tv = & list -> lv_u . mat . lv_last -> li_tv ; expected = tv_get_string_buf_chk ( tv , buf ) ; if ( ! pattern_match ( expected , actual , FALSE ) ) { error_found = TRUE ; expected_str = expected ; } } } } else { wrong_arg_msg = e_assert_fails_second_arg ; goto theend ; } if ( ! error_found && argvars [ 2 ] . v_type != VAR_UNKNOWN && argvars [ 3 ] . v_type != VAR_UNKNOWN ) { if ( argvars [ 3 ] . v_type != VAR_NUMBER ) { wrong_arg_msg = e_assert_fails_fourth_argument ; goto theend ; } else if ( argvars [ 3 ] . vval . v_number >= 0 && argvars [ 3 ] . vval . v_number != emsg_assert_fails_lnum ) { error_found = TRUE ; error_found_index = 3 ; } if ( ! error_found && argvars [ 4 ] . v_type != VAR_UNKNOWN ) { if ( argvars [ 4 ] . v_type != VAR_STRING ) { wrong_arg_msg = e_assert_fails_fifth_argument ; goto theend ; } else if ( argvars [ 4 ] . vval . v_string != NULL && ! pattern_match ( argvars [ 4 ] . vval . v_string , emsg_assert_fails_context , FALSE ) ) { error_found = TRUE ; error_found_index = 4 ; } } } if ( error_found ) { typval_T actual_tv ; prepare_assert_error ( & ga ) ; if ( error_found_index == 3 ) { actual_tv . v_type = VAR_NUMBER ; actual_tv . vval . v_number = emsg_assert_fails_lnum ; } else if ( error_found_index == 4 ) { actual_tv . v_type = VAR_STRING ; actual_tv . vval . v_string = emsg_assert_fails_context ; } else { actual_tv . v_type = VAR_STRING ; actual_tv . vval . v_string = actual ; } fill_assert_error ( & ga , & argvars [ 2 ] , expected_str , & argvars [ error_found_index ] , & actual_tv , ASSERT_OTHER ) ; ga_concat ( & ga , ( char_u * ) ": " ) ; assert_append_cmd_or_arg ( & ga , argvars , cmd ) ; assert_error ( & ga ) ; ga_clear ( & ga ) ; rettv -> vval . v_number = 1 ; } } theend : trylevel = save_trylevel ; suppress_errthrow = FALSE ; in_assert_fails = FALSE ; did_emsg = FALSE ; got_int = FALSE ; msg_col = 0 ; need_wait_return = FALSE ; emsg_on_display = FALSE ; msg_scrolled = 0 ; lines_left = Rows ; VIM_CLEAR ( emsg_assert_fails_msg ) ; vim_free ( tofree ) ; set_vim_var_string ( VV_ERRMSG , NULL , 0 ) ; if ( wrong_arg_msg != NULL ) emsg ( _ ( wrong_arg_msg ) ) ; }
WorkerRunInternal ( WorkerPrivate * aWorkerPrivate ) { MOZ_ASSERT ( aWorkerPrivate ) ; aWorkerPrivate -> AssertIsOnWorkerThread ( ) ; mResolver -> mPromiseProxy -> CleanUp ( ) ; mResolver -> mFetchObserver = nullptr ; if ( mResolver -> mSignalProxy ) { mResolver -> mSignalProxy -> Shutdown ( ) ; mResolver -> mSignalProxy = nullptr ; } }
opj_j2k_t * opj_j2k_create_decompress ( void ) { opj_j2k_t * l_j2k = ( opj_j2k_t * ) opj_calloc ( 1 , sizeof ( opj_j2k_t ) ) ; if ( ! l_j2k ) { return 00 ; } l_j2k -> m_is_decoder = 1 ; l_j2k -> m_cp . m_is_decoder = 1 ; #ifdef OPJ_DISABLE_TPSOT_FIX l_j2k -> m_specific_param . m_decoder . m_nb_tile_parts_correction_checked = 1 ; #endif l_j2k -> m_specific_param . m_decoder . m_default_tcp = ( opj_tcp_t * ) opj_calloc ( 1 , sizeof ( opj_tcp_t ) ) ; if ( ! l_j2k -> m_specific_param . m_decoder . m_default_tcp ) { opj_j2k_destroy ( l_j2k ) ; return 00 ; } l_j2k -> m_specific_param . m_decoder . m_header_data = ( OPJ_BYTE * ) opj_calloc ( 1 , OPJ_J2K_DEFAULT_HEADER_SIZE ) ; if ( ! l_j2k -> m_specific_param . m_decoder . m_header_data ) { opj_j2k_destroy ( l_j2k ) ; return 00 ; } l_j2k -> m_specific_param . m_decoder . m_header_data_size = OPJ_J2K_DEFAULT_HEADER_SIZE ; l_j2k -> m_specific_param . m_decoder . m_tile_ind_to_dec = - 1 ; l_j2k -> m_specific_param . m_decoder . m_last_sot_read_pos = 0 ; l_j2k -> cstr_index = opj_j2k_create_cstr_index ( ) ; if ( ! l_j2k -> cstr_index ) { opj_j2k_destroy ( l_j2k ) ; return 00 ; } l_j2k -> m_validation_list = opj_procedure_list_create ( ) ; if ( ! l_j2k -> m_validation_list ) { opj_j2k_destroy ( l_j2k ) ; return 00 ; } l_j2k -> m_procedure_list = opj_procedure_list_create ( ) ; if ( ! l_j2k -> m_procedure_list ) { opj_j2k_destroy ( l_j2k ) ; return 00 ; } return l_j2k ; }
void Run ( NodeVector * roots ) { for ( Node * const root : * roots ) { queue_ . push ( root ) ; while ( ! queue_ . empty ( ) ) { VisitNode ( queue_ . front ( ) ) ; queue_ . pop ( ) ; } } }
void btif_dm_save_ble_bonding_keys ( void ) { BTIF_TRACE_DEBUG ( "%s" , __func__ ) ; RawAddress bd_addr = pairing_cb . bd_addr ; if ( pairing_cb . ble . is_penc_key_rcvd ) { btif_storage_add_ble_bonding_key ( & bd_addr , ( uint8_t * ) & pairing_cb . ble . penc_key , BTIF_DM_LE_KEY_PENC , sizeof ( tBTM_LE_PENC_KEYS ) ) ; } if ( pairing_cb . ble . is_pid_key_rcvd ) { btif_storage_add_ble_bonding_key ( & bd_addr , ( uint8_t * ) & pairing_cb . ble . pid_key , BTIF_DM_LE_KEY_PID , sizeof ( tBTM_LE_PID_KEYS ) ) ; } if ( pairing_cb . ble . is_pcsrk_key_rcvd ) { btif_storage_add_ble_bonding_key ( & bd_addr , ( uint8_t * ) & pairing_cb . ble . pcsrk_key , BTIF_DM_LE_KEY_PCSRK , sizeof ( tBTM_LE_PCSRK_KEYS ) ) ; } if ( pairing_cb . ble . is_lenc_key_rcvd ) { btif_storage_add_ble_bonding_key ( & bd_addr , ( uint8_t * ) & pairing_cb . ble . lenc_key , BTIF_DM_LE_KEY_LENC , sizeof ( tBTM_LE_LENC_KEYS ) ) ; } if ( pairing_cb . ble . is_lcsrk_key_rcvd ) { btif_storage_add_ble_bonding_key ( & bd_addr , ( uint8_t * ) & pairing_cb . ble . lcsrk_key , BTIF_DM_LE_KEY_LCSRK , sizeof ( tBTM_LE_LCSRK_KEYS ) ) ; } if ( pairing_cb . ble . is_lidk_key_rcvd ) { btif_storage_add_ble_bonding_key ( & bd_addr , NULL , BTIF_DM_LE_KEY_LID , 0 ) ; } }
static ssize_t aio_run_iocb ( struct kiocb * req , unsigned opcode , char __user * buf , size_t len , bool compat ) { struct file * file = req -> ki_filp ; ssize_t ret ; unsigned long nr_segs ; int rw ; fmode_t mode ; aio_rw_op * rw_op ; rw_iter_op * iter_op ; struct iovec inline_vecs [ UIO_FASTIOV ] , * iovec = inline_vecs ; struct iov_iter iter ; switch ( opcode ) { case IOCB_CMD_PREAD : case IOCB_CMD_PREADV : mode = FMODE_READ ; rw = READ ; rw_op = file -> f_op -> aio_read ; iter_op = file -> f_op -> read_iter ; goto rw_common ; case IOCB_CMD_PWRITE : case IOCB_CMD_PWRITEV : mode = FMODE_WRITE ; rw = WRITE ; rw_op = file -> f_op -> aio_write ; iter_op = file -> f_op -> write_iter ; goto rw_common ; rw_common : if ( unlikely ( ! ( file -> f_mode & mode ) ) ) return - EBADF ; if ( ! rw_op && ! iter_op ) return - EINVAL ; if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs , & len , & iovec , compat ) ; else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs , len , iovec ) ; if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ; if ( ret < 0 ) { if ( iovec != inline_vecs ) kfree ( iovec ) ; return ret ; } len = ret ; if ( req -> ki_pos < 0 ) { ret = - EINVAL ; break ; } if ( rw == WRITE ) file_start_write ( file ) ; if ( iter_op ) { iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ; ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iovec , nr_segs , req -> ki_pos ) ; } if ( rw == WRITE ) file_end_write ( file ) ; break ; case IOCB_CMD_FDSYNC : if ( ! file -> f_op -> aio_fsync ) return - EINVAL ; ret = file -> f_op -> aio_fsync ( req , 1 ) ; break ; case IOCB_CMD_FSYNC : if ( ! file -> f_op -> aio_fsync ) return - EINVAL ; ret = file -> f_op -> aio_fsync ( req , 0 ) ; break ; default : pr_debug ( "EINVAL: no operation provided\n" ) ; return - EINVAL ; } if ( iovec != inline_vecs ) kfree ( iovec ) ; if ( ret != - EIOCBQUEUED ) { if ( unlikely ( ret == - ERESTARTSYS || ret == - ERESTARTNOINTR || ret == - ERESTARTNOHAND || ret == - ERESTART_RESTARTBLOCK ) ) ret = - EINTR ; aio_complete ( req , ret , 0 ) ; } return 0 ; }
DataSourceSurfaceD2D1 :: Map ( MapType aMapType , MappedSurface * aMappedSurface ) { MOZ_ASSERT ( ! mMapped ) ; MOZ_ASSERT ( ! mIsMapped ) ; D2D1_MAP_OPTIONS options ; if ( aMapType == MapType :: READ ) { options = D2D1_MAP_OPTIONS_READ ; } else { MOZ_CRASH ( "No support for Write maps on D2D1 DataSourceSurfaces yet!" ) ; } D2D1_MAPPED_RECT map ; mBitmap -> Map ( D2D1_MAP_OPTIONS_READ , & map ) ; aMappedSurface -> mData = map . bits ; aMappedSurface -> mStride = map . pitch ; mIsMapped = ! ! aMappedSurface -> mData ; return mIsMapped ; }
static void cost ( int * costs , vp9_tree tree , const vp9_prob * probs , int i , int c ) { const vp9_prob prob = probs [ i / 2 ] ; int b ; for ( b = 0 ; b <= 1 ; ++ b ) { const int cc = c + vp9_cost_bit ( prob , b ) ; const vp9_tree_index ii = tree [ i + b ] ; if ( ii <= 0 ) costs [ - ii ] = cc ; else cost ( costs , tree , probs , ii , cc ) ; } }
net_bind ( short unsigned * port , int type , const char * log_service_name ) { struct addrinfo hints = { 0 } ; struct addrinfo * servinfo ; struct addrinfo * ptr ; const char * cfgaddr ; char addr [ INET6_ADDRSTRLEN ] ; char strport [ 8 ] ; int yes = 1 ; int no = 0 ; int fd ; int ret ; cfgaddr = cfg_getstr ( cfg_getsec ( cfg , "general" ) , "bind_address" ) ; hints . ai_socktype = ( type & ( SOCK_STREAM | SOCK_DGRAM ) ) ; hints . ai_family = ( cfg_getbool ( cfg_getsec ( cfg , "general" ) , "ipv6" ) ) ? AF_INET6 : AF_INET ; hints . ai_flags = cfgaddr ? 0 : AI_PASSIVE ; snprintf ( strport , sizeof ( strport ) , "%hu" , * port ) ; ret = getaddrinfo ( cfgaddr , strport , & hints , & servinfo ) ; if ( ret < 0 ) { DPRINTF ( E_LOG , L_MISC , "Failure creating '%s' service, could not resolve '%s' (port %s): %s\n" , log_service_name , cfgaddr ? cfgaddr : "(ANY)" , strport , gai_strerror ( ret ) ) ; return - 1 ; } for ( ptr = servinfo , fd = - 1 ; ptr != NULL ; ptr = ptr -> ai_next ) { if ( fd >= 0 ) close ( fd ) ; fd = socket ( ptr -> ai_family , type | SOCK_CLOEXEC , ptr -> ai_protocol ) ; if ( fd < 0 ) continue ; ret = setsockopt ( fd , SOL_SOCKET , SO_KEEPALIVE , & yes , sizeof ( yes ) ) ; if ( ret < 0 ) continue ; ret = setsockopt ( fd , SOL_SOCKET , SO_REUSEADDR , & yes , sizeof ( yes ) ) ; if ( ret < 0 ) continue ; if ( ptr -> ai_family == AF_INET6 ) { ret = setsockopt ( fd , IPPROTO_IPV6 , IPV6_V6ONLY , & no , sizeof ( no ) ) ; if ( ret < 0 ) continue ; } ret = bind ( fd , ptr -> ai_addr , ptr -> ai_addrlen ) ; if ( ret < 0 ) continue ; break ; } freeaddrinfo ( servinfo ) ; if ( ! ptr ) { DPRINTF ( E_LOG , L_MISC , "Could not create service '%s' with address %s, port %hu: %s\n" , log_service_name , cfgaddr ? cfgaddr : "(ANY)" , * port , strerror ( errno ) ) ; goto error ; } ret = getsockname ( fd , ptr -> ai_addr , & ptr -> ai_addrlen ) ; if ( ret < 0 ) { DPRINTF ( E_LOG , L_MISC , "Could not find address of service '%s': %s\n" , log_service_name , strerror ( errno ) ) ; goto error ; } net_port_get ( port , ( union net_sockaddr * ) ptr -> ai_addr ) ; net_address_get ( addr , sizeof ( addr ) , ( union net_sockaddr * ) ptr -> ai_addr ) ; DPRINTF ( E_DBG , L_MISC , "Service '%s' bound to %s, port %hu, socket %d\n" , log_service_name , addr , * port , fd ) ; return fd ; error : close ( fd ) ; return - 1 ; }
static VALUE cState_indent_set ( VALUE self , VALUE indent ) { unsigned long len ; GET_STATE ( self ) ; Check_Type ( indent , T_STRING ) ; len = RSTRING_LEN ( indent ) ; if ( len == 0 ) { if ( state -> indent ) { ruby_xfree ( state -> indent ) ; state -> indent = NULL ; state -> indent_len = 0 ; } } else { if ( state -> indent ) ruby_xfree ( state -> indent ) ; state -> indent = strdup ( RSTRING_PTR ( indent ) ) ; state -> indent_len = len ; } return Qnil ; }
void SmallOrderedHashTable < Derived > :: Initialize ( Isolate * isolate , int capacity ) { DisallowHeapAllocation no_gc ; int num_buckets = capacity / kLoadFactor ; int num_chains = capacity ; SetNumberOfBuckets ( num_buckets ) ; SetNumberOfElements ( 0 ) ; SetNumberOfDeletedElements ( 0 ) ; Address hashtable_start = GetHashTableStartAddress ( capacity ) ; memset ( reinterpret_cast < byte * > ( hashtable_start ) , kNotFound , num_buckets + num_chains ) ; if ( Heap :: InNewSpace ( this ) ) { MemsetPointer ( RawField ( this , kDataTableStartOffset ) , ReadOnlyRoots ( isolate ) . the_hole_value ( ) , capacity * Derived :: kEntrySize ) ; } else { for ( int i = 0 ; i < capacity ; i ++ ) { for ( int j = 0 ; j < Derived :: kEntrySize ; j ++ ) { SetDataEntry ( i , j , ReadOnlyRoots ( isolate ) . the_hole_value ( ) ) ; } } } #ifdef DEBUG for ( int i = 0 ; i < num_buckets ; ++ i ) { DCHECK_EQ ( kNotFound , GetFirstEntry ( i ) ) ; } for ( int i = 0 ; i < num_chains ; ++ i ) { DCHECK_EQ ( kNotFound , GetNextEntry ( i ) ) ; } for ( int i = 0 ; i < capacity ; ++ i ) { for ( int j = 0 ; j < Derived :: kEntrySize ; j ++ ) { DCHECK_EQ ( ReadOnlyRoots ( isolate ) . the_hole_value ( ) , GetDataEntry ( i , j ) ) ; } } #endif // DEBUG }
bool Heap :: IsIneffectiveMarkCompact ( size_t old_generation_size , double mutator_utilization ) { const double kHighHeapPercentage = 0.8 ; const double kLowMutatorUtilization = 0.4 ; return old_generation_size >= kHighHeapPercentage * max_old_generation_size_ && mutator_utilization < kLowMutatorUtilization ; }
BGD_DECLARE ( void * ) gdImageJpegPtr ( gdImagePtr im , int * size , int quality ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; if ( out == NULL ) return NULL ; gdImageJpegCtx ( im , out , quality ) ; rv = gdDPExtractData ( out , size ) ; out -> gd_free ( out ) ; return rv ; }
int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) { if ( radiotap_header -> it_version ) return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 < < IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 < < IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg - ( unsigned long ) iterator -> _rtheader > ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }
void RegExpMacroAssemblerARM :: CheckPreemption ( ) { ExternalReference stack_limit = ExternalReference :: address_of_stack_limit ( isolate ( ) ) ; __ mov ( r0 , Operand ( stack_limit ) ) ; __ ldr ( r0 , MemOperand ( r0 ) ) ; __ cmp ( sp , r0 ) ; SafeCall ( & check_preempt_label_ , ls ) ; }
GetStartupData ( HANDLE pipe , STARTUP_DATA * sud ) { size_t size , len ; BOOL ret = FALSE ; WCHAR * data = NULL ; DWORD bytes , read ; bytes = PeekNamedPipeAsync ( pipe , 1 , & exit_event ) ; if ( bytes == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( "PeekNamedPipeAsync failed" ) ) ; ReturnLastError ( pipe , L"PeekNamedPipeAsync" ) ; goto out ; } size = bytes / sizeof ( * data ) ; if ( size == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( "malformed startup data: 1 byte received" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; goto out ; } data = malloc ( bytes ) ; if ( data == NULL ) { MsgToEventLog ( M_SYSERR , TEXT ( "malloc failed" ) ) ; ReturnLastError ( pipe , L"malloc" ) ; goto out ; } read = ReadPipeAsync ( pipe , data , bytes , 1 , & exit_event ) ; if ( bytes != read ) { MsgToEventLog ( M_SYSERR , TEXT ( "ReadPipeAsync failed" ) ) ; ReturnLastError ( pipe , L"ReadPipeAsync" ) ; goto out ; } if ( data [ size - 1 ] != 0 ) { MsgToEventLog ( M_ERR , TEXT ( "Startup data is not NULL terminated" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; goto out ; } sud -> directory = data ; len = wcslen ( sud -> directory ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( "Startup data ends at working directory" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; goto out ; } sud -> options = sud -> directory + len ; len = wcslen ( sud -> options ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( "Startup data ends at command line options" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; goto out ; } sud -> std_input = sud -> options + len ; data = NULL ; ret = TRUE ; out : free ( data ) ; return ret ; }
Type Typer :: Visitor :: TypeLoadTypedElement ( Node * node ) { switch ( ExternalArrayTypeOf ( node -> op ( ) ) ) { #define TYPED_ARRAY_CASE(ElemType, type, TYPE, ctype) \  case kExternal##ElemType##Array:                    \  return typer_->cache_.k##ElemType; TYPED_ARRAYS ( TYPED_ARRAY_CASE ) #undef TYPED_ARRAY_CASE } UNREACHABLE ( ) ; }
Reduction JSTypedLowering :: ReduceJSForInNext ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSForInNext , node -> opcode ( ) ) ; ForInMode const mode = ForInModeOf ( node -> op ( ) ) ; Node * receiver = NodeProperties :: GetValueInput ( node , 0 ) ; Node * cache_array = NodeProperties :: GetValueInput ( node , 1 ) ; Node * cache_type = NodeProperties :: GetValueInput ( node , 2 ) ; Node * index = NodeProperties :: GetValueInput ( node , 3 ) ; Node * context = NodeProperties :: GetContextInput ( node ) ; Node * frame_state = NodeProperties :: GetFrameStateInput ( node ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; Node * receiver_map = effect = graph ( ) -> NewNode ( simplified ( ) -> LoadField ( AccessBuilder :: ForMap ( ) ) , receiver , effect , control ) ; switch ( mode ) { case ForInMode :: kUseEnumCacheKeys : case ForInMode :: kUseEnumCacheKeysAndIndices : { Node * check = graph ( ) -> NewNode ( simplified ( ) -> ReferenceEqual ( ) , receiver_map , cache_type ) ; effect = graph ( ) -> NewNode ( simplified ( ) -> CheckIf ( DeoptimizeReason :: kWrongMap ) , check , effect , control ) ; ReplaceWithValue ( node , node , node , control ) ; node -> ReplaceInput ( 0 , cache_array ) ; node -> ReplaceInput ( 1 , index ) ; node -> ReplaceInput ( 2 , effect ) ; node -> ReplaceInput ( 3 , control ) ; node -> TrimInputCount ( 4 ) ; NodeProperties :: ChangeOp ( node , simplified ( ) -> LoadElement ( AccessBuilder :: ForFixedArrayElement ( ) ) ) ; NodeProperties :: SetType ( node , Type :: InternalizedString ( ) ) ; break ; } case ForInMode :: kGeneric : { Node * key = effect = graph ( ) -> NewNode ( simplified ( ) -> LoadElement ( AccessBuilder :: ForFixedArrayElement ( ) ) , cache_array , index , effect , control ) ; Node * check = graph ( ) -> NewNode ( simplified ( ) -> ReferenceEqual ( ) , receiver_map , cache_type ) ; Node * branch = graph ( ) -> NewNode ( common ( ) -> Branch ( BranchHint :: kTrue ) , check , control ) ; Node * if_true = graph ( ) -> NewNode ( common ( ) -> IfTrue ( ) , branch ) ; Node * etrue ; Node * vtrue ; { etrue = effect ; vtrue = key ; } Node * if_false = graph ( ) -> NewNode ( common ( ) -> IfFalse ( ) , branch ) ; Node * efalse ; Node * vfalse ; { Callable const callable = Builtins :: CallableFor ( isolate ( ) , Builtins :: kForInFilter ) ; auto call_descriptor = Linkage :: GetStubCallDescriptor ( graph ( ) -> zone ( ) , callable . descriptor ( ) , 0 , CallDescriptor :: kNeedsFrameState ) ; vfalse = efalse = if_false = graph ( ) -> NewNode ( common ( ) -> Call ( call_descriptor ) , jsgraph ( ) -> HeapConstant ( callable . code ( ) ) , key , receiver , context , frame_state , effect , if_false ) ; Node * if_exception = nullptr ; if ( NodeProperties :: IsExceptionalCall ( node , & if_exception ) ) { if_false = graph ( ) -> NewNode ( common ( ) -> IfSuccess ( ) , vfalse ) ; NodeProperties :: ReplaceControlInput ( if_exception , vfalse ) ; NodeProperties :: ReplaceEffectInput ( if_exception , efalse ) ; Revisit ( if_exception ) ; } } control = graph ( ) -> NewNode ( common ( ) -> Merge ( 2 ) , if_true , if_false ) ; effect = graph ( ) -> NewNode ( common ( ) -> EffectPhi ( 2 ) , etrue , efalse , control ) ; ReplaceWithValue ( node , node , effect , control ) ; node -> ReplaceInput ( 0 , vtrue ) ; node -> ReplaceInput ( 1 , vfalse ) ; node -> ReplaceInput ( 2 , control ) ; node -> TrimInputCount ( 3 ) ; NodeProperties :: ChangeOp ( node , common ( ) -> Phi ( MachineRepresentation :: kTagged , 2 ) ) ; } } return Changed ( node ) ; }
IGNITION_HANDLER ( ThrowSuperAlreadyCalledIfNotHole , InterpreterAssembler ) { Node * value = GetAccumulator ( ) ; Label throw_error ( this , Label :: kDeferred ) ; GotoIf ( WordNotEqual ( value , TheHoleConstant ( ) ) , & throw_error ) ; Dispatch ( ) ; BIND ( & throw_error ) ; { CallRuntime ( Runtime :: kThrowSuperAlreadyCalledError , GetContext ( ) ) ; Abort ( AbortReason :: kUnexpectedReturnFromThrow ) ; } }
std :: pair < uint32_t , uint32_t > StackEffect ( const WasmModule * module , FunctionSig * sig , const byte * pc , const byte * end ) { WasmFeatures unused_detected_features ; WasmDecoder < Decoder :: kNoValidate > decoder ( module , kAllWasmFeatures , & unused_detected_features , sig , pc , end ) ; return decoder . StackEffect ( pc ) ; }
int sas_discover_end_dev ( struct domain_device * dev ) { int res ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; sas_discover_event ( dev -> port , DISCE_PROBE ) ; return 0 ; }
FLAC__bool write_bitbuffer_ ( FLAC__StreamEncoder * encoder , unsigned samples , FLAC__bool is_last_block ) { const FLAC__byte * buffer ; size_t bytes ; FLAC__ASSERT ( FLAC__bitwriter_is_byte_aligned ( encoder -> private_ -> frame ) ) ; if ( ! FLAC__bitwriter_get_buffer ( encoder -> private_ -> frame , & buffer , & bytes ) ) { encoder -> protected_ -> state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR ; return false ; } if ( encoder -> protected_ -> verify ) { encoder -> private_ -> verify . output . data = buffer ; encoder -> private_ -> verify . output . bytes = bytes ; if ( encoder -> private_ -> verify . state_hint == ENCODER_IN_MAGIC ) { encoder -> private_ -> verify . needs_magic_hack = true ; } else { if ( ! FLAC__stream_decoder_process_single ( encoder -> private_ -> verify . decoder ) ) { FLAC__bitwriter_release_buffer ( encoder -> private_ -> frame ) ; FLAC__bitwriter_clear ( encoder -> private_ -> frame ) ; if ( encoder -> protected_ -> state != FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA ) encoder -> protected_ -> state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR ; return false ; } } } if ( write_frame_ ( encoder , buffer , bytes , samples , is_last_block ) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK ) { FLAC__bitwriter_release_buffer ( encoder -> private_ -> frame ) ; FLAC__bitwriter_clear ( encoder -> private_ -> frame ) ; encoder -> protected_ -> state = FLAC__STREAM_ENCODER_CLIENT_ERROR ; return false ; } FLAC__bitwriter_release_buffer ( encoder -> private_ -> frame ) ; FLAC__bitwriter_clear ( encoder -> private_ -> frame ) ; if ( samples > 0 ) { encoder -> private_ -> streaminfo . data . stream_info . min_framesize = min ( bytes , encoder -> private_ -> streaminfo . data . stream_info . min_framesize ) ; encoder -> private_ -> streaminfo . data . stream_info . max_framesize = max ( bytes , encoder -> private_ -> streaminfo . data . stream_info . max_framesize ) ; } return true ; }
void RegExpMacroAssemblerARM64 :: CheckPreemption ( ) { ExternalReference stack_limit = ExternalReference :: address_of_stack_limit ( isolate ( ) ) ; __ Mov ( x10 , stack_limit ) ; __ Ldr ( x10 , MemOperand ( x10 ) ) ; __ Cmp ( sp , x10 ) ; CallIf ( & check_preempt_label_ , ls ) ; }
BytecodeParser :: parse ( ) { MOZ_ASSERT ( ! codeArray_ ) ; uint32_t length = script_ -> length ( ) ; codeArray_ = alloc ( ) . newArray < Bytecode * > ( length ) ; if ( ! codeArray_ ) { reportOOM ( ) ; return false ; } mozilla :: PodZero ( codeArray_ , length ) ; Bytecode * startcode = alloc ( ) . new_ < Bytecode > ( ) ; if ( ! startcode ) { reportOOM ( ) ; return false ; } uint32_t * offsetStack = alloc ( ) . newArray < uint32_t > ( maximumStackDepth ( ) ) ; if ( maximumStackDepth ( ) && ! offsetStack ) { reportOOM ( ) ; return false ; } startcode -> stackDepth = 0 ; codeArray_ [ 0 ] = startcode ; uint32_t offset , nextOffset = 0 ; while ( nextOffset < length ) { offset = nextOffset ; Bytecode * code = maybeCode ( offset ) ; jsbytecode * pc = script_ -> offsetToPC ( offset ) ; JSOp op = ( JSOp ) * pc ; MOZ_ASSERT ( op < JSOP_LIMIT ) ; uint32_t successorOffset = offset + GetBytecodeLength ( pc ) ; nextOffset = successorOffset ; if ( ! code ) { continue ; } if ( code -> parsed ) { continue ; } code -> parsed = true ; uint32_t stackDepth = simulateOp ( op , offset , offsetStack , code -> stackDepth ) ; switch ( op ) { case JSOP_TABLESWITCH : { uint32_t defaultOffset = offset + GET_JUMP_OFFSET ( pc ) ; jsbytecode * pc2 = pc + JUMP_OFFSET_LEN ; int32_t low = GET_JUMP_OFFSET ( pc2 ) ; pc2 += JUMP_OFFSET_LEN ; int32_t high = GET_JUMP_OFFSET ( pc2 ) ; pc2 += JUMP_OFFSET_LEN ; if ( ! addJump ( defaultOffset , & nextOffset , stackDepth , offsetStack ) ) return false ; for ( int32_t i = low ; i <= high ; i ++ ) { uint32_t targetOffset = offset + GET_JUMP_OFFSET ( pc2 ) ; if ( targetOffset != offset ) { if ( ! addJump ( targetOffset , & nextOffset , stackDepth , offsetStack ) ) return false ; } pc2 += JUMP_OFFSET_LEN ; } break ; } case JSOP_TRY : { JSTryNote * tn = script_ -> trynotes ( ) -> vector ; JSTryNote * tnlimit = tn + script_ -> trynotes ( ) -> length ; for ( ; tn < tnlimit ; tn ++ ) { uint32_t startOffset = script_ -> mainOffset ( ) + tn -> start ; if ( startOffset == offset + 1 ) { uint32_t catchOffset = startOffset + tn -> length ; if ( tn -> kind != JSTRY_FOR_IN && tn -> kind != JSTRY_LOOP ) { if ( ! addJump ( catchOffset , & nextOffset , stackDepth , offsetStack ) ) return false ; } } } break ; } default : break ; } if ( IsJumpOpcode ( op ) ) { uint32_t newStackDepth = stackDepth ; if ( op == JSOP_CASE ) newStackDepth -- ; uint32_t targetOffset = offset + GET_JUMP_OFFSET ( pc ) ; if ( ! addJump ( targetOffset , & nextOffset , newStackDepth , offsetStack ) ) return false ; } if ( BytecodeFallsThrough ( op ) ) { MOZ_ASSERT ( successorOffset < script_ -> length ( ) ) ; Bytecode * & nextcode = codeArray_ [ successorOffset ] ; if ( ! nextcode ) { nextcode = alloc ( ) . new_ < Bytecode > ( ) ; if ( ! nextcode ) { reportOOM ( ) ; return false ; } if ( ! nextcode -> captureOffsetStack ( alloc ( ) , offsetStack , stackDepth ) ) { reportOOM ( ) ; return false ; } } else { nextcode -> mergeOffsetStack ( offsetStack , stackDepth ) ; } } } return true ; }
Node * ObjectBuiltinsAssembler :: FromPropertyDescriptor ( Node * context , Node * desc ) { VARIABLE ( js_descriptor , MachineRepresentation :: kTagged ) ; Node * flags = LoadAndUntagToWord32ObjectField ( desc , PropertyDescriptorObject :: kFlagsOffset ) ; Node * has_flags = Word32And ( flags , Int32Constant ( PropertyDescriptorObject :: kHasMask ) ) ; Label if_accessor_desc ( this ) , if_data_desc ( this ) , if_generic_desc ( this ) , return_desc ( this ) ; GotoIf ( Word32Equal ( has_flags , Int32Constant ( PropertyDescriptorObject :: kRegularAccessorPropertyBits ) ) , & if_accessor_desc ) ; GotoIf ( Word32Equal ( has_flags , Int32Constant ( PropertyDescriptorObject :: kRegularDataPropertyBits ) ) , & if_data_desc ) ; Goto ( & if_generic_desc ) ; BIND ( & if_accessor_desc ) ; { js_descriptor . Bind ( ConstructAccessorDescriptor ( context , LoadObjectField ( desc , PropertyDescriptorObject :: kGetOffset ) , LoadObjectField ( desc , PropertyDescriptorObject :: kSetOffset ) , IsSetWord32 < PropertyDescriptorObject :: IsEnumerableBit > ( flags ) , IsSetWord32 < PropertyDescriptorObject :: IsConfigurableBit > ( flags ) ) ) ; Goto ( & return_desc ) ; } BIND ( & if_data_desc ) ; { js_descriptor . Bind ( ConstructDataDescriptor ( context , LoadObjectField ( desc , PropertyDescriptorObject :: kValueOffset ) , IsSetWord32 < PropertyDescriptorObject :: IsWritableBit > ( flags ) , IsSetWord32 < PropertyDescriptorObject :: IsEnumerableBit > ( flags ) , IsSetWord32 < PropertyDescriptorObject :: IsConfigurableBit > ( flags ) ) ) ; Goto ( & return_desc ) ; } BIND ( & if_generic_desc ) ; { Node * native_context = LoadNativeContext ( context ) ; Node * map = LoadContextElement ( native_context , Context :: SLOW_OBJECT_WITH_OBJECT_PROTOTYPE_MAP ) ; TNode < NameDictionary > properties = AllocateNameDictionary ( 6 ) ; Node * js_desc = AllocateJSObjectFromMap ( map , properties ) ; Label bailout ( this , Label :: kDeferred ) ; Factory * factory = isolate ( ) -> factory ( ) ; TNode < Object > value = LoadObjectField ( desc , PropertyDescriptorObject :: kValueOffset ) ; AddToDictionaryIf ( IsNotTheHole ( value ) , properties , factory -> value_string ( ) , value , & bailout ) ; AddToDictionaryIf ( IsSetWord32 < PropertyDescriptorObject :: HasWritableBit > ( flags ) , properties , factory -> writable_string ( ) , SelectBooleanConstant ( IsSetWord32 < PropertyDescriptorObject :: IsWritableBit > ( flags ) ) , & bailout ) ; TNode < Object > get = LoadObjectField ( desc , PropertyDescriptorObject :: kGetOffset ) ; AddToDictionaryIf ( IsNotTheHole ( get ) , properties , factory -> get_string ( ) , get , & bailout ) ; TNode < Object > set = LoadObjectField ( desc , PropertyDescriptorObject :: kSetOffset ) ; AddToDictionaryIf ( IsNotTheHole ( set ) , properties , factory -> set_string ( ) , set , & bailout ) ; AddToDictionaryIf ( IsSetWord32 < PropertyDescriptorObject :: HasEnumerableBit > ( flags ) , properties , factory -> enumerable_string ( ) , SelectBooleanConstant ( IsSetWord32 < PropertyDescriptorObject :: IsEnumerableBit > ( flags ) ) , & bailout ) ; AddToDictionaryIf ( IsSetWord32 < PropertyDescriptorObject :: HasConfigurableBit > ( flags ) , properties , factory -> configurable_string ( ) , SelectBooleanConstant ( IsSetWord32 < PropertyDescriptorObject :: IsConfigurableBit > ( flags ) ) , & bailout ) ; js_descriptor . Bind ( js_desc ) ; Goto ( & return_desc ) ; BIND ( & bailout ) ; CSA_ASSERT ( this , Int32Constant ( 0 ) ) ; Unreachable ( ) ; } BIND ( & return_desc ) ; return js_descriptor . value ( ) ; }
ZonePtrList < Statement > * Parser :: ParseFunction ( const AstRawString * function_name , int pos , FunctionKind kind , FunctionLiteral :: FunctionType function_type , DeclarationScope * function_scope , int * num_parameters , int * function_length , bool * has_duplicate_parameters , int * expected_property_count , int * suspend_count , ZonePtrList < const AstRawString > * arguments_for_wrapped_function , bool * ok ) { ParsingModeScope mode ( this , allow_lazy_ ? PARSE_LAZILY : PARSE_EAGERLY ) ; FunctionState function_state ( & function_state_ , & scope_ , function_scope ) ; bool is_wrapped = function_type == FunctionLiteral :: kWrapped ; DuplicateFinder duplicate_finder ; ExpressionClassifier formals_classifier ( this , & duplicate_finder ) ; int expected_parameters_end_pos = parameters_end_pos_ ; if ( expected_parameters_end_pos != kNoSourcePosition ) { parameters_end_pos_ = kNoSourcePosition ; DCHECK_EQ ( function_name , ast_value_factory ( ) -> empty_string ( ) ) ; } ParserFormalParameters formals ( function_scope ) ; if ( is_wrapped ) { int arguments_length = arguments_for_wrapped_function -> length ( ) ; for ( int i = 0 ; i < arguments_length ; i ++ ) { const bool is_rest = false ; Expression * argument = ExpressionFromIdentifier ( arguments_for_wrapped_function -> at ( i ) , kNoSourcePosition ) ; AddFormalParameter ( & formals , argument , NullExpression ( ) , kNoSourcePosition , is_rest ) ; } DCHECK_EQ ( arguments_length , formals . num_parameters ( ) ) ; DeclareFormalParameters ( formals . scope , formals . params , formals . is_simple ) ; } else { DCHECK_NULL ( arguments_for_wrapped_function ) ; ParseFormalParameterList ( & formals , CHECK_OK ) ; if ( expected_parameters_end_pos != kNoSourcePosition ) { int position = peek_position ( ) ; if ( position < expected_parameters_end_pos ) { ReportMessageAt ( Scanner :: Location ( position , position + 1 ) , MessageTemplate :: kArgStringTerminatesParametersEarly ) ; * ok = false ; return nullptr ; } else if ( position > expected_parameters_end_pos ) { ReportMessageAt ( Scanner :: Location ( expected_parameters_end_pos - 2 , expected_parameters_end_pos ) , MessageTemplate :: kUnexpectedEndOfArgString ) ; * ok = false ; return nullptr ; } } Expect ( Token :: RPAREN , CHECK_OK ) ; int formals_end_position = scanner ( ) -> location ( ) . end_pos ; CheckArityRestrictions ( formals . arity , kind , formals . has_rest , function_scope -> start_position ( ) , formals_end_position , CHECK_OK ) ; Expect ( Token :: LBRACE , CHECK_OK ) ; } * num_parameters = formals . num_parameters ( ) ; * function_length = formals . function_length ; ZonePtrList < Statement > * body = new ( zone ( ) ) ZonePtrList < Statement > ( 8 , zone ( ) ) ; ParseFunctionBody ( body , function_name , pos , formals , kind , function_type , ok ) ; const bool allow_duplicate_parameters = is_sloppy ( function_scope -> language_mode ( ) ) && formals . is_simple && ! IsConciseMethod ( kind ) ; ValidateFormalParameters ( function_scope -> language_mode ( ) , allow_duplicate_parameters , CHECK_OK ) ; RewriteDestructuringAssignments ( ) ; * has_duplicate_parameters = ! classifier ( ) -> is_valid_formal_parameter_list_without_duplicates ( ) ; * expected_property_count = function_state . expected_property_count ( ) ; * suspend_count = function_state . suspend_count ( ) ; return body ; }
XMLHttpRequest :: SendInternal ( const nsAString & aStringBody , JSAutoStructuredCloneBuffer && aBody , nsTArray < nsCOMPtr < nsISupports > > & aClonedObjects , ErrorResult & aRv ) { mWorkerPrivate -> AssertIsOnWorkerThread ( ) ; if ( mProxy -> mOpening ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return ; } bool hasUploadListeners = mUpload ? mUpload -> HasListeners ( ) : false ; MaybePin ( aRv ) ; if ( aRv . Failed ( ) ) { return ; } AutoUnpinXHR autoUnpin ( this ) ; Maybe < AutoSyncLoopHolder > autoSyncLoop ; nsCOMPtr < nsIEventTarget > syncLoopTarget ; bool isSyncXHR = mProxy -> mIsSyncXHR ; if ( isSyncXHR ) { autoSyncLoop . emplace ( mWorkerPrivate ) ; syncLoopTarget = autoSyncLoop -> EventTarget ( ) ; } mProxy -> mOuterChannelId ++ ; JSContext * cx = mWorkerPrivate -> GetJSContext ( ) ; nsRefPtr < SendRunnable > runnable = new SendRunnable ( mWorkerPrivate , mProxy , aStringBody , Move ( aBody ) , aClonedObjects , syncLoopTarget , hasUploadListeners ) ; if ( ! runnable -> Dispatch ( cx ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return ; } if ( ! isSyncXHR ) { autoUnpin . Clear ( ) ; MOZ_ASSERT ( ! autoSyncLoop ) ; return ; } autoUnpin . Clear ( ) ; if ( ! autoSyncLoop -> Run ( ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; } }
NS_IMPL_ISUPPORTS1 ( nsRefreshDriver , nsITimerCallback ) NS_IMETHODIMP nsRefreshDriver :: Notify ( nsITimer * aTimer ) { NS_PRECONDITION ( ! mFrozen , "Why are we notified while frozen?" ) ; NS_PRECONDITION ( mPresContext , "Why are we notified after disconnection?" ) ; if ( mTestControllingRefreshes && aTimer ) { return NS_OK ; } UpdateMostRecentRefresh ( ) ; nsCOMPtr < nsIPresShell > presShell = mPresContext -> GetPresShell ( ) ; if ( ! presShell || ObserverCount ( ) == 0 ) { StopTimer ( ) ; return NS_OK ; } for ( PRUint32 i = 0 ; i < NS_ARRAY_LENGTH ( mObservers ) ; ++ i ) { ObserverArray :: EndLimitedIterator etor ( mObservers [ i ] ) ; while ( etor . HasMore ( ) ) { nsRefPtr < nsARefreshObserver > obs = etor . GetNext ( ) ; obs -> WillRefresh ( mMostRecentRefresh ) ; if ( ! mPresContext || ! mPresContext -> GetPresShell ( ) ) { StopTimer ( ) ; return NS_OK ; } } if ( i == 0 ) { nsTArray < nsCOMPtr < nsIDocument > > targets ; targets . SwapElements ( mBeforePaintTargets ) ; for ( PRUint32 i = 0 ; i < targets . Length ( ) ; ++ i ) { targets [ i ] -> BeforePaintEventFiring ( ) ; } nsIDocument :: AnimationListenerList animationListeners ; for ( PRUint32 i = 0 ; i < mAnimationFrameListenerDocs . Length ( ) ; ++ i ) { mAnimationFrameListenerDocs [ i ] -> TakeAnimationFrameListeners ( animationListeners ) ; } mAnimationFrameListenerDocs . Clear ( ) ; PRInt64 eventTime = mMostRecentRefreshEpochTime / PR_USEC_PER_MSEC ; for ( PRUint32 i = 0 ; i < targets . Length ( ) ; ++ i ) { nsEvent ev ( PR_TRUE , NS_BEFOREPAINT ) ; ev . time = eventTime ; nsEventDispatcher :: Dispatch ( targets [ i ] , nsnull , & ev ) ; } for ( PRUint32 i = 0 ; i < animationListeners . Length ( ) ; ++ i ) { animationListeners [ i ] -> OnBeforePaint ( eventTime ) ; } if ( mPresContext && mPresContext -> GetPresShell ( ) ) { nsAutoTArray < nsIPresShell * , 16 > observers ; observers . AppendElements ( mStyleFlushObservers ) ; for ( PRUint32 j = observers . Length ( ) ; j && mPresContext && mPresContext -> GetPresShell ( ) ; -- j ) { nsIPresShell * shell = observers [ j - 1 ] ; if ( ! mStyleFlushObservers . Contains ( shell ) ) continue ; NS_ADDREF ( shell ) ; mStyleFlushObservers . RemoveElement ( shell ) ; shell -> FrameConstructor ( ) -> mObservingRefreshDriver = PR_FALSE ; shell -> FlushPendingNotifications ( Flush_Style ) ; NS_RELEASE ( shell ) ; } } } else if ( i == 1 ) { if ( mPresContext && mPresContext -> GetPresShell ( ) ) { nsAutoTArray < nsIPresShell * , 16 > observers ; observers . AppendElements ( mLayoutFlushObservers ) ; for ( PRUint32 j = observers . Length ( ) ; j && mPresContext && mPresContext -> GetPresShell ( ) ; -- j ) { nsIPresShell * shell = observers [ j - 1 ] ; if ( ! mLayoutFlushObservers . Contains ( shell ) ) continue ; NS_ADDREF ( shell ) ; mLayoutFlushObservers . RemoveElement ( shell ) ; shell -> mReflowScheduled = PR_FALSE ; shell -> mSuppressInterruptibleReflows = PR_FALSE ; shell -> FlushPendingNotifications ( Flush_InterruptibleLayout ) ; NS_RELEASE ( shell ) ; } } } } if ( mThrottled || ( mTimerIsPrecise != ( GetRefreshTimerType ( ) == nsITimer :: TYPE_REPEATING_PRECISE_CAN_SKIP ) ) ) { StopTimer ( ) ; EnsureTimerStarted ( true ) ; } return NS_OK ; }
int vp9_refining_search_8p_c ( const MACROBLOCK * x , MV * ref_mv , int error_per_bit , int search_range , const vp9_variance_fn_ptr_t * fn_ptr , int * mvjcost , int * mvcost [ 2 ] , const MV * center_mv , const uint8_t * second_pred , int w , int h ) { const MV neighbors [ 8 ] = { { - 1 , 0 } , { 0 , - 1 } , { 0 , 1 } , { 1 , 0 } , { - 1 , - 1 } , { 1 , - 1 } , { - 1 , 1 } , { 1 , 1 } } ; const MACROBLOCKD * const xd = & x -> e_mbd ; const struct buf_2d * const what = & x -> plane [ 0 ] . src ; const struct buf_2d * const in_what = & xd -> plane [ 0 ] . pre [ 0 ] ; const MV fcenter_mv = { center_mv -> row > > 3 , center_mv -> col > > 3 } ; const int * mvjsadcost = x -> nmvjointsadcost ; int * mvsadcost [ 2 ] = { x -> nmvsadcost [ 0 ] , x -> nmvsadcost [ 1 ] } ; unsigned int best_sad = fn_ptr -> sdaf ( what -> buf , what -> stride , get_buf_from_mv ( in_what , ref_mv ) , in_what -> stride , second_pred , 0x7fffffff ) + mvsad_err_cost ( ref_mv , & fcenter_mv , mvjsadcost , mvsadcost , error_per_bit ) ; int i , j ; for ( i = 0 ; i < search_range ; ++ i ) { int best_site = - 1 ; for ( j = 0 ; j < 8 ; ++ j ) { const MV mv = { ref_mv -> row + neighbors [ j ] . row , ref_mv -> col + neighbors [ j ] . col } ; if ( is_mv_in ( x , & mv ) ) { unsigned int sad = fn_ptr -> sdaf ( what -> buf , what -> stride , get_buf_from_mv ( in_what , & mv ) , in_what -> stride , second_pred , best_sad ) ; if ( sad < best_sad ) { sad += mvsad_err_cost ( & mv , & fcenter_mv , mvjsadcost , mvsadcost , error_per_bit ) ; if ( sad < best_sad ) { best_sad = sad ; best_site = j ; } } } } if ( best_site == - 1 ) { break ; } else { ref_mv -> row += neighbors [ best_site ] . row ; ref_mv -> col += neighbors [ best_site ] . col ; } } return best_sad ; }
bool DnsTlsSocket :: initialize ( ) { std :: lock_guard < std :: mutex > guard ( mLock ) ; if ( mSslCtx ) { return false ; } mSslCtx . reset ( SSL_CTX_new ( TLS_method ( ) ) ) ; if ( ! mSslCtx ) { return false ; } if ( SSL_CTX_load_verify_locations ( mSslCtx . get ( ) , nullptr , kCaCertDir ) != 1 ) { ALOGE ( "Failed to load CA cert dir: %s" , kCaCertDir ) ; return false ; } SSL_CTX_set_false_start_allowed_without_alpn ( mSslCtx . get ( ) , 1 ) ; SSL_CTX_set_mode ( mSslCtx . get ( ) , SSL_MODE_ENABLE_FALSE_START ) ; mCache -> prepareSslContext ( mSslCtx . get ( ) ) ; Status status = tcpConnect ( ) ; if ( ! status . ok ( ) ) { return false ; } mSsl = sslConnect ( mSslFd . get ( ) ) ; if ( ! mSsl ) { return false ; } int sv [ 2 ] ; if ( socketpair ( AF_LOCAL , SOCK_SEQPACKET , 0 , sv ) ) { return false ; } mIpcInFd . reset ( sv [ 0 ] ) ; mIpcOutFd . reset ( sv [ 1 ] ) ; mLoopThread . reset ( new std :: thread ( & DnsTlsSocket :: loop , this ) ) ; return true ; }
MaybeHandle < JSPluralRules > JSPluralRules :: InitializePluralRules ( Isolate * isolate , Handle < JSPluralRules > plural_rules , Handle < Object > locales , Handle < Object > options_obj ) { Handle < JSObject > requested_locales ; ASSIGN_RETURN_ON_EXCEPTION ( isolate , requested_locales , Intl :: CanonicalizeLocaleListJS ( isolate , locales ) , JSPluralRules ) ; if ( options_obj -> IsUndefined ( isolate ) ) { options_obj = isolate -> factory ( ) -> NewJSObjectWithNullProto ( ) ; } else { ASSIGN_RETURN_ON_EXCEPTION ( isolate , options_obj , Object :: ToObject ( isolate , options_obj , "Intl.PluralRules" ) , JSPluralRules ) ; } Handle < JSReceiver > options = Handle < JSReceiver > :: cast ( options_obj ) ; std :: vector < const char * > values = { "cardinal" , "ordinal" } ; std :: unique_ptr < char [ ] > type_str = nullptr ; const char * type_cstr = "cardinal" ; Maybe < bool > found = Intl :: GetStringOption ( isolate , options , "type" , values , "Intl.PluralRules" , & type_str ) ; MAYBE_RETURN ( found , MaybeHandle < JSPluralRules > ( ) ) ; if ( found . FromJust ( ) ) { type_cstr = type_str . get ( ) ; } Handle < String > type = isolate -> factory ( ) -> NewStringFromAsciiChecked ( type_cstr ) ; plural_rules -> set_type ( * type ) ; Handle < JSObject > r ; ASSIGN_RETURN_ON_EXCEPTION ( isolate , r , Intl :: ResolveLocale ( isolate , "pluralrules" , requested_locales , options ) , JSPluralRules ) ; Handle < String > locale_str = isolate -> factory ( ) -> locale_string ( ) ; Handle < Object > locale_obj = JSObject :: GetDataProperty ( r , locale_str ) ; CHECK ( locale_obj -> IsString ( ) ) ; Handle < String > locale = Handle < String > :: cast ( locale_obj ) ; plural_rules -> set_locale ( * locale ) ; std :: unique_ptr < icu :: PluralRules > icu_plural_rules ; std :: unique_ptr < icu :: DecimalFormat > icu_decimal_format ; InitializeICUPluralRules ( isolate , locale , type_cstr , & icu_plural_rules , & icu_decimal_format ) ; CHECK_NOT_NULL ( icu_plural_rules . get ( ) ) ; CHECK_NOT_NULL ( icu_decimal_format . get ( ) ) ; Maybe < bool > done = Intl :: SetNumberFormatDigitOptions ( isolate , icu_decimal_format . get ( ) , options , 0 , 3 ) ; MAYBE_RETURN ( done , MaybeHandle < JSPluralRules > ( ) ) ; Handle < Managed < icu :: PluralRules > > managed_plural_rules = Managed < icu :: PluralRules > :: FromUniquePtr ( isolate , 0 , std :: move ( icu_plural_rules ) ) ; plural_rules -> set_icu_plural_rules ( * managed_plural_rules ) ; Handle < Managed < icu :: DecimalFormat > > managed_decimal_format = Managed < icu :: DecimalFormat > :: FromUniquePtr ( isolate , 0 , std :: move ( icu_decimal_format ) ) ; plural_rules -> set_icu_decimal_format ( * managed_decimal_format ) ; return plural_rules ; }
parse_range ( char * str , size_t file_sz , int * nranges ) { static struct range ranges [ MAX_RANGES ] ; int i = 0 ; char * p , * q ; if ( ( p = strchr ( str , '=' ) ) == NULL ) return ( NULL ) ; * p ++ = '\0' ; if ( strcmp ( str , "bytes" ) != 0 ) return ( NULL ) ; while ( ( q = strchr ( p , ',' ) ) != NULL ) { * q ++ = '\0' ; if ( parse_range_spec ( p , file_sz , & ranges [ i ] ) == 0 ) continue ; i ++ ; if ( i == MAX_RANGES ) return ( NULL ) ; p = q ; } if ( parse_range_spec ( p , file_sz , & ranges [ i ] ) != 0 ) i ++ ; * nranges = i ; return ( i ? ranges : NULL ) ; }
void Compute ( OpKernelContext * ctx ) override { const Tensor * inputs ; const Tensor * seq_len ; Tensor * log_prob = nullptr ; OpOutputList decoded_indices ; OpOutputList decoded_values ; OpOutputList decoded_shape ; OP_REQUIRES_OK ( ctx , decode_helper_ . ValidateInputsGenerateOutputs ( ctx , & inputs , & seq_len , & log_prob , & decoded_indices , & decoded_values , & decoded_shape ) ) ; const TensorShape & inputs_shape = inputs -> shape ( ) ; std :: vector < typename TTypes < T > :: UnalignedConstMatrix > input_list_t ; const int64 max_time = inputs_shape . dim_size ( 0 ) ; const int64 batch_size = inputs_shape . dim_size ( 1 ) ; const int64 num_classes_raw = inputs_shape . dim_size ( 2 ) ; OP_REQUIRES ( ctx , FastBoundsCheck ( num_classes_raw , std :: numeric_limits < int > :: max ( ) ) , errors :: InvalidArgument ( "num_classes cannot exceed max int" ) ) ; const int num_classes = static_cast < const int > ( num_classes_raw ) ; auto inputs_t = inputs -> tensor < T , 3 > ( ) ; input_list_t . reserve ( max_time ) ; for ( std :: size_t t = 0 ; t < max_time ; ++ t ) { input_list_t . emplace_back ( inputs_t . data ( ) + t * batch_size * num_classes , batch_size , num_classes ) ; } auto seq_len_t = seq_len -> vec < int32 > ( ) ; auto log_prob_t = log_prob -> matrix < T > ( ) ; log_prob_t . setZero ( ) ; int blank_index = num_classes - 1 ; std :: vector < std :: vector < std :: vector < int > > > sequences ( batch_size ) ; auto decode = [ & ] ( const int64 begin , const int64 end ) { for ( int b = begin ; b < end ; ++ b ) { sequences [ b ] . resize ( 1 ) ; auto & sequence = sequences [ b ] [ 0 ] ; int prev_indices = - 1 ; for ( int t = 0 ; t < seq_len_t ( b ) ; ++ t ) { int max_class_indices ; log_prob_t ( b , 0 ) += - RowMax < T > ( input_list_t [ t ] , b , & max_class_indices ) ; if ( max_class_indices != blank_index && ! ( merge_repeated_ && max_class_indices == prev_indices ) ) { sequence . push_back ( max_class_indices ) ; } prev_indices = max_class_indices ; } } } ; const int64 kCostPerUnit = 50 * max_time * num_classes ; const int64 total = batch_size ; const DeviceBase :: CpuWorkerThreads & worker_threads = * ctx -> device ( ) -> tensorflow_cpu_worker_threads ( ) ; Shard ( worker_threads . num_threads , worker_threads . workers , total , kCostPerUnit , decode ) ; OP_REQUIRES_OK ( ctx , decode_helper_ . StoreAllDecodedSequences ( sequences , & decoded_indices , & decoded_values , & decoded_shape ) ) ; }
NS_IMPL_CYCLE_COLLECTION ( L10nReadyHandler , mPromise , mDocumentL10n ) NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION ( L10nReadyHandler ) NS_INTERFACE_MAP_ENTRY ( nsISupports ) NS_INTERFACE_MAP_END NS_IMPL_CYCLE_COLLECTING_ADDREF ( L10nReadyHandler ) NS_IMPL_CYCLE_COLLECTING_RELEASE ( L10nReadyHandler ) void DocumentL10n :: TriggerInitialTranslation ( ) { if ( mState >= DocumentL10nState :: InitialTranslationTriggered ) { return ; } if ( ! mReady ) { InitialTranslationCompleted ( false ) ; return ; } mInitialTranslationStart = mozilla :: TimeStamp :: Now ( ) ; AutoAllowLegacyScriptExecution exemption ; nsTArray < RefPtr < Promise > > promises ; ErrorResult rv ; promises . AppendElement ( TranslateDocument ( rv ) ) ; if ( NS_WARN_IF ( rv . Failed ( ) ) ) { InitialTranslationCompleted ( false ) ; mReady -> MaybeRejectWithUndefined ( ) ; return ; } promises . AppendElement ( TranslateRoots ( rv ) ) ; Element * documentElement = mDocument -> GetDocumentElement ( ) ; if ( ! documentElement ) { InitialTranslationCompleted ( false ) ; mReady -> MaybeRejectWithUndefined ( ) ; return ; } DOMLocalization :: ConnectRoot ( * documentElement , rv ) ; if ( NS_WARN_IF ( rv . Failed ( ) ) ) { InitialTranslationCompleted ( false ) ; mReady -> MaybeRejectWithUndefined ( ) ; return ; } AutoEntryScript aes ( mGlobal , "DocumentL10n InitialTranslation" ) ; RefPtr < Promise > promise = Promise :: All ( aes . cx ( ) , promises , rv ) ; if ( promise -> State ( ) == Promise :: PromiseState :: Resolved ) { InitialTranslationCompleted ( true ) ; mReady -> MaybeResolveWithUndefined ( ) ; } else { RefPtr < PromiseNativeHandler > l10nReadyHandler = new L10nReadyHandler ( mReady , this ) ; promise -> AppendNativeHandler ( l10nReadyHandler ) ; mState = DocumentL10nState :: InitialTranslationTriggered ; } }
png_handle_iCCP ( png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) { png_const_charp errmsg = NULL ; int finished = 0 ; png_debug ( 1 , "in png_handle_iCCP" ) ; if ( ! ( png_ptr -> mode & PNG_HAVE_IHDR ) ) png_chunk_error ( png_ptr , "missing IHDR" ) ; else if ( png_ptr -> mode & ( PNG_HAVE_IDAT | PNG_HAVE_PLTE ) ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "out of place" ) ; return ; } if ( length < 9 ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "too short" ) ; return ; } if ( png_ptr -> colorspace . flags & PNG_COLORSPACE_INVALID ) { png_crc_finish ( png_ptr , length ) ; return ; } if ( ( png_ptr -> colorspace . flags & PNG_COLORSPACE_HAVE_INTENT ) == 0 ) { uInt read_length , keyword_length ; char keyword [ 81 ] ; read_length = 81 ; if ( read_length > length ) read_length = ( uInt ) length ; png_crc_read ( png_ptr , ( png_bytep ) keyword , read_length ) ; length -= read_length ; keyword_length = 0 ; while ( keyword_length < 80 && keyword_length < read_length && keyword [ keyword_length ] != 0 ) ++ keyword_length ; if ( keyword_length >= 1 && keyword_length <= 79 ) { if ( keyword_length + 1 < read_length && keyword [ keyword_length + 1 ] == PNG_COMPRESSION_TYPE_BASE ) { read_length -= keyword_length + 2 ; if ( png_inflate_claim ( png_ptr , png_iCCP ) == Z_OK ) { Byte profile_header [ 132 ] ; Byte local_buffer [ PNG_INFLATE_BUF_SIZE ] ; png_alloc_size_t size = ( sizeof profile_header ) ; png_ptr -> zstream . next_in = ( Bytef * ) keyword + ( keyword_length + 2 ) ; png_ptr -> zstream . avail_in = read_length ; ( void ) png_inflate_read ( png_ptr , local_buffer , ( sizeof local_buffer ) , & length , profile_header , & size , 0 ) ; if ( size == 0 ) { const png_uint_32 profile_length = png_get_uint_32 ( profile_header ) ; if ( png_icc_check_length ( png_ptr , & png_ptr -> colorspace , keyword , profile_length ) ) { if ( png_icc_check_header ( png_ptr , & png_ptr -> colorspace , keyword , profile_length , profile_header , png_ptr -> color_type ) ) { const png_uint_32 tag_count = png_get_uint_32 ( profile_header + 128 ) ; png_bytep profile = png_read_buffer ( png_ptr , profile_length , 2 ) ; if ( profile != NULL ) { memcpy ( profile , profile_header , ( sizeof profile_header ) ) ; size = 12 * tag_count ; ( void ) png_inflate_read ( png_ptr , local_buffer , ( sizeof local_buffer ) , & length , profile + ( sizeof profile_header ) , & size , 0 ) ; if ( size == 0 ) { if ( png_icc_check_tag_table ( png_ptr , & png_ptr -> colorspace , keyword , profile_length , profile ) ) { size = profile_length - ( sizeof profile_header ) - 12 * tag_count ; ( void ) png_inflate_read ( png_ptr , local_buffer , ( sizeof local_buffer ) , & length , profile + ( sizeof profile_header ) + 12 * tag_count , & size , 1 ) ; if ( length > 0 && ! ( png_ptr -> flags & PNG_FLAG_BENIGN_ERRORS_WARN ) ) errmsg = "extra compressed data" ; else if ( size == 0 ) { if ( length > 0 ) { png_chunk_warning ( png_ptr , "extra compressed data" ) ; } png_crc_finish ( png_ptr , length ) ; finished = 1 ; #                                   ifdef PNG_sRGB_SUPPORTED png_icc_set_sRGB ( png_ptr , & png_ptr -> colorspace , profile , png_ptr -> zstream . adler ) ; #                                   endif if ( info_ptr != NULL ) { png_free_data ( png_ptr , info_ptr , PNG_FREE_ICCP , 0 ) ; info_ptr -> iccp_name = png_voidcast ( char * , png_malloc_base ( png_ptr , keyword_length + 1 ) ) ; if ( info_ptr -> iccp_name != NULL ) { memcpy ( info_ptr -> iccp_name , keyword , keyword_length + 1 ) ; info_ptr -> iccp_proflen = profile_length ; info_ptr -> iccp_profile = profile ; png_ptr -> read_buffer = NULL ; info_ptr -> free_me |= PNG_FREE_ICCP ; info_ptr -> valid |= PNG_INFO_iCCP ; } else { png_ptr -> colorspace . flags |= PNG_COLORSPACE_INVALID ; errmsg = "out of memory" ; } } if ( info_ptr != NULL ) png_colorspace_sync ( png_ptr , info_ptr ) ; if ( errmsg == NULL ) { png_ptr -> zowner = 0 ; return ; } } else if ( size > 0 ) errmsg = "truncated" ; else errmsg = png_ptr -> zstream . msg ; } } else errmsg = png_ptr -> zstream . msg ; } else errmsg = "out of memory" ; } } } else errmsg = png_ptr -> zstream . msg ; png_ptr -> zowner = 0 ; } else errmsg = png_ptr -> zstream . msg ; } else errmsg = "bad compression method" ; } else errmsg = "bad keyword" ; } else errmsg = "too many profiles" ; if ( ! finished ) png_crc_finish ( png_ptr , length ) ; png_ptr -> colorspace . flags |= PNG_COLORSPACE_INVALID ; png_colorspace_sync ( png_ptr , info_ptr ) ; if ( errmsg != NULL ) png_chunk_benign_error ( png_ptr , errmsg ) ; }
static jlong android_util_MemoryIntArray_open ( JNIEnv * env , jobject clazz , jint fd , jboolean owner , jboolean writable ) { if ( fd < 0 ) { jniThrowException ( env , "java/io/IOException" , "bad file descriptor" ) ; return - 1 ; } int ashmemSize = ashmem_get_size_region ( fd ) ; if ( ashmemSize <= 0 ) { jniThrowException ( env , "java/io/IOException" , "bad ashmem size" ) ; return - 1 ; } int protMode = ( owner || writable ) ? ( PROT_READ | PROT_WRITE ) : PROT_READ ; void * ashmemAddr = mmap ( NULL , ashmemSize , protMode , MAP_SHARED , fd , 0 ) ; if ( ashmemAddr == MAP_FAILED ) { jniThrowException ( env , "java/io/IOException" , "cannot mmap ashmem" ) ; return - 1 ; } if ( owner ) { int size = ashmemSize / sizeof ( std :: atomic_int ) ; new ( ashmemAddr ) std :: atomic_int [ size ] ; } if ( owner && ! writable ) { int setProtResult = ashmem_set_prot_region ( fd , PROT_READ ) ; if ( setProtResult < 0 ) { jniThrowException ( env , "java/io/IOException" , "cannot set ashmem prot mode" ) ; return - 1 ; } } return reinterpret_cast < jlong > ( ashmemAddr ) ; }
ServerSecurityFeature :: ServerSecurityFeature ( application_features :: ApplicationServer & server ) : ApplicationFeature ( server , "ServerSecurity" ) , _enableFoxxApi ( true ) , _enableFoxxStore ( true ) , _hardenedRestApi ( false ) { setOptional ( false ) ; startsAfter < application_features :: GreetingsFeaturePhase > ( ) ; }
httpClearFields ( http_t * http ) { DEBUG_printf ( ( "httpClearFields(http=%p)" , ( void * ) http ) ) ; if ( http ) { memset ( http -> fields , 0 , sizeof ( http -> fields ) ) ; if ( http -> mode == _HTTP_MODE_CLIENT ) { if ( http -> hostname [ 0 ] == '/' ) httpSetField ( http , HTTP_FIELD_HOST , "localhost" ) ; else httpSetField ( http , HTTP_FIELD_HOST , http -> hostname ) ; } if ( http -> field_authorization ) { free ( http -> field_authorization ) ; http -> field_authorization = NULL ; } if ( http -> accept_encoding ) { _cupsStrFree ( http -> accept_encoding ) ; http -> accept_encoding = NULL ; } if ( http -> allow ) { _cupsStrFree ( http -> allow ) ; http -> allow = NULL ; } if ( http -> server ) { _cupsStrFree ( http -> server ) ; http -> server = NULL ; } http -> expect = ( http_status_t ) 0 ; } }
bool Track :: VetEntry ( const BlockEntry * pBlockEntry ) const { assert ( pBlockEntry ) ; const Block * const pBlock = pBlockEntry -> GetBlock ( ) ; assert ( pBlock ) ; assert ( pBlock -> GetTrackNumber ( ) == m_info . number ) ; if ( ! pBlock || pBlock -> GetTrackNumber ( ) != m_info . number ) return false ; return true ; }
png_handle_gAMA ( png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) { png_fixed_point igamma ; png_byte buf [ 4 ] ; png_debug ( 1 , "in png_handle_gAMA" ) ; if ( ! ( png_ptr -> mode & PNG_HAVE_IHDR ) ) png_chunk_error ( png_ptr , "missing IHDR" ) ; else if ( png_ptr -> mode & ( PNG_HAVE_IDAT | PNG_HAVE_PLTE ) ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "out of place" ) ; return ; } if ( length != 4 ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "invalid" ) ; return ; } png_crc_read ( png_ptr , buf , 4 ) ; if ( png_crc_finish ( png_ptr , 0 ) ) return ; igamma = png_get_fixed_point ( NULL , buf ) ; png_colorspace_set_gamma ( png_ptr , & png_ptr -> colorspace , igamma ) ; png_colorspace_sync ( png_ptr , info_ptr ) ; }
void Logger :: addMessage ( const QString & message , const Log :: MsgType & type ) { QWriteLocker locker ( & lock ) ; Log :: Msg temp = { msgCounter ++ , QDateTime :: currentMSecsSinceEpoch ( ) , type , message } ; m_messages . push_back ( temp ) ; if ( m_messages . size ( ) >= MAX_LOG_MESSAGES ) m_messages . pop_front ( ) ; emit newLogMessage ( temp ) ; }
void NuPlayer2 :: CCDecoder :: display ( int64_t timeUs ) { if ( ! isSelected ( ) ) { return ; } ssize_t index = mCCMap . indexOfKey ( timeUs ) ; if ( index < 0 ) { ALOGV ( "cc for timestamp %" PRId64 " not found" , timeUs ) ; return ; } sp < ABuffer > ccBuf ; if ( index == 0 ) { ccBuf = mCCMap . valueAt ( index ) ; } else { size_t size = 0 ; for ( ssize_t i = 0 ; i <= index ; ++ i ) { size += mCCMap . valueAt ( i ) -> size ( ) ; } ccBuf = new ABuffer ( size ) ; ccBuf -> setRange ( 0 , 0 ) ; for ( ssize_t i = 0 ; i <= index ; ++ i ) { sp < ABuffer > buf = mCCMap . valueAt ( i ) ; memcpy ( ccBuf -> data ( ) + ccBuf -> size ( ) , buf -> data ( ) , buf -> size ( ) ) ; ccBuf -> setRange ( 0 , ccBuf -> size ( ) + buf -> size ( ) ) ; } } if ( ccBuf -> size ( ) > 0 ) { #if 0 dumpBytePair ( ccBuf ) ; #endif ccBuf -> meta ( ) -> setInt32 ( AMEDIAFORMAT_KEY_TRACK_INDEX , mSelectedTrack ) ; ccBuf -> meta ( ) -> setInt64 ( "timeUs" , timeUs ) ; ccBuf -> meta ( ) -> setInt64 ( "durationUs" , 0ll ) ; sp < AMessage > msg = mNotify -> dup ( ) ; msg -> setInt32 ( "what" , kWhatClosedCaptionData ) ; msg -> setBuffer ( "buffer" , ccBuf ) ; msg -> post ( ) ; } mCCMap . removeItemsAt ( 0 , index + 1 ) ; }
js :: RunScript ( JSContext * cx , JSScript * script , StackFrame * fp ) { JS_ASSERT ( script ) ; JS_ASSERT ( fp == cx -> fp ( ) ) ; JS_ASSERT ( fp -> script ( ) == script ) ; #ifdef JS_METHODJIT_SPEW JMCheckLogging ( ) ; #endif if ( script -> compileAndGo ) { if ( fp -> scopeChain ( ) . global ( ) . isCleared ( ) ) { JS_ReportErrorNumber ( cx , js_GetErrorMessage , NULL , JSMSG_CLEARED_SCOPE ) ; return false ; } } #ifdef DEBUG struct CheckStackBalance { JSContext * cx ; StackFrame * fp ; JSObject * enumerators ; CheckStackBalance ( JSContext * cx ) : cx ( cx ) , fp ( cx -> fp ( ) ) , enumerators ( cx -> enumerators ) { } ~ CheckStackBalance ( ) { JS_ASSERT ( fp == cx -> fp ( ) ) ; JS_ASSERT_IF ( ! fp -> isGeneratorFrame ( ) , enumerators == cx -> enumerators ) ; } } check ( cx ) ; #endif #ifdef JS_METHODJIT mjit :: CompileStatus status ; status = mjit :: CanMethodJIT ( cx , script , script -> code , fp -> isConstructing ( ) , mjit :: CompileRequest_Interpreter ) ; if ( status == mjit :: Compile_Error ) return false ; if ( status == mjit :: Compile_Okay ) return mjit :: JaegerShot ( cx , false ) ; #endif return Interpret ( cx , fp ) ; }
adjust_skipcol ( void ) { if ( ! curwin -> w_p_wrap || ! curwin -> w_p_sms || curwin -> w_cursor . lnum != curwin -> w_topline ) return ; int width1 = curwin -> w_width - curwin_col_off ( ) ; int width2 = width1 + curwin_col_off2 ( ) ; long so = get_scrolloff_value ( ) ; int scrolloff_cols = so == 0 ? 0 : width1 + ( so - 1 ) * width2 ; int scrolled = FALSE ; validate_cheight ( ) ; if ( curwin -> w_cline_height == curwin -> w_height && plines_win ( curwin , curwin -> w_cursor . lnum , FALSE ) <= curwin -> w_height ) { reset_skipcol ( ) ; return ; } validate_virtcol ( ) ; while ( curwin -> w_skipcol > 0 && curwin -> w_virtcol < curwin -> w_skipcol + 3 + scrolloff_cols ) { if ( curwin -> w_skipcol >= width1 + width2 ) curwin -> w_skipcol -= width2 ; else curwin -> w_skipcol -= width1 ; redraw_later ( UPD_NOT_VALID ) ; scrolled = TRUE ; validate_virtcol ( ) ; } if ( scrolled ) return ; int col = curwin -> w_virtcol - curwin -> w_skipcol + scrolloff_cols ; int row = 0 ; if ( col >= width1 ) { col -= width1 ; ++ row ; } if ( col > width2 ) { row += col / width2 ; col = col % width2 ; } if ( row >= curwin -> w_height ) { if ( curwin -> w_skipcol == 0 ) { curwin -> w_skipcol += width1 ; -- row ; } if ( row >= curwin -> w_height ) curwin -> w_skipcol += ( row - curwin -> w_height ) * width2 ; redraw_later ( UPD_NOT_VALID ) ; } }
RUNTIME_FUNCTION ( Runtime_AtomicsAnd ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 3 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSTypedArray , sta , 0 ) ; CONVERT_SIZE_ARG_CHECKED ( index , 1 ) ; CONVERT_NUMBER_ARG_HANDLE_CHECKED ( value , 2 ) ; CHECK ( sta -> GetBuffer ( ) -> is_shared ( ) ) ; CHECK_LT ( index , NumberToSize ( sta -> length ( ) ) ) ; uint8_t * source = static_cast < uint8_t * > ( sta -> GetBuffer ( ) -> backing_store ( ) ) + NumberToSize ( sta -> byte_offset ( ) ) ; switch ( sta -> type ( ) ) { #define TYPED_ARRAY_CASE(Type, typeName, TYPE, ctype) \  case kExternal##Type##Array:                        \  return DoAnd<ctype>(isolate, source, index, value); INTEGER_TYPED_ARRAYS ( TYPED_ARRAY_CASE ) #undef TYPED_ARRAY_CASE default : break ; } UNREACHABLE ( ) ; }
nsInlineFrame :: DrainSelfOverflowListInternal ( DrainFlags aFlags , nsIFrame * aLineContainer ) { AutoFrameListPtr overflowFrames ( PresContext ( ) , StealOverflowFrames ( ) ) ; if ( overflowFrames ) { NS_ASSERTION ( mFrames . NotEmpty ( ) , "overflow list w/o frames" ) ; if ( ! ( aFlags & eDontReparentFrames ) ) { nsIFrame * firstChild = overflowFrames -> FirstChild ( ) ; if ( aLineContainer && aLineContainer -> GetPrevContinuation ( ) ) { ReparentFloatsForInlineChild ( aLineContainer , firstChild , true ) ; } const bool doReparentSC = ( aFlags & eInFirstLine ) && ! ( aFlags & eForDestroy ) ; RestyleManager * restyleManager = PresContext ( ) -> RestyleManager ( ) ; for ( nsIFrame * f = firstChild ; f ; f = f -> GetNextSibling ( ) ) { f -> SetParent ( this ) ; if ( doReparentSC ) { restyleManager -> ReparentStyleContext ( f ) ; nsLayoutUtils :: MarkDescendantsDirty ( f ) ; } } } bool result = ! overflowFrames -> IsEmpty ( ) ; mFrames . AppendFrames ( nullptr , * overflowFrames ) ; return result ; } return false ; }
Handle < FixedArrayBase > Factory :: NewFixedDoubleArrayWithHoles ( int length , PretenureFlag pretenure ) { DCHECK_LE ( 0 , length ) ; Handle < FixedArrayBase > array = NewFixedDoubleArray ( length , pretenure ) ; if ( length > 0 ) { Handle < FixedDoubleArray > :: cast ( array ) -> FillWithHoles ( 0 , length ) ; } return array ; }
long Cluster :: CreateBlockGroup ( long long start_offset , long long size , long long discard_padding ) { assert ( m_entries ) ; assert ( m_entries_size > 0 ) ; assert ( m_entries_count >= 0 ) ; assert ( m_entries_count < m_entries_size ) ; IMkvReader * const pReader = m_pSegment -> m_pReader ; long long pos = start_offset ; const long long stop = start_offset + size ; long long prev = 1 ; long long next = 0 ; long long duration = - 1 ; long long bpos = - 1 ; long long bsize = - 1 ; while ( pos < stop ) { long len ; const long long id = ReadUInt ( pReader , pos , len ) ; assert ( id >= 0 ) ; assert ( ( pos + len ) <= stop ) ; pos += len ; const long long size = ReadUInt ( pReader , pos , len ) ; assert ( size >= 0 ) ; assert ( ( pos + len ) <= stop ) ; pos += len ; if ( id == 0x21 ) { if ( bpos < 0 ) { bpos = pos ; bsize = size ; } } else if ( id == 0x1B ) { assert ( size <= 8 ) ; duration = UnserializeUInt ( pReader , pos , size ) ; assert ( duration >= 0 ) ; } else if ( id == 0x7B ) { assert ( size <= 8 ) ; const long size_ = static_cast < long > ( size ) ; long long time ; long status = UnserializeInt ( pReader , pos , size_ , time ) ; assert ( status == 0 ) ; if ( status != 0 ) return - 1 ; if ( time <= 0 ) prev = time ; else next = time ; } pos += size ; assert ( pos <= stop ) ; } assert ( pos == stop ) ; assert ( bpos >= 0 ) ; assert ( bsize >= 0 ) ; const long idx = m_entries_count ; BlockEntry * * const ppEntry = m_entries + idx ; BlockEntry * & pEntry = * ppEntry ; pEntry = new ( std :: nothrow ) BlockGroup ( this , idx , bpos , bsize , prev , next , duration , discard_padding ) ; if ( pEntry == NULL ) return - 1 ; BlockGroup * const p = static_cast < BlockGroup * > ( pEntry ) ; const long status = p -> Parse ( ) ; if ( status == 0 ) { ++ m_entries_count ; return 0 ; } delete pEntry ; pEntry = 0 ; return status ; }
static int idprime_get_token_name ( sc_card_t * card , char * * tname ) { idprime_private_data_t * priv = card -> drv_data ; sc_path_t tinfo_path = { "\x00\x00" , 2 , 0 , 0 , SC_PATH_TYPE_PATH , { "" , 0 } } ; sc_file_t * file = NULL ; u8 buf [ 2 ] ; int r ; LOG_FUNC_CALLED ( card -> ctx ) ; if ( tname == NULL ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_INVALID_ARGUMENTS ) ; } if ( ! priv -> tinfo_present ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_NOT_SUPPORTED ) ; } memcpy ( tinfo_path . value , priv -> tinfo_df , 2 ) ; r = iso_ops -> select_file ( card , & tinfo_path , & file ) ; if ( r != SC_SUCCESS || file -> size == 0 ) { sc_file_free ( file ) ; LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_NOT_SUPPORTED ) ; } r = iso_ops -> read_binary ( card , 0 , buf , 2 , 0 ) ; if ( r < 2 || buf [ 1 ] > file -> size ) { sc_file_free ( file ) ; LOG_FUNC_RETURN ( card -> ctx , r ) ; } sc_file_free ( file ) ; * tname = malloc ( buf [ 1 ] ) ; if ( * tname == NULL ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; } r = iso_ops -> read_binary ( card , 2 , ( unsigned char * ) * tname , buf [ 1 ] , 0 ) ; if ( r < 1 ) { free ( * tname ) ; LOG_FUNC_RETURN ( card -> ctx , r ) ; } if ( ( * tname ) [ r - 1 ] != '\0' ) { ( * tname ) [ r - 1 ] = '\0' ; } LOG_FUNC_RETURN ( card -> ctx , SC_SUCCESS ) ; }
xmlErrValidNode ( xmlValidCtxtPtr ctxt , xmlNodePtr node , xmlParserErrors error , const char * msg , const xmlChar * str1 , const xmlChar * str2 , const xmlChar * str3 ) { xmlStructuredErrorFunc schannel = NULL ; xmlGenericErrorFunc channel = NULL ; xmlParserCtxtPtr pctxt = NULL ; void * data = NULL ; if ( ctxt != NULL ) { channel = ctxt -> error ; data = ctxt -> userData ; if ( ( ctxt -> finishDtd == XML_CTXT_FINISH_DTD_0 ) || ( ctxt -> finishDtd == XML_CTXT_FINISH_DTD_1 ) ) { long delta = ( char * ) ctxt - ( char * ) ctxt -> userData ; if ( ( delta > 0 ) && ( delta < 250 ) ) pctxt = ctxt -> userData ; } } __xmlRaiseError ( schannel , channel , data , pctxt , node , XML_FROM_VALID , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str1 , ( const char * ) str3 , 0 , 0 , msg , str1 , str2 , str3 ) ; }
void GrowMemory ( FullDecoder * decoder , const Value & value , Value * result_val ) { LiftoffRegList pinned ; LiftoffRegister input = pinned . set ( __ PopToRegister ( ) ) ; __ SpillAllRegisters ( ) ; constexpr Register kGpReturnReg = kGpReturnRegisters [ 0 ] ; static_assert ( kLiftoffAssemblerGpCacheRegs & Register :: bit < kGpReturnReg > ( ) , "first return register is a cache register (needs more " "complex code here otherwise)" ) ; LiftoffRegister result = pinned . set ( LiftoffRegister ( kGpReturnReg ) ) ; WasmGrowMemoryDescriptor descriptor ; DCHECK_EQ ( 0 , descriptor . GetStackParameterCount ( ) ) ; DCHECK_EQ ( 1 , descriptor . GetRegisterParameterCount ( ) ) ; DCHECK_EQ ( ValueTypes :: MachineTypeFor ( kWasmI32 ) , descriptor . GetParameterType ( 0 ) ) ; Register param_reg = descriptor . GetRegisterParameter ( 0 ) ; if ( input . gp ( ) != param_reg ) __ Move ( param_reg , input . gp ( ) , kWasmI32 ) ; __ CallRuntimeStub ( WasmCode :: kWasmGrowMemory ) ; safepoint_table_builder_ . DefineSafepoint ( & asm_ , Safepoint :: kSimple , 0 , Safepoint :: kNoLazyDeopt ) ; if ( kReturnRegister0 != result . gp ( ) ) { __ Move ( result . gp ( ) , kReturnRegister0 , kWasmI32 ) ; } __ PushRegister ( kWasmI32 , result ) ; }
IGNITION_HANDLER ( ForInEnumerate , InterpreterAssembler ) { Node * receiver = LoadRegisterAtOperandIndex ( 0 ) ; Node * context = GetContext ( ) ; Label if_empty ( this ) , if_runtime ( this , Label :: kDeferred ) ; Node * receiver_map = CheckEnumCache ( receiver , & if_empty , & if_runtime ) ; SetAccumulator ( receiver_map ) ; Dispatch ( ) ; BIND ( & if_empty ) ; { Node * result = EmptyFixedArrayConstant ( ) ; SetAccumulator ( result ) ; Dispatch ( ) ; } BIND ( & if_runtime ) ; { Node * result = CallRuntime ( Runtime :: kForInEnumerate , context , receiver ) ; SetAccumulator ( result ) ; Dispatch ( ) ; } }
static u_int16_t concat_hash_string ( struct ndpi_packet_struct * packet , char * buf , u_int8_t client_hash ) { u_int16_t offset = 22 , buf_out_len = 0 ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; u_int32_t len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( buf , ( const char * ) & packet -> payload [ offset ] , buf_out_len = len ) ; buf [ buf_out_len ++ ] = ';' ; offset += len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else offset += 4 + len ; #ifdef SSH_DEBUG printf ( "[SSH] %s\n" , buf ) ; #endif return ( buf_out_len ) ; invalid_payload : #ifdef SSH_DEBUG printf ( "[SSH] Invalid packet payload\n" ) ; #endif return ( 0 ) ; }
static void extend_plane ( uint8_t * const src , int src_stride , int width , int height , int extend_top , int extend_left , int extend_bottom , int extend_right ) { int i , j ; uint8_t * left_src , * right_src ; uint8_t * left_dst_start , * right_dst_start ; uint8_t * left_dst , * right_dst ; uint8_t * top_src , * bot_src ; uint8_t * top_dst , * bot_dst ; uint32_t left_pix ; uint32_t right_pix ; uint32_t linesize ; left_src = src ; right_src = src + width - 1 ; left_dst_start = src - extend_left ; right_dst_start = src + width ; for ( i = height ; i -- ; ) { left_dst = left_dst_start ; right_dst = right_dst_start ; __asm__ __volatile__ ( "lb        %[left_pix],     0(%[left_src])      \n\t" "lb        %[right_pix],    0(%[right_src])     \n\t" "replv.qb  %[left_pix],     %[left_pix]         \n\t" "replv.qb  %[right_pix],    %[right_pix]        \n\t" : [ left_pix ] "=&r" ( left_pix ) , [ right_pix ] "=&r" ( right_pix ) : [ left_src ] "r" ( left_src ) , [ right_src ] "r" ( right_src ) ) ; for ( j = extend_left / 4 ; j -- ; ) { __asm__ __volatile__ ( "sw     %[left_pix],    0(%[left_dst])     \n\t" "sw     %[right_pix],   0(%[right_dst])    \n\t" : : [ left_dst ] "r" ( left_dst ) , [ left_pix ] "r" ( left_pix ) , [ right_dst ] "r" ( right_dst ) , [ right_pix ] "r" ( right_pix ) ) ; left_dst += 4 ; right_dst += 4 ; } for ( j = extend_left % 4 ; j -- ; ) { __asm__ __volatile__ ( "sb     %[left_pix],    0(%[left_dst])     \n\t" "sb     %[right_pix],   0(%[right_dst])     \n\t" : : [ left_dst ] "r" ( left_dst ) , [ left_pix ] "r" ( left_pix ) , [ right_dst ] "r" ( right_dst ) , [ right_pix ] "r" ( right_pix ) ) ; left_dst += 1 ; right_dst += 1 ; } left_src += src_stride ; right_src += src_stride ; left_dst_start += src_stride ; right_dst_start += src_stride ; } top_src = src - extend_left ; bot_src = src + src_stride * ( height - 1 ) - extend_left ; top_dst = src + src_stride * ( - extend_top ) - extend_left ; bot_dst = src + src_stride * ( height ) - extend_left ; linesize = extend_left + extend_right + width ; for ( i = 0 ; i < extend_top ; i ++ ) { vpx_memcpy ( top_dst , top_src , linesize ) ; top_dst += src_stride ; } for ( i = 0 ; i < extend_bottom ; i ++ ) { vpx_memcpy ( bot_dst , bot_src , linesize ) ; bot_dst += src_stride ; } }
% o exception : return any errors or warnings in this structure . % * / MagickExport Image * ComplexImages ( const Image * images , const ComplexOperator op , ExceptionInfo * exception ) { #define ComplexImageTag  "Complex/Image" CacheView * Ai_view , * Ar_view , * Bi_view , * Br_view , * Ci_view , * Cr_view ; const char * artifact ; const Image * Ai_image , * Ar_image , * Bi_image , * Br_image ; double snr ; Image * Ci_image , * complex_images , * Cr_image , * image ; MagickBooleanType status ; MagickOffsetType progress ; ssize_t y ; assert ( images != ( Image * ) NULL ) ; assert ( images -> signature == MagickCoreSignature ) ; if ( images -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , images -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; if ( images -> next == ( Image * ) NULL ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , ImageError , "ImageSequenceRequired" , "`%s'" , images -> filename ) ; return ( ( Image * ) NULL ) ; } image = CloneImage ( images , 0 , 0 , MagickTrue , exception ) ; if ( image == ( Image * ) NULL ) return ( ( Image * ) NULL ) ; if ( SetImageStorageClass ( image , DirectClass , exception ) == MagickFalse ) { image = DestroyImageList ( image ) ; return ( image ) ; } image -> depth = 32UL ; complex_images = NewImageList ( ) ; AppendImageToList ( & complex_images , image ) ; image = CloneImage ( images , 0 , 0 , MagickTrue , exception ) ; if ( image == ( Image * ) NULL ) { complex_images = DestroyImageList ( complex_images ) ; return ( complex_images ) ; } AppendImageToList ( & complex_images , image ) ; artifact = GetImageArtifact ( image , "complex:snr" ) ; snr = 0.0 ; if ( artifact != ( const char * ) NULL ) snr = StringToDouble ( artifact , ( char * * ) NULL ) ; Ar_image = images ; Ai_image = images -> next ; Br_image = images ; Bi_image = images -> next ; if ( ( images -> next -> next != ( Image * ) NULL ) && ( images -> next -> next -> next != ( Image * ) NULL ) ) { Br_image = images -> next -> next ; Bi_image = images -> next -> next -> next ; } Cr_image = complex_images ; Ci_image = complex_images -> next ; Ar_view = AcquireVirtualCacheView ( Ar_image , exception ) ; Ai_view = AcquireVirtualCacheView ( Ai_image , exception ) ; Br_view = AcquireVirtualCacheView ( Br_image , exception ) ; Bi_view = AcquireVirtualCacheView ( Bi_image , exception ) ; Cr_view = AcquireAuthenticCacheView ( Cr_image , exception ) ; Ci_view = AcquireAuthenticCacheView ( Ci_image , exception ) ; status = MagickTrue ; progress = 0 ; #if defined(MAGICKCORE_OPENMP_SUPPORT) #pragma omp parallel for schedule(static) shared(progress,status) \     magick_number_threads(images,complex_images,images->rows,1L) #endif for ( y = 0 ; y < ( ssize_t ) images -> rows ; y ++ ) { register const Quantum * magick_restrict Ai , * magick_restrict Ar , * magick_restrict Bi , * magick_restrict Br ; register Quantum * magick_restrict Ci , * magick_restrict Cr ; register ssize_t x ; if ( status == MagickFalse ) continue ; Ar = GetCacheViewVirtualPixels ( Ar_view , 0 , y , Ar_image -> columns , 1 , exception ) ; Ai = GetCacheViewVirtualPixels ( Ai_view , 0 , y , Ai_image -> columns , 1 , exception ) ; Br = GetCacheViewVirtualPixels ( Br_view , 0 , y , Br_image -> columns , 1 , exception ) ; Bi = GetCacheViewVirtualPixels ( Bi_view , 0 , y , Bi_image -> columns , 1 , exception ) ; Cr = QueueCacheViewAuthenticPixels ( Cr_view , 0 , y , Cr_image -> columns , 1 , exception ) ; Ci = QueueCacheViewAuthenticPixels ( Ci_view , 0 , y , Ci_image -> columns , 1 , exception ) ; if ( ( Ar == ( const Quantum * ) NULL ) || ( Ai == ( const Quantum * ) NULL ) || ( Br == ( const Quantum * ) NULL ) || ( Bi == ( const Quantum * ) NULL ) || ( Cr == ( Quantum * ) NULL ) || ( Ci == ( Quantum * ) NULL ) ) { status = MagickFalse ; continue ; } for ( x = 0 ; x < ( ssize_t ) images -> columns ; x ++ ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) GetPixelChannels ( images ) ; i ++ ) { switch ( op ) { case AddComplexOperator : { Cr [ i ] = Ar [ i ] + Br [ i ] ; Ci [ i ] = Ai [ i ] + Bi [ i ] ; break ; } case ConjugateComplexOperator : default : { Cr [ i ] = Ar [ i ] ; Ci [ i ] = ( - Bi [ i ] ) ; break ; } case DivideComplexOperator : { double gamma ; gamma = PerceptibleReciprocal ( Br [ i ] * Br [ i ] + Bi [ i ] * Bi [ i ] + snr ) ; Cr [ i ] = gamma * ( Ar [ i ] * Br [ i ] + Ai [ i ] * Bi [ i ] ) ; Ci [ i ] = gamma * ( Ai [ i ] * Br [ i ] - Ar [ i ] * Bi [ i ] ) ; break ; } case MagnitudePhaseComplexOperator : { Cr [ i ] = sqrt ( Ar [ i ] * Ar [ i ] + Ai [ i ] * Ai [ i ] ) ; Ci [ i ] = atan2 ( Ai [ i ] , Ar [ i ] ) / ( 2.0 * MagickPI ) + 0.5 ; break ; } case MultiplyComplexOperator : { Cr [ i ] = QuantumScale * ( Ar [ i ] * Br [ i ] - Ai [ i ] * Bi [ i ] ) ; Ci [ i ] = QuantumScale * ( Ai [ i ] * Br [ i ] + Ar [ i ] * Bi [ i ] ) ; break ; } case RealImaginaryComplexOperator : { Cr [ i ] = Ar [ i ] * cos ( 2.0 * MagickPI * ( Ai [ i ] - 0.5 ) ) ; Ci [ i ] = Ar [ i ] * sin ( 2.0 * MagickPI * ( Ai [ i ] - 0.5 ) ) ; break ; } case SubtractComplexOperator : { Cr [ i ] = Ar [ i ] - Br [ i ] ; Ci [ i ] = Ai [ i ] - Bi [ i ] ; break ; } } } Ar += GetPixelChannels ( Ar_image ) ; Ai += GetPixelChannels ( Ai_image ) ; Br += GetPixelChannels ( Br_image ) ; Bi += GetPixelChannels ( Bi_image ) ; Cr += GetPixelChannels ( Cr_image ) ; Ci += GetPixelChannels ( Ci_image ) ; } if ( SyncCacheViewAuthenticPixels ( Ci_view , exception ) == MagickFalse ) status = MagickFalse ; if ( SyncCacheViewAuthenticPixels ( Cr_view , exception ) == MagickFalse ) status = MagickFalse ; if ( images -> progress_monitor != ( MagickProgressMonitor ) NULL ) { MagickBooleanType proceed ; #if defined(MAGICKCORE_OPENMP_SUPPORT) #pragma omp atomic #endif progress ++ ; proceed = SetImageProgress ( images , ComplexImageTag , progress , images -> rows ) ; if ( proceed == MagickFalse ) status = MagickFalse ; } } Cr_view = DestroyCacheView ( Cr_view ) ; Ci_view = DestroyCacheView ( Ci_view ) ; Br_view = DestroyCacheView ( Br_view ) ; Bi_view = DestroyCacheView ( Bi_view ) ; Ar_view = DestroyCacheView ( Ar_view ) ; Ai_view = DestroyCacheView ( Ai_view ) ; if ( status == MagickFalse )
TEST_P ( ConvolveTest , CopyVert ) { uint8_t * const in = input ( ) ; uint8_t * const out = output ( ) ; DECLARE_ALIGNED ( 256 , const int16_t , filter8 [ 8 ] ) = { 0 , 0 , 0 , 128 , 0 , 0 , 0 , 0 } ; REGISTER_STATE_CHECK ( UUT_ -> v8_ ( in , kInputStride , out , kOutputStride , filter8 , 16 , filter8 , 16 , Width ( ) , Height ( ) ) ) ; CheckGuardBlocks ( ) ; for ( int y = 0 ; y < Height ( ) ; ++ y ) for ( int x = 0 ; x < Width ( ) ; ++ x ) ASSERT_EQ ( out [ y * kOutputStride + x ] , in [ y * kInputStride + x ] ) < < "(" < < x < < "," < < y < < ")" ; }
UnixSocketConsumer :: SendSocketData ( const nsACString & aStr ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; if ( ! mImpl ) { return false ; } if ( aStr . Length ( ) > MAX_READ_SIZE ) { return false ; } nsCString str ( aStr ) ; UnixSocketRawData * d = new UnixSocketRawData ( aStr . Length ( ) ) ; memcpy ( d -> mData , str . get ( ) , aStr . Length ( ) ) ; XRE_GetIOMessageLoop ( ) -> PostTask ( FROM_HERE , new SocketSendTask ( this , mImpl , d ) ) ; return true ; }
int prepareForShutdown ( ) { redisLog ( REDIS_WARNING , "User requested shutdown, saving DB..." ) ; if ( server . bgsavechildpid != - 1 ) { redisLog ( REDIS_WARNING , "There is a live saving child. Killing it!" ) ; kill ( server . bgsavechildpid , SIGKILL ) ; rdbRemoveTempFile ( server . bgsavechildpid ) ; } if ( server . appendonly ) { aof_fsync ( server . appendfd ) ; if ( server . vm_enabled ) unlink ( server . vm_swap_file ) ; } else if ( server . saveparamslen > 0 ) { if ( rdbSave ( server . dbfilename ) != REDIS_OK ) { redisLog ( REDIS_WARNING , "Error trying to save the DB, can't exit" ) ; return REDIS_ERR ; } } else { redisLog ( REDIS_WARNING , "Not saving DB." ) ; } if ( server . daemonize ) unlink ( server . pidfile ) ; redisLog ( REDIS_WARNING , "Server exit now, bye bye..." ) ; return REDIS_OK ; }
TEST_P ( DecodePerfTest , PerfTest ) { const char * const video_name = GET_PARAM ( VIDEO_NAME ) ; const unsigned threads = GET_PARAM ( THREADS ) ; libvpx_test :: WebMVideoSource video ( video_name ) ; video . Init ( ) ; vpx_codec_dec_cfg_t cfg = { 0 } ; cfg . threads = threads ; libvpx_test :: VP9Decoder decoder ( cfg , 0 ) ; vpx_usec_timer t ; vpx_usec_timer_start ( & t ) ; for ( video . Begin ( ) ; video . cxdata ( ) != NULL ; video . Next ( ) ) { decoder . DecodeFrame ( video . cxdata ( ) , video . frame_size ( ) ) ; } vpx_usec_timer_mark ( & t ) ; const double elapsed_secs = double ( vpx_usec_timer_elapsed ( & t ) ) / kUsecsInSec ; const unsigned frames = video . frame_number ( ) ; const double fps = double ( frames ) / elapsed_secs ; printf ( "{\n" ) ; printf ( "\t\"version\" : \"%s\",\n" , VERSION_STRING_NOSP ) ; printf ( "\t\"videoName\" : \"%s\",\n" , video_name ) ; printf ( "\t\"threadCount\" : %u,\n" , threads ) ; printf ( "\t\"decodeTimeSecs\" : %f,\n" , elapsed_secs ) ; printf ( "\t\"totalFrames\" : %u,\n" , frames ) ; printf ( "\t\"framesPerSecond\" : %f\n" , fps ) ; printf ( "}\n" ) ; }
int main ( int argc , char * * argv ) { char * * pp = argv ; char * arg ; while ( ( arg = * ++ pp ) != NULL ) { if ( strcmp ( arg , "--ids=-" ) == 0 ) continue ; if ( strncmp ( arg , "--exact" , 7 ) == 0 ) continue ; if ( strncmp ( arg , "--cache" , 7 ) == 0 ) error_msg_and_die ( "bad option %s" , arg ) ; if ( strncmp ( arg , "--tmpdir" , 8 ) == 0 ) error_msg_and_die ( "bad option %s" , arg ) ; if ( strncmp ( arg , "--ids" , 5 ) == 0 ) error_msg_and_die ( "bad option %s" , arg ) ; } gid_t g = getegid ( ) ; if ( g != getgid ( ) ) IGNORE_RESULT ( setregid ( g , g ) ) ; uid_t u = geteuid ( ) ; if ( u != getuid ( ) ) { IGNORE_RESULT ( setreuid ( u , u ) ) ; #if 1 static const char * whitelist [ ] = { "REPORT_CLIENT_SLAVE" , "LANG" , } ; const size_t wlsize = sizeof ( whitelist ) / sizeof ( char * ) ; char * setlist [ sizeof ( whitelist ) / sizeof ( char * ) ] = { 0 } ; char * p = NULL ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( ( p = getenv ( whitelist [ i ] ) ) != NULL ) setlist [ i ] = xstrdup ( p ) ; clearenv ( ) ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( setlist [ i ] != NULL ) { xsetenv ( whitelist [ i ] , setlist [ i ] ) ; free ( setlist [ i ] ) ; } #else static const char forbid [ ] = "LD_LIBRARY_PATH" "\0" "LD_PRELOAD" "\0" "LD_TRACE_LOADED_OBJECTS" "\0" "LD_BIND_NOW" "\0" "LD_AOUT_LIBRARY_PATH" "\0" "LD_AOUT_PRELOAD" "\0" "LD_NOWARN" "\0" "LD_KEEPDIR" "\0" ; const char * p = forbid ; do { unsetenv ( p ) ; p += strlen ( p ) + 1 ; } while ( * p ) ; #endif char path_env [ ] = "PATH=/usr/sbin:/sbin:/usr/bin:/bin:"BIN_DIR ":"SBIN_DIR ; if ( u != 0 ) strcpy ( path_env , "PATH=/usr/bin:/bin:"BIN_DIR ) ; putenv ( path_env ) ; } execvp ( EXECUTABLE , argv ) ; error_msg_and_die ( "Can't execute %s" , EXECUTABLE ) ; }
xmlParseStartTag ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; const xmlChar * attname ; xmlChar * attvalue ; const xmlChar * * atts = ctxt -> atts ; int nbatts = 0 ; int maxatts = ctxt -> maxatts ; int i ; if ( RAW != '<' ) return ( NULL ) ; NEXT1 ; name = xmlParseName ( ctxt ) ; if ( name == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "xmlParseStartTag: invalid element name\n" ) ; return ( NULL ) ; } SKIP_BLANKS ; GROW ; while ( ( ( RAW != '>' ) && ( ( RAW != '/' ) || ( NXT ( 1 ) != '>' ) ) && ( IS_BYTE_CHAR ( RAW ) ) ) && ( ctxt -> instate != XML_PARSER_EOF ) ) { const xmlChar * q = CUR_PTR ; unsigned int cons = ctxt -> input -> consumed ; attname = xmlParseAttribute ( ctxt , & attvalue ) ; if ( ( attname != NULL ) && ( attvalue != NULL ) ) { for ( i = 0 ; i < nbatts ; i += 2 ) { if ( xmlStrEqual ( atts [ i ] , attname ) ) { xmlErrAttributeDup ( ctxt , NULL , attname ) ; xmlFree ( attvalue ) ; goto failed ; } } if ( atts == NULL ) { maxatts = 22 ; atts = ( const xmlChar * * ) xmlMalloc ( maxatts * sizeof ( xmlChar * ) ) ; if ( atts == NULL ) { xmlErrMemory ( ctxt , NULL ) ; if ( attvalue != NULL ) xmlFree ( attvalue ) ; goto failed ; } ctxt -> atts = atts ; ctxt -> maxatts = maxatts ; } else if ( nbatts + 4 > maxatts ) { const xmlChar * * n ; maxatts *= 2 ; n = ( const xmlChar * * ) xmlRealloc ( ( void * ) atts , maxatts * sizeof ( const xmlChar * ) ) ; if ( n == NULL ) { xmlErrMemory ( ctxt , NULL ) ; if ( attvalue != NULL ) xmlFree ( attvalue ) ; goto failed ; } atts = n ; ctxt -> atts = atts ; ctxt -> maxatts = maxatts ; } atts [ nbatts ++ ] = attname ; atts [ nbatts ++ ] = attvalue ; atts [ nbatts ] = NULL ; atts [ nbatts + 1 ] = NULL ; } else { if ( attvalue != NULL ) xmlFree ( attvalue ) ; } failed : GROW if ( ( RAW == '>' ) || ( ( ( RAW == '/' ) && ( NXT ( 1 ) == '>' ) ) ) ) break ; if ( ! IS_BLANK_CH ( RAW ) ) { xmlFatalErrMsg ( ctxt , XML_ERR_SPACE_REQUIRED , "attributes construct error\n" ) ; } SKIP_BLANKS ; if ( ( cons == ctxt -> input -> consumed ) && ( q == CUR_PTR ) && ( attname == NULL ) && ( attvalue == NULL ) ) { xmlFatalErrMsg ( ctxt , XML_ERR_INTERNAL_ERROR , "xmlParseStartTag: problem parsing attributes\n" ) ; break ; } SHRINK ; GROW ; } if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> startElement != NULL ) && ( ! ctxt -> disableSAX ) ) { if ( nbatts > 0 ) ctxt -> sax -> startElement ( ctxt -> userData , name , atts ) ; else ctxt -> sax -> startElement ( ctxt -> userData , name , NULL ) ; } if ( atts != NULL ) { for ( i = 1 ; i < nbatts ; i += 2 ) if ( atts [ i ] != NULL ) xmlFree ( ( xmlChar * ) atts [ i ] ) ; } return ( name ) ; }
IndexedDBDatabaseParent :: HandleRequestEvent ( nsIDOMEvent * aEvent , const nsAString & aType ) { MOZ_ASSERT ( mOpenRequest ) ; MOZ_ASSERT ( ! IsDisconnected ( ) ) ; nsresult rv ; if ( aType . EqualsLiteral ( ERROR_EVT_STR ) ) { nsRefPtr < IDBOpenDBRequest > request ; mOpenRequest . swap ( request ) ; rv = request -> GetErrorCode ( ) ; MOZ_ASSERT ( NS_FAILED ( rv ) ) ; if ( ! SendError ( rv ) ) { return NS_ERROR_FAILURE ; } rv = aEvent -> PreventDefault ( ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; return NS_OK ; } if ( aType . EqualsLiteral ( BLOCKED_EVT_STR ) ) { MOZ_ASSERT ( ! mDatabase ) ; nsCOMPtr < IDBVersionChangeEvent > changeEvent = do_QueryInterface ( aEvent ) ; NS_ENSURE_TRUE ( changeEvent , NS_ERROR_FAILURE ) ; uint64_t oldVersion = changeEvent -> OldVersion ( ) ; if ( ! SendBlocked ( oldVersion ) ) { return NS_ERROR_FAILURE ; } return NS_OK ; } AutoSafeJSContext cx ; ErrorResult error ; JS :: Rooted < JS :: Value > result ( cx , mOpenRequest -> GetResult ( cx , error ) ) ; ENSURE_SUCCESS ( error , error . ErrorCode ( ) ) ; MOZ_ASSERT ( ! result . isPrimitive ( ) ) ; IDBDatabase * database ; rv = UNWRAP_OBJECT ( IDBDatabase , & result . toObject ( ) , database ) ; if ( NS_FAILED ( rv ) ) { NS_WARNING ( "Didn't get the object we expected!" ) ; return rv ; } DatabaseInfo * dbInfo = database -> Info ( ) ; MOZ_ASSERT ( dbInfo ) ; nsAutoTArray < nsString , 20 > objectStoreNames ; if ( ! dbInfo -> GetObjectStoreNames ( objectStoreNames ) ) { MOZ_CRASH ( "This should never fail!" ) ; } InfallibleTArray < ObjectStoreInfoGuts > objectStoreInfos ; if ( ! objectStoreNames . IsEmpty ( ) ) { uint32_t length = objectStoreNames . Length ( ) ; objectStoreInfos . SetCapacity ( length ) ; for ( uint32_t i = 0 ; i < length ; i ++ ) { ObjectStoreInfo * osInfo = dbInfo -> GetObjectStore ( objectStoreNames [ i ] ) ; MOZ_ASSERT ( osInfo ) ; objectStoreInfos . AppendElement ( * osInfo ) ; } } if ( aType . EqualsLiteral ( SUCCESS_EVT_STR ) ) { nsRefPtr < IDBOpenDBRequest > request ; mOpenRequest . swap ( request ) ; EventTarget * target = static_cast < EventTarget * > ( database ) ; #ifdef DEBUG { nsresult rvDEBUG = target -> AddEventListener ( NS_LITERAL_STRING ( ERROR_EVT_STR ) , mEventListener , false ) ; NS_WARN_IF_FALSE ( NS_SUCCEEDED ( rvDEBUG ) , "Failed to add error listener!" ) ; } #endif NS_NAMED_LITERAL_STRING ( versionChange , VERSIONCHANGE_EVT_STR ) ; rv = target -> AddEventListener ( versionChange , mEventListener , false ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! SendSuccess ( * dbInfo , objectStoreInfos ) ) { return NS_ERROR_FAILURE ; } MOZ_ASSERT ( ! mDatabase || mDatabase == database ) ; if ( ! mDatabase ) { database -> SetActor ( this ) ; mDatabase = database ; } return NS_OK ; } if ( aType . EqualsLiteral ( UPGRADENEEDED_EVT_STR ) ) { MOZ_ASSERT ( ! mDatabase ) ; IDBTransaction * transaction = AsyncConnectionHelper :: GetCurrentTransaction ( ) ; MOZ_ASSERT ( transaction ) ; if ( ! CheckWritePermission ( database -> Name ( ) ) ) { ErrorResult rv ; transaction -> Abort ( rv ) ; if ( rv . Failed ( ) ) { NS_WARNING ( "Failed to abort transaction!" ) ; } return NS_ERROR_FAILURE ; } nsCOMPtr < IDBVersionChangeEvent > changeEvent = do_QueryInterface ( aEvent ) ; NS_ENSURE_TRUE ( changeEvent , NS_ERROR_FAILURE ) ; uint64_t oldVersion = changeEvent -> OldVersion ( ) ; nsAutoPtr < IndexedDBVersionChangeTransactionParent > actor ( new IndexedDBVersionChangeTransactionParent ( ) ) ; rv = actor -> SetTransaction ( transaction ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; VersionChangeTransactionParams versionChangeParams ; versionChangeParams . dbInfo ( ) = * dbInfo ; versionChangeParams . osInfo ( ) = objectStoreInfos ; versionChangeParams . oldVersion ( ) = oldVersion ; if ( ! SendPIndexedDBTransactionConstructor ( actor . forget ( ) , versionChangeParams ) ) { return NS_ERROR_FAILURE ; } database -> SetActor ( this ) ; mDatabase = database ; return NS_OK ; } MOZ_CRASH ( "Unexpected message type!" ) ; }
xmlGzfileOpenW ( const char * filename , int compression ) { const char * path = NULL ; char mode [ 15 ] ; gzFile fd ; snprintf ( mode , sizeof ( mode ) , "wb%d" , compression ) ; if ( ! strcmp ( filename , "-" ) ) { int duped_fd = dup ( fileno ( stdout ) ) ; fd = gzdopen ( duped_fd , "rb" ) ; if ( fd == Z_NULL && duped_fd >= 0 ) { close ( duped_fd ) ; } return ( ( void * ) fd ) ; } if ( ! xmlStrncasecmp ( BAD_CAST filename , BAD_CAST "file://localhost/" , 17 ) ) #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__) path = & filename [ 17 ] ; #else path = & filename [ 16 ] ; #endif else if ( ! xmlStrncasecmp ( BAD_CAST filename , BAD_CAST "file:///" , 8 ) ) { #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__) path = & filename [ 8 ] ; #else path = & filename [ 7 ] ; #endif } else path = filename ; if ( path == NULL ) return ( NULL ) ; #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__) fd = xmlWrapGzOpen ( path , mode ) ; #else fd = gzopen ( path , mode ) ; #endif return ( ( void * ) fd ) ; }
bool Channel :: ChannelImpl :: ProcessOutgoingMessages ( ) { DCHECK ( ! waiting_connect_ ) ; is_blocked_on_write_ = false ; if ( output_queue_ . empty ( ) ) return true ; if ( pipe_ == - 1 ) return false ; while ( ! output_queue_ . empty ( ) ) { Message * msg = output_queue_ . front ( ) ; size_t amt_to_write = msg -> size ( ) - message_send_bytes_written_ ; DCHECK ( amt_to_write != 0 ) ; const char * out_bytes = reinterpret_cast < const char * > ( msg -> data ( ) ) + message_send_bytes_written_ ; struct msghdr msgh = { 0 } ; struct iovec iov = { const_cast < char * > ( out_bytes ) , amt_to_write } ; msgh . msg_iov = & iov ; msgh . msg_iovlen = 1 ; static const int tmp = CMSG_SPACE ( sizeof ( int [ FileDescriptorSet :: MAX_DESCRIPTORS_PER_MESSAGE ] ) ) ; char buf [ tmp ] ; if ( message_send_bytes_written_ == 0 && ! msg -> file_descriptor_set ( ) -> empty ( ) ) { struct cmsghdr * cmsg ; const unsigned num_fds = msg -> file_descriptor_set ( ) -> size ( ) ; DCHECK_LE ( num_fds , FileDescriptorSet :: MAX_DESCRIPTORS_PER_MESSAGE ) ; msgh . msg_control = buf ; msgh . msg_controllen = CMSG_SPACE ( sizeof ( int ) * num_fds ) ; cmsg = CMSG_FIRSTHDR ( & msgh ) ; cmsg -> cmsg_level = SOL_SOCKET ; cmsg -> cmsg_type = SCM_RIGHTS ; cmsg -> cmsg_len = CMSG_LEN ( sizeof ( int ) * num_fds ) ; msg -> file_descriptor_set ( ) -> GetDescriptors ( reinterpret_cast < int * > ( CMSG_DATA ( cmsg ) ) ) ; msgh . msg_controllen = cmsg -> cmsg_len ; msg -> header ( ) -> num_fds = num_fds ; } ssize_t bytes_written = HANDLE_EINTR ( sendmsg ( pipe_ , & msgh , MSG_DONTWAIT ) ) ; if ( bytes_written > 0 ) msg -> file_descriptor_set ( ) -> CommitAll ( ) ; if ( bytes_written < 0 && errno != EAGAIN ) { LOG ( ERROR ) < < "pipe error: " < < strerror ( errno ) ; return false ; } if ( static_cast < size_t > ( bytes_written ) != amt_to_write ) { if ( bytes_written > 0 ) { message_send_bytes_written_ += bytes_written ; } is_blocked_on_write_ = true ; MessageLoopForIO :: current ( ) -> WatchFileDescriptor ( pipe_ , false , MessageLoopForIO :: WATCH_WRITE , & write_watcher_ , this ) ; return true ; } else { message_send_bytes_written_ = 0 ; #ifdef IPC_MESSAGE_DEBUG_EXTRA DLOG ( INFO ) < < "sent message @" < < msg < < " on channel @" < < this < < " with type " < < msg -> type ( ) ; #endif output_queue_ . pop ( ) ; delete msg ; } } return true ; }
void vp9_twopass_postencode_update ( VP9_COMP * cpi ) { #ifdef DISABLE_RC_LONG_TERM_MEM const uint64_t bits_used = cpi -> rc . this_frame_target ; #else const uint64_t bits_used = cpi -> rc . projected_frame_size ; #endif cpi -> twopass . bits_left -= bits_used ; cpi -> twopass . bits_left = MAX ( cpi -> twopass . bits_left , 0 ) ; if ( cpi -> common . frame_type == KEY_FRAME ) { cpi -> twopass . kf_group_bits += cpi -> rc . this_frame_target - bits_used ; } else { cpi -> twopass . kf_group_bits -= bits_used ; cpi -> twopass . gf_group_bits -= bits_used ; cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ; } cpi -> twopass . kf_group_bits = MAX ( cpi -> twopass . kf_group_bits , 0 ) ; }
static int faultin_page ( struct task_struct * tsk , struct vm_area_struct * vma , unsigned long address , unsigned int * flags , int * nonblocking ) { unsigned int fault_flags = 0 ; int ret ; if ( ( * flags & ( FOLL_POPULATE | FOLL_MLOCK ) ) == FOLL_MLOCK ) return - ENOENT ; if ( ( * flags & FOLL_POPULATE ) && ( stack_guard_page_start ( vma , address ) || stack_guard_page_end ( vma , address + PAGE_SIZE ) ) ) return - ENOENT ; if ( * flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( * flags & FOLL_REMOTE ) fault_flags |= FAULT_FLAG_REMOTE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( * flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( * flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = handle_mm_fault ( vma , address , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { if ( ret & VM_FAULT_OOM ) return - ENOMEM ; if ( ret & ( VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE ) ) return * flags & FOLL_HWPOISON ? - EHWPOISON : - EFAULT ; if ( ret & ( VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV ) ) return - EFAULT ; BUG ( ) ; } if ( tsk ) { if ( ret & VM_FAULT_MAJOR ) tsk -> maj_flt ++ ; else tsk -> min_flt ++ ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking ) * nonblocking = 0 ; return - EBUSY ; } if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) ) * flags &= ~ FOLL_WRITE ; return 0 ; }
char * enl_ipc_get ( const char * msg_data ) { static char * message = NULL ; static unsigned short len = 0 ; char buff [ 13 ] , * ret_msg = NULL ; register unsigned char i ; unsigned char blen ; if ( msg_data == IPC_TIMEOUT ) { return ( IPC_TIMEOUT ) ; } for ( i = 0 ; i < 12 ; i ++ ) { buff [ i ] = msg_data [ i ] ; } buff [ 12 ] = 0 ; blen = strlen ( buff ) ; if ( message != NULL ) { len += blen ; message = ( char * ) erealloc ( message , len + 1 ) ; strcat ( message , buff ) ; } else { len = blen ; message = ( char * ) emalloc ( len + 1 ) ; strcpy ( message , buff ) ; } if ( blen < 12 ) { ret_msg = message ; message = NULL ; D ( ( "Received complete reply:  \"%s\"\n" , ret_msg ) ) ; } return ( ret_msg ) ; }
void MetaData :: typed_data :: setData ( uint32_t type , const void * data , size_t size ) { clear ( ) ; mType = type ; allocateStorage ( size ) ; memcpy ( storage ( ) , data , size ) ; }
ps_parser_skip_PS_token ( PS_Parser parser ) { FT_Byte * cur = parser -> cursor ; FT_Byte * limit = parser -> limit ; FT_Error error = FT_Err_Ok ; skip_spaces ( & cur , limit ) ; if ( cur >= limit ) goto Exit ; if ( * cur == '[' || * cur == ']' ) { cur ++ ; goto Exit ; } if ( * cur == '{' ) { error = skip_procedure ( & cur , limit ) ; goto Exit ; } if ( * cur == '(' ) { error = skip_literal_string ( & cur , limit ) ; goto Exit ; } if ( * cur == '<' ) { if ( cur + 1 < limit && * ( cur + 1 ) == '<' ) { cur ++ ; cur ++ ; } else error = skip_string ( & cur , limit ) ; goto Exit ; } if ( * cur == '>' ) { cur ++ ; if ( cur >= limit || * cur != '>' ) { FT_ERROR ( ( "ps_parser_skip_PS_token:" " unexpected closing delimiter `>'\n" ) ) ; error = FT_THROW ( Invalid_File_Format ) ; goto Exit ; } cur ++ ; goto Exit ; } if ( * cur == '/' ) cur ++ ; while ( cur < limit ) { if ( IS_PS_DELIM ( * cur ) ) break ; cur ++ ; } Exit : if ( cur < limit && cur == parser -> cursor ) { FT_ERROR ( ( "ps_parser_skip_PS_token:" " current token is `%c' which is self-delimiting\n" "                        " " but invalid at this point\n" , * cur ) ) ; error = FT_THROW ( Invalid_File_Format ) ; } parser -> error = error ; parser -> cursor = cur ; }
void TracingCategoryObserver :: TearDown ( ) { v8 :: internal :: V8 :: GetCurrentPlatform ( ) -> GetTracingController ( ) -> RemoveTraceStateObserver ( TracingCategoryObserver :: instance_ ) ; delete TracingCategoryObserver :: instance_ ; }
static int ip6_frag_queue ( struct frag_queue * fq , struct sk_buff * skb , struct frag_hdr * fhdr , int nhoff ) { struct sk_buff * prev , * next ; struct net_device * dev ; int offset , end ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; if ( fq -> q . last_in & INET_FRAG_COMPLETE ) goto err ; offset = ntohs ( fhdr -> frag_off ) & ~ 0x7 ; end = offset + ( ntohs ( ipv6_hdr ( skb ) -> payload_len ) - ( ( u8 * ) ( fhdr + 1 ) - ( u8 * ) ( ipv6_hdr ( skb ) + 1 ) ) ) ; if ( ( unsigned int ) end > IPV6_MAXPLEN ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , ( ( u8 * ) & fhdr -> frag_off - skb_network_header ( skb ) ) ) ; return - 1 ; } if ( skb -> ip_summed == CHECKSUM_COMPLETE ) { const unsigned char * nh = skb_network_header ( skb ) ; skb -> csum = csum_sub ( skb -> csum , csum_partial ( nh , ( u8 * ) ( fhdr + 1 ) - nh , 0 ) ) ; } if ( ! ( fhdr -> frag_off & htons ( IP6_MF ) ) ) { if ( end < fq -> q . len || ( ( fq -> q . last_in & INET_FRAG_LAST_IN ) && end != fq -> q . len ) ) goto err ; fq -> q . last_in |= INET_FRAG_LAST_IN ; fq -> q . len = end ; } else { if ( end & 0x7 ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , offsetof ( struct ipv6hdr , payload_len ) ) ; return - 1 ; } if ( end > fq -> q . len ) { if ( fq -> q . last_in & INET_FRAG_LAST_IN ) goto err ; fq -> q . len = end ; } } if ( end == offset ) goto err ; if ( ! pskb_pull ( skb , ( u8 * ) ( fhdr + 1 ) - skb -> data ) ) goto err ; if ( pskb_trim_rcsum ( skb , end - offset ) ) goto err ; prev = fq -> q . fragments_tail ; if ( ! prev || FRAG6_CB ( prev ) -> offset < offset ) { next = NULL ; goto found ; } prev = NULL ; for ( next = fq -> q . fragments ; next != NULL ; next = next -> next ) { if ( FRAG6_CB ( next ) -> offset >= offset ) break ; prev = next ; } found : if ( prev ) { int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ; if ( i > 0 ) { offset += i ; if ( end <= offset ) goto err ; if ( ! pskb_pull ( skb , i ) ) goto err ; if ( skb -> ip_summed != CHECKSUM_UNNECESSARY ) skb -> ip_summed = CHECKSUM_NONE ; } } while ( next && FRAG6_CB ( next ) -> offset < end ) { int i = end - FRAG6_CB ( next ) -> offset ; if ( i < next -> len ) { if ( ! pskb_pull ( next , i ) ) goto err ; FRAG6_CB ( next ) -> offset += i ; fq -> q . meat -= i ; if ( next -> ip_summed != CHECKSUM_UNNECESSARY ) next -> ip_summed = CHECKSUM_NONE ; break ; } else { struct sk_buff * free_it = next ; next = next -> next ; if ( prev ) prev -> next = next ; else fq -> q . fragments = next ; fq -> q . meat -= free_it -> len ; frag_kfree_skb ( fq -> q . net , free_it ) ; } } FRAG6_CB ( skb ) -> offset = offset ; skb -> next = next ; if ( ! next ) fq -> q . fragments_tail = skb ; if ( prev ) prev -> next = skb ; else fq -> q . fragments = skb ; dev = skb -> dev ; if ( dev ) { fq -> iif = dev -> ifindex ; skb -> dev = NULL ; } fq -> q . stamp = skb -> tstamp ; fq -> q . meat += skb -> len ; atomic_add ( skb -> truesize , & fq -> q . net -> mem ) ; if ( offset == 0 ) { fq -> nhoffset = nhoff ; fq -> q . last_in |= INET_FRAG_FIRST_IN ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) return ip6_frag_reasm ( fq , prev , dev ) ; write_lock ( & ip6_frags . lock ) ; list_move_tail ( & fq -> q . lru_list , & fq -> q . net -> lru_list ) ; write_unlock ( & ip6_frags . lock ) ; return - 1 ; err : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ; kfree_skb ( skb ) ; return - 1 ; }
GetElementIC :: update ( JSContext * cx , size_t cacheIndex , HandleObject obj , HandleValue idval , MutableHandleValue res ) { void * returnAddr ; IonScript * ion = GetTopIonJSScript ( cx , & returnAddr ) -> ionScript ( ) ; GetElementIC & cache = ion -> getCache ( cacheIndex ) . toGetElement ( ) ; RootedScript script ( cx ) ; jsbytecode * pc ; cache . getScriptedLocation ( & script , & pc ) ; if ( cache . isDisabled ( ) ) { if ( ! GetObjectElementOperation ( cx , JSOp ( * pc ) , obj , true , idval , res ) ) return false ; types :: TypeScript :: Monitor ( cx , script , pc , res ) ; return true ; } AutoFlushCache afc ( "GetElementCache" , cx -> runtime ( ) -> jitRuntime ( ) ) ; AutoDetectInvalidation adi ( cx , res . address ( ) , ion ) ; RootedId id ( cx ) ; if ( ! ValueToId < CanGC > ( cx , idval , & id ) ) return false ; bool attachedStub = false ; if ( cache . canAttachStub ( ) ) { if ( IsOptimizableArgumentsObjectForGetElem ( obj , idval ) && ! cache . hasArgumentsStub ( obj -> is < StrictArgumentsObject > ( ) ) && ! cache . index ( ) . constant ( ) && ( cache . index ( ) . reg ( ) . hasValue ( ) || cache . index ( ) . reg ( ) . type ( ) == MIRType_Int32 ) && ( cache . output ( ) . hasValue ( ) || ! cache . output ( ) . typedReg ( ) . isFloat ( ) ) ) { if ( ! cache . attachArgumentsElement ( cx , ion , obj ) ) return false ; attachedStub = true ; } if ( ! attachedStub && cache . monitoredResult ( ) && canAttachGetProp ( obj , idval , id ) ) { RootedPropertyName name ( cx , JSID_TO_ATOM ( id ) -> asPropertyName ( ) ) ; if ( ! cache . attachGetProp ( cx , ion , obj , idval , name , returnAddr ) ) return false ; attachedStub = true ; } if ( ! attachedStub && ! cache . hasDenseStub ( ) && canAttachDenseElement ( obj , idval ) ) { if ( ! cache . attachDenseElement ( cx , ion , obj , idval ) ) return false ; attachedStub = true ; } if ( ! attachedStub && canAttachTypedArrayElement ( obj , idval , cache . output ( ) ) ) { Rooted < TypedArrayObject * > tarr ( cx , & obj -> as < TypedArrayObject > ( ) ) ; if ( ! cache . attachTypedArrayElement ( cx , ion , tarr , idval ) ) return false ; attachedStub = true ; } } if ( ! GetObjectElementOperation ( cx , JSOp ( * pc ) , obj , true , idval , res ) ) return false ; if ( ! attachedStub ) { cache . incFailedUpdates ( ) ; if ( cache . shouldDisable ( ) ) { IonSpew ( IonSpew_InlineCaches , "Disable inline cache" ) ; cache . disable ( ) ; } } else { cache . resetFailedUpdates ( ) ; } types :: TypeScript :: Monitor ( cx , script , pc , res ) ; return true ; }
CodeGenerator :: visitNeuterCheck ( LNeuterCheck * lir ) { Register obj = ToRegister ( lir -> object ( ) ) ; Register temp = ToRegister ( lir -> temp ( ) ) ; masm . loadPtr ( Address ( obj , TypedObject :: dataOffset ( ) ) , temp ) ; masm . testPtr ( temp , temp ) ; if ( ! bailoutIf ( Assembler :: Zero , lir -> snapshot ( ) ) ) return false ; return true ; }
bool UpdateAttempterAndroid :: VerifyPayloadApplicable ( const std :: string & metadata_filename , brillo :: ErrorPtr * error ) { FileDescriptorPtr fd ( new EintrSafeFileDescriptor ) ; if ( ! fd -> Open ( metadata_filename . c_str ( ) , O_RDONLY ) ) { return LogAndSetError ( error , FROM_HERE , "Failed to open " + metadata_filename ) ; } brillo :: Blob metadata ( kMaxPayloadHeaderSize ) ; if ( ! fd -> Read ( metadata . data ( ) , metadata . size ( ) ) ) { return LogAndSetError ( error , FROM_HERE , "Failed to read payload header from " + metadata_filename ) ; } ErrorCode errorcode ; PayloadMetadata payload_metadata ; if ( payload_metadata . ParsePayloadHeader ( metadata , kBrilloMajorPayloadVersion , & errorcode ) != MetadataParseResult :: kSuccess ) { return LogAndSetError ( error , FROM_HERE , "Failed to parse payload header: " + utils :: ErrorCodeToString ( errorcode ) ) ; } metadata . resize ( payload_metadata . GetMetadataSize ( ) + payload_metadata . GetMetadataSignatureSize ( ) ) ; if ( metadata . size ( ) < kMaxPayloadHeaderSize ) { return LogAndSetError ( error , FROM_HERE , "Metadata size too small: " + std :: to_string ( metadata . size ( ) ) ) ; } if ( ! fd -> Read ( metadata . data ( ) + kMaxPayloadHeaderSize , metadata . size ( ) - kMaxPayloadHeaderSize ) ) { return LogAndSetError ( error , FROM_HERE , "Failed to read metadata and signature from " + metadata_filename ) ; } fd -> Close ( ) ; errorcode = payload_metadata . ValidateMetadataSignature ( metadata , "" , base :: FilePath ( constants :: kUpdatePayloadPublicKeyPath ) ) ; if ( errorcode != ErrorCode :: kSuccess ) { return LogAndSetError ( error , FROM_HERE , "Failed to validate metadata signature: " + utils :: ErrorCodeToString ( errorcode ) ) ; } DeltaArchiveManifest manifest ; if ( ! payload_metadata . GetManifest ( metadata , & manifest ) ) { return LogAndSetError ( error , FROM_HERE , "Failed to parse manifest." ) ; } BootControlInterface :: Slot current_slot = boot_control_ -> GetCurrentSlot ( ) ; for ( const PartitionUpdate & partition : manifest . partitions ( ) ) { if ( ! partition . has_old_partition_info ( ) ) continue ; string partition_path ; if ( ! boot_control_ -> GetPartitionDevice ( partition . partition_name ( ) , current_slot , & partition_path ) ) { return LogAndSetError ( error , FROM_HERE , "Failed to get partition device for " + partition . partition_name ( ) ) ; } if ( ! fd -> Open ( partition_path . c_str ( ) , O_RDONLY ) ) { return LogAndSetError ( error , FROM_HERE , "Failed to open " + partition_path ) ; } for ( const InstallOperation & operation : partition . operations ( ) ) { if ( ! operation . has_src_sha256_hash ( ) ) continue ; brillo :: Blob source_hash ; if ( ! fd_utils :: ReadAndHashExtents ( fd , operation . src_extents ( ) , manifest . block_size ( ) , & source_hash ) ) { return LogAndSetError ( error , FROM_HERE , "Failed to hash " + partition_path ) ; } if ( ! DeltaPerformer :: ValidateSourceHash ( source_hash , operation , fd , & errorcode ) ) { return false ; } } fd -> Close ( ) ; } return true ; }
void mp_encode_lua_table_as_map ( lua_State * L , mp_buf * buf , int level ) { size_t len = 0 ; lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pop ( L , 1 ) ; len ++ ; } mp_encode_map ( L , buf , len ) ; lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pushvalue ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }
ImageDataSerializerBase :: ComputeMinBufferSize ( IntSize aSize , SurfaceFormat aFormat ) { uint32_t bufsize = aSize . height * ComputeStride ( aFormat , aSize . width ) ; return SurfaceBufferInfo :: GetOffset ( ) + GetAlignedStride < 16 > ( bufsize ) ; }
BGD_DECLARE ( void ) gdImageWBMPCtx ( gdImagePtr image , int fg , gdIOCtx * out ) { int x , y , pos ; Wbmp * wbmp ; if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) { gd_error ( "Could not create WBMP\n" ) ; return ; } pos = 0 ; for ( y = 0 ; y < gdImageSY ( image ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( image ) ; x ++ ) { if ( gdImageGetPixel ( image , x , y ) == fg ) { wbmp -> bitmap [ pos ] = WBMP_BLACK ; } pos ++ ; } } if ( writewbmp ( wbmp , & gd_putout , out ) ) { gd_error ( "Could not save WBMP\n" ) ; } freewbmp ( wbmp ) ; }
Variable * Parser :: Declare ( Declaration * declaration , DeclarationDescriptor :: Kind declaration_kind , VariableMode mode , InitializationFlag init , bool * ok , Scope * scope , int var_end_pos ) { if ( scope == nullptr ) { scope = this -> scope ( ) ; } bool sloppy_mode_block_scope_function_redefinition = false ; Variable * variable = scope -> DeclareVariable ( declaration , mode , init , & sloppy_mode_block_scope_function_redefinition , ok ) ; if ( ! * ok ) { Scanner :: Location loc ( declaration -> proxy ( ) -> position ( ) , var_end_pos != kNoSourcePosition ? var_end_pos : declaration -> proxy ( ) -> position ( ) + 1 ) ; if ( declaration_kind == DeclarationDescriptor :: PARAMETER ) { ReportMessageAt ( loc , MessageTemplate :: kParamDupe ) ; } else { ReportMessageAt ( loc , MessageTemplate :: kVarRedeclaration , declaration -> proxy ( ) -> raw_name ( ) ) ; } return nullptr ; } if ( sloppy_mode_block_scope_function_redefinition ) { ++ use_counts_ [ v8 :: Isolate :: kSloppyModeBlockScopedFunctionRedefinition ] ; } return variable ; }
void rw_t3t_act_handle_sro_rsp ( tRW_T3T_CB * p_cb , NFC_HDR * p_msg_rsp ) { uint8_t * p_t3t_rsp = ( uint8_t * ) ( p_msg_rsp + 1 ) + p_msg_rsp -> offset ; uint8_t * p_mc ; tRW_DATA evt_data ; evt_data . status = NFC_STATUS_OK ; if ( p_cb -> rw_substate == RW_T3T_SRO_SST_UPDATE_NDEF_ATTRIB ) { if ( ( p_t3t_rsp [ T3T_MSG_RSP_OFFSET_RSPCODE ] != T3T_MSG_OPC_UPDATE_RSP ) || ( p_t3t_rsp [ T3T_MSG_RSP_OFFSET_STATUS1 ] != T3T_MSG_RSP_STATUS_OK ) ) { LOG ( ERROR ) < < StringPrintf ( "Response error: rsp_code=%02X, status=%02X" , p_t3t_rsp [ T3T_MSG_RSP_OFFSET_RSPCODE ] , p_t3t_rsp [ T3T_MSG_RSP_OFFSET_STATUS1 ] ) ; evt_data . status = NFC_STATUS_FAILED ; } else { p_cb -> ndef_attrib . rwflag = T3T_MSG_NDEF_RWFLAG_RO ; if ( p_cb -> cur_cmd == RW_T3T_CMD_SET_READ_ONLY_HARD ) { p_cb -> rw_substate = RW_T3T_SRO_SST_CHECK_MC_BLK ; evt_data . status = rw_t3t_check_mc_block ( p_cb ) ; } else { rw_t3t_set_readonly_cplt ( evt_data . status ) ; } } } else if ( p_cb -> rw_substate == RW_T3T_SRO_SST_CHECK_MC_BLK ) { if ( p_t3t_rsp [ T3T_MSG_RSP_OFFSET_RSPCODE ] != T3T_MSG_OPC_CHECK_RSP ) { LOG ( ERROR ) < < StringPrintf ( "Response error: expecting rsp_code %02X, but got %02X" , T3T_MSG_OPC_CHECK_RSP , p_t3t_rsp [ T3T_MSG_RSP_OFFSET_RSPCODE ] ) ; evt_data . status = NFC_STATUS_FAILED ; } else if ( ( p_t3t_rsp [ T3T_MSG_RSP_OFFSET_STATUS1 ] != T3T_MSG_RSP_STATUS_OK ) || ( memcmp ( p_cb -> peer_nfcid2 , & p_t3t_rsp [ T3T_MSG_RSP_OFFSET_IDM ] , NCI_NFCID2_LEN ) != 0 ) ) { evt_data . status = NFC_STATUS_FAILED ; } else { p_mc = & p_t3t_rsp [ T3T_MSG_RSP_OFFSET_CHECK_DATA ] ; if ( p_mc [ T3T_MSG_FELICALITE_MC_OFFSET_SYS_OP ] != 0x01 ) { evt_data . status = NFC_STATUS_FAILED ; } else { p_mc [ T3T_MSG_FELICALITE_MC_OFFSET_MC_SP ] = 0x00 ; p_mc [ T3T_MSG_FELICALITE_MC_OFFSET_MC_SP + 1 ] = 0xC0 ; p_mc [ T3T_MSG_FELICALITE_MC_OFFSET_RF_PRM ] = 0x07 ; p_cb -> rw_substate = RW_T3T_SRO_SST_UPDATE_MC_BLK ; evt_data . status = rw_t3t_update_block ( p_cb , T3T_MSG_FELICALITE_BLOCK_ID_MC , p_mc ) ; } } } else if ( p_cb -> rw_substate == RW_T3T_SRO_SST_UPDATE_MC_BLK ) { if ( ( p_t3t_rsp [ T3T_MSG_RSP_OFFSET_RSPCODE ] != T3T_MSG_OPC_UPDATE_RSP ) || ( p_t3t_rsp [ T3T_MSG_RSP_OFFSET_STATUS1 ] != T3T_MSG_RSP_STATUS_OK ) ) { LOG ( ERROR ) < < StringPrintf ( "Response error: rsp_code=%02X, status=%02X" , p_t3t_rsp [ T3T_MSG_RSP_OFFSET_RSPCODE ] , p_t3t_rsp [ T3T_MSG_RSP_OFFSET_STATUS1 ] ) ; evt_data . status = NFC_STATUS_FAILED ; } else { rw_t3t_set_readonly_cplt ( evt_data . status ) ; } } if ( evt_data . status != NFC_STATUS_OK ) { rw_t3t_set_readonly_cplt ( evt_data . status ) ; } GKI_freebuf ( p_msg_rsp ) ; }
nsDirIndexParser :: ParseFormat ( const char * aFormatStr ) { const char * pos = aFormatStr ; unsigned int num = 0 ; do { while ( * pos && nsCRT :: IsAsciiSpace ( char16_t ( * pos ) ) ) ++ pos ; ++ num ; if ( num > ( 2 * ArrayLength ( gFieldTable ) ) ) return NS_ERROR_UNEXPECTED ; if ( ! * pos ) break ; while ( * pos && ! nsCRT :: IsAsciiSpace ( char16_t ( * pos ) ) ) ++ pos ; } while ( * pos ) ; delete [ ] mFormat ; mFormat = new int [ num + 1 ] ; if ( mFormat == nullptr ) return NS_ERROR_OUT_OF_MEMORY ; mFormat [ num ] = - 1 ; mFormat [ 0 ] = - 1 ; int formatNum = 0 ; do { while ( * aFormatStr && nsCRT :: IsAsciiSpace ( char16_t ( * aFormatStr ) ) ) ++ aFormatStr ; if ( ! * aFormatStr ) break ; nsAutoCString name ; int32_t len = 0 ; while ( aFormatStr [ len ] && ! nsCRT :: IsAsciiSpace ( char16_t ( aFormatStr [ len ] ) ) ) ++ len ; name . SetCapacity ( len + 1 ) ; name . Append ( aFormatStr , len ) ; aFormatStr += len ; name . SetLength ( nsUnescapeCount ( name . BeginWriting ( ) ) ) ; if ( name . LowerCaseEqualsLiteral ( "description" ) ) mHasDescription = true ; for ( Field * i = gFieldTable ; i -> mName ; ++ i ) { if ( name . EqualsIgnoreCase ( i -> mName ) ) { mFormat [ formatNum ] = i -> mType ; ++ formatNum ; break ; } } } while ( * aFormatStr ) ; return NS_OK ; }
xmlValidNormalizeAttributeValue ( xmlDocPtr doc , xmlNodePtr elem , const xmlChar * name , const xmlChar * value ) { xmlChar * ret , * dst ; const xmlChar * src ; xmlAttributePtr attrDecl = NULL ; if ( doc == NULL ) return ( NULL ) ; if ( elem == NULL ) return ( NULL ) ; if ( name == NULL ) return ( NULL ) ; if ( value == NULL ) return ( NULL ) ; if ( ( elem -> ns != NULL ) && ( elem -> ns -> prefix != NULL ) ) { xmlChar fn [ 50 ] ; xmlChar * fullname ; fullname = xmlBuildQName ( elem -> name , elem -> ns -> prefix , fn , 50 ) ; if ( fullname == NULL ) return ( NULL ) ; if ( ( fullname != fn ) && ( fullname != elem -> name ) ) xmlFree ( fullname ) ; } attrDecl = xmlGetDtdAttrDesc ( doc -> intSubset , elem -> name , name ) ; if ( ( attrDecl == NULL ) && ( doc -> extSubset != NULL ) ) attrDecl = xmlGetDtdAttrDesc ( doc -> extSubset , elem -> name , name ) ; if ( attrDecl == NULL ) return ( NULL ) ; if ( attrDecl -> atype == XML_ATTRIBUTE_CDATA ) return ( NULL ) ; ret = xmlStrdup ( value ) ; if ( ret == NULL ) return ( NULL ) ; src = value ; dst = ret ; while ( * src == 0x20 ) src ++ ; while ( * src != 0 ) { if ( * src == 0x20 ) { while ( * src == 0x20 ) src ++ ; if ( * src != 0 ) * dst ++ = 0x20 ; } else { * dst ++ = * src ++ ; } } * dst = 0 ; return ( ret ) ; }
static __exit void sctp_exit ( void ) { sctp_v6_del_protocol ( ) ; sctp_v4_del_protocol ( ) ; unregister_pernet_subsys ( & sctp_net_ops ) ; sctp_v6_protosw_exit ( ) ; sctp_v4_protosw_exit ( ) ; sctp_v6_pf_exit ( ) ; sctp_v4_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; kfree ( sctp_ep_hashtable ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; percpu_counter_destroy ( & sctp_sockets_allocated ) ; rcu_barrier ( ) ; kmem_cache_destroy ( sctp_chunk_cachep ) ; kmem_cache_destroy ( sctp_bucket_cachep ) ; }
void vp9_foreach_transformed_block ( const MACROBLOCKD * const xd , BLOCK_SIZE bsize , foreach_transformed_block_visitor visit , void * arg ) { int plane ; for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ ) vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ; }
bool RegExpUtils :: IsUnmodifiedRegExp ( Isolate * isolate , Handle < Object > obj ) { #ifdef V8_ENABLE_FORCE_SLOW_PATH if ( isolate -> force_slow_path ( ) ) return false ; #endif if ( ! obj -> IsJSReceiver ( ) ) return false ; JSReceiver * recv = JSReceiver :: cast ( * obj ) ; if ( ! HasInitialRegExpMap ( isolate , recv ) ) return false ; Object * proto = recv -> map ( ) -> prototype ( ) ; if ( ! proto -> IsJSReceiver ( ) ) return false ; Handle < Map > initial_proto_initial_map = isolate -> regexp_prototype_map ( ) ; if ( JSReceiver :: cast ( proto ) -> map ( ) != * initial_proto_initial_map ) { return false ; } Object * last_index = JSRegExp :: cast ( recv ) -> last_index ( ) ; return last_index -> IsSmi ( ) && Smi :: ToInt ( last_index ) >= 0 ; }
xmlXPathNewValueTree ( xmlNodePtr val ) { xmlXPathObjectPtr ret ; ret = ( xmlXPathObjectPtr ) xmlMalloc ( sizeof ( xmlXPathObject ) ) ; if ( ret == NULL ) { xmlXPathErrMemory ( NULL , "creating result value tree\n" ) ; return ( NULL ) ; } memset ( ret , 0 , ( size_t ) sizeof ( xmlXPathObject ) ) ; ret -> type = XPATH_XSLT_TREE ; ret -> boolval = 1 ; ret -> user = ( void * ) val ; ret -> nodesetval = xmlXPathNodeSetCreate ( val ) ; #ifdef XP_DEBUG_OBJ_USAGE xmlXPathDebugObjUsageRequested ( NULL , XPATH_XSLT_TREE ) ; #endif return ( ret ) ; }
std :: ostream & operator < < ( std :: ostream & os , const CallDescriptor :: Kind & k ) { switch ( k ) { case CallDescriptor :: kCallCodeObject : os < < "Code" ; break ; case CallDescriptor :: kCallJSFunction : os < < "JS" ; break ; case CallDescriptor :: kCallAddress : os < < "Addr" ; break ; case CallDescriptor :: kCallWasmFunction : os < < "Wasm" ; break ; } return os ; }
void nsWindow :: NativeMoveResizeWaylandPopupCallback ( const GdkRectangle * aFinalSize , bool aFlippedX , bool aFlippedY ) { mWaitingForMoveToRectCallback = false ; bool movedByLayout = mNewBoundsAfterMoveToRect . x || mNewBoundsAfterMoveToRect . y ; bool resizedByLayout = mNewBoundsAfterMoveToRect . width || mNewBoundsAfterMoveToRect . height ; if ( movedByLayout || resizedByLayout ) { LOG ( "  Another move/resize called during waiting for callback\n" ) ; if ( movedByLayout ) { mBounds . x = mNewBoundsAfterMoveToRect . x ; mBounds . y = mNewBoundsAfterMoveToRect . y ; } if ( resizedByLayout ) { mBounds . width = mNewBoundsAfterMoveToRect . width ; mBounds . height = mNewBoundsAfterMoveToRect . height ; if ( mCompositorSession && ! wr :: WindowSizeSanityCheck ( mBounds . width , mBounds . height ) ) { gfxCriticalNoteOnce < < "Invalid mNewBoundsAfterMoveToRect in PopupCallback " < < mBounds < < " size state " < < mSizeState ; } } mNewBoundsAfterMoveToRect = LayoutDeviceIntRect ( 0 , 0 , 0 , 0 ) ; NativeMoveResize ( movedByLayout , resizedByLayout ) ; return ; } LOG ( "  orig mBounds [%d, %d] -> [%d x %d]\n" , mBounds . x , mBounds . y , mBounds . width , mBounds . height ) ; LayoutDeviceIntRect newBounds = [ & ] { GdkRectangle finalRect = * aFinalSize ; GdkPoint parent = WaylandGetParentPosition ( ) ; finalRect . x += parent . x ; finalRect . y += parent . y ; return GdkRectToDevicePixels ( finalRect ) ; } ( ) ; LOG ( "  new mBounds [%d, %d] -> [%d x %d]" , newBounds . x , newBounds . y , newBounds . width , newBounds . height ) ; bool needsPositionUpdate = newBounds . TopLeft ( ) != mBounds . TopLeft ( ) ; bool needsSizeUpdate = newBounds . Size ( ) != mBounds . Size ( ) ; if ( needsPositionUpdate ) { if ( StaticPrefs :: layout_css_devPixelsPerPx ( ) > 0 || gfxPlatformGtk :: GetFontScaleFactor ( ) != 1 ) { bool roundingError = ( abs ( newBounds . x - mBounds . x ) < 2 && abs ( newBounds . y - mBounds . y ) < 2 ) ; if ( roundingError ) { GdkPoint topLeft = DevicePixelsToGdkPointRoundDown ( mBounds . TopLeft ( ) ) ; LOG ( "  apply rounding error workaround, move to %d, %d" , topLeft . x , topLeft . y ) ; gtk_window_move ( GTK_WINDOW ( mShell ) , topLeft . x , topLeft . y ) ; needsPositionUpdate = false ; } } } if ( needsSizeUpdate ) { if ( newBounds . width < mBounds . width ) { mMoveToRectPopupSize . width = newBounds . width ; } if ( newBounds . height < mBounds . height ) { mMoveToRectPopupSize . height = newBounds . height ; } LOG ( "  mMoveToRectPopupSize set to [%d, %d]" , mMoveToRectPopupSize . width , mMoveToRectPopupSize . height ) ; } mBounds = newBounds ; if ( mCompositorSession && ! wr :: WindowSizeSanityCheck ( mBounds . width , mBounds . height ) ) { gfxCriticalNoteOnce < < "Invalid mBounds in PopupCallback " < < mBounds < < " size state " < < mSizeState ; } WaylandPopupPropagateChangesToLayout ( needsPositionUpdate , needsSizeUpdate ) ; }
vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) { ssize_t l , ll , o ; double now ; uint8_t * ptr ; struct vsb * synth_body ; CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ; AN ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ; assert ( bo -> director_state == DIR_S_NULL ) ; wrk -> stats -> fetch_failed ++ ; now = W_TIM_real ( wrk ) ; VSLb_ts_busyobj ( bo , "Error" , now ) ; if ( bo -> fetch_objcore -> stobj -> stevedore != NULL ) ObjFreeObj ( bo -> wrk , bo -> fetch_objcore ) ; HTTP_Setup ( bo -> beresp , bo -> ws , bo -> vsl , SLT_BerespMethod ) ; http_PutResponse ( bo -> beresp , "HTTP/1.1" , 503 , "Backend fetch failed" ) ; http_TimeHeader ( bo -> beresp , "Date: " , now ) ; http_SetHeader ( bo -> beresp , "Server: Varnish" ) ; bo -> fetch_objcore -> t_origin = now ; if ( ! VTAILQ_EMPTY ( & bo -> fetch_objcore -> objhead -> waitinglist ) ) { bo -> fetch_objcore -> ttl = 1 ; bo -> fetch_objcore -> grace = 5 ; bo -> fetch_objcore -> keep = 5 ; } else { bo -> fetch_objcore -> ttl = 0 ; bo -> fetch_objcore -> grace = 0 ; bo -> fetch_objcore -> keep = 0 ; } synth_body = VSB_new_auto ( ) ; AN ( synth_body ) ; VCL_backend_error_method ( bo -> vcl , wrk , NULL , bo , synth_body ) ; AZ ( VSB_finish ( synth_body ) ) ; if ( wrk -> handling == VCL_RET_ABANDON || wrk -> handling == VCL_RET_FAIL ) { VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } if ( wrk -> handling == VCL_RET_RETRY ) { VSB_destroy ( & synth_body ) ; if ( bo -> retries ++ < cache_param -> max_retries ) return ( F_STP_RETRY ) ; VSLb ( bo -> vsl , SLT_VCL_Error , "Too many retries, failing" ) ; return ( F_STP_FAIL ) ; } assert ( wrk -> handling == VCL_RET_DELIVER ) ; bo -> vfc -> bo = bo ; bo -> vfc -> wrk = bo -> wrk ; bo -> vfc -> oc = bo -> fetch_objcore ; bo -> vfc -> http = bo -> beresp ; bo -> vfc -> esi_req = bo -> bereq ; if ( vbf_beresp2obj ( bo ) ) { ( void ) VFP_Error ( bo -> vfc , "Could not get storage" ) ; VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } ll = VSB_len ( synth_body ) ; o = 0 ; while ( ll > 0 ) { l = ll ; if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ; memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ; VFP_Extend ( bo -> vfc , l ) ; ll -= l ; o += l ; } AZ ( ObjSetU64 ( wrk , bo -> fetch_objcore , OA_LEN , o ) ) ; VSB_destroy ( & synth_body ) ; HSH_Unbusy ( wrk , bo -> fetch_objcore ) ; ObjSetState ( wrk , bo -> fetch_objcore , BOS_FINISHED ) ; return ( F_STP_DONE ) ; }
status_t Parcel :: writeNativeHandleNoDup ( const native_handle_t * handle , bool embedded , size_t parent_buffer_handle , size_t parent_offset ) { struct binder_fd_array_object fd_array ; size_t buffer_handle ; status_t status = OK ; if ( handle == nullptr ) { status = writeUint64 ( 0 ) ; return status ; } size_t native_handle_size = sizeof ( native_handle_t ) + handle -> numFds * sizeof ( int ) + handle -> numInts * sizeof ( int ) ; writeUint64 ( native_handle_size ) ; if ( embedded ) { status = writeEmbeddedBuffer ( ( void * ) handle , native_handle_size , & buffer_handle , parent_buffer_handle , parent_offset ) ; } else { status = writeBuffer ( ( void * ) handle , native_handle_size , & buffer_handle ) ; } if ( status != OK ) { return status ; } fd_array . hdr . type = BINDER_TYPE_FDA ; fd_array . num_fds = handle -> numFds ; fd_array . parent = buffer_handle ; fd_array . parent_offset = offsetof ( native_handle_t , data ) ; return writeObject ( fd_array ) ; }
xmlXPathRegisterNs ( xmlXPathContextPtr ctxt , const xmlChar * prefix , const xmlChar * ns_uri ) { if ( ctxt == NULL ) return ( - 1 ) ; if ( prefix == NULL ) return ( - 1 ) ; if ( prefix [ 0 ] == 0 ) return ( - 1 ) ; if ( ctxt -> nsHash == NULL ) ctxt -> nsHash = xmlHashCreate ( 10 ) ; if ( ctxt -> nsHash == NULL ) return ( - 1 ) ; if ( ns_uri == NULL ) return ( xmlHashRemoveEntry ( ctxt -> nsHash , prefix , ( xmlHashDeallocator ) xmlFree ) ) ; return ( xmlHashUpdateEntry ( ctxt -> nsHash , prefix , ( void * ) xmlStrdup ( ns_uri ) , ( xmlHashDeallocator ) xmlFree ) ) ; }
LoadInfo :: LoadInfo ( const LoadInfo & rhs ) : mLoadingPrincipal ( rhs . mLoadingPrincipal ) , mTriggeringPrincipal ( rhs . mTriggeringPrincipal ) , mPrincipalToInherit ( rhs . mPrincipalToInherit ) , mSandboxedLoadingPrincipal ( rhs . mSandboxedLoadingPrincipal ) , mResultPrincipalURI ( rhs . mResultPrincipalURI ) , mClientInfo ( rhs . mClientInfo ) , mController ( rhs . mController ) , mLoadingContext ( rhs . mLoadingContext ) , mContextForTopLevelLoad ( rhs . mContextForTopLevelLoad ) , mSecurityFlags ( rhs . mSecurityFlags ) , mInternalContentPolicyType ( rhs . mInternalContentPolicyType ) , mTainting ( rhs . mTainting ) , mUpgradeInsecureRequests ( rhs . mUpgradeInsecureRequests ) , mVerifySignedContent ( rhs . mVerifySignedContent ) , mEnforceSRI ( rhs . mEnforceSRI ) , mForceAllowDataURI ( rhs . mForceAllowDataURI ) , mForceInheritPrincipalDropped ( rhs . mForceInheritPrincipalDropped ) , mInnerWindowID ( rhs . mInnerWindowID ) , mOuterWindowID ( rhs . mOuterWindowID ) , mParentOuterWindowID ( rhs . mParentOuterWindowID ) , mTopOuterWindowID ( rhs . mTopOuterWindowID ) , mFrameOuterWindowID ( rhs . mFrameOuterWindowID ) , mEnforceSecurity ( rhs . mEnforceSecurity ) , mInitialSecurityCheckDone ( rhs . mInitialSecurityCheckDone ) , mIsThirdPartyContext ( rhs . mIsThirdPartyContext ) , mOriginAttributes ( rhs . mOriginAttributes ) , mRedirectChainIncludingInternalRedirects ( rhs . mRedirectChainIncludingInternalRedirects ) , mRedirectChain ( rhs . mRedirectChain ) , mAncestorPrincipals ( rhs . mAncestorPrincipals ) , mAncestorOuterWindowIDs ( rhs . mAncestorOuterWindowIDs ) , mCorsUnsafeHeaders ( rhs . mCorsUnsafeHeaders ) , mForcePreflight ( rhs . mForcePreflight ) , mIsPreflight ( rhs . mIsPreflight ) , mLoadTriggeredFromExternal ( rhs . mLoadTriggeredFromExternal ) , mServiceWorkerTaintingSynthesized ( rhs . mServiceWorkerTaintingSynthesized ) , mForceHSTSPriming ( rhs . mForceHSTSPriming ) , mMixedContentWouldBlock ( rhs . mMixedContentWouldBlock ) , mIsHSTSPriming ( rhs . mIsHSTSPriming ) , mIsHSTSPrimingUpgrade ( rhs . mIsHSTSPrimingUpgrade ) { }
TokenStream :: SourceCoords :: fill ( const TokenStream :: SourceCoords & other ) { JS_ASSERT ( lineStartOffsets_ . back ( ) == MAX_PTR ) ; JS_ASSERT ( other . lineStartOffsets_ . back ( ) == MAX_PTR ) ; if ( lineStartOffsets_ . length ( ) >= other . lineStartOffsets_ . length ( ) ) return ; uint32_t sentinelIndex = lineStartOffsets_ . length ( ) - 1 ; lineStartOffsets_ [ sentinelIndex ] = other . lineStartOffsets_ [ sentinelIndex ] ; for ( size_t i = sentinelIndex + 1 ; i < other . lineStartOffsets_ . length ( ) ; i ++ ) ( void ) lineStartOffsets_ . append ( other . lineStartOffsets_ [ i ] ) ; }
nsDocument :: MaybePreLoadImage ( nsIURI * uri ) { if ( nsContentUtils :: IsImageInCache ( uri ) ) { return ; } nsCOMPtr < imgIRequest > request ; nsresult rv = nsContentUtils :: LoadImage ( uri , this , NodePrincipal ( ) , mDocumentURI , nsnull , nsIRequest :: LOAD_NORMAL , getter_AddRefs ( request ) ) ; if ( NS_SUCCEEDED ( rv ) ) { mPreloadingImages . AppendObject ( request ) ; } }
static void sctp_v6_get_dst ( struct sctp_transport * t , union sctp_addr * saddr , struct flowi * fl , struct sock * sk ) { struct sctp_association * asoc = t -> asoc ; struct dst_entry * dst = NULL ; struct flowi6 * fl6 = & fl -> u . ip6 ; struct sctp_bind_addr * bp ; struct sctp_sockaddr_entry * laddr ; union sctp_addr * baddr = NULL ; union sctp_addr * daddr = & t -> ipaddr ; union sctp_addr dst_saddr ; __u8 matchlen = 0 ; __u8 bmatchlen ; sctp_scope_t scope ; memset ( fl6 , 0 , sizeof ( struct flowi6 ) ) ; fl6 -> daddr = daddr -> v6 . sin6_addr ; fl6 -> fl6_dport = daddr -> v6 . sin6_port ; fl6 -> flowi6_proto = IPPROTO_SCTP ; if ( ipv6_addr_type ( & daddr -> v6 . sin6_addr ) & IPV6_ADDR_LINKLOCAL ) fl6 -> flowi6_oif = daddr -> v6 . sin6_scope_id ; pr_debug ( "%s: dst=%pI6 " , __func__ , & fl6 -> daddr ) ; if ( asoc ) fl6 -> fl6_sport = htons ( asoc -> base . bind_addr . port ) ; if ( saddr ) { fl6 -> saddr = saddr -> v6 . sin6_addr ; fl6 -> fl6_sport = saddr -> v6 . sin6_port ; pr_debug ( "src=%pI6 - " , & fl6 -> saddr ) ; } dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; if ( ! asoc || saddr ) goto out ; bp = & asoc -> base . bind_addr ; scope = sctp_scope ( daddr ) ; if ( ! IS_ERR ( dst ) ) { sctp_v6_to_addr ( & dst_saddr , & fl6 -> saddr , htons ( bp -> port ) ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( laddr , & bp -> address_list , list ) { if ( ! laddr -> valid || ( laddr -> state != SCTP_ADDR_SRC ) ) continue ; if ( ( laddr -> a . sa . sa_family == AF_INET6 ) && ( sctp_v6_cmp_addr ( & dst_saddr , & laddr -> a ) ) ) { rcu_read_unlock ( ) ; goto out ; } } rcu_read_unlock ( ) ; dst_release ( dst ) ; dst = NULL ; } rcu_read_lock ( ) ; list_for_each_entry_rcu ( laddr , & bp -> address_list , list ) { if ( ! laddr -> valid ) continue ; if ( ( laddr -> state == SCTP_ADDR_SRC ) && ( laddr -> a . sa . sa_family == AF_INET6 ) && ( scope <= sctp_scope ( & laddr -> a ) ) ) { bmatchlen = sctp_v6_addr_match_len ( daddr , & laddr -> a ) ; if ( ! baddr || ( matchlen < bmatchlen ) ) { baddr = & laddr -> a ; matchlen = bmatchlen ; } } } rcu_read_unlock ( ) ; if ( baddr ) { fl6 -> saddr = baddr -> v6 . sin6_addr ; fl6 -> fl6_sport = baddr -> v6 . sin6_port ; dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; } out : if ( ! IS_ERR_OR_NULL ( dst ) ) { struct rt6_info * rt ; rt = ( struct rt6_info * ) dst ; t -> dst = dst ; t -> dst_cookie = rt -> rt6i_node ? rt -> rt6i_node -> fn_sernum : 0 ; pr_debug ( "rt6_dst:%pI6 rt6_src:%pI6\n" , & rt -> rt6i_dst . addr , & fl6 -> saddr ) ; } else { t -> dst = NULL ; pr_debug ( "no route\n" ) ; } }
PlanarYCbCrImage :: SetDataNoCopy ( const Data & aData ) { mData = aData ; mSize = aData . mPicSize ; }
ogg_int32_t * floor0_inverse1 ( vorbis_dsp_state * vd , vorbis_info_floor * i , ogg_int32_t * lsp ) { vorbis_info_floor0 * info = ( vorbis_info_floor0 * ) i ; int j , k ; int ampraw = oggpack_read ( & vd -> opb , info -> ampbits ) ; if ( ampraw > 0 ) { long maxval = ( 1 < < info -> ampbits ) - 1 ; int amp = ( ( ampraw * info -> ampdB ) < < 4 ) / maxval ; int booknum = oggpack_read ( & vd -> opb , _ilog ( info -> numbooks ) ) ; if ( booknum != - 1 && booknum < info -> numbooks ) { codec_setup_info * ci = ( codec_setup_info * ) vd -> vi -> codec_setup ; codebook * b = ci -> book_param + info -> books [ booknum ] ; ogg_int32_t last = 0 ; for ( j = 0 ; j < info -> order ; j += b -> dim ) if ( vorbis_book_decodev_set ( b , lsp + j , & vd -> opb , b -> dim , - 24 ) == - 1 ) goto eop ; for ( j = 0 ; j < info -> order ; ) { for ( k = 0 ; k < b -> dim ; k ++ , j ++ ) lsp [ j ] += last ; last = lsp [ j - 1 ] ; } lsp [ info -> order ] = amp ; return ( lsp ) ; } } eop : return ( NULL ) ; }
XPCArrayHomogenizer :: GetTypeForArray ( JSContext * cx , HandleObject array , uint32_t length , nsXPTType * resultType , nsID * resultID ) { Type state = tUnk ; Type type ; RootedValue val ( cx ) ; RootedObject jsobj ( cx ) ; for ( uint32_t i = 0 ; i < length ; i ++ ) { if ( ! JS_GetElement ( cx , array , i , & val ) ) return false ; if ( val . isInt32 ( ) ) { type = tInt ; } else if ( val . isDouble ( ) ) { type = tDbl ; } else if ( val . isBoolean ( ) ) { type = tBool ; } else if ( val . isUndefined ( ) ) { state = tVar ; break ; } else if ( val . isNull ( ) ) { type = tNull ; } else if ( val . isString ( ) ) { type = tStr ; } else { MOZ_ASSERT ( val . isObject ( ) , "invalid type of jsval!" ) ; jsobj = & val . toObject ( ) ; if ( JS_IsArrayObject ( cx , jsobj ) ) type = tArr ; else if ( xpc_JSObjectIsID ( cx , jsobj ) ) type = tID ; else type = tISup ; } MOZ_ASSERT ( state != tErr , "bad state table!" ) ; MOZ_ASSERT ( type != tErr , "bad type!" ) ; MOZ_ASSERT ( type != tVar , "bad type!" ) ; MOZ_ASSERT ( type != tUnk , "bad type!" ) ; state = StateTable [ state ] [ type ] ; MOZ_ASSERT ( state != tErr , "bad state table!" ) ; MOZ_ASSERT ( state != tUnk , "bad state table!" ) ; if ( state == tVar ) break ; } switch ( state ) { case tInt : * resultType = nsXPTType ( ( uint8_t ) TD_INT32 ) ; break ; case tDbl : * resultType = nsXPTType ( ( uint8_t ) TD_DOUBLE ) ; break ; case tBool : * resultType = nsXPTType ( ( uint8_t ) TD_BOOL ) ; break ; case tStr : * resultType = nsXPTType ( ( uint8_t ) TD_PWSTRING ) ; break ; case tID : * resultType = nsXPTType ( ( uint8_t ) TD_PNSIID ) ; break ; case tISup : * resultType = nsXPTType ( ( uint8_t ) TD_INTERFACE_IS_TYPE ) ; * resultID = NS_GET_IID ( nsISupports ) ; break ; case tNull : case tVar : * resultType = nsXPTType ( ( uint8_t ) TD_INTERFACE_IS_TYPE ) ; * resultID = NS_GET_IID ( nsIVariant ) ; break ; case tArr : case tUnk : case tErr : default : NS_ERROR ( "bad state" ) ; return false ; } return true ; }
IndexedDatabaseManager :: GetFileManager ( const nsACString & aOrigin , const nsAString & aDatabaseName ) { nsTArray < nsRefPtr < FileManager > > * array ; if ( ! mFileManagers . Get ( aOrigin , & array ) ) { return nullptr ; } for ( uint32_t i = 0 ; i < array -> Length ( ) ; i ++ ) { nsRefPtr < FileManager > & fileManager = array -> ElementAt ( i ) ; if ( fileManager -> DatabaseName ( ) . Equals ( aDatabaseName ) ) { nsRefPtr < FileManager > result = fileManager ; return result . forget ( ) ; } } return nullptr ; }
NativeObjectsExplorer :: NativeObjectsExplorer ( HeapSnapshot * snapshot , SnapshottingProgressReportingInterface * progress ) : isolate_ ( snapshot -> profiler ( ) -> heap_object_map ( ) -> heap ( ) -> isolate ( ) ) , snapshot_ ( snapshot ) , names_ ( snapshot_ -> profiler ( ) -> names ( ) ) , embedder_queried_ ( false ) , native_groups_ ( 0 , SeededStringHasher ( isolate_ -> heap ( ) -> HashSeed ( ) ) ) , synthetic_entries_allocator_ ( new BasicHeapEntriesAllocator ( snapshot , HeapEntry :: kSynthetic ) ) , native_entries_allocator_ ( new BasicHeapEntriesAllocator ( snapshot , HeapEntry :: kNative ) ) , embedder_graph_entries_allocator_ ( new EmbedderGraphEntriesAllocator ( snapshot ) ) , filler_ ( nullptr ) { }
static int smb2_get_info_sec ( struct ksmbd_work * work , struct smb2_query_info_req * req , struct smb2_query_info_rsp * rsp ) { struct ksmbd_file * fp ; struct user_namespace * user_ns ; struct smb_ntsd * pntsd = ( struct smb_ntsd * ) rsp -> Buffer , * ppntsd = NULL ; struct smb_fattr fattr = { { 0 } } ; struct inode * inode ; __u32 secdesclen ; unsigned int id = KSMBD_NO_FID , pid = KSMBD_NO_FID ; int addition_info = le32_to_cpu ( req -> AdditionalInformation ) ; int rc ; if ( addition_info & ~ ( OWNER_SECINFO | GROUP_SECINFO | DACL_SECINFO | PROTECTED_DACL_SECINFO | UNPROTECTED_DACL_SECINFO ) ) { ksmbd_debug ( SMB , "Unsupported addition info: 0x%x)\n" , addition_info ) ; pntsd -> revision = cpu_to_le16 ( 1 ) ; pntsd -> type = cpu_to_le16 ( SELF_RELATIVE | DACL_PROTECTED ) ; pntsd -> osidoffset = 0 ; pntsd -> gsidoffset = 0 ; pntsd -> sacloffset = 0 ; pntsd -> dacloffset = 0 ; secdesclen = sizeof ( struct smb_ntsd ) ; rsp -> OutputBufferLength = cpu_to_le32 ( secdesclen ) ; inc_rfc1001_len ( work -> response_buf , secdesclen ) ; return 0 ; } if ( work -> next_smb2_rcv_hdr_off ) { if ( ! has_file_id ( req -> VolatileFileId ) ) { ksmbd_debug ( SMB , "Compound request set FID = %llu\n" , work -> compound_fid ) ; id = work -> compound_fid ; pid = work -> compound_pfid ; } } if ( ! has_file_id ( id ) ) { id = req -> VolatileFileId ; pid = req -> PersistentFileId ; } fp = ksmbd_lookup_fd_slow ( work , id , pid ) ; if ( ! fp ) return - ENOENT ; user_ns = file_mnt_user_ns ( fp -> filp ) ; inode = file_inode ( fp -> filp ) ; ksmbd_acls_fattr ( & fattr , user_ns , inode ) ; if ( test_share_config_flag ( work -> tcon -> share_conf , KSMBD_SHARE_FLAG_ACL_XATTR ) ) ksmbd_vfs_get_sd_xattr ( work -> conn , user_ns , fp -> filp -> f_path . dentry , & ppntsd ) ; rc = build_sec_desc ( user_ns , pntsd , ppntsd , addition_info , & secdesclen , & fattr ) ; posix_acl_release ( fattr . cf_acls ) ; posix_acl_release ( fattr . cf_dacls ) ; kfree ( ppntsd ) ; ksmbd_fd_put ( work , fp ) ; if ( rc ) return rc ; rsp -> OutputBufferLength = cpu_to_le32 ( secdesclen ) ; inc_rfc1001_len ( work -> response_buf , secdesclen ) ; return 0 ; }
RasterImage :: SyncDecode ( ) { PROFILER_LABEL_PRINTF ( "RasterImage" , "SyncDecode" , "%s" , GetURIString ( ) . get ( ) ) ; ; if ( mDecoder && mDecoder -> IsSizeDecode ( ) ) { nsresult rv = DecodePool :: Singleton ( ) -> DecodeUntilSizeAvailable ( this ) ; CONTAINER_ENSURE_SUCCESS ( rv ) ; if ( ! mHasSize ) { mWantFullDecode = true ; return NS_ERROR_NOT_AVAILABLE ; } } MutexAutoLock imgLock ( mDecodingMutex ) ; NS_ABORT_IF_FALSE ( ! mInDecoder , "Yikes, forcing sync in reentrant call!" ) ; if ( mDecodeRequest ) { if ( mDecodeRequest -> mRequestStatus == DecodeRequest :: REQUEST_WORK_DONE ) { nsresult rv = FinishedSomeDecoding ( ) ; CONTAINER_ENSURE_SUCCESS ( rv ) ; } } nsresult rv ; if ( mDecoded ) return NS_OK ; if ( mBytesDecoded > mSourceData . Length ( ) ) return NS_OK ; if ( mDecoder && mDecoder -> GetDecodeFlags ( ) != mFrameDecodeFlags ) { nsresult rv = FinishedSomeDecoding ( eShutdownIntent_NotNeeded ) ; CONTAINER_ENSURE_SUCCESS ( rv ) ; } if ( mDecoder && mDecoder -> NeedsNewFrame ( ) ) { mDecoder -> AllocateFrame ( ) ; mDecodeRequest -> mAllocatedNewFrame = true ; } if ( ! mDecoder ) { rv = InitDecoder ( false ) ; CONTAINER_ENSURE_SUCCESS ( rv ) ; } { AutoSetSyncDecode syncDecode ( mDecoder ) ; rv = DecodeSomeData ( mSourceData . Length ( ) - mBytesDecoded ) ; CONTAINER_ENSURE_SUCCESS ( rv ) ; } nsRefPtr < Decoder > kungFuDeathGrip = mDecoder ; mInDecoder = true ; mDecoder -> FlushInvalidations ( ) ; mInDecoder = false ; rv = FinishedSomeDecoding ( ) ; CONTAINER_ENSURE_SUCCESS ( rv ) ; if ( mDecoder ) { DecodePool :: Singleton ( ) -> RequestDecode ( this ) ; } return mError ? NS_ERROR_FAILURE : NS_OK ; }
xmlCharEncFirstLineInput ( xmlParserInputBufferPtr input , int len ) { int ret = - 2 ; size_t written ; size_t toconv ; int c_in ; int c_out ; xmlBufPtr in ; xmlBufPtr out ; if ( ( input == NULL ) || ( input -> encoder == NULL ) || ( input -> buffer == NULL ) || ( input -> raw == NULL ) ) return ( - 1 ) ; out = input -> buffer ; in = input -> raw ; toconv = xmlBufUse ( in ) ; if ( toconv == 0 ) return ( 0 ) ; written = xmlBufAvail ( out ) - 1 ; if ( len >= 0 ) { if ( toconv > ( unsigned int ) len ) toconv = len ; } else { if ( toconv > 180 ) toconv = 180 ; } if ( toconv * 2 >= written ) { xmlBufGrow ( out , toconv * 2 ) ; written = xmlBufAvail ( out ) - 1 ; } if ( written > 360 ) written = 360 ; c_in = toconv ; c_out = written ; if ( input -> encoder -> input != NULL ) { ret = input -> encoder -> input ( xmlBufEnd ( out ) , & c_out , xmlBufContent ( in ) , & c_in ) ; xmlBufShrink ( in , c_in ) ; xmlBufAddLen ( out , c_out ) ; } #ifdef LIBXML_ICONV_ENABLED else if ( input -> encoder -> iconv_in != NULL ) { ret = xmlIconvWrapper ( input -> encoder -> iconv_in , xmlBufEnd ( out ) , & c_out , xmlBufContent ( in ) , & c_in ) ; xmlBufShrink ( in , c_in ) ; xmlBufAddLen ( out , c_out ) ; if ( ret == - 1 ) ret = - 3 ; } #endif /* LIBXML_ICONV_ENABLED */ #ifdef LIBXML_ICU_ENABLED else if ( input -> encoder -> uconv_in != NULL ) { ret = xmlUconvWrapper ( input -> encoder -> uconv_in , 1 , xmlBufEnd ( out ) , & c_out , xmlBufContent ( in ) , & c_in ) ; xmlBufShrink ( in , c_in ) ; xmlBufAddLen ( out , c_out ) ; if ( ret == - 1 ) ret = - 3 ; } #endif /* LIBXML_ICU_ENABLED */ switch ( ret ) { case 0 : #ifdef DEBUG_ENCODING xmlGenericError ( xmlGenericErrorContext , "converted %d bytes to %d bytes of input\n" , c_in , c_out ) ; #endif break ; case - 1 : #ifdef DEBUG_ENCODING xmlGenericError ( xmlGenericErrorContext , "converted %d bytes to %d bytes of input, %d left\n" , c_in , c_out , ( int ) xmlBufUse ( in ) ) ; #endif break ; case - 3 : #ifdef DEBUG_ENCODING xmlGenericError ( xmlGenericErrorContext , "converted %d bytes to %d bytes of input, %d left\n" , c_in , c_out , ( int ) xmlBufUse ( in ) ) ; #endif break ; case - 2 : { char buf [ 50 ] ; const xmlChar * content = xmlBufContent ( in ) ; snprintf ( & buf [ 0 ] , 49 , "0x%02X 0x%02X 0x%02X 0x%02X" , content [ 0 ] , content [ 1 ] , content [ 2 ] , content [ 3 ] ) ; buf [ 49 ] = 0 ; xmlEncodingErr ( XML_I18N_CONV_FAILED , "input conversion failed due to input error, bytes %s\n" , buf ) ; } } if ( ret == - 3 ) ret = 0 ; if ( ret == - 1 ) ret = 0 ; return ( ret ) ; }
SampleTable :: setSampleAuxiliaryInformationOffsetParams ( off64_t data_offset , size_t data_size , uint32_t drm_scheme ) { off64_t data_end = data_offset + data_size ; uint8_t version ; uint32_t aux_type ; status_t err = validateCencBoxHeader ( mDataSource , data_offset , & version , & aux_type ) ; if ( err != OK ) { return err ; } if ( aux_type && aux_type != kAuxTypeCenc && drm_scheme != kAuxTypeCenc ) { return OK ; } if ( ! mCencOffsets . isEmpty ( ) ) { ALOGE ( "duplicate cenc saio box" ) ; return ERROR_MALFORMED ; } uint32_t cencOffsetCount ; if ( ! mDataSource -> getUInt32 ( data_offset , & cencOffsetCount ) ) { ALOGE ( "error reading cenc aux info offset count" ) ; return ERROR_IO ; } data_offset += 4 ; mCencOffsets . setCapacity ( cencOffsetCount ) ; if ( ! version ) { for ( uint32_t i = 0 ; i < cencOffsetCount ; i ++ ) { uint32_t tmp ; if ( ! mDataSource -> getUInt32 ( data_offset , & tmp ) ) { ALOGE ( "error reading cenc aux info offsets" ) ; return ERROR_IO ; } mCencOffsets . push ( tmp ) ; data_offset += 4 ; } } else { for ( uint32_t i = 0 ; i < cencOffsetCount ; i ++ ) { if ( ! mDataSource -> getUInt64 ( data_offset , & mCencOffsets . editItemAt ( i ) ) ) { ALOGE ( "error reading cenc aux info offsets" ) ; return ERROR_IO ; } data_offset += 8 ; } } CHECK ( data_offset == data_end ) ; return parseSampleCencInfo ( ) ; }
void vp9_read_mode_info ( VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * const tile , int mi_row , int mi_col , vp9_reader * r ) { if ( frame_is_intra_only ( cm ) ) read_intra_frame_mode_info ( cm , xd , mi_row , mi_col , r ) ; else read_inter_frame_mode_info ( cm , xd , tile , mi_row , mi_col , r ) ; }
static struct sock * tcp_v6_syn_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; #ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key * key ; #endif struct flowi6 fl6 ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( ! newsk ) return NULL ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; #ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; #endif newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } ireq = inet_rsk ( req ) ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_TCP ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( ! newsk ) goto out_nonewsk ; newsk -> sk_gso_type = SKB_GSO_TCPV6 ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; inet6_sk_rx_dst_set ( newsk , skb ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; tcp_ca_openreq_child ( newsk , dst ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = tcp_mss_clamp ( tcp_sk ( sk ) , dst_metric_advmss ( dst ) ) ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; #ifdef CONFIG_TCP_MD5SIG key = tcp_v6_md5_do_lookup ( sk , & newsk -> sk_v6_daddr ) ; if ( key ) { tcp_md5_do_add ( newsk , ( union tcp_md5_addr * ) & newsk -> sk_v6_daddr , AF_INET6 , key -> key , key -> keylen , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; } #endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; tcp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req ) { tcp_move_syn ( newtp , req ) ; if ( ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) { tcp_v6_restore_cb ( newnp -> pktoptions ) ; skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } } } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : tcp_listendrop ( sk ) ; return NULL ; }
list_dbs ( MYSQL * mysql , const char * wild ) { const char * header ; uint length , counter = 0 ; ulong rowcount = 0L ; char tables [ NAME_LEN + 1 ] , rows [ NAME_LEN + 1 ] ; char query [ 255 ] ; MYSQL_FIELD * field ; MYSQL_RES * result ; MYSQL_ROW row = NULL , rrow ; if ( ! ( result = mysql_list_dbs ( mysql , wild ) ) ) { fprintf ( stderr , "%s: Cannot list databases: %s\n" , my_progname , mysql_error ( mysql ) ) ; return 1 ; } if ( wild && mysql_num_rows ( result ) == 1 ) { row = mysql_fetch_row ( result ) ; if ( ! my_strcasecmp ( & my_charset_latin1 , row [ 0 ] , wild ) ) { mysql_free_result ( result ) ; if ( opt_status ) return list_table_status ( mysql , wild , NULL ) ; else return list_tables ( mysql , wild , NULL ) ; } } if ( wild ) printf ( "Wildcard: %s\n" , wild ) ; header = "Databases" ; length = ( uint ) strlen ( header ) ; field = mysql_fetch_field ( result ) ; if ( length < field -> max_length ) length = field -> max_length ; if ( ! opt_verbose ) print_header ( header , length , NullS ) ; else if ( opt_verbose == 1 ) print_header ( header , length , "Tables" , 6 , NullS ) ; else print_header ( header , length , "Tables" , 6 , "Total Rows" , 12 , NullS ) ; while ( row || ( row = mysql_fetch_row ( result ) ) ) { counter ++ ; if ( opt_verbose ) { if ( ! ( mysql_select_db ( mysql , row [ 0 ] ) ) ) { MYSQL_RES * tresult = mysql_list_tables ( mysql , ( char * ) NULL ) ; if ( mysql_affected_rows ( mysql ) > 0 ) { sprintf ( tables , "%6lu" , ( ulong ) mysql_affected_rows ( mysql ) ) ; rowcount = 0 ; if ( opt_verbose > 1 ) { MYSQL_ROW trow ; while ( ( trow = mysql_fetch_row ( tresult ) ) ) { sprintf ( query , "SELECT COUNT(*) FROM `%s`" , trow [ 0 ] ) ; if ( ! ( mysql_query ( mysql , query ) ) ) { MYSQL_RES * rresult ; if ( ( rresult = mysql_store_result ( mysql ) ) ) { rrow = mysql_fetch_row ( rresult ) ; rowcount += ( ulong ) strtoull ( rrow [ 0 ] , ( char * * ) 0 , 10 ) ; mysql_free_result ( rresult ) ; } } } sprintf ( rows , "%12lu" , rowcount ) ; } } else { sprintf ( tables , "%6d" , 0 ) ; sprintf ( rows , "%12d" , 0 ) ; } mysql_free_result ( tresult ) ; } else { strmov ( tables , "N/A" ) ; strmov ( rows , "N/A" ) ; } } if ( ! opt_verbose ) print_row ( row [ 0 ] , length , 0 ) ; else if ( opt_verbose == 1 ) print_row ( row [ 0 ] , length , tables , 6 , NullS ) ; else print_row ( row [ 0 ] , length , tables , 6 , rows , 12 , NullS ) ; row = NULL ; } print_trailer ( length , ( opt_verbose > 0 ? 6 : 0 ) , ( opt_verbose > 1 ? 12 : 0 ) , 0 ) ; if ( counter && opt_verbose ) printf ( "%u row%s in set.\n" , counter , ( counter > 1 ) ? "s" : "" ) ; mysql_free_result ( result ) ; return 0 ; }
netdev_tx_t ieee80211_monitor_start_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct ieee80211_local * local = wdev_priv ( dev -> ieee80211_ptr ) ; struct ieee80211_chanctx_conf * chanctx_conf ; struct ieee80211_tx_info * info = IEEE80211_SKB_CB ( skb ) ; struct ieee80211_hdr * hdr ; struct ieee80211_sub_if_data * tmp_sdata , * sdata ; struct cfg80211_chan_def * chandef ; u16 len_rthdr ; int hdrlen ; memset ( info , 0 , sizeof ( * info ) ) ; info -> flags = IEEE80211_TX_CTL_REQ_TX_STATUS | IEEE80211_TX_CTL_INJECTED ; if ( ! ieee80211_parse_tx_radiotap ( skb , dev ) ) goto fail ; len_rthdr = ieee80211_get_radiotap_len ( skb -> data ) ; skb_set_mac_header ( skb , len_rthdr ) ; skb_set_network_header ( skb , len_rthdr ) ; skb_set_transport_header ( skb , len_rthdr ) ; if ( skb -> len < len_rthdr + 2 ) goto fail ; hdr = ( struct ieee80211_hdr * ) ( skb -> data + len_rthdr ) ; hdrlen = ieee80211_hdrlen ( hdr -> frame_control ) ; if ( skb -> len < len_rthdr + hdrlen ) goto fail ; if ( ieee80211_is_data ( hdr -> frame_control ) && skb -> len >= len_rthdr + hdrlen + sizeof ( rfc1042_header ) + 2 ) { u8 * payload = ( u8 * ) hdr + hdrlen ; if ( ether_addr_equal ( payload , rfc1042_header ) ) skb -> protocol = cpu_to_be16 ( ( payload [ 6 ] < < 8 ) | payload [ 7 ] ) ; } rcu_read_lock ( ) ; sdata = IEEE80211_DEV_TO_SUB_IF ( dev ) ; list_for_each_entry_rcu ( tmp_sdata , & local -> interfaces , list ) { if ( ! ieee80211_sdata_running ( tmp_sdata ) ) continue ; if ( tmp_sdata -> vif . type == NL80211_IFTYPE_MONITOR || tmp_sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) continue ; if ( ether_addr_equal ( tmp_sdata -> vif . addr , hdr -> addr2 ) ) { sdata = tmp_sdata ; break ; } } chanctx_conf = rcu_dereference ( sdata -> vif . chanctx_conf ) ; if ( ! chanctx_conf ) { tmp_sdata = rcu_dereference ( local -> monitor_sdata ) ; if ( tmp_sdata ) chanctx_conf = rcu_dereference ( tmp_sdata -> vif . chanctx_conf ) ; } if ( chanctx_conf ) chandef = & chanctx_conf -> def ; else if ( ! local -> use_chanctx ) chandef = & local -> _oper_chandef ; else goto fail_rcu ; if ( ! cfg80211_reg_can_beacon ( local -> hw . wiphy , chandef , sdata -> vif . type ) ) goto fail_rcu ; info -> band = chandef -> chan -> band ; ieee80211_select_queue_80211 ( sdata , skb , hdr ) ; skb_set_queue_mapping ( skb , ieee80211_ac_from_tid ( skb -> priority ) ) ; skb_pull ( skb , len_rthdr ) ; ieee80211_xmit ( sdata , NULL , skb ) ; rcu_read_unlock ( ) ; return NETDEV_TX_OK ; fail_rcu : rcu_read_unlock ( ) ; fail : dev_kfree_skb ( skb ) ; return NETDEV_TX_OK ; }
static struct dir * squashfs_opendir ( unsigned int block_start , unsigned int offset , struct inode * * i ) { squashfs_dir_header_2 dirh ; char buffer [ sizeof ( squashfs_dir_entry_2 ) + SQUASHFS_NAME_LEN + 1 ] __attribute__ ( ( aligned ) ) ; squashfs_dir_entry_2 * dire = ( squashfs_dir_entry_2 * ) buffer ; long long start ; int bytes ; int dir_count , size ; struct dir_ent * new_dir ; struct dir * dir ; TRACE ( "squashfs_opendir: inode start block %d, offset %d\n" , block_start , offset ) ; * i = read_inode ( block_start , offset ) ; dir = malloc ( sizeof ( struct dir ) ) ; if ( dir == NULL ) EXIT_UNSQUASH ( "squashfs_opendir: malloc failed!\n" ) ; dir -> dir_count = 0 ; dir -> cur_entry = 0 ; dir -> mode = ( * i ) -> mode ; dir -> uid = ( * i ) -> uid ; dir -> guid = ( * i ) -> gid ; dir -> mtime = ( * i ) -> time ; dir -> xattr = ( * i ) -> xattr ; dir -> dirs = NULL ; if ( ( * i ) -> data == 0 ) return dir ; start = sBlk . s . directory_table_start + ( * i ) -> start ; bytes = lookup_entry ( directory_table_hash , start ) ; if ( bytes == - 1 ) EXIT_UNSQUASH ( "squashfs_opendir: directory block %d not " "found!\n" , block_start ) ; bytes += ( * i ) -> offset ; size = ( * i ) -> data + bytes ; while ( bytes < size ) { if ( swap ) { squashfs_dir_header_2 sdirh ; memcpy ( & sdirh , directory_table + bytes , sizeof ( sdirh ) ) ; SQUASHFS_SWAP_DIR_HEADER_2 ( & dirh , & sdirh ) ; } else memcpy ( & dirh , directory_table + bytes , sizeof ( dirh ) ) ; dir_count = dirh . count + 1 ; TRACE ( "squashfs_opendir: Read directory header @ byte position " "%d, %d directory entries\n" , bytes , dir_count ) ; bytes += sizeof ( dirh ) ; if ( dir_count > SQUASHFS_DIR_COUNT ) { ERROR ( "File system corrupted: too many entries in directory\n" ) ; goto corrupted ; } while ( dir_count -- ) { if ( swap ) { squashfs_dir_entry_2 sdire ; memcpy ( & sdire , directory_table + bytes , sizeof ( sdire ) ) ; SQUASHFS_SWAP_DIR_ENTRY_2 ( dire , & sdire ) ; } else memcpy ( dire , directory_table + bytes , sizeof ( * dire ) ) ; bytes += sizeof ( * dire ) ; if ( dire -> size >= SQUASHFS_NAME_LEN ) { ERROR ( "File system corrupted: filename too long\n" ) ; goto corrupted ; } memcpy ( dire -> name , directory_table + bytes , dire -> size + 1 ) ; dire -> name [ dire -> size + 1 ] = '\0' ; TRACE ( "squashfs_opendir: directory entry %s, inode " "%d:%d, type %d\n" , dire -> name , dirh . start_block , dire -> offset , dire -> type ) ; if ( ( dir -> dir_count % DIR_ENT_SIZE ) == 0 ) { new_dir = realloc ( dir -> dirs , ( dir -> dir_count + DIR_ENT_SIZE ) * sizeof ( struct dir_ent ) ) ; if ( new_dir == NULL ) EXIT_UNSQUASH ( "squashfs_opendir: " "realloc failed!\n" ) ; dir -> dirs = new_dir ; } strcpy ( dir -> dirs [ dir -> dir_count ] . name , dire -> name ) ; dir -> dirs [ dir -> dir_count ] . start_block = dirh . start_block ; dir -> dirs [ dir -> dir_count ] . offset = dire -> offset ; dir -> dirs [ dir -> dir_count ] . type = dire -> type ; dir -> dir_count ++ ; bytes += dire -> size + 1 ; } } return dir ; corrupted : free ( dir -> dirs ) ; free ( dir ) ; return NULL ; }
void Serializer < AllocatorT > :: ObjectSerializer :: SerializeDeferred ( ) { if ( FLAG_trace_serializer ) { PrintF ( " Encoding deferred heap object: " ) ; object_ -> ShortPrint ( ) ; PrintF ( "\n" ) ; } int size = object_ -> Size ( ) ; Map * map = object_ -> map ( ) ; SerializerReference back_reference = serializer_ -> reference_map ( ) -> LookupReference ( object_ ) ; DCHECK ( back_reference . is_back_reference ( ) ) ; CHECK_EQ ( 0 , bytes_processed_so_far_ ) ; bytes_processed_so_far_ = kPointerSize ; serializer_ -> PutAlignmentPrefix ( object_ ) ; sink_ -> Put ( kNewObject + back_reference . space ( ) , "deferred object" ) ; serializer_ -> PutBackReference ( object_ , back_reference ) ; sink_ -> PutInt ( size > > kPointerSizeLog2 , "deferred object size" ) ; SerializeContent ( map , size ) ; }
js_watch_set ( JSContext * cx , JSObject * obj , jsval id , jsval * vp ) { JSRuntime * rt ; JSWatchPoint * wp ; JSScopeProperty * sprop ; jsval propid , userid ; JSScope * scope ; JSBool ok ; rt = cx -> runtime ; DBG_LOCK ( rt ) ; for ( wp = ( JSWatchPoint * ) rt -> watchPointList . next ; & wp -> links != & rt -> watchPointList ; wp = ( JSWatchPoint * ) wp -> links . next ) { sprop = wp -> sprop ; if ( wp -> object == obj && SPROP_USERID ( sprop ) == id && ! ( wp -> flags & JSWP_HELD ) ) { wp -> flags |= JSWP_HELD ; DBG_UNLOCK ( rt ) ; JS_LOCK_OBJ ( cx , obj ) ; propid = ID_TO_VALUE ( sprop -> id ) ; userid = ( sprop -> flags & SPROP_HAS_SHORTID ) ? INT_TO_JSVAL ( sprop -> shortid ) : propid ; scope = OBJ_SCOPE ( obj ) ; JS_UNLOCK_OBJ ( cx , obj ) ; ok = wp -> handler ( cx , obj , propid , SPROP_HAS_VALID_SLOT ( sprop , scope ) ? OBJ_GET_SLOT ( cx , obj , sprop -> slot ) : JSVAL_VOID , vp , wp -> closure ) ; if ( ok ) { JSObject * closure ; JSClass * clasp ; JSFunction * fun ; JSScript * script ; JSBool injectFrame ; uintN nslots ; jsval smallv [ 5 ] ; jsval * argv ; JSStackFrame frame ; JSFrameRegs regs ; closure = ( JSObject * ) wp -> closure ; clasp = OBJ_GET_CLASS ( cx , closure ) ; if ( clasp == & js_FunctionClass ) { fun = GET_FUNCTION_PRIVATE ( cx , closure ) ; script = FUN_SCRIPT ( fun ) ; } else if ( clasp == & js_ScriptClass ) { fun = NULL ; script = ( JSScript * ) JS_GetPrivate ( cx , closure ) ; } else { fun = NULL ; script = NULL ; } nslots = 2 ; injectFrame = JS_TRUE ; if ( fun ) { nslots += FUN_MINARGS ( fun ) ; if ( ! FUN_INTERPRETED ( fun ) ) { nslots += fun -> u . n . extra ; injectFrame = ! ( fun -> flags & JSFUN_FAST_NATIVE ) ; } } if ( injectFrame ) { if ( nslots <= JS_ARRAY_LENGTH ( smallv ) ) { argv = smallv ; } else { argv = ( jsval * ) JS_malloc ( cx , nslots * sizeof ( jsval ) ) ; if ( ! argv ) { DBG_LOCK ( rt ) ; DropWatchPointAndUnlock ( cx , wp , JSWP_HELD ) ; return JS_FALSE ; } } argv [ 0 ] = OBJECT_TO_JSVAL ( closure ) ; argv [ 1 ] = JSVAL_NULL ; memset ( argv + 2 , 0 , ( nslots - 2 ) * sizeof ( jsval ) ) ; memset ( & frame , 0 , sizeof ( frame ) ) ; frame . script = script ; frame . regs = NULL ; if ( script ) { JS_ASSERT ( script -> length >= JSOP_STOP_LENGTH ) ; regs . pc = script -> code + script -> length - JSOP_STOP_LENGTH ; regs . sp = NULL ; frame . regs = & regs ; } frame . callee = closure ; frame . fun = fun ; frame . argv = argv + 2 ; frame . down = js_GetTopStackFrame ( cx ) ; frame . scopeChain = OBJ_GET_PARENT ( cx , closure ) ; cx -> fp = & frame ; } #ifdef __GNUC__ else argv = NULL ; #endif ok = ! wp -> setter || ( ( sprop -> attrs & JSPROP_SETTER ) ? js_InternalCall ( cx , obj , OBJECT_TO_JSVAL ( wp -> setter ) , 1 , vp , vp ) : wp -> setter ( cx , OBJ_THIS_OBJECT ( cx , obj ) , userid , vp ) ) ; if ( injectFrame ) { if ( frame . callobj ) ok &= js_PutCallObject ( cx , & frame ) ; if ( frame . argsobj ) ok &= js_PutArgsObject ( cx , & frame ) ; cx -> fp = frame . down ; if ( argv != smallv ) JS_free ( cx , argv ) ; } } DBG_LOCK ( rt ) ; return DropWatchPointAndUnlock ( cx , wp , JSWP_HELD ) && ok ; } } DBG_UNLOCK ( rt ) ; return JS_TRUE ; }
FastCGIServer :: FastCGIServer ( const std :: string & address , int port , int workers , bool useFileSocket ) : Server ( address , port ) , m_worker ( & m_eventBaseManager ) , m_dispatcher ( workers , workers , RuntimeOption :: ServerThreadDropCacheTimeoutSeconds , RuntimeOption :: ServerThreadDropStack , this , RuntimeOption :: ServerThreadJobLIFOSwitchThreshold , RuntimeOption :: ServerThreadJobMaxQueuingMilliSeconds , RequestPriority :: k_numPriorities ) { folly :: SocketAddress sock_addr ; if ( useFileSocket ) { sock_addr . setFromPath ( address ) ; } else if ( address . empty ( ) ) { sock_addr . setFromLocalPort ( port ) ; } else { sock_addr . setFromHostPort ( address , port ) ; } m_socketConfig . bindAddress = sock_addr ; m_socketConfig . acceptBacklog = RuntimeOption :: ServerBacklog ; std :: chrono :: seconds timeout ; if ( RuntimeOption :: ConnectionTimeoutSeconds >= 0 ) { timeout = std :: chrono :: seconds ( RuntimeOption :: ConnectionTimeoutSeconds ) ; } else { timeout = std :: chrono :: seconds ( 120 ) ; } m_socketConfig . connectionIdleTimeout = timeout ; }
static int jpc_pi_nextcprl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { pirlvl = pi -> picomp -> pirlvls ; pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) < < ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ; pi -> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) < < ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ; for ( rlvlno = 1 , pirlvl = & pi -> picomp -> pirlvls [ 1 ] ; rlvlno < pi -> picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) < < ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) < < ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp < < r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp < < r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; if ( ( ( pi -> x == pi -> xstart && ( ( trx0 < < r ) % ( 1 < < rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp < < rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 < < r ) % ( 1 < < rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp < < rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp < < r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp < < r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
long _book_maptype1_quantvals ( codebook * b ) { int bits = _ilog ( b -> entries ) ; int vals = b -> entries > > ( ( bits - 1 ) * ( b -> dim - 1 ) / b -> dim ) ; while ( 1 ) { long acc = 1 ; long acc1 = 1 ; int i ; for ( i = 0 ; i < b -> dim ; i ++ ) { acc *= vals ; acc1 *= vals + 1 ; } if ( acc <= b -> entries && acc1 > b -> entries ) { return ( vals ) ; } else { if ( acc > b -> entries ) { vals -- ; } else { vals ++ ; } } } }
void Compute ( OpKernelContext * context ) override { const Tensor & diagonal = context -> input ( 0 ) ; int32 lower_diag_index = 0 ; int32 upper_diag_index = 0 ; int32 num_rows = - 1 ; int32 num_cols = - 1 ; T padding_value ( 0 ) ; if ( context -> num_inputs ( ) > kNumV1Inputs ) { auto & diag_index = context -> input ( 1 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( diag_index . shape ( ) ) || TensorShapeUtils :: IsVector ( diag_index . shape ( ) ) , errors :: InvalidArgument ( "diag_index must be a scalar or vector, received shape: " , diag_index . shape ( ) . DebugString ( ) ) ) ; lower_diag_index = diag_index . flat < int32 > ( ) ( 0 ) ; upper_diag_index = lower_diag_index ; if ( TensorShapeUtils :: IsVector ( diag_index . shape ( ) ) ) { auto diag_index_size = diag_index . dim_size ( 0 ) ; OP_REQUIRES ( context , 0 < diag_index_size && diag_index_size <= 2 , errors :: InvalidArgument ( "diag_index must have only one or two elements, received " , diag_index_size , " elements." ) ) ; if ( diag_index_size > 1 ) { upper_diag_index = diag_index . flat < int32 > ( ) ( 1 ) ; } } num_rows = context -> input ( 2 ) . flat < int32 > ( ) ( 0 ) ; num_cols = context -> input ( 3 ) . flat < int32 > ( ) ( 0 ) ; padding_value = context -> input ( 4 ) . flat < T > ( ) ( 0 ) ; } const TensorShape & diagonal_shape = diagonal . shape ( ) ; const int diag_rank = diagonal_shape . dims ( ) ; const Eigen :: Index num_diags = upper_diag_index - lower_diag_index + 1 ; OP_REQUIRES ( context , TensorShapeUtils :: IsVectorOrHigher ( diagonal_shape ) , errors :: InvalidArgument ( "diagonal must be at least 1-dim, received shape: " , diagonal . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , lower_diag_index <= upper_diag_index , errors :: InvalidArgument ( "lower_diag_index must not be larger than upper_diag_index: " , lower_diag_index , " > " , upper_diag_index ) ) ; OP_REQUIRES ( context , lower_diag_index == upper_diag_index || diagonal_shape . dim_size ( diag_rank - 2 ) == num_diags , errors :: InvalidArgument ( "The number of diagonals provided in the input does not " "match the lower_diag_index and upper_diag_index range." ) ) ; const Eigen :: Index max_diag_len = diagonal_shape . dim_size ( diag_rank - 1 ) ; const int32 min_num_rows = max_diag_len - std :: min ( upper_diag_index , 0 ) ; const int32 min_num_cols = max_diag_len + std :: max ( lower_diag_index , 0 ) ; OP_REQUIRES ( context , num_rows == - 1 || num_rows >= min_num_rows , errors :: InvalidArgument ( "The number of rows is too small." ) ) ; OP_REQUIRES ( context , num_cols == - 1 || num_cols >= min_num_cols , errors :: InvalidArgument ( "The number of columns is too small." ) ) ; if ( num_rows == - 1 && num_cols == - 1 ) { num_rows = std :: max ( min_num_rows , min_num_cols ) ; num_cols = num_rows ; } else if ( num_rows == - 1 ) { num_rows = min_num_rows ; } else if ( num_cols == - 1 ) { num_cols = min_num_cols ; } OP_REQUIRES ( context , num_rows == min_num_rows || num_cols == min_num_cols , errors :: InvalidArgument ( "The number of rows or columns is not consistent with " "the specified d_lower, d_upper, and diagonal." ) ) ; TensorShape output_shape = diagonal_shape ; if ( num_diags == 1 ) { output_shape . set_dim ( diag_rank - 1 , num_rows ) ; output_shape . AddDim ( num_cols ) ; } else { output_shape . set_dim ( diag_rank - 2 , num_rows ) ; output_shape . set_dim ( diag_rank - 1 , num_cols ) ; } Tensor * output = nullptr ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , output_shape , & output ) ) ; auto output_reshaped = output -> flat_inner_dims < T , 3 > ( ) ; auto diag_reshaped = diagonal . flat < T > ( ) ; functor :: MatrixDiag < Device , T > :: Compute ( context , context -> eigen_device < Device > ( ) , diag_reshaped , output_reshaped , lower_diag_index , upper_diag_index , max_diag_len , padding_value , left_align_superdiagonal_ , left_align_subdiagonal_ ) ; }
Handle < Object > StoreHandler :: StoreThroughPrototype ( Isolate * isolate , Handle < Map > receiver_map , Handle < JSReceiver > holder , Handle < Smi > smi_handler , MaybeObjectHandle maybe_data1 , MaybeObjectHandle maybe_data2 ) { MaybeObjectHandle data1 ; if ( maybe_data1 . is_null ( ) ) { data1 = MaybeObjectHandle :: Weak ( holder ) ; } else { data1 = maybe_data1 ; } int checks_count = GetPrototypeCheckCount < StoreHandler > ( isolate , & smi_handler , receiver_map , holder , data1 , maybe_data2 ) ; Handle < Object > validity_cell = Map :: GetOrCreatePrototypeChainValidityCell ( receiver_map , isolate ) ; DCHECK_IMPLIES ( validity_cell -> IsSmi ( ) , checks_count == 0 ) ; int data_count = 1 + checks_count ; Handle < StoreHandler > handler = isolate -> factory ( ) -> NewStoreHandler ( data_count ) ; handler -> set_smi_handler ( * smi_handler ) ; handler -> set_validity_cell ( * validity_cell ) ; InitPrototypeChecks ( isolate , handler , receiver_map , holder , data1 , maybe_data2 ) ; return handler ; }
static bool WritePrincipalInfo ( JSStructuredCloneWriter * aWriter , const OriginAttributes & aAttrs , const nsCString & aSpec , const nsCString & aOriginNoSuffix ) { nsAutoCString suffix ; aAttrs . CreateSuffix ( suffix ) ; return JS_WriteUint32Pair ( aWriter , suffix . Length ( ) , aSpec . Length ( ) ) && JS_WriteBytes ( aWriter , suffix . get ( ) , suffix . Length ( ) ) && JS_WriteBytes ( aWriter , aSpec . get ( ) , aSpec . Length ( ) ) && JS_WriteUint32Pair ( aWriter , aOriginNoSuffix . Length ( ) , 0 ) && JS_WriteBytes ( aWriter , aOriginNoSuffix . get ( ) , aOriginNoSuffix . Length ( ) ) ; }
bool nsDeviceSensors :: IsSensorAllowedByPref ( uint32_t aType , nsIDOMWindow * aWindow ) { if ( ! StaticPrefs :: device_sensors_enabled ( ) ) { return false ; } nsCOMPtr < nsPIDOMWindowInner > window = do_QueryInterface ( aWindow ) ; nsCOMPtr < Document > doc ; if ( window ) { doc = window -> GetExtantDoc ( ) ; } switch ( aType ) { case nsIDeviceSensorData :: TYPE_LINEAR_ACCELERATION : case nsIDeviceSensorData :: TYPE_ACCELERATION : case nsIDeviceSensorData :: TYPE_GYROSCOPE : if ( ! StaticPrefs :: device_sensors_motion_enabled ( ) ) { return false ; } else if ( doc ) { doc -> WarnOnceAbout ( Document :: eMotionEvent ) ; } break ; case nsIDeviceSensorData :: TYPE_GAME_ROTATION_VECTOR : case nsIDeviceSensorData :: TYPE_ORIENTATION : case nsIDeviceSensorData :: TYPE_ROTATION_VECTOR : if ( ! StaticPrefs :: device_sensors_orientation_enabled ( ) ) { return false ; } else if ( doc ) { doc -> WarnOnceAbout ( Document :: eOrientationEvent ) ; } break ; case nsIDeviceSensorData :: TYPE_PROXIMITY : if ( ! StaticPrefs :: device_sensors_proximity_enabled ( ) ) { return false ; } else if ( doc ) { doc -> WarnOnceAbout ( Document :: eProximityEvent , true ) ; } break ; case nsIDeviceSensorData :: TYPE_LIGHT : if ( ! StaticPrefs :: device_sensors_ambientLight_enabled ( ) ) { return false ; } else if ( doc ) { doc -> WarnOnceAbout ( Document :: eAmbientLightEvent , true ) ; } break ; default : MOZ_ASSERT_UNREACHABLE ( "Device sensor type not recognised" ) ; return false ; } if ( ! window ) { return true ; } return ! nsContentUtils :: ShouldResistFingerprinting ( window -> GetDocShell ( ) ) ; }
bool GetSurfaces ( imgFrame * srcFrame ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; nsRefPtr < RasterImage > image = weakImage . get ( ) ; if ( ! image ) { return false ; } bool success = false ; if ( ! dstLocked ) { bool srcLocked = NS_SUCCEEDED ( srcFrame -> LockImageData ( ) ) ; srcSurface = srcFrame -> GetSurface ( ) ; dstLocked = NS_SUCCEEDED ( dstFrame -> LockImageData ( ) ) ; dstSurface = dstFrame -> GetSurface ( ) ; success = srcLocked && dstLocked && srcSurface && dstSurface ; if ( success ) { srcData = srcFrame -> GetImageData ( ) ; dstData = dstFrame -> GetImageData ( ) ; srcStride = srcFrame -> GetImageBytesPerRow ( ) ; dstStride = dstFrame -> GetImageBytesPerRow ( ) ; srcFormat = srcFrame -> GetFormat ( ) ; } if ( srcLocked ) { success = NS_SUCCEEDED ( srcFrame -> UnlockImageData ( ) ) && success ; } } return success ; }
void ObjectStatsCollectorImpl :: RecordVirtualJSGlobalObjectDetails ( JSGlobalObject * object ) { GlobalDictionary * properties = object -> global_dictionary ( ) ; RecordHashTableVirtualObjectStats ( object , properties , ObjectStats :: GLOBAL_PROPERTIES_TYPE ) ; FixedArrayBase * elements = object -> elements ( ) ; RecordSimpleVirtualObjectStats ( object , elements , ObjectStats :: GLOBAL_ELEMENTS_TYPE ) ; }
TfLiteStatus ResizeOutputTensors ( TfLiteContext * context , TfLiteNode * node , const TfLiteTensor * axis , const TfLiteTensor * input , int num_splits ) { int axis_value = GetTensorData < int > ( axis ) [ 0 ] ; if ( axis_value < 0 ) { axis_value += NumDimensions ( input ) ; } TF_LITE_ENSURE ( context , axis_value >= 0 ) ; TF_LITE_ENSURE ( context , axis_value < NumDimensions ( input ) ) ; const int input_size = SizeOfDimension ( input , axis_value ) ; TF_LITE_ENSURE_MSG ( context , input_size % num_splits == 0 , "Not an even split" ) ; const int slice_size = input_size / num_splits ; for ( int i = 0 ; i < NumOutputs ( node ) ; ++ i ) { TfLiteIntArray * output_dims = TfLiteIntArrayCopy ( input -> dims ) ; output_dims -> data [ axis_value ] = slice_size ; TfLiteTensor * output = GetOutput ( context , node , i ) ; TF_LITE_ENSURE_STATUS ( context -> ResizeTensor ( context , output , output_dims ) ) ; } return kTfLiteOk ; }
static size_t optsize ( lua_State * L , char opt , const char * * fmt ) { switch ( opt ) { case 'B' : case 'b' : return sizeof ( char ) ; case 'H' : case 'h' : return sizeof ( short ) ; case 'L' : case 'l' : return sizeof ( long ) ; case 'T' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ; case 'c' : return getnum ( fmt , 1 ) ; case 'i' : case 'I' : { int sz = getnum ( fmt , sizeof ( int ) ) ; if ( sz > MAXINTSIZE ) luaL_error ( L , "integral size %d is larger than limit of %d" , sz , MAXINTSIZE ) ; return sz ; } default : return 0 ; } }
void TraceMemoryOperation ( bool is_store , MachineRepresentation rep , Register index , uint32_t offset , WasmCodePosition position ) { __ SpillAllRegisters ( ) ; LiftoffRegList pinned = LiftoffRegList :: ForRegs ( index ) ; LiftoffRegister address = pinned . set ( __ GetUnusedRegister ( kGpReg , pinned ) ) ; __ LoadConstant ( address , WasmValue ( offset ) ) ; __ emit_i32_add ( address . gp ( ) , address . gp ( ) , index ) ; LiftoffRegister info = pinned . set ( __ GetUnusedRegister ( kGpReg , pinned ) ) ; __ AllocateStackSlot ( info . gp ( ) , sizeof ( MemoryTracingInfo ) ) ; __ Store ( info . gp ( ) , no_reg , offsetof ( MemoryTracingInfo , address ) , address , StoreType :: kI32Store , pinned ) ; __ LoadConstant ( address , WasmValue ( is_store ? 1 : 0 ) ) ; __ Store ( info . gp ( ) , no_reg , offsetof ( MemoryTracingInfo , is_store ) , address , StoreType :: kI32Store8 , pinned ) ; __ LoadConstant ( address , WasmValue ( static_cast < int > ( rep ) ) ) ; __ Store ( info . gp ( ) , no_reg , offsetof ( MemoryTracingInfo , mem_rep ) , address , StoreType :: kI32Store8 , pinned ) ; source_position_table_builder_ . AddPosition ( __ pc_offset ( ) , SourcePosition ( position ) , false ) ; Register args [ ] = { info . gp ( ) } ; GenerateRuntimeCall ( Runtime :: kWasmTraceMemory , arraysize ( args ) , args ) ; __ DeallocateStackSlot ( sizeof ( MemoryTracingInfo ) ) ; }
Status check_index_ordering ( const Tensor & indices ) { auto findices = indices . flat < int > ( ) ; for ( std :: size_t i = 0 ; i < findices . dimension ( 0 ) - 1 ; ++ i ) { if ( findices ( i ) < findices ( i + 1 ) ) { continue ; } return Status ( errors :: InvalidArgument ( "Indices are not strictly ordered" ) ) ; } return Status :: OK ( ) ; }
void HalDeathHandler :: serviceDied ( uint64_t , const wp < IBase > & ) { std :: lock_guard < std :: mutex > guard ( mHandlersLock ) ; for ( const auto & handler : mHandlers ) { handler . second ( ) ; } ALOGE ( "HAL server crashed, audio server is restarting" ) ; exit ( 1 ) ; }
nsWindow :: SetScrollingRootContent ( const bool isRootContent ) { MOZ_ASSERT ( APZThreadUtils :: IsControllerThread ( ) , "nsWindow::SetScrollingRootContent must be called from the controller thread" ) ; if ( mNPZCSupport ) { mNPZCSupport -> SetScrollingRootContent ( isRootContent ) ; } }
TPM2B_PUBLIC_Unmarshal ( TPM2B_PUBLIC * target , BYTE * * buffer , INT32 * size , BOOL allowNull ) { TPM_RC rc = TPM_RC_SUCCESS ; INT32 startSize ; if ( rc == TPM_RC_SUCCESS ) { rc = UINT16_Unmarshal ( & target -> size , buffer , size ) ; } if ( rc == TPM_RC_SUCCESS ) { if ( target -> size == 0 ) { rc = TPM_RC_SIZE ; } } if ( rc == TPM_RC_SUCCESS ) { startSize = * size ; } if ( rc == TPM_RC_SUCCESS ) { rc = TPMT_PUBLIC_Unmarshal ( & target -> publicArea , buffer , size , allowNull ) ; } if ( rc == TPM_RC_SUCCESS ) { if ( target -> size != startSize - * size ) { rc = TPM_RC_SIZE ; } } return rc ; }
NS_IMPL_RELEASE ( nsExternalAppHandler ) NS_INTERFACE_MAP_BEGIN ( nsExternalAppHandler ) NS_INTERFACE_MAP_ENTRY_AMBIGUOUS ( nsISupports , nsIStreamListener ) NS_INTERFACE_MAP_ENTRY ( nsIStreamListener ) NS_INTERFACE_MAP_ENTRY ( nsIRequestObserver ) NS_INTERFACE_MAP_ENTRY ( nsIHelperAppLauncher ) NS_INTERFACE_MAP_ENTRY ( nsICancelable ) NS_INTERFACE_MAP_ENTRY ( nsIBackgroundFileSaverObserver ) NS_INTERFACE_MAP_ENTRY ( nsINamed ) NS_INTERFACE_MAP_END nsExternalAppHandler :: nsExternalAppHandler ( nsIMIMEInfo * aMIMEInfo , const nsACString & aTempFileExtension , BrowsingContext * aBrowsingContext , nsIInterfaceRequestor * aWindowContext , nsExternalHelperAppService * aExtProtSvc , const nsAString & aSuggestedFilename , uint32_t aReason , bool aForceSave ) : mMimeInfo ( aMIMEInfo ) , mBrowsingContext ( aBrowsingContext ) , mWindowContext ( aWindowContext ) , mSuggestedFileName ( aSuggestedFilename ) , mForceSave ( aForceSave ) , mCanceled ( false ) , mStopRequestIssued ( false ) , mIsFileChannel ( false ) , mShouldCloseWindow ( false ) , mHandleInternally ( false ) , mReason ( aReason ) , mTempFileIsExecutable ( false ) , mTimeDownloadStarted ( 0 ) , mContentLength ( - 1 ) , mProgress ( 0 ) , mSaver ( nullptr ) , mDialogProgressListener ( nullptr ) , mTransfer ( nullptr ) , mRequest ( nullptr ) , mExtProtSvc ( aExtProtSvc ) { if ( ! aTempFileExtension . IsEmpty ( ) && aTempFileExtension . First ( ) != '.' ) mTempFileExtension = char16_t ( '.' ) ; AppendUTF8toUTF16 ( aTempFileExtension , mTempFileExtension ) ; nsAutoString originalFileExt ; int32_t pos = mSuggestedFileName . RFindChar ( '.' ) ; if ( pos != kNotFound ) { mSuggestedFileName . Right ( originalFileExt , mSuggestedFileName . Length ( ) - pos ) ; } mSuggestedFileName . ReplaceChar ( KNOWN_PATH_SEPARATORS , '_' ) ; mSuggestedFileName . ReplaceChar ( FILE_ILLEGAL_CHARACTERS , ' ' ) ; mTempFileExtension . ReplaceChar ( KNOWN_PATH_SEPARATORS , '_' ) ; mTempFileExtension . ReplaceChar ( FILE_ILLEGAL_CHARACTERS , ' ' ) ; const char16_t unsafeBidiCharacters [ ] = { char16_t ( 0x061c ) , char16_t ( 0x200e ) , char16_t ( 0x200f ) , char16_t ( 0x202a ) , char16_t ( 0x202b ) , char16_t ( 0x202c ) , char16_t ( 0x202d ) , char16_t ( 0x202e ) , char16_t ( 0x2066 ) , char16_t ( 0x2067 ) , char16_t ( 0x2068 ) , char16_t ( 0x2069 ) , char16_t ( 0 ) } ; mSuggestedFileName . ReplaceChar ( unsafeBidiCharacters , '_' ) ; mTempFileExtension . ReplaceChar ( unsafeBidiCharacters , '_' ) ; mSuggestedFileName . CompressWhitespace ( ) ; mTempFileExtension . CompressWhitespace ( ) ; if ( originalFileExt . FindCharInSet ( KNOWN_PATH_SEPARATORS FILE_ILLEGAL_CHARACTERS ) != kNotFound ) { mSuggestedFileName . Append ( mTempFileExtension ) ; originalFileExt = mTempFileExtension ; } EnsureTempFileExtension ( originalFileExt ) ; mBufferSize = Preferences :: GetUint ( "network.buffer.cache.size" , 4096 ) ; }
void Builtins :: Generate_FunctionPrototypeCall ( MacroAssembler * masm ) { { Label done ; __ Branch ( & done , ne , a0 , Operand ( zero_reg ) ) ; __ PushRoot ( Heap :: kUndefinedValueRootIndex ) ; __ Daddu ( a0 , a0 , Operand ( 1 ) ) ; __ bind ( & done ) ; } __ Dlsa ( kScratchReg , sp , a0 , kPointerSizeLog2 ) ; __ Ld ( a1 , MemOperand ( kScratchReg ) ) ; { Label loop ; __ Dlsa ( a2 , sp , a0 , kPointerSizeLog2 ) ; __ bind ( & loop ) ; __ Ld ( kScratchReg , MemOperand ( a2 , - kPointerSize ) ) ; __ Sd ( kScratchReg , MemOperand ( a2 ) ) ; __ Dsubu ( a2 , a2 , Operand ( kPointerSize ) ) ; __ Branch ( & loop , ne , a2 , Operand ( sp ) ) ; __ Dsubu ( a0 , a0 , Operand ( 1 ) ) ; __ Pop ( ) ; } __ Jump ( masm -> isolate ( ) -> builtins ( ) -> Call ( ) , RelocInfo :: CODE_TARGET ) ; }
StackIter :: calleev ( ) const { switch ( state_ ) { case DONE : break ; case SCRIPTED : JS_ASSERT ( isFunctionFrame ( ) ) ; return fp ( ) -> calleev ( ) ; case ION : #ifdef JS_ION return ObjectValue ( * callee ( ) ) ; #else break ; #endif case NATIVE : return nativeArgs ( ) . calleev ( ) ; } JS_NOT_REACHED ( "Unexpected state" ) ; return Value ( ) ; }
int create_symlink_lockfile ( const char * lock_file , const char * pid ) { while ( symlink ( pid , lock_file ) != 0 ) { if ( errno != EEXIST ) { if ( errno != ENOENT && errno != ENOTDIR && errno != EACCES ) { perror_msg ( "Can't create lock file '%s'" , lock_file ) ; errno = 0 ; } return - 1 ; } char pid_buf [ sizeof ( pid_t ) * 3 + 4 ] ; ssize_t r = readlink ( lock_file , pid_buf , sizeof ( pid_buf ) - 1 ) ; if ( r < 0 ) { if ( errno == ENOENT ) { usleep ( SYMLINK_RETRY_USLEEP ) ; continue ; } perror_msg ( "Can't read lock file '%s'" , lock_file ) ; errno = 0 ; return - 1 ; } pid_buf [ r ] = '\0' ; if ( strcmp ( pid_buf , pid ) == 0 ) { log ( "Lock file '%s' is already locked by us" , lock_file ) ; return 0 ; } if ( isdigit_str ( pid_buf ) ) { char pid_str [ sizeof ( "/proc/" ) + sizeof ( pid_buf ) ] ; snprintf ( pid_str , sizeof ( pid_str ) , "/proc/%s" , pid_buf ) ; if ( access ( pid_str , F_OK ) == 0 ) { log ( "Lock file '%s' is locked by process %s" , lock_file , pid_buf ) ; return 0 ; } log ( "Lock file '%s' was locked by process %s, but it crashed?" , lock_file , pid_buf ) ; } if ( unlink ( lock_file ) != 0 && errno != ENOENT ) { perror_msg ( "Can't remove stale lock file '%s'" , lock_file ) ; errno = 0 ; return - 1 ; } } log_info ( "Locked '%s'" , lock_file ) ; return 1 ; }
StackIter :: isConstructing ( ) const { switch ( state_ ) { case DONE : JS_NOT_REACHED ( "Unexpected state" ) ; return false ; case ION : #ifdef JS_ION       return ionInlineFrames_ . isConstructing ( ) ; #else JS_NOT_REACHED ( "Unexpected state" ) ; return false ; #endif         case SCRIPTED : case NATIVE : return fp ( ) -> isConstructing ( ) ; } return false ; }
ParseContext < ParseHandler > :: generateBindings ( ExclusiveContext * cx , TokenStream & ts , LifoAlloc & alloc , MutableHandle < Bindings > bindings ) const { MOZ_ASSERT_IF ( sc -> isFunctionBox ( ) , args_ . length ( ) < ARGNO_LIMIT ) ; MOZ_ASSERT_IF ( sc -> isModuleBox ( ) , args_ . length ( ) == 0 ) ; MOZ_ASSERT ( vars_ . length ( ) + bodyLevelLexicals_ . length ( ) < LOCALNO_LIMIT ) ; if ( UINT32_MAX - args_ . length ( ) <= vars_ . length ( ) + bodyLevelLexicals_ . length ( ) ) return ts . reportError ( JSMSG_TOO_MANY_LOCALS ) ; if ( ! sc -> isGlobalContext ( ) ) { for ( size_t i = 0 ; i < vars_ . length ( ) ; i ++ ) vars_ [ i ] -> pn_blockid = bodyid ; for ( size_t i = 0 ; i < bodyLevelLexicals_ . length ( ) ; i ++ ) { Definition * dn = bodyLevelLexicals_ [ i ] ; if ( ! dn -> pn_scopecoord . setSlot ( ts , vars_ . length ( ) + i ) ) return false ; } } uint32_t count = args_ . length ( ) + vars_ . length ( ) + bodyLevelLexicals_ . length ( ) ; Binding * packedBindings = alloc . newArrayUninitialized < Binding > ( count ) ; if ( ! packedBindings ) { ReportOutOfMemory ( cx ) ; return false ; } uint32_t numUnaliasedVars = 0 ; uint32_t numUnaliasedBodyLevelLexicals = 0 ; AppendPackedBindings ( this , args_ , packedBindings ) ; AppendPackedBindings ( this , vars_ , packedBindings + args_ . length ( ) , & numUnaliasedVars ) ; AppendPackedBindings ( this , bodyLevelLexicals_ , packedBindings + args_ . length ( ) + vars_ . length ( ) , & numUnaliasedBodyLevelLexicals ) ; return Bindings :: initWithTemporaryStorage ( cx , bindings , args_ . length ( ) , vars_ . length ( ) , bodyLevelLexicals_ . length ( ) , blockScopeDepth , numUnaliasedVars , numUnaliasedBodyLevelLexicals , packedBindings , sc -> isModuleBox ( ) ) ; }
const CuePoint * Cues :: GetNext ( const CuePoint * pCurr ) const { if ( pCurr == NULL ) return NULL ; assert ( pCurr -> GetTimeCode ( ) >= 0 ) ; assert ( m_cue_points ) ; assert ( m_count >= 1 ) ; #if 0 const size_t count = m_count + m_preload_count ; size_t index = pCurr -> m_index ; assert ( index < count ) ; CuePoint * const * const pp = m_cue_points ; assert ( pp ) ; assert ( pp [ index ] == pCurr ) ; ++ index ; if ( index >= count ) return NULL ; CuePoint * const pNext = pp [ index ] ; assert ( pNext ) ; pNext -> Load ( m_pSegment -> m_pReader ) ; #else long index = pCurr -> m_index ; assert ( index < m_count ) ; CuePoint * const * const pp = m_cue_points ; assert ( pp ) ; assert ( pp [ index ] == pCurr ) ; ++ index ; if ( index >= m_count ) return NULL ; CuePoint * const pNext = pp [ index ] ; assert ( pNext ) ; assert ( pNext -> GetTimeCode ( ) >= 0 ) ; #endif return pNext ; }
void ProfilerListener :: CodeCreateEvent ( CodeEventListener :: LogEventsAndTags tag , AbstractCode * code , SharedFunctionInfo * shared , Name * script_name ) { CodeEventsContainer evt_rec ( CodeEventRecord :: CODE_CREATION ) ; CodeCreateEventRecord * rec = & evt_rec . CodeCreateEventRecord_ ; rec -> instruction_start = code -> InstructionStart ( ) ; rec -> entry = NewCodeEntry ( tag , GetName ( shared -> DebugName ( ) ) , GetName ( InferScriptName ( script_name , shared ) ) , CpuProfileNode :: kNoLineNumberInfo , CpuProfileNode :: kNoColumnNumberInfo , nullptr , code -> InstructionStart ( ) ) ; RecordInliningInfo ( rec -> entry , code ) ; rec -> entry -> FillFunctionInfo ( shared ) ; rec -> instruction_size = code -> InstructionSize ( ) ; DispatchCodeEvent ( evt_rec ) ; }
static int dnxhd_decode_header ( DNXHDContext * ctx , AVFrame * frame , const uint8_t * buf , int buf_size , int first_field ) { int i , cid , ret ; int old_bit_depth = ctx -> bit_depth , bitdepth ; uint64_t header_prefix ; if ( buf_size < 0x280 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "buffer too small (%d < 640).\n" , buf_size ) ; return AVERROR_INVALIDDATA ; } header_prefix = ff_dnxhd_parse_header_prefix ( buf ) ; if ( header_prefix == 0 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n" , buf [ 0 ] , buf [ 1 ] , buf [ 2 ] , buf [ 3 ] , buf [ 4 ] ) ; return AVERROR_INVALIDDATA ; } if ( buf [ 5 ] & 2 ) { ctx -> cur_field = buf [ 5 ] & 1 ; frame -> interlaced_frame = 1 ; frame -> top_field_first = first_field ^ ctx -> cur_field ; av_log ( ctx -> avctx , AV_LOG_DEBUG , "interlaced %d, cur field %d\n" , buf [ 5 ] & 3 , ctx -> cur_field ) ; } else { ctx -> cur_field = 0 ; } ctx -> mbaff = ( buf [ 0x6 ] > > 5 ) & 1 ; ctx -> height = AV_RB16 ( buf + 0x18 ) ; ctx -> width = AV_RB16 ( buf + 0x1a ) ; switch ( buf [ 0x21 ] > > 5 ) { case 1 : bitdepth = 8 ; break ; case 2 : bitdepth = 10 ; break ; case 3 : bitdepth = 12 ; break ; default : av_log ( ctx -> avctx , AV_LOG_ERROR , "Unknown bitdepth indicator (%d)\n" , buf [ 0x21 ] > > 5 ) ; return AVERROR_INVALIDDATA ; } cid = AV_RB32 ( buf + 0x28 ) ; ctx -> avctx -> profile = dnxhd_get_profile ( cid ) ; if ( ( ret = dnxhd_init_vlc ( ctx , cid , bitdepth ) ) < 0 ) return ret ; if ( ctx -> mbaff && ctx -> cid_table -> cid != 1260 ) av_log ( ctx -> avctx , AV_LOG_WARNING , "Adaptive MB interlace flag in an unsupported profile.\n" ) ; ctx -> act = buf [ 0x2C ] & 7 ; if ( ctx -> act && ctx -> cid_table -> cid != 1256 && ctx -> cid_table -> cid != 1270 ) av_log ( ctx -> avctx , AV_LOG_WARNING , "Adaptive color transform in an unsupported profile.\n" ) ; ctx -> is_444 = ( buf [ 0x2C ] > > 6 ) & 1 ; if ( ctx -> is_444 ) { if ( bitdepth == 8 ) { avpriv_request_sample ( ctx -> avctx , "4:4:4 8 bits" ) ; return AVERROR_INVALIDDATA ; } else if ( bitdepth == 10 ) { ctx -> decode_dct_block = dnxhd_decode_dct_block_10_444 ; ctx -> pix_fmt = ctx -> act ? AV_PIX_FMT_YUV444P10 : AV_PIX_FMT_GBRP10 ; } else { ctx -> decode_dct_block = dnxhd_decode_dct_block_12_444 ; ctx -> pix_fmt = ctx -> act ? AV_PIX_FMT_YUV444P12 : AV_PIX_FMT_GBRP12 ; } } else if ( bitdepth == 12 ) { ctx -> decode_dct_block = dnxhd_decode_dct_block_12 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P12 ; } else if ( bitdepth == 10 ) { if ( ctx -> avctx -> profile == FF_PROFILE_DNXHR_HQX ) ctx -> decode_dct_block = dnxhd_decode_dct_block_10_444 ; else ctx -> decode_dct_block = dnxhd_decode_dct_block_10 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ; } else { ctx -> decode_dct_block = dnxhd_decode_dct_block_8 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P ; } ctx -> avctx -> bits_per_raw_sample = ctx -> bit_depth = bitdepth ; if ( ctx -> bit_depth != old_bit_depth ) { ff_blockdsp_init ( & ctx -> bdsp , ctx -> avctx ) ; ff_idctdsp_init ( & ctx -> idsp , ctx -> avctx ) ; ff_init_scantable ( ctx -> idsp . idct_permutation , & ctx -> scantable , ff_zigzag_direct ) ; } if ( ctx -> width != ctx -> cid_table -> width && ctx -> cid_table -> width != DNXHD_VARIABLE ) { av_reduce ( & ctx -> avctx -> sample_aspect_ratio . num , & ctx -> avctx -> sample_aspect_ratio . den , ctx -> width , ctx -> cid_table -> width , 255 ) ; ctx -> width = ctx -> cid_table -> width ; } if ( buf_size < ctx -> cid_table -> coding_unit_size ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "incorrect frame size (%d < %u).\n" , buf_size , ctx -> cid_table -> coding_unit_size ) ; return AVERROR_INVALIDDATA ; } ctx -> mb_width = ( ctx -> width + 15 ) > > 4 ; ctx -> mb_height = AV_RB16 ( buf + 0x16c ) ; if ( ( ctx -> height + 15 ) > > 4 == ctx -> mb_height && frame -> interlaced_frame ) ctx -> height <<= 1 ; av_log ( ctx -> avctx , AV_LOG_VERBOSE , "%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\n" , ctx -> width , ctx -> height , ctx -> is_444 ? "4:4" : "2:2" , ctx -> bit_depth , ctx -> mbaff , ctx -> act ) ; if ( ctx -> mb_height > 68 && ff_dnxhd_check_header_prefix_hr ( header_prefix ) ) { ctx -> data_offset = 0x170 + ( ctx -> mb_height < < 2 ) ; } else { if ( ctx -> mb_height > 68 || ( ctx -> mb_height < < frame -> interlaced_frame ) > ( ctx -> height + 15 ) > > 4 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "mb height too big: %d\n" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( buf_size < ctx -> data_offset ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "buffer too small (%d < %d).\n" , buf_size , ctx -> data_offset ) ; return AVERROR_INVALIDDATA ; } if ( ctx -> mb_height > FF_ARRAY_ELEMS ( ctx -> mb_scan_index ) ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "mb_height too big (%d > %"SIZE_SPECIFIER ").\n" , ctx -> mb_height , FF_ARRAY_ELEMS ( ctx -> mb_scan_index ) ) ; return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < ctx -> mb_height ; i ++ ) { ctx -> mb_scan_index [ i ] = AV_RB32 ( buf + 0x170 + ( i < < 2 ) ) ; ff_dlog ( ctx -> avctx , "mb scan index %d, pos %d: %"PRIu32 "\n" , i , 0x170 + ( i < < 2 ) , ctx -> mb_scan_index [ i ] ) ; if ( buf_size - ctx -> data_offset < ctx -> mb_scan_index [ i ] ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "invalid mb scan index (%"PRIu32 " vs %u).\n" , ctx -> mb_scan_index [ i ] , buf_size - ctx -> data_offset ) ; return AVERROR_INVALIDDATA ; } } return 0 ; }
static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ; lxc_attach_options_t * options = payload -> options ; struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; #if HAVE_SYS_PERSONALITY_H long new_personality ; #endif int ret ; int status ; int expected ; long flags ; int fd ; uid_t new_uid ; gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( "error using IPC to receive notification from initial process (0)" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } #if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( "could not ensure correct architecture" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } #endif if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { ret = lxc_attach_drop_privs ( init_ctx ) ; if ( ret < 0 ) { ERROR ( "could not drop privileges" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } ret = lxc_attach_set_environment ( options -> env_policy , options -> extra_env_vars , options -> extra_keep_env ) ; if ( ret < 0 ) { ERROR ( "could not set initial environment for attached process" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } new_uid = 0 ; new_gid = 0 ; if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ; if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ; if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ; if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) { if ( setsid ( ) < 0 ) { SYSERROR ( "unable to setsid" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) { SYSERROR ( "unable to TIOCSTTY" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_gid != 0 || options -> namespaces & CLONE_NEWUSER ) ) { if ( setgid ( new_gid ) || setgroups ( 0 , NULL ) ) { SYSERROR ( "switching to container gid" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_uid != 0 || options -> namespaces & CLONE_NEWUSER ) && setuid ( new_uid ) ) { SYSERROR ( "switching to container uid" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } status = 1 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret != sizeof ( status ) ) { ERROR ( "error using IPC to notify initial process for initialization (1)" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } expected = 2 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( "error using IPC to receive final notification from initial process (2)" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) ) { int on_exec ; int proc_mounted ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; proc_mounted = mount_proc_if_needed ( "/" ) ; if ( proc_mounted == - 1 ) { ERROR ( "Error mounting a sane /proc" ) ; rexit ( - 1 ) ; } ret = lsm_process_label_set ( init_ctx -> lsm_label , init_ctx -> container -> lxc_conf , 0 , on_exec ) ; if ( proc_mounted ) umount ( "/proc" ) ; if ( ret < 0 ) { rexit ( - 1 ) ; } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && lxc_seccomp_load ( init_ctx -> container -> lxc_conf ) != 0 ) { ERROR ( "Loading seccomp policy" ) ; rexit ( - 1 ) ; } lxc_proc_put_context_info ( init_ctx ) ; if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ; if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ; if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ; if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ; if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ; if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ; for ( fd = 0 ; fd <= 2 ; fd ++ ) { flags = fcntl ( fd , F_GETFL ) ; if ( flags < 0 ) continue ; if ( flags & FD_CLOEXEC ) { if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) { SYSERROR ( "Unable to clear CLOEXEC from fd" ) ; } } } rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; }
static int fill_thread_core_info ( struct elf_thread_core_info * t , const struct user_regset_view * view , long signr , size_t * total ) { unsigned int i ; unsigned int regset0_size = regset_size ( t -> task , & view -> regsets [ 0 ] ) ; fill_prstatus ( & t -> prstatus , t -> task , signr ) ; ( void ) view -> regsets [ 0 ] . get ( t -> task , & view -> regsets [ 0 ] , 0 , regset0_size , & t -> prstatus . pr_reg , NULL ) ; fill_note ( & t -> notes [ 0 ] , "CORE" , NT_PRSTATUS , PRSTATUS_SIZE ( t -> prstatus , regset0_size ) , & t -> prstatus ) ; * total += notesize ( & t -> notes [ 0 ] ) ; do_thread_regset_writeback ( t -> task , & view -> regsets [ 0 ] ) ; for ( i = 1 ; i < view -> n ; ++ i ) { const struct user_regset * regset = & view -> regsets [ i ] ; do_thread_regset_writeback ( t -> task , regset ) ; if ( regset -> core_note_type && regset -> get && ( ! regset -> active || regset -> active ( t -> task , regset ) > 0 ) ) { int ret ; size_t size = regset_size ( t -> task , regset ) ; void * data = kmalloc ( size , GFP_KERNEL ) ; if ( unlikely ( ! data ) ) return 0 ; ret = regset -> get ( t -> task , regset , 0 , size , data , NULL ) ; if ( unlikely ( ret ) ) kfree ( data ) ; else { if ( regset -> core_note_type != NT_PRFPREG ) fill_note ( & t -> notes [ i ] , "LINUX" , regset -> core_note_type , size , data ) ; else { SET_PR_FPVALID ( & t -> prstatus , 1 , regset0_size ) ; fill_note ( & t -> notes [ i ] , "CORE" , NT_PRFPREG , size , data ) ; } * total += notesize ( & t -> notes [ i ] ) ; } } } return 1 ; }
RUNTIME_FUNCTION ( Runtime_NewObject ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 2 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSFunction , target , 0 ) ; CONVERT_ARG_HANDLE_CHECKED ( JSReceiver , new_target , 1 ) ; RETURN_RESULT_OR_FAILURE ( isolate , JSObject :: New ( target , new_target ) ) ; }
int CoverageInfo :: StartSourcePosition ( int slot_index ) const { DCHECK_LT ( slot_index , SlotCount ( ) ) ; const int slot_start = CoverageInfo :: FirstIndexForSlot ( slot_index ) ; return Smi :: ToInt ( get ( slot_start + kSlotStartSourcePositionIndex ) ) ; }
static Variant _php_mb_regex_ereg_replace_exec ( const Variant & pattern , const String & replacement , const String & str , const String & option , OnigOptionType options ) { const char * p ; php_mb_regex_t * re ; OnigSyntaxType * syntax ; OnigRegion * regs = nullptr ; StringBuffer out_buf ; int i , err , eval , n ; OnigUChar * pos ; OnigUChar * string_lim ; char pat_buf [ 2 ] ; const mbfl_encoding * enc ; { const char * current_enc_name ; current_enc_name = php_mb_regex_mbctype2name ( MBSTRG ( current_mbctype ) ) ; if ( current_enc_name == nullptr || ( enc = mbfl_name2encoding ( current_enc_name ) ) == nullptr ) { raise_warning ( "Unknown error" ) ; return false ; } } eval = 0 ; { if ( ! option . empty ( ) ) { _php_mb_regex_init_options ( option . data ( ) , option . size ( ) , & options , & syntax , & eval ) ; } else { options |= MBSTRG ( regex_default_options ) ; syntax = MBSTRG ( regex_default_syntax ) ; } } String spattern ; if ( pattern . isString ( ) ) { spattern = pattern . toString ( ) ; } else { pat_buf [ 0 ] = pattern . toByte ( ) ; pat_buf [ 1 ] = '\0' ; spattern = String ( pat_buf , 1 , CopyString ) ; } re = php_mbregex_compile_pattern ( spattern , options , MBSTRG ( current_mbctype ) , syntax ) ; if ( re == nullptr ) { return false ; } if ( eval ) { throw_not_supported ( "ereg_replace" , "dynamic coding" ) ; } err = 0 ; pos = ( OnigUChar * ) str . data ( ) ; string_lim = ( OnigUChar * ) ( str . data ( ) + str . size ( ) ) ; regs = onig_region_new ( ) ; while ( err >= 0 ) { err = onig_search ( re , ( OnigUChar * ) str . data ( ) , ( OnigUChar * ) string_lim , pos , ( OnigUChar * ) string_lim , regs , 0 ) ; if ( err <= - 2 ) { OnigUChar err_str [ ONIG_MAX_ERROR_MESSAGE_LEN ] ; onig_error_code_to_str ( err_str , err ) ; raise_warning ( "mbregex search failure: %s" , err_str ) ; break ; } if ( err >= 0 ) { #if moriyoshi_0 if ( regs -> beg [ 0 ] == regs -> end [ 0 ] ) { raise_warning ( "Empty regular expression" ) ; break ; } #endif out_buf . append ( ( const char * ) pos , ( OnigUChar * ) ( str . data ( ) + regs -> beg [ 0 ] ) - pos ) ; i = 0 ; p = replacement . data ( ) ; while ( i < replacement . size ( ) ) { int fwd = ( int ) php_mb_mbchar_bytes_ex ( p , enc ) ; n = - 1 ; if ( ( replacement . size ( ) - i ) >= 2 && fwd == 1 && p [ 0 ] == '\\' && p [ 1 ] >= '0' && p [ 1 ] <= '9' ) { n = p [ 1 ] - '0' ; } if ( n >= 0 && n < regs -> num_regs ) { if ( regs -> beg [ n ] >= 0 && regs -> beg [ n ] < regs -> end [ n ] && regs -> end [ n ] <= str . size ( ) ) { out_buf . append ( str . data ( ) + regs -> beg [ n ] , regs -> end [ n ] - regs -> beg [ n ] ) ; } p += 2 ; i += 2 ; } else { out_buf . append ( p , fwd ) ; p += fwd ; i += fwd ; } } n = regs -> end [ 0 ] ; if ( ( pos - ( OnigUChar * ) str . data ( ) ) < n ) { pos = ( OnigUChar * ) ( str . data ( ) + n ) ; } else { if ( pos < string_lim ) { out_buf . append ( ( const char * ) pos , 1 ) ; } pos ++ ; } } else { if ( string_lim - pos > 0 ) { out_buf . append ( ( const char * ) pos , string_lim - pos ) ; } } onig_region_free ( regs , 0 ) ; } if ( regs != nullptr ) { onig_region_free ( regs , 1 ) ; } if ( err <= - 2 ) { return false ; } return out_buf . detach ( ) ; }
static PyObject * __pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter_4write_into_stream ( struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter * __pyx_v_self ) { PyObject * __pyx_r = NULL ; __Pyx_RefNannyDeclarations PyObject * __pyx_t_1 = NULL ; __Pyx_RefNannySetupContext ( "write_into_stream" , 0 ) ; __Pyx_XDECREF ( __pyx_r ) ; __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedwriter_14BufferedWriter_write_into_stream ( __pyx_v_self , 1 ) ; if ( unlikely ( ! __pyx_t_1 ) ) __PYX_ERR ( 0 , 25 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_1 ) ; __pyx_r = __pyx_t_1 ; __pyx_t_1 = 0 ; goto __pyx_L0 ; __pyx_L1_error : ; __Pyx_XDECREF ( __pyx_t_1 ) ; __Pyx_AddTraceback ( "clickhouse_driver.bufferedwriter.BufferedWriter.write_into_stream" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __pyx_r = NULL ; __pyx_L0 : ; __Pyx_XGIVEREF ( __pyx_r ) ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
static void LookupForRead ( Isolate * isolate , LookupIterator * it ) { for ( ; it -> IsFound ( ) ; it -> Next ( ) ) { switch ( it -> state ( ) ) { case LookupIterator :: NOT_FOUND : case LookupIterator :: TRANSITION : UNREACHABLE ( ) ; case LookupIterator :: JSPROXY : return ; case LookupIterator :: INTERCEPTOR : { Handle < JSObject > holder = it -> GetHolder < JSObject > ( ) ; if ( ! holder -> GetNamedInterceptor ( ) -> getter ( ) -> IsUndefined ( isolate ) ) { return ; } break ; } case LookupIterator :: ACCESS_CHECK : if ( it -> GetHolder < JSObject > ( ) -> IsJSGlobalProxy ( ) && it -> HasAccess ( ) ) { break ; } return ; case LookupIterator :: ACCESSOR : case LookupIterator :: INTEGER_INDEXED_EXOTIC : case LookupIterator :: DATA : return ; } } }
svc_set_num_threads ( struct svc_serv * serv , struct svc_pool * pool , int nrservs ) { struct svc_rqst * rqstp ; struct task_struct * task ; struct svc_pool * chosen_pool ; int error = 0 ; unsigned int state = serv -> sv_nrthreads - 1 ; int node ; if ( pool == NULL ) { nrservs -= ( serv -> sv_nrthreads - 1 ) ; } else { spin_lock_bh ( & pool -> sp_lock ) ; nrservs -= pool -> sp_nrthreads ; spin_unlock_bh ( & pool -> sp_lock ) ; } while ( nrservs > 0 ) { nrservs -- ; chosen_pool = choose_pool ( serv , pool , & state ) ; node = svc_pool_map_get_node ( chosen_pool -> sp_id ) ; rqstp = svc_prepare_thread ( serv , chosen_pool , node ) ; if ( IS_ERR ( rqstp ) ) { error = PTR_ERR ( rqstp ) ; break ; } __module_get ( serv -> sv_ops -> svo_module ) ; task = kthread_create_on_node ( serv -> sv_ops -> svo_function , rqstp , node , "%s" , serv -> sv_name ) ; if ( IS_ERR ( task ) ) { error = PTR_ERR ( task ) ; module_put ( serv -> sv_ops -> svo_module ) ; svc_exit_thread ( rqstp ) ; break ; } rqstp -> rq_task = task ; if ( serv -> sv_nrpools > 1 ) svc_pool_map_set_cpumask ( task , chosen_pool -> sp_id ) ; svc_sock_update_bufs ( serv ) ; wake_up_process ( task ) ; } while ( nrservs < 0 && ( task = choose_victim ( serv , pool , & state ) ) != NULL ) { send_sig ( SIGINT , task , 1 ) ; nrservs ++ ; } return error ; }
Handle < JSObject > Factory :: NewArgumentsObject ( Handle < JSFunction > callee , int length ) { bool strict_mode_callee = is_strict ( callee -> shared ( ) -> language_mode ( ) ) || ! callee -> shared ( ) -> has_simple_parameters ( ) ; Handle < Map > map = strict_mode_callee ? isolate ( ) -> strict_arguments_map ( ) : isolate ( ) -> sloppy_arguments_map ( ) ; AllocationSiteUsageContext context ( isolate ( ) , Handle < AllocationSite > ( ) , false ) ; DCHECK ( ! isolate ( ) -> has_pending_exception ( ) ) ; Handle < JSObject > result = NewJSObjectFromMap ( map ) ; Handle < Smi > value ( Smi :: FromInt ( length ) , isolate ( ) ) ; Object :: SetProperty ( isolate ( ) , result , length_string ( ) , value , LanguageMode :: kStrict ) . Assert ( ) ; if ( ! strict_mode_callee ) { Object :: SetProperty ( isolate ( ) , result , callee_string ( ) , callee , LanguageMode :: kStrict ) . Assert ( ) ; } return result ; }
void YCbCrImageDataDeserializerBase :: Validate ( ) { mIsValid = false ; if ( ! mData ) { return ; } YCbCrBufferInfo * info = GetYCbCrBufferInfo ( mData , mDataSize ) ; if ( ! info ) { return ; } size_t requiredSize = ComputeMinBufferSize ( IntSize ( info -> mYWidth , info -> mYHeight ) , info -> mYStride , IntSize ( info -> mCbCrWidth , info -> mCbCrHeight ) , info -> mCbCrStride ) ; mIsValid = requiredSize <= mDataSize ; }
autofit_module_class_pic_init ( FT_Library library ) { FT_PIC_Container * pic_container = & library -> pic_container ; FT_UInt ss ; FT_Error error = FT_Err_Ok ; AFModulePIC * container = NULL ; FT_Memory memory = library -> memory ; if ( FT_ALLOC ( container , sizeof ( * container ) ) ) return error ; FT_MEM_SET ( container , 0 , sizeof ( * container ) ) ; pic_container -> autofit = container ; error = FT_Create_Class_af_services ( library , & container -> af_services ) ; if ( error ) goto Exit ; FT_Init_Class_af_service_properties ( & container -> af_service_properties ) ; for ( ss = 0 ; ss < AF_WRITING_SYSTEM_MAX ; ss ++ ) container -> af_writing_system_classes [ ss ] = & container -> af_writing_system_classes_rec [ ss ] ; container -> af_writing_system_classes [ AF_WRITING_SYSTEM_MAX ] = NULL ; for ( ss = 0 ; ss < AF_SCRIPT_MAX ; ss ++ ) container -> af_script_classes [ ss ] = & container -> af_script_classes_rec [ ss ] ; container -> af_script_classes [ AF_SCRIPT_MAX ] = NULL ; for ( ss = 0 ; ss < AF_STYLE_MAX ; ss ++ ) container -> af_style_classes [ ss ] = & container -> af_style_classes_rec [ ss ] ; container -> af_style_classes [ AF_STYLE_MAX ] = NULL ; #undef  WRITING_SYSTEM #define WRITING_SYSTEM( ws, WS )                             \         FT_Init_Class_af_ ## ws ## _writing_system_class(    \  &container->af_writing_system_classes_rec[ss++] ); ss = 0 ; #include "afwrtsys.h" #undef  SCRIPT #define SCRIPT( s, S, d, h, sc1, sc2, sc3 )          \         FT_Init_Class_af_ ## s ## _script_class(     \  &container->af_script_classes_rec[ss++] ); ss = 0 ; #include "afscript.h" #undef  STYLE #define STYLE( s, S, d, ws, sc, bss, c )            \         FT_Init_Class_af_ ## s ## _style_class(     \  &container->af_style_classes_rec[ss++] ); ss = 0 ; #include "afstyles.h" FT_Init_Class_af_autofitter_interface ( library , & container -> af_autofitter_interface ) ; Exit : if ( error ) autofit_module_class_pic_free ( library ) ; return error ; }
Handle < JSFunction > CreateFunc ( Isolate * isolate , Handle < String > name , FunctionCallback func ) { Handle < FunctionTemplateInfo > temp = NewFunctionTemplate ( isolate , func ) ; Handle < JSFunction > function = ApiNatives :: InstantiateFunction ( temp , name ) . ToHandleChecked ( ) ; DCHECK ( function -> shared ( ) -> HasSharedName ( ) ) ; return function ; }
bool Serializer < AllocatorT > :: ObjectIsBytecodeHandler ( HeapObject * obj ) const { if ( ! obj -> IsCode ( ) ) return false ; Code * code = Code :: cast ( obj ) ; if ( isolate ( ) -> heap ( ) -> IsDeserializeLazyHandler ( code ) ) return false ; return ( code -> kind ( ) == Code :: BYTECODE_HANDLER ) ; }
void vp9_default_coef_probs ( VP9_COMMON * cm ) { vp9_copy ( cm -> fc . coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ; vp9_copy ( cm -> fc . coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ; vp9_copy ( cm -> fc . coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ; vp9_copy ( cm -> fc . coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ; }
header_put_be_3byte ( SF_PRIVATE * psf , int x ) { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) { psf -> header [ psf -> headindex ++ ] = ( x > > 16 ) ; psf -> header [ psf -> headindex ++ ] = ( x > > 8 ) ; psf -> header [ psf -> headindex ++ ] = x ; } ; }
void SoftAACEncoder2 :: onReset ( ) { delete [ ] mInputFrame ; mInputFrame = NULL ; mInputSize = 0 ; mSentCodecSpecificData = false ; mInputTimeUs = - 1ll ; mSawInputEOS = false ; mSignalledError = false ; }
Return < void > DrmPlugin :: getOfflineLicenseState ( const KeySetId & keySetId , getOfflineLicenseState_cb _hidl_cb ) { std :: string licenseName ( keySetId . begin ( ) , keySetId . end ( ) ) ; DeviceFiles :: LicenseState state ; std :: string license ; OfflineLicenseState hLicenseState ; if ( mMockError != Status_V1_2 :: OK ) { _hidl_cb ( toStatus_1_0 ( mMockError ) , OfflineLicenseState :: UNKNOWN ) ; } else if ( mFileHandle . RetrieveLicense ( licenseName , & state , & license ) ) { switch ( state ) { case DeviceFiles :: kLicenseStateActive : hLicenseState = OfflineLicenseState :: USABLE ; break ; case DeviceFiles :: kLicenseStateReleasing : hLicenseState = OfflineLicenseState :: INACTIVE ; break ; case DeviceFiles :: kLicenseStateUnknown : hLicenseState = OfflineLicenseState :: UNKNOWN ; break ; } _hidl_cb ( Status :: OK , hLicenseState ) ; } else { _hidl_cb ( Status :: BAD_VALUE , OfflineLicenseState :: UNKNOWN ) ; } return Void ( ) ; }
find_auth_end ( FlatpakProxyClient * client , Buffer * buffer ) { guchar * match ; int i ; if ( client -> auth_end_offset > 0 ) { gsize left = strlen ( AUTH_END_STRING ) - client -> auth_end_offset ; gsize to_match = MIN ( left , buffer -> pos ) ; if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) { client -> auth_end_offset += to_match ; if ( client -> auth_end_offset == strlen ( AUTH_END_STRING ) ) return to_match ; return - 1 ; } client -> auth_end_offset = - 1 ; } match = memmem ( buffer , buffer -> pos , AUTH_END_STRING , strlen ( AUTH_END_STRING ) ) ; if ( match != NULL ) return match - buffer -> data + strlen ( AUTH_END_STRING ) ; for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ; i > 0 ; i -- ) { if ( memcmp ( buffer -> data + buffer -> pos - i , AUTH_END_STRING , i ) == 0 ) { client -> auth_end_offset = i ; break ; } } return - 1 ; }
void Compute ( OpKernelContext * context ) override { const Tensor & images = context -> input ( 0 ) ; const Tensor & boxes = context -> input ( 1 ) ; const int64 depth = images . dim_size ( 3 ) ; OP_REQUIRES ( context , images . dims ( ) == 4 , errors :: InvalidArgument ( "The rank of the images should be 4" ) ) ; OP_REQUIRES ( context , boxes . dims ( ) == 3 , errors :: InvalidArgument ( "The rank of the boxes tensor should be 3" ) ) ; OP_REQUIRES ( context , images . dim_size ( 0 ) == boxes . dim_size ( 0 ) , errors :: InvalidArgument ( "The batch sizes should be the same" ) ) ; OP_REQUIRES ( context , depth == 4 || depth == 1 || depth == 3 , errors :: InvalidArgument ( "Channel depth should be either 1 (GRY), " "3 (RGB), or 4 (RGBA)" ) ) ; const int64 batch_size = images . dim_size ( 0 ) ; const int64 height = images . dim_size ( 1 ) ; const int64 width = images . dim_size ( 2 ) ; std :: vector < std :: vector < float > > color_table ; if ( context -> num_inputs ( ) == 3 ) { const Tensor & colors_tensor = context -> input ( 2 ) ; OP_REQUIRES ( context , colors_tensor . shape ( ) . dims ( ) == 2 , errors :: InvalidArgument ( "colors must be a 2-D matrix" , colors_tensor . shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( context , colors_tensor . shape ( ) . dim_size ( 1 ) >= depth , errors :: InvalidArgument ( "colors must have equal or more " , "channels than the image provided: " , colors_tensor . shape ( ) . DebugString ( ) ) ) ; if ( colors_tensor . NumElements ( ) != 0 ) { color_table . clear ( ) ; auto colors = colors_tensor . matrix < float > ( ) ; for ( int64 i = 0 ; i < colors . dimension ( 0 ) ; i ++ ) { std :: vector < float > color_value ( 4 ) ; for ( int64 j = 0 ; j < 4 ; j ++ ) { color_value [ j ] = colors ( i , j ) ; } color_table . emplace_back ( color_value ) ; } } } if ( color_table . empty ( ) ) { color_table = DefaultColorTable ( depth ) ; } Tensor * output ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { batch_size , height , width , depth } ) , & output ) ) ; output -> tensor < T , 4 > ( ) = images . tensor < T , 4 > ( ) ; auto canvas = output -> tensor < T , 4 > ( ) ; for ( int64 b = 0 ; b < batch_size ; ++ b ) { const int64 num_boxes = boxes . dim_size ( 1 ) ; const auto tboxes = boxes . tensor < T , 3 > ( ) ; for ( int64 bb = 0 ; bb < num_boxes ; ++ bb ) { int64 color_index = bb % color_table . size ( ) ; const int64 min_box_row = static_cast < float > ( tboxes ( b , bb , 0 ) ) * ( height - 1 ) ; const int64 min_box_row_clamp = std :: max < int64 > ( min_box_row , int64 { 0 } ) ; const int64 max_box_row = static_cast < float > ( tboxes ( b , bb , 2 ) ) * ( height - 1 ) ; const int64 max_box_row_clamp = std :: min < int64 > ( max_box_row , height - 1 ) ; const int64 min_box_col = static_cast < float > ( tboxes ( b , bb , 1 ) ) * ( width - 1 ) ; const int64 min_box_col_clamp = std :: max < int64 > ( min_box_col , int64 { 0 } ) ; const int64 max_box_col = static_cast < float > ( tboxes ( b , bb , 3 ) ) * ( width - 1 ) ; const int64 max_box_col_clamp = std :: min < int64 > ( max_box_col , width - 1 ) ; if ( min_box_row > max_box_row || min_box_col > max_box_col ) { LOG ( WARNING ) < < "Bounding box (" < < min_box_row < < "," < < min_box_col < < "," < < max_box_row < < "," < < max_box_col < < ") is inverted and will not be drawn." ; continue ; } if ( min_box_row >= height || max_box_row < 0 || min_box_col >= width || max_box_col < 0 ) { LOG ( WARNING ) < < "Bounding box (" < < min_box_row < < "," < < min_box_col < < "," < < max_box_row < < "," < < max_box_col < < ") is completely outside the image" < < " and will not be drawn." ; continue ; } OP_REQUIRES ( context , min_box_row_clamp >= 0 , errors :: InvalidArgument ( "Min box row clamp is less than 0." ) ) ; OP_REQUIRES ( context , max_box_row_clamp >= 0 , errors :: InvalidArgument ( "Max box row clamp is less than 0." ) ) ; OP_REQUIRES ( context , min_box_row_clamp <= height , errors :: InvalidArgument ( "Min box row clamp is greater than height." ) ) ; OP_REQUIRES ( context , max_box_row_clamp <= height , errors :: InvalidArgument ( "Max box row clamp is greater than height." ) ) ; OP_REQUIRES ( context , min_box_col_clamp >= 0 , errors :: InvalidArgument ( "Min box col clamp is less than 0." ) ) ; OP_REQUIRES ( context , max_box_col_clamp >= 0 , errors :: InvalidArgument ( "Max box col clamp is less than 0." ) ) ; OP_REQUIRES ( context , min_box_col_clamp <= width , errors :: InvalidArgument ( "Min box col clamp is greater than width." ) ) ; OP_REQUIRES ( context , max_box_col_clamp <= width , errors :: InvalidArgument ( "Max box col clamp is greater than width." ) ) ; OP_REQUIRES ( context , min_box_row <= height , errors :: InvalidArgument ( "Min box row is greater than height." ) ) ; OP_REQUIRES ( context , max_box_row >= 0 , errors :: InvalidArgument ( "Max box row is less than 0." ) ) ; OP_REQUIRES ( context , min_box_col <= width , errors :: InvalidArgument ( "Min box col is greater than width." ) ) ; OP_REQUIRES ( context , max_box_col >= 0 , errors :: InvalidArgument ( "Max box col is less than 0." ) ) ; if ( min_box_row >= 0 ) { for ( int64 j = min_box_col_clamp ; j <= max_box_col_clamp ; ++ j ) for ( int64 c = 0 ; c < depth ; c ++ ) { canvas ( b , min_box_row , j , c ) = static_cast < T > ( color_table [ color_index ] [ c ] ) ; } } if ( max_box_row < height ) { for ( int64 j = min_box_col_clamp ; j <= max_box_col_clamp ; ++ j ) for ( int64 c = 0 ; c < depth ; c ++ ) { canvas ( b , max_box_row , j , c ) = static_cast < T > ( color_table [ color_index ] [ c ] ) ; } } if ( min_box_col >= 0 ) { for ( int64 i = min_box_row_clamp ; i <= max_box_row_clamp ; ++ i ) for ( int64 c = 0 ; c < depth ; c ++ ) { canvas ( b , i , min_box_col , c ) = static_cast < T > ( color_table [ color_index ] [ c ] ) ; } } if ( max_box_col < width ) { for ( int64 i = min_box_row_clamp ; i <= max_box_row_clamp ; ++ i ) for ( int64 c = 0 ; c < depth ; c ++ ) { canvas ( b , i , max_box_col , c ) = static_cast < T > ( color_table [ color_index ] [ c ] ) ; } } } } }
png_process_data_skip ( png_structrp png_ptr ) { png_uint_32 remaining = 0 ; if ( png_ptr != NULL && png_ptr -> process_mode == PNG_SKIP_MODE && png_ptr -> skip_length > 0 ) { if ( png_ptr -> buffer_size != 0 ) png_error ( png_ptr , "png_process_data_skip called inside png_process_data" ) ; if ( png_ptr -> save_buffer_size != 0 ) png_error ( png_ptr , "png_process_data_skip called with saved data" ) ; remaining = png_ptr -> skip_length ; png_ptr -> skip_length = 0 ; png_ptr -> process_mode = PNG_READ_CHUNK_MODE ; } return remaining ; }
ppp_unregister_channel ( struct ppp_channel * chan ) { struct channel * pch = chan -> ppp ; struct ppp_net * pn ; if ( ! pch ) return ; chan -> ppp = NULL ; down_write ( & pch -> chan_sem ) ; spin_lock_bh ( & pch -> downl ) ; pch -> chan = NULL ; spin_unlock_bh ( & pch -> downl ) ; up_write ( & pch -> chan_sem ) ; ppp_disconnect_channel ( pch ) ; pn = ppp_pernet ( pch -> chan_net ) ; spin_lock_bh ( & pn -> all_channels_lock ) ; list_del ( & pch -> list ) ; spin_unlock_bh ( & pn -> all_channels_lock ) ; pch -> file . dead = 1 ; wake_up_interruptible ( & pch -> file . rwait ) ; if ( atomic_dec_and_test ( & pch -> file . refcnt ) ) ppp_destroy_channel ( pch ) ; }
nsThread :: nsThread ( ) : mEvents ( nullptr ) , mEventTarget ( nullptr ) , mShutdownContext ( nullptr ) , mScriptObserver ( nullptr ) , mThreadName ( "<uninitialized>" ) , mStackSize ( 0 ) , mNestedEventLoopDepth ( 0 ) , mShutdownRequired ( false ) , mPriority ( PRIORITY_NORMAL ) , mIsMainThread ( false ) , mUseHangMonitor ( false ) , mCanInvokeJS ( false ) , #ifdef EARLY_BETA_OR_EARLIER mLastWakeupCheckTime ( TimeStamp :: Now ( ) ) , #endif mPerformanceCounterState ( mNestedEventLoopDepth , mIsMainThread ) { MOZ_ASSERT ( ! NS_IsMainThread ( ) ) ; }
cmdline_erase_chars ( int c , int indent #ifdef FEAT_SEARCH_EXTRA , incsearch_state_T * isp #endif ) { int i ; int j ; if ( c == K_KDEL ) c = K_DEL ; if ( c == K_DEL && ccline . cmdpos != ccline . cmdlen ) ++ ccline . cmdpos ; if ( has_mbyte && c == K_DEL ) ccline . cmdpos += mb_off_next ( ccline . cmdbuff , ccline . cmdbuff + ccline . cmdpos ) ; if ( ccline . cmdpos > 0 ) { char_u * p ; j = ccline . cmdpos ; p = ccline . cmdbuff + j ; if ( has_mbyte ) { p = mb_prevptr ( ccline . cmdbuff , p ) ; if ( c == Ctrl_W ) { while ( p > ccline . cmdbuff && vim_isspace ( * p ) ) p = mb_prevptr ( ccline . cmdbuff , p ) ; i = mb_get_class ( p ) ; while ( p > ccline . cmdbuff && mb_get_class ( p ) == i ) p = mb_prevptr ( ccline . cmdbuff , p ) ; if ( mb_get_class ( p ) != i ) p += ( * mb_ptr2len ) ( p ) ; } } else if ( c == Ctrl_W ) { while ( p > ccline . cmdbuff && vim_isspace ( p [ - 1 ] ) ) -- p ; i = vim_iswordc ( p [ - 1 ] ) ; while ( p > ccline . cmdbuff && ! vim_isspace ( p [ - 1 ] ) && vim_iswordc ( p [ - 1 ] ) == i ) -- p ; } else -- p ; ccline . cmdpos = ( int ) ( p - ccline . cmdbuff ) ; ccline . cmdlen -= j - ccline . cmdpos ; i = ccline . cmdpos ; while ( i < ccline . cmdlen ) ccline . cmdbuff [ i ++ ] = ccline . cmdbuff [ j ++ ] ; ccline . cmdbuff [ ccline . cmdlen ] = NUL ; #ifdef FEAT_SEARCH_EXTRA if ( ccline . cmdlen == 0 ) { isp -> search_start = isp -> save_cursor ; isp -> old_viewstate = isp -> init_viewstate ; } #endif redrawcmd ( ) ; } else if ( ccline . cmdlen == 0 && c != Ctrl_W && ccline . cmdprompt == NULL && indent == 0 ) { if ( exmode_active #ifdef FEAT_EVAL || ccline . cmdfirstc == '>' #endif ) return CMDLINE_NOT_CHANGED ; VIM_CLEAR ( ccline . cmdbuff ) ; if ( ! cmd_silent ) { #ifdef FEAT_RIGHTLEFT if ( cmdmsg_rl ) msg_col = Columns ; else #endif msg_col = 0 ; msg_putchar ( ' ' ) ; } #ifdef FEAT_SEARCH_EXTRA if ( ccline . cmdlen == 0 ) isp -> search_start = isp -> save_cursor ; #endif redraw_cmdline = TRUE ; return GOTO_NORMAL_MODE ; } return CMDLINE_CHANGED ; }
Result < std :: vector < std :: function < void ( ) > * > > Epoll :: Wait ( std :: optional < std :: chrono :: milliseconds > timeout ) { int timeout_ms = - 1 ; if ( timeout && timeout -> count ( ) < INT_MAX ) { timeout_ms = timeout -> count ( ) ; } const auto max_events = epoll_handlers_ . size ( ) ; epoll_event ev [ max_events ] ; auto num_events = TEMP_FAILURE_RETRY ( epoll_wait ( epoll_fd_ , ev , max_events , timeout_ms ) ) ; if ( num_events == - 1 ) { return ErrnoError ( ) < < "epoll_wait failed" ; } std :: vector < std :: function < void ( ) > * > pending_functions ; for ( int i = 0 ; i < num_events ; ++ i ) { pending_functions . emplace_back ( reinterpret_cast < std :: function < void ( ) > * > ( ev [ i ] . data . ptr ) ) ; } return pending_functions ; }
void smp_send_enc_info ( tSMP_CB * p_cb , tSMP_INT_DATA * p_data ) { tBTM_LE_LENC_KEYS le_key ; SMP_TRACE_DEBUG ( "%s: p_cb->loc_enc_size = %d" , __func__ , p_cb -> loc_enc_size ) ; smp_update_key_mask ( p_cb , SMP_SEC_KEY_TYPE_ENC , false ) ; smp_send_cmd ( SMP_OPCODE_ENCRYPT_INFO , p_cb ) ; smp_send_cmd ( SMP_OPCODE_MASTER_ID , p_cb ) ; memcpy ( le_key . ltk , p_cb -> ltk , BT_OCTET16_LEN ) ; le_key . div = p_cb -> div ; le_key . key_size = p_cb -> loc_enc_size ; le_key . sec_level = p_cb -> sec_level ; if ( ( p_cb -> peer_auth_req & SMP_AUTH_BOND ) && ( p_cb -> loc_auth_req & SMP_AUTH_BOND ) ) btm_sec_save_le_key ( p_cb -> pairing_bda , BTM_LE_KEY_LENC , ( tBTM_LE_KEY_VALUE * ) & le_key , true ) ; SMP_TRACE_WARNING ( "%s" , __func__ ) ; smp_key_distribution ( p_cb , NULL ) ; }
Reduction JSNativeContextSpecialization :: ReduceJSStoreGlobal ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSStoreGlobal , node -> opcode ( ) ) ; NameRef name ( js_heap_broker ( ) , StoreGlobalParametersOf ( node -> op ( ) ) . name ( ) ) ; Node * value = NodeProperties :: GetValueInput ( node , 0 ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; base :: Optional < ScriptContextTableRef :: LookupResult > result = native_context ( ) . script_context_table ( ) . lookup ( name ) ; if ( result ) { ObjectRef contents = result -> context . get ( result -> index ) ; OddballType oddball_type = contents . oddball_type ( ) ; if ( oddball_type == OddballType :: kHole || result -> immutable ) { return NoChange ( ) ; } Node * context = jsgraph ( ) -> Constant ( result -> context ) ; effect = graph ( ) -> NewNode ( javascript ( ) -> StoreContext ( 0 , result -> index ) , value , context , effect , control ) ; ReplaceWithValue ( node , value , effect , control ) ; return Replace ( value ) ; } return ReduceGlobalAccess ( node , nullptr , value , name . object < Name > ( ) , AccessMode :: kStore ) ; }
v8 :: Local < v8 :: Object > InjectedScript :: commandLineAPI ( ) { if ( m_commandLineAPI . IsEmpty ( ) ) { m_commandLineAPI . Reset ( m_context -> isolate ( ) , m_context -> inspector ( ) -> console ( ) -> createCommandLineAPI ( m_context -> context ( ) , m_sessionId ) ) ; m_commandLineAPI . AnnotateStrongRetainer ( kGlobalHandleLabel ) ; } return m_commandLineAPI . Get ( m_context -> isolate ( ) ) ; }
void WasmTableObject :: ClearDispatchTables ( Isolate * isolate , Handle < WasmTableObject > table , int index ) { Handle < FixedArray > dispatch_tables ( table -> dispatch_tables ( ) , isolate ) ; DCHECK_EQ ( 0 , dispatch_tables -> length ( ) % kDispatchTableNumElements ) ; for ( int i = 0 ; i < dispatch_tables -> length ( ) ; i += kDispatchTableNumElements ) { Handle < WasmInstanceObject > target_instance ( WasmInstanceObject :: cast ( dispatch_tables -> get ( i + kDispatchTableInstanceOffset ) ) , isolate ) ; DCHECK_LT ( index , target_instance -> indirect_function_table_size ( ) ) ; IndirectFunctionTableEntry ( target_instance , index ) . clear ( ) ; } }
static int raw_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct net * net = sock_net ( sk ) ; struct ipcm_cookie ipc ; struct rtable * rt = NULL ; struct flowi4 fl4 ; int free = 0 ; __be32 daddr ; __be32 saddr ; u8 tos ; int err ; struct ip_options_data opt_copy ; struct raw_frag_vec rfv ; err = - EMSGSIZE ; if ( len > 0xFFFF ) goto out ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; err = - EINVAL ; if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ; if ( usin -> sin_family != AF_INET ) { pr_info_once ( "%s: %s forgot to set AF_INET. Fix it!\n" , __func__ , current -> comm ) ; err = - EAFNOSUPPORT ; if ( usin -> sin_family ) goto out ; } daddr = usin -> sin_addr . s_addr ; } else { err = - EDESTADDRREQ ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; daddr = inet -> inet_daddr ; } ipc . sockc . tsflags = sk -> sk_tsflags ; ipc . addr = inet -> inet_saddr ; ipc . opt = NULL ; ipc . tx_flags = 0 ; ipc . ttl = 0 ; ipc . tos = - 1 ; ipc . oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sk , msg , & ipc , false ) ; if ( unlikely ( err ) ) { kfree ( ipc . opt ) ; goto out ; } if ( ipc . opt ) free = 1 ; } saddr = ipc . addr ; ipc . addr = daddr ; if ( ! ipc . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } if ( ipc . opt ) { err = - EINVAL ; if ( inet -> hdrincl ) goto done ; if ( ipc . opt -> opt . srr ) { if ( ! daddr ) goto done ; daddr = ipc . opt -> opt . faddr ; } } tos = get_rtconn_flags ( & ipc , sk ) ; if ( msg -> msg_flags & MSG_DONTROUTE ) tos |= RTO_ONLINK ; if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; } else if ( ! ipc . oif ) ipc . oif = inet -> uc_index ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , inet_sk_flowi_flags ( sk ) | ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , daddr , saddr , 0 , 0 , sk -> sk_uid ) ; if ( ! inet -> hdrincl ) { rfv . msg = msg ; rfv . hlen = 0 ; err = raw_probe_proto_opt ( & rfv , & fl4 ) ; if ( err ) goto done ; } security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; goto done ; } err = - EACCES ; if ( rt -> rt_flags & RTCF_BROADCAST && ! sock_flag ( sk , SOCK_BROADCAST ) ) goto done ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ; else { sock_tx_timestamp ( sk , ipc . sockc . tsflags , & ipc . tx_flags ) ; if ( ! ipc . addr ) ipc . addr = fl4 . daddr ; lock_sock ( sk ) ; err = ip_append_data ( sk , & fl4 , raw_getfrag , & rfv , len , 0 , & ipc , & rt , msg -> msg_flags ) ; if ( err ) ip_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) { err = ip_push_pending_frames ( sk , & fl4 ) ; if ( err == - ENOBUFS && ! inet -> recverr ) err = 0 ; } release_sock ( sk ) ; } done : if ( free ) kfree ( ipc . opt ) ; ip_rt_put ( rt ) ; out : if ( err < 0 ) return err ; return len ; do_confirm : if ( msg -> msg_flags & MSG_PROBE ) dst_confirm_neigh ( & rt -> dst , & fl4 . daddr ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }
NS_IMETHODIMP_ ( void ) GCGraphBuilder :: NoteWeakMapping ( void * map , void * key , void * val ) { PtrInfo * valNode = AddWeakMapNode ( val ) ; if ( ! valNode ) return ; WeakMapping * mapping = mWeakMaps . AppendElement ( ) ; mapping -> mMap = map ? AddWeakMapNode ( map ) : nullptr ; mapping -> mKey = key ? AddWeakMapNode ( key ) : nullptr ; mapping -> mVal = valNode ; }
HTMLCanvasElement :: ToBlob ( JSContext * aCx , FileCallback & aCallback , const nsAString & aType , JS :: Handle < JS :: Value > aParams , ErrorResult & aRv ) { if ( mWriteOnly && ! nsContentUtils :: IsCallerChrome ( ) ) { aRv . Throw ( NS_ERROR_DOM_SECURITY_ERR ) ; return ; } nsAutoString type ; nsContentUtils :: ASCIIToLower ( aType , type ) ; nsAutoString params ; bool usingCustomParseOptions ; aRv = ParseParams ( aCx , type , aParams , params , & usingCustomParseOptions ) ; if ( aRv . Failed ( ) ) { return ; } #ifdef DEBUG if ( mCurrentContext ) { nsIntSize elementSize = GetWidthHeight ( ) ; MOZ_ASSERT ( elementSize . width == mCurrentContext -> GetWidth ( ) || ( elementSize . width == 0 && mCurrentContext -> GetWidth ( ) == 1 ) ) ; MOZ_ASSERT ( elementSize . height == mCurrentContext -> GetHeight ( ) || ( elementSize . height == 0 && mCurrentContext -> GetHeight ( ) == 1 ) ) ; } #endif uint8_t * imageBuffer = nullptr ; int32_t format = 0 ; if ( mCurrentContext ) { mCurrentContext -> GetImageBuffer ( & imageBuffer , & format ) ; } class EncodeCallback : public EncodeCompleteCallback { public : EncodeCallback ( nsIGlobalObject * aGlobal , FileCallback * aCallback ) : mGlobal ( aGlobal ) , mFileCallback ( aCallback ) { } nsresult ReceiveBlob ( already_AddRefed < Blob > aBlob ) { nsRefPtr < Blob > blob = aBlob ; ErrorResult rv ; uint64_t size = blob -> GetSize ( rv ) ; if ( rv . Failed ( ) ) { rv . SuppressException ( ) ; } else { AutoJSAPI jsapi ; if ( jsapi . Init ( mGlobal ) ) { JS_updateMallocCounter ( jsapi . cx ( ) , size ) ; } } nsRefPtr < Blob > newBlob = Blob :: Create ( mGlobal , blob -> Impl ( ) ) ; mFileCallback -> Call ( * newBlob , rv ) ; mGlobal = nullptr ; mFileCallback = nullptr ; return rv . StealNSResult ( ) ; } nsCOMPtr < nsIGlobalObject > mGlobal ; nsRefPtr < FileCallback > mFileCallback ; } ; nsCOMPtr < nsIGlobalObject > global = OwnerDoc ( ) -> GetScopeObject ( ) ; MOZ_ASSERT ( global ) ; nsRefPtr < EncodeCompleteCallback > callback = new EncodeCallback ( global , & aCallback ) ; aRv = ImageEncoder :: ExtractDataAsync ( type , params , usingCustomParseOptions , imageBuffer , format , GetSize ( ) , callback ) ; }
void TransitiveClosure ( ) { while ( ! marking_stack_ . empty ( ) ) { HeapObject * obj = marking_stack_ . back ( ) ; marking_stack_ . pop_back ( ) ; obj -> Iterate ( this ) ; } }
static void filter_selectively_horiz ( uint8_t * s , int pitch , unsigned int mask_16x16 , unsigned int mask_8x8 , unsigned int mask_4x4 , unsigned int mask_4x4_int , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) { unsigned int mask ; int count ; for ( mask = mask_16x16 | mask_8x8 | mask_4x4 | mask_4x4_int ; mask ; mask >>= count ) { const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ; count = 1 ; if ( mask & 1 ) { if ( mask_16x16 & 1 ) { if ( ( mask_16x16 & 3 ) == 3 ) { vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 2 ) ; count = 2 ; } else { vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_8x8 & 1 ) { if ( ( mask_8x8 & 3 ) == 3 ) { const loop_filter_thresh * lfin = lfi_n -> lfthr + * ( lfl + 1 ) ; vp9_lpf_horizontal_8_dual ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; if ( ( mask_4x4_int & 3 ) == 3 ) { vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; else if ( mask_4x4_int & 2 ) vp9_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim , lfin -> lim , lfin -> hev_thr , 1 ) ; } count = 2 ; } else { vp9_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4 & 1 ) { if ( ( mask_4x4 & 3 ) == 3 ) { const loop_filter_thresh * lfin = lfi_n -> lfthr + * ( lfl + 1 ) ; vp9_lpf_horizontal_4_dual ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; if ( ( mask_4x4_int & 3 ) == 3 ) { vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; else if ( mask_4x4_int & 2 ) vp9_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim , lfin -> lim , lfin -> hev_thr , 1 ) ; } count = 2 ; } else { vp9_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4_int & 1 ) { vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } s += 8 * count ; lfl += count ; mask_16x16 >>= count ; mask_8x8 >>= count ; mask_4x4 >>= count ; mask_4x4_int >>= count ; } }
int CommandData :: IsProcessFile ( FileHeader & FileHead , bool * ExactMatch , int MatchType , wchar * MatchedArg , uint MatchedArgSize ) { if ( MatchedArg != NULL && MatchedArgSize > 0 ) * MatchedArg = 0 ; if ( wcslen ( FileHead . FileName ) >= NM ) return 0 ; bool Dir = FileHead . Dir ; if ( ExclCheck ( FileHead . FileName , Dir , false , true ) ) return 0 ; #ifndef SFX_MODULE if ( TimeCheck ( FileHead . mtime ) ) return 0 ; if ( ( FileHead . FileAttr & ExclFileAttr ) != 0 || InclAttrSet && ( FileHead . FileAttr & InclFileAttr ) == 0 ) return 0 ; if ( ! Dir && SizeCheck ( FileHead . UnpSize ) ) return 0 ; #endif wchar * ArgName ; FileArgs . Rewind ( ) ; for ( int StringCount = 1 ; ( ArgName = FileArgs . GetString ( ) ) != NULL ; StringCount ++ ) if ( CmpName ( ArgName , FileHead . FileName , MatchType ) ) { if ( ExactMatch != NULL ) * ExactMatch = wcsicompc ( ArgName , FileHead . FileName ) == 0 ; if ( MatchedArg != NULL ) wcsncpyz ( MatchedArg , ArgName , MatchedArgSize ) ; return StringCount ; } return 0 ; }
int main ( int argc , char * argv [ ] ) { CRYPTO_library_init ( ) ; ScopedFILE bc_file ; argc -- ; argv ++ ; while ( argc >= 1 ) { if ( strcmp ( * argv , "-bc" ) == 0 ) { if ( argc < 2 ) { fprintf ( stderr , "Missing parameter to -bc\n" ) ; return 1 ; } bc_file . reset ( fopen ( argv [ 1 ] , "w+" ) ) ; if ( ! bc_file ) { fprintf ( stderr , "Failed to open %s: %s\n" , argv [ 1 ] , strerror ( errno ) ) ; } argc -- ; argv ++ ; } else { fprintf ( stderr , "Unknown option: %s\n" , argv [ 0 ] ) ; return 1 ; } argc -- ; argv ++ ; } ScopedBN_CTX ctx ( BN_CTX_new ( ) ) ; if ( ! ctx ) { return 1 ; } puts_fp ( bc_file . get ( ) , "/* This script, when run through the UNIX bc utility, " "should produce a sequence of zeros. */\n" ) ; puts_fp ( bc_file . get ( ) , "/* tr a-f A-F < bn_test.out | sed s/BAsE/base/ | bc " "| grep -v 0 */\n" ) ; puts_fp ( bc_file . get ( ) , "obase=16\nibase=16\n" ) ; message ( bc_file . get ( ) , "BN_add" ) ; if ( ! test_add ( bc_file . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_sub" ) ; if ( ! test_sub ( bc_file . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_lshift1" ) ; if ( ! test_lshift1 ( bc_file . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_lshift (fixed)" ) ; ScopedBIGNUM sample ( BN_bin2bn ( kSample , sizeof ( kSample ) - 1 , NULL ) ) ; if ( ! sample ) { return 1 ; } if ( ! test_lshift ( bc_file . get ( ) , ctx . get ( ) , std :: move ( sample ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_lshift" ) ; if ( ! test_lshift ( bc_file . get ( ) , ctx . get ( ) , nullptr ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_rshift1" ) ; if ( ! test_rshift1 ( bc_file . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_rshift" ) ; if ( ! test_rshift ( bc_file . get ( ) , ctx . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_sqr" ) ; if ( ! test_sqr ( bc_file . get ( ) , ctx . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_mul" ) ; if ( ! test_mul ( bc_file . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_div" ) ; if ( ! test_div ( bc_file . get ( ) , ctx . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_div_word" ) ; if ( ! test_div_word ( bc_file . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_mod" ) ; if ( ! test_mod ( bc_file . get ( ) , ctx . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_mod_mul" ) ; if ( ! test_mod_mul ( bc_file . get ( ) , ctx . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_mont" ) ; if ( ! test_mont ( bc_file . get ( ) , ctx . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_mod_exp" ) ; if ( ! test_mod_exp ( bc_file . get ( ) , ctx . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_mod_exp_mont_consttime" ) ; if ( ! test_mod_exp_mont_consttime ( bc_file . get ( ) , ctx . get ( ) ) || ! test_mod_exp_mont5 ( bc_file . get ( ) , ctx . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_exp" ) ; if ( ! test_exp ( bc_file . get ( ) , ctx . get ( ) ) || ! test_exp_mod_zero ( ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_mod_sqrt" ) ; if ( ! test_mod_sqrt ( bc_file . get ( ) , ctx . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "Small prime generation" ) ; if ( ! test_small_prime ( bc_file . get ( ) , ctx . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; message ( bc_file . get ( ) , "BN_sqrt" ) ; if ( ! test_sqrt ( bc_file . get ( ) , ctx . get ( ) ) ) { return 1 ; } flush_fp ( bc_file . get ( ) ) ; if ( ! test_bn2bin_padded ( ctx . get ( ) ) || ! test_dec2bn ( ctx . get ( ) ) || ! test_hex2bn ( ctx . get ( ) ) || ! test_asc2bn ( ctx . get ( ) ) || ! test_mpi ( ) || ! test_rand ( ) || ! test_asn1 ( ) ) { return 1 ; } printf ( "PASS\n" ) ; return 0 ; }
int au1100fb_fb_mmap ( struct fb_info * fbi , struct vm_area_struct * vma ) { struct au1100fb_device * fbdev ; unsigned int len ; unsigned long start = 0 , off ; fbdev = to_au1100fb_device ( fbi ) ; if ( vma -> vm_pgoff > ( ~ 0UL > > PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff < < PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off > > PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= ( 6 < < 9 ) ; if ( io_remap_pfn_range ( vma , vma -> vm_start , off > > PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) { return - EAGAIN ; } return 0 ; }
static int rtl8xxxu_submit_int_urb ( struct ieee80211_hw * hw ) { struct rtl8xxxu_priv * priv = hw -> priv ; struct urb * urb ; u32 val32 ; int ret ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) return - ENOMEM ; usb_fill_int_urb ( urb , priv -> udev , priv -> pipe_interrupt , priv -> int_buf , USB_INTR_CONTENT_LENGTH , rtl8xxxu_int_complete , priv , 1 ) ; usb_anchor_urb ( urb , & priv -> int_anchor ) ; ret = usb_submit_urb ( urb , GFP_KERNEL ) ; if ( ret ) { usb_unanchor_urb ( urb ) ; goto error ; } val32 = rtl8xxxu_read32 ( priv , REG_USB_HIMR ) ; val32 |= USB_HIMR_CPWM ; rtl8xxxu_write32 ( priv , REG_USB_HIMR , val32 ) ; error : return ret ; }
png_user_version_check ( png_structrp png_ptr , png_const_charp user_png_ver ) { if ( user_png_ver ) { int i = 0 ; do { if ( user_png_ver [ i ] != png_libpng_ver [ i ] ) png_ptr -> flags |= PNG_FLAG_LIBRARY_MISMATCH ; } while ( png_libpng_ver [ i ++ ] ) ; } else png_ptr -> flags |= PNG_FLAG_LIBRARY_MISMATCH ; if ( png_ptr -> flags & PNG_FLAG_LIBRARY_MISMATCH ) { if ( user_png_ver == NULL || user_png_ver [ 0 ] != png_libpng_ver [ 0 ] || ( user_png_ver [ 0 ] == '1' && ( user_png_ver [ 2 ] != png_libpng_ver [ 2 ] || user_png_ver [ 3 ] != png_libpng_ver [ 3 ] ) ) || ( user_png_ver [ 0 ] == '0' && user_png_ver [ 2 ] < '9' ) ) { #ifdef PNG_WARNINGS_SUPPORTED size_t pos = 0 ; char m [ 128 ] ; pos = png_safecat ( m , ( sizeof m ) , pos , "Application built with libpng-" ) ; pos = png_safecat ( m , ( sizeof m ) , pos , user_png_ver ) ; pos = png_safecat ( m , ( sizeof m ) , pos , " but running with " ) ; pos = png_safecat ( m , ( sizeof m ) , pos , png_libpng_ver ) ; PNG_UNUSED ( pos ) png_warning ( png_ptr , m ) ; #endif #ifdef PNG_ERROR_NUMBERS_SUPPORTED png_ptr -> flags = 0 ; #endif return 0 ; } } return 1 ; }
int vp9_refining_search_sad_c ( const MACROBLOCK * x , MV * ref_mv , int error_per_bit , int search_range , const vp9_variance_fn_ptr_t * fn_ptr , int * mvjcost , int * mvcost [ 2 ] , const MV * center_mv ) { const MV neighbors [ 4 ] = { { - 1 , 0 } , { 0 , - 1 } , { 0 , 1 } , { 1 , 0 } } ; const MACROBLOCKD * const xd = & x -> e_mbd ; const struct buf_2d * const what = & x -> plane [ 0 ] . src ; const struct buf_2d * const in_what = & xd -> plane [ 0 ] . pre [ 0 ] ; const MV fcenter_mv = { center_mv -> row > > 3 , center_mv -> col > > 3 } ; const int * mvjsadcost = x -> nmvjointsadcost ; int * mvsadcost [ 2 ] = { x -> nmvsadcost [ 0 ] , x -> nmvsadcost [ 1 ] } ; unsigned int best_sad = fn_ptr -> sdf ( what -> buf , what -> stride , get_buf_from_mv ( in_what , ref_mv ) , in_what -> stride , 0x7fffffff ) + mvsad_err_cost ( ref_mv , & fcenter_mv , mvjsadcost , mvsadcost , error_per_bit ) ; int i , j ; for ( i = 0 ; i < search_range ; i ++ ) { int best_site = - 1 ; for ( j = 0 ; j < 4 ; j ++ ) { const MV mv = { ref_mv -> row + neighbors [ j ] . row , ref_mv -> col + neighbors [ j ] . col } ; if ( is_mv_in ( x , & mv ) ) { unsigned int sad = fn_ptr -> sdf ( what -> buf , what -> stride , get_buf_from_mv ( in_what , & mv ) , in_what -> stride , best_sad ) ; if ( sad < best_sad ) { sad += mvsad_err_cost ( & mv , & fcenter_mv , mvjsadcost , mvsadcost , error_per_bit ) ; if ( sad < best_sad ) { best_sad = sad ; best_site = j ; } } } } if ( best_site == - 1 ) { break ; } else { ref_mv -> row += neighbors [ best_site ] . row ; ref_mv -> col += neighbors [ best_site ] . col ; } } return best_sad ; }
NS_IMETHODIMP nsPlaintextEditor :: Cut ( ) { if ( FireClipboardEvent ( NS_CUT ) ) return DeleteSelection ( eNone , eStrip ) ; return NS_OK ; }
png_crc_finish ( png_structrp png_ptr , png_uint_32 skip ) { while ( skip > 0 ) { png_uint_32 len ; png_byte tmpbuf [ PNG_INFLATE_BUF_SIZE ] ; len = ( sizeof tmpbuf ) ; if ( len > skip ) len = skip ; skip -= len ; png_crc_read ( png_ptr , tmpbuf , len ) ; } if ( png_crc_error ( png_ptr ) ) { if ( PNG_CHUNK_ANCILLARY ( png_ptr -> chunk_name ) ? ! ( png_ptr -> flags & PNG_FLAG_CRC_ANCILLARY_NOWARN ) : ( png_ptr -> flags & PNG_FLAG_CRC_CRITICAL_USE ) ) { png_chunk_warning ( png_ptr , "CRC error" ) ; } else png_chunk_error ( png_ptr , "CRC error" ) ; return ( 1 ) ; } return ( 0 ) ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; const TfLiteTensor * input = GetInput ( context , node , kInputTensor ) ; const TfLiteTensor * diag = GetInput ( context , node , kDiagonalTensor ) ; FillDiagHelper ( input , diag , output ) ; return kTfLiteOk ; }
nsDragServiceProxy :: InvokeDragSessionImpl ( nsIArray * aArrayTransferables , nsIScriptableRegion * aRegion , uint32_t aActionType ) { nsCOMPtr < nsIDocument > doc = do_QueryInterface ( mSourceDocument ) ; NS_ENSURE_STATE ( doc -> GetDocShell ( ) ) ; TabChild * child = TabChild :: GetFrom ( doc -> GetDocShell ( ) ) ; NS_ENSURE_STATE ( child ) ; nsTArray < mozilla :: dom :: IPCDataTransfer > dataTransfers ; nsContentUtils :: TransferablesToIPCTransferables ( aArrayTransferables , dataTransfers , false , child -> Manager ( ) , nullptr ) ; LayoutDeviceIntRect dragRect ; if ( mHasImage || mSelection ) { nsPresContext * pc ; RefPtr < mozilla :: gfx :: SourceSurface > surface ; DrawDrag ( mSourceNode , aRegion , mScreenPosition , & dragRect , & surface , & pc ) ; if ( surface ) { RefPtr < mozilla :: gfx :: DataSourceSurface > dataSurface = surface -> GetDataSurface ( ) ; if ( dataSurface ) { size_t length ; int32_t stride ; Maybe < Shmem > maybeShm = nsContentUtils :: GetSurfaceData ( dataSurface , & length , & stride , child ) ; if ( maybeShm . isNothing ( ) ) { return NS_ERROR_FAILURE ; } auto surfaceData = maybeShm . value ( ) ; if ( ! surfaceData . IsReadable ( ) || ! surfaceData . get < char > ( ) ) { NS_WARNING ( "Failed to create shared memory for drag session." ) ; return NS_ERROR_FAILURE ; } mozilla :: Unused < < child -> SendInvokeDragSession ( dataTransfers , aActionType , surfaceData , stride , static_cast < uint8_t > ( dataSurface -> GetFormat ( ) ) , dragRect ) ; StartDragSession ( ) ; return NS_OK ; } } } mozilla :: Unused < < child -> SendInvokeDragSession ( dataTransfers , aActionType , mozilla :: void_t ( ) , 0 , 0 , dragRect ) ; StartDragSession ( ) ; return NS_OK ; }
TF_BUILTIN ( MapPrototypeEntries , CollectionsBuiltinsAssembler ) { Node * const receiver = Parameter ( Descriptor :: kReceiver ) ; Node * const context = Parameter ( Descriptor :: kContext ) ; ThrowIfNotInstanceType ( context , receiver , JS_MAP_TYPE , "Map.prototype.entries" ) ; Return ( AllocateJSCollectionIterator < JSMapIterator > ( context , Context :: MAP_KEY_VALUE_ITERATOR_MAP_INDEX , receiver ) ) ; }
void Debug :: PrepareStep ( StepAction step_action ) { HandleScope scope ( isolate_ ) ; DCHECK ( in_debug_scope ( ) ) ; StackFrame :: Id frame_id = break_frame_id ( ) ; if ( frame_id == StackFrame :: NO_ID ) return ; feature_tracker ( ) -> Track ( DebugFeatureTracker :: kStepping ) ; thread_local_ . last_step_action_ = step_action ; StackTraceFrameIterator frames_it ( isolate_ , frame_id ) ; StandardFrame * frame = frames_it . frame ( ) ; if ( frame -> is_wasm ( ) ) { if ( frame -> is_wasm_compiled ( ) ) return ; WasmInterpreterEntryFrame * wasm_frame = WasmInterpreterEntryFrame :: cast ( frame ) ; wasm_frame -> debug_info ( ) -> PrepareStep ( step_action ) ; return ; } JavaScriptFrame * js_frame = JavaScriptFrame :: cast ( frame ) ; DCHECK ( js_frame -> function ( ) -> IsJSFunction ( ) ) ; auto summary = FrameSummary :: GetTop ( frame ) . AsJavaScript ( ) ; Handle < JSFunction > function ( summary . function ( ) ) ; Handle < SharedFunctionInfo > shared ( function -> shared ( ) , isolate_ ) ; if ( ! EnsureBreakInfo ( shared ) ) return ; PrepareFunctionForDebugExecution ( shared ) ; Handle < DebugInfo > debug_info ( shared -> GetDebugInfo ( ) , isolate_ ) ; BreakLocation location = BreakLocation :: FromFrame ( debug_info , js_frame ) ; if ( location . IsReturn ( ) || ( location . IsSuspend ( ) && step_action == StepOut ) ) { if ( last_step_action ( ) == StepOut ) { thread_local_ . ignore_step_into_function_ = * function ; } step_action = StepOut ; thread_local_ . last_step_action_ = StepIn ; } UpdateHookOnFunctionCall ( ) ; if ( step_action == StepNext && IsBlackboxed ( shared ) ) step_action = StepOut ; thread_local_ . last_statement_position_ = summary . abstract_code ( ) -> SourceStatementPosition ( summary . code_offset ( ) ) ; int current_frame_count = CurrentFrameCount ( ) ; thread_local_ . last_frame_count_ = current_frame_count ; clear_suspended_generator ( ) ; switch ( step_action ) { case StepNone : UNREACHABLE ( ) ; break ; case StepOut : { thread_local_ . last_statement_position_ = kNoSourcePosition ; thread_local_ . last_frame_count_ = - 1 ; if ( ! location . IsReturnOrSuspend ( ) && ! IsBlackboxed ( shared ) ) { thread_local_ . target_frame_count_ = current_frame_count ; thread_local_ . fast_forward_to_return_ = true ; FloodWithOneShot ( shared , true ) ; return ; } bool in_current_frame = true ; for ( ; ! frames_it . done ( ) ; frames_it . Advance ( ) ) { if ( frames_it . frame ( ) -> is_wasm ( ) ) continue ; JavaScriptFrame * frame = JavaScriptFrame :: cast ( frames_it . frame ( ) ) ; if ( last_step_action ( ) == StepIn ) { Deoptimizer :: DeoptimizeFunction ( frame -> function ( ) ) ; } HandleScope scope ( isolate_ ) ; std :: vector < Handle < SharedFunctionInfo > > infos ; frame -> GetFunctions ( & infos ) ; for ( ; ! infos . empty ( ) ; current_frame_count -- ) { Handle < SharedFunctionInfo > info = infos . back ( ) ; infos . pop_back ( ) ; if ( in_current_frame ) { in_current_frame = false ; continue ; } if ( IsBlackboxed ( info ) ) continue ; FloodWithOneShot ( info ) ; thread_local_ . target_frame_count_ = current_frame_count ; return ; } } break ; } case StepNext : thread_local_ . target_frame_count_ = current_frame_count ; V8_FALLTHROUGH ; case StepIn : FloodWithOneShot ( shared ) ; break ; } }
Reduction JSTypedLowering :: ReduceJSDecrement ( Node * node ) { Node * input = NodeProperties :: GetValueInput ( node , 0 ) ; Type input_type = NodeProperties :: GetType ( input ) ; if ( input_type . Is ( Type :: PlainPrimitive ( ) ) ) { node -> InsertInput ( graph ( ) -> zone ( ) , 1 , jsgraph ( ) -> OneConstant ( ) ) ; NodeProperties :: ChangeOp ( node , javascript ( ) -> Subtract ( ) ) ; JSBinopReduction r ( this , node ) ; r . ConvertInputsToNumber ( ) ; DCHECK_EQ ( simplified ( ) -> NumberSubtract ( ) , r . NumberOp ( ) ) ; return r . ChangeToPureOperator ( r . NumberOp ( ) , Type :: Number ( ) ) ; } return NoChange ( ) ; }
StackScopedCloneWrite ( JSContext * cx , JSStructuredCloneWriter * writer , Handle < JSObject * > objArg , void * closure ) { MOZ_ASSERT ( closure , "Null pointer!" ) ; StackScopedCloneData * cloneData = static_cast < StackScopedCloneData * > ( closure ) ; RootedObject obj ( cx , JS_ObjectToInnerObject ( cx , objArg ) ) ; if ( ( cloneData -> mOptions -> wrapReflectors && IsReflector ( obj ) ) || IsBlobOrFileList ( obj ) ) { if ( ! cloneData -> mReflectors . append ( obj ) ) return false ; size_t idx = cloneData -> mReflectors . length ( ) - 1 ; if ( ! JS_WriteUint32Pair ( writer , SCTAG_REFLECTOR , 0 ) ) return false ; if ( ! JS_WriteBytes ( writer , & idx , sizeof ( size_t ) ) ) return false ; return true ; } if ( JS_ObjectIsCallable ( cx , obj ) ) { if ( cloneData -> mOptions -> cloneFunctions ) { cloneData -> mFunctions . append ( obj ) ; return JS_WriteUint32Pair ( writer , SCTAG_FUNCTION , cloneData -> mFunctions . length ( ) - 1 ) ; } else { JS_ReportError ( cx , "Permission denied to pass a Function via structured clone" ) ; return false ; } } JS_ReportError ( cx , "Encountered unsupported value type writing stack-scoped structured clone" ) ; return false ; }
SystemWorkerManager :: Init ( ) { if ( XRE_GetProcessType ( ) != GeckoProcessType_Default ) { return NS_ERROR_NOT_AVAILABLE ; } NS_ASSERTION ( NS_IsMainThread ( ) , "We can only initialize on the main thread" ) ; NS_ASSERTION ( ! mShutdown , "Already shutdown!" ) ; JSContext * cx = nsContentUtils :: ThreadJSContextStack ( ) -> GetSafeJSContext ( ) ; NS_ENSURE_TRUE ( cx , NS_ERROR_FAILURE ) ; nsCxPusher pusher ; if ( ! pusher . Push ( cx , false ) ) { return NS_ERROR_FAILURE ; } nsresult rv = InitWifi ( cx ) ; if ( NS_FAILED ( rv ) ) { NS_WARNING ( "Failed to initialize WiFi Networking!" ) ; return rv ; } #ifdef MOZ_WIDGET_GONK InitAutoMounter ( ) ; InitializeTimeZoneSettingObserver ( ) ; rv = InitNetd ( cx ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; #endif nsCOMPtr < nsIObserverService > obs = do_GetService ( NS_OBSERVERSERVICE_CONTRACTID ) ; if ( ! obs ) { NS_WARNING ( "Failed to get observer service!" ) ; return NS_ERROR_FAILURE ; } rv = obs -> AddObserver ( this , WORKERS_SHUTDOWN_TOPIC , false ) ; if ( NS_FAILED ( rv ) ) { NS_WARNING ( "Failed to initialize worker shutdown event!" ) ; return rv ; } return NS_OK ; }
png_handle_sCAL ( png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) { png_bytep buffer ; png_size_t i ; int state ; png_debug ( 1 , "in png_handle_sCAL" ) ; if ( ! ( png_ptr -> mode & PNG_HAVE_IHDR ) ) png_chunk_error ( png_ptr , "missing IHDR" ) ; else if ( png_ptr -> mode & PNG_HAVE_IDAT ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "out of place" ) ; return ; } else if ( info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_sCAL ) ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "duplicate" ) ; return ; } else if ( length < 4 ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "invalid" ) ; return ; } png_debug1 ( 2 , "Allocating and reading sCAL chunk data (%u bytes)" , length + 1 ) ; buffer = png_read_buffer ( png_ptr , length + 1 , 2 ) ; if ( buffer == NULL ) { png_chunk_benign_error ( png_ptr , "out of memory" ) ; png_crc_finish ( png_ptr , length ) ; return ; } png_crc_read ( png_ptr , buffer , length ) ; buffer [ length ] = 0 ; if ( png_crc_finish ( png_ptr , 0 ) ) return ; if ( buffer [ 0 ] != 1 && buffer [ 0 ] != 2 ) { png_chunk_benign_error ( png_ptr , "invalid unit" ) ; return ; } i = 1 ; state = 0 ; if ( ! png_check_fp_number ( ( png_const_charp ) buffer , length , & state , & i ) || i >= length || buffer [ i ++ ] != 0 ) png_chunk_benign_error ( png_ptr , "bad width format" ) ; else if ( ! PNG_FP_IS_POSITIVE ( state ) ) png_chunk_benign_error ( png_ptr , "non-positive width" ) ; else { png_size_t heighti = i ; state = 0 ; if ( ! png_check_fp_number ( ( png_const_charp ) buffer , length , & state , & i ) || i != length ) png_chunk_benign_error ( png_ptr , "bad height format" ) ; else if ( ! PNG_FP_IS_POSITIVE ( state ) ) png_chunk_benign_error ( png_ptr , "non-positive height" ) ; else png_set_sCAL_s ( png_ptr , info_ptr , buffer [ 0 ] , ( png_charp ) buffer + 1 , ( png_charp ) buffer + heighti ) ; } }
check_rpcsec_auth ( struct svc_req * rqstp ) { gss_ctx_id_t ctx ; krb5_context kctx ; OM_uint32 maj_stat , min_stat ; gss_name_t name ; krb5_principal princ ; int ret , success ; krb5_data * c1 , * c2 , * realm ; gss_buffer_desc gss_str ; kadm5_server_handle_t handle ; size_t slen ; char * sdots ; success = 0 ; handle = ( kadm5_server_handle_t ) global_server_handle ; if ( rqstp -> rq_cred . oa_flavor != RPCSEC_GSS ) return 0 ; ctx = rqstp -> rq_svccred ; maj_stat = gss_inquire_context ( & min_stat , ctx , NULL , & name , NULL , NULL , NULL , NULL , NULL ) ; if ( maj_stat != GSS_S_COMPLETE ) { krb5_klog_syslog ( LOG_ERR , _ ( "check_rpcsec_auth: failed " "inquire_context, stat=%u" ) , maj_stat ) ; log_badauth ( maj_stat , min_stat , rqstp -> rq_xprt , NULL ) ; goto fail_name ; } kctx = handle -> context ; ret = gss_to_krb5_name_1 ( rqstp , kctx , name , & princ , & gss_str ) ; if ( ret == 0 ) goto fail_name ; slen = gss_str . length ; trunc_name ( & slen , & sdots ) ; if ( krb5_princ_size ( kctx , princ ) != 2 ) goto fail_princ ; c1 = krb5_princ_component ( kctx , princ , 0 ) ; c2 = krb5_princ_component ( kctx , princ , 1 ) ; realm = krb5_princ_realm ( kctx , princ ) ; if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 && strncmp ( "kadmin" , c1 -> data , c1 -> length ) == 0 ) { if ( strncmp ( "history" , c2 -> data , c2 -> length ) == 0 ) goto fail_princ ; else success = 1 ; } fail_princ : if ( ! success ) { krb5_klog_syslog ( LOG_ERR , _ ( "bad service principal %.*s%s" ) , ( int ) slen , ( char * ) gss_str . value , sdots ) ; } gss_release_buffer ( & min_stat , & gss_str ) ; krb5_free_principal ( kctx , princ ) ; fail_name : gss_release_name ( & min_stat , & name ) ; return success ; }
static M_fs_error_t M_fs_copy_file ( const char * path_old , const char * path_new , M_fs_file_mode_t mode , M_fs_progress_cb_t cb , M_fs_progress_flags_t progress_flags , M_fs_progress_t * progress , const M_fs_perms_t * perms ) { M_fs_file_t * fd_old ; M_fs_file_t * fd_new ; M_fs_info_t * info = NULL ; unsigned char temp [ M_FS_BUF_SIZE ] ; size_t read_len ; size_t wrote_len ; size_t wrote_total = 0 ; size_t offset ; M_fs_error_t res ; if ( M_fs_perms_can_access ( path_new , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { res = M_fs_delete ( path_new , M_FALSE , NULL , M_FS_PROGRESS_NOEXTRA ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } } res = M_fs_file_open ( & fd_old , path_old , M_FS_BUF_SIZE , M_FS_FILE_MODE_READ | M_FS_FILE_MODE_NOCREATE , NULL ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } if ( perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS ) { res = M_fs_info_file ( & info , fd_old , M_FS_PATH_INFO_FLAGS_NONE ) ; if ( res != M_FS_ERROR_SUCCESS ) { M_fs_file_close ( fd_old ) ; return res ; } perms = M_fs_info_get_perms ( info ) ; } res = M_fs_file_open ( & fd_new , path_new , M_FS_BUF_SIZE , M_FS_FILE_MODE_WRITE | M_FS_FILE_MODE_OVERWRITE , perms ) ; M_fs_info_destroy ( info ) ; if ( res != M_FS_ERROR_SUCCESS ) { M_fs_file_close ( fd_old ) ; return res ; } while ( ( res = M_fs_file_read ( fd_old , temp , sizeof ( temp ) , & read_len , M_FS_FILE_RW_NORMAL ) ) == M_FS_ERROR_SUCCESS && read_len != 0 ) { offset = 0 ; while ( offset < read_len ) { res = M_fs_file_write ( fd_new , temp + offset , read_len - offset , & wrote_len , M_FS_FILE_RW_NORMAL ) ; offset += wrote_len ; wrote_total += wrote_len ; if ( cb ) { M_fs_progress_set_result ( progress , res ) ; if ( progress_flags & M_FS_PROGRESS_SIZE_TOTAL ) { M_fs_progress_set_size_total_progess ( progress , M_fs_progress_get_size_total_progess ( progress ) + wrote_len ) ; } if ( progress_flags & M_FS_PROGRESS_SIZE_CUR ) { M_fs_progress_set_size_current_progress ( progress , wrote_total ) ; } if ( progress_flags & M_FS_PROGRESS_COUNT ) { M_fs_progress_set_count ( progress , M_fs_progress_get_count ( progress ) + 1 ) ; } if ( ! cb ( progress ) ) { res = M_FS_ERROR_CANCELED ; } } if ( res != M_FS_ERROR_SUCCESS ) { break ; } } if ( res != M_FS_ERROR_SUCCESS ) { break ; } } M_fs_file_close ( fd_old ) ; M_fs_file_close ( fd_new ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } return M_FS_ERROR_SUCCESS ; }
static int get_exif_tag_dbl_value ( struct iw_exif_state * e , unsigned int tag_pos , double * pv ) { unsigned int field_type ; unsigned int value_count ; unsigned int value_pos ; unsigned int numer , denom ; field_type = iw_get_ui16_e ( & e -> d [ tag_pos + 2 ] , e -> endian ) ; value_count = iw_get_ui32_e ( & e -> d [ tag_pos + 4 ] , e -> endian ) ; if ( value_count != 1 ) return 0 ; if ( field_type != 5 ) return 0 ; value_pos = iw_get_ui32_e ( & e -> d [ tag_pos + 8 ] , e -> endian ) ; if ( value_pos > e -> d_len - 8 ) return 0 ; numer = iw_get_ui32_e ( & e -> d [ value_pos ] , e -> endian ) ; denom = iw_get_ui32_e ( & e -> d [ value_pos + 4 ] , e -> endian ) ; if ( denom == 0 ) return 0 ; * pv = ( ( double ) numer ) / denom ; return 1 ; }
static int xfrm_user_rcv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh ) { struct net * net = sock_net ( skb -> sk ) ; struct nlattr * attrs [ XFRMA_MAX + 1 ] ; const struct xfrm_link * link ; int type , err ; type = nlh -> nlmsg_type ; if ( type > XFRM_MSG_MAX ) return - EINVAL ; type -= XFRM_MSG_BASE ; link = & xfrm_dispatch [ type ] ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; if ( ( type == ( XFRM_MSG_GETSA - XFRM_MSG_BASE ) || type == ( XFRM_MSG_GETPOLICY - XFRM_MSG_BASE ) ) && ( nlh -> nlmsg_flags & NLM_F_DUMP ) ) { if ( link -> dump == NULL ) return - EINVAL ; { struct netlink_dump_control c = { . dump = link -> dump , . done = link -> done , } ; return netlink_dump_start ( net -> xfrm . nlsk , skb , nlh , & c ) ; } } err = nlmsg_parse ( nlh , xfrm_msg_min [ type ] , attrs , XFRMA_MAX , xfrma_policy ) ; if ( err < 0 ) return err ; if ( link -> doit == NULL ) return - EINVAL ; return link -> doit ( skb , nlh , attrs ) ; }
void GenerateInternalArrayConstructorCase ( MacroAssembler * masm , ElementsKind kind ) { Label not_zero_case , not_one_case ; Label normal_sequence ; __ test ( eax , eax ) ; __ j ( not_zero , & not_zero_case ) ; __ Jump ( CodeFactory :: InternalArrayNoArgumentConstructor ( masm -> isolate ( ) , kind ) . code ( ) , RelocInfo :: CODE_TARGET ) ; __ bind ( & not_zero_case ) ; __ cmp ( eax , 1 ) ; __ j ( greater , & not_one_case ) ; if ( IsFastPackedElementsKind ( kind ) ) { __ mov ( ecx , Operand ( esp , kPointerSize ) ) ; __ test ( ecx , ecx ) ; __ j ( zero , & normal_sequence ) ; __ Jump ( CodeFactory :: InternalArraySingleArgumentConstructor ( masm -> isolate ( ) , GetHoleyElementsKind ( kind ) ) . code ( ) , RelocInfo :: CODE_TARGET ) ; } __ bind ( & normal_sequence ) ; __ Jump ( CodeFactory :: InternalArraySingleArgumentConstructor ( masm -> isolate ( ) , kind ) . code ( ) , RelocInfo :: CODE_TARGET ) ; __ bind ( & not_one_case ) ; __ Move ( kJavaScriptCallExtraArg1Register , ebx ) ; Handle < Code > code = BUILTIN_CODE ( masm -> isolate ( ) , ArrayNArgumentsConstructor ) ; __ Jump ( code , RelocInfo :: CODE_TARGET ) ; }
auto uncomp = output_buffer . make_fragmented_temporary_buffer ( uncomp_len , fragmented_temporary_buffer :: default_fragment_size , [ & ] ( bytes_mutable_view out ) { auto ret = LZ4_decompress_safe ( reinterpret_cast < const char * > ( in . data ( ) ) , reinterpret_cast < char * > ( out . data ( ) ) , in . size ( ) , out . size ( ) ) ; if ( ret < 0 ) { throw std :: runtime_error ( "CQL frame LZ4 uncompression failure" ) ; } - - return out . size ( ) ; + if ( ret != out . size ( ) ) { + throw std :: runtime_error ( "Malformed CQL frame - provided uncompressed size different than real uncompressed size" ) ; + } + return static_cast < size_t > ( ret ) ; + if ( ret != out . size ( ) ) { + throw std :: runtime_error ( "Malformed CQL frame - provided uncompressed size different than real uncompressed size" ) ; + } + return static_cast < size_t > ( ret ) ; } ) ;
bool Cues :: Find ( long long time_ns , const Track * pTrack , const CuePoint * & pCP , const CuePoint :: TrackPosition * & pTP ) const { assert ( time_ns >= 0 ) ; assert ( pTrack ) ; #if 0 LoadCuePoint ( ) ; assert ( m_cue_points ) ; assert ( m_count > 0 ) ; CuePoint * * const ii = m_cue_points ; CuePoint * * i = ii ; CuePoint * * const jj = ii + m_count + m_preload_count ; CuePoint * * j = jj ; pCP = * i ; assert ( pCP ) ; if ( time_ns <= pCP -> GetTime ( m_pSegment ) ) { pTP = pCP -> Find ( pTrack ) ; return ( pTP != NULL ) ; } IMkvReader * const pReader = m_pSegment -> m_pReader ; while ( i < j ) { CuePoint * * const k = i + ( j - i ) / 2 ; assert ( k < jj ) ; CuePoint * const pCP = * k ; assert ( pCP ) ; pCP -> Load ( pReader ) ; const long long t = pCP -> GetTime ( m_pSegment ) ; if ( t <= time_ns ) i = k + 1 ; else j = k ; assert ( i <= j ) ; } assert ( i == j ) ; assert ( i <= jj ) ; assert ( i > ii ) ; pCP = * -- i ; assert ( pCP ) ; assert ( pCP -> GetTime ( m_pSegment ) <= time_ns ) ; #else if ( m_cue_points == NULL ) return false ; if ( m_count == 0 ) return false ; CuePoint * * const ii = m_cue_points ; CuePoint * * i = ii ; CuePoint * * const jj = ii + m_count ; CuePoint * * j = jj ; pCP = * i ; assert ( pCP ) ; if ( time_ns <= pCP -> GetTime ( m_pSegment ) ) { pTP = pCP -> Find ( pTrack ) ; return ( pTP != NULL ) ; } while ( i < j ) { CuePoint * * const k = i + ( j - i ) / 2 ; assert ( k < jj ) ; CuePoint * const pCP = * k ; assert ( pCP ) ; const long long t = pCP -> GetTime ( m_pSegment ) ; if ( t <= time_ns ) i = k + 1 ; else j = k ; assert ( i <= j ) ; } assert ( i == j ) ; assert ( i <= jj ) ; assert ( i > ii ) ; pCP = * -- i ; assert ( pCP ) ; assert ( pCP -> GetTime ( m_pSegment ) <= time_ns ) ; #endif pTP = pCP -> Find ( pTrack ) ; return ( pTP != NULL ) ; }
GF_Err iloc_box_read ( GF_Box * s , GF_BitStream * bs ) { u32 item_count , extent_count , i , j ; GF_ItemLocationBox * ptr = ( GF_ItemLocationBox * ) s ; ISOM_DECREASE_SIZE ( ptr , 2 ) ptr -> offset_size = gf_bs_read_int ( bs , 4 ) ; ptr -> length_size = gf_bs_read_int ( bs , 4 ) ; ptr -> base_offset_size = gf_bs_read_int ( bs , 4 ) ; if ( ptr -> version == 1 || ptr -> version == 2 ) { ptr -> index_size = gf_bs_read_int ( bs , 4 ) ; } else { gf_bs_read_int ( bs , 4 ) ; } if ( ptr -> version < 2 ) { ISOM_DECREASE_SIZE ( ptr , 2 ) item_count = gf_bs_read_u16 ( bs ) ; } else { ISOM_DECREASE_SIZE ( ptr , 4 ) item_count = gf_bs_read_u32 ( bs ) ; } for ( i = 0 ; i < item_count ; i ++ ) { GF_ItemLocationEntry * location_entry = ( GF_ItemLocationEntry * ) gf_malloc ( sizeof ( GF_ItemLocationEntry ) ) ; if ( ! location_entry ) return GF_OUT_OF_MEM ; gf_list_add ( ptr -> location_entries , location_entry ) ; if ( ptr -> version < 2 ) { ISOM_DECREASE_SIZE ( ptr , 2 ) location_entry -> item_ID = gf_bs_read_u16 ( bs ) ; } else { ISOM_DECREASE_SIZE ( ptr , 4 ) location_entry -> item_ID = gf_bs_read_u32 ( bs ) ; } if ( ptr -> version == 1 || ptr -> version == 2 ) { ISOM_DECREASE_SIZE ( ptr , 2 ) location_entry -> construction_method = gf_bs_read_u16 ( bs ) ; } else { location_entry -> construction_method = 0 ; } ISOM_DECREASE_SIZE ( ptr , ( 2 + ptr -> base_offset_size ) ) location_entry -> data_reference_index = gf_bs_read_u16 ( bs ) ; location_entry -> base_offset = gf_bs_read_int ( bs , 8 * ptr -> base_offset_size ) ; #ifndef GPAC_DISABLE_ISOM_WRITE location_entry -> original_base_offset = location_entry -> base_offset ; #endif ISOM_DECREASE_SIZE ( ptr , 2 ) extent_count = gf_bs_read_u16 ( bs ) ; location_entry -> extent_entries = gf_list_new ( ) ; for ( j = 0 ; j < extent_count ; j ++ ) { GF_ItemExtentEntry * extent_entry = ( GF_ItemExtentEntry * ) gf_malloc ( sizeof ( GF_ItemExtentEntry ) ) ; if ( ! extent_entry ) return GF_OUT_OF_MEM ; gf_list_add ( location_entry -> extent_entries , extent_entry ) ; if ( ( ptr -> version == 1 || ptr -> version == 2 ) && ptr -> index_size > 0 ) { ISOM_DECREASE_SIZE ( ptr , ptr -> index_size ) extent_entry -> extent_index = gf_bs_read_int ( bs , 8 * ptr -> index_size ) ; } else { extent_entry -> extent_index = 0 ; } ISOM_DECREASE_SIZE ( ptr , ( ptr -> offset_size + ptr -> length_size ) ) extent_entry -> extent_offset = gf_bs_read_int ( bs , 8 * ptr -> offset_size ) ; extent_entry -> extent_length = gf_bs_read_int ( bs , 8 * ptr -> length_size ) ; #ifndef GPAC_DISABLE_ISOM_WRITE extent_entry -> original_extent_offset = extent_entry -> extent_offset ; #endif } } return GF_OK ; }
MaybeHandle < MutableBigInt > MutableBigInt :: BitwiseXor ( Isolate * isolate , Handle < BigInt > x , Handle < BigInt > y ) { if ( ! x -> sign ( ) && ! y -> sign ( ) ) { return AbsoluteXor ( isolate , x , y ) ; } else if ( x -> sign ( ) && y -> sign ( ) ) { int result_length = Max ( x -> length ( ) , y -> length ( ) ) ; Handle < MutableBigInt > result = AbsoluteSubOne ( isolate , x , result_length ) . ToHandleChecked ( ) ; Handle < MutableBigInt > y_1 = AbsoluteSubOne ( isolate , y ) ; return AbsoluteXor ( isolate , result , y_1 , * result ) ; } else { DCHECK ( x -> sign ( ) != y -> sign ( ) ) ; int result_length = Max ( x -> length ( ) , y -> length ( ) ) + 1 ; if ( x -> sign ( ) ) std :: swap ( x , y ) ; Handle < MutableBigInt > result ; if ( ! AbsoluteSubOne ( isolate , y , result_length ) . ToHandle ( & result ) ) { return MaybeHandle < MutableBigInt > ( ) ; } result = AbsoluteXor ( isolate , result , x , * result ) ; return AbsoluteAddOne ( isolate , result , true , * result ) ; } }
void zunionInterGenericCommand ( client * c , robj * dstkey , int op ) { int i , j ; long setnum ; int aggregate = REDIS_AGGR_SUM ; zsetopsrc * src ; zsetopval zval ; sds tmp ; size_t maxelelen = 0 ; robj * dstobj ; zset * dstzset ; zskiplistNode * znode ; int touched = 0 ; if ( ( getLongFromObjectOrReply ( c , c -> argv [ 2 ] , & setnum , NULL ) != C_OK ) ) return ; if ( setnum < 1 ) { addReplyError ( c , "at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE" ) ; return ; } if ( setnum > c -> argc - 3 ) { addReply ( c , shared . syntaxerr ) ; return ; } src = zcalloc ( sizeof ( zsetopsrc ) * setnum ) ; for ( i = 0 , j = 3 ; i < setnum ; i ++ , j ++ ) { robj * obj = lookupKeyWrite ( c -> db , c -> argv [ j ] ) ; if ( obj != NULL ) { if ( obj -> type != OBJ_ZSET && obj -> type != OBJ_SET ) { zfree ( src ) ; addReply ( c , shared . wrongtypeerr ) ; return ; } src [ i ] . subject = obj ; src [ i ] . type = obj -> type ; src [ i ] . encoding = obj -> encoding ; } else { src [ i ] . subject = NULL ; } src [ i ] . weight = 1.0 ; } if ( j < c -> argc ) { int remaining = c -> argc - j ; while ( remaining ) { if ( remaining >= ( setnum + 1 ) && ! strcasecmp ( c -> argv [ j ] -> ptr , "weights" ) ) { j ++ ; remaining -- ; for ( i = 0 ; i < setnum ; i ++ , j ++ , remaining -- ) { if ( getDoubleFromObjectOrReply ( c , c -> argv [ j ] , & src [ i ] . weight , "weight value is not a float" ) != C_OK ) { zfree ( src ) ; return ; } } } else if ( remaining >= 2 && ! strcasecmp ( c -> argv [ j ] -> ptr , "aggregate" ) ) { j ++ ; remaining -- ; if ( ! strcasecmp ( c -> argv [ j ] -> ptr , "sum" ) ) { aggregate = REDIS_AGGR_SUM ; } else if ( ! strcasecmp ( c -> argv [ j ] -> ptr , "min" ) ) { aggregate = REDIS_AGGR_MIN ; } else if ( ! strcasecmp ( c -> argv [ j ] -> ptr , "max" ) ) { aggregate = REDIS_AGGR_MAX ; } else { zfree ( src ) ; addReply ( c , shared . syntaxerr ) ; return ; } j ++ ; remaining -- ; } else { zfree ( src ) ; addReply ( c , shared . syntaxerr ) ; return ; } } } qsort ( src , setnum , sizeof ( zsetopsrc ) , zuiCompareByCardinality ) ; dstobj = createZsetObject ( ) ; dstzset = dstobj -> ptr ; memset ( & zval , 0 , sizeof ( zval ) ) ; if ( op == SET_OP_INTER ) { if ( zuiLength ( & src [ 0 ] ) > 0 ) { zuiInitIterator ( & src [ 0 ] ) ; while ( zuiNext ( & src [ 0 ] , & zval ) ) { double score , value ; score = src [ 0 ] . weight * zval . score ; if ( isnan ( score ) ) score = 0 ; for ( j = 1 ; j < setnum ; j ++ ) { if ( src [ j ] . subject == src [ 0 ] . subject ) { value = zval . score * src [ j ] . weight ; zunionInterAggregate ( & score , value , aggregate ) ; } else if ( zuiFind ( & src [ j ] , & zval , & value ) ) { value *= src [ j ] . weight ; zunionInterAggregate ( & score , value , aggregate ) ; } else { break ; } } if ( j == setnum ) { tmp = zuiNewSdsFromValue ( & zval ) ; znode = zslInsert ( dstzset -> zsl , score , tmp ) ; dictAdd ( dstzset -> dict , tmp , & znode -> score ) ; if ( sdslen ( tmp ) > maxelelen ) maxelelen = sdslen ( tmp ) ; } } zuiClearIterator ( & src [ 0 ] ) ; } } else if ( op == SET_OP_UNION ) { dict * accumulator = dictCreate ( & setAccumulatorDictType , NULL ) ; dictIterator * di ; dictEntry * de , * existing ; double score ; if ( setnum ) { dictExpand ( accumulator , zuiLength ( & src [ setnum - 1 ] ) ) ; } for ( i = 0 ; i < setnum ; i ++ ) { if ( zuiLength ( & src [ i ] ) == 0 ) continue ; zuiInitIterator ( & src [ i ] ) ; while ( zuiNext ( & src [ i ] , & zval ) ) { score = src [ i ] . weight * zval . score ; if ( isnan ( score ) ) score = 0 ; de = dictAddRaw ( accumulator , zuiSdsFromValue ( & zval ) , & existing ) ; if ( ! existing ) { tmp = zuiNewSdsFromValue ( & zval ) ; if ( sdslen ( tmp ) > maxelelen ) maxelelen = sdslen ( tmp ) ; dictSetKey ( accumulator , de , tmp ) ; dictSetDoubleVal ( de , score ) ; } else { zunionInterAggregate ( & existing -> v . d , score , aggregate ) ; } } zuiClearIterator ( & src [ i ] ) ; } di = dictGetIterator ( accumulator ) ; dictExpand ( dstzset -> dict , dictSize ( accumulator ) ) ; while ( ( de = dictNext ( di ) ) != NULL ) { sds ele = dictGetKey ( de ) ; score = dictGetDoubleVal ( de ) ; znode = zslInsert ( dstzset -> zsl , score , ele ) ; dictAdd ( dstzset -> dict , ele , & znode -> score ) ; } dictReleaseIterator ( di ) ; dictRelease ( accumulator ) ; } else { serverPanic ( "Unknown operator" ) ; } if ( dbDelete ( c -> db , dstkey ) ) touched = 1 ; if ( dstzset -> zsl -> length ) { zsetConvertToZiplistIfNeeded ( dstobj , maxelelen ) ; dbAdd ( c -> db , dstkey , dstobj ) ; addReplyLongLong ( c , zsetLength ( dstobj ) ) ; signalModifiedKey ( c , c -> db , dstkey ) ; notifyKeyspaceEvent ( NOTIFY_ZSET , ( op == SET_OP_UNION ) ? "zunionstore" : "zinterstore" , dstkey , c -> db -> id ) ; server . dirty ++ ; } else { decrRefCount ( dstobj ) ; addReply ( c , shared . czero ) ; if ( touched ) { signalModifiedKey ( c , c -> db , dstkey ) ; notifyKeyspaceEvent ( NOTIFY_GENERIC , "del" , dstkey , c -> db -> id ) ; server . dirty ++ ; } } zfree ( src ) ; }
bool IsCanceled ( ) { MutexAutoLock lock ( mLock ) ; return mCurrentTaskIsCanceled ; }
TF_BUILTIN ( GeneratorPrototypeNext , GeneratorBuiltinsAssembler ) { const int kValueArg = 0 ; Node * argc = ChangeInt32ToIntPtr ( Parameter ( Descriptor :: kJSActualArgumentsCount ) ) ; CodeStubArguments args ( this , argc ) ; Node * receiver = args . GetReceiver ( ) ; Node * value = args . GetOptionalArgumentValue ( kValueArg ) ; Node * context = Parameter ( Descriptor :: kContext ) ; GeneratorPrototypeResume ( & args , receiver , value , context , JSGeneratorObject :: kNext , "[Generator].prototype.next" ) ; }
void InterpreterAssembler :: CallJSWithSpreadAndDispatch ( Node * function , Node * context , const RegListNodePair & args , Node * slot_id , Node * feedback_vector ) { DCHECK ( Bytecodes :: MakesCallAlongCriticalPath ( bytecode_ ) ) ; DCHECK_EQ ( Bytecodes :: GetReceiverMode ( bytecode_ ) , ConvertReceiverMode :: kAny ) ; CollectCallFeedback ( function , context , feedback_vector , slot_id ) ; Comment ( "call using CallWithSpread builtin" ) ; Callable callable = CodeFactory :: InterpreterPushArgsThenCall ( isolate ( ) , ConvertReceiverMode :: kAny , InterpreterPushArgsMode :: kWithFinalSpread ) ; Node * code_target = HeapConstant ( callable . code ( ) ) ; Node * receiver_count = Int32Constant ( 1 ) ; Node * args_count = Int32Sub ( args . reg_count ( ) , receiver_count ) ; TailCallStubThenBytecodeDispatch ( callable . descriptor ( ) , code_target , context , args_count , args . base_reg_location ( ) , function ) ; accumulator_use_ = accumulator_use_ | AccumulatorUse :: kWrite ; }
static pj_status_t pjsip_auth_verify ( const pjsip_authorization_hdr * hdr , const pj_str_t * method , const pjsip_cred_info * cred_info ) { if ( pj_stricmp ( & hdr -> scheme , & pjsip_DIGEST_STR ) == 0 ) { char digest_buf [ PJSIP_MD5STRLEN ] ; pj_str_t digest ; const pjsip_digest_credential * dig = & hdr -> credential . digest ; PJ_ASSERT_RETURN ( pj_strcmp ( & dig -> username , & cred_info -> username ) == 0 , PJ_EINVALIDOP ) ; PJ_ASSERT_RETURN ( pj_strcmp ( & dig -> realm , & cred_info -> realm ) == 0 , PJ_EINVALIDOP ) ; digest . ptr = digest_buf ; digest . slen = PJSIP_MD5STRLEN ; pjsip_auth_create_digest ( & digest , & hdr -> credential . digest . nonce , & hdr -> credential . digest . nc , & hdr -> credential . digest . cnonce , & hdr -> credential . digest . qop , & hdr -> credential . digest . uri , & cred_info -> realm , cred_info , method ) ; return ( pj_stricmp ( & digest , & hdr -> credential . digest . response ) == 0 ) ? PJ_SUCCESS : PJSIP_EAUTHINVALIDDIGEST ; } else { pj_assert ( ! "Unsupported authentication scheme" ) ; return PJSIP_EINVALIDAUTHSCHEME ; } }
void vp8_init_mbmode_probs ( VP8_COMMON * x ) { vpx_memcpy ( x -> fc . ymode_prob , vp8_ymode_prob , sizeof ( vp8_ymode_prob ) ) ; vpx_memcpy ( x -> fc . uv_mode_prob , vp8_uv_mode_prob , sizeof ( vp8_uv_mode_prob ) ) ; vpx_memcpy ( x -> fc . sub_mv_ref_prob , sub_mv_ref_prob , sizeof ( sub_mv_ref_prob ) ) ; }
int checkBufYUV ( unsigned char * buf , int w , int h , int subsamp , tjscalingfactor sf ) { int row , col ; int hsf = tjMCUWidth [ subsamp ] / 8 , vsf = tjMCUHeight [ subsamp ] / 8 ; int pw = PAD ( w , hsf ) , ph = PAD ( h , vsf ) ; int cw = pw / hsf , ch = ph / vsf ; int ypitch = PAD ( pw , pad ) , uvpitch = PAD ( cw , pad ) ; int retval = 1 ; int halfway = 16 * sf . num / sf . denom ; int blocksize = 8 * sf . num / sf . denom ; for ( row = 0 ; row < ph ; row ++ ) { for ( col = 0 ; col < pw ; col ++ ) { unsigned char y = buf [ ypitch * row + col ] ; if ( ( ( row / blocksize ) + ( col / blocksize ) ) % 2 == 0 ) { if ( row < halfway ) checkval255 ( y ) else checkval0 ( y ) ; } else { if ( row < halfway ) checkval ( y , 76 ) else checkval ( y , 226 ) ; } } } if ( subsamp != TJSAMP_GRAY ) { int halfway = 16 / vsf * sf . num / sf . denom ; for ( row = 0 ; row < ch ; row ++ ) { for ( col = 0 ; col < cw ; col ++ ) { unsigned char u = buf [ ypitch * ph + ( uvpitch * row + col ) ] , v = buf [ ypitch * ph + uvpitch * ch + ( uvpitch * row + col ) ] ; if ( ( ( row * vsf / blocksize ) + ( col * hsf / blocksize ) ) % 2 == 0 ) { checkval ( u , 128 ) ; checkval ( v , 128 ) ; } else { if ( row < halfway ) { checkval ( u , 85 ) ; checkval255 ( v ) ; } else { checkval0 ( u ) ; checkval ( v , 149 ) ; } } } } } bailout : if ( retval == 0 ) { for ( row = 0 ; row < ph ; row ++ ) { for ( col = 0 ; col < pw ; col ++ ) printf ( "%.3d " , buf [ ypitch * row + col ] ) ; printf ( "\n" ) ; } printf ( "\n" ) ; for ( row = 0 ; row < ch ; row ++ ) { for ( col = 0 ; col < cw ; col ++ ) printf ( "%.3d " , buf [ ypitch * ph + ( uvpitch * row + col ) ] ) ; printf ( "\n" ) ; } printf ( "\n" ) ; for ( row = 0 ; row < ch ; row ++ ) { for ( col = 0 ; col < cw ; col ++ ) printf ( "%.3d " , buf [ ypitch * ph + uvpitch * ch + ( uvpitch * row + col ) ] ) ; printf ( "\n" ) ; } } return retval ; }
status_t NuPlayer :: GenericSource :: initFromDataSource ( ) { sp < MediaExtractor > extractor ; String8 mimeType ; float confidence ; sp < AMessage > dummy ; bool isWidevineStreaming = false ; CHECK ( mDataSource != NULL ) ; if ( mIsWidevine ) { isWidevineStreaming = SniffWVM ( mDataSource , & mimeType , & confidence , & dummy ) ; if ( ! isWidevineStreaming || strcasecmp ( mimeType . string ( ) , MEDIA_MIMETYPE_CONTAINER_WVM ) ) { ALOGE ( "unsupported widevine mime: %s" , mimeType . string ( ) ) ; return UNKNOWN_ERROR ; } } else if ( mIsStreaming ) { if ( ! mDataSource -> sniff ( & mimeType , & confidence , & dummy ) ) { return UNKNOWN_ERROR ; } isWidevineStreaming = ! strcasecmp ( mimeType . string ( ) , MEDIA_MIMETYPE_CONTAINER_WVM ) ; } if ( isWidevineStreaming ) { mCachedSource . clear ( ) ; mDataSource = mHttpSource ; mWVMExtractor = new WVMExtractor ( mDataSource ) ; mWVMExtractor -> setAdaptiveStreamingMode ( true ) ; if ( mUIDValid ) { mWVMExtractor -> setUID ( mUID ) ; } extractor = mWVMExtractor ; } else { extractor = MediaExtractor :: Create ( mDataSource , mimeType . isEmpty ( ) ? NULL : mimeType . string ( ) ) ; } if ( extractor == NULL ) { return UNKNOWN_ERROR ; } if ( extractor -> getDrmFlag ( ) ) { checkDrmStatus ( mDataSource ) ; } mFileMeta = extractor -> getMetaData ( ) ; if ( mFileMeta != NULL ) { int64_t duration ; if ( mFileMeta -> findInt64 ( kKeyDuration , & duration ) ) { mDurationUs = duration ; } if ( ! mIsWidevine ) { const char * fileMime ; if ( mFileMeta -> findCString ( kKeyMIMEType , & fileMime ) && ! strncasecmp ( fileMime , "video/wvm" , 9 ) ) { mIsWidevine = true ; } } } int32_t totalBitrate = 0 ; size_t numtracks = extractor -> countTracks ( ) ; if ( numtracks == 0 ) { return UNKNOWN_ERROR ; } for ( size_t i = 0 ; i < numtracks ; ++ i ) { sp < MediaSource > track = extractor -> getTrack ( i ) ; sp < MetaData > meta = extractor -> getTrackMetaData ( i ) ; const char * mime ; CHECK ( meta -> findCString ( kKeyMIMEType , & mime ) ) ; if ( ! strncasecmp ( mime , "audio/" , 6 ) ) { if ( mAudioTrack . mSource == NULL ) { mAudioTrack . mIndex = i ; mAudioTrack . mSource = track ; mAudioTrack . mPackets = new AnotherPacketSource ( mAudioTrack . mSource -> getFormat ( ) ) ; if ( ! strcasecmp ( mime , MEDIA_MIMETYPE_AUDIO_VORBIS ) ) { mAudioIsVorbis = true ; } else { mAudioIsVorbis = false ; } } } else if ( ! strncasecmp ( mime , "video/" , 6 ) ) { if ( mVideoTrack . mSource == NULL ) { mVideoTrack . mIndex = i ; mVideoTrack . mSource = track ; mVideoTrack . mPackets = new AnotherPacketSource ( mVideoTrack . mSource -> getFormat ( ) ) ; int32_t secure ; if ( meta -> findInt32 ( kKeyRequiresSecureBuffers , & secure ) && secure ) { mIsSecure = true ; if ( mUIDValid ) { extractor -> setUID ( mUID ) ; } } } } if ( track != NULL ) { mSources . push ( track ) ; int64_t durationUs ; if ( meta -> findInt64 ( kKeyDuration , & durationUs ) ) { if ( durationUs > mDurationUs ) { mDurationUs = durationUs ; } } int32_t bitrate ; if ( totalBitrate >= 0 && meta -> findInt32 ( kKeyBitRate , & bitrate ) ) { totalBitrate += bitrate ; } else { totalBitrate = - 1 ; } } } mBitrate = totalBitrate ; return OK ; }
static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; switch ( mode ) { case PSR_AA32_MODE_USR : case PSR_AA32_MODE_FIQ : case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }
status_t MPEG4Source :: parseSampleAuxiliaryInformationSizes ( off64_t offset , off64_t size ) { ALOGV ( "parseSampleAuxiliaryInformationSizes" ) ; if ( mCurrentSamples . isEmpty ( ) ) { ALOGW ( "deferring processing of saiz box" ) ; AuxRange range ; range . mStart = offset ; range . mSize = size ; mDeferredSaiz . add ( range ) ; return OK ; } uint8_t version ; if ( mDataSource -> readAt ( offset , & version , sizeof ( version ) ) < ( ssize_t ) sizeof ( version ) ) { return ERROR_IO ; } if ( version != 0 ) { return ERROR_UNSUPPORTED ; } offset ++ ; uint32_t flags ; if ( ! mDataSource -> getUInt24 ( offset , & flags ) ) { return ERROR_IO ; } offset += 3 ; if ( flags & 1 ) { uint32_t tmp ; if ( ! mDataSource -> getUInt32 ( offset , & tmp ) ) { return ERROR_MALFORMED ; } mCurrentAuxInfoType = tmp ; offset += 4 ; if ( ! mDataSource -> getUInt32 ( offset , & tmp ) ) { return ERROR_MALFORMED ; } mCurrentAuxInfoTypeParameter = tmp ; offset += 4 ; } uint8_t defsize ; if ( mDataSource -> readAt ( offset , & defsize , 1 ) != 1 ) { return ERROR_MALFORMED ; } mCurrentDefaultSampleInfoSize = defsize ; offset ++ ; uint32_t smplcnt ; if ( ! mDataSource -> getUInt32 ( offset , & smplcnt ) ) { return ERROR_MALFORMED ; } mCurrentSampleInfoCount = smplcnt ; offset += 4 ; if ( mCurrentDefaultSampleInfoSize != 0 ) { ALOGV ( "@@@@ using default sample info size of %d" , mCurrentDefaultSampleInfoSize ) ; return OK ; } if ( smplcnt > mCurrentSampleInfoAllocSize ) { mCurrentSampleInfoSizes = ( uint8_t * ) realloc ( mCurrentSampleInfoSizes , smplcnt ) ; mCurrentSampleInfoAllocSize = smplcnt ; } mDataSource -> readAt ( offset , mCurrentSampleInfoSizes , smplcnt ) ; return OK ; }
BUILTIN ( StringPrototypeToLocaleUpperCase ) { HandleScope scope ( isolate ) ; TO_THIS_STRING ( string , "String.prototype.toLocaleUpperCase" ) ; RETURN_RESULT_OR_FAILURE ( isolate , Intl :: StringLocaleConvertCase ( isolate , string , true , args . atOrUndefined ( isolate , 1 ) ) ) ; }
int ProcessSystemProperties ( JNIEnv * env ) { jclass cls ; jmethodID mid ; jstring jName , jValue ; const char * value ; bailif0 ( cls = ( * env ) -> FindClass ( env , "java/lang/System" ) ) ; bailif0 ( mid = ( * env ) -> GetStaticMethodID ( env , cls , "getProperty" , "(Ljava/lang/String;)Ljava/lang/String;" ) ) ; prop2env ( "turbojpeg.optimize" , "TJ_OPTIMIZE" ) ; prop2env ( "turbojpeg.arithmetic" , "TJ_ARITHMETIC" ) ; prop2env ( "turbojpeg.restart" , "TJ_RESTART" ) ; prop2env ( "turbojpeg.progressive" , "TJ_PROGRESSIVE" ) ; return 0 ; bailout : return - 1 ; }
Define ( ParseNode * pn , JSAtom * atom , TreeContext * tc , bool let = false ) { JS_ASSERT ( ! pn -> isUsed ( ) ) ; JS_ASSERT_IF ( pn -> isDefn ( ) , pn -> isPlaceholder ( ) ) ; bool foundLexdep = false ; Definition * dn = NULL ; if ( let ) dn = tc -> decls . lookupFirst ( atom ) ; if ( ! dn ) { dn = tc -> lexdeps . lookupDefn ( atom ) ; foundLexdep = ! ! dn ; } if ( dn && dn != pn ) { ParseNode * * pnup = & dn -> dn_uses ; ParseNode * pnu ; uintN start = let ? pn -> pn_blockid : tc -> bodyid ; while ( ( pnu = * pnup ) != NULL && pnu -> pn_blockid >= start ) { JS_ASSERT ( pnu -> isUsed ( ) ) ; pnu -> pn_lexdef = ( Definition * ) pn ; pn -> pn_dflags |= pnu -> pn_dflags & PND_USE2DEF_FLAGS ; pnup = & pnu -> pn_link ; } if ( pnu != dn -> dn_uses ) { * pnup = pn -> dn_uses ; pn -> dn_uses = dn -> dn_uses ; dn -> dn_uses = pnu ; if ( ( ! pnu || pnu -> pn_blockid < tc -> bodyid ) && foundLexdep ) tc -> lexdeps -> remove ( atom ) ; } } Definition * toAdd = ( Definition * ) pn ; bool ok = let ? tc -> decls . addShadow ( atom , toAdd ) : tc -> decls . addUnique ( atom , toAdd ) ; if ( ! ok ) return false ; pn -> setDefn ( true ) ; pn -> pn_dflags &= ~ PND_PLACEHOLDER ; if ( ! tc -> parent ) pn -> pn_dflags |= PND_TOPLEVEL ; return true ; }
OMX_ERRORTYPE SoftVorbis :: internalSetParameter ( OMX_INDEXTYPE index , const OMX_PTR params ) { switch ( index ) { case OMX_IndexParamStandardComponentRole : { const OMX_PARAM_COMPONENTROLETYPE * roleParams = ( const OMX_PARAM_COMPONENTROLETYPE * ) params ; if ( strncmp ( ( const char * ) roleParams -> cRole , "audio_decoder.vorbis" , OMX_MAX_STRINGNAME_SIZE - 1 ) ) { return OMX_ErrorUndefined ; } return OMX_ErrorNone ; } case OMX_IndexParamAudioVorbis : { const OMX_AUDIO_PARAM_VORBISTYPE * vorbisParams = ( const OMX_AUDIO_PARAM_VORBISTYPE * ) params ; if ( vorbisParams -> nPortIndex != 0 ) { return OMX_ErrorUndefined ; } return OMX_ErrorNone ; } default : return SimpleSoftOMXComponent :: internalSetParameter ( index , params ) ; } }
OMX_ERRORTYPE SoftAVC :: releaseEncoder ( ) { IV_STATUS_T status = IV_SUCCESS ; iv_retrieve_mem_rec_ip_t s_retrieve_mem_ip ; iv_retrieve_mem_rec_op_t s_retrieve_mem_op ; iv_mem_rec_t * ps_mem_rec ; if ( ! mStarted ) { return OMX_ErrorNone ; } s_retrieve_mem_ip . u4_size = sizeof ( iv_retrieve_mem_rec_ip_t ) ; s_retrieve_mem_op . u4_size = sizeof ( iv_retrieve_mem_rec_op_t ) ; s_retrieve_mem_ip . e_cmd = IV_CMD_RETRIEVE_MEMREC ; s_retrieve_mem_ip . ps_mem_rec = mMemRecords ; status = ive_api_function ( mCodecCtx , & s_retrieve_mem_ip , & s_retrieve_mem_op ) ; if ( status != IV_SUCCESS ) { ALOGE ( "Unable to retrieve memory records = 0x%x\n" , s_retrieve_mem_op . u4_error_code ) ; return OMX_ErrorUndefined ; } ps_mem_rec = mMemRecords ; for ( size_t i = 0 ; i < s_retrieve_mem_op . u4_num_mem_rec_filled ; i ++ ) { ive_aligned_free ( ps_mem_rec -> pv_base ) ; ps_mem_rec ++ ; } free ( mMemRecords ) ; for ( size_t i = 0 ; i < MAX_CONVERSION_BUFFERS ; i ++ ) { if ( mConversionBuffers [ i ] ) { free ( mConversionBuffers [ i ] ) ; mConversionBuffers [ i ] = NULL ; } } mStarted = false ; return OMX_ErrorNone ; }
OfflineCacheUpdateChild :: RecvFinish ( const bool & succeeded , const bool & isUpgrade ) { LOG ( ( "OfflineCacheUpdateChild::RecvFinish [%p]" , this ) ) ; nsRefPtr < OfflineCacheUpdateChild > kungFuDeathGrip ( this ) ; mState = STATE_FINISHED ; mSucceeded = succeeded ; mIsUpgrade = isUpgrade ; nsCOMPtr < nsIObserverService > observerService = mozilla :: services :: GetObserverService ( ) ; if ( observerService ) { LOG ( ( "Calling offline-cache-update-completed" ) ) ; observerService -> NotifyObservers ( static_cast < nsIOfflineCacheUpdate * > ( this ) , "offline-cache-update-completed" , nullptr ) ; LOG ( ( "Done offline-cache-update-completed" ) ) ; } this -> Release ( ) ; return true ; }
njs_object_iterate_reverse ( njs_vm_t * vm , njs_iterator_args_t * args , njs_iterator_handler_t handler ) { double idx ; int64_t i , from , to , length ; njs_int_t ret ; njs_array_t * array , * keys ; njs_value_t * entry , * value , prop , character , string_obj ; const u_char * p , * end , * pos ; njs_string_prop_t string_prop ; njs_object_value_t * object ; value = args -> value ; from = args -> from ; to = args -> to ; if ( njs_is_array ( value ) ) { array = njs_array ( value ) ; from += 1 ; while ( from -- > to ) { if ( njs_slow_path ( ! array -> object . fast_array ) ) { goto process_object ; } if ( njs_fast_path ( from < array -> length && njs_is_valid ( & array -> start [ from ] ) ) ) { ret = handler ( vm , args , & array -> start [ from ] , from ) ; } else { entry = njs_value_arg ( & njs_value_invalid ) ; ret = njs_value_property_i64 ( vm , value , from , & prop ) ; if ( njs_slow_path ( ret != NJS_DECLINED ) ) { if ( ret == NJS_ERROR ) { return NJS_ERROR ; } entry = & prop ; } ret = handler ( vm , args , entry , from ) ; } if ( njs_slow_path ( ret != NJS_OK ) ) { if ( ret == NJS_DONE ) { return NJS_DONE ; } return NJS_ERROR ; } } return NJS_OK ; } if ( njs_is_string ( value ) || njs_is_object_string ( value ) ) { if ( njs_is_string ( value ) ) { object = njs_object_value_alloc ( vm , NJS_OBJ_TYPE_STRING , 0 , value ) ; if ( njs_slow_path ( object == NULL ) ) { return NJS_ERROR ; } njs_set_object_value ( & string_obj , object ) ; args -> value = & string_obj ; } else { value = njs_object_value ( value ) ; } length = njs_string_prop ( & string_prop , value ) ; end = string_prop . start + string_prop . size ; if ( ( size_t ) length == string_prop . size ) { p = string_prop . start + from ; i = from + 1 ; while ( i -- > to ) { ( void ) njs_string_new ( vm , & character , p , 1 , 1 ) ; ret = handler ( vm , args , & character , i ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { if ( ret == NJS_DONE ) { return NJS_DONE ; } return NJS_ERROR ; } p -- ; } } else { p = njs_string_offset ( string_prop . start , end , from ) ; p = njs_utf8_next ( p , end ) ; i = from + 1 ; while ( i -- > to ) { pos = njs_utf8_prev ( p ) ; ( void ) njs_string_new ( vm , & character , pos , p - pos , 1 ) ; ret = handler ( vm , args , & character , i ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { if ( ret == NJS_DONE ) { return NJS_DONE ; } return NJS_ERROR ; } p = pos ; } } return NJS_OK ; } if ( ! njs_is_object ( value ) ) { return NJS_OK ; } process_object : if ( ! njs_fast_object ( from - to ) ) { keys = njs_array_indices ( vm , value ) ; if ( njs_slow_path ( keys == NULL ) ) { return NJS_ERROR ; } i = keys -> length ; while ( i > 0 ) { idx = njs_string_to_index ( & keys -> start [ -- i ] ) ; if ( idx < to || idx > from ) { continue ; } ret = njs_iterator_object_handler ( vm , handler , args , & keys -> start [ i ] , idx ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { njs_array_destroy ( vm , keys ) ; return ret ; } } njs_array_destroy ( vm , keys ) ; return NJS_OK ; } i = from + 1 ; while ( i -- > to ) { ret = njs_iterator_object_handler ( vm , handler , args , NULL , i ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return ret ; } } return NJS_OK ; }
rfbClient * rfbGetClient ( int bitsPerSample , int samplesPerPixel , int bytesPerPixel ) { #ifdef WIN32 WSADATA unused ; #endif rfbClient * client = ( rfbClient * ) calloc ( sizeof ( rfbClient ) , 1 ) ; if ( ! client ) { rfbClientErr ( "Couldn't allocate client structure!\n" ) ; return NULL ; } #ifdef WIN32 if ( ( errno = WSAStartup ( MAKEWORD ( 2 , 0 ) , & unused ) ) != 0 ) { rfbClientErr ( "Could not init Windows Sockets: %s\n" , strerror ( errno ) ) ; return NULL ; } #endif initAppData ( & client -> appData ) ; client -> endianTest = 1 ; client -> programName = "" ; client -> serverHost = strdup ( "" ) ; client -> serverPort = 5900 ; client -> destHost = NULL ; client -> destPort = 5900 ; client -> connectTimeout = DEFAULT_CONNECT_TIMEOUT ; client -> CurrentKeyboardLedState = 0 ; client -> HandleKeyboardLedState = ( HandleKeyboardLedStateProc ) DummyPoint ; client -> updateRect . x = - 1 ; client -> frameBuffer = NULL ; client -> outputWindow = 0 ; client -> format . bitsPerPixel = bytesPerPixel * 8 ; client -> format . depth = bitsPerSample * samplesPerPixel ; client -> appData . requestedDepth = client -> format . depth ; client -> format . bigEndian = * ( char * ) & client -> endianTest ? FALSE : TRUE ; client -> format . trueColour = 1 ; if ( client -> format . bitsPerPixel == 8 ) { client -> format . redMax = 7 ; client -> format . greenMax = 7 ; client -> format . blueMax = 3 ; client -> format . redShift = 0 ; client -> format . greenShift = 3 ; client -> format . blueShift = 6 ; } else { client -> format . redMax = ( 1 < < bitsPerSample ) - 1 ; client -> format . greenMax = ( 1 < < bitsPerSample ) - 1 ; client -> format . blueMax = ( 1 < < bitsPerSample ) - 1 ; if ( ! client -> format . bigEndian ) { client -> format . redShift = 0 ; client -> format . greenShift = bitsPerSample ; client -> format . blueShift = bitsPerSample * 2 ; } else { if ( client -> format . bitsPerPixel == 8 * 3 ) { client -> format . redShift = bitsPerSample * 2 ; client -> format . greenShift = bitsPerSample * 1 ; client -> format . blueShift = 0 ; } else { client -> format . redShift = bitsPerSample * 3 ; client -> format . greenShift = bitsPerSample * 2 ; client -> format . blueShift = bitsPerSample ; } } } client -> bufoutptr = client -> buf ; client -> buffered = 0 ; #ifdef LIBVNCSERVER_HAVE_LIBZ client -> raw_buffer_size = - 1 ; client -> decompStreamInited = FALSE ; #ifdef LIBVNCSERVER_HAVE_LIBJPEG memset ( client -> zlibStreamActive , 0 , sizeof ( rfbBool ) * 4 ) ; #endif #endif client -> HandleCursorPos = DummyPoint ; client -> SoftCursorLockArea = DummyRect ; client -> SoftCursorUnlockScreen = Dummy ; client -> GotFrameBufferUpdate = DummyRect ; client -> GotCopyRect = CopyRectangleFromRectangle ; client -> GotFillRect = FillRectangle ; client -> GotBitmap = CopyRectangle ; client -> FinishedFrameBufferUpdate = NULL ; client -> GetPassword = ReadPassword ; client -> MallocFrameBuffer = MallocFrameBuffer ; client -> Bell = Dummy ; client -> CurrentKeyboardLedState = 0 ; client -> HandleKeyboardLedState = ( HandleKeyboardLedStateProc ) DummyPoint ; client -> QoS_DSCP = 0 ; client -> authScheme = 0 ; client -> subAuthScheme = 0 ; client -> GetCredential = NULL ; client -> tlsSession = NULL ; client -> LockWriteToTLS = NULL ; client -> UnlockWriteToTLS = NULL ; client -> sock = RFB_INVALID_SOCKET ; client -> listenSock = RFB_INVALID_SOCKET ; client -> listenAddress = NULL ; client -> listen6Sock = RFB_INVALID_SOCKET ; client -> listen6Address = NULL ; client -> clientAuthSchemes = NULL ; #ifdef LIBVNCSERVER_HAVE_SASL client -> GetSASLMechanism = NULL ; client -> GetUser = NULL ; client -> saslSecret = NULL ; #endif /* LIBVNCSERVER_HAVE_SASL */ return client ; }
find_insert ( png_const_charp what , png_charp param ) { png_uint_32 chunk = 0 ; png_charp parameter_list [ 1024 ] ; int i , nparams ; for ( i = 0 ; i < 4 ; ++ i ) { char ch = what [ i ] ; if ( ( ch >= 65 && ch <= 90 ) || ( ch >= 97 && ch <= 122 ) ) chunk = ( chunk < < 8 ) + what [ i ] ; else break ; } if ( i < 4 || what [ 4 ] != 0 ) { fprintf ( stderr , "makepng --insert \"%s\": invalid chunk name\n" , what ) ; exit ( 1 ) ; } nparams = find_parameters ( what , param , parameter_list , 1024 ) ; #  define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d)) switch ( chunk ) { case CHUNK ( 105 , 67 , 67 , 80 ) : if ( nparams == 2 ) return make_insert ( what , insert_iCCP , nparams , parameter_list ) ; break ; case CHUNK ( 116 , 69 , 88 , 116 ) : if ( nparams == 2 ) return make_insert ( what , insert_tEXt , nparams , parameter_list ) ; break ; case CHUNK ( 122 , 84 , 88 , 116 ) : if ( nparams == 2 ) return make_insert ( what , insert_zTXt , nparams , parameter_list ) ; break ; case CHUNK ( 105 , 84 , 88 , 116 ) : if ( nparams == 4 ) return make_insert ( what , insert_iTXt , nparams , parameter_list ) ; break ; case CHUNK ( 104 , 73 , 83 , 84 ) : if ( nparams <= 256 ) return make_insert ( what , insert_hIST , nparams , parameter_list ) ; break ; #if 0 case CHUNK ( 115 , 80 , 76 , 84 ) : return make_insert ( what , insert_sPLT , nparams , parameter_list ) ; #endif default : fprintf ( stderr , "makepng --insert \"%s\": unrecognized chunk name\n" , what ) ; exit ( 1 ) ; } bad_parameter_count ( what , nparams ) ; return NULL ; }
s4u_identify_user ( krb5_context context , krb5_creds * in_creds , krb5_data * subject_cert , krb5_principal * canon_user ) { krb5_error_code code ; krb5_preauthtype ptypes [ 1 ] = { KRB5_PADATA_S4U_X509_USER } ; krb5_creds creds ; int use_master = 0 ; krb5_get_init_creds_opt * opts = NULL ; krb5_principal_data client ; krb5_s4u_userid userid ; * canon_user = NULL ; if ( in_creds -> client == NULL && subject_cert == NULL ) { return EINVAL ; } if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) { int anonymous ; anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ; return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ; } memset ( & creds , 0 , sizeof ( creds ) ) ; memset ( & userid , 0 , sizeof ( userid ) ) ; if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ; code = krb5_get_init_creds_opt_alloc ( context , & opts ) ; if ( code != 0 ) goto cleanup ; krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ; krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ; krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ; krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ; krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ; krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ; if ( in_creds -> client != NULL ) { client = * in_creds -> client ; client . realm = in_creds -> server -> realm ; } else { client . magic = KV5M_PRINCIPAL ; client . realm = in_creds -> server -> realm ; client . data = NULL ; client . length = 0 ; client . type = KRB5_NT_ENTERPRISE_PRINCIPAL ; } code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , opts , krb5_get_as_key_noop , & userid , & use_master , NULL ) ; if ( code == 0 || code == KRB5_PREAUTH_FAILED ) { * canon_user = userid . user ; userid . user = NULL ; code = 0 ; } cleanup : krb5_free_cred_contents ( context , & creds ) ; if ( opts != NULL ) krb5_get_init_creds_opt_free ( context , opts ) ; if ( userid . user != NULL ) krb5_free_principal ( context , userid . user ) ; return code ; }
static void n_tty_set_termios ( struct tty_struct * tty , struct ktermios * old ) { struct n_tty_data * ldata = tty -> disc_data ; if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ; ldata -> line_start = ldata -> read_tail ; if ( ! L_ICANON ( tty ) || ! read_cnt ( ldata ) ) { ldata -> canon_head = ldata -> read_tail ; ldata -> push = 0 ; } else { set_bit ( ( ldata -> read_head - 1 ) & ( N_TTY_BUF_SIZE - 1 ) , ldata -> read_flags ) ; ldata -> canon_head = ldata -> read_head ; ldata -> push = 1 ; } ldata -> commit_head = ldata -> read_head ; ldata -> erasing = 0 ; ldata -> lnext = 0 ; } ldata -> icanon = ( L_ICANON ( tty ) != 0 ) ; if ( I_ISTRIP ( tty ) || I_IUCLC ( tty ) || I_IGNCR ( tty ) || I_ICRNL ( tty ) || I_INLCR ( tty ) || L_ICANON ( tty ) || I_IXON ( tty ) || L_ISIG ( tty ) || L_ECHO ( tty ) || I_PARMRK ( tty ) ) { bitmap_zero ( ldata -> char_map , 256 ) ; if ( I_IGNCR ( tty ) || I_ICRNL ( tty ) ) set_bit ( '\r' , ldata -> char_map ) ; if ( I_INLCR ( tty ) ) set_bit ( '\n' , ldata -> char_map ) ; if ( L_ICANON ( tty ) ) { set_bit ( ERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( KILL_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOF_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( '\n' , ldata -> char_map ) ; set_bit ( EOL_CHAR ( tty ) , ldata -> char_map ) ; if ( L_IEXTEN ( tty ) ) { set_bit ( WERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( LNEXT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOL2_CHAR ( tty ) , ldata -> char_map ) ; if ( L_ECHO ( tty ) ) set_bit ( REPRINT_CHAR ( tty ) , ldata -> char_map ) ; } } if ( I_IXON ( tty ) ) { set_bit ( START_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( STOP_CHAR ( tty ) , ldata -> char_map ) ; } if ( L_ISIG ( tty ) ) { set_bit ( INTR_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( QUIT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( SUSP_CHAR ( tty ) , ldata -> char_map ) ; } clear_bit ( __DISABLED_CHAR , ldata -> char_map ) ; ldata -> raw = 0 ; ldata -> real_raw = 0 ; } else { ldata -> raw = 1 ; if ( ( I_IGNBRK ( tty ) || ( ! I_BRKINT ( tty ) && ! I_PARMRK ( tty ) ) ) && ( I_IGNPAR ( tty ) || ! I_INPCK ( tty ) ) && ( tty -> driver -> flags & TTY_DRIVER_REAL_RAW ) ) ldata -> real_raw = 1 ; else ldata -> real_raw = 0 ; } if ( ! I_IXON ( tty ) && old && ( old -> c_iflag & IXON ) && ! tty -> flow_stopped ) { start_tty ( tty ) ; process_echoes ( tty ) ; } wake_up_interruptible ( & tty -> write_wait ) ; wake_up_interruptible ( & tty -> read_wait ) ; }
audio_devices_t AudioPolicyManager :: getDeviceAndMixForInputSource ( audio_source_t inputSource , AudioMix * * policyMix ) { audio_devices_t availableDeviceTypes = mAvailableInputDevices . types ( ) & ~ AUDIO_DEVICE_BIT_IN ; audio_devices_t selectedDeviceFromMix = mPolicyMixes . getDeviceAndMixForInputSource ( inputSource , availableDeviceTypes , policyMix ) ; if ( selectedDeviceFromMix != AUDIO_DEVICE_NONE ) { return selectedDeviceFromMix ; } return getDeviceForInputSource ( inputSource ) ; }
static void alpha_perf_event_irq_handler ( unsigned long la_ptr , struct pt_regs * regs ) { struct cpu_hw_events * cpuc ; struct perf_sample_data data ; struct perf_event * event ; struct hw_perf_event * hwc ; int idx , j ; __get_cpu_var ( irq_pmi_count ) ++ ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; wrperfmon ( PERFMON_CMD_DISABLE , cpuc -> idx_mask ) ; if ( unlikely ( la_ptr >= alpha_pmu -> num_pmcs ) ) { irq_err_count ++ ; pr_warning ( "PMI: silly index %ld\n" , la_ptr ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } idx = la_ptr ; perf_sample_data_init ( & data , 0 ) ; for ( j = 0 ; j < cpuc -> n_events ; j ++ ) { if ( cpuc -> current_idx [ j ] == idx ) break ; } if ( unlikely ( j == cpuc -> n_events ) ) { wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } event = cpuc -> event [ j ] ; if ( unlikely ( ! event ) ) { irq_err_count ++ ; pr_warning ( "PMI: No event at index %d!\n" , idx ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } hwc = & event -> hw ; alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ; data . period = event -> hw . last_period ; if ( alpha_perf_event_set_period ( event , hwc , idx ) ) { if ( perf_event_overflow ( event , 1 , & data , regs ) ) { alpha_pmu_stop ( event , 0 ) ; } } wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; }
static void update_sharpness ( loop_filter_info_n * lfi , int sharpness_lvl ) { int lvl ; for ( lvl = 0 ; lvl <= MAX_LOOP_FILTER ; lvl ++ ) { int block_inside_limit = lvl > > ( ( sharpness_lvl > 0 ) + ( sharpness_lvl > 4 ) ) ; if ( sharpness_lvl > 0 ) { if ( block_inside_limit > ( 9 - sharpness_lvl ) ) block_inside_limit = ( 9 - sharpness_lvl ) ; } if ( block_inside_limit < 1 ) block_inside_limit = 1 ; vpx_memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ; vpx_memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) , SIMD_WIDTH ) ; } }
void ItemParallelJob :: Task :: SetupInternal ( base :: Semaphore * on_finish , std :: vector < Item * > * items , size_t start_index , base :: Optional < AsyncTimedHistogram > gc_parallel_task_latency_histogram ) { on_finish_ = on_finish ; items_ = items ; if ( start_index < items -> size ( ) ) { cur_index_ = start_index ; } else { items_considered_ = items_ -> size ( ) ; } gc_parallel_task_latency_histogram_ = std :: move ( gc_parallel_task_latency_histogram ) ; }
void BytecodeGraphBuilder :: VisitGetTemplateObject ( ) { Handle < TemplateObjectDescription > description ( TemplateObjectDescription :: cast ( bytecode_iterator ( ) . GetConstantForIndexOperand ( 0 ) ) , isolate ( ) ) ; FeedbackSlot slot = bytecode_iterator ( ) . GetSlotOperand ( 1 ) ; FeedbackNexus nexus ( feedback_vector ( ) , slot ) ; Handle < JSArray > cached_value ; if ( nexus . GetFeedback ( ) == MaybeObject :: FromSmi ( Smi :: kZero ) ) { cached_value = TemplateObjectDescription :: CreateTemplateObject ( isolate ( ) , description ) ; nexus . vector ( ) -> Set ( slot , * cached_value ) ; } else { cached_value = handle ( JSArray :: cast ( nexus . GetFeedback ( ) -> ToStrongHeapObject ( ) ) , isolate ( ) ) ; } Node * template_object = jsgraph ( ) -> HeapConstant ( cached_value ) ; environment ( ) -> BindAccumulator ( template_object ) ; }
xmlByteConsumed ( xmlParserCtxtPtr ctxt ) { xmlParserInputPtr in ; if ( ctxt == NULL ) return ( - 1 ) ; in = ctxt -> input ; if ( in == NULL ) return ( - 1 ) ; if ( ( in -> buf != NULL ) && ( in -> buf -> encoder != NULL ) ) { unsigned int unused = 0 ; xmlCharEncodingHandler * handler = in -> buf -> encoder ; if ( in -> end - in -> cur > 0 ) { unsigned char convbuf [ 32000 ] ; const unsigned char * cur = ( const unsigned char * ) in -> cur ; int toconv = in -> end - in -> cur , written = 32000 ; int ret ; if ( handler -> output != NULL ) { do { toconv = in -> end - cur ; written = 32000 ; ret = handler -> output ( & convbuf [ 0 ] , & written , cur , & toconv ) ; if ( ret == - 1 ) return ( - 1 ) ; unused += written ; cur += toconv ; } while ( ret == - 2 ) ; #ifdef LIBXML_ICONV_ENABLED } else if ( handler -> iconv_out != NULL ) { do { toconv = in -> end - cur ; written = 32000 ; ret = xmlIconvWrapper ( handler -> iconv_out , & convbuf [ 0 ] , & written , cur , & toconv ) ; if ( ret < 0 ) { if ( written > 0 ) ret = - 2 ; else return ( - 1 ) ; } unused += written ; cur += toconv ; } while ( ret == - 2 ) ; #endif #ifdef LIBXML_ICU_ENABLED } else if ( handler -> uconv_out != NULL ) { do { toconv = in -> end - cur ; written = 32000 ; ret = xmlUconvWrapper ( handler -> uconv_out , 0 , & convbuf [ 0 ] , & written , cur , & toconv ) ; if ( ret < 0 ) { if ( written > 0 ) ret = - 2 ; else return ( - 1 ) ; } unused += written ; cur += toconv ; } while ( ret == - 2 ) ; #endif } else { return ( - 1 ) ; } } if ( in -> buf -> rawconsumed < unused ) return ( - 1 ) ; return ( in -> buf -> rawconsumed - unused ) ; } return ( in -> consumed + ( in -> cur - in -> base ) ) ; }
DOMSVGTransformList :: EnsureItemAt ( uint32_t aIndex ) { if ( ! mItems [ aIndex ] ) { mItems [ aIndex ] = new SVGTransform ( this , aIndex , IsAnimValList ( ) ) ; } }
XDRBuffer :: grow ( size_t n ) { MOZ_ASSERT ( n > size_t ( limit - cursor ) ) ; const size_t MIN_CAPACITY = 8192 ; size_t offset = cursor - base ; size_t newCapacity = mozilla :: RoundUpPow2 ( offset + n ) ; if ( newCapacity < MIN_CAPACITY ) newCapacity = MIN_CAPACITY ; if ( isUint32Overflow ( newCapacity ) ) { js :: gc :: AutoSuppressGC suppressGC ( cx ( ) ) ; JS_ReportErrorNumber ( cx ( ) , GetErrorMessage , nullptr , JSMSG_TOO_BIG_TO_ENCODE ) ; return false ; } void * data = js_realloc ( base , newCapacity ) ; if ( ! data ) { ReportOutOfMemory ( cx ( ) ) ; return false ; } base = static_cast < uint8_t * > ( data ) ; cursor = base + offset ; limit = base + newCapacity ; return true ; }
BufferMeta ( const sp < IMemory > & mem , OMX_U32 portIndex , bool is_backup = false ) : mMem ( mem ) , mIsBackup ( is_backup ) , mPortIndex ( portIndex ) { }
Node * RepresentationChanger :: GetRepresentationFor ( Node * node , MachineRepresentation output_rep , Type output_type , Node * use_node , UseInfo use_info ) { if ( output_rep == MachineRepresentation :: kNone && ! output_type . IsNone ( ) ) { return TypeError ( node , output_rep , output_type , use_info . representation ( ) ) ; } if ( use_info . type_check ( ) == TypeCheckKind :: kNone || output_rep != MachineRepresentation :: kWord32 ) { if ( use_info . representation ( ) == output_rep ) { return node ; } if ( IsWord ( use_info . representation ( ) ) && IsWord ( output_rep ) ) { return node ; } } switch ( use_info . representation ( ) ) { case MachineRepresentation :: kTaggedSigned : DCHECK ( use_info . type_check ( ) == TypeCheckKind :: kNone || use_info . type_check ( ) == TypeCheckKind :: kSignedSmall ) ; return GetTaggedSignedRepresentationFor ( node , output_rep , output_type , use_node , use_info ) ; case MachineRepresentation :: kTaggedPointer : DCHECK ( use_info . type_check ( ) == TypeCheckKind :: kNone || use_info . type_check ( ) == TypeCheckKind :: kHeapObject ) ; return GetTaggedPointerRepresentationFor ( node , output_rep , output_type , use_node , use_info ) ; case MachineRepresentation :: kTagged : DCHECK_EQ ( TypeCheckKind :: kNone , use_info . type_check ( ) ) ; return GetTaggedRepresentationFor ( node , output_rep , output_type , use_info . truncation ( ) ) ; case MachineRepresentation :: kFloat32 : DCHECK_EQ ( TypeCheckKind :: kNone , use_info . type_check ( ) ) ; return GetFloat32RepresentationFor ( node , output_rep , output_type , use_info . truncation ( ) ) ; case MachineRepresentation :: kFloat64 : return GetFloat64RepresentationFor ( node , output_rep , output_type , use_node , use_info ) ; case MachineRepresentation :: kBit : DCHECK_EQ ( TypeCheckKind :: kNone , use_info . type_check ( ) ) ; return GetBitRepresentationFor ( node , output_rep , output_type ) ; case MachineRepresentation :: kWord8 : case MachineRepresentation :: kWord16 : case MachineRepresentation :: kWord32 : return GetWord32RepresentationFor ( node , output_rep , output_type , use_node , use_info ) ; case MachineRepresentation :: kWord64 : DCHECK_EQ ( TypeCheckKind :: kNone , use_info . type_check ( ) ) ; return GetWord64RepresentationFor ( node , output_rep , output_type ) ; case MachineRepresentation :: kSimd128 : case MachineRepresentation :: kNone : return node ; } UNREACHABLE ( ) ; }
const Type * ImplementationVisitor :: Visit ( BreakStatement * stmt ) { Label * break_label = global_context_ . GetCurrentBreak ( ) ; if ( break_label == nullptr ) { ReportError ( "break used outside of loop" ) ; } GenerateLabelGoto ( break_label ) ; return TypeOracle :: GetNeverType ( ) ; }
static int ion_dma_buf_end_cpu_access ( struct dma_buf * dmabuf , enum dma_data_direction direction ) { struct ion_buffer * buffer = dmabuf -> priv ; struct ion_dma_buf_attachment * a ; if ( buffer -> heap -> ops -> map_kernel ) { mutex_lock ( & buffer -> lock ) ; ion_buffer_kmap_put ( buffer ) ; mutex_unlock ( & buffer -> lock ) ; } mutex_lock ( & buffer -> lock ) ; list_for_each_entry ( a , & buffer -> attachments , list ) { dma_sync_sg_for_device ( a -> dev , a -> table -> sgl , a -> table -> nents , direction ) ; } mutex_unlock ( & buffer -> lock ) ; return 0 ; }
MaybeHandle < String > Factory :: NewStringFromTwoByte ( const ZoneVector < uc16 > * string , PretenureFlag pretenure ) { return NewStringFromTwoByte ( string -> data ( ) , static_cast < int > ( string -> size ( ) ) , pretenure ) ; }
static void read_encryption_key_size_complete_after_encryption_change ( uint8_t status , uint16_t handle , uint8_t key_size ) { int ret = android :: util :: stats_write ( android :: util :: BLUETOOTH_CLASSIC_PAIRING_EVENT_REPORTED , "" , handle , HCI_READ_ENCR_KEY_SIZE , HCI_COMMAND_COMPLETE_EVT , status , 0 , key_size ) ; if ( ret < 0 ) { LOG ( WARNING ) < < __func__ < < ": failed to log encryption key size " < < std :: to_string ( key_size ) ; } if ( status != HCI_SUCCESS ) { LOG ( INFO ) < < __func__ < < ": disconnecting, status: " < < loghex ( status ) ; btsnd_hcic_disconnect ( handle , HCI_ERR_PEER_USER ) ; return ; } if ( key_size < MIN_KEY_SIZE ) { android_errorWriteLog ( 0x534e4554 , "124301137" ) ; LOG ( ERROR ) < < __func__ < < " encryption key too short, disconnecting. handle: " < < loghex ( handle ) < < " key_size: " < < + key_size ; btsnd_hcic_disconnect ( handle , HCI_ERR_HOST_REJECT_SECURITY ) ; return ; } btm_acl_encrypt_change ( handle , status , 1 ) ; btm_sec_encrypt_change ( handle , status , 1 ) ; }
long oggpack_read ( oggpack_buffer * b , int bits ) { long ret ; unsigned long m = mask [ bits ] ; bits += b -> endbit ; if ( b -> endbyte + 4 >= b -> storage ) { ret = - 1L ; if ( b -> endbyte * 8 + bits > b -> storage * 8 ) goto overflow ; } ret = b -> ptr [ 0 ] > > b -> endbit ; if ( bits > 8 ) { ret |= b -> ptr [ 1 ] < < ( 8 - b -> endbit ) ; if ( bits > 16 ) { ret |= b -> ptr [ 2 ] < < ( 16 - b -> endbit ) ; if ( bits > 24 ) { ret |= b -> ptr [ 3 ] < < ( 24 - b -> endbit ) ; if ( bits > 32 && b -> endbit ) { ret |= b -> ptr [ 4 ] < < ( 32 - b -> endbit ) ; } } } } ret &= m ; overflow : b -> ptr += bits / 8 ; b -> endbyte += bits / 8 ; b -> endbit = bits & 7 ; return ( ret ) ; }
void luaD_shrinkstack ( lua_State * L ) { int inuse = stackinuse ( L ) ; int goodsize = inuse + ( inuse / 8 ) + 2 * EXTRA_STACK ; if ( goodsize > LUAI_MAXSTACK ) goodsize = LUAI_MAXSTACK ; if ( inuse <= ( LUAI_MAXSTACK - EXTRA_STACK ) && goodsize < L -> stacksize ) luaD_reallocstack ( L , goodsize , 0 ) ; else condmovestack ( L , { } , { } ) ; luaE_shrinkCI ( L ) ; }
MaybeObjectHandle StoreHandler :: StoreTransition ( Isolate * isolate , Handle < Map > transition_map ) { bool is_dictionary_map = transition_map -> is_dictionary_map ( ) ; #ifdef DEBUG if ( ! is_dictionary_map ) { int descriptor = transition_map -> LastAdded ( ) ; Handle < DescriptorArray > descriptors ( transition_map -> instance_descriptors ( ) , isolate ) ; PropertyDetails details = descriptors -> GetDetails ( descriptor ) ; if ( descriptors -> GetKey ( descriptor ) -> IsPrivate ( ) ) { DCHECK_EQ ( DONT_ENUM , details . attributes ( ) ) ; } else { DCHECK_EQ ( NONE , details . attributes ( ) ) ; } Representation representation = details . representation ( ) ; DCHECK ( ! representation . IsNone ( ) ) ; } #endif DCHECK ( ! transition_map -> is_access_check_needed ( ) ) ; Handle < Object > validity_cell ; if ( is_dictionary_map || ! transition_map -> IsPrototypeValidityCellValid ( ) ) { validity_cell = Map :: GetOrCreatePrototypeChainValidityCell ( transition_map , isolate ) ; } if ( is_dictionary_map ) { DCHECK ( ! transition_map -> IsJSGlobalObjectMap ( ) ) ; Handle < StoreHandler > handler = isolate -> factory ( ) -> NewStoreHandler ( 0 ) ; int config = KindBits :: encode ( kNormal ) | LookupOnReceiverBits :: encode ( true ) ; handler -> set_smi_handler ( Smi :: FromInt ( config ) ) ; handler -> set_validity_cell ( * validity_cell ) ; return MaybeObjectHandle ( handler ) ; } else { if ( ! validity_cell . is_null ( ) ) { transition_map -> set_prototype_validity_cell ( * validity_cell ) ; } return MaybeObjectHandle :: Weak ( transition_map ) ; } }
uc32 RegExpParser :: ParseClassCharacterEscape ( ) { DCHECK_EQ ( '\\' , current ( ) ) ; DCHECK ( has_next ( ) && ! IsSpecialClassEscape ( Next ( ) ) ) ; Advance ( ) ; switch ( current ( ) ) { case 'b' : Advance ( ) ; return '\b' ; case 'f' : Advance ( ) ; return '\f' ; case 'n' : Advance ( ) ; return '\n' ; case 'r' : Advance ( ) ; return '\r' ; case 't' : Advance ( ) ; return '\t' ; case 'v' : Advance ( ) ; return '\v' ; case 'c' : { uc32 controlLetter = Next ( ) ; uc32 letter = controlLetter & ~ ( 'A' ^ 'a' ) ; if ( letter >= 'A' && letter <= 'Z' ) { Advance ( 2 ) ; return controlLetter & 0x1F ; } if ( unicode ( ) ) { ReportError ( CStrVector ( "Invalid class escape" ) ) ; return 0 ; } if ( ( controlLetter >= '0' && controlLetter <= '9' ) || controlLetter == '_' ) { Advance ( 2 ) ; return controlLetter & 0x1F ; } return '\\' ; } case '0' : if ( unicode ( ) && ! ( Next ( ) >= '0' && Next ( ) <= '9' ) ) { Advance ( ) ; return 0 ; } V8_FALLTHROUGH ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : if ( unicode ( ) ) { ReportError ( CStrVector ( "Invalid class escape" ) ) ; return 0 ; } return ParseOctalLiteral ( ) ; case 'x' : { Advance ( ) ; uc32 value ; if ( ParseHexEscape ( 2 , & value ) ) return value ; if ( unicode ( ) ) { ReportError ( CStrVector ( "Invalid escape" ) ) ; return 0 ; } return 'x' ; } case 'u' : { Advance ( ) ; uc32 value ; if ( ParseUnicodeEscape ( & value ) ) return value ; if ( unicode ( ) ) { ReportError ( CStrVector ( "Invalid unicode escape" ) ) ; return 0 ; } return 'u' ; } default : { uc32 result = current ( ) ; if ( ! unicode ( ) || IsSyntaxCharacterOrSlash ( result ) || result == '-' ) { Advance ( ) ; return result ; } ReportError ( CStrVector ( "Invalid escape" ) ) ; return 0 ; } } return 0 ; }
nsDOMAttribute :: RemoveChildAt ( PRUint32 aIndex , PRBool aNotify , PRBool aMutationEvent ) { NS_ASSERTION ( aMutationEvent , "Someone tried to inhibit mutations on attribute child removal." ) ; if ( aIndex != 0 || ! mChild ) { return NS_OK ; } nsCOMPtr < nsIContent > child = mChild ; nsMutationGuard :: DidMutate ( ) ; mozAutoDocUpdate updateBatch ( GetOwnerDoc ( ) , UPDATE_CONTENT_MODEL , aNotify ) ; nsMutationGuard guard ; mozAutoSubtreeModified subtree ( nsnull , nsnull ) ; if ( aNotify && nsContentUtils :: HasMutationListeners ( mChild , NS_EVENT_BITS_MUTATION_NODEREMOVED , this ) ) { mozAutoRemovableBlockerRemover blockerRemover ; nsMutationEvent mutation ( PR_TRUE , NS_MUTATION_NODEREMOVED ) ; mutation . mRelatedNode = do_QueryInterface ( static_cast < nsIAttribute * > ( this ) ) ; subtree . UpdateTarget ( GetOwnerDoc ( ) , this ) ; nsEventDispatcher :: Dispatch ( mChild , nsnull , & mutation ) ; } if ( guard . Mutated ( 0 ) && mChild != child ) { return NS_OK ; } NS_RELEASE ( mChild ) ; static_cast < nsTextNode * > ( child . get ( ) ) -> UnbindFromAttribute ( ) ; nsString nullString ; SetDOMStringToNull ( nullString ) ; SetValue ( nullString ) ; return NS_OK ; }
struct sock * inet_csk_clone_lock ( const struct sock * sk , const struct request_sock * req , const gfp_t priority ) { struct sock * newsk = sk_clone_lock ( sk , priority ) ; if ( newsk ) { struct inet_connection_sock * newicsk = inet_csk ( newsk ) ; newsk -> sk_state = TCP_SYN_RECV ; newicsk -> icsk_bind_hash = NULL ; inet_sk ( newsk ) -> inet_dport = inet_rsk ( req ) -> ir_rmt_port ; inet_sk ( newsk ) -> inet_num = inet_rsk ( req ) -> ir_num ; inet_sk ( newsk ) -> inet_sport = htons ( inet_rsk ( req ) -> ir_num ) ; newsk -> sk_write_space = sk_stream_write_space ; sock_reset_flag ( newsk , SOCK_RCU_FREE ) ; newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ; newicsk -> icsk_retransmits = 0 ; newicsk -> icsk_backoff = 0 ; newicsk -> icsk_probes_out = 0 ; memset ( & newicsk -> icsk_accept_queue , 0 , sizeof ( newicsk -> icsk_accept_queue ) ) ; security_inet_csk_clone ( newsk , req ) ; } return newsk ; }
void OptimizingCompileDispatcher :: FlushOutputQueue ( bool restore_function_code ) { for ( ; ; ) { OptimizedCompilationJob * job = nullptr ; { base :: LockGuard < base :: Mutex > access_output_queue_ ( & output_queue_mutex_ ) ; if ( output_queue_ . empty ( ) ) return ; job = output_queue_ . front ( ) ; output_queue_ . pop ( ) ; } DisposeCompilationJob ( job , restore_function_code ) ; } }
void JSGenericLowering :: LowerJSCreateLiteralObject ( Node * node ) { CreateLiteralParameters const & p = CreateLiteralParametersOf ( node -> op ( ) ) ; CallDescriptor :: Flags flags = FrameStateFlagForCall ( node ) ; node -> InsertInput ( zone ( ) , 0 , jsgraph ( ) -> HeapConstant ( p . feedback ( ) . vector ( ) ) ) ; node -> InsertInput ( zone ( ) , 1 , jsgraph ( ) -> SmiConstant ( p . feedback ( ) . index ( ) ) ) ; node -> InsertInput ( zone ( ) , 2 , jsgraph ( ) -> HeapConstant ( p . constant ( ) ) ) ; node -> InsertInput ( zone ( ) , 3 , jsgraph ( ) -> SmiConstant ( p . flags ( ) ) ) ; if ( ( p . flags ( ) & AggregateLiteral :: kIsShallow ) != 0 && p . length ( ) <= ConstructorBuiltins :: kMaximumClonedShallowObjectProperties ) { Callable callable = Builtins :: CallableFor ( isolate ( ) , Builtins :: kCreateShallowObjectLiteral ) ; ReplaceWithStubCall ( node , callable , flags ) ; } else { ReplaceWithRuntimeCall ( node , Runtime :: kCreateObjectLiteral ) ; } }
static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) { if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , "GAB2" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) { uint8_t desc [ 256 ] ; int score = AVPROBE_SCORE_EXTENSION , ret ; AVIStream * ast = st -> priv_data ; AVInputFormat * sub_demuxer ; AVRational time_base ; int size ; AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ; AVProbeData pd ; unsigned int desc_len = avio_rl32 ( pb ) ; if ( desc_len > pb -> buf_end - pb -> buf_ptr ) goto error ; ret = avio_get_str16le ( pb , desc_len , desc , sizeof ( desc ) ) ; avio_skip ( pb , desc_len - ret ) ; if ( * desc ) av_dict_set ( & st -> metadata , "title" , desc , 0 ) ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; size = pb -> buf_end - pb -> buf_ptr ; pd = ( AVProbeData ) { . buf = av_mallocz ( size + AVPROBE_PADDING_SIZE ) , . buf_size = size } ; if ( ! pd . buf ) goto error ; memcpy ( pd . buf , pb -> buf_ptr , size ) ; sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ; av_freep ( & pd . buf ) ; if ( ! sub_demuxer ) goto error ; if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) goto error ; ast -> sub_ctx -> pb = pb ; if ( ff_copy_whiteblacklists ( ast -> sub_ctx , s ) < 0 ) goto error ; if ( ! avformat_open_input ( & ast -> sub_ctx , "" , sub_demuxer , NULL ) ) { if ( ast -> sub_ctx -> nb_streams != 1 ) goto error ; ff_read_packet ( ast -> sub_ctx , & ast -> sub_pkt ) ; avcodec_parameters_copy ( st -> codecpar , ast -> sub_ctx -> streams [ 0 ] -> codecpar ) ; time_base = ast -> sub_ctx -> streams [ 0 ] -> time_base ; avpriv_set_pts_info ( st , 64 , time_base . num , time_base . den ) ; } ast -> sub_buffer = pkt -> data ; memset ( pkt , 0 , sizeof ( * pkt ) ) ; return 1 ; error : av_freep ( & ast -> sub_ctx ) ; av_freep ( & pb ) ; } return 0 ; }
static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) { write_seqlock ( & state -> seqlock ) ; if ( deleg_stateid != NULL ) { memcpy ( state -> stateid . data , deleg_stateid -> data , sizeof ( state -> stateid . data ) ) ; set_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } if ( open_stateid != NULL ) nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; write_sequnlock ( & state -> seqlock ) ; spin_lock ( & state -> owner -> so_lock ) ; update_open_stateflags ( state , open_flags ) ; spin_unlock ( & state -> owner -> so_lock ) ; }
int vfs_open ( const struct path * path , struct file * file , const struct cred * cred ) { struct dentry * dentry = path -> dentry ; struct inode * inode = dentry -> d_inode ; file -> f_path = * path ; if ( dentry -> d_flags & DCACHE_OP_SELECT_INODE ) { inode = dentry -> d_op -> d_select_inode ( dentry , file -> f_flags ) ; if ( IS_ERR ( inode ) ) return PTR_ERR ( inode ) ; } return do_dentry_open ( file , inode , NULL , cred ) ; }
WasmCode * NativeModule :: AddDeserializedCode ( uint32_t index , Vector < const byte > instructions , uint32_t stack_slots , size_t safepoint_table_offset , size_t handler_table_offset , size_t constant_pool_offset , OwnedVector < trap_handler :: ProtectedInstructionData > protected_instructions , OwnedVector < const byte > reloc_info , OwnedVector < const byte > source_position_table , WasmCode :: Tier tier ) { WasmCode * code = AddOwnedCode ( Just ( index ) , instructions , stack_slots , safepoint_table_offset , handler_table_offset , constant_pool_offset , std :: move ( protected_instructions ) , std :: move ( reloc_info ) , std :: move ( source_position_table ) , WasmCode :: kFunction , tier ) ; if ( ! code -> protected_instructions_ . is_empty ( ) ) { code -> RegisterTrapHandlerData ( ) ; } set_code ( index , code ) ; PatchJumpTable ( index , code -> instruction_start ( ) , WasmCode :: kFlushICache ) ; return code ; }
void LanLinkProvider :: dataReceived ( ) { QSslSocket * socket = qobject_cast < QSslSocket * > ( sender ( ) ) ; if ( socket -> bytesAvailable ( ) > 8192 ) { qCWarning ( KDECONNECT_CORE ) < < "LanLinkProvider/newConnection: Suspiciously long identity package received. Closing connection." < < socket -> peerAddress ( ) < < socket -> bytesAvailable ( ) ; socket -> disconnectFromHost ( ) ; return ; } #if QT_VERSION < QT_VERSION_CHECK(5,7,0) if ( ! socket -> canReadLine ( ) ) return ; #else socket -> startTransaction ( ) ; #endif const QByteArray data = socket -> readLine ( ) ; qCDebug ( KDECONNECT_CORE ) < < "LanLinkProvider received reply:" < < data ; NetworkPacket * np = new NetworkPacket ( QLatin1String ( "" ) ) ; bool success = NetworkPacket :: unserialize ( data , np ) ; #if QT_VERSION < QT_VERSION_CHECK(5,7,0) if ( ! success ) { delete np ; return ; } #else if ( ! success ) { delete np ; socket -> rollbackTransaction ( ) ; return ; } socket -> commitTransaction ( ) ; #endif if ( np -> type ( ) != PACKET_TYPE_IDENTITY ) { qCWarning ( KDECONNECT_CORE ) < < "LanLinkProvider/newConnection: Expected identity, received " < < np -> type ( ) ; delete np ; return ; } m_receivedIdentityPackets [ socket ] . np = np ; const QString & deviceId = np -> get < QString > ( QStringLiteral ( "deviceId" ) ) ; disconnect ( socket , & QIODevice :: readyRead , this , & LanLinkProvider :: dataReceived ) ; if ( np -> get < int > ( QStringLiteral ( "protocolVersion" ) ) >= MIN_VERSION_WITH_SSL_SUPPORT ) { bool isDeviceTrusted = KdeConnectConfig :: instance ( ) . trustedDevices ( ) . contains ( deviceId ) ; configureSslSocket ( socket , deviceId , isDeviceTrusted ) ; qCDebug ( KDECONNECT_CORE ) < < "Starting client ssl (but I'm the server TCP socket)" ; connect ( socket , & QSslSocket :: encrypted , this , & LanLinkProvider :: encrypted ) ; if ( isDeviceTrusted ) { connect ( socket , QOverload < const QList < QSslError > & > :: of ( & QSslSocket :: sslErrors ) , this , & LanLinkProvider :: sslErrors ) ; } socket -> startClientEncryption ( ) ; } else { qWarning ( ) < < np -> get < QString > ( QStringLiteral ( "deviceName" ) ) < < "uses an old protocol version, this won't work" ; delete m_receivedIdentityPackets . take ( socket ) . np ; } }
sp < MediaPlayerBase > MediaPlayerService :: Client :: createPlayer ( player_type playerType ) { sp < MediaPlayerBase > p = getPlayer ( ) ; if ( ( p != NULL ) && ( p -> playerType ( ) != playerType ) ) { ALOGV ( "delete player" ) ; p . clear ( ) ; } if ( p == NULL ) { p = MediaPlayerFactory :: createPlayer ( playerType , this , notify , mPid ) ; } if ( p != NULL ) { p -> setUID ( mUid ) ; } return p ; }
static s32 gf_hevc_read_vps_bs_internal ( GF_BitStream * bs , HEVCState * hevc , Bool stop_at_vps_ext ) { u8 vps_sub_layer_ordering_info_present_flag , vps_extension_flag ; u32 i , j ; s32 vps_id ; HEVC_VPS * vps ; u8 layer_id_included_flag [ MAX_LHVC_LAYERS ] [ 64 ] ; vps_id = gf_bs_read_int_log ( bs , 4 , "vps_id" ) ; if ( vps_id >= 16 ) return - 1 ; vps = & hevc -> vps [ vps_id ] ; vps -> bit_pos_vps_extensions = - 1 ; if ( ! vps -> state ) { vps -> id = vps_id ; vps -> state = 1 ; } vps -> base_layer_internal_flag = gf_bs_read_int_log ( bs , 1 , "base_layer_internal_flag" ) ; vps -> base_layer_available_flag = gf_bs_read_int_log ( bs , 1 , "base_layer_available_flag" ) ; vps -> max_layers = 1 + gf_bs_read_int_log ( bs , 6 , "max_layers_minus1" ) ; if ( vps -> max_layers > MAX_LHVC_LAYERS ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( "[HEVC] sorry, %d layers in VPS but only %d supported\n" , vps -> max_layers , MAX_LHVC_LAYERS ) ) ; return - 1 ; } vps -> max_sub_layers = gf_bs_read_int_log ( bs , 3 , "max_sub_layers_minus1" ) + 1 ; vps -> temporal_id_nesting = gf_bs_read_int_log ( bs , 1 , "temporal_id_nesting" ) ; gf_bs_read_int_log ( bs , 16 , "vps_reserved_ffff_16bits" ) ; hevc_profile_tier_level ( bs , 1 , vps -> max_sub_layers - 1 , & vps -> ptl , 0 ) ; vps_sub_layer_ordering_info_present_flag = gf_bs_read_int_log ( bs , 1 , "vps_sub_layer_ordering_info_present_flag" ) ; for ( i = ( vps_sub_layer_ordering_info_present_flag ? 0 : vps -> max_sub_layers - 1 ) ; i < vps -> max_sub_layers ; i ++ ) { gf_bs_read_ue_log_idx ( bs , "vps_max_dec_pic_buffering_minus1" , i ) ; gf_bs_read_ue_log_idx ( bs , "vps_max_num_reorder_pics" , i ) ; gf_bs_read_ue_log_idx ( bs , "vps_max_latency_increase_plus1" , i ) ; } vps -> max_layer_id = gf_bs_read_int_log ( bs , 6 , "max_layer_id" ) ; if ( vps -> max_layer_id > MAX_LHVC_LAYERS ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( "[HEVC] VPS max layer ID %u but GPAC only supports %u\n" , vps -> max_layer_id , MAX_LHVC_LAYERS ) ) ; return - 1 ; } vps -> num_layer_sets = gf_bs_read_ue_log ( bs , "num_layer_sets_minus1" ) + 1 ; if ( vps -> num_layer_sets > MAX_LHVC_LAYERS ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( "[HEVC] Wrong number of layer sets in VPS %d\n" , vps -> num_layer_sets ) ) ; return - 1 ; } for ( i = 1 ; i < vps -> num_layer_sets ; i ++ ) { for ( j = 0 ; j <= vps -> max_layer_id ; j ++ ) { layer_id_included_flag [ i ] [ j ] = gf_bs_read_int_log_idx2 ( bs , 1 , "layer_id_included_flag" , i , j ) ; } } vps -> num_layers_in_id_list [ 0 ] = 1 ; for ( i = 1 ; i < vps -> num_layer_sets ; i ++ ) { u32 n , m ; n = 0 ; for ( m = 0 ; m <= vps -> max_layer_id ; m ++ ) { if ( layer_id_included_flag [ i ] [ m ] ) { vps -> LayerSetLayerIdList [ i ] [ n ++ ] = m ; if ( vps -> LayerSetLayerIdListMax [ i ] < m ) vps -> LayerSetLayerIdListMax [ i ] = m ; } } vps -> num_layers_in_id_list [ i ] = n ; } if ( gf_bs_read_int_log ( bs , 1 , "vps_timing_info_present_flag" ) ) { u32 vps_num_hrd_parameters ; gf_bs_read_int_log ( bs , 32 , "vps_num_units_in_tick" ) ; gf_bs_read_int_log ( bs , 32 , "vps_time_scale" ) ; if ( gf_bs_read_int_log ( bs , 1 , "vps_poc_proportional_to_timing_flag" ) ) { gf_bs_read_ue_log ( bs , "vps_num_ticks_poc_diff_one_minus1" ) ; } vps_num_hrd_parameters = gf_bs_read_ue_log ( bs , "vps_num_hrd_parameters" ) ; for ( i = 0 ; i < vps_num_hrd_parameters ; i ++ ) { Bool cprms_present_flag = GF_TRUE ; gf_bs_read_ue_log_idx ( bs , "hrd_layer_set_idx" , i ) ; if ( i > 0 ) cprms_present_flag = gf_bs_read_int_log ( bs , 1 , "cprms_present_flag" ) ; hevc_parse_hrd_parameters ( bs , cprms_present_flag , vps -> max_sub_layers - 1 , i ) ; } } if ( stop_at_vps_ext ) { return vps_id ; } vps_extension_flag = gf_bs_read_int_log ( bs , 1 , "vps_extension_flag" ) ; if ( vps_extension_flag ) { Bool res ; gf_bs_align ( bs ) ; res = hevc_parse_vps_extension ( vps , bs ) ; if ( res != GF_TRUE ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( "[HEVC] Failed to parse VPS extensions\n" ) ) ; return - 1 ; } if ( gf_bs_read_int_log ( bs , 1 , "vps_extension2_flag" ) ) { #if 0 while ( gf_bs_available ( bs ) ) { gf_bs_read_int ( bs , 1 ) ; } #endif } } return vps_id ; }
nsHtml5TreeBuilder :: newSnapshot ( ) { jArray < nsHtml5StackNode * , int32_t > listCopy = jArray < nsHtml5StackNode * , int32_t > :: newJArray ( listPtr + 1 ) ; for ( int32_t i = 0 ; i < listCopy . length ; i ++ ) { nsHtml5StackNode * node = listOfActiveFormattingElements [ i ] ; if ( node ) { nsHtml5StackNode * newNode = new nsHtml5StackNode ( node -> getFlags ( ) , node -> ns , node -> name , node -> node , node -> popName , node -> attributes -> cloneAttributes ( nullptr ) ) ; listCopy [ i ] = newNode ; } else { listCopy [ i ] = nullptr ; } } jArray < nsHtml5StackNode * , int32_t > stackCopy = jArray < nsHtml5StackNode * , int32_t > :: newJArray ( currentPtr + 1 ) ; for ( int32_t i = 0 ; i < stackCopy . length ; i ++ ) { nsHtml5StackNode * node = stack [ i ] ; int32_t listIndex = findInListOfActiveFormattingElements ( node ) ; if ( listIndex == - 1 ) { nsHtml5StackNode * newNode = new nsHtml5StackNode ( node -> getFlags ( ) , node -> ns , node -> name , node -> node , node -> popName , nullptr ) ; stackCopy [ i ] = newNode ; } else { stackCopy [ i ] = listCopy [ listIndex ] ; stackCopy [ i ] -> retain ( ) ; } } return new nsHtml5StateSnapshot ( stackCopy , listCopy , formPointer , headPointer , deepTreeSurrogateParent , mode , originalMode , framesetOk , needToDropLF , quirks ) ; }
static void do_free_upto ( BIO * f , BIO * upto ) { if ( upto ) { BIO * tbio ; do { tbio = BIO_pop ( f ) ; BIO_free ( f ) ; f = tbio ; } while ( f != upto ) ; } else BIO_free_all ( f ) ; }
int fb_compact_unserialize_from_buffer ( Variant & out , const char * buf , int n , int & p ) { CHECK_ENOUGH ( 1 , p , n ) ; int code = ( unsigned char ) buf [ p ] ; if ( ( code & ~ kCodeMask ) != kCodePrefix || ( code & kCodeMask ) == FB_CS_INT16 || ( code & kCodeMask ) == FB_CS_INT32 || ( code & kCodeMask ) == FB_CS_INT64 ) { int64_t val ; int err = fb_compact_unserialize_int64_from_buffer ( val , buf , n , p ) ; if ( err ) { return err ; } out = ( int64_t ) val ; return 0 ; } p += 1 ; code &= kCodeMask ; switch ( code ) { case FB_CS_NULL : out = uninit_null ( ) ; break ; case FB_CS_TRUE : out = true ; break ; case FB_CS_FALSE : out = false ; break ; case FB_CS_DOUBLE : { CHECK_ENOUGH ( 8 , p , n ) ; double d = * reinterpret_cast < const double * > ( buf + p ) ; p += 8 ; out = d ; break ; } case FB_CS_STRING_0 : { out = s_empty ; break ; } case FB_CS_STRING_1 : case FB_CS_STRING_N : { int64_t len = 1 ; if ( code == FB_CS_STRING_N ) { int err = fb_compact_unserialize_int64_from_buffer ( len , buf , n , p ) ; if ( err ) { return err ; } } CHECK_ENOUGH ( len , p , n ) ; out = Variant :: attach ( StringData :: Make ( buf + p , len , CopyString ) ) ; p += len ; break ; } case FB_CS_VECTOR : { Array arr = Array :: CreateVArray ( ) ; while ( p < n && buf [ p ] != ( char ) ( kCodePrefix | FB_CS_STOP ) ) { Variant value ; int err = fb_compact_unserialize_from_buffer ( value , buf , n , p ) ; if ( err ) { return err ; } arr . append ( value ) ; } CHECK_ENOUGH ( 1 , p , n ) ; p += 1 ; out = arr ; break ; } case FB_CS_LIST_MAP : { Array arr = Array :: CreateDArray ( ) ; int64_t i = 0 ; while ( p < n && buf [ p ] != ( char ) ( kCodePrefix | FB_CS_STOP ) ) { if ( buf [ p ] == ( char ) ( kCodePrefix | FB_CS_SKIP ) ) { ++ i ; ++ p ; } else { Variant value ; int err = fb_compact_unserialize_from_buffer ( value , buf , n , p ) ; if ( err ) { return err ; } arr . set ( i ++ , value ) ; } } CHECK_ENOUGH ( 1 , p , n ) ; p += 1 ; out = arr ; break ; } case FB_CS_MAP : { Array arr = Array :: CreateDArray ( ) ; while ( p < n && buf [ p ] != ( char ) ( kCodePrefix | FB_CS_STOP ) ) { Variant key ; int err = fb_compact_unserialize_from_buffer ( key , buf , n , p ) ; if ( err ) { return err ; } Variant value ; err = fb_compact_unserialize_from_buffer ( value , buf , n , p ) ; if ( err ) { return err ; } if ( key . getType ( ) == KindOfInt64 ) { arr . set ( key . toInt64 ( ) , value ) ; } else if ( key . getType ( ) == KindOfString || key . getType ( ) == KindOfPersistentString ) { mapSetAndConvertStaticKeys ( arr , key . asStrRef ( ) . get ( ) , std :: move ( value ) ) ; } else { return FB_UNSERIALIZE_UNEXPECTED_ARRAY_KEY_TYPE ; } } CHECK_ENOUGH ( 1 , p , n ) ; p += 1 ; out = arr ; break ; } default : return FB_UNSERIALIZE_UNRECOGNIZED_OBJECT_TYPE ; } return 0 ; }
bool HasOnlyStringMaps ( MapHandles const & maps ) { for ( auto map : maps ) { if ( ! map -> IsStringMap ( ) ) return false ; } return true ; }
JitFrameIterator :: machineState ( ) const { SafepointReader reader ( ionScript ( ) , safepoint ( ) ) ; uintptr_t * spill = spillBase ( ) ; MachineState machine ; for ( GeneralRegisterBackwardIterator iter ( reader . allGprSpills ( ) ) ; iter . more ( ) ; iter ++ ) machine . setRegisterLocation ( * iter , -- spill ) ; uint8_t * spillAlign = alignDoubleSpillWithOffset ( reinterpret_cast < uint8_t * > ( spill ) , 0 ) ; char * floatSpill = reinterpret_cast < char * > ( spillAlign ) ; FloatRegisterSet fregs = reader . allFloatSpills ( ) ; fregs = fregs . reduceSetForPush ( ) ; for ( FloatRegisterBackwardIterator iter ( fregs ) ; iter . more ( ) ; iter ++ ) { floatSpill -= ( * iter ) . size ( ) ; for ( uint32_t a = 0 ; a < ( * iter ) . numAlignedAliased ( ) ; a ++ ) { FloatRegister ftmp ; ( * iter ) . alignedAliased ( a , & ftmp ) ; machine . setRegisterLocation ( ftmp , ( double * ) floatSpill ) ; } } return machine ; }
Skip the mipmap images for uncompressed ( RGB or RGBA ) dds files * / static void SkipRGBMipmaps ( Image * image , DDSInfo * dds_info , int pixel_size ) { MagickOffsetType offset ; register ssize_t i ; size_t h , w ; if ( dds_info -> ddscaps1 & DDSCAPS_MIPMAP && ( dds_info -> ddscaps1 & DDSCAPS_TEXTURE || dds_info -> ddscaps2 & DDSCAPS2_CUBEMAP ) ) { w = DIV2 ( dds_info -> width ) ; h = DIV2 ( dds_info -> height ) ; for ( i = 1 ; ( i < ( ssize_t ) dds_info -> mipmapcount ) && w && h ; i ++ ) { offset = ( MagickOffsetType ) w * h * pixel_size ; ( void ) SeekBlob ( image , offset , SEEK_CUR ) ; w = DIV2 ( w ) ; h = DIV2 ( h ) ; }
nsXBLProtoImplMethod :: InstallMember ( JSContext * aCx , JSObject * aTargetClassObject ) { NS_PRECONDITION ( IsCompiled ( ) , "Should not be installing an uncompiled method" ) ; MOZ_ASSERT ( js :: IsObjectInContextCompartment ( aTargetClassObject , aCx ) ) ; JSObject * globalObject = JS_GetGlobalForObject ( aCx , aTargetClassObject ) ; if ( mJSMethodObject ) { nsDependentString name ( mName ) ; JSObject * method = :: JS_CloneFunctionObject ( aCx , mJSMethodObject , globalObject ) ; if ( ! method ) { return NS_ERROR_OUT_OF_MEMORY ; } if ( ! :: JS_DefineUCProperty ( aCx , aTargetClassObject , static_cast < const jschar * > ( mName ) , name . Length ( ) , OBJECT_TO_JSVAL ( method ) , NULL , NULL , JSPROP_ENUMERATE ) ) { return NS_ERROR_OUT_OF_MEMORY ; } } return NS_OK ; }
int RandomNumberGenerator :: NextInt ( int max ) { DCHECK_LT ( 0 , max ) ; if ( bits :: IsPowerOfTwo ( max ) ) { return static_cast < int > ( ( max * static_cast < int64_t > ( Next ( 31 ) ) ) > > 31 ) ; } while ( true ) { int rnd = Next ( 31 ) ; int val = rnd % max ; if ( rnd - val + ( max - 1 ) >= 0 ) { return val ; } } }
BaselineScript :: icEntryFromPCOffset ( uint32_t pcOffset ) { size_t bottom = 0 ; size_t top = numICEntries ( ) ; size_t mid = ( bottom + top ) / 2 ; while ( mid < top ) { ICEntry & midEntry = icEntry ( mid ) ; if ( midEntry . pcOffset ( ) < pcOffset ) bottom = mid + 1 ; else if ( midEntry . pcOffset ( ) > pcOffset ) top = mid ; else break ; mid = ( bottom + top ) / 2 ; } for ( size_t i = mid ; i < numICEntries ( ) && icEntry ( i ) . pcOffset ( ) == pcOffset ; i -- ) { if ( icEntry ( i ) . isForOp ( ) ) return icEntry ( i ) ; } for ( size_t i = mid + 1 ; i < numICEntries ( ) && icEntry ( i ) . pcOffset ( ) == pcOffset ; i ++ ) { if ( icEntry ( i ) . isForOp ( ) ) return icEntry ( i ) ; } MOZ_ASSUME_UNREACHABLE ( "Invalid PC offset for IC entry." ) ; }
const Operator * CommonOperatorBuilder :: TrapIf ( TrapId trap_id ) { switch ( trap_id ) { #define CACHED_TRAP_IF(Trap) \  case TrapId::k##Trap:      \  return &cache_.kTrapIf##Trap##Operator; CACHED_TRAP_IF_LIST ( CACHED_TRAP_IF ) #undef CACHED_TRAP_IF default : break ; } return new ( zone ( ) ) Operator1 < TrapId > ( IrOpcode :: kTrapIf , Operator :: kFoldable | Operator :: kNoThrow , "TrapIf" , 1 , 1 , 1 , 0 , 0 , 1 , trap_id ) ; }
static void xen_netbk_fill_frags ( struct xen_netbk * netbk , struct sk_buff * skb ) { struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i ; for ( i = 0 ; i < nr_frags ; i ++ ) { skb_frag_t * frag = shinfo -> frags + i ; struct xen_netif_tx_request * txp ; struct page * page ; u16 pending_idx ; pending_idx = frag_get_pending_idx ( frag ) ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx ) ) ; __skb_fill_page_desc ( skb , i , page , txp -> offset , txp -> size ) ; skb -> len += txp -> size ; skb -> data_len += txp -> size ; skb -> truesize += txp -> size ; get_page ( netbk -> mmap_pages [ pending_idx ] ) ; xen_netbk_idx_release ( netbk , pending_idx ) ; } }
void Http2Stream :: UpdatePriorityDependency ( ) { if ( ! mSession -> UseH2Deps ( ) ) { return ; } nsHttpTransaction * trans = mTransaction -> QueryHttpTransaction ( ) ; if ( ! trans ) { return ; } mPriorityDependency = GetPriorityDependencyFromTransaction ( trans ) ; if ( gHttpHandler -> ActiveTabPriority ( ) && mTransactionTabId != mCurrentTopBrowsingContextId && mPriorityDependency != Http2Session :: kUrgentStartGroupID ) { LOG3 ( ( "Http2Stream::UpdatePriorityDependency %p " " depends on background group for trans %p\n" , this , trans ) ) ; mPriorityDependency = Http2Session :: kBackgroundGroupID ; nsHttp :: NotifyActiveTabLoadOptimization ( ) ; } LOG1 ( ( "Http2Stream::UpdatePriorityDependency %p " "depends on stream 0x%X\n" , this , mPriorityDependency ) ) ; }
Handle < PropertyCell > Factory :: NewPropertyCell ( Handle < Name > name , PretenureFlag pretenure ) { DCHECK ( name -> IsUniqueName ( ) ) ; STATIC_ASSERT ( PropertyCell :: kSize <= kMaxRegularHeapObjectSize ) ; HeapObject * result = AllocateRawWithImmortalMap ( PropertyCell :: kSize , pretenure , * global_property_cell_map ( ) ) ; Handle < PropertyCell > cell ( PropertyCell :: cast ( result ) , isolate ( ) ) ; cell -> set_dependent_code ( DependentCode :: cast ( * empty_weak_fixed_array ( ) ) , SKIP_WRITE_BARRIER ) ; cell -> set_property_details ( PropertyDetails ( Smi :: kZero ) ) ; cell -> set_name ( * name ) ; cell -> set_value ( * the_hole_value ( ) ) ; return cell ; }
RUNTIME_FUNCTION ( Runtime_LoadGlobalIC_Miss ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 3 , args . length ( ) ) ; Handle < JSGlobalObject > global = isolate -> global_object ( ) ; Handle < String > name = args . at < String > ( 0 ) ; Handle < Smi > slot = args . at < Smi > ( 1 ) ; Handle < FeedbackVector > vector = args . at < FeedbackVector > ( 2 ) ; FeedbackSlot vector_slot = FeedbackVector :: ToSlot ( slot -> value ( ) ) ; LoadGlobalIC ic ( isolate , vector , vector_slot ) ; ic . UpdateState ( global , name ) ; Handle < Object > result ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , result , ic . Load ( name ) ) ; return * result ; }
xmlFreeEntityWrapper ( xmlEntityPtr entity , const xmlChar * name ATTRIBUTE_UNUSED ) { if ( entity != NULL ) xmlFreeEntity ( entity ) ; }
base :: Optional < ParseResult > MakeVarDeclarationStatement ( ParseResultIterator * child_results ) { auto kind = child_results -> NextAs < std :: string > ( ) ; bool const_qualified = kind == "const" ; if ( ! const_qualified ) DCHECK_EQ ( "let" , kind ) ; auto name = child_results -> NextAs < std :: string > ( ) ; auto type = child_results -> NextAs < TypeExpression * > ( ) ; base :: Optional < Expression * > initializer ; if ( child_results -> HasNext ( ) ) initializer = child_results -> NextAs < Expression * > ( ) ; Statement * result = MakeNode < VarDeclarationStatement > ( const_qualified , std :: move ( name ) , type , initializer ) ; return ParseResult { result } ; }
static bool getVSCoverage ( std :: vector < uint32_t > * out_ranges , const uint8_t * data , size_t size , uint32_t defaultUVSTableOffset , uint32_t nonDefaultUVSTableOffset , const SparseBitSet & baseCoverage ) { std :: vector < uint32_t > rangesFromNonDefaultUVSTable ; if ( nonDefaultUVSTableOffset != 0 ) { constexpr size_t kHeaderSize = 4 ; constexpr size_t kUVSMappingRecordSize = 5 ; const uint8_t * nonDefaultUVSTable = data + nonDefaultUVSTableOffset ; const size_t nonDefaultUVSTableRemaining = size - nonDefaultUVSTableOffset ; if ( nonDefaultUVSTableRemaining < kHeaderSize ) { return false ; } const uint32_t numRecords = readU32 ( nonDefaultUVSTable , 0 ) ; if ( numRecords * kUVSMappingRecordSize + kHeaderSize > nonDefaultUVSTableRemaining ) { return false ; } for ( uint32_t i = 0 ; i < numRecords ; ++ i ) { const size_t recordOffset = kHeaderSize + kUVSMappingRecordSize * i ; const uint32_t codePoint = readU24 ( nonDefaultUVSTable , recordOffset ) ; if ( ! addRange ( rangesFromNonDefaultUVSTable , codePoint , codePoint + 1 ) ) { return false ; } } } std :: vector < uint32_t > rangesFromDefaultUVSTable ; if ( defaultUVSTableOffset != 0 ) { constexpr size_t kHeaderSize = 4 ; constexpr size_t kUnicodeRangeRecordSize = 4 ; const uint8_t * defaultUVSTable = data + defaultUVSTableOffset ; const size_t defaultUVSTableRemaining = size - defaultUVSTableOffset ; if ( defaultUVSTableRemaining < kHeaderSize ) { return false ; } const uint32_t numRecords = readU32 ( defaultUVSTable , 0 ) ; if ( numRecords * kUnicodeRangeRecordSize + kHeaderSize > defaultUVSTableRemaining ) { return false ; } for ( uint32_t i = 0 ; i < numRecords ; ++ i ) { const size_t recordOffset = kHeaderSize + kUnicodeRangeRecordSize * i ; const uint32_t startCp = readU24 ( defaultUVSTable , recordOffset ) ; const uint8_t rangeLength = defaultUVSTable [ recordOffset + 3 ] ; for ( uint32_t cp = startCp ; cp <= startCp + rangeLength ; ++ cp ) { if ( baseCoverage . get ( cp ) ) { if ( ! addRange ( rangesFromDefaultUVSTable , cp , cp + 1 ) ) { return false ; } } } } } * out_ranges = mergeRanges ( rangesFromDefaultUVSTable , rangesFromNonDefaultUVSTable ) ; return true ; }
static void do_popen ( FILE * fin , FILE * fout , int afdt_fd ) { char buf [ BUFFER_SIZE ] ; char cwd [ BUFFER_SIZE ] ; if ( ! fgets ( buf , BUFFER_SIZE , fin ) ) buf [ 0 ] = '\0' ; bool read_only = ( buf [ 0 ] == 'r' ) ; read_buf ( fin , buf ) ; std :: string old_cwd = Process :: GetCurrentDirectory ( ) ; read_buf ( fin , cwd ) ; if ( old_cwd != cwd ) { if ( chdir ( cwd ) ) { Logger :: Warning ( "Light Process failed chdir to %s." , cwd ) ; } } FILE * f = buf [ 0 ] ? :: popen ( buf , read_only ? "r" : "w" ) : nullptr ; if ( old_cwd != cwd && chdir ( old_cwd . c_str ( ) ) ) { } if ( f == nullptr ) { Logger :: Error ( "Light process failed popen: %d (%s)." , errno , folly :: errnoStr ( errno ) . c_str ( ) ) ; fprintf ( fout , "error\n" ) ; fflush ( fout ) ; } else { fprintf ( fout , "success\n%" PRId64 "\n" , ( int64_t ) f ) ; fflush ( fout ) ; int fd = fileno ( f ) ; send_fd ( afdt_fd , fd ) ; } }
bool Remove ( RefPtr < SourceListener > aListener ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; if ( ! mInactiveListeners . RemoveElement ( aListener ) && ! mActiveListeners . RemoveElement ( aListener ) ) { return false ; } MOZ_ASSERT ( ! mInactiveListeners . Contains ( aListener ) , "A SourceListener should only be once in one of " "mInactiveListeners and mActiveListeners" ) ; MOZ_ASSERT ( ! mActiveListeners . Contains ( aListener ) , "A SourceListener should only be once in one of " "mInactiveListeners and mActiveListeners" ) ; LOG ( "GUMWindowListener %p stopping SourceListener %p." , this , aListener . get ( ) ) ; aListener -> Stop ( ) ; if ( MediaDevice * removedDevice = aListener -> GetVideoDevice ( ) ) { bool revokeVideoPermission = true ; nsString removedRawId ; nsString removedSourceType ; removedDevice -> GetRawId ( removedRawId ) ; removedDevice -> GetMediaSource ( removedSourceType ) ; for ( const auto & l : mActiveListeners ) { if ( MediaDevice * device = l -> GetVideoDevice ( ) ) { nsString rawId ; device -> GetRawId ( rawId ) ; if ( removedRawId . Equals ( rawId ) ) { revokeVideoPermission = false ; break ; } } } if ( revokeVideoPermission ) { nsCOMPtr < nsIObserverService > obs = services :: GetObserverService ( ) ; auto * window = nsGlobalWindowInner :: GetInnerWindowWithId ( mWindowID ) ; auto req = MakeRefPtr < GetUserMediaRequest > ( window , removedRawId , removedSourceType , UserActivation :: IsHandlingUserInput ( ) ) ; obs -> NotifyWhenScriptSafe ( req , "recording-device-stopped" , nullptr ) ; } } if ( MediaDevice * removedDevice = aListener -> GetAudioDevice ( ) ) { bool revokeAudioPermission = true ; nsString removedRawId ; nsString removedSourceType ; removedDevice -> GetRawId ( removedRawId ) ; removedDevice -> GetMediaSource ( removedSourceType ) ; for ( const auto & l : mActiveListeners ) { if ( MediaDevice * device = l -> GetAudioDevice ( ) ) { nsString rawId ; device -> GetRawId ( rawId ) ; if ( removedRawId . Equals ( rawId ) ) { revokeAudioPermission = false ; break ; } } } if ( revokeAudioPermission ) { nsCOMPtr < nsIObserverService > obs = services :: GetObserverService ( ) ; auto * window = nsGlobalWindowInner :: GetInnerWindowWithId ( mWindowID ) ; auto req = MakeRefPtr < GetUserMediaRequest > ( window , removedRawId , removedSourceType , UserActivation :: IsHandlingUserInput ( ) ) ; obs -> NotifyWhenScriptSafe ( req , "recording-device-stopped" , nullptr ) ; } } if ( mInactiveListeners . Length ( ) == 0 && mActiveListeners . Length ( ) == 0 ) { LOG ( "GUMWindowListener %p Removed last SourceListener. Cleaning up." , this ) ; RemoveAll ( ) ; } nsCOMPtr < nsIEventTarget > mainTarget = do_GetMainThread ( ) ; NS_ProxyRelease ( __func__ , mainTarget , aListener . forget ( ) , true ) ; return true ; }
cib_tls_close ( cib_t * cib ) { cib_remote_opaque_t * private = cib -> variant_opaque ; shutdown ( private -> command . socket , SHUT_RDWR ) ; shutdown ( private -> callback . socket , SHUT_RDWR ) ; close ( private -> command . socket ) ; close ( private -> callback . socket ) ; #ifdef HAVE_GNUTLS_GNUTLS_H if ( private -> command . encrypted ) { gnutls_bye ( * ( private -> command . session ) , GNUTLS_SHUT_RDWR ) ; gnutls_deinit ( * ( private -> command . session ) ) ; gnutls_free ( private -> command . session ) ; gnutls_bye ( * ( private -> callback . session ) , GNUTLS_SHUT_RDWR ) ; gnutls_deinit ( * ( private -> callback . session ) ) ; gnutls_free ( private -> callback . session ) ; gnutls_anon_free_client_credentials ( anon_cred_c ) ; gnutls_global_deinit ( ) ; } #endif return 0 ; }
Handle < JSObject > Factory :: NewJSObjectFromMap ( Handle < Map > map , PretenureFlag pretenure , Handle < AllocationSite > allocation_site ) { DCHECK ( map -> instance_type ( ) != JS_FUNCTION_TYPE ) ; DCHECK ( map -> instance_type ( ) != JS_GLOBAL_OBJECT_TYPE ) ; HeapObject * obj = AllocateRawWithAllocationSite ( map , pretenure , allocation_site ) ; Handle < JSObject > js_obj ( JSObject :: cast ( obj ) , isolate ( ) ) ; InitializeJSObjectFromMap ( js_obj , empty_fixed_array ( ) , map ) ; DCHECK ( js_obj -> HasFastElements ( ) || js_obj -> HasFixedTypedArrayElements ( ) || js_obj -> HasFastStringWrapperElements ( ) || js_obj -> HasFastArgumentsElements ( ) ) ; return js_obj ; }
TimerThread :: Run ( ) { PR_SetCurrentThreadName ( "Timer" ) ; #ifdef MOZ_NUWA_PROCESS if ( IsNuwaProcess ( ) ) { NuwaMarkCurrentThread ( nullptr , nullptr ) ; } #endif MonitorAutoLock lock ( mMonitor ) ; uint32_t usForPosInterval = 1 ; while ( PR_MicrosecondsToInterval ( usForPosInterval ) == 0 ) { usForPosInterval <<= 1 ; } size_t usIntervalResolution ; BinarySearchIf ( MicrosecondsToInterval ( ) , 0 , usForPosInterval , IntervalComparator ( ) , & usIntervalResolution ) ; MOZ_ASSERT ( PR_MicrosecondsToInterval ( usIntervalResolution - 1 ) == 0 ) ; MOZ_ASSERT ( PR_MicrosecondsToInterval ( usIntervalResolution ) == 1 ) ; int32_t halfMicrosecondsIntervalResolution = usIntervalResolution / 2 ; bool forceRunNextTimer = false ; while ( ! mShutdown ) { PRIntervalTime waitFor ; bool forceRunThisTimer = forceRunNextTimer ; forceRunNextTimer = false ; if ( mSleeping ) { uint32_t milliseconds = 100 ; if ( ChaosMode :: isActive ( ChaosMode :: TimerScheduling ) ) { milliseconds = ChaosMode :: randomUint32LessThan ( 200 ) ; } waitFor = PR_MillisecondsToInterval ( milliseconds ) ; } else { waitFor = PR_INTERVAL_NO_TIMEOUT ; TimeStamp now = TimeStamp :: Now ( ) ; nsTimerImpl * timer = nullptr ; if ( ! mTimers . IsEmpty ( ) ) { timer = mTimers [ 0 ] ; if ( now >= timer -> mTimeout || forceRunThisTimer ) { next : nsRefPtr < nsTimerImpl > timerRef ( timer ) ; RemoveTimerInternal ( timer ) ; timer = nullptr ; MOZ_LOG ( GetTimerLog ( ) , LogLevel :: Debug , ( "Timer thread woke up %fms from when it was supposed to\n" , fabs ( ( now - timerRef -> mTimeout ) . ToMilliseconds ( ) ) ) ) ; { MonitorAutoUnlock unlock ( mMonitor ) ; timerRef = nsTimerImpl :: PostTimerEvent ( timerRef . forget ( ) ) ; } if ( timerRef ) { nsrefcnt rc = timerRef . forget ( ) . take ( ) -> Release ( ) ; ( void ) rc ; MOZ_ASSERT ( rc != 0 , "destroyed timer off its target thread!" ) ; } if ( mShutdown ) { break ; } now = TimeStamp :: Now ( ) ; } } if ( ! mTimers . IsEmpty ( ) ) { timer = mTimers [ 0 ] ; TimeStamp timeout = timer -> mTimeout ; double microseconds = ( timeout - now ) . ToMilliseconds ( ) * 1000 ; if ( ChaosMode :: isActive ( ChaosMode :: TimerScheduling ) ) { static const float sFractions [ ] = { 0.0f , 0.25f , 0.5f , 0.75f , 1.0f , 1.75f , 2.75f } ; microseconds *= sFractions [ ChaosMode :: randomUint32LessThan ( ArrayLength ( sFractions ) ) ] ; forceRunNextTimer = true ; } if ( microseconds < halfMicrosecondsIntervalResolution ) { forceRunNextTimer = false ; goto next ; } waitFor = PR_MicrosecondsToInterval ( static_cast < uint32_t > ( microseconds ) ) ; if ( waitFor == 0 ) { waitFor = 1 ; } } if ( MOZ_LOG_TEST ( GetTimerLog ( ) , LogLevel :: Debug ) ) { if ( waitFor == PR_INTERVAL_NO_TIMEOUT ) MOZ_LOG ( GetTimerLog ( ) , LogLevel :: Debug , ( "waiting for PR_INTERVAL_NO_TIMEOUT\n" ) ) ; else MOZ_LOG ( GetTimerLog ( ) , LogLevel :: Debug , ( "waiting for %u\n" , PR_IntervalToMilliseconds ( waitFor ) ) ) ; } } mWaiting = true ; mNotified = false ; mMonitor . Wait ( waitFor ) ; if ( mNotified ) { forceRunNextTimer = false ; } mWaiting = false ; } return NS_OK ; }
vpx_codec_err_t vpx_validate_mmaps ( const vpx_codec_stream_info_t * si , const vpx_codec_mmap_t * mmaps , const mem_req_t * mem_reqs , int nreqs , vpx_codec_flags_t init_flags ) { int i ; for ( i = 0 ; i < nreqs - 1 ; ++ i ) { if ( mmaps [ i ] . base == NULL ) { return VPX_CODEC_MEM_ERROR ; } if ( mem_reqs [ i ] . calc_sz != NULL ) { vpx_codec_dec_cfg_t cfg ; cfg . w = si -> w ; cfg . h = si -> h ; if ( mmaps [ i ] . sz < mem_reqs [ i ] . calc_sz ( & cfg , init_flags ) ) { return VPX_CODEC_MEM_ERROR ; } } } return VPX_CODEC_OK ; }
void XMLHttpRequestMainThread :: SetRequestHeader ( const nsACString & aName , const nsACString & aValue , ErrorResult & aRv ) { NOT_CALLABLE_IN_SYNC_SEND_RV if ( mState != XMLHttpRequest_Binding :: OPENED ) { aRv . ThrowInvalidStateError ( "XMLHttpRequest state must be OPENED." ) ; return ; } if ( mFlagSend ) { aRv . ThrowInvalidStateError ( "XMLHttpRequest must not be sending." ) ; return ; } nsAutoCString value ; NS_TrimHTTPWhitespace ( aValue , value ) ; if ( ! NS_IsValidHTTPToken ( aName ) || ! NS_IsReasonableHTTPHeaderValue ( value ) ) { aRv . Throw ( NS_ERROR_DOM_INVALID_HEADER_NAME ) ; return ; } bool isPrivilegedCaller = IsSystemXHR ( ) ; bool isForbiddenHeader = nsContentUtils :: IsForbiddenRequestHeader ( aName ) ; if ( ! isPrivilegedCaller && isForbiddenHeader ) { AutoTArray < nsString , 1 > params ; CopyUTF8toUTF16 ( aName , * params . AppendElement ( ) ) ; LogMessage ( "ForbiddenHeaderWarning" , GetOwner ( ) , params ) ; return ; } if ( isPrivilegedCaller && isForbiddenHeader ) { mAuthorRequestHeaders . Set ( aName , value ) ; } else { mAuthorRequestHeaders . MergeOrSet ( aName , value ) ; } }
COMMON_CACHED_OP_LIST ( CACHED ) #undef CACHED const Operator * CommonOperatorBuilder :: End ( size_t control_input_count ) { switch ( control_input_count ) { #define CACHED_END(input_count) \  case input_count:             \  return &cache_.kEnd##input_count##Operator; CACHED_END_LIST ( CACHED_END ) #undef CACHED_END default : break ; } return new ( zone ( ) ) Operator ( IrOpcode :: kEnd , Operator :: kKontrol , "End" , 0 , 0 , control_input_count , 0 , 0 , 0 ) ; }
void btm_ble_cache_adv_data ( tBTM_INQ_RESULTS * p_cur , UINT8 data_len , UINT8 * p , UINT8 evt_type ) { tBTM_BLE_INQ_CB * p_le_inq_cb = & btm_cb . ble_ctr_cb . inq_var ; UINT8 * p_cache ; UINT8 length ; UNUSED ( p_cur ) ; if ( evt_type != BTM_BLE_SCAN_RSP_EVT ) { p_le_inq_cb -> adv_len = 0 ; memset ( p_le_inq_cb -> adv_data_cache , 0 , BTM_BLE_CACHE_ADV_DATA_MAX ) ; } if ( data_len > 0 ) { p_cache = & p_le_inq_cb -> adv_data_cache [ p_le_inq_cb -> adv_len ] ; STREAM_TO_UINT8 ( length , p ) ; while ( length && ( ( p_le_inq_cb -> adv_len + length + 1 ) <= BTM_BLE_CACHE_ADV_DATA_MAX ) ) { memcpy ( p_cache , p - 1 , length + 1 ) ; p_cache += length + 1 ; p_le_inq_cb -> adv_len += length + 1 ; p += length ; STREAM_TO_UINT8 ( length , p ) ; } } }
void checkWrappingBuffer ( ) { WrappingBuffer wrappingBuffer ; fifo_frames_t framesAvailable = mFifoBuffer . getFifoControllerBase ( ) -> getEmptyFramesAvailable ( ) ; fifo_frames_t wrapAvailable = mFifoBuffer . getEmptyRoomAvailable ( & wrappingBuffer ) ; EXPECT_EQ ( framesAvailable , wrapAvailable ) ; fifo_frames_t bothAvailable = wrappingBuffer . numFrames [ 0 ] + wrappingBuffer . numFrames [ 1 ] ; EXPECT_EQ ( framesAvailable , bothAvailable ) ; framesAvailable = mFifoBuffer . getFifoControllerBase ( ) -> getFullFramesAvailable ( ) ; wrapAvailable = mFifoBuffer . getFullDataAvailable ( & wrappingBuffer ) ; EXPECT_EQ ( framesAvailable , wrapAvailable ) ; bothAvailable = wrappingBuffer . numFrames [ 0 ] + wrappingBuffer . numFrames [ 1 ] ; EXPECT_EQ ( framesAvailable , bothAvailable ) ; }
mozilla :: ipc :: IPCResult ContentParent :: RecvWindowFocus ( BrowsingContext * aContext ) { if ( ! aContext || aContext -> IsDiscarded ( ) ) { MOZ_LOG ( BrowsingContext :: GetLog ( ) , LogLevel :: Debug , ( "ParentIPC: Trying to send a message to dead or detached context" ) ) ; return IPC_OK ( ) ; } ContentProcessManager * cpm = ContentProcessManager :: GetSingleton ( ) ; ContentParent * cp = cpm -> GetContentProcessById ( ContentParentId ( aContext -> Canonical ( ) -> OwnerProcessId ( ) ) ) ; Unused < < cp -> SendWindowFocus ( aContext ) ; return IPC_OK ( ) ; }
static SvcInternal * get_svc_internal ( SvcContext * svc_ctx ) { if ( svc_ctx == NULL ) return NULL ; if ( svc_ctx -> internal == NULL ) { SvcInternal * const si = ( SvcInternal * ) malloc ( sizeof ( * si ) ) ; if ( si != NULL ) { memset ( si , 0 , sizeof ( * si ) ) ; } svc_ctx -> internal = si ; } return ( SvcInternal * ) svc_ctx -> internal ; }
void RegExpMacroAssemblerMIPS :: CheckNotBackReference ( int start_reg , bool read_backward , Label * on_no_match ) { Label fallthrough ; Label success ; __ lw ( a0 , register_location ( start_reg ) ) ; __ lw ( a1 , register_location ( start_reg + 1 ) ) ; __ Subu ( a1 , a1 , a0 ) ; __ Branch ( & fallthrough , le , a1 , Operand ( zero_reg ) ) ; if ( read_backward ) { __ lw ( t0 , MemOperand ( frame_pointer ( ) , kStringStartMinusOne ) ) ; __ Addu ( t0 , t0 , a1 ) ; BranchOrBacktrack ( on_no_match , le , current_input_offset ( ) , Operand ( t0 ) ) ; } else { __ Addu ( t5 , a1 , current_input_offset ( ) ) ; BranchOrBacktrack ( on_no_match , gt , t5 , Operand ( zero_reg ) ) ; } __ Addu ( a0 , a0 , Operand ( end_of_input_address ( ) ) ) ; __ Addu ( a2 , end_of_input_address ( ) , Operand ( current_input_offset ( ) ) ) ; if ( read_backward ) { __ Subu ( a2 , a2 , Operand ( a1 ) ) ; } __ Addu ( a1 , a0 , Operand ( a1 ) ) ; Label loop ; __ bind ( & loop ) ; if ( mode_ == LATIN1 ) { __ lbu ( a3 , MemOperand ( a0 , 0 ) ) ; __ addiu ( a0 , a0 , char_size ( ) ) ; __ lbu ( t0 , MemOperand ( a2 , 0 ) ) ; __ addiu ( a2 , a2 , char_size ( ) ) ; } else { DCHECK ( mode_ == UC16 ) ; __ lhu ( a3 , MemOperand ( a0 , 0 ) ) ; __ addiu ( a0 , a0 , char_size ( ) ) ; __ lhu ( t0 , MemOperand ( a2 , 0 ) ) ; __ addiu ( a2 , a2 , char_size ( ) ) ; } BranchOrBacktrack ( on_no_match , ne , a3 , Operand ( t0 ) ) ; __ Branch ( & loop , lt , a0 , Operand ( a1 ) ) ; __ Subu ( current_input_offset ( ) , a2 , end_of_input_address ( ) ) ; if ( read_backward ) { __ lw ( t0 , register_location ( start_reg ) ) ; __ lw ( t5 , register_location ( start_reg + 1 ) ) ; __ Addu ( current_input_offset ( ) , current_input_offset ( ) , Operand ( t0 ) ) ; __ Subu ( current_input_offset ( ) , current_input_offset ( ) , Operand ( t5 ) ) ; } __ bind ( & fallthrough ) ; }
ContentParent :: ActorDestroy ( ActorDestroyReason why ) { if ( mForceKillTimer ) { mForceKillTimer -> Cancel ( ) ; mForceKillTimer = nullptr ; } mIPCOpen = false ; if ( mHangMonitorActor ) { ProcessHangMonitor :: RemoveProcess ( mHangMonitorActor ) ; mHangMonitorActor = nullptr ; } if ( why == NormalShutdown && ! mCalledClose ) { mCalledClose = true ; } ShutDownProcess ( why == NormalShutdown ? CLOSE_CHANNEL : CLOSE_CHANNEL_WITH_ERROR ) ; RefPtr < ContentParent > kungFuDeathGrip ( this ) ; nsCOMPtr < nsIObserverService > obs = mozilla :: services :: GetObserverService ( ) ; if ( obs ) { size_t length = ArrayLength ( sObserverTopics ) ; for ( size_t i = 0 ; i < length ; ++ i ) { obs -> RemoveObserver ( static_cast < nsIObserver * > ( this ) , sObserverTopics [ i ] ) ; } } Preferences :: RemoveObserver ( this , "" ) ; gfxVars :: RemoveReceiver ( this ) ; if ( GPUProcessManager * gpu = GPUProcessManager :: Get ( ) ) { gpu -> RemoveListener ( this ) ; } RecvRemoveGeolocationListener ( ) ; mConsoleService = nullptr ; #ifdef MOZ_GECKO_PROFILER if ( mIsProfilerActive && ! mProfile . IsEmpty ( ) ) { profiler_OOP_exit_profile ( mProfile ) ; } #endif if ( obs ) { RefPtr < nsHashPropertyBag > props = new nsHashPropertyBag ( ) ; props -> SetPropertyAsUint64 ( NS_LITERAL_STRING ( "childID" ) , mChildID ) ; if ( AbnormalShutdown == why ) { Telemetry :: Accumulate ( Telemetry :: SUBPROCESS_ABNORMAL_ABORT , NS_LITERAL_CSTRING ( "content" ) , 1 ) ; props -> SetPropertyAsBool ( NS_LITERAL_STRING ( "abnormal" ) , true ) ; #ifdef MOZ_CRASHREPORTER if ( mCrashReporter ) { if ( ! mCreatedPairedMinidumps ) { mCrashReporter -> GenerateCrashReport ( OtherPid ( ) ) ; } nsAutoString dumpID ; if ( mCrashReporter -> HasMinidump ( ) ) { dumpID = mCrashReporter -> MinidumpID ( ) ; } props -> SetPropertyAsAString ( NS_LITERAL_STRING ( "dumpID" ) , dumpID ) ; } #endif } nsAutoString cpId ; cpId . AppendInt ( static_cast < uint64_t > ( this -> ChildID ( ) ) ) ; obs -> NotifyObservers ( ( nsIPropertyBag2 * ) props , "ipc:content-shutdown" , cpId . get ( ) ) ; } nsCOMPtr < nsIIdleService > idleService = do_GetService ( "@mozilla.org/widget/idleservice;1" ) ; MOZ_ASSERT ( idleService ) ; RefPtr < ParentIdleListener > listener ; for ( int32_t i = mIdleListeners . Length ( ) - 1 ; i >= 0 ; -- i ) { listener = static_cast < ParentIdleListener * > ( mIdleListeners [ i ] . get ( ) ) ; idleService -> RemoveIdleObserver ( listener , listener -> mTime ) ; } mIdleListeners . Clear ( ) ; MessageLoop :: current ( ) -> PostTask ( NewRunnableFunction ( DelayedDeleteSubprocess , mSubprocess ) ) ; mSubprocess = nullptr ; NS_DispatchToCurrentThread ( new DelayedDeleteContentParentTask ( this ) ) ; ContentProcessManager * cpm = ContentProcessManager :: GetSingleton ( ) ; nsTArray < ContentParentId > childIDArray = cpm -> GetAllChildProcessById ( this -> ChildID ( ) ) ; for ( uint32_t i = 0 ; i < childIDArray . Length ( ) ; i ++ ) { ContentParent * cp = cpm -> GetContentProcessById ( childIDArray [ i ] ) ; MessageLoop :: current ( ) -> PostTask ( NewRunnableMethod < ShutDownMethod > ( cp , & ContentParent :: ShutDownProcess , SEND_SHUTDOWN_MESSAGE ) ) ; } cpm -> RemoveContentProcess ( this -> ChildID ( ) ) ; if ( mDriverCrashGuard ) { mDriverCrashGuard -> NotifyCrashed ( ) ; } for ( uint32_t i = 0 ; i < mBlobURLs . Length ( ) ; ++ i ) { nsHostObjectProtocolHandler :: RemoveDataEntry ( mBlobURLs [ i ] ) ; } mBlobURLs . Clear ( ) ; #if defined(XP_WIN32) && defined(ACCESSIBILITY) a11y :: AccessibleWrap :: ReleaseContentProcessIdFor ( ChildID ( ) ) ; #endif }
static OPJ_BOOL opj_j2k_add_mct ( opj_tcp_t * p_tcp , opj_image_t * p_image , OPJ_UINT32 p_index ) { OPJ_UINT32 i ; opj_simple_mcc_decorrelation_data_t * l_mcc_record ; opj_mct_data_t * l_deco_array , * l_offset_array ; OPJ_UINT32 l_data_size , l_mct_size , l_offset_size ; OPJ_UINT32 l_nb_elem ; OPJ_UINT32 * l_offset_data , * l_current_offset_data ; opj_tccp_t * l_tccp ; assert ( p_tcp != 00 ) ; l_mcc_record = p_tcp -> m_mcc_records ; for ( i = 0 ; i < p_tcp -> m_nb_mcc_records ; ++ i ) { if ( l_mcc_record -> m_index == p_index ) { break ; } } if ( i == p_tcp -> m_nb_mcc_records ) { return OPJ_TRUE ; } if ( l_mcc_record -> m_nb_comps != p_image -> numcomps ) { return OPJ_TRUE ; } l_deco_array = l_mcc_record -> m_decorrelation_array ; if ( l_deco_array ) { l_data_size = MCT_ELEMENT_SIZE [ l_deco_array -> m_element_type ] * p_image -> numcomps * p_image -> numcomps ; if ( l_deco_array -> m_data_size != l_data_size ) { return OPJ_FALSE ; } l_nb_elem = p_image -> numcomps * p_image -> numcomps ; l_mct_size = l_nb_elem * ( OPJ_UINT32 ) sizeof ( OPJ_FLOAT32 ) ; p_tcp -> m_mct_decoding_matrix = ( OPJ_FLOAT32 * ) opj_malloc ( l_mct_size ) ; if ( ! p_tcp -> m_mct_decoding_matrix ) { return OPJ_FALSE ; } j2k_mct_read_functions_to_float [ l_deco_array -> m_element_type ] ( l_deco_array -> m_data , p_tcp -> m_mct_decoding_matrix , l_nb_elem ) ; } l_offset_array = l_mcc_record -> m_offset_array ; if ( l_offset_array ) { l_data_size = MCT_ELEMENT_SIZE [ l_offset_array -> m_element_type ] * p_image -> numcomps ; if ( l_offset_array -> m_data_size != l_data_size ) { return OPJ_FALSE ; } l_nb_elem = p_image -> numcomps ; l_offset_size = l_nb_elem * ( OPJ_UINT32 ) sizeof ( OPJ_UINT32 ) ; l_offset_data = ( OPJ_UINT32 * ) opj_malloc ( l_offset_size ) ; if ( ! l_offset_data ) { return OPJ_FALSE ; } j2k_mct_read_functions_to_int32 [ l_offset_array -> m_element_type ] ( l_offset_array -> m_data , l_offset_data , l_nb_elem ) ; l_tccp = p_tcp -> tccps ; l_current_offset_data = l_offset_data ; for ( i = 0 ; i < p_image -> numcomps ; ++ i ) { l_tccp -> m_dc_level_shift = ( OPJ_INT32 ) * ( l_current_offset_data ++ ) ; ++ l_tccp ; } opj_free ( l_offset_data ) ; } return OPJ_TRUE ; }
static void sig_server_connect_copy ( SERVER_CONNECT_REC * * dest , IRC_SERVER_CONNECT_REC * src ) { IRC_SERVER_CONNECT_REC * rec ; g_return_if_fail ( dest != NULL ) ; if ( ! IS_IRC_SERVER_CONNECT ( src ) ) return ; rec = g_new0 ( IRC_SERVER_CONNECT_REC , 1 ) ; rec -> chat_type = IRC_PROTOCOL ; rec -> max_cmds_at_once = src -> max_cmds_at_once ; rec -> cmd_queue_speed = src -> cmd_queue_speed ; rec -> max_query_chans = src -> max_query_chans ; rec -> max_kicks = src -> max_kicks ; rec -> max_modes = src -> max_modes ; rec -> max_msgs = src -> max_msgs ; rec -> max_whois = src -> max_whois ; rec -> usermode = g_strdup ( src -> usermode ) ; rec -> alternate_nick = g_strdup ( src -> alternate_nick ) ; rec -> sasl_mechanism = src -> sasl_mechanism ; rec -> sasl_username = src -> sasl_username ; rec -> sasl_password = src -> sasl_password ; * dest = ( SERVER_CONNECT_REC * ) rec ; }
static void copy_asoundrc ( void ) { char * src = RUN_ASOUNDRC_FILE ; char * dest ; if ( asprintf ( & dest , "%s/.asoundrc" , cfg . homedir ) == - 1 ) errExit ( "asprintf" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , "Error: %s is a symbolic link\n" , dest ) ; exit ( 1 ) ; } pid_t child = fork ( ) ; if ( child < 0 ) errExit ( "fork" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; if ( rv ) fprintf ( stderr , "Warning: cannot transfer .asoundrc in private home directory\n" ) ; else { fs_logger2 ( "clone" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; unlink ( src ) ; }
Notification :: CreateAndShow ( nsIGlobalObject * aGlobal , const nsAString & aTitle , const NotificationOptions & aOptions , const nsAString & aScope , ErrorResult & aRv ) { MOZ_ASSERT ( aGlobal ) ; AutoJSAPI jsapi ; if ( NS_WARN_IF ( ! jsapi . Init ( aGlobal ) ) ) { aRv . Throw ( NS_ERROR_DOM_ABORT_ERR ) ; return nullptr ; } JSContext * cx = jsapi . cx ( ) ; RefPtr < Notification > notification = CreateInternal ( aGlobal , EmptyString ( ) , aTitle , aOptions ) ; JS :: Rooted < JS :: Value > data ( cx , aOptions . mData ) ; notification -> InitFromJSVal ( cx , data , aRv ) ; if ( NS_WARN_IF ( aRv . Failed ( ) ) ) { return nullptr ; } notification -> SetScope ( aScope ) ; auto ref = MakeUnique < NotificationRef > ( notification ) ; if ( NS_WARN_IF ( ! ref -> Initialized ( ) ) ) { aRv . Throw ( NS_ERROR_DOM_ABORT_ERR ) ; return nullptr ; } nsCOMPtr < nsIRunnable > showNotificationTask = new NotificationTask ( Move ( ref ) , NotificationTask :: eShow ) ; nsresult rv = NS_DispatchToMainThread ( showNotificationTask ) ; if ( NS_WARN_IF ( NS_FAILED ( rv ) ) ) { notification -> DispatchTrustedEvent ( NS_LITERAL_STRING ( "error" ) ) ; } return notification . forget ( ) ; }
void WorkerPrivate :: ClearMainEventQueue ( WorkerRanOrNot aRanOrNot ) { AssertIsOnWorkerThread ( ) ; MOZ_ASSERT ( mSyncLoopStack . IsEmpty ( ) ) ; MOZ_ASSERT ( ! mCancelAllPendingRunnables ) ; mCancelAllPendingRunnables = true ; if ( WorkerNeverRan == aRanOrNot ) { for ( uint32_t count = mPreStartRunnables . Length ( ) , index = 0 ; index < count ; index ++ ) { RefPtr < WorkerRunnable > runnable = std :: move ( mPreStartRunnables [ index ] ) ; static_cast < nsIRunnable * > ( runnable . get ( ) ) -> Run ( ) ; } } else { nsIThread * currentThread = NS_GetCurrentThread ( ) ; MOZ_ASSERT ( currentThread ) ; NS_ProcessPendingEvents ( currentThread ) ; ReportUseCounters ( ) ; } MOZ_ASSERT ( mCancelAllPendingRunnables ) ; mCancelAllPendingRunnables = false ; }
generate_palette ( png_colorp palette , png_bytep trans , int bit_depth , png_const_bytep gamma_table , unsigned int * colors ) { switch ( colors [ 0 ] ) { default : fprintf ( stderr , "makepng: --colors=...: invalid count %u\n" , colors [ 0 ] ) ; exit ( 1 ) ; case 1 : set_color ( palette + 0 , trans + 0 , colors [ 1 ] , colors [ 1 ] , colors [ 1 ] , 255 , gamma_table ) ; return 1 ; case 2 : set_color ( palette + 0 , trans + 0 , colors [ 1 ] , colors [ 1 ] , colors [ 1 ] , colors [ 2 ] , gamma_table ) ; return 1 ; case 3 : set_color ( palette + 0 , trans + 0 , colors [ 1 ] , colors [ 2 ] , colors [ 3 ] , 255 , gamma_table ) ; return 1 ; case 4 : set_color ( palette + 0 , trans + 0 , colors [ 1 ] , colors [ 2 ] , colors [ 3 ] , colors [ 4 ] , gamma_table ) ; return 1 ; case 0 : if ( bit_depth == 1 ) { set_color ( palette + 0 , trans + 0 , 255 , 0 , 0 , 0 , gamma_table ) ; set_color ( palette + 1 , trans + 1 , 255 , 255 , 255 , 255 , gamma_table ) ; return 2 ; } else { unsigned int size = 1U < < ( bit_depth / 2 ) ; unsigned int x , y , ip ; for ( x = 0 ; x < size ; ++ x ) for ( y = 0 ; y < size ; ++ y ) { ip = x + ( size * y ) ; #              define interp(pos, c1, c2) ((pos * c1) + ((size-pos) * c2)) #              define xyinterp(x, y, c1, c2, c3, c4) (((size * size / 2) +\  (interp(x, c1, c2) * y + (size-y) * interp(x, c3, c4))) /\  (size*size)) set_color ( palette + ip , trans + ip , xyinterp ( x , y , 0 , 255 , 0 , 255 ) , xyinterp ( x , y , 255 , 0 , 0 , 255 ) , xyinterp ( x , y , 0 , 0 , 255 , 255 ) , xyinterp ( x , y , 0 , 102 , 204 , 255 ) , gamma_table ) ; } return ip + 1 ; } } }
sctp_find_ifa_in_ep ( struct sctp_inpcb * inp , struct sockaddr * addr , int holds_lock ) { struct sctp_laddr * laddr ; if ( holds_lock == 0 ) { SCTP_INP_RLOCK ( inp ) ; } LIST_FOREACH ( laddr , & inp -> sctp_addr_list , sctp_nxt_addr ) { if ( laddr -> ifa == NULL ) continue ; if ( addr -> sa_family != laddr -> ifa -> address . sa . sa_family ) continue ; #ifdef INET if ( addr -> sa_family == AF_INET ) { if ( ( ( struct sockaddr_in * ) addr ) -> sin_addr . s_addr == laddr -> ifa -> address . sin . sin_addr . s_addr ) { break ; } } #endif #ifdef INET6 if ( addr -> sa_family == AF_INET6 ) { if ( SCTP6_ARE_ADDR_EQUAL ( ( struct sockaddr_in6 * ) addr , & laddr -> ifa -> address . sin6 ) ) { break ; } } #endif #if defined(__Userspace__) if ( addr -> sa_family == AF_CONN ) { if ( ( ( struct sockaddr_conn * ) addr ) -> sconn_addr == laddr -> ifa -> address . sconn . sconn_addr ) { break ; } } #endif } if ( holds_lock == 0 ) { SCTP_INP_RUNLOCK ( inp ) ; } return ( laddr -> ifa ) ; }
static int perf_swevent_init ( struct perf_event * event ) { int event_id = event -> attr . config ; if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ; if ( has_branch_stack ( event ) ) return - EOPNOTSUPP ; switch ( event_id ) { case PERF_COUNT_SW_CPU_CLOCK : case PERF_COUNT_SW_TASK_CLOCK : return - ENOENT ; default : break ; } if ( event_id >= PERF_COUNT_SW_MAX ) return - ENOENT ; if ( ! event -> parent ) { int err ; err = swevent_hlist_get ( event ) ; if ( err ) return err ; static_key_slow_inc ( & perf_swevent_enabled [ event_id ] ) ; event -> destroy = sw_perf_event_destroy ; } return 0 ; }
R_API bool r_anal_vtable_begin ( RAnal * anal , RVTableContext * context ) { context -> anal = anal ; context -> abi = anal -> cxxabi ; context -> word_size = ( ut8 ) ( anal -> config -> bits / 8 ) ; const bool is_arm = anal -> cur -> arch && r_str_startswith ( anal -> cur -> arch , "arm" ) ; if ( is_arm && context -> word_size < 4 ) { context -> word_size = 4 ; } const bool be = anal -> config -> big_endian ; switch ( context -> word_size ) { case 1 : context -> read_addr = be ? vtable_read_addr_be8 : vtable_read_addr_le8 ; break ; case 2 : context -> read_addr = be ? vtable_read_addr_be16 : vtable_read_addr_le16 ; break ; case 4 : context -> read_addr = be ? vtable_read_addr_be32 : vtable_read_addr_le32 ; break ; case 8 : context -> read_addr = be ? vtable_read_addr_be64 : vtable_read_addr_le64 ; break ; default : return false ; } return true ; }
int smb_check_perm_dacl ( struct ksmbd_conn * conn , struct path * path , __le32 * pdaccess , int uid ) { struct user_namespace * user_ns = mnt_user_ns ( path -> mnt ) ; struct smb_ntsd * pntsd = NULL ; struct smb_acl * pdacl ; struct posix_acl * posix_acls ; int rc = 0 , acl_size ; struct smb_sid sid ; int granted = le32_to_cpu ( * pdaccess & ~ FILE_MAXIMAL_ACCESS_LE ) ; struct smb_ace * ace ; int i , found = 0 ; unsigned int access_bits = 0 ; struct smb_ace * others_ace = NULL ; struct posix_acl_entry * pa_entry ; unsigned int sid_type = SIDOWNER ; char * end_of_acl ; ksmbd_debug ( SMB , "check permission using windows acl\n" ) ; acl_size = ksmbd_vfs_get_sd_xattr ( conn , user_ns , path -> dentry , & pntsd ) ; if ( acl_size <= 0 || ! pntsd || ! pntsd -> dacloffset ) { kfree ( pntsd ) ; return 0 ; } pdacl = ( struct smb_acl * ) ( ( char * ) pntsd + le32_to_cpu ( pntsd -> dacloffset ) ) ; end_of_acl = ( ( char * ) pntsd ) + acl_size ; if ( end_of_acl <= ( char * ) pdacl ) { kfree ( pntsd ) ; return 0 ; } if ( end_of_acl < ( char * ) pdacl + le16_to_cpu ( pdacl -> size ) || le16_to_cpu ( pdacl -> size ) < sizeof ( struct smb_acl ) ) { kfree ( pntsd ) ; return 0 ; } if ( ! pdacl -> num_aces ) { if ( ! ( le16_to_cpu ( pdacl -> size ) - sizeof ( struct smb_acl ) ) && * pdaccess & ~ ( FILE_READ_CONTROL_LE | FILE_WRITE_DAC_LE ) ) { rc = - EACCES ; goto err_out ; } kfree ( pntsd ) ; return 0 ; } if ( * pdaccess & FILE_MAXIMAL_ACCESS_LE ) { granted = READ_CONTROL | WRITE_DAC | FILE_READ_ATTRIBUTES | DELETE ; ace = ( struct smb_ace * ) ( ( char * ) pdacl + sizeof ( struct smb_acl ) ) ; for ( i = 0 ; i < le32_to_cpu ( pdacl -> num_aces ) ; i ++ ) { granted |= le32_to_cpu ( ace -> access_req ) ; ace = ( struct smb_ace * ) ( ( char * ) ace + le16_to_cpu ( ace -> size ) ) ; if ( end_of_acl < ( char * ) ace ) goto err_out ; } if ( ! pdacl -> num_aces ) granted = GENERIC_ALL_FLAGS ; } if ( ! uid ) sid_type = SIDUNIX_USER ; id_to_sid ( uid , sid_type , & sid ) ; ace = ( struct smb_ace * ) ( ( char * ) pdacl + sizeof ( struct smb_acl ) ) ; for ( i = 0 ; i < le32_to_cpu ( pdacl -> num_aces ) ; i ++ ) { if ( ! compare_sids ( & sid , & ace -> sid ) || ! compare_sids ( & sid_unix_NFS_mode , & ace -> sid ) ) { found = 1 ; break ; } if ( ! compare_sids ( & sid_everyone , & ace -> sid ) ) others_ace = ace ; ace = ( struct smb_ace * ) ( ( char * ) ace + le16_to_cpu ( ace -> size ) ) ; if ( end_of_acl < ( char * ) ace ) goto err_out ; } if ( * pdaccess & FILE_MAXIMAL_ACCESS_LE && found ) { granted = READ_CONTROL | WRITE_DAC | FILE_READ_ATTRIBUTES | DELETE ; granted |= le32_to_cpu ( ace -> access_req ) ; if ( ! pdacl -> num_aces ) granted = GENERIC_ALL_FLAGS ; } if ( IS_ENABLED ( CONFIG_FS_POSIX_ACL ) ) { posix_acls = get_acl ( d_inode ( path -> dentry ) , ACL_TYPE_ACCESS ) ; if ( posix_acls && ! found ) { unsigned int id = - 1 ; pa_entry = posix_acls -> a_entries ; for ( i = 0 ; i < posix_acls -> a_count ; i ++ , pa_entry ++ ) { if ( pa_entry -> e_tag == ACL_USER ) id = posix_acl_uid_translate ( user_ns , pa_entry ) ; else if ( pa_entry -> e_tag == ACL_GROUP ) id = posix_acl_gid_translate ( user_ns , pa_entry ) ; else continue ; if ( id == uid ) { mode_to_access_flags ( pa_entry -> e_perm , 0777 , & access_bits ) ; if ( ! access_bits ) access_bits = SET_MINIMUM_RIGHTS ; posix_acl_release ( posix_acls ) ; goto check_access_bits ; } } } if ( posix_acls ) posix_acl_release ( posix_acls ) ; } if ( ! found ) { if ( others_ace ) { ace = others_ace ; } else { ksmbd_debug ( SMB , "Can't find corresponding sid\n" ) ; rc = - EACCES ; goto err_out ; } } switch ( ace -> type ) { case ACCESS_ALLOWED_ACE_TYPE : access_bits = le32_to_cpu ( ace -> access_req ) ; break ; case ACCESS_DENIED_ACE_TYPE : case ACCESS_DENIED_CALLBACK_ACE_TYPE : access_bits = le32_to_cpu ( ~ ace -> access_req ) ; break ; } check_access_bits : if ( granted & ~ ( access_bits | FILE_READ_ATTRIBUTES | READ_CONTROL | WRITE_DAC | DELETE ) ) { ksmbd_debug ( SMB , "Access denied with winACL, granted : %x, access_req : %x\n" , granted , le32_to_cpu ( ace -> access_req ) ) ; rc = - EACCES ; goto err_out ; } * pdaccess = cpu_to_le32 ( granted ) ; err_out : kfree ( pntsd ) ; return rc ; }
unique_ptr < IOBuf > IOBuf :: takeOwnership ( void * buf , std :: size_t capacity , std :: size_t offset , std :: size_t length , FreeFunction freeFn , void * userData , bool freeOnError , TakeOwnershipOption option ) { DCHECK ( ! userData || ( userData && freeFn ) || ( userData && ! freeFn && ( option == TakeOwnershipOption :: STORE_SIZE ) ) ) ; HeapFullStorage * storage = nullptr ; auto rollback = makeGuard ( [ & ] { if ( storage ) { free ( storage ) ; } takeOwnershipError ( freeOnError , buf , freeFn , userData ) ; } ) ; size_t requiredStorage = sizeof ( HeapFullStorage ) ; size_t mallocSize = goodMallocSize ( requiredStorage ) ; storage = static_cast < HeapFullStorage * > ( checkedMalloc ( mallocSize ) ) ; new ( & storage -> hs . prefix ) HeapPrefix ( kIOBufInUse | kSharedInfoInUse , mallocSize ) ; new ( & storage -> shared ) SharedInfo ( freeFn , userData , true ) ; auto result = unique_ptr < IOBuf > ( new ( & storage -> hs . buf ) IOBuf ( InternalConstructor ( ) , packFlagsAndSharedInfo ( 0 , & storage -> shared ) , static_cast < uint8_t * > ( buf ) , capacity , static_cast < uint8_t * > ( buf ) + offset , length ) ) ; rollback . dismiss ( ) ; if ( io_buf_alloc_cb ) { io_buf_alloc_cb ( storage , mallocSize ) ; if ( userData && ! freeFn && ( option == TakeOwnershipOption :: STORE_SIZE ) ) { io_buf_alloc_cb ( buf , capacity ) ; } } return result ; }
R_API int r_socket_read_block ( RSocket * s , ut8 * buf , int len ) { int ret = 0 ; for ( ret = 0 ; ret < len ; ) { int r = r_socket_read ( s , buf + ret , len - ret ) ; if ( r == - 1 ) { return - 1 ; } if ( r < 1 ) { break ; } ret += r ; } return ret ; }
sctp_fs_audit ( struct sctp_association * asoc ) { struct sctp_tmit_chunk * chk ; int inflight = 0 , resend = 0 , inbetween = 0 , acked = 0 , above = 0 ; int ret ; #ifndef INVARIANTS int entry_flight , entry_cnt ; #endif ret = 0 ; #ifndef INVARIANTS entry_flight = asoc -> total_flight ; entry_cnt = asoc -> total_flight_count ; #endif if ( asoc -> pr_sctp_cnt >= asoc -> sent_queue_cnt ) return ( 0 ) ; TAILQ_FOREACH ( chk , & asoc -> sent_queue , sctp_next ) { if ( chk -> sent < SCTP_DATAGRAM_RESEND ) { SCTP_PRINTF ( "Chk TSN: %u size: %d inflight cnt: %d\n" , chk -> rec . data . tsn , chk -> send_size , chk -> snd_count ) ; inflight ++ ; } else if ( chk -> sent == SCTP_DATAGRAM_RESEND ) { resend ++ ; } else if ( chk -> sent < SCTP_DATAGRAM_ACKED ) { inbetween ++ ; } else if ( chk -> sent > SCTP_DATAGRAM_ACKED ) { above ++ ; } else { acked ++ ; } } if ( ( inflight > 0 ) || ( inbetween > 0 ) ) { #ifdef INVARIANTS panic ( "Flight size-express incorrect? \n" ) ; #else SCTP_PRINTF ( "asoc->total_flight: %d cnt: %d\n" , entry_flight , entry_cnt ) ; SCTP_PRINTF ( "Flight size-express incorrect F: %d I: %d R: %d Ab: %d ACK: %d\n" , inflight , inbetween , resend , above , acked ) ; ret = 1 ; #endif } return ( ret ) ; }
void JNICALL ProvideCameraFrame ( JNIEnv * env , jobject , jbyteArray javaCameraFrame , jint length , jint rotation , jlong timeStamp , jlong context ) { webrtc :: videocapturemodule :: VideoCaptureAndroid * captureModule = reinterpret_cast < webrtc :: videocapturemodule :: VideoCaptureAndroid * > ( context ) ; jbyte * cameraFrame = env -> GetByteArrayElements ( javaCameraFrame , NULL ) ; captureModule -> OnIncomingFrame ( reinterpret_cast < uint8_t * > ( cameraFrame ) , length , rotation , 0 ) ; env -> ReleaseByteArrayElements ( javaCameraFrame , cameraFrame , JNI_ABORT ) ; }
static int on_header_value ( multipart_parser * parser , const char * at , size_t length ) { multipart_parser_data_t * data = NULL ; ogs_assert ( parser ) ; data = multipart_parser_get_data ( parser ) ; ogs_assert ( data ) ; if ( at && length ) { SWITCH ( data -> header_field ) CASE ( OGS_SBI_CONTENT_TYPE ) if ( data -> part [ data -> num_of_part ] . content_type ) ogs_free ( data -> part [ data -> num_of_part ] . content_type ) ; data -> part [ data -> num_of_part ] . content_type = ogs_strndup ( at , length ) ; ogs_assert ( data -> part [ data -> num_of_part ] . content_type ) ; break ; CASE ( OGS_SBI_CONTENT_ID ) if ( data -> part [ data -> num_of_part ] . content_id ) ogs_free ( data -> part [ data -> num_of_part ] . content_id ) ; data -> part [ data -> num_of_part ] . content_id = ogs_strndup ( at , length ) ; ogs_assert ( data -> part [ data -> num_of_part ] . content_id ) ; break ; DEFAULT ogs_error ( "Unknown header field [%s]" , data -> header_field ) ; END } return 0 ; }
reg . prepare = [ ] ( TfLiteContext * context , TfLiteNode * node ) { - const TfLiteTensor * input1 = GetInput ( context , node , 0 ) ; - const TfLiteTensor * input2 = GetInput ( context , node , 1 ) ; - TfLiteTensor * output = GetOutput ( context , node , 0 ) ; + const TfLiteTensor * input1 ; + TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , 0 , & input1 ) ) ; + const TfLiteTensor * input2 ; + TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , 1 , & input2 ) ) ; + TfLiteTensor * output ; + TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , 0 , & output ) ) ; TF_LITE_ENSURE_EQ ( context , input1 -> dims -> size , input2 -> dims -> size ) ; for ( int i = 0 ; i < input1 -> dims -> size ; ++ i ) { TF_LITE_ENSURE_EQ ( context , input1 -> dims -> data [ i ] , input2 -> dims -> data [ i ] ) ; } TF_LITE_ENSURE_STATUS ( context -> ResizeTensor ( context , output , TfLiteIntArrayCopy ( input1 -> dims ) ) ) ; return kTfLiteOk ; } ;
header_put_be_short ( SF_PRIVATE * psf , int x ) { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 2 ) { psf -> header [ psf -> headindex ++ ] = ( x > > 8 ) ; psf -> header [ psf -> headindex ++ ] = x ; } ; }
txLoadedDocumentsHash :: init ( txXPathNode * aSourceDocument ) { mSourceDocument = aSourceDocument ; nsAutoString baseURI ; nsresult rv = txXPathNodeUtils :: getBaseURI ( * mSourceDocument , baseURI ) ; if ( NS_WARN_IF ( NS_FAILED ( rv ) ) ) { return rv ; } PutEntry ( baseURI ) -> mDocument = mSourceDocument ; return NS_OK ; }
void * PageAllocator :: AllocatePages ( void * address , size_t size , size_t alignment , PageAllocator :: Permission access ) { return base :: OS :: Allocate ( address , size , alignment , static_cast < base :: OS :: MemoryPermission > ( access ) ) ; }
nsMIMEInfoWin :: LoadUriInternal ( nsIURI * aURL ) { nsresult rv = NS_OK ; if ( aURL ) { nsAutoCString urlSpec ; aURL -> GetAsciiSpec ( urlSpec ) ; nsAutoString utf16Spec ; nsCOMPtr < nsITextToSubURI > textToSubURI = do_GetService ( NS_ITEXTTOSUBURI_CONTRACTID , & rv ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( NS_FAILED ( textToSubURI -> UnEscapeNonAsciiURI ( NS_LITERAL_CSTRING ( "UTF-8" ) , urlSpec , utf16Spec ) ) ) { CopyASCIItoUTF16 ( urlSpec , utf16Spec ) ; } static const wchar_t cmdVerb [ ] = L"open" ; SHELLEXECUTEINFOW sinfo ; memset ( & sinfo , 0 , sizeof ( sinfo ) ) ; sinfo . cbSize = sizeof ( sinfo ) ; sinfo . fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_FLAG_NO_UI ; sinfo . hwnd = nullptr ; sinfo . lpVerb = ( LPWSTR ) & cmdVerb ; sinfo . nShow = SW_SHOWNORMAL ; LPITEMIDLIST pidl = nullptr ; SFGAOF sfgao ; if ( SUCCEEDED ( SHParseDisplayName ( utf16Spec . get ( ) , nullptr , & pidl , 0 , & sfgao ) ) ) { sinfo . lpIDList = pidl ; sinfo . fMask |= SEE_MASK_INVOKEIDLIST ; } else { rv = NS_ERROR_FAILURE ; } if ( NS_SUCCEEDED ( rv ) ) { BOOL result = ShellExecuteExW ( & sinfo ) ; if ( ! result || ( ( LONG_PTR ) sinfo . hInstApp ) < 32 ) rv = NS_ERROR_FAILURE ; } if ( pidl ) CoTaskMemFree ( pidl ) ; } return rv ; }
do_bid_note ( struct magic_set * ms , unsigned char * nbuf , uint32_t type , int swap __attribute__ ( ( __unused__ ) ) , uint32_t namesz , uint32_t descsz , size_t noff , size_t doff , int * flags ) { if ( namesz == 4 && strcmp ( ( char * ) & nbuf [ noff ] , "GNU" ) == 0 && type == NT_GNU_BUILD_ID && ( descsz == 16 || descsz == 20 ) ) { uint8_t desc [ 20 ] ; uint32_t i ; * flags |= FLAGS_DID_BUILD_ID ; if ( file_printf ( ms , ", BuildID[%s]=" , descsz == 16 ? "md5/uuid" : "sha1" ) == - 1 ) return 1 ; ( void ) memcpy ( desc , & nbuf [ doff ] , descsz ) ; for ( i = 0 ; i < descsz ; i ++ ) if ( file_printf ( ms , "%02x" , desc [ i ] ) == - 1 ) return 1 ; return 1 ; } return 0 ; }
static bool ndp_msg_check_valid ( struct ndp_msg * msg ) { size_t len = ndp_msg_payload_len ( msg ) ; enum ndp_msg_type msg_type = ndp_msg_type ( msg ) ; if ( len < ndp_msg_type_info ( msg_type ) -> raw_struct_size ) return false ; return true ; }
static int cqspi_setup_flash ( struct cqspi_st * cqspi , struct device_node * np ) { struct platform_device * pdev = cqspi -> pdev ; struct device * dev = & pdev -> dev ; struct cqspi_flash_pdata * f_pdata ; struct spi_nor * nor ; struct mtd_info * mtd ; unsigned int cs ; int i , ret ; for_each_available_child_of_node ( dev -> of_node , np ) { if ( of_property_read_u32 ( np , "reg" , & cs ) ) { dev_err ( dev , "Couldn't determine chip select.\n" ) ; goto err ; } if ( cs > CQSPI_MAX_CHIPSELECT ) { dev_err ( dev , "Chip select %d out of range.\n" , cs ) ; goto err ; } f_pdata = & cqspi -> f_pdata [ cs ] ; f_pdata -> cqspi = cqspi ; f_pdata -> cs = cs ; ret = cqspi_of_get_flash_pdata ( pdev , f_pdata , np ) ; if ( ret ) goto err ; nor = & f_pdata -> nor ; mtd = & nor -> mtd ; mtd -> priv = nor ; nor -> dev = dev ; spi_nor_set_flash_node ( nor , np ) ; nor -> priv = f_pdata ; nor -> read_reg = cqspi_read_reg ; nor -> write_reg = cqspi_write_reg ; nor -> read = cqspi_read ; nor -> write = cqspi_write ; nor -> erase = cqspi_erase ; nor -> prepare = cqspi_prep ; nor -> unprepare = cqspi_unprep ; mtd -> name = devm_kasprintf ( dev , GFP_KERNEL , "%s.%d" , dev_name ( dev ) , cs ) ; if ( ! mtd -> name ) { ret = - ENOMEM ; goto err ; } ret = spi_nor_scan ( nor , NULL , SPI_NOR_QUAD ) ; if ( ret ) goto err ; ret = mtd_device_register ( mtd , NULL , 0 ) ; if ( ret ) goto err ; f_pdata -> registered = true ; } return 0 ; err : for ( i = 0 ; i < CQSPI_MAX_CHIPSELECT ; i ++ ) if ( cqspi -> f_pdata [ i ] . registered ) mtd_device_unregister ( & cqspi -> f_pdata [ i ] . nor . mtd ) ; return ret ; }
TF_BUILTIN ( AtomicsLoad , SharedArrayBufferBuiltinsAssembler ) { Node * array = Parameter ( Descriptor :: kArray ) ; Node * index = Parameter ( Descriptor :: kIndex ) ; Node * context = Parameter ( Descriptor :: kContext ) ; Node * instance_type ; Node * backing_store ; ValidateSharedTypedArray ( array , context , & instance_type , & backing_store ) ; Node * index_integer ; Node * index_word32 = ConvertTaggedAtomicIndexToWord32 ( index , context , & index_integer ) ; ValidateAtomicIndex ( array , index_word32 , context ) ; Node * index_word = ChangeUint32ToWord ( index_word32 ) ; Label i8 ( this ) , u8 ( this ) , i16 ( this ) , u16 ( this ) , i32 ( this ) , u32 ( this ) , other ( this ) ; int32_t case_values [ ] = { FIXED_INT8_ARRAY_TYPE , FIXED_UINT8_ARRAY_TYPE , FIXED_INT16_ARRAY_TYPE , FIXED_UINT16_ARRAY_TYPE , FIXED_INT32_ARRAY_TYPE , FIXED_UINT32_ARRAY_TYPE , } ; Label * case_labels [ ] = { & i8 , & u8 , & i16 , & u16 , & i32 , & u32 , } ; Switch ( instance_type , & other , case_values , case_labels , arraysize ( case_labels ) ) ; BIND ( & i8 ) ; Return ( SmiFromInt32 ( AtomicLoad ( MachineType :: Int8 ( ) , backing_store , index_word ) ) ) ; BIND ( & u8 ) ; Return ( SmiFromInt32 ( AtomicLoad ( MachineType :: Uint8 ( ) , backing_store , index_word ) ) ) ; BIND ( & i16 ) ; Return ( SmiFromInt32 ( AtomicLoad ( MachineType :: Int16 ( ) , backing_store , WordShl ( index_word , 1 ) ) ) ) ; BIND ( & u16 ) ; Return ( SmiFromInt32 ( AtomicLoad ( MachineType :: Uint16 ( ) , backing_store , WordShl ( index_word , 1 ) ) ) ) ; BIND ( & i32 ) ; Return ( ChangeInt32ToTagged ( AtomicLoad ( MachineType :: Int32 ( ) , backing_store , WordShl ( index_word , 2 ) ) ) ) ; BIND ( & u32 ) ; Return ( ChangeUint32ToTagged ( AtomicLoad ( MachineType :: Uint32 ( ) , backing_store , WordShl ( index_word , 2 ) ) ) ) ; BIND ( & other ) ; Unreachable ( ) ; }
static PyObject * __pyx_pw_17clickhouse_driver_7columns_12stringcolumn_11FixedString_1__init__ ( PyObject * __pyx_self , PyObject * __pyx_args , PyObject * __pyx_kwds ) { PyObject * __pyx_v_self = 0 ; PyObject * __pyx_v_length = 0 ; PyObject * __pyx_v_kwargs = 0 ; PyObject * __pyx_r = 0 ; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext ( "__init__ (wrapper)" , 0 ) ; __pyx_v_kwargs = PyDict_New ( ) ; if ( unlikely ( ! __pyx_v_kwargs ) ) return NULL ; __Pyx_GOTREF ( __pyx_v_kwargs ) ; { static PyObject * * __pyx_pyargnames [ ] = { & __pyx_n_s_self , & __pyx_n_s_length , 0 } ; PyObject * values [ 2 ] = { 0 , 0 } ; if ( unlikely ( __pyx_kwds ) ) { Py_ssize_t kw_args ; const Py_ssize_t pos_args = PyTuple_GET_SIZE ( __pyx_args ) ; switch ( pos_args ) { case 2 : values [ 1 ] = PyTuple_GET_ITEM ( __pyx_args , 1 ) ; CYTHON_FALLTHROUGH ; case 1 : values [ 0 ] = PyTuple_GET_ITEM ( __pyx_args , 0 ) ; CYTHON_FALLTHROUGH ; case 0 : break ; default : goto __pyx_L5_argtuple_error ; } kw_args = PyDict_Size ( __pyx_kwds ) ; switch ( pos_args ) { case 0 : if ( likely ( ( values [ 0 ] = __Pyx_PyDict_GetItemStr ( __pyx_kwds , __pyx_n_s_self ) ) != 0 ) ) kw_args -- ; else goto __pyx_L5_argtuple_error ; CYTHON_FALLTHROUGH ; case 1 : if ( likely ( ( values [ 1 ] = __Pyx_PyDict_GetItemStr ( __pyx_kwds , __pyx_n_s_length ) ) != 0 ) ) kw_args -- ; else { __Pyx_RaiseArgtupleInvalid ( "__init__" , 1 , 2 , 2 , 1 ) ; __PYX_ERR ( 0 , 47 , __pyx_L3_error ) } } if ( unlikely ( kw_args > 0 ) ) { if ( unlikely ( __Pyx_ParseOptionalKeywords ( __pyx_kwds , __pyx_pyargnames , __pyx_v_kwargs , values , pos_args , "__init__" ) < 0 ) ) __PYX_ERR ( 0 , 47 , __pyx_L3_error ) } } else if ( PyTuple_GET_SIZE ( __pyx_args ) != 2 ) { goto __pyx_L5_argtuple_error ; } else { values [ 0 ] = PyTuple_GET_ITEM ( __pyx_args , 0 ) ; values [ 1 ] = PyTuple_GET_ITEM ( __pyx_args , 1 ) ; } __pyx_v_self = values [ 0 ] ; __pyx_v_length = values [ 1 ] ; } goto __pyx_L4_argument_unpacking_done ; __pyx_L5_argtuple_error : ; __Pyx_RaiseArgtupleInvalid ( "__init__" , 1 , 2 , 2 , PyTuple_GET_SIZE ( __pyx_args ) ) ; __PYX_ERR ( 0 , 47 , __pyx_L3_error ) __pyx_L3_error : ; __Pyx_DECREF ( __pyx_v_kwargs ) ; __pyx_v_kwargs = 0 ; __Pyx_AddTraceback ( "clickhouse_driver.columns.stringcolumn.FixedString.__init__" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __Pyx_RefNannyFinishContext ( ) ; return NULL ; __pyx_L4_argument_unpacking_done : ; __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_11FixedString___init__ ( __pyx_self , __pyx_v_self , __pyx_v_length , __pyx_v_kwargs ) ; __Pyx_XDECREF ( __pyx_v_kwargs ) ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
void l2c_rcv_acl_data ( BT_HDR * p_msg ) { UINT8 * p = ( UINT8 * ) ( p_msg + 1 ) + p_msg -> offset ; UINT16 handle , hci_len ; UINT8 pkt_type ; tL2C_LCB * p_lcb ; tL2C_CCB * p_ccb = NULL ; UINT16 l2cap_len , rcv_cid , psm ; UINT16 credit ; STREAM_TO_UINT16 ( handle , p ) ; pkt_type = HCID_GET_EVENT ( handle ) ; handle = HCID_GET_HANDLE ( handle ) ; if ( pkt_type != L2CAP_PKT_CONTINUE ) { if ( ( p_lcb = l2cu_find_lcb_by_handle ( handle ) ) == NULL ) { UINT8 cmd_code ; STREAM_TO_UINT16 ( hci_len , p ) ; STREAM_TO_UINT16 ( l2cap_len , p ) ; STREAM_TO_UINT16 ( rcv_cid , p ) ; STREAM_TO_UINT8 ( cmd_code , p ) ; if ( ( p_msg -> layer_specific == 0 ) && ( rcv_cid == L2CAP_SIGNALLING_CID ) && ( cmd_code == L2CAP_CMD_INFO_REQ || cmd_code == L2CAP_CMD_CONN_REQ ) ) { L2CAP_TRACE_WARNING ( "L2CAP - holding ACL for unknown handle:%d ls:%d" "  cid:%d opcode:%d cur count:%d" , handle , p_msg -> layer_specific , rcv_cid , cmd_code , list_length ( l2cb . rcv_pending_q ) ) ; p_msg -> layer_specific = 2 ; list_append ( l2cb . rcv_pending_q , p_msg ) ; if ( list_length ( l2cb . rcv_pending_q ) == 1 ) { alarm_set_on_queue ( l2cb . receive_hold_timer , BT_1SEC_TIMEOUT_MS , l2c_receive_hold_timer_timeout , NULL , btu_general_alarm_queue ) ; } return ; } else { L2CAP_TRACE_ERROR ( "L2CAP - rcvd ACL for unknown handle:%d ls:%d cid:%d" " opcode:%d cur count:%d" , handle , p_msg -> layer_specific , rcv_cid , cmd_code , list_length ( l2cb . rcv_pending_q ) ) ; } osi_free ( p_msg ) ; return ; } } else { L2CAP_TRACE_WARNING ( "L2CAP - expected pkt start or complete, got: %d" , pkt_type ) ; osi_free ( p_msg ) ; return ; } STREAM_TO_UINT16 ( hci_len , p ) ; p_msg -> offset += 4 ; STREAM_TO_UINT16 ( l2cap_len , p ) ; STREAM_TO_UINT16 ( rcv_cid , p ) ; #if BLE_INCLUDED == TRUE if ( p_lcb && p_lcb -> transport == BT_TRANSPORT_LE && p_lcb -> link_state != LST_DISCONNECTING ) l2cble_notify_le_connection ( p_lcb -> remote_bd_addr ) ; #endif if ( rcv_cid >= L2CAP_BASE_APPL_CID ) { if ( ( p_ccb = l2cu_find_ccb_by_cid ( p_lcb , rcv_cid ) ) == NULL ) { L2CAP_TRACE_WARNING ( "L2CAP - unknown CID: 0x%04x" , rcv_cid ) ; osi_free ( p_msg ) ; return ; } } if ( hci_len >= L2CAP_PKT_OVERHEAD ) { p_msg -> len = hci_len - L2CAP_PKT_OVERHEAD ; p_msg -> offset += L2CAP_PKT_OVERHEAD ; } else { L2CAP_TRACE_WARNING ( "L2CAP - got incorrect hci header" ) ; osi_free ( p_msg ) ; return ; } if ( l2cap_len != p_msg -> len ) { L2CAP_TRACE_WARNING ( "L2CAP - bad length in pkt. Exp: %d  Act: %d" , l2cap_len , p_msg -> len ) ; osi_free ( p_msg ) ; return ; } if ( rcv_cid == L2CAP_SIGNALLING_CID ) { process_l2cap_cmd ( p_lcb , p , l2cap_len ) ; osi_free ( p_msg ) ; } else if ( rcv_cid == L2CAP_CONNECTIONLESS_CID ) { STREAM_TO_UINT16 ( psm , p ) ; L2CAP_TRACE_DEBUG ( "GOT CONNECTIONLESS DATA PSM:%d" , psm ) ; #if (L2CAP_UCD_INCLUDED == TRUE) if ( l2c_ucd_check_rx_pkts ( p_lcb , p_msg ) ) { } else #endif osi_free ( p_msg ) ; } #if (BLE_INCLUDED == TRUE) else if ( rcv_cid == L2CAP_BLE_SIGNALLING_CID ) { l2cble_process_sig_cmd ( p_lcb , p , l2cap_len ) ; osi_free ( p_msg ) ; } #endif #if (L2CAP_NUM_FIXED_CHNLS > 0) else if ( ( rcv_cid >= L2CAP_FIRST_FIXED_CHNL ) && ( rcv_cid <= L2CAP_LAST_FIXED_CHNL ) && ( l2cb . fixed_reg [ rcv_cid - L2CAP_FIRST_FIXED_CHNL ] . pL2CA_FixedData_Cb != NULL ) ) { if ( p_lcb && ( p_lcb -> link_state != LST_DISCONNECTING ) && l2cu_initialize_fixed_ccb ( p_lcb , rcv_cid , & l2cb . fixed_reg [ rcv_cid - L2CAP_FIRST_FIXED_CHNL ] . fixed_chnl_opts ) ) { p_ccb = p_lcb -> p_fixed_ccbs [ rcv_cid - L2CAP_FIRST_FIXED_CHNL ] ; if ( p_ccb -> peer_cfg . fcr . mode != L2CAP_FCR_BASIC_MODE ) l2c_fcr_proc_pdu ( p_ccb , p_msg ) ; else ( * l2cb . fixed_reg [ rcv_cid - L2CAP_FIRST_FIXED_CHNL ] . pL2CA_FixedData_Cb ) ( rcv_cid , p_lcb -> remote_bd_addr , p_msg ) ; } else osi_free ( p_msg ) ; } #endif else { if ( p_ccb == NULL ) osi_free ( p_msg ) ; else { if ( p_lcb -> transport == BT_TRANSPORT_LE ) { l2c_lcc_proc_pdu ( p_ccb , p_msg ) ; credit = L2CAP_LE_DEFAULT_CREDIT ; l2c_csm_execute ( p_ccb , L2CEVT_L2CA_SEND_FLOW_CONTROL_CREDIT , & credit ) ; } else { if ( p_ccb -> peer_cfg . fcr . mode == L2CAP_FCR_BASIC_MODE ) l2c_csm_execute ( p_ccb , L2CEVT_L2CAP_DATA , p_msg ) ; else { if ( ( p_ccb -> chnl_state == CST_OPEN ) || ( p_ccb -> chnl_state == CST_CONFIG ) ) l2c_fcr_proc_pdu ( p_ccb , p_msg ) ; else osi_free ( p_msg ) ; } } } } }
static int store_asoundrc ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_ASOUNDRC_FILE ; FILE * fp = fopen ( dest , "w" ) ; if ( fp ) { fprintf ( fp , "\n" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0644 ) ; fclose ( fp ) ; } if ( asprintf ( & src , "%s/.asoundrc" , cfg . homedir ) == - 1 ) errExit ( "asprintf" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { char * rp = realpath ( src , NULL ) ; if ( ! rp ) { fprintf ( stderr , "Error: Cannot access %s\n" , src ) ; exit ( 1 ) ; } if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != 0 ) { fprintf ( stderr , "Error: .asoundrc is a symbolic link pointing to a file outside home directory\n" ) ; exit ( 1 ) ; } free ( rp ) ; } pid_t child = fork ( ) ; if ( child < 0 ) errExit ( "fork" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ; if ( rv ) fprintf ( stderr , "Warning: cannot transfer .asoundrc in private home directory\n" ) ; else { fs_logger2 ( "clone" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; return 1 ; } return 0 ; }
PropertyAccessInfo PropertyAccessInfo :: DataField ( PropertyConstness constness , MapHandles const & receiver_maps , FieldIndex field_index , MachineRepresentation field_representation , Type field_type , MaybeHandle < Map > field_map , MaybeHandle < JSObject > holder , MaybeHandle < Map > transition_map ) { Kind kind = constness == PropertyConstness :: kConst ? kDataConstantField : kDataField ; return PropertyAccessInfo ( kind , holder , transition_map , field_index , field_representation , field_type , field_map , receiver_maps ) ; }
already_AddRefed < gfxImageSurface > gfxQuartzSurface :: GetAsImageSurface ( ) { cairo_surface_t * surface = cairo_quartz_surface_get_image ( mSurface ) ; if ( ! surface ) return nullptr ; nsRefPtr < gfxASurface > img = Wrap ( surface ) ; gfxImageSurface * imgSurface = static_cast < gfxImageSurface * > ( img . forget ( ) . get ( ) ) ; imgSurface -> Release ( ) ; return imgSurface ; }
CopyDataSourceSurface ( DataSourceSurface * aSource , DataSourceSurface * aDest ) { MOZ_ASSERT ( aSource -> GetSize ( ) == aDest -> GetSize ( ) ) ; MOZ_ASSERT ( aSource -> GetFormat ( ) == SurfaceFormat :: R8G8B8A8 || aSource -> GetFormat ( ) == SurfaceFormat :: R8G8B8X8 || aSource -> GetFormat ( ) == SurfaceFormat :: B8G8R8A8 || aSource -> GetFormat ( ) == SurfaceFormat :: B8G8R8X8 ) ; MOZ_ASSERT ( aDest -> GetFormat ( ) == SurfaceFormat :: R8G8B8A8 || aDest -> GetFormat ( ) == SurfaceFormat :: R8G8B8X8 || aDest -> GetFormat ( ) == SurfaceFormat :: B8G8R8A8 || aDest -> GetFormat ( ) == SurfaceFormat :: B8G8R8X8 || aDest -> GetFormat ( ) == SurfaceFormat :: R5G6B5 ) ; const bool isSrcBGR = aSource -> GetFormat ( ) == SurfaceFormat :: B8G8R8A8 || aSource -> GetFormat ( ) == SurfaceFormat :: B8G8R8X8 ; const bool isDestBGR = aDest -> GetFormat ( ) == SurfaceFormat :: B8G8R8A8 || aDest -> GetFormat ( ) == SurfaceFormat :: B8G8R8X8 ; const bool needsSwap02 = isSrcBGR != isDestBGR ; const bool srcHasAlpha = aSource -> GetFormat ( ) == SurfaceFormat :: R8G8B8A8 || aSource -> GetFormat ( ) == SurfaceFormat :: B8G8R8A8 ; const bool destHasAlpha = aDest -> GetFormat ( ) == SurfaceFormat :: R8G8B8A8 || aDest -> GetFormat ( ) == SurfaceFormat :: B8G8R8A8 ; const bool needsAlphaMask = ! srcHasAlpha && destHasAlpha ; const bool needsConvertTo16Bits = aDest -> GetFormat ( ) == SurfaceFormat :: R5G6B5 ; DataSourceSurface :: MappedSurface srcMap ; DataSourceSurface :: MappedSurface destMap ; MOZ_ALWAYS_TRUE ( aSource -> Map ( DataSourceSurface :: MapType :: READ , & srcMap ) ) ; MOZ_ALWAYS_TRUE ( aDest -> Map ( DataSourceSurface :: MapType :: WRITE , & destMap ) ) ; MOZ_ASSERT ( srcMap . mStride >= 0 ) ; MOZ_ASSERT ( destMap . mStride >= 0 ) ; const size_t srcBPP = BytesPerPixel ( aSource -> GetFormat ( ) ) ; const size_t srcRowBytes = aSource -> GetSize ( ) . width * srcBPP ; const size_t srcRowHole = srcMap . mStride - srcRowBytes ; const size_t destBPP = BytesPerPixel ( aDest -> GetFormat ( ) ) ; const size_t destRowBytes = aDest -> GetSize ( ) . width * destBPP ; const size_t destRowHole = destMap . mStride - destRowBytes ; uint8_t * srcRow = srcMap . mData ; uint8_t * destRow = destMap . mData ; const size_t rows = aSource -> GetSize ( ) . height ; for ( size_t i = 0 ; i < rows ; i ++ ) { const uint8_t * srcRowEnd = srcRow + srcRowBytes ; while ( srcRow != srcRowEnd ) { uint8_t d0 = needsSwap02 ? srcRow [ 2 ] : srcRow [ 0 ] ; uint8_t d1 = srcRow [ 1 ] ; uint8_t d2 = needsSwap02 ? srcRow [ 0 ] : srcRow [ 2 ] ; uint8_t d3 = needsAlphaMask ? 0xff : srcRow [ 3 ] ; if ( needsConvertTo16Bits ) { * ( uint16_t * ) destRow = PackRGB565 ( d0 , d1 , d2 ) ; } else { destRow [ 0 ] = d0 ; destRow [ 1 ] = d1 ; destRow [ 2 ] = d2 ; destRow [ 3 ] = d3 ; } srcRow += srcBPP ; destRow += destBPP ; } srcRow += srcRowHole ; destRow += destRowHole ; } aSource -> Unmap ( ) ; aDest -> Unmap ( ) ; }
bool DebugInfo :: HasBreakPoint ( Isolate * isolate , int source_position ) { DCHECK ( HasBreakInfo ( ) ) ; Object * break_point_info = GetBreakPointInfo ( isolate , source_position ) ; if ( break_point_info -> IsUndefined ( isolate ) ) return false ; return BreakPointInfo :: cast ( break_point_info ) -> GetBreakPointCount ( isolate ) > 0 ; }
tAVRC_STS avrc_parse_notification_rsp ( uint8_t * p_stream , uint16_t len , tAVRC_REG_NOTIF_RSP * p_rsp ) { uint16_t min_len = 1 ; if ( len < min_len ) goto length_error ; BE_STREAM_TO_UINT8 ( p_rsp -> event_id , p_stream ) ; switch ( p_rsp -> event_id ) { case AVRC_EVT_PLAY_STATUS_CHANGE : min_len += 1 ; if ( len < min_len ) goto length_error ; BE_STREAM_TO_UINT8 ( p_rsp -> param . play_status , p_stream ) ; break ; case AVRC_EVT_TRACK_CHANGE : min_len += 8 ; if ( len < min_len ) goto length_error ; BE_STREAM_TO_ARRAY ( p_stream , p_rsp -> param . track , 8 ) ; break ; case AVRC_EVT_APP_SETTING_CHANGE : min_len += 1 ; if ( len < min_len ) goto length_error ; BE_STREAM_TO_UINT8 ( p_rsp -> param . player_setting . num_attr , p_stream ) ; if ( p_rsp -> param . player_setting . num_attr > AVRC_MAX_APP_SETTINGS ) { android_errorWriteLog ( 0x534e4554 , "73782082" ) ; p_rsp -> param . player_setting . num_attr = AVRC_MAX_APP_SETTINGS ; } min_len += p_rsp -> param . player_setting . num_attr * 2 ; if ( len < min_len ) goto length_error ; for ( int index = 0 ; index < p_rsp -> param . player_setting . num_attr ; index ++ ) { BE_STREAM_TO_UINT8 ( p_rsp -> param . player_setting . attr_id [ index ] , p_stream ) ; BE_STREAM_TO_UINT8 ( p_rsp -> param . player_setting . attr_value [ index ] , p_stream ) ; } break ; case AVRC_EVT_NOW_PLAYING_CHANGE : break ; case AVRC_EVT_AVAL_PLAYERS_CHANGE : break ; case AVRC_EVT_ADDR_PLAYER_CHANGE : min_len += 4 ; if ( len < min_len ) goto length_error ; BE_STREAM_TO_UINT16 ( p_rsp -> param . addr_player . player_id , p_stream ) ; BE_STREAM_TO_UINT16 ( p_rsp -> param . addr_player . uid_counter , p_stream ) ; break ; case AVRC_EVT_PLAY_POS_CHANGED : min_len += 4 ; if ( len < min_len ) goto length_error ; BE_STREAM_TO_UINT32 ( p_rsp -> param . play_pos , p_stream ) ; break ; case AVRC_EVT_UIDS_CHANGE : break ; case AVRC_EVT_TRACK_REACHED_END : case AVRC_EVT_TRACK_REACHED_START : case AVRC_EVT_BATTERY_STATUS_CHANGE : case AVRC_EVT_SYSTEM_STATUS_CHANGE : default : break ; } return AVRC_STS_NO_ERROR ; length_error : android_errorWriteLog ( 0x534e4554 , "111450417" ) ; AVRC_TRACE_WARNING ( "%s: invalid parameter length %d: must be at least %d" , __func__ , len , min_len ) ; return AVRC_STS_INTERNAL_ERR ; }
IGNITION_HANDLER ( GetSuperConstructor , InterpreterAssembler ) { Node * active_function = GetAccumulator ( ) ; Node * context = GetContext ( ) ; Node * result = GetSuperConstructor ( context , active_function ) ; StoreRegisterAtOperandIndex ( result , 0 ) ; Dispatch ( ) ; }
TF_BUILTIN ( ObjectPrototypeIsPrototypeOf , ObjectBuiltinsAssembler ) { Node * receiver = Parameter ( Descriptor :: kReceiver ) ; Node * value = Parameter ( Descriptor :: kValue ) ; Node * context = Parameter ( Descriptor :: kContext ) ; Label if_receiverisnullorundefined ( this , Label :: kDeferred ) , if_valueisnotreceiver ( this , Label :: kDeferred ) ; GotoIf ( TaggedIsSmi ( value ) , & if_valueisnotreceiver ) ; GotoIf ( IsNull ( receiver ) , & if_receiverisnullorundefined ) ; GotoIf ( IsUndefined ( receiver ) , & if_receiverisnullorundefined ) ; Return ( HasInPrototypeChain ( context , value , receiver ) ) ; BIND ( & if_receiverisnullorundefined ) ; { GotoIfNot ( IsJSReceiver ( value ) , & if_valueisnotreceiver ) ; ToObject ( context , receiver ) ; Unreachable ( ) ; } BIND ( & if_valueisnotreceiver ) ; Return ( FalseConstant ( ) ) ; }
PHPAPI zend_string * php_escape_shell_arg ( char * str ) { int x , y = 0 , l = ( int ) strlen ( str ) ; zend_string * cmd ; size_t estimate = ( 4 * l ) + 3 ; cmd = zend_string_alloc ( 4 * l + 2 , 0 ) ; #ifdef PHP_WIN32 ZSTR_VAL ( cmd ) [ y ++ ] = '"' ; #else ZSTR_VAL ( cmd ) [ y ++ ] = '\'' ; #endif for ( x = 0 ; x < l ; x ++ ) { int mb_len = php_mblen ( str + x , ( l - x ) ) ; if ( mb_len < 0 ) { continue ; } else if ( mb_len > 1 ) { memcpy ( ZSTR_VAL ( cmd ) + y , str + x , mb_len ) ; y += mb_len ; x += mb_len - 1 ; continue ; } switch ( str [ x ] ) { #ifdef PHP_WIN32 case '"' : case '%' : case '!' : ZSTR_VAL ( cmd ) [ y ++ ] = ' ' ; break ; #else case '\'' : ZSTR_VAL ( cmd ) [ y ++ ] = '\'' ; ZSTR_VAL ( cmd ) [ y ++ ] = '\\' ; ZSTR_VAL ( cmd ) [ y ++ ] = '\'' ; #endif default : ZSTR_VAL ( cmd ) [ y ++ ] = str [ x ] ; } } #ifdef PHP_WIN32 if ( y > 0 && '\\' == ZSTR_VAL ( cmd ) [ y - 1 ] ) { int k = 0 , n = y - 1 ; for ( ; n >= 0 && '\\' == ZSTR_VAL ( cmd ) [ n ] ; n -- , k ++ ) ; if ( k % 2 ) { ZSTR_VAL ( cmd ) [ y ++ ] = '\\' ; } } ZSTR_VAL ( cmd ) [ y ++ ] = '"' ; #else ZSTR_VAL ( cmd ) [ y ++ ] = '\'' ; #endif ZSTR_VAL ( cmd ) [ y ] = '\0' ; if ( ( estimate - y ) > 4096 ) { cmd = zend_string_truncate ( cmd , y , 0 ) ; } ZSTR_LEN ( cmd ) = y ; return cmd ; }
win_exchange ( long Prenum ) { frame_T * frp ; frame_T * frp2 ; win_T * wp ; win_T * wp2 ; int temp ; if ( ERROR_IF_ANY_POPUP_WINDOW ) return ; if ( ONE_WINDOW ) { beep_flush ( ) ; return ; } #ifdef FEAT_GUI need_mouse_correct = TRUE ; #endif if ( Prenum ) { frp = curwin -> w_frame -> fr_parent -> fr_child ; while ( frp != NULL && -- Prenum > 0 ) frp = frp -> fr_next ; } else if ( curwin -> w_frame -> fr_next != NULL ) frp = curwin -> w_frame -> fr_next ; else frp = curwin -> w_frame -> fr_prev ; if ( frp == NULL || frp -> fr_win == NULL || frp -> fr_win == curwin ) return ; wp = frp -> fr_win ; wp2 = curwin -> w_prev ; frp2 = curwin -> w_frame -> fr_prev ; if ( wp -> w_prev != curwin ) { win_remove ( curwin , NULL ) ; frame_remove ( curwin -> w_frame ) ; win_append ( wp -> w_prev , curwin ) ; frame_insert ( frp , curwin -> w_frame ) ; } if ( wp != wp2 ) { win_remove ( wp , NULL ) ; frame_remove ( wp -> w_frame ) ; win_append ( wp2 , wp ) ; if ( frp2 == NULL ) frame_insert ( wp -> w_frame -> fr_parent -> fr_child , wp -> w_frame ) ; else frame_append ( frp2 , wp -> w_frame ) ; } temp = curwin -> w_status_height ; curwin -> w_status_height = wp -> w_status_height ; wp -> w_status_height = temp ; temp = curwin -> w_vsep_width ; curwin -> w_vsep_width = wp -> w_vsep_width ; wp -> w_vsep_width = temp ; frame_fix_height ( curwin ) ; frame_fix_height ( wp ) ; frame_fix_width ( curwin ) ; frame_fix_width ( wp ) ; ( void ) win_comp_pos ( ) ; win_enter ( wp , TRUE ) ; redraw_all_later ( NOT_VALID ) ; }
PropertyProvider :: CalcTabWidths ( uint32_t aStart , uint32_t aLength ) { if ( ! mTabWidths ) { if ( mReflowing && ! mLineContainer ) { return ; } if ( ! mReflowing ) { mTabWidths = static_cast < TabWidthStore * > ( mFrame -> Properties ( ) . Get ( TabWidthProperty ( ) ) ) ; #ifdef DEBUG for ( uint32_t i = aStart + aLength ; i > aStart ; -- i ) { if ( mTextRun -> CharIsTab ( i - 1 ) ) { NS_ASSERTION ( mTabWidths && mTabWidths -> mLimit >= i , "Precomputed tab widths are missing!" ) ; break ; } } #endif return ; } } uint32_t startOffset = mStart . GetSkippedOffset ( ) ; uint32_t tabsEnd = mTabWidths ? mTabWidths -> mLimit : std :: max ( mTabWidthsAnalyzedLimit , startOffset ) ; if ( tabsEnd < aStart + aLength ) { NS_ASSERTION ( mReflowing , "We need precomputed tab widths, but don't have enough." ) ; gfxFloat tabWidth = - 1 ; for ( uint32_t i = tabsEnd ; i < aStart + aLength ; ++ i ) { Spacing spacing ; GetSpacingInternal ( i , 1 , & spacing , true ) ; mOffsetFromBlockOriginForTabs += spacing . mBefore ; if ( ! mTextRun -> CharIsTab ( i ) ) { if ( mTextRun -> IsClusterStart ( i ) ) { uint32_t clusterEnd = i + 1 ; while ( clusterEnd < mTextRun -> GetLength ( ) && ! mTextRun -> IsClusterStart ( clusterEnd ) ) { ++ clusterEnd ; } mOffsetFromBlockOriginForTabs += mTextRun -> GetAdvanceWidth ( i , clusterEnd - i , nullptr ) ; } } else { if ( ! mTabWidths ) { mTabWidths = new TabWidthStore ( ) ; mFrame -> Properties ( ) . Set ( TabWidthProperty ( ) , mTabWidths ) ; } double nextTab = AdvanceToNextTab ( mOffsetFromBlockOriginForTabs , mFrame , mTextRun , & tabWidth ) ; mTabWidths -> mWidths . AppendElement ( TabWidth ( i - startOffset , NSToIntRound ( nextTab - mOffsetFromBlockOriginForTabs ) ) ) ; mOffsetFromBlockOriginForTabs = nextTab ; } mOffsetFromBlockOriginForTabs += spacing . mAfter ; } if ( mTabWidths ) { mTabWidths -> mLimit = aStart + aLength ; } } if ( ! mTabWidths ) { mFrame -> Properties ( ) . Delete ( TabWidthProperty ( ) ) ; mTabWidthsAnalyzedLimit = std :: max ( mTabWidthsAnalyzedLimit , aStart + aLength ) ; } }
static void set_ntacl_dacl ( struct user_namespace * user_ns , struct smb_acl * pndacl , struct smb_acl * nt_dacl , const struct smb_sid * pownersid , const struct smb_sid * pgrpsid , struct smb_fattr * fattr ) { struct smb_ace * ntace , * pndace ; int nt_num_aces = le32_to_cpu ( nt_dacl -> num_aces ) , num_aces = 0 ; unsigned short size = 0 ; int i ; pndace = ( struct smb_ace * ) ( ( char * ) pndacl + sizeof ( struct smb_acl ) ) ; if ( nt_num_aces ) { ntace = ( struct smb_ace * ) ( ( char * ) nt_dacl + sizeof ( struct smb_acl ) ) ; for ( i = 0 ; i < nt_num_aces ; i ++ ) { memcpy ( ( char * ) pndace + size , ntace , le16_to_cpu ( ntace -> size ) ) ; size += le16_to_cpu ( ntace -> size ) ; ntace = ( struct smb_ace * ) ( ( char * ) ntace + le16_to_cpu ( ntace -> size ) ) ; num_aces ++ ; } } set_posix_acl_entries_dacl ( user_ns , pndace , fattr , & num_aces , & size , nt_num_aces ) ; pndacl -> num_aces = cpu_to_le32 ( num_aces ) ; pndacl -> size = cpu_to_le16 ( le16_to_cpu ( pndacl -> size ) + size ) ; }
void RegExpMacroAssemblerIA32 :: CheckStackLimit ( ) { Label no_stack_overflow ; ExternalReference stack_limit = ExternalReference :: address_of_regexp_stack_limit ( isolate ( ) ) ; __ cmp ( backtrack_stackpointer ( ) , masm_ -> StaticVariable ( stack_limit ) ) ; __ j ( above , & no_stack_overflow ) ; SafeCall ( & stack_overflow_label_ ) ; __ bind ( & no_stack_overflow ) ; }
SQLWCHAR * _single_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) { return in ; } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 1 ) ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; return chr ; }
void BaseCollectionsAssembler :: GenerateConstructor ( Variant variant , Handle < String > constructor_function_name , TNode < Object > new_target , TNode < IntPtrT > argc , TNode < Context > context ) { const int kIterableArg = 0 ; CodeStubArguments args ( this , argc ) ; TNode < Object > iterable = args . GetOptionalArgumentValue ( kIterableArg ) ; Label if_undefined ( this , Label :: kDeferred ) ; GotoIf ( IsUndefined ( new_target ) , & if_undefined ) ; TNode < Context > native_context = LoadNativeContext ( context ) ; TNode < Object > collection = AllocateJSCollection ( context , GetConstructor ( variant , native_context ) , new_target ) ; AddConstructorEntries ( variant , context , native_context , collection , iterable ) ; Return ( collection ) ; BIND ( & if_undefined ) ; ThrowTypeError ( context , MessageTemplate :: kConstructorNotFunction , HeapConstant ( constructor_function_name ) ) ; }
nsDOMDeviceStorageCursor :: Continue ( ErrorResult & aRv ) { if ( ! mOkToCallContinue ) { aRv . Throw ( NS_ERROR_UNEXPECTED ) ; return ; } if ( mRooted ) { mResult = JSVAL_VOID ; NS_DROP_JS_OBJECTS ( this , nsDOMDeviceStorageCursor ) ; mDone = false ; mRooted = false ; } nsCOMPtr < ContinueCursorEvent > event = new ContinueCursorEvent ( this ) ; event -> Continue ( ) ; mOkToCallContinue = false ; }
arena_palloc ( arena_t * arena , size_t alignment , size_t size , size_t alloc_size ) { void * ret ; size_t offset ; arena_chunk_t * chunk ; assert ( ( size & pagesize_mask ) == 0 ) ; assert ( ( alignment & pagesize_mask ) == 0 ) ; #ifdef MALLOC_BALANCE arena_lock_balance ( arena ) ; #else malloc_spin_lock ( & arena -> lock ) ; #endif ret = ( void * ) arena_run_alloc ( arena , NULL , alloc_size , true , false ) ; if ( ret == NULL ) { malloc_spin_unlock ( & arena -> lock ) ; return ( NULL ) ; } chunk = ( arena_chunk_t * ) CHUNK_ADDR2BASE ( ret ) ; offset = ( uintptr_t ) ret & ( alignment - 1 ) ; assert ( ( offset & pagesize_mask ) == 0 ) ; assert ( offset < alloc_size ) ; if ( offset == 0 ) arena_run_trim_tail ( arena , chunk , ( arena_run_t * ) ret , alloc_size , size , false ) ; else { size_t leadsize , trailsize ; leadsize = alignment - offset ; if ( leadsize > 0 ) { arena_run_trim_head ( arena , chunk , ( arena_run_t * ) ret , alloc_size , alloc_size - leadsize ) ; ret = ( void * ) ( ( uintptr_t ) ret + leadsize ) ; } trailsize = alloc_size - leadsize - size ; if ( trailsize != 0 ) { assert ( trailsize < alloc_size ) ; arena_run_trim_tail ( arena , chunk , ( arena_run_t * ) ret , size + trailsize , size , false ) ; } } #ifdef MALLOC_STATS arena -> stats . nmalloc_large ++ ; arena -> stats . allocated_large += size ; #endif malloc_spin_unlock ( & arena -> lock ) ; #ifdef MALLOC_FILL if ( opt_junk ) memset ( ret , 0xa5 , size ) ; else if ( opt_zero ) memset ( ret , 0 , size ) ; #endif return ( ret ) ; }
static void hugetlbfs_put_super ( struct super_block * sb ) { struct hugetlbfs_sb_info * sbi = HUGETLBFS_SB ( sb ) ; if ( sbi ) { sb -> s_fs_info = NULL ; kfree ( sbi ) ; } }
ScriptCompiler :: CachedData * CodeSerializer :: Serialize ( Handle < SharedFunctionInfo > info ) { Isolate * isolate = info -> GetIsolate ( ) ; TRACE_EVENT_CALL_STATS_SCOPED ( isolate , "v8" , "V8.Execute" ) ; HistogramTimerScope histogram_timer ( isolate -> counters ( ) -> compile_serialize ( ) ) ; RuntimeCallTimerScope runtimeTimer ( isolate , RuntimeCallCounterId :: kCompileSerialize ) ; TRACE_EVENT0 ( TRACE_DISABLED_BY_DEFAULT ( "v8.compile" ) , "V8.CompileSerialize" ) ; base :: ElapsedTimer timer ; if ( FLAG_profile_deserialization ) timer . Start ( ) ; Handle < Script > script ( Script :: cast ( info -> script ( ) ) , isolate ) ; if ( FLAG_trace_serializer ) { PrintF ( "[Serializing from" ) ; script -> name ( ) -> ShortPrint ( ) ; PrintF ( "]\n" ) ; } if ( script -> ContainsAsmModule ( ) ) return nullptr ; isolate -> heap ( ) -> read_only_space ( ) -> ClearStringPaddingIfNeeded ( ) ; Handle < String > source ( String :: cast ( script -> source ( ) ) , isolate ) ; CodeSerializer cs ( isolate , SerializedCodeData :: SourceHash ( source , script -> origin_options ( ) ) ) ; DisallowHeapAllocation no_gc ; cs . reference_map ( ) -> AddAttachedReference ( * source ) ; ScriptData * script_data = cs . SerializeSharedFunctionInfo ( info ) ; if ( FLAG_profile_deserialization ) { double ms = timer . Elapsed ( ) . InMillisecondsF ( ) ; int length = script_data -> length ( ) ; PrintF ( "[Serializing to %d bytes took %0.3f ms]\n" , length , ms ) ; } ScriptCompiler :: CachedData * result = new ScriptCompiler :: CachedData ( script_data -> data ( ) , script_data -> length ( ) , ScriptCompiler :: CachedData :: BufferOwned ) ; script_data -> ReleaseDataOwnership ( ) ; delete script_data ; return result ; }
long Segment :: DoLoadClusterUnknownSize ( long long & pos , long & len ) { assert ( m_pos < 0 ) ; assert ( m_pUnknownSize ) ; #if 0 assert ( m_pUnknownSize -> GetElementSize ( ) < 0 ) ; const long long element_start = m_pUnknownSize -> m_element_start ; pos = - m_pos ; assert ( pos > element_start ) ; long long total , avail ; long status = m_pReader -> Length ( & total , & avail ) ; if ( status < 0 ) return status ; assert ( ( total < 0 ) || ( avail <= total ) ) ; const long long segment_stop = ( m_size < 0 ) ? - 1 : m_start + m_size ; long long element_size = - 1 ; for ( ; ; ) { if ( ( total >= 0 ) && ( pos >= total ) ) { element_size = total - element_start ; assert ( element_size > 0 ) ; break ; } if ( ( segment_stop >= 0 ) && ( pos >= segment_stop ) ) { element_size = segment_stop - element_start ; assert ( element_size > 0 ) ; break ; } if ( ( pos + 1 ) > avail ) { len = 1 ; return E_BUFFER_NOT_FULL ; } long long result = GetUIntLength ( m_pReader , pos , len ) ; if ( result < 0 ) return static_cast < long > ( result ) ; if ( result > 0 ) return E_BUFFER_NOT_FULL ; if ( ( segment_stop >= 0 ) && ( ( pos + len ) > segment_stop ) ) return E_FILE_FORMAT_INVALID ; if ( ( pos + len ) > avail ) return E_BUFFER_NOT_FULL ; const long long idpos = pos ; const long long id = ReadUInt ( m_pReader , idpos , len ) ; if ( id < 0 ) return static_cast < long > ( id ) ; if ( ( id == 0x0F43B675 ) || ( id == 0x0C53BB6B ) ) { element_size = pos - element_start ; assert ( element_size > 0 ) ; break ; } #ifdef _DEBUG switch ( id ) { case 0x20 : case 0x23 : case 0x67 : case 0x2B : break ; default : assert ( false ) ; break ; } #endif pos += len ; if ( ( pos + 1 ) > avail ) { len = 1 ; return E_BUFFER_NOT_FULL ; } result = GetUIntLength ( m_pReader , pos , len ) ; if ( result < 0 ) return static_cast < long > ( result ) ; if ( result > 0 ) return E_BUFFER_NOT_FULL ; if ( ( segment_stop >= 0 ) && ( ( pos + len ) > segment_stop ) ) return E_FILE_FORMAT_INVALID ; if ( ( pos + len ) > avail ) return E_BUFFER_NOT_FULL ; const long long size = ReadUInt ( m_pReader , pos , len ) ; if ( size < 0 ) return static_cast < long > ( size ) ; pos += len ; if ( size == 0 ) continue ; const long long unknown_size = ( 1LL < < ( 7 * len ) ) - 1 ; if ( size == unknown_size ) return E_FILE_FORMAT_INVALID ; if ( ( segment_stop >= 0 ) && ( ( pos + size ) > segment_stop ) ) return E_FILE_FORMAT_INVALID ; pos += size ; assert ( ( segment_stop < 0 ) || ( pos <= segment_stop ) ) ; } assert ( element_size >= 0 ) ; m_pos = element_start + element_size ; m_pUnknownSize = 0 ; return 2 ; #else const long status = m_pUnknownSize -> Parse ( pos , len ) ; if ( status < 0 ) return status ; if ( status == 0 ) return 2 ; assert ( status > 0 ) ; const long long start = m_pUnknownSize -> m_element_start ; const long long size = m_pUnknownSize -> GetElementSize ( ) ; assert ( size >= 0 ) ; pos = start + size ; m_pos = pos ; m_pUnknownSize = 0 ; return 2 ; #endif }
status_t M3UParser :: parseMedia ( const AString & line ) { ssize_t colonPos = line . find ( ":" ) ; if ( colonPos < 0 ) { return ERROR_MALFORMED ; } bool haveGroupType = false ; MediaGroup :: Type groupType = MediaGroup :: TYPE_AUDIO ; bool haveGroupID = false ; AString groupID ; bool haveGroupLanguage = false ; AString groupLanguage ; bool haveGroupName = false ; AString groupName ; bool haveGroupAutoselect = false ; bool groupAutoselect = false ; bool haveGroupDefault = false ; bool groupDefault = false ; bool haveGroupForced = false ; bool groupForced = false ; bool haveGroupURI = false ; AString groupURI ; size_t offset = colonPos + 1 ; while ( offset < line . size ( ) ) { ssize_t end = FindNextUnquoted ( line , ',' , offset ) ; if ( end < 0 ) { end = line . size ( ) ; } AString attr ( line , offset , end - offset ) ; attr . trim ( ) ; offset = end + 1 ; ssize_t equalPos = attr . find ( "=" ) ; if ( equalPos < 0 ) { continue ; } AString key ( attr , 0 , equalPos ) ; key . trim ( ) ; AString val ( attr , equalPos + 1 , attr . size ( ) - equalPos - 1 ) ; val . trim ( ) ; ALOGV ( "key=%s value=%s" , key . c_str ( ) , val . c_str ( ) ) ; if ( ! strcasecmp ( "type" , key . c_str ( ) ) ) { if ( ! strcasecmp ( "subtitles" , val . c_str ( ) ) ) { groupType = MediaGroup :: TYPE_SUBS ; } else if ( ! strcasecmp ( "audio" , val . c_str ( ) ) ) { groupType = MediaGroup :: TYPE_AUDIO ; } else if ( ! strcasecmp ( "video" , val . c_str ( ) ) ) { groupType = MediaGroup :: TYPE_VIDEO ; } else if ( ! strcasecmp ( "closed-captions" , val . c_str ( ) ) ) { groupType = MediaGroup :: TYPE_CC ; } else { ALOGE ( "Invalid media group type '%s'" , val . c_str ( ) ) ; return ERROR_MALFORMED ; } haveGroupType = true ; } else if ( ! strcasecmp ( "group-id" , key . c_str ( ) ) ) { if ( val . size ( ) < 2 || val . c_str ( ) [ 0 ] != '"' || val . c_str ( ) [ val . size ( ) - 1 ] != '"' ) { ALOGE ( "Expected quoted string for GROUP-ID, got '%s' instead." , val . c_str ( ) ) ; return ERROR_MALFORMED ; } groupID . setTo ( val , 1 , val . size ( ) - 2 ) ; haveGroupID = true ; } else if ( ! strcasecmp ( "language" , key . c_str ( ) ) ) { if ( val . size ( ) < 2 || val . c_str ( ) [ 0 ] != '"' || val . c_str ( ) [ val . size ( ) - 1 ] != '"' ) { ALOGE ( "Expected quoted string for LANGUAGE, got '%s' instead." , val . c_str ( ) ) ; return ERROR_MALFORMED ; } groupLanguage . setTo ( val , 1 , val . size ( ) - 2 ) ; haveGroupLanguage = true ; } else if ( ! strcasecmp ( "name" , key . c_str ( ) ) ) { if ( val . size ( ) < 2 || val . c_str ( ) [ 0 ] != '"' || val . c_str ( ) [ val . size ( ) - 1 ] != '"' ) { ALOGE ( "Expected quoted string for NAME, got '%s' instead." , val . c_str ( ) ) ; return ERROR_MALFORMED ; } groupName . setTo ( val , 1 , val . size ( ) - 2 ) ; haveGroupName = true ; } else if ( ! strcasecmp ( "autoselect" , key . c_str ( ) ) ) { groupAutoselect = false ; if ( ! strcasecmp ( "YES" , val . c_str ( ) ) ) { groupAutoselect = true ; } else if ( ! strcasecmp ( "NO" , val . c_str ( ) ) ) { groupAutoselect = false ; } else { ALOGE ( "Expected YES or NO for AUTOSELECT attribute, " "got '%s' instead." , val . c_str ( ) ) ; return ERROR_MALFORMED ; } haveGroupAutoselect = true ; } else if ( ! strcasecmp ( "default" , key . c_str ( ) ) ) { groupDefault = false ; if ( ! strcasecmp ( "YES" , val . c_str ( ) ) ) { groupDefault = true ; } else if ( ! strcasecmp ( "NO" , val . c_str ( ) ) ) { groupDefault = false ; } else { ALOGE ( "Expected YES or NO for DEFAULT attribute, " "got '%s' instead." , val . c_str ( ) ) ; return ERROR_MALFORMED ; } haveGroupDefault = true ; } else if ( ! strcasecmp ( "forced" , key . c_str ( ) ) ) { groupForced = false ; if ( ! strcasecmp ( "YES" , val . c_str ( ) ) ) { groupForced = true ; } else if ( ! strcasecmp ( "NO" , val . c_str ( ) ) ) { groupForced = false ; } else { ALOGE ( "Expected YES or NO for FORCED attribute, " "got '%s' instead." , val . c_str ( ) ) ; return ERROR_MALFORMED ; } haveGroupForced = true ; } else if ( ! strcasecmp ( "uri" , key . c_str ( ) ) ) { if ( val . size ( ) < 2 || val . c_str ( ) [ 0 ] != '"' || val . c_str ( ) [ val . size ( ) - 1 ] != '"' ) { ALOGE ( "Expected quoted string for URI, got '%s' instead." , val . c_str ( ) ) ; return ERROR_MALFORMED ; } AString tmp ( val , 1 , val . size ( ) - 2 ) ; if ( ! MakeURL ( mBaseURI . c_str ( ) , tmp . c_str ( ) , & groupURI ) ) { ALOGI ( "Failed to make absolute URI from '%s'." , tmp . c_str ( ) ) ; } haveGroupURI = true ; } } if ( ! haveGroupType || ! haveGroupID || ! haveGroupName ) { ALOGE ( "Incomplete EXT-X-MEDIA element." ) ; return ERROR_MALFORMED ; } if ( groupType == MediaGroup :: TYPE_CC ) { return OK ; } uint32_t flags = 0 ; if ( haveGroupAutoselect && groupAutoselect ) { flags |= MediaGroup :: FLAG_AUTOSELECT ; } if ( haveGroupDefault && groupDefault ) { flags |= MediaGroup :: FLAG_DEFAULT ; } if ( haveGroupForced ) { if ( groupType != MediaGroup :: TYPE_SUBS ) { ALOGE ( "The FORCED attribute MUST not be present on anything " "but SUBS media." ) ; return ERROR_MALFORMED ; } if ( groupForced ) { flags |= MediaGroup :: FLAG_FORCED ; } } if ( haveGroupLanguage ) { flags |= MediaGroup :: FLAG_HAS_LANGUAGE ; } if ( haveGroupURI ) { flags |= MediaGroup :: FLAG_HAS_URI ; } ssize_t groupIndex = mMediaGroups . indexOfKey ( groupID ) ; sp < MediaGroup > group ; if ( groupIndex < 0 ) { group = new MediaGroup ( groupType ) ; mMediaGroups . add ( groupID , group ) ; } else { group = mMediaGroups . valueAt ( groupIndex ) ; if ( group -> type ( ) != groupType ) { ALOGE ( "Attempt to put media item under group of different type " "(groupType = %d, item type = %d" , group -> type ( ) , groupType ) ; return ERROR_MALFORMED ; } } return group -> addMedia ( groupName . c_str ( ) , haveGroupURI ? groupURI . c_str ( ) : NULL , haveGroupLanguage ? groupLanguage . c_str ( ) : NULL , flags ) ; }
struct crypto_alg * crypto_larval_lookup ( const char * name , u32 type , u32 mask ) { struct crypto_alg * alg ; if ( ! name ) return ERR_PTR ( - ENOENT ) ; mask &= ~ ( CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD ) ; type &= mask ; alg = crypto_alg_lookup ( name , type , mask ) ; if ( ! alg ) { request_module ( "%s" , name ) ; if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) ) request_module ( "%s-all" , name ) ; alg = crypto_alg_lookup ( name , type , mask ) ; } if ( alg ) return crypto_is_larval ( alg ) ? crypto_larval_wait ( alg ) : alg ; return crypto_larval_add ( name , type , mask ) ; }
static int jas_iccgetuint16 ( jas_stream_t * in , jas_iccuint16_t * val ) { ulonglong tmp ; if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
Reduction RedundancyElimination :: Reduce ( Node * node ) { if ( node_checks_ . Get ( node ) ) return NoChange ( ) ; switch ( node -> opcode ( ) ) { case IrOpcode :: kCheckBounds : case IrOpcode :: kCheckEqualsInternalizedString : case IrOpcode :: kCheckEqualsSymbol : case IrOpcode :: kCheckFloat64Hole : case IrOpcode :: kCheckHeapObject : case IrOpcode :: kCheckIf : case IrOpcode :: kCheckInternalizedString : case IrOpcode :: kCheckNotTaggedHole : case IrOpcode :: kCheckNumber : case IrOpcode :: kCheckReceiver : case IrOpcode :: kCheckSmi : case IrOpcode :: kCheckString : case IrOpcode :: kCheckSymbol : case IrOpcode :: kCheckedFloat64ToInt32 : case IrOpcode :: kCheckedInt32Add : case IrOpcode :: kCheckedInt32Div : case IrOpcode :: kCheckedInt32Mod : case IrOpcode :: kCheckedInt32Mul : case IrOpcode :: kCheckedInt32Sub : case IrOpcode :: kCheckedInt32ToTaggedSigned : case IrOpcode :: kCheckedTaggedSignedToInt32 : case IrOpcode :: kCheckedTaggedToFloat64 : case IrOpcode :: kCheckedTaggedToInt32 : case IrOpcode :: kCheckedTaggedToTaggedPointer : case IrOpcode :: kCheckedTaggedToTaggedSigned : case IrOpcode :: kCheckedTruncateTaggedToWord32 : case IrOpcode :: kCheckedUint32Div : case IrOpcode :: kCheckedUint32Mod : case IrOpcode :: kCheckedUint32ToInt32 : case IrOpcode :: kCheckedUint32ToTaggedSigned : return ReduceCheckNode ( node ) ; case IrOpcode :: kSpeculativeNumberAdd : case IrOpcode :: kSpeculativeNumberSubtract : case IrOpcode :: kSpeculativeSafeIntegerAdd : case IrOpcode :: kSpeculativeSafeIntegerSubtract : return TryReuseBoundsCheckForFirstInput ( node ) ; case IrOpcode :: kEffectPhi : return ReduceEffectPhi ( node ) ; case IrOpcode :: kDead : break ; case IrOpcode :: kStart : return ReduceStart ( node ) ; default : return ReduceOtherNode ( node ) ; } return NoChange ( ) ; }
JSStructuredCloneWriter :: parseTransferable ( ) { MOZ_ASSERT ( transferableObjects . empty ( ) , "parseTransferable called with stale data" ) ; if ( transferable . isNull ( ) || transferable . isUndefined ( ) ) return true ; if ( ! transferable . isObject ( ) ) return reportErrorTransferable ( ) ; JSContext * cx = context ( ) ; RootedObject array ( cx , & transferable . toObject ( ) ) ; if ( ! JS_IsArrayObject ( cx , array ) ) return reportErrorTransferable ( ) ; uint32_t length ; if ( ! JS_GetArrayLength ( cx , array , & length ) ) { return false ; } RootedValue v ( context ( ) ) ; for ( uint32_t i = 0 ; i < length ; ++ i ) { if ( ! JS_GetElement ( cx , array , i , & v ) ) return false ; if ( ! v . isObject ( ) ) return reportErrorTransferable ( ) ; RootedObject tObj ( context ( ) , CheckedUnwrap ( & v . toObject ( ) ) ) ; if ( ! tObj ) { JS_ReportErrorNumber ( context ( ) , js_GetErrorMessage , nullptr , JSMSG_UNWRAP_DENIED ) ; return false ; } if ( std :: find ( transferableObjects . begin ( ) , transferableObjects . end ( ) , tObj ) != transferableObjects . end ( ) ) { JS_ReportErrorNumber ( context ( ) , js_GetErrorMessage , nullptr , JSMSG_SC_DUP_TRANSFERABLE ) ; return false ; } if ( ! transferableObjects . append ( tObj ) ) return false ; } return true ; }
Reduction LoadElimination :: Reduce ( Node * node ) { if ( FLAG_trace_turbo_load_elimination ) { if ( node -> op ( ) -> EffectInputCount ( ) > 0 ) { PrintF ( " visit #%d:%s" , node -> id ( ) , node -> op ( ) -> mnemonic ( ) ) ; if ( node -> op ( ) -> ValueInputCount ( ) > 0 ) { PrintF ( "(" ) ; for ( int i = 0 ; i < node -> op ( ) -> ValueInputCount ( ) ; ++ i ) { if ( i > 0 ) PrintF ( ", " ) ; Node * const value = NodeProperties :: GetValueInput ( node , i ) ; PrintF ( "#%d:%s" , value -> id ( ) , value -> op ( ) -> mnemonic ( ) ) ; } PrintF ( ")" ) ; } PrintF ( "\n" ) ; for ( int i = 0 ; i < node -> op ( ) -> EffectInputCount ( ) ; ++ i ) { Node * const effect = NodeProperties :: GetEffectInput ( node , i ) ; if ( AbstractState const * const state = node_states_ . Get ( effect ) ) { PrintF ( "  state[%i]: #%d:%s\n" , i , effect -> id ( ) , effect -> op ( ) -> mnemonic ( ) ) ; state -> Print ( ) ; } else { PrintF ( "  no state[%i]: #%d:%s\n" , i , effect -> id ( ) , effect -> op ( ) -> mnemonic ( ) ) ; } } } } switch ( node -> opcode ( ) ) { case IrOpcode :: kArrayBufferWasNeutered : return ReduceArrayBufferWasNeutered ( node ) ; case IrOpcode :: kMapGuard : return ReduceMapGuard ( node ) ; case IrOpcode :: kCheckMaps : return ReduceCheckMaps ( node ) ; case IrOpcode :: kCompareMaps : return ReduceCompareMaps ( node ) ; case IrOpcode :: kEnsureWritableFastElements : return ReduceEnsureWritableFastElements ( node ) ; case IrOpcode :: kMaybeGrowFastElements : return ReduceMaybeGrowFastElements ( node ) ; case IrOpcode :: kTransitionElementsKind : return ReduceTransitionElementsKind ( node ) ; case IrOpcode :: kLoadField : return ReduceLoadField ( node ) ; case IrOpcode :: kStoreField : return ReduceStoreField ( node ) ; case IrOpcode :: kLoadElement : return ReduceLoadElement ( node ) ; case IrOpcode :: kStoreElement : return ReduceStoreElement ( node ) ; case IrOpcode :: kTransitionAndStoreElement : return ReduceTransitionAndStoreElement ( node ) ; case IrOpcode :: kStoreTypedElement : return ReduceStoreTypedElement ( node ) ; case IrOpcode :: kEffectPhi : return ReduceEffectPhi ( node ) ; case IrOpcode :: kDead : break ; case IrOpcode :: kStart : return ReduceStart ( node ) ; default : return ReduceOtherNode ( node ) ; } return NoChange ( ) ; }
TEST_F ( GroupVerifierTest , TestRequiresAnyWithAllowMissingButOk ) { TestUtility :: loadFromYaml ( RequiresAnyConfig , proto_config_ ) ; proto_config_ . mutable_rules ( 0 ) -> mutable_requires ( ) -> mutable_requires_any ( ) -> add_requirements ( ) -> mutable_allow_missing ( ) ; createAsyncMockAuthsAndVerifier ( std :: vector < std :: string > { "example_provider" , "other_provider" } ) ; EXPECT_CALL ( mock_cb_ , onComplete ( Status :: Ok ) ) ; auto headers = Http :: TestRequestHeaderMapImpl { } ; context_ = Verifier :: createContext ( headers , parent_span_ , & mock_cb_ ) ; verifier_ -> verify ( context_ ) ; callbacks_ [ "example_provider" ] ( Status :: JwtMissed ) ; callbacks_ [ "other_provider" ] ( Status :: JwtUnknownIssuer ) ; }
bool CompilationDependencies :: Commit ( Handle < Code > code ) { if ( ! AreValid ( ) ) { dependencies_ . clear ( ) ; return false ; } for ( auto dep : dependencies_ ) { if ( ! dep -> IsValid ( ) ) { dependencies_ . clear ( ) ; return false ; } dep -> Install ( MaybeObjectHandle :: Weak ( code ) ) ; } dependencies_ . clear ( ) ; return true ; }
FrameIter :: abstractFramePtr ( ) const { MOZ_ASSERT ( hasUsableAbstractFramePtr ( ) ) ; switch ( data_ . state_ ) { case DONE : case ASMJS : break ; case JIT : { if ( data_ . jitFrames_ . isBaselineJS ( ) ) return data_ . jitFrames_ . baselineFrame ( ) ; MOZ_ASSERT ( data_ . jitFrames_ . isIonJS ( ) ) ; return activation ( ) -> asJit ( ) -> lookupRematerializedFrame ( data_ . jitFrames_ . fp ( ) , ionInlineFrames_ . frameNo ( ) ) ; break ; } case INTERP : MOZ_ASSERT ( interpFrame ( ) ) ; return AbstractFramePtr ( interpFrame ( ) ) ; } MOZ_CRASH ( "Unexpected state" ) ; }
static int dsa_priv_decode ( EVP_PKEY * pkey , PKCS8_PRIV_KEY_INFO * p8 ) { const uint8_t * p , * pm ; int pklen , pmlen ; int ptype ; void * pval ; ASN1_STRING * pstr ; X509_ALGOR * palg ; ASN1_INTEGER * privkey = NULL ; BN_CTX * ctx = NULL ; STACK_OF ( ASN1_TYPE ) * ndsa = NULL ; DSA * dsa = NULL ; if ( ! PKCS8_pkey_get0 ( NULL , & p , & pklen , & palg , p8 ) ) { return 0 ; } X509_ALGOR_get0 ( NULL , & ptype , & pval , palg ) ; if ( * p == ( V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED ) ) { ASN1_TYPE * t1 , * t2 ; ndsa = d2i_ASN1_SEQUENCE_ANY ( NULL , & p , pklen ) ; if ( ndsa == NULL ) { goto decerr ; } if ( sk_ASN1_TYPE_num ( ndsa ) != 2 ) { goto decerr ; } t1 = sk_ASN1_TYPE_value ( ndsa , 0 ) ; t2 = sk_ASN1_TYPE_value ( ndsa , 1 ) ; if ( t1 -> type == V_ASN1_SEQUENCE ) { p8 -> broken = PKCS8_EMBEDDED_PARAM ; pval = t1 -> value . ptr ; } else if ( ptype == V_ASN1_SEQUENCE ) { p8 -> broken = PKCS8_NS_DB ; } else { goto decerr ; } if ( t2 -> type != V_ASN1_INTEGER ) { goto decerr ; } privkey = t2 -> value . integer ; } else { const uint8_t * q = p ; privkey = d2i_ASN1_INTEGER ( NULL , & p , pklen ) ; if ( privkey == NULL ) { goto decerr ; } if ( privkey -> type == V_ASN1_NEG_INTEGER ) { p8 -> broken = PKCS8_NEG_PRIVKEY ; ASN1_INTEGER_free ( privkey ) ; privkey = d2i_ASN1_UINTEGER ( NULL , & q , pklen ) ; if ( privkey == NULL ) { goto decerr ; } } if ( ptype != V_ASN1_SEQUENCE ) { goto decerr ; } } pstr = pval ; pm = pstr -> data ; pmlen = pstr -> length ; dsa = d2i_DSAparams ( NULL , & pm , pmlen ) ; if ( dsa == NULL ) { goto decerr ; } dsa -> priv_key = ASN1_INTEGER_to_BN ( privkey , NULL ) ; if ( dsa -> priv_key == NULL ) { OPENSSL_PUT_ERROR ( EVP , dsa_priv_decode , ERR_LIB_BN ) ; goto dsaerr ; } dsa -> pub_key = BN_new ( ) ; if ( dsa -> pub_key == NULL ) { OPENSSL_PUT_ERROR ( EVP , dsa_priv_decode , ERR_R_MALLOC_FAILURE ) ; goto dsaerr ; } ctx = BN_CTX_new ( ) ; if ( ctx == NULL ) { OPENSSL_PUT_ERROR ( EVP , dsa_priv_decode , ERR_R_MALLOC_FAILURE ) ; goto dsaerr ; } if ( ! BN_mod_exp ( dsa -> pub_key , dsa -> g , dsa -> priv_key , dsa -> p , ctx ) ) { OPENSSL_PUT_ERROR ( EVP , dsa_priv_decode , ERR_LIB_BN ) ; goto dsaerr ; } EVP_PKEY_assign_DSA ( pkey , dsa ) ; BN_CTX_free ( ctx ) ; sk_ASN1_TYPE_pop_free ( ndsa , ASN1_TYPE_free ) ; ASN1_INTEGER_free ( privkey ) ; return 1 ; decerr : OPENSSL_PUT_ERROR ( EVP , dsa_priv_decode , EVP_R_DECODE_ERROR ) ; dsaerr : BN_CTX_free ( ctx ) ; ASN1_INTEGER_free ( privkey ) ; sk_ASN1_TYPE_pop_free ( ndsa , ASN1_TYPE_free ) ; DSA_free ( dsa ) ; return 0 ; }
void EffectControlLinearizer :: LowerTransitionAndStoreElement ( Node * node ) { Node * array = node -> InputAt ( 0 ) ; Node * index = node -> InputAt ( 1 ) ; Node * value = node -> InputAt ( 2 ) ; Node * map = __ LoadField ( AccessBuilder :: ForMap ( ) , array ) ; Node * kind ; { Node * bit_field2 = __ LoadField ( AccessBuilder :: ForMapBitField2 ( ) , map ) ; Node * mask = __ Int32Constant ( Map :: ElementsKindBits :: kMask ) ; Node * andit = __ Word32And ( bit_field2 , mask ) ; Node * shift = __ Int32Constant ( Map :: ElementsKindBits :: kShift ) ; kind = __ Word32Shr ( andit , shift ) ; } auto do_store = __ MakeLabel ( MachineRepresentation :: kWord32 ) ; __ GotoIf ( ObjectIsSmi ( value ) , & do_store , kind ) ; auto transition_smi_array = __ MakeDeferredLabel ( ) ; auto transition_double_to_fast = __ MakeDeferredLabel ( ) ; { __ GotoIfNot ( IsElementsKindGreaterThan ( kind , HOLEY_SMI_ELEMENTS ) , & transition_smi_array ) ; __ GotoIfNot ( IsElementsKindGreaterThan ( kind , HOLEY_ELEMENTS ) , & do_store , kind ) ; Node * value_map = __ LoadField ( AccessBuilder :: ForMap ( ) , value ) ; Node * heap_number_map = __ HeapNumberMapConstant ( ) ; Node * check = __ WordEqual ( value_map , heap_number_map ) ; __ GotoIfNot ( check , & transition_double_to_fast ) ; __ Goto ( & do_store , kind ) ; } __ Bind ( & transition_smi_array ) ; { auto if_value_not_heap_number = __ MakeLabel ( ) ; Node * value_map = __ LoadField ( AccessBuilder :: ForMap ( ) , value ) ; Node * heap_number_map = __ HeapNumberMapConstant ( ) ; Node * check = __ WordEqual ( value_map , heap_number_map ) ; __ GotoIfNot ( check , & if_value_not_heap_number ) ; { TransitionElementsTo ( node , array , HOLEY_SMI_ELEMENTS , HOLEY_DOUBLE_ELEMENTS ) ; __ Goto ( & do_store , __ Int32Constant ( HOLEY_DOUBLE_ELEMENTS ) ) ; } __ Bind ( & if_value_not_heap_number ) ; { TransitionElementsTo ( node , array , HOLEY_SMI_ELEMENTS , HOLEY_ELEMENTS ) ; __ Goto ( & do_store , __ Int32Constant ( HOLEY_ELEMENTS ) ) ; } } __ Bind ( & transition_double_to_fast ) ; { TransitionElementsTo ( node , array , HOLEY_DOUBLE_ELEMENTS , HOLEY_ELEMENTS ) ; __ Goto ( & do_store , __ Int32Constant ( HOLEY_ELEMENTS ) ) ; } __ Bind ( & do_store ) ; kind = do_store . PhiAt ( 0 ) ; Node * elements = __ LoadField ( AccessBuilder :: ForJSObjectElements ( ) , array ) ; auto if_kind_is_double = __ MakeLabel ( ) ; auto done = __ MakeLabel ( ) ; __ GotoIf ( IsElementsKindGreaterThan ( kind , HOLEY_ELEMENTS ) , & if_kind_is_double ) ; { __ StoreElement ( AccessBuilder :: ForFixedArrayElement ( HOLEY_ELEMENTS ) , elements , index , value ) ; __ Goto ( & done ) ; } __ Bind ( & if_kind_is_double ) ; { auto do_double_store = __ MakeLabel ( ) ; __ GotoIfNot ( ObjectIsSmi ( value ) , & do_double_store ) ; { Node * int_value = ChangeSmiToInt32 ( value ) ; Node * float_value = __ ChangeInt32ToFloat64 ( int_value ) ; __ StoreElement ( AccessBuilder :: ForFixedDoubleArrayElement ( ) , elements , index , float_value ) ; __ Goto ( & done ) ; } __ Bind ( & do_double_store ) ; { Node * float_value = __ LoadField ( AccessBuilder :: ForHeapNumberValue ( ) , value ) ; __ StoreElement ( AccessBuilder :: ForFixedDoubleArrayElement ( ) , elements , index , float_value ) ; __ Goto ( & done ) ; } } __ Bind ( & done ) ; }
Node * WasmGraphBuilder :: TrapIfEq32 ( wasm :: TrapReason reason , Node * node , int32_t val , wasm :: WasmCodePosition position ) { Int32Matcher m ( node ) ; if ( m . HasValue ( ) && ! m . Is ( val ) ) return graph ( ) -> start ( ) ; if ( val == 0 ) { return TrapIfFalse ( reason , node , position ) ; } else { return TrapIfTrue ( reason , graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Word32Equal ( ) , node , mcgraph ( ) -> Int32Constant ( val ) ) , position ) ; } }
tNFA_STATUS NFA_SendRawFrame ( uint8_t * p_raw_data , uint16_t data_len , uint16_t presence_check_start_delay ) { NFC_HDR * p_msg ; uint16_t size ; uint8_t * p ; DLOG_IF ( INFO , nfc_debug_enabled ) < < StringPrintf ( "data_len:%d" , data_len ) ; if ( ( data_len == 0 ) || ( p_raw_data == NULL ) ) return ( NFA_STATUS_INVALID_PARAM ) ; size = NFC_HDR_SIZE + NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE + data_len ; p_msg = ( NFC_HDR * ) GKI_getbuf ( size ) ; if ( p_msg != NULL ) { p_msg -> event = NFA_DM_API_RAW_FRAME_EVT ; p_msg -> layer_specific = presence_check_start_delay ; p_msg -> offset = NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE ; p_msg -> len = data_len ; p = ( uint8_t * ) ( p_msg + 1 ) + p_msg -> offset ; memcpy ( p , p_raw_data , data_len ) ; nfa_sys_sendmsg ( p_msg ) ; return ( NFA_STATUS_OK ) ; } return ( NFA_STATUS_FAILED ) ; }
bool icmp_global_allow ( void ) { u32 credit , delta , incr = 0 , now = ( u32 ) jiffies ; bool rc = false ; if ( ! READ_ONCE ( icmp_global . credit ) ) { delta = min_t ( u32 , now - READ_ONCE ( icmp_global . stamp ) , HZ ) ; if ( delta < HZ / 50 ) return false ; } spin_lock ( & icmp_global . lock ) ; delta = min_t ( u32 , now - icmp_global . stamp , HZ ) ; if ( delta >= HZ / 50 ) { incr = sysctl_icmp_msgs_per_sec * delta / HZ ; if ( incr ) WRITE_ONCE ( icmp_global . stamp , now ) ; } credit = min_t ( u32 , icmp_global . credit + incr , sysctl_icmp_msgs_burst ) ; if ( credit ) { credit -- ; rc = true ; } WRITE_ONCE ( icmp_global . credit , credit ) ; spin_unlock ( & icmp_global . lock ) ; return rc ; }
static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , struct sctp_association * assoc , sctp_socket_type_t type ) { struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; struct sctp_sock * newsp = sctp_sk ( newsk ) ; struct sctp_bind_bucket * pp ; struct sctp_endpoint * newep = newsp -> ep ; struct sk_buff * skb , * tmp ; struct sctp_ulpevent * event ; int flags = 0 ; newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ; inet_sk_copy_descendant ( newsk , oldsk ) ; newsp -> ep = newep ; newsp -> hmac = NULL ; pp = sctp_sk ( oldsk ) -> bind_hash ; sk_add_bind_node ( newsk , & pp -> owner ) ; sctp_sk ( newsk ) -> bind_hash = pp ; inet_sk ( newsk ) -> num = inet_sk ( oldsk ) -> num ; if ( PF_INET6 == assoc -> base . sk -> sk_family ) flags = SCTP_ADDR6_ALLOWED ; if ( assoc -> peer . ipv4_address ) flags |= SCTP_ADDR4_PEERSUPP ; if ( assoc -> peer . ipv6_address ) flags |= SCTP_ADDR6_PEERSUPP ; sctp_bind_addr_copy ( & newsp -> ep -> base . bind_addr , & oldsp -> ep -> base . bind_addr , SCTP_SCOPE_GLOBAL , GFP_KERNEL , flags ) ; sctp_skb_for_each ( skb , & oldsk -> sk_receive_queue , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { sctp_sock_rfree ( skb ) ; __skb_unlink ( skb , & oldsk -> sk_receive_queue ) ; __skb_queue_tail ( & newsk -> sk_receive_queue , skb ) ; sctp_skb_set_owner_r ( skb , newsk ) ; } } skb_queue_head_init ( & newsp -> pd_lobby ) ; sctp_sk ( newsk ) -> pd_mode = assoc -> ulpq . pd_mode ; if ( sctp_sk ( oldsk ) -> pd_mode ) { struct sk_buff_head * queue ; if ( assoc -> ulpq . pd_mode ) { queue = & newsp -> pd_lobby ; } else queue = & newsk -> sk_receive_queue ; sctp_skb_for_each ( skb , & oldsp -> pd_lobby , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { sctp_sock_rfree ( skb ) ; __skb_unlink ( skb , & oldsp -> pd_lobby ) ; __skb_queue_tail ( queue , skb ) ; sctp_skb_set_owner_r ( skb , newsk ) ; } } if ( assoc -> ulpq . pd_mode ) sctp_clear_pd ( oldsk ) ; } newsp -> type = type ; sctp_lock_sock ( newsk ) ; sctp_assoc_migrate ( assoc , newsk ) ; if ( sctp_state ( assoc , CLOSED ) && sctp_style ( newsk , TCP ) ) newsk -> sk_shutdown |= RCV_SHUTDOWN ; newsk -> sk_state = SCTP_SS_ESTABLISHED ; sctp_release_sock ( newsk ) ; }
EventStateManager :: DispatchMouseOrPointerEvent ( WidgetMouseEvent * aMouseEvent , EventMessage aMessage , nsIContent * aTargetContent , nsIContent * aRelatedContent ) { if ( sIsPointerLocked && ( aMessage == eMouseLeave || aMessage == eMouseEnter || aMessage == eMouseOver || aMessage == eMouseOut ) ) { mCurrentTargetContent = nullptr ; nsCOMPtr < Element > pointerLockedElement = do_QueryReferent ( EventStateManager :: sPointerLockedElement ) ; if ( ! pointerLockedElement ) { NS_WARNING ( "Should have pointer locked element, but didn't." ) ; return nullptr ; } nsCOMPtr < nsIContent > content = do_QueryInterface ( pointerLockedElement ) ; return mPresContext -> GetPrimaryFrameFor ( content ) ; } mCurrentTargetContent = nullptr ; if ( ! aTargetContent ) { return nullptr ; } nsAutoPtr < WidgetMouseEvent > dispatchEvent ; CreateMouseOrPointerWidgetEvent ( aMouseEvent , aMessage , aRelatedContent , dispatchEvent ) ; AutoWeakFrame previousTarget = mCurrentTarget ; mCurrentTargetContent = aTargetContent ; nsIFrame * targetFrame = nullptr ; nsEventStatus status = nsEventStatus_eIgnore ; ESMEventCB callback ( aTargetContent ) ; EventDispatcher :: Dispatch ( aTargetContent , mPresContext , dispatchEvent , nullptr , & status , & callback ) ; if ( mPresContext ) { targetFrame = mPresContext -> GetPrimaryFrameFor ( aTargetContent ) ; if ( IsRemoteTarget ( aTargetContent ) ) { if ( aMessage == eMouseOut ) { nsAutoPtr < WidgetMouseEvent > remoteEvent ; CreateMouseOrPointerWidgetEvent ( aMouseEvent , eMouseExitFromWidget , aRelatedContent , remoteEvent ) ; remoteEvent -> mExitFrom = WidgetMouseEvent :: eTopLevel ; mCurrentTarget = targetFrame ; HandleCrossProcessEvent ( remoteEvent , & status ) ; } else if ( aMessage == eMouseOver ) { nsAutoPtr < WidgetMouseEvent > remoteEvent ; CreateMouseOrPointerWidgetEvent ( aMouseEvent , eMouseEnterIntoWidget , aRelatedContent , remoteEvent ) ; HandleCrossProcessEvent ( remoteEvent , & status ) ; } } } mCurrentTargetContent = nullptr ; mCurrentTarget = previousTarget ; return targetFrame ; }
_cupsSetDefaults ( void ) { cups_file_t * fp ; const char * home ; char filename [ 1024 ] ; _cups_client_conf_t cc ; _cups_globals_t * cg = _cupsGlobals ( ) ; DEBUG_puts ( "_cupsSetDefaults()" ) ; cups_init_client_conf ( & cc ) ; snprintf ( filename , sizeof ( filename ) , "%s/client.conf" , cg -> cups_serverroot ) ; if ( ( fp = cupsFileOpen ( filename , "r" ) ) != NULL ) { cups_read_client_conf ( fp , & cc ) ; cupsFileClose ( fp ) ; } #  ifdef HAVE_GETEUID if ( ( geteuid ( ) == getuid ( ) || ! getuid ( ) ) && getegid ( ) == getgid ( ) && ( home = getenv ( "HOME" ) ) != NULL ) #  elif !defined(WIN32) if ( getuid ( ) && ( home = getenv ( "HOME" ) ) != NULL ) #  else if ( ( home = getenv ( "HOME" ) ) != NULL ) #  endif /* HAVE_GETEUID */ { snprintf ( filename , sizeof ( filename ) , "%s/.cups/client.conf" , home ) ; if ( ( fp = cupsFileOpen ( filename , "r" ) ) != NULL ) { cups_read_client_conf ( fp , & cc ) ; cupsFileClose ( fp ) ; } } cups_finalize_client_conf ( & cc ) ; if ( cg -> encryption == ( http_encryption_t ) - 1 ) cg -> encryption = cc . encryption ; if ( ! cg -> server [ 0 ] || ! cg -> ipp_port ) cupsSetServer ( cc . server_name ) ; if ( ! cg -> ipp_port ) cups_set_default_ipp_port ( cg ) ; if ( ! cg -> user [ 0 ] ) strlcpy ( cg -> user , cc . user , sizeof ( cg -> user ) ) ; #ifdef HAVE_GSSAPI if ( ! cg -> gss_service_name [ 0 ] ) strlcpy ( cg -> gss_service_name , cc . gss_service_name , sizeof ( cg -> gss_service_name ) ) ; #endif /* HAVE_GSSAPI */ if ( cg -> trust_first < 0 ) cg -> trust_first = cc . trust_first ; if ( cg -> any_root < 0 ) cg -> any_root = cc . any_root ; if ( cg -> expired_certs < 0 ) cg -> expired_certs = cc . expired_certs ; if ( cg -> validate_certs < 0 ) cg -> validate_certs = cc . validate_certs ; #ifdef HAVE_SSL _httpTLSSetOptions ( cc . ssl_options | _HTTP_TLS_SET_DEFAULT ) ; #endif /* HAVE_SSL */ }
bool M3UParser :: MediaGroup :: getActiveURI ( AString * uri ) const { for ( size_t i = 0 ; i < mMediaItems . size ( ) ; ++ i ) { if ( mSelectedIndex >= 0 && i == ( size_t ) mSelectedIndex ) { const Media & item = mMediaItems . itemAt ( i ) ; * uri = item . mURI ; return true ; } } return false ; }
std :: string ImplementationVisitor :: RValueFlattenStructs ( VisitResult result ) { if ( result . declarable ( ) ) { const Value * value = * result . declarable ( ) ; const Type * type = value -> type ( ) ; if ( const StructType * struct_type = StructType :: DynamicCast ( type ) ) { std :: stringstream s ; s < < struct_type -> name ( ) < < "{" ; PrintCommaSeparatedList ( s , struct_type -> fields ( ) , [ & ] ( const NameAndType & field ) { std :: string field_declaration = value -> name ( ) + "." + field . name ; Variable * field_variable = Variable :: cast ( declarations ( ) -> LookupValue ( field_declaration ) ) ; return RValueFlattenStructs ( VisitResult ( field_variable -> type ( ) , field_variable ) ) ; } ) ; s < < "}" ; return s . str ( ) ; } } return result . RValue ( ) ; }
static int __pyx_pf_17clickhouse_driver_14bufferedreader_24CompressedBufferedReader___init__ ( struct __pyx_obj_17clickhouse_driver_14bufferedreader_CompressedBufferedReader * __pyx_v_self , PyObject * __pyx_v_read_block , PyObject * __pyx_v_bufsize ) { int __pyx_r ; __Pyx_RefNannyDeclarations PyObject * __pyx_t_1 = NULL ; PyObject * __pyx_t_2 = NULL ; PyObject * __pyx_t_3 = NULL ; __Pyx_RefNannySetupContext ( "__init__" , 0 ) ; __Pyx_INCREF ( __pyx_v_read_block ) ; __Pyx_GIVEREF ( __pyx_v_read_block ) ; __Pyx_GOTREF ( __pyx_v_self -> read_block ) ; __Pyx_DECREF ( __pyx_v_self -> read_block ) ; __pyx_v_self -> read_block = __pyx_v_read_block ; __pyx_t_2 = PyTuple_New ( 2 ) ; if ( unlikely ( ! __pyx_t_2 ) ) __PYX_ERR ( 0 , 199 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_2 ) ; __Pyx_INCREF ( ( ( PyObject * ) __pyx_ptype_17clickhouse_driver_14bufferedreader_CompressedBufferedReader ) ) ; __Pyx_GIVEREF ( ( ( PyObject * ) __pyx_ptype_17clickhouse_driver_14bufferedreader_CompressedBufferedReader ) ) ; PyTuple_SET_ITEM ( __pyx_t_2 , 0 , ( ( PyObject * ) __pyx_ptype_17clickhouse_driver_14bufferedreader_CompressedBufferedReader ) ) ; __Pyx_INCREF ( ( ( PyObject * ) __pyx_v_self ) ) ; __Pyx_GIVEREF ( ( ( PyObject * ) __pyx_v_self ) ) ; PyTuple_SET_ITEM ( __pyx_t_2 , 1 , ( ( PyObject * ) __pyx_v_self ) ) ; __pyx_t_3 = __Pyx_PyObject_Call ( __pyx_builtin_super , __pyx_t_2 , NULL ) ; if ( unlikely ( ! __pyx_t_3 ) ) __PYX_ERR ( 0 , 199 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_3 ) ; __Pyx_DECREF ( __pyx_t_2 ) ; __pyx_t_2 = 0 ; __pyx_t_2 = __Pyx_PyObject_GetAttrStr ( __pyx_t_3 , __pyx_n_s_init ) ; if ( unlikely ( ! __pyx_t_2 ) ) __PYX_ERR ( 0 , 199 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_2 ) ; __Pyx_DECREF ( __pyx_t_3 ) ; __pyx_t_3 = 0 ; __pyx_t_3 = NULL ; if ( CYTHON_UNPACK_METHODS && likely ( PyMethod_Check ( __pyx_t_2 ) ) ) { __pyx_t_3 = PyMethod_GET_SELF ( __pyx_t_2 ) ; if ( likely ( __pyx_t_3 ) ) { PyObject * function = PyMethod_GET_FUNCTION ( __pyx_t_2 ) ; __Pyx_INCREF ( __pyx_t_3 ) ; __Pyx_INCREF ( function ) ; __Pyx_DECREF_SET ( __pyx_t_2 , function ) ; } } __pyx_t_1 = ( __pyx_t_3 ) ? __Pyx_PyObject_Call2Args ( __pyx_t_2 , __pyx_t_3 , __pyx_v_bufsize ) : __Pyx_PyObject_CallOneArg ( __pyx_t_2 , __pyx_v_bufsize ) ; __Pyx_XDECREF ( __pyx_t_3 ) ; __pyx_t_3 = 0 ; if ( unlikely ( ! __pyx_t_1 ) ) __PYX_ERR ( 0 , 199 , __pyx_L1_error ) __Pyx_GOTREF ( __pyx_t_1 ) ; __Pyx_DECREF ( __pyx_t_2 ) ; __pyx_t_2 = 0 ; __Pyx_DECREF ( __pyx_t_1 ) ; __pyx_t_1 = 0 ; __pyx_r = 0 ; goto __pyx_L0 ; __pyx_L1_error : ; __Pyx_XDECREF ( __pyx_t_1 ) ; __Pyx_XDECREF ( __pyx_t_2 ) ; __Pyx_XDECREF ( __pyx_t_3 ) ; __Pyx_AddTraceback ( "clickhouse_driver.bufferedreader.CompressedBufferedReader.__init__" , __pyx_clineno , __pyx_lineno , __pyx_filename ) ; __pyx_r = - 1 ; __pyx_L0 : ; __Pyx_RefNannyFinishContext ( ) ; return __pyx_r ; }
compiler :: CallDescriptor * GetLoweredCallDescriptor ( Zone * zone , compiler :: CallDescriptor * call_desc ) { return kPointerSize == 4 ? compiler :: GetI32WasmCallDescriptor ( zone , call_desc ) : call_desc ; }
GF_Err afra_box_read ( GF_Box * s , GF_BitStream * bs ) { unsigned int i ; GF_AdobeFragRandomAccessBox * ptr = ( GF_AdobeFragRandomAccessBox * ) s ; ISOM_DECREASE_SIZE ( ptr , 9 ) ptr -> long_ids = gf_bs_read_int ( bs , 1 ) ; ptr -> long_offsets = gf_bs_read_int ( bs , 1 ) ; ptr -> global_entries = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 5 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> entry_count = gf_bs_read_u32 ( bs ) ; if ( ptr -> size / ( ( ptr -> long_offsets ? 16 : 12 ) ) < ptr -> entry_count ) return GF_ISOM_INVALID_FILE ; for ( i = 0 ; i < ptr -> entry_count ; i ++ ) { GF_AfraEntry * ae = gf_malloc ( sizeof ( GF_AfraEntry ) ) ; if ( ! ae ) return GF_OUT_OF_MEM ; ISOM_DECREASE_SIZE ( ptr , 8 ) ae -> time = gf_bs_read_u64 ( bs ) ; if ( ptr -> long_offsets ) { ISOM_DECREASE_SIZE ( ptr , 8 ) ae -> offset = gf_bs_read_u64 ( bs ) ; } else { ISOM_DECREASE_SIZE ( ptr , 4 ) ae -> offset = gf_bs_read_u32 ( bs ) ; } gf_list_insert ( ptr -> local_access_entries , ae , i ) ; } if ( ptr -> global_entries ) { ISOM_DECREASE_SIZE ( ptr , 4 ) ptr -> global_entry_count = gf_bs_read_u32 ( bs ) ; for ( i = 0 ; i < ptr -> global_entry_count ; i ++ ) { GF_GlobalAfraEntry * ae = gf_malloc ( sizeof ( GF_GlobalAfraEntry ) ) ; if ( ! ae ) return GF_OUT_OF_MEM ; ISOM_DECREASE_SIZE ( ptr , 8 ) ae -> time = gf_bs_read_u64 ( bs ) ; if ( ptr -> long_ids ) { ISOM_DECREASE_SIZE ( ptr , 8 ) ae -> segment = gf_bs_read_u32 ( bs ) ; ae -> fragment = gf_bs_read_u32 ( bs ) ; } else { ISOM_DECREASE_SIZE ( ptr , 4 ) ae -> segment = gf_bs_read_u16 ( bs ) ; ae -> fragment = gf_bs_read_u16 ( bs ) ; } if ( ptr -> long_offsets ) { ISOM_DECREASE_SIZE ( ptr , 16 ) ae -> afra_offset = gf_bs_read_u64 ( bs ) ; ae -> offset_from_afra = gf_bs_read_u64 ( bs ) ; } else { ISOM_DECREASE_SIZE ( ptr , 8 ) ae -> afra_offset = gf_bs_read_u32 ( bs ) ; ae -> offset_from_afra = gf_bs_read_u32 ( bs ) ; } gf_list_insert ( ptr -> global_access_entries , ae , i ) ; } } return GF_OK ; }
CMD_FUNC ( m_authenticate ) { aClient * agent_p = NULL ; if ( ! SASL_SERVER || ! MyConnect ( sptr ) || BadPtr ( parv [ 1 ] ) || ! CHECKPROTO ( sptr , PROTO_SASL ) ) return 0 ; if ( sptr -> local -> sasl_complete ) { sendto_one ( sptr , err_str ( ERR_SASLALREADY ) , me . name , BadPtr ( sptr -> name ) ? "*" : sptr -> name ) ; return 0 ; } if ( strlen ( parv [ 1 ] ) > 400 ) { sendto_one ( sptr , err_str ( ERR_SASLTOOLONG ) , me . name , BadPtr ( sptr -> name ) ? "*" : sptr -> name ) ; return 0 ; } if ( * sptr -> local -> sasl_agent ) agent_p = find_client ( sptr -> local -> sasl_agent , NULL ) ; if ( agent_p == NULL ) { char * addr = BadPtr ( sptr -> ip ) ? "0" : sptr -> ip ; char * certfp = moddata_client_get ( sptr , "certfp" ) ; sendto_server ( NULL , 0 , 0 , ":%s SASL %s %s H %s %s" , me . name , SASL_SERVER , encode_puid ( sptr ) , addr , addr ) ; if ( certfp ) sendto_server ( NULL , 0 , 0 , ":%s SASL %s %s S %s %s" , me . name , SASL_SERVER , encode_puid ( sptr ) , parv [ 1 ] , certfp ) ; else sendto_server ( NULL , 0 , 0 , ":%s SASL %s %s S %s" , me . name , SASL_SERVER , encode_puid ( sptr ) , parv [ 1 ] ) ; } else sendto_server ( NULL , 0 , 0 , ":%s SASL %s %s C %s" , me . name , AGENT_SID ( agent_p ) , encode_puid ( sptr ) , parv [ 1 ] ) ; sptr -> local -> sasl_out ++ ; return 0 ; }
check_vim9_unlet ( char_u * name ) { if ( name [ 1 ] != ':' || vim_strchr ( ( char_u * ) "gwtb" , * name ) == NULL ) { if ( * name == 's' && ! script_is_vim9 ( ) ) return OK ; semsg ( _ ( e_cannot_unlet_str ) , name ) ; return FAIL ; } return OK ; }
nsresult XMLHttpRequestMainThread :: StreamReaderFunc ( nsIInputStream * in , void * closure , const char * fromRawSegment , uint32_t toOffset , uint32_t count , uint32_t * writeCount ) { XMLHttpRequestMainThread * xmlHttpRequest = static_cast < XMLHttpRequestMainThread * > ( closure ) ; if ( ! xmlHttpRequest || ! writeCount ) { NS_WARNING ( "XMLHttpRequest cannot read from stream: no closure or writeCount" ) ; return NS_ERROR_FAILURE ; } nsresult rv = NS_OK ; if ( xmlHttpRequest -> mResponseType == XMLHttpRequestResponseType :: Blob ) { xmlHttpRequest -> MaybeCreateBlobStorage ( ) ; rv = xmlHttpRequest -> mBlobStorage -> Append ( fromRawSegment , count ) ; } else if ( ( xmlHttpRequest -> mResponseType == XMLHttpRequestResponseType :: Arraybuffer && ! xmlHttpRequest -> mIsMappedArrayBuffer ) || xmlHttpRequest -> mResponseType == XMLHttpRequestResponseType :: Moz_chunked_arraybuffer ) { if ( xmlHttpRequest -> mArrayBufferBuilder . capacity ( ) == 0 ) xmlHttpRequest -> mArrayBufferBuilder . setCapacity ( std :: max ( count , XML_HTTP_REQUEST_ARRAYBUFFER_MIN_SIZE ) ) ; if ( NS_WARN_IF ( ! xmlHttpRequest -> mArrayBufferBuilder . append ( reinterpret_cast < const uint8_t * > ( fromRawSegment ) , count , XML_HTTP_REQUEST_ARRAYBUFFER_MAX_GROWTH ) ) ) { return NS_ERROR_OUT_OF_MEMORY ; } } else if ( xmlHttpRequest -> mResponseType == XMLHttpRequestResponseType :: _empty && xmlHttpRequest -> mResponseXML ) { if ( ! xmlHttpRequest -> mResponseBody . Append ( fromRawSegment , count , fallible ) ) { return NS_ERROR_OUT_OF_MEMORY ; } } else if ( xmlHttpRequest -> mResponseType == XMLHttpRequestResponseType :: _empty || xmlHttpRequest -> mResponseType == XMLHttpRequestResponseType :: Text || xmlHttpRequest -> mResponseType == XMLHttpRequestResponseType :: Json ) { MOZ_ASSERT ( ! xmlHttpRequest -> mResponseXML , "We shouldn't be parsing a doc here" ) ; rv = xmlHttpRequest -> AppendToResponseText ( AsBytes ( MakeSpan ( fromRawSegment , count ) ) ) ; if ( NS_WARN_IF ( NS_FAILED ( rv ) ) ) { return rv ; } } if ( xmlHttpRequest -> mFlagParseBody ) { nsCOMPtr < nsIInputStream > copyStream ; rv = NS_NewByteInputStream ( getter_AddRefs ( copyStream ) , fromRawSegment , count ) ; if ( NS_SUCCEEDED ( rv ) && xmlHttpRequest -> mXMLParserStreamListener ) { NS_ASSERTION ( copyStream , "NS_NewByteInputStream lied" ) ; nsresult parsingResult = xmlHttpRequest -> mXMLParserStreamListener -> OnDataAvailable ( xmlHttpRequest -> mChannel , xmlHttpRequest -> mContext , copyStream , toOffset , count ) ; if ( NS_FAILED ( parsingResult ) ) { xmlHttpRequest -> mFlagParseBody = false ; } } } if ( NS_SUCCEEDED ( rv ) ) { * writeCount = count ; } else { * writeCount = 0 ; } return rv ; }
bool WddxPacket :: recursiveAddVar ( const String & varName , const Variant & varVariant , bool hasVarTag ) { bool isArray = varVariant . isArray ( ) ; bool isObject = varVariant . isObject ( ) ; if ( isArray || isObject ) { if ( hasVarTag ) { m_packetString . append ( "<var name='" ) ; m_packetString . append ( varName . data ( ) ) ; m_packetString . append ( "'>" ) ; } Array varAsArray ; Object varAsObject = varVariant . toObject ( ) ; if ( isArray ) varAsArray = varVariant . toArray ( ) ; if ( isObject ) varAsArray = varAsObject . toArray ( ) ; int length = varAsArray . length ( ) ; if ( length > 0 ) { ArrayIter it = ArrayIter ( varAsArray ) ; if ( it . first ( ) . isString ( ) ) isObject = true ; if ( isObject ) { m_packetString . append ( "<struct>" ) ; if ( ! isArray ) { m_packetString . append ( "<var name='php_class_name'><string>" ) ; m_packetString . append ( varAsObject -> getClassName ( ) ) ; m_packetString . append ( "</string></var>" ) ; } } else { m_packetString . append ( "<array length='" ) ; m_packetString . append ( std :: to_string ( length ) ) ; m_packetString . append ( "'>" ) ; } for ( ArrayIter it ( varAsArray ) ; it ; ++ it ) { Variant key = it . first ( ) ; Variant value = it . second ( ) ; recursiveAddVar ( key . toString ( ) , value , isObject ) ; } if ( isObject ) { m_packetString . append ( "</struct>" ) ; } else { m_packetString . append ( "</array>" ) ; } } else { if ( isObject ) { m_packetString . append ( "<struct>" ) ; if ( ! isArray ) { m_packetString . append ( "<var name='php_class_name'><string>" ) ; m_packetString . append ( varAsObject -> getClassName ( ) ) ; m_packetString . append ( "</string></var>" ) ; } m_packetString . append ( "</struct>" ) ; } } if ( hasVarTag ) { m_packetString . append ( "</var>" ) ; } return true ; } String varType = getDataTypeString ( varVariant . getType ( ) ) ; if ( ! getWddxEncoded ( varType , "" , varName , false ) . empty ( ) ) { String varValue ; if ( varType . compare ( "boolean" ) == 0 ) { varValue = varVariant . toBoolean ( ) ? "true" : "false" ; } else { varValue = StringUtil :: HtmlEncode ( varVariant . toString ( ) , StringUtil :: QuoteStyle :: Double , "UTF-8" , false , false ) . toCppString ( ) ; } m_packetString . append ( getWddxEncoded ( varType , varValue , varName , hasVarTag ) ) ; return true ; } return false ; }
RUNTIME_FUNCTION ( Runtime_RegExpInternalReplace ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 3 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSRegExp , regexp , 0 ) ; CONVERT_ARG_HANDLE_CHECKED ( String , subject , 1 ) ; CONVERT_ARG_HANDLE_CHECKED ( String , replacement , 2 ) ; Handle < RegExpMatchInfo > internal_match_info = isolate -> regexp_internal_match_info ( ) ; return StringReplaceGlobalRegExpWithStringHelper ( isolate , regexp , subject , replacement , internal_match_info ) ; }
% % o image : The image . % % o exception : return any errors or warnings in this structure . % * / static MagickBooleanType WriteINLINEImage ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { char * base64 , message [ MagickPathExtent ] ; const MagickInfo * magick_info ; Image * write_image ; ImageInfo * write_info ; MagickBooleanType status ; size_t blob_length , encode_length ; unsigned char * blob ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image -> filename ) ; write_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfo ( write_info , 1 , exception ) ; if ( LocaleCompare ( write_info -> magick , "INLINE" ) == 0 ) ( void ) CopyMagickString ( write_info -> magick , image -> magick , MagickPathExtent ) ; magick_info = GetMagickInfo ( write_info -> magick , exception ) ; if ( ( magick_info == ( const MagickInfo * ) NULL ) || ( GetMagickMimeType ( magick_info ) == ( const char * ) NULL ) ) ThrowWriterException ( CorruptImageError , "ImageTypeNotSupported" ) ; ( void ) CopyMagickString ( image -> filename , write_info -> filename , MagickPathExtent ) ; blob_length = 2048 ; write_image = CloneImage ( image , 0 , 0 , MagickTrue , exception ) ; if ( write_image == ( Image * ) NULL ) { write_info = DestroyImageInfo ( write_info ) ; return ( MagickTrue ) ; } blob = ( unsigned char * ) ImageToBlob ( write_info , write_image , & blob_length , exception ) ; write_image = DestroyImage ( write_image ) ; write_info = DestroyImageInfo ( write_info ) ; if ( blob == ( unsigned char * ) NULL ) return ( MagickFalse ) ; encode_length = 0 ; base64 = Base64Encode ( blob , blob_length , & encode_length ) ; blob = ( unsigned char * ) RelinquishMagickMemory ( blob ) ; if ( base64 == ( char * ) NULL ) ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; status = OpenBlob ( image_info , image , WriteBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { base64 = DestroyString ( base64 ) ; return ( status ) ; } ( void ) FormatLocaleString ( message , MagickPathExtent , "data:%s;base64," ,
static void perform_gamma_transform_tests ( png_modifier * pm ) { png_byte colour_type = 0 ; png_byte bit_depth = 0 ; unsigned int palette_number = 0 ; while ( next_format ( & colour_type , & bit_depth , & palette_number , 1 ) ) { unsigned int i , j ; for ( i = 0 ; i < pm -> ngamma_tests ; ++ i ) for ( j = 0 ; j < pm -> ngamma_tests ; ++ j ) if ( i != j ) { gamma_transform_test ( pm , colour_type , bit_depth , palette_number , pm -> interlace_type , 1 / pm -> gammas [ i ] , pm -> gammas [ j ] , 0 , pm -> use_input_precision , 0 ) ; if ( fail ( pm ) ) return ; } } }
ScriptLoaderRunnable ( WorkerPrivate * aWorkerPrivate , nsIEventTarget * aSyncLoopTarget , nsTArray < ScriptLoadInfo > & aLoadInfos , bool aIsMainScript , WorkerScriptType aWorkerScriptType ) : mWorkerPrivate ( aWorkerPrivate ) , mSyncLoopTarget ( aSyncLoopTarget ) , mIsMainScript ( aIsMainScript ) , mWorkerScriptType ( aWorkerScriptType ) , mCanceled ( false ) , mCanceledMainThread ( false ) { aWorkerPrivate -> AssertIsOnWorkerThread ( ) ; MOZ_ASSERT ( aSyncLoopTarget ) ; MOZ_ASSERT_IF ( aIsMainScript , aLoadInfos . Length ( ) == 1 ) ; mLoadInfos . SwapElements ( aLoadInfos ) ; }
CairoTextureClientD3D9 :: BorrowDrawTarget ( ) { MOZ_ASSERT ( mIsLocked && mD3D9Surface ) ; if ( ! mIsLocked || ! mD3D9Surface ) { NS_WARNING ( "Calling BorrowDrawTarget on an Unlocked TextureClient" ) ; return nullptr ; } if ( mDrawTarget ) { return mDrawTarget ; } if ( ContentForFormat ( mFormat ) == gfxContentType :: COLOR ) { mSurface = new gfxWindowsSurface ( mD3D9Surface ) ; if ( ! mSurface || mSurface -> CairoStatus ( ) ) { NS_WARNING ( "Could not create surface for d3d9 surface" ) ; mSurface = nullptr ; return nullptr ; } } else { D3DLOCKED_RECT rect ; mD3D9Surface -> LockRect ( & rect , nullptr , 0 ) ; mSurface = new gfxImageSurface ( ( uint8_t * ) rect . pBits , mSize , rect . Pitch , SurfaceFormatToImageFormat ( mFormat ) ) ; mLockRect = true ; } mDrawTarget = gfxPlatform :: GetPlatform ( ) -> CreateDrawTargetForSurface ( mSurface , mSize ) ; return mDrawTarget ; }
status_t SampleTable :: setCompositionTimeToSampleParams ( off64_t data_offset , size_t data_size ) { ALOGI ( "There are reordered frames present." ) ; if ( mCompositionTimeDeltaEntries != NULL || data_size < 8 ) { return ERROR_MALFORMED ; } uint8_t header [ 8 ] ; if ( mDataSource -> readAt ( data_offset , header , sizeof ( header ) ) < ( ssize_t ) sizeof ( header ) ) { return ERROR_IO ; } if ( U32_AT ( header ) != 0 ) { return ERROR_MALFORMED ; } size_t numEntries = U32_AT ( & header [ 4 ] ) ; if ( data_size != ( numEntries + 1 ) * 8 ) { return ERROR_MALFORMED ; } mNumCompositionTimeDeltaEntries = numEntries ; uint64_t allocSize = numEntries * 2 * sizeof ( uint32_t ) ; if ( allocSize > SIZE_MAX ) { return ERROR_OUT_OF_RANGE ; } mCompositionTimeDeltaEntries = new uint32_t [ 2 * numEntries ] ; if ( mDataSource -> readAt ( data_offset + 8 , mCompositionTimeDeltaEntries , numEntries * 8 ) < ( ssize_t ) numEntries * 8 ) { delete [ ] mCompositionTimeDeltaEntries ; mCompositionTimeDeltaEntries = NULL ; return ERROR_IO ; } for ( size_t i = 0 ; i < 2 * numEntries ; ++ i ) { mCompositionTimeDeltaEntries [ i ] = ntohl ( mCompositionTimeDeltaEntries [ i ] ) ; } mCompositionDeltaLookup -> setEntries ( mCompositionTimeDeltaEntries , mNumCompositionTimeDeltaEntries ) ; return OK ; }
WebGLContext :: TexImage2D ( GLenum target , GLint level , GLenum internalformat , GLsizei width , GLsizei height , GLint border , GLenum format , GLenum type , const Nullable < ArrayBufferView > & pixels , ErrorResult & rv ) { if ( IsContextLost ( ) ) return ; return TexImage2D_base ( target , level , internalformat , width , height , 0 , border , format , type , pixels . IsNull ( ) ? 0 : pixels . Value ( ) . Data ( ) , pixels . IsNull ( ) ? 0 : pixels . Value ( ) . Length ( ) , pixels . IsNull ( ) ? - 1 : ( int ) JS_GetArrayBufferViewType ( pixels . Value ( ) . Obj ( ) ) , WebGLTexelFormat :: Auto , false ) ; }
void Compute ( OpKernelContext * context ) override { Tensor encoded_t = context -> input ( 0 ) ; auto * encoded = encoded_t . flat < Variant > ( ) ( 0 ) . get < CompositeTensorVariant > ( ) ; auto expected_class = metadata_ . type_spec_proto ( ) . type_spec_class ( ) ; auto actual_class = encoded -> metadata ( ) . type_spec_proto ( ) . type_spec_class ( ) ; OP_REQUIRES ( context , expected_class == actual_class , errors :: InvalidArgument ( "Expected a " , TypeSpecProto :: TypeSpecClass_Name ( expected_class ) , " (based on `type_spec`), but `encoded` contains a " , TypeSpecProto :: TypeSpecClass_Name ( actual_class ) ) ) ; OpOutputList components ; OP_REQUIRES_OK ( context , context -> output_list ( "components" , & components ) ) ; int num_components = encoded -> flat_components ( ) . size ( ) ; OP_REQUIRES ( context , component_dtypes_ . size ( ) == num_components , errors :: InvalidArgument ( "Encoded value has " , num_components , " tensor components; expected " , component_dtypes_ . size ( ) , " components based on type_spec" ) ) ; for ( int i = 0 ; i < component_dtypes_ . size ( ) ; i ++ ) { const Tensor & component = encoded -> flat_components ( ) [ i ] ; OP_REQUIRES ( context , component_dtypes_ [ i ] == component . dtype ( ) , errors :: InvalidArgument ( "Tensor component " , i , " had dtype " , DataType_Name ( component . dtype ( ) ) , "; expected dtype " , DataType_Name ( component_dtypes_ [ i ] ) ) ) ; components . set ( i , component ) ; } }
nsDocument :: SetScriptGlobalObject ( nsIScriptGlobalObject * aScriptGlobalObject ) { #ifdef DEBUG { nsCOMPtr < nsPIDOMWindowInner > win ( do_QueryInterface ( aScriptGlobalObject ) ) ; NS_ASSERTION ( ! win || win -> IsInnerWindow ( ) , "Script global object must be an inner window!" ) ; } #endif MOZ_ASSERT ( aScriptGlobalObject || ! mAnimationController || mAnimationController -> IsPausedByType ( nsSMILTimeContainer :: PAUSE_PAGEHIDE | nsSMILTimeContainer :: PAUSE_BEGIN ) , "Clearing window pointer while animations are unpaused" ) ; if ( mScriptGlobalObject && ! aScriptGlobalObject ) { mLayoutHistoryState = GetLayoutHistoryState ( ) ; if ( mPresShell && ! EventHandlingSuppressed ( ) && ! AnimationsPaused ( ) ) { RevokeAnimationFrameNotifications ( ) ; } if ( mOnloadBlockCount != 0 ) { nsCOMPtr < nsILoadGroup > loadGroup = GetDocumentLoadGroup ( ) ; if ( loadGroup ) { loadGroup -> RemoveRequest ( mOnloadBlocker , nullptr , NS_OK ) ; } } using mozilla :: dom :: workers :: ServiceWorkerManager ; RefPtr < ServiceWorkerManager > swm = ServiceWorkerManager :: GetInstance ( ) ; if ( swm ) { ErrorResult error ; if ( swm -> IsControlled ( this , error ) ) { imgLoader * loader = nsContentUtils :: GetImgLoaderForDocument ( this ) ; if ( loader ) { loader -> ClearCacheForControlledDocument ( this ) ; } mMaybeServiceWorkerControlled = false ; } swm -> MaybeStopControlling ( this ) ; } if ( ! nsContentUtils :: IsSystemPrincipal ( GetPrincipal ( ) ) && ! GetPrincipal ( ) -> GetIsNullPrincipal ( ) ) { nsCOMPtr < nsIObserverService > os = mozilla :: services :: GetObserverService ( ) ; if ( os ) { os -> RemoveObserver ( this , "service-worker-get-client" ) ; } } } else if ( ! mScriptGlobalObject && aScriptGlobalObject && mDocumentContainer && GetChannel ( ) && ! nsContentUtils :: IsSystemPrincipal ( GetPrincipal ( ) ) && ! GetPrincipal ( ) -> GetIsNullPrincipal ( ) ) { nsCOMPtr < nsIObserverService > os = mozilla :: services :: GetObserverService ( ) ; if ( os ) { os -> AddObserver ( this , "service-worker-get-client" , false ) ; } } mScriptGlobalObject = aScriptGlobalObject ; if ( aScriptGlobalObject ) { mLayoutHistoryState = nullptr ; SetScopeObject ( aScriptGlobalObject ) ; mHasHadDefaultView = true ; #ifdef DEBUG if ( ! mWillReparent ) { JSObject * obj = GetWrapperPreserveColor ( ) ; if ( obj ) { JSObject * newScope = aScriptGlobalObject -> GetGlobalJSObject ( ) ; NS_ASSERTION ( js :: GetGlobalForObjectCrossCompartment ( obj ) == newScope , "Wrong scope, this is really bad!" ) ; } } #endif if ( mAllowDNSPrefetch ) { nsCOMPtr < nsIDocShell > docShell ( mDocumentContainer ) ; if ( docShell ) { #ifdef DEBUG nsCOMPtr < nsIWebNavigation > webNav = do_GetInterface ( aScriptGlobalObject ) ; NS_ASSERTION ( SameCOMIdentity ( webNav , docShell ) , "Unexpected container or script global?" ) ; #endif bool allowDNSPrefetch ; docShell -> GetAllowDNSPrefetch ( & allowDNSPrefetch ) ; mAllowDNSPrefetch = allowDNSPrefetch ; } } MaybeRescheduleAnimationFrameNotifications ( ) ; } nsCOMPtr < nsPIDOMWindowInner > window = do_QueryInterface ( mScriptGlobalObject ) ; mWindow = window ; nsCOMPtr < nsIContentSecurityPolicy > csp ; NodePrincipal ( ) -> GetCsp ( getter_AddRefs ( csp ) ) ; if ( csp ) { static_cast < nsCSPContext * > ( csp . get ( ) ) -> flushConsoleMessages ( ) ; } nsCOMPtr < nsIHttpChannelInternal > internalChannel = do_QueryInterface ( GetChannel ( ) ) ; if ( internalChannel ) { nsCOMArray < nsISecurityConsoleMessage > messages ; internalChannel -> TakeAllSecurityMessages ( messages ) ; SendToConsole ( messages ) ; } dom :: VisibilityState oldState = mVisibilityState ; mVisibilityState = GetVisibilityState ( ) ; if ( oldState != mVisibilityState ) { EnumerateActivityObservers ( NotifyActivityChanged , nullptr ) ; } if ( mTemplateContentsOwner && mTemplateContentsOwner != this ) { mTemplateContentsOwner -> SetScriptGlobalObject ( aScriptGlobalObject ) ; } if ( ! mMaybeServiceWorkerControlled && mDocumentContainer && mScriptGlobalObject && GetChannel ( ) ) { nsCOMPtr < nsIDocShell > docShell ( mDocumentContainer ) ; uint32_t loadType ; docShell -> GetLoadType ( & loadType ) ; if ( IsForceReloadType ( loadType ) ) { NS_WARNING ( "Page was shift reloaded, skipping ServiceWorker control" ) ; return ; } nsCOMPtr < nsIServiceWorkerManager > swm = mozilla :: services :: GetServiceWorkerManager ( ) ; if ( swm ) { nsString documentId ( GetId ( ) ) ; if ( documentId . IsEmpty ( ) ) { static_cast < nsDocShell * > ( docShell . get ( ) ) -> GetInterceptedDocumentId ( documentId ) ; } swm -> MaybeStartControlling ( this , documentId ) ; mMaybeServiceWorkerControlled = true ; } } }
static ssize_t ext4_ext_direct_IO ( int rw , struct kiocb * iocb , const struct iovec * iov , loff_t offset , unsigned long nr_segs ) { struct file * file = iocb -> ki_filp ; struct inode * inode = file -> f_mapping -> host ; ssize_t ret ; size_t count = iov_length ( iov , nr_segs ) ; loff_t final_size = offset + count ; if ( rw == WRITE && final_size <= inode -> i_size ) { iocb -> private = NULL ; EXT4_I ( inode ) -> cur_aio_dio = NULL ; if ( ! is_sync_kiocb ( iocb ) ) { iocb -> private = ext4_init_io_end ( inode ) ; if ( ! iocb -> private ) return - ENOMEM ; EXT4_I ( inode ) -> cur_aio_dio = iocb -> private ; } ret = blockdev_direct_IO ( rw , iocb , inode , inode -> i_sb -> s_bdev , iov , offset , nr_segs , ext4_get_block_write , ext4_end_io_dio ) ; if ( iocb -> private ) EXT4_I ( inode ) -> cur_aio_dio = NULL ; if ( ret != - EIOCBQUEUED && ret <= 0 && iocb -> private ) { ext4_free_io_end ( iocb -> private ) ; iocb -> private = NULL ; } else if ( ret > 0 && ext4_test_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ) { int err ; err = ext4_convert_unwritten_extents ( inode , offset , ret ) ; if ( err < 0 ) ret = err ; ext4_clear_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; } return ret ; } return ext4_ind_direct_IO ( rw , iocb , iov , offset , nr_segs ) ; }
void BinaryOpSmiWithFeedback ( BinaryOpGenerator generator ) { Node * lhs = GetAccumulator ( ) ; Node * rhs = BytecodeOperandImmSmi ( 0 ) ; Node * context = GetContext ( ) ; Node * slot_index = BytecodeOperandIdx ( 1 ) ; Node * feedback_vector = LoadFeedbackVector ( ) ; BinaryOpAssembler binop_asm ( state ( ) ) ; Node * result = ( binop_asm .* generator ) ( context , lhs , rhs , slot_index , feedback_vector , true ) ; SetAccumulator ( result ) ; Dispatch ( ) ; }
void SoundTriggerHwService :: Module :: detach ( const sp < ModuleClient > & moduleClient ) { ALOGV ( "Module::detach()" ) ; AutoMutex lock ( mLock ) ; ssize_t index = - 1 ; for ( size_t i = 0 ; i < mModuleClients . size ( ) ; i ++ ) { if ( mModuleClients [ i ] == moduleClient ) { index = i ; break ; } } if ( index == - 1 ) { return ; } ALOGV ( "remove client %p" , moduleClient . get ( ) ) ; mModuleClients . removeAt ( index ) ; for ( size_t i = mModels . size ( ) ; i > 0 ; i -- ) { sp < Model > model = mModels . valueAt ( i - 1 ) ; if ( moduleClient == model -> mModuleClient ) { mModels . removeItemsAt ( i - 1 ) ; ALOGV ( "detach() unloading model %d" , model -> mHandle ) ; if ( mHalInterface != 0 ) { if ( model -> mState == Model :: STATE_ACTIVE ) { mHalInterface -> stopRecognition ( model -> mHandle ) ; } mHalInterface -> unloadSoundModel ( model -> mHandle ) ; } AudioSystem :: releaseSoundTriggerSession ( model -> mCaptureSession ) ; mHalInterface -> unloadSoundModel ( model -> mHandle ) ; } } }
void RegExpMacroAssemblerMIPS :: CallCheckStackGuardState ( Register scratch ) { int stack_alignment = base :: OS :: ActivationFrameAlignment ( ) ; __ mov ( scratch , sp ) ; __ Subu ( sp , sp , Operand ( kPointerSize ) ) ; DCHECK ( base :: bits :: IsPowerOfTwo ( stack_alignment ) ) ; __ And ( sp , sp , Operand ( - stack_alignment ) ) ; __ sw ( scratch , MemOperand ( sp ) ) ; __ mov ( a2 , frame_pointer ( ) ) ; __ li ( a1 , Operand ( masm_ -> CodeObject ( ) ) , CONSTANT_SIZE ) ; DCHECK ( IsAligned ( stack_alignment , kPointerSize ) ) ; __ Subu ( sp , sp , Operand ( stack_alignment ) ) ; __ mov ( a0 , sp ) ; ExternalReference stack_guard_check = ExternalReference :: re_check_stack_guard_state ( masm_ -> isolate ( ) ) ; __ li ( t9 , Operand ( stack_guard_check ) ) ; DirectCEntryStub stub ( isolate ( ) ) ; stub . GenerateCall ( masm_ , t9 ) ; __ lw ( sp , MemOperand ( sp , stack_alignment + kCArgsSlotsSize ) ) ; __ li ( code_pointer ( ) , Operand ( masm_ -> CodeObject ( ) ) ) ; }
static int journal_unmap_buffer ( journal_t * journal , struct buffer_head * bh ) { transaction_t * transaction ; struct journal_head * jh ; int may_free = 1 ; int ret ; BUFFER_TRACE ( bh , "entry" ) ; if ( ! buffer_jbd ( bh ) ) goto zap_buffer_unlocked ; write_lock ( & journal -> j_state_lock ) ; jbd_lock_bh_state ( bh ) ; spin_lock ( & journal -> j_list_lock ) ; jh = jbd2_journal_grab_journal_head ( bh ) ; if ( ! jh ) goto zap_buffer_no_jh ; transaction = jh -> b_transaction ; if ( transaction == NULL ) { if ( ! jh -> b_cp_transaction ) { JBUFFER_TRACE ( jh , "not on any transaction: zap" ) ; goto zap_buffer ; } if ( ! buffer_dirty ( bh ) ) { goto zap_buffer ; } if ( journal -> j_running_transaction ) { JBUFFER_TRACE ( jh , "checkpointed: add to BJ_Forget" ) ; ret = __dispose_buffer ( jh , journal -> j_running_transaction ) ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return ret ; } else { if ( journal -> j_committing_transaction ) { JBUFFER_TRACE ( jh , "give to committing trans" ) ; ret = __dispose_buffer ( jh , journal -> j_committing_transaction ) ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return ret ; } else { clear_buffer_jbddirty ( bh ) ; goto zap_buffer ; } } } else if ( transaction == journal -> j_committing_transaction ) { JBUFFER_TRACE ( jh , "on committing transaction" ) ; set_buffer_freed ( bh ) ; if ( journal -> j_running_transaction && buffer_jbddirty ( bh ) ) jh -> b_next_transaction = journal -> j_running_transaction ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return 0 ; } else { J_ASSERT_JH ( jh , transaction == journal -> j_running_transaction ) ; JBUFFER_TRACE ( jh , "on running transaction" ) ; may_free = __dispose_buffer ( jh , transaction ) ; } zap_buffer : jbd2_journal_put_journal_head ( jh ) ; zap_buffer_no_jh : spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; zap_buffer_unlocked : clear_buffer_dirty ( bh ) ; J_ASSERT_BH ( bh , ! buffer_jbddirty ( bh ) ) ; clear_buffer_mapped ( bh ) ; clear_buffer_req ( bh ) ; clear_buffer_new ( bh ) ; bh -> b_bdev = NULL ; return may_free ; }
TfLiteStatus PreluPrepare ( TfLiteContext * context , TfLiteNode * node ) { TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 2 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; const TfLiteTensor * input = GetInput ( context , node , 0 ) ; TfLiteTensor * output = GetOutput ( context , node , 0 ) ; const TfLiteTensor * alpha = GetInput ( context , node , 1 ) ; PreluOpData * data = reinterpret_cast < PreluOpData * > ( node -> user_data ) ; TF_LITE_ENSURE_TYPES_EQ ( context , input -> type , alpha -> type ) ; output -> type = input -> type ; if ( output -> type == kTfLiteUInt8 || output -> type == kTfLiteInt8 || output -> type == kTfLiteInt16 ) { double real_multiplier_1 = input -> params . scale / output -> params . scale ; double real_multiplier_2 = input -> params . scale * alpha -> params . scale / output -> params . scale ; QuantizeMultiplier ( real_multiplier_1 , & data -> output_multiplier_1 , & data -> output_shift_1 ) ; QuantizeMultiplier ( real_multiplier_2 , & data -> output_multiplier_2 , & data -> output_shift_2 ) ; } data -> requires_broadcast = ! HaveSameShapes ( input , alpha ) ; TfLiteIntArray * output_size = nullptr ; TF_LITE_ENSURE_OK ( context , CalculateShapeForBroadcast ( context , input , alpha , & output_size ) ) ; TF_LITE_ENSURE_OK ( context , context -> ResizeTensor ( context , output , output_size ) ) ; TF_LITE_ENSURE ( context , HaveSameShapes ( input , output ) ) ; return kTfLiteOk ; }
* d += ( size_t ) b * 256l ; return ; } static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) { ExceptionInfo * exception ; int bit ; ssize_t x ; register PixelPacket * q ; IndexPacket index ; register IndexPacket * indexes ; exception = ( & image -> exception ) ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 > > bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 > > bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p > > 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p > > 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p > > 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p > > 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p > > 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p > > 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p > > 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p > > 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) )
void FetchBody < Derived > :: SetBodyUsed ( JSContext * aCx , ErrorResult & aRv ) { MOZ_ASSERT ( aCx ) ; MOZ_ASSERT ( mOwner -> EventTargetFor ( TaskCategory :: Other ) -> IsOnCurrentThread ( ) ) ; if ( mBodyUsed ) { return ; } mBodyUsed = true ; if ( mReadableStreamBody ) { aRv . MightThrowJSException ( ) ; JS :: Rooted < JSObject * > readableStreamObj ( aCx , mReadableStreamBody ) ; JS :: ReadableStreamMode mode ; if ( ! JS :: ReadableStreamGetMode ( aCx , readableStreamObj , & mode ) ) { aRv . StealExceptionFromJSContext ( aCx ) ; return ; } if ( mode == JS :: ReadableStreamMode :: ExternalSource ) { LockStream ( aCx , readableStreamObj , aRv ) ; if ( NS_WARN_IF ( aRv . Failed ( ) ) ) { return ; } } else { MOZ_ASSERT ( mFetchStreamReader ) ; JS :: Rooted < JSObject * > reader ( aCx ) ; mFetchStreamReader -> StartConsuming ( aCx , readableStreamObj , & reader , aRv ) ; if ( NS_WARN_IF ( aRv . Failed ( ) ) ) { return ; } mReadableStreamReader = reader ; } } }
static int __init mbochs_dev_init ( void ) { int ret = 0 ; ret = alloc_chrdev_region ( & mbochs_devt , 0 , MINORMASK + 1 , MBOCHS_NAME ) ; if ( ret < 0 ) { pr_err ( "Error: failed to register mbochs_dev, err: %d\n" , ret ) ; return ret ; } cdev_init ( & mbochs_cdev , & vd_fops ) ; cdev_add ( & mbochs_cdev , mbochs_devt , MINORMASK + 1 ) ; pr_info ( "%s: major %d\n" , __func__ , MAJOR ( mbochs_devt ) ) ; ret = mdev_register_driver ( & mbochs_driver ) ; if ( ret ) goto err_cdev ; mbochs_class = class_create ( THIS_MODULE , MBOCHS_CLASS_NAME ) ; if ( IS_ERR ( mbochs_class ) ) { pr_err ( "Error: failed to register mbochs_dev class\n" ) ; ret = PTR_ERR ( mbochs_class ) ; goto err_driver ; } mbochs_dev . class = mbochs_class ; mbochs_dev . release = mbochs_device_release ; dev_set_name ( & mbochs_dev , "%s" , MBOCHS_NAME ) ; ret = device_register ( & mbochs_dev ) ; if ( ret ) goto err_class ; ret = mdev_register_device ( & mbochs_dev , & mdev_fops ) ; if ( ret ) goto err_device ; return 0 ; err_device : device_unregister ( & mbochs_dev ) ; err_class : class_destroy ( mbochs_class ) ; err_driver : mdev_unregister_driver ( & mbochs_driver ) ; err_cdev : cdev_del ( & mbochs_cdev ) ; unregister_chrdev_region ( mbochs_devt , MINORMASK + 1 ) ; return ret ; }
nsBlockFrame :: StealFrame ( nsPresContext * aPresContext , nsIFrame * aChild , bool aForceNormal ) { NS_PRECONDITION ( aPresContext && aChild , "null pointer" ) ; if ( ( aChild -> GetStateBits ( ) & NS_FRAME_OUT_OF_FLOW ) && aChild -> GetStyleDisplay ( ) -> IsFloating ( ) ) { bool removed = mFloats . RemoveFrameIfPresent ( aChild ) ; if ( ! removed ) { nsFrameList * list = GetPushedFloats ( ) ; if ( list ) { removed = list -> RemoveFrameIfPresent ( aChild ) ; } } return removed ? NS_OK : NS_ERROR_UNEXPECTED ; } if ( ( aChild -> GetStateBits ( ) & NS_FRAME_IS_OVERFLOW_CONTAINER ) && ! aForceNormal ) return nsContainerFrame :: StealFrame ( aPresContext , aChild ) ; nsLineList :: iterator line = mLines . begin ( ) , line_start = line , line_end = mLines . end ( ) ; bool searchingOverflowList = false ; FrameLines * overflowLines = nsnull ; nsIFrame * prevSibling = nsnull ; TryAllLines ( & line , & line_start , & line_end , & searchingOverflowList , & overflowLines ) ; while ( line != line_end ) { nsIFrame * frame = line -> mFirstChild ; PRInt32 n = line -> GetChildCount ( ) ; while ( -- n >= 0 ) { if ( frame == aChild ) { if ( frame == line -> mFirstChild ) { line -> mFirstChild = frame -> GetNextSibling ( ) ; } if ( searchingOverflowList ) { overflowLines -> mFrames . RemoveFrame ( frame ) ; } else { mFrames . RemoveFrame ( frame ) ; } line -> NoteFrameRemoved ( frame ) ; if ( line -> GetChildCount ( ) > 0 ) { line -> MarkDirty ( ) ; } else { nsLineBox * lineBox = line ; if ( searchingOverflowList ) { RemoveOverflowLines ( ) ; line = overflowLines -> mLines . erase ( line ) ; if ( ! overflowLines -> mLines . empty ( ) ) { SetOverflowLines ( overflowLines ) ; } else { delete overflowLines ; line_start = mLines . begin ( ) ; line_end = mLines . end ( ) ; line = line_end ; } } else { line = mLines . erase ( line ) ; } lineBox -> Destroy ( aPresContext -> PresShell ( ) ) ; if ( line != line_end ) { line -> MarkPreviousMarginDirty ( ) ; } } return NS_OK ; } prevSibling = frame ; frame = frame -> GetNextSibling ( ) ; } ++ line ; TryAllLines ( & line , & line_start , & line_end , & searchingOverflowList , & overflowLines ) ; if ( prevSibling && ! prevSibling -> GetNextSibling ( ) ) { prevSibling = nsnull ; } } return NS_ERROR_UNEXPECTED ; }
varbit_in ( PG_FUNCTION_ARGS ) { char * input_string = PG_GETARG_CSTRING ( 0 ) ; #ifdef NOT_USED Oid typelem = PG_GETARG_OID ( 1 ) ; #endif int32 atttypmod = PG_GETARG_INT32 ( 2 ) ; VarBit * result ; char * sp ; bits8 * r ; int len , bitlen , slen ; bool bit_not_hex ; int bc ; bits8 x = 0 ; if ( input_string [ 0 ] == 'b' || input_string [ 0 ] == 'B' ) { bit_not_hex = true ; sp = input_string + 1 ; } else if ( input_string [ 0 ] == 'x' || input_string [ 0 ] == 'X' ) { bit_not_hex = false ; sp = input_string + 1 ; } else { bit_not_hex = true ; sp = input_string ; } slen = strlen ( sp ) ; if ( bit_not_hex ) bitlen = slen ; else bitlen = slen * 4 ; if ( atttypmod <= 0 ) atttypmod = bitlen ; else if ( bitlen > atttypmod ) ereport ( ERROR , ( errcode ( ERRCODE_STRING_DATA_RIGHT_TRUNCATION ) , errmsg ( "bit string too long for type bit varying(%d)" , atttypmod ) ) ) ; len = VARBITTOTALLEN ( bitlen ) ; result = ( VarBit * ) palloc0 ( len ) ; SET_VARSIZE ( result , len ) ; VARBITLEN ( result ) = Min ( bitlen , atttypmod ) ; r = VARBITS ( result ) ; if ( bit_not_hex ) { x = HIGHBIT ; for ( ; * sp ; sp ++ ) { if ( * sp == '1' ) * r |= x ; else if ( * sp != '0' ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( "\"%c\" is not a valid binary digit" , * sp ) ) ) ; x >>= 1 ; if ( x == 0 ) { x = HIGHBIT ; r ++ ; } } } else { for ( bc = 0 ; * sp ; sp ++ ) { if ( * sp >= '0' && * sp <= '9' ) x = ( bits8 ) ( * sp - '0' ) ; else if ( * sp >= 'A' && * sp <= 'F' ) x = ( bits8 ) ( * sp - 'A' ) + 10 ; else if ( * sp >= 'a' && * sp <= 'f' ) x = ( bits8 ) ( * sp - 'a' ) + 10 ; else ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( "\"%c\" is not a valid hexadecimal digit" , * sp ) ) ) ; if ( bc ) { * r ++ |= x ; bc = 0 ; } else { * r = x < < 4 ; bc = 1 ; } } } PG_RETURN_VARBIT_P ( result ) ; }
int nfsd_mountpoint ( struct dentry * dentry , struct svc_export * exp ) { if ( d_mountpoint ( dentry ) ) return 1 ; if ( nfsd4_is_junction ( dentry ) ) return 1 ; if ( ! ( exp -> ex_flags & NFSEXP_V4ROOT ) ) return 0 ; return d_inode ( dentry ) != NULL ; }
FrameIter :: Data :: Data ( ThreadSafeContext * cx , SavedOption savedOption , ContextOption contextOption , JSPrincipals * principals ) : cx_ ( cx ) , savedOption_ ( savedOption ) , contextOption_ ( contextOption ) , principals_ ( principals ) , pc_ ( nullptr ) , interpFrames_ ( nullptr ) , activations_ ( cx -> perThreadData ) , jitFrames_ ( ( uint8_t * ) nullptr , SequentialExecution ) , ionInlineFrameNo_ ( 0 ) , asmJSFrames_ ( ) { }
void hashTypeTryConversion ( robj * o , robj * * argv , int start , int end ) { int i ; if ( o -> encoding != OBJ_ENCODING_ZIPLIST ) return ; for ( i = start ; i <= end ; i ++ ) { if ( sdsEncodedObject ( argv [ i ] ) && sdslen ( argv [ i ] -> ptr ) > server . hash_max_ziplist_value ) { hashTypeConvert ( o , OBJ_ENCODING_HT ) ; break ; } } }
js :: ion :: SetPropertyCache ( JSContext * cx , size_t cacheIndex , HandleObject obj , HandleValue value , bool isSetName ) { AutoFlushCache afc ( "SetPropertyCache" ) ; void * returnAddr ; const SafepointIndex * safepointIndex ; RootedScript script ( cx , GetTopIonJSScript ( cx , & safepointIndex , & returnAddr ) ) ; IonScript * ion = script -> ion ; IonCacheSetProperty & cache = ion -> getCache ( cacheIndex ) . toSetProperty ( ) ; RootedPropertyName name ( cx , cache . name ( ) ) ; RootedId id ( cx , AtomToId ( name ) ) ; RootedShape shape ( cx ) ; RootedObject holder ( cx ) ; bool inlinable = IsPropertyInlineable ( obj , cache ) ; if ( inlinable ) { RootedShape shape ( cx ) ; if ( IsPropertySetInlineable ( cx , obj , id , & shape ) ) { cache . incrementStubCount ( ) ; if ( ! cache . attachNativeExisting ( cx , ion , obj , shape ) ) return false ; } else { RootedObject holder ( cx ) ; if ( ! JSObject :: lookupProperty ( cx , obj , name , & holder , & shape ) ) return false ; if ( IsPropertySetterCallInlineable ( cx , obj , holder , id , shape ) ) { cache . incrementStubCount ( ) ; if ( ! cache . attachSetterCall ( cx , ion , obj , holder , shape , returnAddr ) ) return false ; } } } uint32_t oldSlots = obj -> numDynamicSlots ( ) ; RootedShape oldShape ( cx , obj -> lastProperty ( ) ) ; if ( ! SetProperty ( cx , obj , name , value , cache . strict ( ) , isSetName ) ) return false ; if ( inlinable && IsPropertyAddInlineable ( cx , obj , id , oldSlots , & shape ) ) { RootedShape newShape ( cx , obj -> lastProperty ( ) ) ; cache . incrementStubCount ( ) ; if ( ! cache . attachNativeAdding ( cx , ion , obj , oldShape , newShape , shape ) ) return false ; } return true ; }
GetElementParIC :: attachTypedArrayElement ( LockedJSContext & cx , IonScript * ion , TypedArrayObject * tarr , const Value & idval ) { MacroAssembler masm ( cx , ion ) ; DispatchStubPrepender attacher ( * this ) ; GenerateGetTypedArrayElement ( cx , masm , attacher , tarr , idval , object ( ) , index ( ) , output ( ) ) ; return linkAndAttachStub ( cx , masm , attacher , ion , "parallel typed array" ) ; }
void WasmGraphBuilder :: InitInstanceCache ( WasmInstanceCacheNodes * instance_cache ) { DCHECK_NOT_NULL ( instance_node_ ) ; instance_cache -> mem_start = SetEffect ( graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Load ( MachineType :: UintPtr ( ) ) , instance_node_ . get ( ) , mcgraph ( ) -> Int32Constant ( WASM_INSTANCE_OBJECT_OFFSET ( MemoryStart ) ) , Effect ( ) , Control ( ) ) ) ; instance_cache -> mem_size = SetEffect ( graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Load ( MachineType :: UintPtr ( ) ) , instance_node_ . get ( ) , mcgraph ( ) -> Int32Constant ( WASM_INSTANCE_OBJECT_OFFSET ( MemorySize ) ) , Effect ( ) , Control ( ) ) ) ; if ( untrusted_code_mitigations_ ) { instance_cache -> mem_mask = SetEffect ( graph ( ) -> NewNode ( mcgraph ( ) -> machine ( ) -> Load ( MachineType :: UintPtr ( ) ) , instance_node_ . get ( ) , mcgraph ( ) -> Int32Constant ( WASM_INSTANCE_OBJECT_OFFSET ( MemoryMask ) ) , Effect ( ) , Control ( ) ) ) ; } else { instance_cache -> mem_mask = nullptr ; } }
boost :: optional < SaplingOutgoingPlaintext > SaplingOutgoingPlaintext :: decrypt ( const SaplingOutCiphertext & ciphertext , const uint256 & ovk , const uint256 & cv , const uint256 & cm , const uint256 & epk ) { auto pt = AttemptSaplingOutDecryption ( ciphertext , ovk , cv , cm , epk ) ; if ( ! pt ) { return boost :: none ; } CDataStream ss ( SER_NETWORK , PROTOCOL_VERSION ) ; ss < < pt . get ( ) ; SaplingOutgoingPlaintext ret ; ss > > ret ; assert ( ss . size ( ) == 0 ) ; return ret ; }
void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( "usage: condump <filename>\n" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , ".txt" ) ; f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( "ERROR: couldn't open %s.\n" , filename ) ; return ; } Com_Printf ( "Dumped console text to %s.\n" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != ' ' ) break ; if ( x != con . linewidth ) break ; } #ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; #else bufferlen = con . linewidth + 2 * sizeof ( char ) ; #endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == ' ' ) buffer [ x ] = 0 ; else break ; } #ifdef _WIN32 Q_strcat ( buffer , bufferlen , "\r\n" ) ; #else Q_strcat ( buffer , bufferlen , "\n" ) ; #endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }
Type OperationTyper :: ToNumberConvertBigInt ( Type type ) { if ( base :: Optional < Type > maybe_result_type = ToNumberCommon ( type ) ) { return * maybe_result_type ; } return Type :: Number ( ) ; }
static void oz_usb_handle_ep_data ( struct oz_usb_ctx * usb_ctx , struct oz_usb_hdr * usb_hdr , int len ) { struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ; switch ( data_hdr -> format ) { case OZ_DATA_F_MULTIPLE_FIXED : { struct oz_multiple_fixed * body = ( struct oz_multiple_fixed * ) data_hdr ; u8 * data = body -> data ; int n ; if ( ! body -> unit_size ) break ; n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) / body -> unit_size ; while ( n -- ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , body -> unit_size ) ; data += body -> unit_size ; } } break ; case OZ_DATA_F_ISOC_FIXED : { struct oz_isoc_fixed * body = ( struct oz_isoc_fixed * ) data_hdr ; int data_len = len - sizeof ( struct oz_isoc_fixed ) + 1 ; int unit_size = body -> unit_size ; u8 * data = body -> data ; int count ; int i ; if ( ! unit_size ) break ; count = data_len / unit_size ; for ( i = 0 ; i < count ; i ++ ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , unit_size ) ; data += unit_size ; } } break ; } }
int perf_cpu_time_max_percent_handler ( struct ctl_table * table , int write , void __user * buffer , size_t * lenp , loff_t * ppos ) { int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ; if ( ret || ! write ) return ret ; if ( sysctl_perf_cpu_time_max_percent == 100 || sysctl_perf_cpu_time_max_percent == 0 ) { printk ( KERN_WARNING "perf: Dynamic interrupt throttling disabled, can hang your system!\n" ) ; WRITE_ONCE ( perf_sample_allowed_ns , 0 ) ; } else { update_perf_cpu_limits ( ) ; } return 0 ; }
void Compute ( OpKernelContext * context ) override { const Tensor & tensor_in = context -> input ( 0 ) ; const Tensor & tensor_out = context -> input ( 1 ) ; const Tensor & out_grad_backprop = context -> input ( 2 ) ; OP_REQUIRES ( context , tensor_in . dims ( ) == 4 , errors :: InvalidArgument ( "tensor_in must be 4-dimensional" ) ) ; OP_REQUIRES ( context , tensor_out . dims ( ) == 4 , errors :: InvalidArgument ( "tensor_out must be 4-dimensional" ) ) ; OP_REQUIRES ( context , out_grad_backprop . dims ( ) == 4 , errors :: InvalidArgument ( "out_grad_backprop must be 4-dimensional" ) ) ; std :: vector < int32 > ksize = ksize_ ; std :: vector < int32 > stride = stride_ ; if ( context -> num_inputs ( ) == 5 ) { const Tensor & tensor_ksize = context -> input ( 3 ) ; auto value_ksize = tensor_ksize . flat < int32 > ( ) ; ksize . resize ( tensor_ksize . shape ( ) . num_elements ( ) ) ; std :: copy_n ( & value_ksize ( 0 ) , ksize . size ( ) , ksize . begin ( ) ) ; const Tensor & tensor_stride = context -> input ( 4 ) ; auto value_stride = tensor_stride . flat < int32 > ( ) ; stride . resize ( tensor_stride . shape ( ) . num_elements ( ) ) ; std :: copy_n ( & value_stride ( 0 ) , stride . size ( ) , stride . begin ( ) ) ; } OP_REQUIRES ( context , ksize . size ( ) == 4 , errors :: InvalidArgument ( "Sliding window ksize field must " "specify 4 dimensions" ) ) ; OP_REQUIRES ( context , stride . size ( ) == 4 , errors :: InvalidArgument ( "Sliding window strides field must " "specify 4 dimensions" ) ) ; OP_REQUIRES ( context , ksize [ 0 ] == 1 && stride [ 0 ] == 1 , errors :: Unimplemented ( "Pooling is not yet supported on the batch dimension." ) ) ; OP_REQUIRES ( context , ksize [ 3 ] == 1 && stride [ 3 ] == 1 , errors :: Unimplemented ( "MaxPoolingGrad is not yet supported on the depth dimension." ) ) ; PoolParameters params { context , ksize , stride , padding_ , { } , FORMAT_NHWC , tensor_in . shape ( ) } ; Tensor * output = nullptr ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_output ( { 2 } , 0 , tensor_out . shape ( ) , & output ) ) ; SpatialMaxPoolGradGrad ( context , output , tensor_in , tensor_out , out_grad_backprop , params , padding_ ) ; }
void BrTable ( FullDecoder * decoder , const BranchTableImmediate < validate > & imm , const Value & key ) { LiftoffRegList pinned ; LiftoffRegister value = pinned . set ( __ PopToRegister ( ) ) ; BranchTableIterator < validate > table_iterator ( decoder , imm ) ; std :: map < uint32_t , MovableLabel > br_targets ; if ( imm . table_count > 0 ) { LiftoffRegister tmp = __ GetUnusedRegister ( kGpReg , pinned ) ; __ LoadConstant ( tmp , WasmValue ( uint32_t { imm . table_count } ) ) ; Label case_default ; __ emit_cond_jump ( kUnsignedGreaterEqual , & case_default , kWasmI32 , value . gp ( ) , tmp . gp ( ) ) ; GenerateBrTable ( decoder , tmp , value , 0 , imm . table_count , table_iterator , br_targets ) ; __ bind ( & case_default ) ; } GenerateBrCase ( decoder , table_iterator . next ( ) , br_targets ) ; DCHECK ( ! table_iterator . has_next ( ) ) ; }
void ObjectLiteral :: CalculateEmitStore ( Zone * zone ) { const auto GETTER = ObjectLiteral :: Property :: GETTER ; const auto SETTER = ObjectLiteral :: Property :: SETTER ; ZoneAllocationPolicy allocator ( zone ) ; CustomMatcherZoneHashMap table ( Literal :: Match , ZoneHashMap :: kDefaultHashMapCapacity , allocator ) ; for ( int i = properties ( ) -> length ( ) - 1 ; i >= 0 ; i -- ) { ObjectLiteral :: Property * property = properties ( ) -> at ( i ) ; if ( property -> is_computed_name ( ) ) continue ; if ( property -> IsPrototype ( ) ) continue ; Literal * literal = property -> key ( ) -> AsLiteral ( ) ; DCHECK ( ! literal -> IsNullLiteral ( ) ) ; uint32_t hash = literal -> Hash ( ) ; ZoneHashMap :: Entry * entry = table . LookupOrInsert ( literal , hash , allocator ) ; if ( entry -> value == nullptr ) { entry -> value = property ; } else { auto later_kind = static_cast < ObjectLiteral :: Property * > ( entry -> value ) -> kind ( ) ; bool complementary_accessors = ( property -> kind ( ) == GETTER && later_kind == SETTER ) || ( property -> kind ( ) == SETTER && later_kind == GETTER ) ; if ( ! complementary_accessors ) { property -> set_emit_store ( false ) ; if ( later_kind == GETTER || later_kind == SETTER ) { entry -> value = property ; } } } } }
NS_IMPL_ADDREF_INHERITED ( nsSVGScriptElement , nsSVGScriptElementBase ) NS_IMPL_RELEASE_INHERITED ( nsSVGScriptElement , nsSVGScriptElementBase ) NS_INTERFACE_TABLE_HEAD ( nsSVGScriptElement ) NS_NODE_INTERFACE_TABLE8 ( nsSVGScriptElement , nsIDOMNode , nsIDOMElement , nsIDOMSVGElement , nsIDOMSVGScriptElement , nsIDOMSVGURIReference , nsIScriptLoaderObserver , nsIScriptElement , nsIMutationObserver ) NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO ( SVGScriptElement ) NS_INTERFACE_MAP_END_INHERITING ( nsSVGScriptElementBase ) nsSVGScriptElement :: nsSVGScriptElement ( nsINodeInfo * aNodeInfo ) : nsSVGScriptElementBase ( aNodeInfo ) , mLineNumber ( 0 ) , mIsEvaluated ( PR_FALSE ) , mEvaluating ( PR_FALSE ) { AddMutationObserver ( this ) ; }
void BytecodeGraphBuilder :: BuildLoopExitsUntilLoop ( int loop_offset , const BytecodeLivenessState * liveness ) { int origin_offset = bytecode_iterator ( ) . current_offset ( ) ; int current_loop = bytecode_analysis ( ) -> GetLoopOffsetFor ( origin_offset ) ; loop_offset = std :: max ( loop_offset , currently_peeled_loop_offset_ ) ; while ( loop_offset < current_loop ) { Node * loop_node = merge_environments_ [ current_loop ] -> GetControlDependency ( ) ; const LoopInfo & loop_info = bytecode_analysis ( ) -> GetLoopInfoFor ( current_loop ) ; environment ( ) -> PrepareForLoopExit ( loop_node , loop_info . assignments ( ) , liveness ) ; current_loop = loop_info . parent_offset ( ) ; } }
enum sctp_disposition sctp_sf_do_5_1D_ce ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const union sctp_subtype type , void * arg , struct sctp_cmd_seq * commands ) { struct sctp_ulpevent * ev , * ai_ev = NULL , * auth_ev = NULL ; struct sctp_association * new_asoc ; struct sctp_init_chunk * peer_init ; struct sctp_chunk * chunk = arg ; struct sctp_chunk * err_chk_p ; struct sctp_chunk * repl ; struct sock * sk ; int error = 0 ; if ( ep == sctp_sk ( net -> sctp . ctl_sock ) -> ep ) { SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } if ( ! sctp_chunk_length_valid ( chunk , sizeof ( struct sctp_chunkhdr ) ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; sk = ep -> base . sk ; if ( ! sctp_sstate ( sk , LISTENING ) || ( sctp_style ( sk , TCP ) && sk_acceptq_is_full ( sk ) ) ) return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( struct sctp_chunkhdr ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } peer_init = & chunk -> subh . cookie_hdr -> c . peer_init [ 0 ] ; if ( ! sctp_process_init ( new_asoc , chunk , & chunk -> subh . cookie_hdr -> c . peer_addr , peer_init , GFP_ATOMIC ) ) goto nomem_init ; error = sctp_auth_asoc_init_active_key ( new_asoc , GFP_ATOMIC ) ; if ( error ) goto nomem_init ; if ( ! sctp_auth_chunk_verify ( net , chunk , new_asoc ) ) { sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } repl = sctp_make_cookie_ack ( new_asoc , chunk ) ; if ( ! repl ) goto nomem_init ; ev = sctp_ulpevent_make_assoc_change ( new_asoc , 0 , SCTP_COMM_UP , 0 , new_asoc -> c . sinit_num_ostreams , new_asoc -> c . sinit_max_instreams , NULL , GFP_ATOMIC ) ; if ( ! ev ) goto nomem_ev ; if ( new_asoc -> peer . adaptation_ind ) { ai_ev = sctp_ulpevent_make_adaptation_indication ( new_asoc , GFP_ATOMIC ) ; if ( ! ai_ev ) goto nomem_aiev ; } if ( ! new_asoc -> peer . auth_capable ) { auth_ev = sctp_ulpevent_make_authkey ( new_asoc , 0 , SCTP_AUTH_NO_AUTH , GFP_ATOMIC ) ; if ( ! auth_ev ) goto nomem_authev ; } sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_STATE , SCTP_STATE ( SCTP_STATE_ESTABLISHED ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_CURRESTAB ) ; SCTP_INC_STATS ( net , SCTP_MIB_PASSIVEESTABS ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_HB_TIMERS_START , SCTP_NULL ( ) ) ; if ( new_asoc -> timeouts [ SCTP_EVENT_TIMEOUT_AUTOCLOSE ] ) sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_START , SCTP_TO ( SCTP_EVENT_TIMEOUT_AUTOCLOSE ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( repl ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ev ) ) ; if ( ai_ev ) sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ai_ev ) ) ; if ( auth_ev ) sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( auth_ev ) ) ; return SCTP_DISPOSITION_CONSUME ; nomem_authev : sctp_ulpevent_free ( ai_ev ) ; nomem_aiev : sctp_ulpevent_free ( ev ) ; nomem_ev : sctp_chunk_free ( repl ) ; nomem_init : sctp_association_free ( new_asoc ) ; nomem : return SCTP_DISPOSITION_NOMEM ; }
static void do_sched_cfs_slack_timer ( struct cfs_bandwidth * cfs_b ) { u64 runtime = 0 , slice = sched_cfs_bandwidth_slice ( ) ; unsigned long flags ; u64 expires ; raw_spin_lock_irqsave ( & cfs_b -> lock , flags ) ; cfs_b -> slack_started = false ; if ( cfs_b -> distribute_running ) { raw_spin_unlock_irqrestore ( & cfs_b -> lock , flags ) ; return ; } if ( runtime_refresh_within ( cfs_b , min_bandwidth_expiration ) ) { raw_spin_unlock_irqrestore ( & cfs_b -> lock , flags ) ; return ; } if ( cfs_b -> quota != RUNTIME_INF && cfs_b -> runtime > slice ) runtime = cfs_b -> runtime ; expires = cfs_b -> runtime_expires ; if ( runtime ) cfs_b -> distribute_running = 1 ; raw_spin_unlock_irqrestore ( & cfs_b -> lock , flags ) ; if ( ! runtime ) return ; runtime = distribute_cfs_runtime ( cfs_b , runtime , expires ) ; raw_spin_lock_irqsave ( & cfs_b -> lock , flags ) ; if ( expires == cfs_b -> runtime_expires ) lsub_positive ( & cfs_b -> runtime , runtime ) ; cfs_b -> distribute_running = 0 ; raw_spin_unlock_irqrestore ( & cfs_b -> lock , flags ) ; }
sctp_handle_cookie_ack ( struct sctp_cookie_ack_chunk * cp SCTP_UNUSED , struct sctp_tcb * stcb , struct sctp_nets * net ) { struct sctp_association * asoc ; struct sctp_tmit_chunk * chk ; SCTPDBG ( SCTP_DEBUG_INPUT2 , "sctp_handle_cookie_ack: handling COOKIE-ACK\n" ) ; if ( ( stcb == NULL ) || ( net == NULL ) ) { return ; } asoc = & stcb -> asoc ; if ( SCTP_BASE_SYSCTL ( sctp_logging_level ) & SCTP_THRESHOLD_LOGGING ) { sctp_misc_ints ( SCTP_THRESHOLD_CLEAR , asoc -> overall_error_count , 0 , SCTP_FROM_SCTP_INPUT , __LINE__ ) ; } asoc -> overall_error_count = 0 ; sctp_stop_all_cookie_timers ( stcb ) ; if ( SCTP_GET_STATE ( stcb ) == SCTP_STATE_COOKIE_ECHOED ) { SCTPDBG ( SCTP_DEBUG_INPUT2 , "moving to OPEN state\n" ) ; SCTP_SET_STATE ( stcb , SCTP_STATE_OPEN ) ; sctp_start_net_timers ( stcb ) ; if ( asoc -> state & SCTP_STATE_SHUTDOWN_PENDING ) { sctp_timer_start ( SCTP_TIMER_TYPE_SHUTDOWNGUARD , stcb -> sctp_ep , stcb , NULL ) ; } SCTP_STAT_INCR_COUNTER32 ( sctps_activeestab ) ; SCTP_STAT_INCR_GAUGE32 ( sctps_currestab ) ; if ( asoc -> overall_error_count == 0 ) { sctp_calculate_rto ( stcb , asoc , net , & asoc -> time_entered , SCTP_RTT_FROM_NON_DATA ) ; } ( void ) SCTP_GETTIME_TIMEVAL ( & asoc -> time_entered ) ; sctp_ulp_notify ( SCTP_NOTIFY_ASSOC_UP , stcb , 0 , NULL , SCTP_SO_NOT_LOCKED ) ; if ( ( stcb -> sctp_ep -> sctp_flags & SCTP_PCB_FLAGS_TCPTYPE ) || ( stcb -> sctp_ep -> sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL ) ) { #if defined(__APPLE__) && !defined(__Userspace__) struct socket * so ; #endif stcb -> sctp_ep -> sctp_flags |= SCTP_PCB_FLAGS_CONNECTED ; #if defined(__APPLE__) && !defined(__Userspace__) so = SCTP_INP_SO ( stcb -> sctp_ep ) ; atomic_add_int ( & stcb -> asoc . refcnt , 1 ) ; SCTP_TCB_UNLOCK ( stcb ) ; SCTP_SOCKET_LOCK ( so , 1 ) ; SCTP_TCB_LOCK ( stcb ) ; atomic_subtract_int ( & stcb -> asoc . refcnt , 1 ) ; #endif if ( ( stcb -> asoc . state & SCTP_STATE_CLOSED_SOCKET ) == 0 ) { soisconnected ( stcb -> sctp_socket ) ; } #if defined(__APPLE__) && !defined(__Userspace__) SCTP_SOCKET_UNLOCK ( so , 1 ) ; #endif } net -> hb_responded = 1 ; if ( stcb -> asoc . state & SCTP_STATE_CLOSED_SOCKET ) { goto closed_socket ; } sctp_timer_start ( SCTP_TIMER_TYPE_HEARTBEAT , stcb -> sctp_ep , stcb , net ) ; if ( stcb -> asoc . sctp_autoclose_ticks && sctp_is_feature_on ( stcb -> sctp_ep , SCTP_PCB_FLAGS_AUTOCLOSE ) ) { sctp_timer_start ( SCTP_TIMER_TYPE_AUTOCLOSE , stcb -> sctp_ep , stcb , NULL ) ; } if ( ( sctp_is_feature_on ( stcb -> sctp_ep , SCTP_PCB_FLAGS_DO_ASCONF ) ) && ( stcb -> asoc . asconf_supported == 1 ) && ( ! TAILQ_EMPTY ( & stcb -> asoc . asconf_queue ) ) ) { #ifdef SCTP_TIMER_BASED_ASCONF sctp_timer_start ( SCTP_TIMER_TYPE_ASCONF , stcb -> sctp_ep , stcb , stcb -> asoc . primary_destination ) ; #else sctp_send_asconf ( stcb , stcb -> asoc . primary_destination , SCTP_ADDR_NOT_LOCKED ) ; #endif } } closed_socket : sctp_toss_old_cookies ( stcb , asoc ) ; TAILQ_FOREACH ( chk , & asoc -> sent_queue , sctp_next ) { if ( chk -> whoTo != NULL ) { break ; } } if ( chk != NULL ) { sctp_timer_start ( SCTP_TIMER_TYPE_SEND , stcb -> sctp_ep , stcb , chk -> whoTo ) ; } }
BUILTIN ( DatePrototypeSetUTCMonth ) { HandleScope scope ( isolate ) ; CHECK_RECEIVER ( JSDate , date , "Date.prototype.setUTCMonth" ) ; int const argc = args . length ( ) - 1 ; Handle < Object > month = args . atOrUndefined ( isolate , 1 ) ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , month , Object :: ToNumber ( isolate , month ) ) ; double time_val = date -> value ( ) -> Number ( ) ; if ( ! std :: isnan ( time_val ) ) { int64_t const time_ms = static_cast < int64_t > ( time_val ) ; int days = isolate -> date_cache ( ) -> DaysFromTime ( time_ms ) ; int time_within_day = isolate -> date_cache ( ) -> TimeInDay ( time_ms , days ) ; int year , unused , day ; isolate -> date_cache ( ) -> YearMonthDayFromDays ( days , & year , & unused , & day ) ; double m = month -> Number ( ) ; double dt = day ; if ( argc >= 2 ) { Handle < Object > date = args . at ( 2 ) ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , date , Object :: ToNumber ( isolate , date ) ) ; dt = date -> Number ( ) ; } time_val = MakeDate ( MakeDay ( year , m , dt ) , time_within_day ) ; } return * JSDate :: SetValue ( date , DateCache :: TimeClip ( time_val ) ) ; }
PackLinuxElf32 :: elf_find_dynamic ( unsigned int key ) const { Elf32_Dyn const * dynp = dynseg ; if ( dynp ) for ( ; ( unsigned ) ( ( char const * ) dynp - ( char const * ) dynseg ) < sz_dynseg && Elf32_Dyn :: DT_NULL != dynp -> d_tag ; ++ dynp ) if ( get_te32 ( & dynp -> d_tag ) == key ) { unsigned const t = elf_get_offset_from_address ( get_te32 ( & dynp -> d_val ) ) ; if ( t ) { return t + file_image ; } break ; } return 0 ; }
nfs41_callback_svc ( void * vrqstp ) { struct svc_rqst * rqstp = vrqstp ; struct svc_serv * serv = rqstp -> rq_server ; struct rpc_rqst * req ; int error ; DEFINE_WAIT ( wq ) ; set_freezable ( ) ; while ( ! kthread_should_stop ( ) ) { if ( try_to_freeze ( ) ) continue ; prepare_to_wait ( & serv -> sv_cb_waitq , & wq , TASK_INTERRUPTIBLE ) ; spin_lock_bh ( & serv -> sv_cb_lock ) ; if ( ! list_empty ( & serv -> sv_cb_list ) ) { req = list_first_entry ( & serv -> sv_cb_list , struct rpc_rqst , rq_bc_list ) ; list_del ( & req -> rq_bc_list ) ; spin_unlock_bh ( & serv -> sv_cb_lock ) ; finish_wait ( & serv -> sv_cb_waitq , & wq ) ; dprintk ( "Invoking bc_svc_process()\n" ) ; error = bc_svc_process ( serv , req , rqstp ) ; dprintk ( "bc_svc_process() returned w/ error code= %d\n" , error ) ; } else { spin_unlock_bh ( & serv -> sv_cb_lock ) ; schedule ( ) ; finish_wait ( & serv -> sv_cb_waitq , & wq ) ; } flush_signals ( current ) ; } return 0 ; }
void Compute ( OpKernelContext * context ) override { OpInputList ragged_nested_splits_in ; OP_REQUIRES_OK ( context , context -> input_list ( "rt_nested_splits" , & ragged_nested_splits_in ) ) ; const int ragged_nested_splits_len = ragged_nested_splits_in . size ( ) ; RaggedTensorVariant batched_ragged_input ; batched_ragged_input . set_values ( context -> input ( ragged_nested_splits_len ) ) ; batched_ragged_input . mutable_nested_splits ( ) -> reserve ( ragged_nested_splits_len ) ; for ( int i = 0 ; i < ragged_nested_splits_len ; i ++ ) { batched_ragged_input . append_splits ( ragged_nested_splits_in [ i ] ) ; } if ( ! batched_input_ ) { Tensor * encoded_scalar ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { } ) , & encoded_scalar ) ) ; encoded_scalar -> scalar < Variant > ( ) ( ) = std :: move ( batched_ragged_input ) ; return ; } std :: vector < RaggedTensorVariant > unbatched_ragged_input ; OP_REQUIRES_OK ( context , UnbatchRaggedZerothDim < VALUE_TYPE , SPLIT_TYPE > ( batched_ragged_input , & unbatched_ragged_input ) ) ; Tensor * encoded_vector ; int output_size = unbatched_ragged_input . size ( ) ; OP_REQUIRES_OK ( context , context -> allocate_output ( 0 , TensorShape ( { output_size } ) , & encoded_vector ) ) ; auto encoded_vector_t = encoded_vector -> vec < Variant > ( ) ; for ( int i = 0 ; i < output_size ; i ++ ) { encoded_vector_t ( i ) = unbatched_ragged_input [ i ] ; } }
static bool add ( V8InspectorSessionImpl * session , v8 :: Local < v8 :: Context > context , v8 :: Local < v8 :: Value > value , int executionContextId , const String16 & objectGroup , bool returnByValue , bool generatePreview , EvaluateCallback * callback ) { v8 :: Local < v8 :: Promise :: Resolver > resolver ; if ( ! v8 :: Promise :: Resolver :: New ( context ) . ToLocal ( & resolver ) ) { callback -> sendFailure ( Response :: InternalError ( ) ) ; return false ; } if ( ! resolver -> Resolve ( context , value ) . FromMaybe ( false ) ) { callback -> sendFailure ( Response :: InternalError ( ) ) ; return false ; } v8 :: Local < v8 :: Promise > promise = resolver -> GetPromise ( ) ; V8InspectorImpl * inspector = session -> inspector ( ) ; ProtocolPromiseHandler * handler = new ProtocolPromiseHandler ( session , executionContextId , objectGroup , returnByValue , generatePreview , callback ) ; v8 :: Local < v8 :: Value > wrapper = handler -> m_wrapper . Get ( inspector -> isolate ( ) ) ; v8 :: Local < v8 :: Function > thenCallbackFunction = v8 :: Function :: New ( context , thenCallback , wrapper , 0 , v8 :: ConstructorBehavior :: kThrow ) . ToLocalChecked ( ) ; if ( promise -> Then ( context , thenCallbackFunction ) . IsEmpty ( ) ) { callback -> sendFailure ( Response :: InternalError ( ) ) ; return false ; } v8 :: Local < v8 :: Function > catchCallbackFunction = v8 :: Function :: New ( context , catchCallback , wrapper , 0 , v8 :: ConstructorBehavior :: kThrow ) . ToLocalChecked ( ) ; if ( promise -> Catch ( context , catchCallbackFunction ) . IsEmpty ( ) ) { callback -> sendFailure ( Response :: InternalError ( ) ) ; return false ; } return true ; }
ft_gzip_stream_io ( FT_Stream stream , FT_ULong pos , FT_Byte * buffer , FT_ULong count ) { FT_GZipFile zip = ( FT_GZipFile ) stream -> descriptor . pointer ; return ft_gzip_file_io ( zip , pos , buffer , count ) ; }
static __u8 * ch_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) { hid_info ( hdev , "fixing up Cherry Cymotion report descriptor\n" ) ; rdesc [ 11 ] = rdesc [ 16 ] = 0xff ; rdesc [ 12 ] = rdesc [ 17 ] = 0x03 ; } return rdesc ; }
static int handle_exception ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct kvm_run * kvm_run = vcpu -> run ; u32 intr_info , ex_no , error_code ; unsigned long cr2 , rip , dr6 ; u32 vect_info ; enum emulation_result er ; vect_info = vmx -> idt_vectoring_info ; intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ; if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) return 1 ; if ( is_no_device ( intr_info ) ) { vmx_fpu_activate ( vcpu ) ; return 1 ; } if ( is_invalid_opcode ( intr_info ) ) { if ( is_guest_mode ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } er = emulate_instruction ( vcpu , EMULTYPE_TRAP_UD ) ; if ( er != EMULATE_DONE ) kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } error_code = 0 ; if ( intr_info & INTR_INFO_DELIVER_CODE_MASK ) error_code = vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) ; if ( ( vect_info & VECTORING_INFO_VALID_MASK ) && ! ( is_page_fault ( intr_info ) && ! ( error_code & PFERR_RSVD_MASK ) ) ) { vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_SIMUL_EX ; vcpu -> run -> internal . ndata = 3 ; vcpu -> run -> internal . data [ 0 ] = vect_info ; vcpu -> run -> internal . data [ 1 ] = intr_info ; vcpu -> run -> internal . data [ 2 ] = error_code ; return 0 ; } if ( is_page_fault ( intr_info ) ) { BUG_ON ( enable_ept ) ; cr2 = vmcs_readl ( EXIT_QUALIFICATION ) ; trace_kvm_page_fault ( cr2 , error_code ) ; if ( kvm_event_needs_reinjection ( vcpu ) ) kvm_mmu_unprotect_page_virt ( vcpu , cr2 ) ; return kvm_mmu_page_fault ( vcpu , cr2 , error_code , NULL , 0 ) ; } ex_no = intr_info & INTR_INFO_VECTOR_MASK ; if ( vmx -> rmode . vm86_active && rmode_exception ( vcpu , ex_no ) ) return handle_rmode_exception ( vcpu , ex_no , error_code ) ; switch ( ex_no ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case DB_VECTOR : dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ; if ( ! ( vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) ) { vcpu -> arch . dr6 &= ~ 15 ; vcpu -> arch . dr6 |= dr6 | DR6_RTM ; if ( ! ( dr6 & ~ DR6_RESERVED ) ) skip_emulated_instruction ( vcpu ) ; kvm_queue_exception ( vcpu , DB_VECTOR ) ; return 1 ; } kvm_run -> debug . arch . dr6 = dr6 | DR6_FIXED_1 ; kvm_run -> debug . arch . dr7 = vmcs_readl ( GUEST_DR7 ) ; case BP_VECTOR : vmx -> vcpu . arch . event_exit_inst_len = vmcs_read32 ( VM_EXIT_INSTRUCTION_LEN ) ; kvm_run -> exit_reason = KVM_EXIT_DEBUG ; rip = kvm_rip_read ( vcpu ) ; kvm_run -> debug . arch . pc = vmcs_readl ( GUEST_CS_BASE ) + rip ; kvm_run -> debug . arch . exception = ex_no ; break ; default : kvm_run -> exit_reason = KVM_EXIT_EXCEPTION ; kvm_run -> ex . exception = ex_no ; kvm_run -> ex . error_code = error_code ; break ; } return 0 ; }
OMX_ERRORTYPE omx_video :: use_output_buffer ( OMX_IN OMX_HANDLETYPE hComp , OMX_INOUT OMX_BUFFERHEADERTYPE * * bufferHdr , OMX_IN OMX_U32 port , OMX_IN OMX_PTR appData , OMX_IN OMX_U32 bytes , OMX_IN OMX_U8 * buffer ) { ( void ) hComp , ( void ) port ; OMX_ERRORTYPE eRet = OMX_ErrorNone ; OMX_BUFFERHEADERTYPE * bufHdr = NULL ; unsigned i = 0 ; unsigned char * buf_addr = NULL ; #ifdef _MSM8974_ int align_size ; #endif DEBUG_PRINT_HIGH ( "Inside use_output_buffer()" ) ; if ( bytes != m_sOutPortDef . nBufferSize ) { DEBUG_PRINT_ERROR ( "ERROR: use_output_buffer: Size Mismatch!! " "bytes[%u] != Port.nBufferSize[%u]" , ( unsigned int ) bytes , ( unsigned int ) m_sOutPortDef . nBufferSize ) ; return OMX_ErrorBadParameter ; } if ( ! m_out_mem_ptr ) { output_use_buffer = true ; int nBufHdrSize = 0 ; DEBUG_PRINT_LOW ( "Allocating First Output Buffer(%u)" , ( unsigned int ) m_sOutPortDef . nBufferCountActual ) ; nBufHdrSize = m_sOutPortDef . nBufferCountActual * sizeof ( OMX_BUFFERHEADERTYPE ) ; m_out_mem_ptr = ( OMX_BUFFERHEADERTYPE * ) calloc ( nBufHdrSize , 1 ) ; if ( m_out_mem_ptr == NULL ) { DEBUG_PRINT_ERROR ( "ERROR: calloc() Failed for m_out_mem_ptr" ) ; return OMX_ErrorInsufficientResources ; } m_pOutput_pmem = ( struct pmem * ) calloc ( sizeof ( struct pmem ) , m_sOutPortDef . nBufferCountActual ) ; if ( m_pOutput_pmem == NULL ) { DEBUG_PRINT_ERROR ( "ERROR: calloc() Failed for m_pOutput_pmem" ) ; return OMX_ErrorInsufficientResources ; } #ifdef USE_ION m_pOutput_ion = ( struct venc_ion * ) calloc ( sizeof ( struct venc_ion ) , m_sOutPortDef . nBufferCountActual ) ; if ( m_pOutput_ion == NULL ) { DEBUG_PRINT_ERROR ( "ERROR: calloc() Failed for m_pOutput_ion" ) ; return OMX_ErrorInsufficientResources ; } #endif if ( m_out_mem_ptr ) { bufHdr = m_out_mem_ptr ; DEBUG_PRINT_LOW ( "Memory Allocation Succeeded for OUT port%p" , m_out_mem_ptr ) ; for ( i = 0 ; i < m_sOutPortDef . nBufferCountActual ; i ++ ) { bufHdr -> nSize = sizeof ( OMX_BUFFERHEADERTYPE ) ; bufHdr -> nVersion . nVersion = OMX_SPEC_VERSION ; bufHdr -> nAllocLen = bytes ; bufHdr -> nFilledLen = 0 ; bufHdr -> pAppPrivate = appData ; bufHdr -> nOutputPortIndex = PORT_INDEX_OUT ; bufHdr -> pBuffer = NULL ; bufHdr ++ ; m_pOutput_pmem [ i ] . fd = - 1 ; #ifdef USE_ION m_pOutput_ion [ i ] . ion_device_fd = - 1 ; m_pOutput_ion [ i ] . fd_ion_data . fd = - 1 ; m_pOutput_ion [ i ] . ion_alloc_data . handle = 0 ; #endif } } else { DEBUG_PRINT_ERROR ( "ERROR: Output buf mem alloc failed[0x%p]" , m_out_mem_ptr ) ; eRet = OMX_ErrorInsufficientResources ; } } for ( i = 0 ; i < m_sOutPortDef . nBufferCountActual ; i ++ ) { if ( BITMASK_ABSENT ( & m_out_bm_count , i ) ) { break ; } } if ( eRet == OMX_ErrorNone ) { if ( i < m_sOutPortDef . nBufferCountActual ) { * bufferHdr = ( m_out_mem_ptr + i ) ; ( * bufferHdr ) -> pBuffer = ( OMX_U8 * ) buffer ; ( * bufferHdr ) -> pAppPrivate = appData ; BITMASK_SET ( & m_out_bm_count , i ) ; if ( ! m_use_output_pmem ) { #ifdef USE_ION #ifdef _MSM8974_ align_size = ( m_sOutPortDef . nBufferSize + ( SZ_4K - 1 ) ) & ~ ( SZ_4K - 1 ) ; m_pOutput_ion [ i ] . ion_device_fd = alloc_map_ion_memory ( align_size , & m_pOutput_ion [ i ] . ion_alloc_data , & m_pOutput_ion [ i ] . fd_ion_data , 0 ) ; #else m_pOutput_ion [ i ] . ion_device_fd = alloc_map_ion_memory ( m_sOutPortDef . nBufferSize , & m_pOutput_ion [ i ] . ion_alloc_data , & m_pOutput_ion [ i ] . fd_ion_data , ION_FLAG_CACHED ) ; #endif if ( m_pOutput_ion [ i ] . ion_device_fd < 0 ) { DEBUG_PRINT_ERROR ( "ERROR:ION device open() Failed" ) ; return OMX_ErrorInsufficientResources ; } m_pOutput_pmem [ i ] . fd = m_pOutput_ion [ i ] . fd_ion_data . fd ; #else m_pOutput_pmem [ i ] . fd = open ( MEM_DEVICE , O_RDWR ) ; if ( m_pOutput_pmem [ i ] . fd == 0 ) { m_pOutput_pmem [ i ] . fd = open ( MEM_DEVICE , O_RDWR ) ; } if ( m_pOutput_pmem [ i ] . fd < 0 ) { DEBUG_PRINT_ERROR ( "ERROR: /dev/pmem_adsp open() Failed" ) ; return OMX_ErrorInsufficientResources ; } #endif m_pOutput_pmem [ i ] . size = m_sOutPortDef . nBufferSize ; m_pOutput_pmem [ i ] . offset = 0 ; m_pOutput_pmem [ i ] . buffer = ( OMX_U8 * ) SECURE_BUFPTR ; if ( ! secure_session ) { #ifdef _MSM8974_ m_pOutput_pmem [ i ] . buffer = ( unsigned char * ) mmap ( NULL , align_size , PROT_READ | PROT_WRITE , MAP_SHARED , m_pOutput_pmem [ i ] . fd , 0 ) ; #else m_pOutput_pmem [ i ] . buffer = ( unsigned char * ) mmap ( NULL , m_pOutput_pmem [ i ] . size , PROT_READ | PROT_WRITE , MAP_SHARED , m_pOutput_pmem [ i ] . fd , 0 ) ; #endif if ( m_pOutput_pmem [ i ] . buffer == MAP_FAILED ) { DEBUG_PRINT_ERROR ( "ERROR: mmap() Failed" ) ; close ( m_pOutput_pmem [ i ] . fd ) ; #ifdef USE_ION free_ion_memory ( & m_pOutput_ion [ i ] ) ; #endif return OMX_ErrorInsufficientResources ; } } } else { OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO * pParam = reinterpret_cast < OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO * > ( ( * bufferHdr ) -> pAppPrivate ) ; DEBUG_PRINT_LOW ( "Inside qcom_ext pParam: %p" , pParam ) ; if ( pParam ) { DEBUG_PRINT_LOW ( "Inside qcom_ext with luma:(fd:%lu,offset:0x%x)" , pParam -> pmem_fd , ( int ) pParam -> offset ) ; m_pOutput_pmem [ i ] . fd = pParam -> pmem_fd ; m_pOutput_pmem [ i ] . offset = pParam -> offset ; m_pOutput_pmem [ i ] . size = m_sOutPortDef . nBufferSize ; m_pOutput_pmem [ i ] . buffer = ( unsigned char * ) buffer ; } else { DEBUG_PRINT_ERROR ( "ERROR: Invalid AppData given for PMEM o/p UseBuffer case" ) ; return OMX_ErrorBadParameter ; } buf_addr = ( unsigned char * ) buffer ; } DEBUG_PRINT_LOW ( "use_out:: bufhdr = %p, pBuffer = %p, m_pOutput_pmem[i].buffer = %p" , ( * bufferHdr ) , ( * bufferHdr ) -> pBuffer , m_pOutput_pmem [ i ] . buffer ) ; if ( dev_use_buf ( & m_pOutput_pmem [ i ] , PORT_INDEX_OUT , i ) != true ) { DEBUG_PRINT_ERROR ( "ERROR: dev_use_buf Failed for o/p buf" ) ; return OMX_ErrorInsufficientResources ; } } else { DEBUG_PRINT_ERROR ( "ERROR: All o/p Buffers have been Used, invalid use_buf call for " "index = %u" , i ) ; eRet = OMX_ErrorInsufficientResources ; } } return eRet ; }
nsStandardURL :: SetHost ( const nsACString & input ) { ENSURE_MUTABLE ( ) ; const nsPromiseFlatCString & flat = PromiseFlatCString ( input ) ; const char * host = flat . get ( ) ; LOG ( ( "nsStandardURL::SetHost [host=%s]\n" , host ) ) ; if ( mURLType == URLTYPE_NO_AUTHORITY ) { if ( flat . IsEmpty ( ) ) return NS_OK ; NS_WARNING ( "cannot set host on no-auth url" ) ; return NS_ERROR_UNEXPECTED ; } else { if ( flat . IsEmpty ( ) ) { return NS_ERROR_UNEXPECTED ; } } if ( strlen ( host ) < flat . Length ( ) ) return NS_ERROR_MALFORMED_URI ; if ( strchr ( host , ' ' ) ) return NS_ERROR_MALFORMED_URI ; if ( ! ValidIPv6orHostname ( host ) ) { return NS_ERROR_MALFORMED_URI ; } InvalidateCache ( ) ; mHostEncoding = eEncoding_ASCII ; int32_t len ; nsAutoCString hostBuf ; if ( NormalizeIDN ( flat , hostBuf ) ) { host = hostBuf . get ( ) ; len = hostBuf . Length ( ) ; } else len = flat . Length ( ) ; if ( mHost . mLen < 0 ) { int port_length = 0 ; if ( mPort != - 1 ) { nsAutoCString buf ; buf . Assign ( ':' ) ; buf . AppendInt ( mPort ) ; port_length = buf . Length ( ) ; } mHost . mPos = mAuthority . mPos + mAuthority . mLen - port_length ; mHost . mLen = 0 ; } int32_t shift = ReplaceSegment ( mHost . mPos , mHost . mLen , host , len ) ; if ( shift ) { mHost . mLen = len ; mAuthority . mLen += shift ; ShiftFromPath ( shift ) ; } net_ToLowerCase ( mSpec . BeginWriting ( ) + mHost . mPos , mHost . mLen ) ; return NS_OK ; }
void Scope :: AllocateVariablesRecursively ( ) { DCHECK ( ! already_resolved_ ) ; DCHECK_IMPLIES ( ! FLAG_preparser_scope_analysis , num_stack_slots_ == 0 ) ; if ( is_declaration_scope ( ) && AsDeclarationScope ( ) -> was_lazily_parsed ( ) ) { return ; } for ( Scope * scope = inner_scope_ ; scope != nullptr ; scope = scope -> sibling_ ) { scope -> AllocateVariablesRecursively ( ) ; } DCHECK ( ! already_resolved_ ) ; DCHECK_EQ ( Context :: MIN_CONTEXT_SLOTS , num_heap_slots_ ) ; if ( is_declaration_scope ( ) ) { if ( is_function_scope ( ) ) { AsDeclarationScope ( ) -> AllocateParameterLocals ( ) ; } AsDeclarationScope ( ) -> AllocateReceiver ( ) ; } AllocateNonParameterLocalsAndDeclaredGlobals ( ) ; bool must_have_context = is_with_scope ( ) || is_module_scope ( ) || IsAsmModule ( ) || ( is_function_scope ( ) && AsDeclarationScope ( ) -> calls_sloppy_eval ( ) ) || ( is_block_scope ( ) && is_declaration_scope ( ) && AsDeclarationScope ( ) -> calls_sloppy_eval ( ) ) ; if ( num_heap_slots_ == Context :: MIN_CONTEXT_SLOTS && ! must_have_context ) { num_heap_slots_ = 0 ; } DCHECK ( num_heap_slots_ == 0 || num_heap_slots_ >= Context :: MIN_CONTEXT_SLOTS ) ; }
Context AccessControl :: getContext ( pid_t sourcePid ) { char * sourceContext = NULL ; if ( getpidcon ( sourcePid , & sourceContext ) < 0 ) { ALOGE ( "SELinux: failed to retrieve process context for pid %d" , sourcePid ) ; return Context ( nullptr , freecon ) ; } return Context ( sourceContext , freecon ) ; }
void MarkCompactCollector :: EvacuatePrologue ( ) { NewSpace * new_space = heap ( ) -> new_space ( ) ; for ( Page * p : PageRange ( new_space -> first_allocatable_address ( ) , new_space -> top ( ) ) ) { new_space_evacuation_pages_ . push_back ( p ) ; } new_space -> Flip ( ) ; new_space -> ResetLinearAllocationArea ( ) ; DCHECK ( old_space_evacuation_pages_ . empty ( ) ) ; old_space_evacuation_pages_ = std :: move ( evacuation_candidates_ ) ; evacuation_candidates_ . clear ( ) ; DCHECK ( evacuation_candidates_ . empty ( ) ) ; }
static void control_work_handler ( struct work_struct * work ) { struct ports_device * portdev ; struct virtqueue * vq ; struct port_buffer * buf ; unsigned int len ; portdev = container_of ( work , struct ports_device , control_work ) ; vq = portdev -> c_ivq ; spin_lock ( & portdev -> c_ivq_lock ) ; while ( ( buf = virtqueue_get_buf ( vq , & len ) ) ) { spin_unlock ( & portdev -> c_ivq_lock ) ; buf -> len = len ; buf -> offset = 0 ; handle_control_message ( vq -> vdev , portdev , buf ) ; spin_lock ( & portdev -> c_ivq_lock ) ; if ( add_inbuf ( portdev -> c_ivq , buf ) < 0 ) { dev_warn ( & portdev -> vdev -> dev , "Error adding buffer to queue\n" ) ; free_buf ( buf , false ) ; } } spin_unlock ( & portdev -> c_ivq_lock ) ; }
void RegExpMacroAssemblerPPC :: CheckNotBackReference ( int start_reg , bool read_backward , Label * on_no_match ) { Label fallthrough ; Label success ; __ LoadP ( r3 , register_location ( start_reg ) , r0 ) ; __ LoadP ( r4 , register_location ( start_reg + 1 ) , r0 ) ; __ sub ( r4 , r4 , r3 , LeaveOE , SetRC ) ; __ beq ( & fallthrough , cr0 ) ; if ( read_backward ) { __ LoadP ( r6 , MemOperand ( frame_pointer ( ) , kStringStartMinusOne ) ) ; __ add ( r6 , r6 , r4 ) ; __ cmp ( current_input_offset ( ) , r6 ) ; BranchOrBacktrack ( le , on_no_match ) ; } else { __ add ( r0 , r4 , current_input_offset ( ) , LeaveOE , SetRC ) ; BranchOrBacktrack ( gt , on_no_match , cr0 ) ; } __ add ( r3 , r3 , end_of_input_address ( ) ) ; __ add ( r5 , end_of_input_address ( ) , current_input_offset ( ) ) ; if ( read_backward ) { __ sub ( r5 , r5 , r4 ) ; } __ add ( r4 , r4 , r3 ) ; Label loop ; __ bind ( & loop ) ; if ( mode_ == LATIN1 ) { __ lbz ( r6 , MemOperand ( r3 ) ) ; __ addi ( r3 , r3 , Operand ( char_size ( ) ) ) ; __ lbz ( r25 , MemOperand ( r5 ) ) ; __ addi ( r5 , r5 , Operand ( char_size ( ) ) ) ; } else { DCHECK ( mode_ == UC16 ) ; __ lhz ( r6 , MemOperand ( r3 ) ) ; __ addi ( r3 , r3 , Operand ( char_size ( ) ) ) ; __ lhz ( r25 , MemOperand ( r5 ) ) ; __ addi ( r5 , r5 , Operand ( char_size ( ) ) ) ; } __ cmp ( r6 , r25 ) ; BranchOrBacktrack ( ne , on_no_match ) ; __ cmp ( r3 , r4 ) ; __ blt ( & loop ) ; __ sub ( current_input_offset ( ) , r5 , end_of_input_address ( ) ) ; if ( read_backward ) { __ LoadP ( r3 , register_location ( start_reg ) ) ; __ LoadP ( r4 , register_location ( start_reg + 1 ) ) ; __ add ( current_input_offset ( ) , current_input_offset ( ) , r3 ) ; __ sub ( current_input_offset ( ) , current_input_offset ( ) , r4 ) ; } __ bind ( & fallthrough ) ; }
virtual void SetUp ( ) { fwd_txfm_ = GET_PARAM ( 0 ) ; inv_txfm_ = GET_PARAM ( 1 ) ; tx_type_ = GET_PARAM ( 2 ) ; pitch_ = 8 ; fwd_txfm_ref = fdct8x8_ref ; }
LoadElimination :: AbstractElements :: Merge ( AbstractElements const * that , Zone * zone ) const { if ( this -> Equals ( that ) ) return this ; AbstractElements * copy = new ( zone ) AbstractElements ( zone ) ; for ( Element const this_element : this -> elements_ ) { if ( this_element . object == nullptr ) continue ; for ( Element const that_element : that -> elements_ ) { if ( this_element . object == that_element . object && this_element . index == that_element . index && this_element . value == that_element . value ) { copy -> elements_ [ copy -> next_index_ ++ ] = this_element ; break ; } } } copy -> next_index_ %= arraysize ( elements_ ) ; return copy ; }
Maybe < RegExp :: Flags > Scanner :: ScanRegExpFlags ( ) { DCHECK_EQ ( Token :: REGEXP_LITERAL , next ( ) . token ) ; int flags = 0 ; while ( unicode_cache_ -> IsIdentifierPart ( c0_ ) ) { RegExp :: Flags flag = RegExp :: kNone ; switch ( c0_ ) { case 'g' : flag = RegExp :: kGlobal ; break ; case 'i' : flag = RegExp :: kIgnoreCase ; break ; case 'm' : flag = RegExp :: kMultiline ; break ; case 's' : flag = RegExp :: kDotAll ; break ; case 'u' : flag = RegExp :: kUnicode ; break ; case 'y' : flag = RegExp :: kSticky ; break ; default : return Nothing < RegExp :: Flags > ( ) ; } if ( flags & flag ) { return Nothing < RegExp :: Flags > ( ) ; } Advance ( ) ; flags |= flag ; } next ( ) . location . end_pos = source_pos ( ) ; return Just ( RegExp :: Flags ( flags ) ) ; }
ssize_t utf16_to_utf8_length ( const char16_t * src , size_t src_len ) { if ( src == NULL || src_len == 0 ) { return - 1 ; } size_t ret = 0 ; const char16_t * const end = src + src_len ; while ( src < end ) { if ( ( * src & 0xFC00 ) == 0xD800 && ( src + 1 ) < end && ( * ( src + 1 ) & 0xFC00 ) == 0xDC00 ) { ret += 4 ; src += 2 ; } else { ret += utf32_codepoint_utf8_length ( ( char32_t ) * src ++ ) ; } } return ret ; }
js_TransplantObjectWithWrapper ( JSContext * cx , JSObject * origobj , JSObject * origwrapper , JSObject * targetobj , JSObject * targetwrapper ) { AssertNoGC ( cx ) ; JS_ASSERT ( ! IsCrossCompartmentWrapper ( origobj ) ) ; JS_ASSERT ( ! IsCrossCompartmentWrapper ( origwrapper ) ) ; JS_ASSERT ( ! IsCrossCompartmentWrapper ( origwrapper ) ) ; JS_ASSERT ( ! IsCrossCompartmentWrapper ( origwrapper ) ) ; JSObject * newWrapper ; JSCompartment * destination = targetobj -> compartment ( ) ; WrapperMap & map = destination -> crossCompartmentWrappers ; Value origv = ObjectValue ( * origobj ) ; if ( WrapperMap :: Ptr p = map . lookup ( origv ) ) { newWrapper = & p -> value . toObject ( ) ; map . remove ( p ) ; NukeCrossCompartmentWrapper ( newWrapper ) ; if ( ! newWrapper -> swap ( cx , targetwrapper ) ) return NULL ; } else { newWrapper = targetwrapper ; } if ( ! RemapWrappers ( cx , origobj , targetobj ) ) return NULL ; { AutoCompartment ac ( cx , origobj ) ; JSObject * wrapperGuts = targetobj ; if ( ! ac . enter ( ) || ! JS_WrapObject ( cx , & wrapperGuts ) ) return NULL ; if ( ! origwrapper -> swap ( cx , wrapperGuts ) ) return NULL ; origwrapper -> compartment ( ) -> crossCompartmentWrappers . put ( ObjectValue ( * targetobj ) , ObjectValue ( * origwrapper ) ) ; } return newWrapper ; }
TNode < Object > CodeAssembler :: CallRuntimeWithCEntryImpl ( Runtime :: FunctionId function , TNode < Code > centry , TNode < Object > context , std :: initializer_list < TNode < Object > > args ) { constexpr size_t kMaxNumArgs = 6 ; DCHECK_GE ( kMaxNumArgs , args . size ( ) ) ; int argc = static_cast < int > ( args . size ( ) ) ; auto call_descriptor = Linkage :: GetRuntimeCallDescriptor ( zone ( ) , function , argc , Operator :: kNoProperties , CallDescriptor :: kNoFlags ) ; Node * ref = ExternalConstant ( ExternalReference :: Create ( function ) ) ; Node * arity = Int32Constant ( argc ) ; NodeArray < kMaxNumArgs + 4 > inputs ; inputs . Add ( centry ) ; for ( auto arg : args ) inputs . Add ( arg ) ; inputs . Add ( ref ) ; inputs . Add ( arity ) ; inputs . Add ( context ) ; CallPrologue ( ) ; Node * return_value = raw_assembler ( ) -> CallN ( call_descriptor , inputs . size ( ) , inputs . data ( ) ) ; CallEpilogue ( ) ; return UncheckedCast < Object > ( return_value ) ; }
static void decode_mb_mode_mvs ( VP8D_COMP * pbi , MODE_INFO * mi , MB_MODE_INFO * mbmi ) { if ( pbi -> mb . update_mb_segmentation_map ) read_mb_features ( & pbi -> mbc [ 8 ] , & mi -> mbmi , & pbi -> mb ) ; else if ( pbi -> common . frame_type == KEY_FRAME ) mi -> mbmi . segment_id = 0 ; if ( pbi -> common . mb_no_coeff_skip ) mi -> mbmi . mb_skip_coeff = vp8_read ( & pbi -> mbc [ 8 ] , pbi -> prob_skip_false ) ; else mi -> mbmi . mb_skip_coeff = 0 ; mi -> mbmi . is_4x4 = 0 ; if ( pbi -> common . frame_type == KEY_FRAME ) read_kf_modes ( pbi , mi ) ; else read_mb_modes_mv ( pbi , mi , & mi -> mbmi ) ; }
void next_character ( void ) { strlcpy ( cipher , english_alphabet , ENGLISH_ALPHABET_BUF ) ; random_permute_char ( cipher , strlen ( cipher ) ) ; static char CONFIDENTIAL current_word [ CURRENT_WORD_BUF ] ; get_current_word ( current_word ) ; if ( strlen ( current_word ) > 4 ) { memzero ( current_word , sizeof ( current_word ) ) ; recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_SyntaxError , "Words were not entered correctly. Make sure you are using the substition cipher." ) ; layoutHome ( ) ; return ; } CharacterRequest resp ; memset ( & resp , 0 , sizeof ( CharacterRequest ) ) ; resp . word_pos = get_current_word_pos ( ) ; resp . character_pos = strlen ( current_word ) ; msg_write ( MessageType_MessageType_CharacterRequest , & resp ) ; bool auto_completed = false ; if ( strlen ( current_word ) >= 3 ) { auto_completed = attempt_auto_complete ( current_word ) ; } #if DEBUG_LINK if ( auto_completed ) { strlcpy ( auto_completed_word , current_word , CURRENT_WORD_BUF ) ; } else { auto_completed_word [ 0 ] = '\0' ; } #endif format_current_word ( current_word , auto_completed ) ; layout_cipher ( current_word , cipher ) ; memzero ( current_word , sizeof ( current_word ) ) ; }
status_t OMXNodeInstance :: useGraphicBuffer_l ( OMX_U32 portIndex , const sp < GraphicBuffer > & graphicBuffer , IOMX :: buffer_id * buffer ) { if ( graphicBuffer == NULL || buffer == NULL ) { ALOGE ( "b/25884056" ) ; return BAD_VALUE ; } if ( mMetadataType [ portIndex ] != kMetadataBufferTypeInvalid ) { return useGraphicBufferWithMetadata_l ( portIndex , graphicBuffer , buffer ) ; } OMX_INDEXTYPE index ; if ( OMX_GetExtensionIndex ( mHandle , const_cast < OMX_STRING > ( "OMX.google.android.index.useAndroidNativeBuffer2" ) , & index ) == OMX_ErrorNone ) { return useGraphicBuffer2_l ( portIndex , graphicBuffer , buffer ) ; } OMX_STRING name = const_cast < OMX_STRING > ( "OMX.google.android.index.useAndroidNativeBuffer" ) ; OMX_ERRORTYPE err = OMX_GetExtensionIndex ( mHandle , name , & index ) ; if ( err != OMX_ErrorNone ) { CLOG_ERROR ( getExtensionIndex , err , "%s" , name ) ; return StatusFromOMXError ( err ) ; } BufferMeta * bufferMeta = new BufferMeta ( graphicBuffer , portIndex ) ; OMX_BUFFERHEADERTYPE * header ; OMX_VERSIONTYPE ver ; ver . s . nVersionMajor = 1 ; ver . s . nVersionMinor = 0 ; ver . s . nRevision = 0 ; ver . s . nStep = 0 ; UseAndroidNativeBufferParams params = { sizeof ( UseAndroidNativeBufferParams ) , ver , portIndex , bufferMeta , & header , graphicBuffer , } ; err = OMX_SetParameter ( mHandle , index , & params ) ; if ( err != OMX_ErrorNone ) { CLOG_ERROR ( setParameter , err , "%s(%#x): %s:%u meta=%p GB=%p" , name , index , portString ( portIndex ) , portIndex , bufferMeta , graphicBuffer -> handle ) ; delete bufferMeta ; bufferMeta = NULL ; * buffer = 0 ; return StatusFromOMXError ( err ) ; } CHECK_EQ ( header -> pAppPrivate , bufferMeta ) ; * buffer = makeBufferID ( header ) ; addActiveBuffer ( portIndex , * buffer ) ; CLOG_BUFFER ( useGraphicBuffer , NEW_BUFFER_FMT ( * buffer , portIndex , "GB=%p" , graphicBuffer -> handle ) ) ; return OK ; }
void writeStats ( Array & ) override { fprintf ( stderr , "writeStats start\n" ) ; fprintf ( stderr , "Count Function MinSerLen MaxSerLen RetSame HasThis " "AllSame MemberCount\n" ) ; for ( auto & me : m_memos ) { if ( me . second . m_ignore ) continue ; if ( me . second . m_count == 1 ) continue ; int min_ser_len = 999999999 ; int max_ser_len = 0 ; int count = 0 ; int member_count = 0 ; bool all_same = true ; if ( me . second . m_has_this ) { bool any_multiple = false ; auto & fr = me . second . m_member_memos . begin ( ) -> second . m_return_value ; member_count = me . second . m_member_memos . size ( ) ; for ( auto & mme : me . second . m_member_memos ) { if ( mme . second . m_return_value != fr ) all_same = false ; count += mme . second . m_count ; auto ser_len = mme . second . m_return_value . length ( ) ; min_ser_len = std :: min ( min_ser_len , ser_len ) ; max_ser_len = std :: max ( max_ser_len , ser_len ) ; if ( mme . second . m_count > 1 ) any_multiple = true ; } if ( ! any_multiple && ! all_same ) continue ; } else { min_ser_len = max_ser_len = me . second . m_return_value . length ( ) ; count = me . second . m_count ; all_same = me . second . m_ret_tv_same ; } fprintf ( stderr , "%d %s %d %d %s %s %s %d\n" , count , me . first . data ( ) , min_ser_len , max_ser_len , me . second . m_ret_tv_same ? " true" : "false" , me . second . m_has_this ? " true" : "false" , all_same ? " true" : "false" , member_count ) ; } fprintf ( stderr , "writeStats end\n" ) ; }
static int setup_config ( int type ) { int rv ; rv = read_config ( cl . configfile , type ) ; if ( rv < 0 ) goto out ; if ( is_auth_req ( ) ) { rv = read_authkey ( ) ; if ( rv < 0 ) goto out ; #if HAVE_LIBGCRYPT if ( ! gcry_check_version ( NULL ) ) { log_error ( "gcry_check_version" ) ; rv = - ENOENT ; goto out ; } gcry_control ( GCRYCTL_DISABLE_SECMEM , 0 ) ; gcry_control ( GCRYCTL_INITIALIZATION_FINISHED , 0 ) ; #endif } if ( cl . type == DAEMON && cl . site [ 0 ] ) { if ( ! find_site_by_name ( cl . site , & local , 1 ) ) { log_error ( "Cannot find \"%s\" in the configuration." , cl . site ) ; return - EINVAL ; } local -> local = 1 ; } else find_myself ( NULL , type == CLIENT || type == GEOSTORE ) ; rv = check_config ( type ) ; if ( rv < 0 ) goto out ; if ( ! cl . lockfile [ 0 ] ) { snprintf ( cl . lockfile , sizeof ( cl . lockfile ) - 1 , "%s/%s.pid" , BOOTH_RUN_DIR , booth_conf -> name ) ; } out : return rv ; }
static void ip6_append_data_mtu ( int * mtu , int * maxfraglen , unsigned int fragheaderlen , struct sk_buff * skb , struct rt6_info * rt ) { if ( ! ( rt -> dst . flags & DST_XFRM_TUNNEL ) ) { if ( skb == NULL ) { * mtu = * mtu - rt -> dst . header_len ; } else { * mtu = dst_mtu ( rt -> dst . path ) ; } * maxfraglen = ( ( * mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; } }
static void mpage_put_bnr_to_bhs ( struct mpage_da_data * mpd , sector_t logical , struct buffer_head * exbh ) { struct inode * inode = mpd -> inode ; struct address_space * mapping = inode -> i_mapping ; int blocks = exbh -> b_size > > inode -> i_blkbits ; sector_t pblock = exbh -> b_blocknr , cur_logical ; struct buffer_head * head , * bh ; pgoff_t index , end ; struct pagevec pvec ; int nr_pages , i ; index = logical > > ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; end = ( logical + blocks - 1 ) > > ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; cur_logical = index < < ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; pagevec_init ( & pvec , 0 ) ; while ( index <= end ) { nr_pages = pagevec_lookup ( & pvec , mapping , index , PAGEVEC_SIZE ) ; if ( nr_pages == 0 ) break ; for ( i = 0 ; i < nr_pages ; i ++ ) { struct page * page = pvec . pages [ i ] ; index = page -> index ; if ( index > end ) break ; index ++ ; BUG_ON ( ! PageLocked ( page ) ) ; BUG_ON ( PageWriteback ( page ) ) ; BUG_ON ( ! page_has_buffers ( page ) ) ; bh = page_buffers ( page ) ; head = bh ; do { if ( cur_logical >= logical ) break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do { if ( cur_logical >= logical + blocks ) break ; if ( buffer_delay ( bh ) || buffer_unwritten ( bh ) ) { BUG_ON ( bh -> b_bdev != inode -> i_sb -> s_bdev ) ; if ( buffer_delay ( bh ) ) { clear_buffer_delay ( bh ) ; bh -> b_blocknr = pblock ; } else { clear_buffer_unwritten ( bh ) ; BUG_ON ( bh -> b_blocknr != pblock ) ; } } else if ( buffer_mapped ( bh ) ) BUG_ON ( bh -> b_blocknr != pblock ) ; cur_logical ++ ; pblock ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; } pagevec_release ( & pvec ) ; } }
bool JSInliner :: DetermineCallTarget ( Node * node , Handle < SharedFunctionInfo > & shared_info_out ) { DCHECK ( IrOpcode :: IsInlineeOpcode ( node -> opcode ( ) ) ) ; HeapObjectMatcher match ( node -> InputAt ( 0 ) ) ; if ( match . HasValue ( ) && match . Value ( ) -> IsJSFunction ( ) ) { Handle < JSFunction > function = Handle < JSFunction > :: cast ( match . Value ( ) ) ; if ( function -> context ( ) -> native_context ( ) != info_ -> context ( ) -> native_context ( ) ) { return false ; } shared_info_out = handle ( function -> shared ( ) , isolate ( ) ) ; return true ; } if ( match . IsJSCreateClosure ( ) ) { CreateClosureParameters const & p = CreateClosureParametersOf ( match . op ( ) ) ; Handle < FeedbackCell > cell = p . feedback_cell ( ) ; if ( ! cell -> value ( ) -> IsFeedbackVector ( ) ) return false ; shared_info_out = p . shared_info ( ) ; return true ; } return false ; }
WrapperFactory :: WaiveXray ( JSContext * cx , JSObject * obj ) { obj = UnwrapObject ( obj ) ; obj = GetCurrentOuter ( cx , obj ) ; { CompartmentPrivate * priv = ( CompartmentPrivate * ) JS_GetCompartmentPrivate ( cx , js :: GetObjectCompartment ( obj ) ) ; JSObject * wobj = nsnull ; if ( priv && priv -> waiverWrapperMap ) wobj = priv -> waiverWrapperMap -> Find ( obj ) ; if ( ! wobj ) { JSObject * proto = js :: GetObjectProto ( obj ) ; if ( proto && ! ( proto = WaiveXray ( cx , proto ) ) ) return nsnull ; JSAutoEnterCompartment ac ; if ( ! ac . enter ( cx , obj ) || ! JS_WrapObject ( cx , & proto ) ) return nsnull ; wobj = Wrapper :: New ( cx , obj , proto , JS_GetGlobalForObject ( cx , obj ) , & WaiveXrayWrapperWrapper ) ; if ( ! wobj ) return nsnull ; if ( priv ) { if ( ! priv -> waiverWrapperMap ) { priv -> waiverWrapperMap = JSObject2JSObjectMap :: newMap ( XPC_WRAPPER_MAP_SIZE ) ; if ( ! priv -> waiverWrapperMap ) return nsnull ; } if ( ! priv -> waiverWrapperMap -> Add ( obj , wobj ) ) return nsnull ; } } obj = wobj ; } return obj ; }
static void predict_and_reconstruct_intra_block ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct intra_args * const args = ( struct intra_args * ) arg ; VP9_COMMON * const cm = args -> cm ; MACROBLOCKD * const xd = args -> xd ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; MODE_INFO * const mi = xd -> mi [ 0 ] ; const MB_PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) : mi -> mbmi . uv_mode ; int x , y ; uint8_t * dst ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ; dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ; vp9_predict_intra_block ( xd , block > > ( tx_size < < 1 ) , b_width_log2 ( plane_bsize ) , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , x , y , plane ) ; if ( ! mi -> mbmi . skip ) { const int eob = vp9_decode_block_tokens ( cm , xd , plane , block , plane_bsize , x , y , tx_size , args -> r ) ; inverse_transform_block ( xd , plane , block , tx_size , dst , pd -> dst . stride , eob ) ; } }
status_t ClearKeyCasPlugin :: setSessionPrivateData ( const CasSessionId & sessionId , const CasData & ) { ALOGV ( "setSessionPrivateData: sessionId=%s" , sessionIdToString ( sessionId ) . string ( ) ) ; sp < ClearKeyCasSession > session = ClearKeySessionLibrary :: get ( ) -> findSession ( sessionId ) ; if ( session == NULL ) { return ERROR_CAS_SESSION_NOT_OPENED ; } return OK ; }
COMPAT_SYSCALL_DEFINE5 ( waitid , int , which , compat_pid_t , pid , struct compat_siginfo __user * , infop , int , options , struct compat_rusage __user * , uru ) { struct rusage ru ; struct waitid_info info = { . status = 0 } ; long err = kernel_waitid ( which , pid , & info , options , uru ? & ru : NULL ) ; int signo = 0 ; if ( err > 0 ) { signo = SIGCHLD ; err = 0 ; } if ( ! err && uru ) { if ( COMPAT_USE_64BIT_TIME ) err = copy_to_user ( uru , & ru , sizeof ( ru ) ) ; else err = put_compat_rusage ( & ru , uru ) ; if ( err ) return - EFAULT ; } if ( ! infop ) return err ; user_access_begin ( ) ; unsafe_put_user ( signo , & infop -> si_signo , Efault ) ; unsafe_put_user ( 0 , & infop -> si_errno , Efault ) ; unsafe_put_user ( info . cause , & infop -> si_code , Efault ) ; unsafe_put_user ( info . pid , & infop -> si_pid , Efault ) ; unsafe_put_user ( info . uid , & infop -> si_uid , Efault ) ; unsafe_put_user ( info . status , & infop -> si_status , Efault ) ; user_access_end ( ) ; return err ; Efault : user_access_end ( ) ; return - EFAULT ; }
piv_compute_signature ( sc_card_t * card , const u8 * data , size_t datalen , u8 * out , size_t outlen ) { piv_private_data_t * priv = PIV_DATA ( card ) ; int r ; int i ; size_t nLen ; u8 rbuf [ 128 ] ; const u8 * body ; size_t bodylen ; const u8 * tag ; size_t taglen ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_VERBOSE ) ; if ( priv -> alg_id == 0x11 || priv -> alg_id == 0x14 ) { nLen = ( priv -> key_size + 7 ) / 8 ; if ( outlen < 2 * nLen ) { sc_log ( card -> ctx , " output too small for EC signature %"SC_FORMAT_LEN_SIZE_T "u < %"SC_FORMAT_LEN_SIZE_T "u" , outlen , 2 * nLen ) ; r = SC_ERROR_INVALID_DATA ; goto err ; } memset ( out , 0 , outlen ) ; r = piv_validate_general_authentication ( card , data , datalen , rbuf , sizeof rbuf ) ; if ( r < 0 ) goto err ; body = sc_asn1_find_tag ( card -> ctx , rbuf , r , 0x30 , & bodylen ) ; for ( i = 0 ; i < 2 ; i ++ ) { if ( body ) { tag = sc_asn1_find_tag ( card -> ctx , body , bodylen , 0x02 , & taglen ) ; if ( tag ) { bodylen -= taglen - ( tag - body ) ; body = tag + taglen ; if ( taglen > nLen ) { if ( * tag != 0x00 ) { r = SC_ERROR_INVALID_DATA ; goto err ; } tag ++ ; taglen -- ; } memcpy ( out + nLen * i + nLen - taglen , tag , taglen ) ; } else { r = SC_ERROR_INVALID_DATA ; goto err ; } } else { r = SC_ERROR_INVALID_DATA ; goto err ; } } r = 2 * nLen ; } else { r = piv_validate_general_authentication ( card , data , datalen , out , outlen ) ; } err : SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , r ) ; }
mono_gc_init ( void ) { InitializeCriticalSection ( & handle_section ) ; InitializeCriticalSection ( & allocator_section ) ; InitializeCriticalSection ( & finalizer_mutex ) ; MONO_GC_REGISTER_ROOT_FIXED ( gc_handles [ HANDLE_NORMAL ] . entries ) ; MONO_GC_REGISTER_ROOT_FIXED ( gc_handles [ HANDLE_PINNED ] . entries ) ; mono_gc_base_init ( ) ; if ( mono_gc_is_disabled ( ) ) { gc_disabled = TRUE ; return ; } finalizer_event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ; pending_done_event = CreateEvent ( NULL , TRUE , FALSE , NULL ) ; shutdown_event = CreateEvent ( NULL , TRUE , FALSE , NULL ) ; if ( finalizer_event == NULL || pending_done_event == NULL || shutdown_event == NULL ) { g_assert_not_reached ( ) ; } #ifdef MONO_HAS_SEMAPHORES MONO_SEM_INIT ( & finalizer_sem , 0 ) ; #endif gc_thread = mono_thread_create_internal ( mono_domain_get ( ) , finalizer_thread , NULL , FALSE ) ; ves_icall_System_Threading_Thread_SetName_internal ( gc_thread , mono_string_new ( mono_domain_get ( ) , "Finalizer" ) ) ; }
void AsyncGeneratorBuiltinsAssembler :: AsyncGeneratorAwaitResumeClosure ( Node * context , Node * value , JSAsyncGeneratorObject :: ResumeMode resume_mode ) { Node * const generator = LoadContextElement ( context , AwaitContext :: kGeneratorSlot ) ; CSA_SLOW_ASSERT ( this , TaggedIsAsyncGenerator ( generator ) ) ; SetGeneratorNotAwaiting ( generator ) ; CSA_SLOW_ASSERT ( this , IsGeneratorSuspended ( generator ) ) ; StoreObjectFieldNoWriteBarrier ( generator , JSGeneratorObject :: kResumeModeOffset , SmiConstant ( resume_mode ) ) ; CallStub ( CodeFactory :: ResumeGenerator ( isolate ( ) ) , context , value , generator ) ; TailCallBuiltin ( Builtins :: kAsyncGeneratorResumeNext , context , generator ) ; }
static void tokenize_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct tokenize_b_args * const args = arg ; VP9_COMP * cpi = args -> cpi ; MACROBLOCKD * xd = args -> xd ; TOKENEXTRA * * tp = args -> tp ; uint8_t token_cache [ 32 * 32 ] ; struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ; struct macroblockd_plane * pd = & xd -> plane [ plane ] ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; int pt ; int c ; TOKENEXTRA * t = * tp ; int eob = p -> eobs [ block ] ; const PLANE_TYPE type = pd -> plane_type ; const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ; vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ; unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] = cpi -> common . counts . eob_branch [ tx_size ] [ type ] [ ref ] ; const uint8_t * const band = get_band_translate ( tx_size ) ; const int seg_eob = get_tx_eob ( & cpi -> common . seg , segment_id , tx_size ) ; int aoff , loff ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ; pt = get_entropy_context ( tx_size , pd -> above_context + aoff , pd -> left_context + loff ) ; so = get_scan ( xd , tx_size , type , block ) ; scan = so -> scan ; nb = so -> neighbors ; c = 0 ; while ( c < eob ) { int v = 0 ; int skip_eob = 0 ; v = qcoeff [ scan [ c ] ] ; while ( ! v ) { add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , ZERO_TOKEN , skip_eob , counts [ band [ c ] ] [ pt ] ) ; eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ; skip_eob = 1 ; token_cache [ scan [ c ] ] = 0 ; ++ c ; pt = get_coef_context ( nb , token_cache , c ) ; v = qcoeff [ scan [ c ] ] ; } add_token ( & t , coef_probs [ band [ c ] ] [ pt ] , vp9_dct_value_tokens_ptr [ v ] . extra , ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token , ( uint8_t ) skip_eob , counts [ band [ c ] ] [ pt ] ) ; eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ; token_cache [ scan [ c ] ] = vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ; ++ c ; pt = get_coef_context ( nb , token_cache , c ) ; } if ( c < seg_eob ) { add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , EOB_TOKEN , 0 , counts [ band [ c ] ] [ pt ] ) ; ++ eob_branch [ band [ c ] ] [ pt ] ; } * tp = t ; vp9_set_contexts ( xd , pd , plane_bsize , tx_size , c > 0 , aoff , loff ) ; }
static size_t copy_page_to_iter_pipe ( struct page * page , size_t offset , size_t bytes , struct iov_iter * i ) { struct pipe_inode_info * pipe = i -> pipe ; struct pipe_buffer * buf ; unsigned int p_tail = pipe -> tail ; unsigned int p_mask = pipe -> ring_size - 1 ; unsigned int i_head = i -> head ; size_t off ; if ( unlikely ( bytes > i -> count ) ) bytes = i -> count ; if ( unlikely ( ! bytes ) ) return 0 ; if ( ! sanity ( i ) ) return 0 ; off = i -> iov_offset ; buf = & pipe -> bufs [ i_head & p_mask ] ; if ( off ) { if ( offset == off && buf -> page == page ) { buf -> len += bytes ; i -> iov_offset += bytes ; goto out ; } i_head ++ ; buf = & pipe -> bufs [ i_head & p_mask ] ; } if ( pipe_full ( i_head , p_tail , pipe -> max_usage ) ) return 0 ; buf -> ops = & page_cache_pipe_buf_ops ; get_page ( page ) ; buf -> page = page ; buf -> offset = offset ; buf -> len = bytes ; pipe -> head = i_head + 1 ; i -> iov_offset = offset + bytes ; i -> head = i_head ; out : i -> count -= bytes ; return bytes ; }
void Builtins :: Generate_CEntry ( MacroAssembler * masm , int result_size , SaveFPRegsMode save_doubles , ArgvMode argv_mode , bool builtin_exit_frame ) { STATIC_ASSERT ( eax == kRuntimeCallArgCountRegister ) ; STATIC_ASSERT ( ecx == kRuntimeCallArgvRegister ) ; STATIC_ASSERT ( edx == kRuntimeCallFunctionRegister ) ; STATIC_ASSERT ( esi == kContextRegister ) ; STATIC_ASSERT ( edi == kJSFunctionRegister ) ; DCHECK ( ! AreAliased ( kRuntimeCallArgCountRegister , kRuntimeCallArgvRegister , kRuntimeCallFunctionRegister , kContextRegister , kJSFunctionRegister , kRootRegister ) ) ; ProfileEntryHookStub :: MaybeCallEntryHook ( masm ) ; int arg_stack_space = 3 ; if ( argv_mode == kArgvInRegister ) { DCHECK ( save_doubles == kDontSaveFPRegs ) ; DCHECK ( ! builtin_exit_frame ) ; __ EnterApiExitFrame ( arg_stack_space ) ; __ mov ( esi , ecx ) ; __ mov ( edi , eax ) ; } else { __ EnterExitFrame ( arg_stack_space , save_doubles == kSaveFPRegs , builtin_exit_frame ? StackFrame :: BUILTIN_EXIT : StackFrame :: EXIT ) ; } if ( FLAG_debug_code ) { __ CheckStackAlignment ( ) ; } __ mov ( Operand ( esp , 0 * kPointerSize ) , edi ) ; __ mov ( Operand ( esp , 1 * kPointerSize ) , esi ) ; __ mov ( Operand ( esp , 2 * kPointerSize ) , Immediate ( ExternalReference :: isolate_address ( masm -> isolate ( ) ) ) ) ; __ call ( kRuntimeCallFunctionRegister ) ; Label exception_returned ; __ cmp ( eax , masm -> isolate ( ) -> factory ( ) -> exception ( ) ) ; __ j ( equal , & exception_returned ) ; if ( FLAG_debug_code ) { __ push ( edx ) ; __ mov ( edx , Immediate ( masm -> isolate ( ) -> factory ( ) -> the_hole_value ( ) ) ) ; Label okay ; ExternalReference pending_exception_address = ExternalReference :: Create ( IsolateAddressId :: kPendingExceptionAddress , masm -> isolate ( ) ) ; __ cmp ( edx , __ StaticVariable ( pending_exception_address ) ) ; __ j ( equal , & okay , Label :: kNear ) ; __ int3 ( ) ; __ bind ( & okay ) ; __ pop ( edx ) ; } __ LeaveExitFrame ( save_doubles == kSaveFPRegs , argv_mode == kArgvOnStack ) ; __ ret ( 0 ) ; __ bind ( & exception_returned ) ; ExternalReference pending_handler_context_address = ExternalReference :: Create ( IsolateAddressId :: kPendingHandlerContextAddress , masm -> isolate ( ) ) ; ExternalReference pending_handler_entrypoint_address = ExternalReference :: Create ( IsolateAddressId :: kPendingHandlerEntrypointAddress , masm -> isolate ( ) ) ; ExternalReference pending_handler_fp_address = ExternalReference :: Create ( IsolateAddressId :: kPendingHandlerFPAddress , masm -> isolate ( ) ) ; ExternalReference pending_handler_sp_address = ExternalReference :: Create ( IsolateAddressId :: kPendingHandlerSPAddress , masm -> isolate ( ) ) ; ExternalReference find_handler = ExternalReference :: Create ( Runtime :: kUnwindAndFindExceptionHandler ) ; { FrameScope scope ( masm , StackFrame :: MANUAL ) ; __ PrepareCallCFunction ( 3 , eax ) ; __ mov ( Operand ( esp , 0 * kPointerSize ) , Immediate ( 0 ) ) ; __ mov ( Operand ( esp , 1 * kPointerSize ) , Immediate ( 0 ) ) ; __ mov ( Operand ( esp , 2 * kPointerSize ) , Immediate ( ExternalReference :: isolate_address ( masm -> isolate ( ) ) ) ) ; __ CallCFunction ( find_handler , 3 ) ; } __ mov ( esi , __ StaticVariable ( pending_handler_context_address ) ) ; __ mov ( esp , __ StaticVariable ( pending_handler_sp_address ) ) ; __ mov ( ebp , __ StaticVariable ( pending_handler_fp_address ) ) ; Label skip ; __ test ( esi , esi ) ; __ j ( zero , & skip , Label :: kNear ) ; __ mov ( Operand ( ebp , StandardFrameConstants :: kContextOffset ) , esi ) ; __ bind ( & skip ) ; __ ResetSpeculationPoisonRegister ( ) ; __ mov ( edi , __ StaticVariable ( pending_handler_entrypoint_address ) ) ; __ jmp ( edi ) ; }
void Debug :: ThreadInit ( ) { thread_local_ . break_frame_id_ = StackFrame :: NO_ID ; thread_local_ . last_step_action_ = StepNone ; thread_local_ . last_statement_position_ = kNoSourcePosition ; thread_local_ . last_frame_count_ = - 1 ; thread_local_ . fast_forward_to_return_ = false ; thread_local_ . ignore_step_into_function_ = Smi :: kZero ; thread_local_ . target_frame_count_ = - 1 ; thread_local_ . return_value_ = Smi :: kZero ; thread_local_ . last_breakpoint_id_ = 0 ; clear_suspended_generator ( ) ; thread_local_ . restart_fp_ = kNullAddress ; base :: Relaxed_Store ( & thread_local_ . current_debug_scope_ , static_cast < base :: AtomicWord > ( 0 ) ) ; thread_local_ . break_on_next_function_call_ = false ; UpdateHookOnFunctionCall ( ) ; }
struct snd_seq_client_port * snd_seq_create_port ( struct snd_seq_client * client , int port ) { unsigned long flags ; struct snd_seq_client_port * new_port , * p ; int num = - 1 ; if ( snd_BUG_ON ( ! client ) ) return NULL ; if ( client -> num_ports >= SNDRV_SEQ_MAX_PORTS ) { pr_warn ( "ALSA: seq: too many ports for client %d\n" , client -> number ) ; return NULL ; } new_port = kzalloc ( sizeof ( * new_port ) , GFP_KERNEL ) ; if ( ! new_port ) return NULL ; new_port -> addr . client = client -> number ; new_port -> addr . port = - 1 ; new_port -> owner = THIS_MODULE ; sprintf ( new_port -> name , "port-%d" , num ) ; snd_use_lock_init ( & new_port -> use_lock ) ; port_subs_info_init ( & new_port -> c_src ) ; port_subs_info_init ( & new_port -> c_dest ) ; num = port >= 0 ? port : 0 ; mutex_lock ( & client -> ports_mutex ) ; write_lock_irqsave ( & client -> ports_lock , flags ) ; list_for_each_entry ( p , & client -> ports_list_head , list ) { if ( p -> addr . port > num ) break ; if ( port < 0 ) num = p -> addr . port + 1 ; } list_add_tail ( & new_port -> list , & p -> list ) ; client -> num_ports ++ ; new_port -> addr . port = num ; write_unlock_irqrestore ( & client -> ports_lock , flags ) ; mutex_unlock ( & client -> ports_mutex ) ; sprintf ( new_port -> name , "port-%d" , num ) ; return new_port ; }
const Operator * CommonOperatorBuilder :: TypedStateValues ( const ZoneVector < MachineType > * types , SparseInputMask bitmask ) { #if DEBUG DCHECK ( bitmask . IsDense ( ) || bitmask . CountReal ( ) == static_cast < int > ( types -> size ( ) ) ) ; #endif return new ( zone ( ) ) Operator1 < TypedStateValueInfo > ( IrOpcode :: kTypedStateValues , Operator :: kPure , "TypedStateValues" , static_cast < int > ( types -> size ( ) ) , 0 , 0 , 1 , 0 , 0 , TypedStateValueInfo ( types , bitmask ) ) ; }
Handle < CallHandlerInfo > Factory :: NewCallHandlerInfo ( bool has_no_side_effect ) { Handle < Map > map = has_no_side_effect ? side_effect_free_call_handler_info_map ( ) : side_effect_call_handler_info_map ( ) ; Handle < CallHandlerInfo > info ( CallHandlerInfo :: cast ( New ( map , TENURED ) ) , isolate ( ) ) ; Object * undefined_value = ReadOnlyRoots ( isolate ( ) ) . undefined_value ( ) ; info -> set_callback ( undefined_value ) ; info -> set_js_callback ( undefined_value ) ; info -> set_data ( undefined_value ) ; return info ; }
void CompilerDispatcher :: ScheduleMoreWorkerTasksIfNeeded ( ) { TRACE_EVENT0 ( TRACE_DISABLED_BY_DEFAULT ( "v8.compile" ) , "V8.CompilerDispatcherScheduleMoreWorkerTasksIfNeeded" ) ; { base :: LockGuard < base :: Mutex > lock ( & mutex_ ) ; if ( pending_background_jobs_ . empty ( ) ) return ; if ( platform_ -> NumberOfWorkerThreads ( ) <= num_worker_tasks_ ) { return ; } ++ num_worker_tasks_ ; } platform_ -> CallOnWorkerThread ( base :: make_unique < WorkerTask > ( task_manager_ . get ( ) , this ) ) ; }
void * OS :: Allocate ( void * address , size_t size , size_t alignment , MemoryPermission access ) { size_t page_size = AllocatePageSize ( ) ; DCHECK_EQ ( 0 , size % page_size ) ; DCHECK_EQ ( 0 , alignment % page_size ) ; DCHECK_LE ( page_size , alignment ) ; address = AlignedAddress ( address , alignment ) ; DWORD flags = ( access == OS :: MemoryPermission :: kNoAccess ) ? MEM_RESERVE : MEM_RESERVE | MEM_COMMIT ; DWORD protect = GetProtectionFromMemoryPermission ( access ) ; uint8_t * base = RandomizedVirtualAlloc ( size , flags , protect , address ) ; if ( base == nullptr ) return nullptr ; uint8_t * aligned_base = RoundUp ( base , alignment ) ; if ( base == aligned_base ) return reinterpret_cast < void * > ( base ) ; CHECK ( Free ( base , size ) ) ; address = nullptr ; size_t padded_size = size + ( alignment - page_size ) ; const int kMaxAttempts = 3 ; aligned_base = nullptr ; for ( int i = 0 ; i < kMaxAttempts ; ++ i ) { base = RandomizedVirtualAlloc ( padded_size , flags , protect , address ) ; if ( base == nullptr ) return nullptr ; CHECK ( Free ( base , padded_size ) ) ; aligned_base = RoundUp ( base , alignment ) ; base = reinterpret_cast < uint8_t * > ( VirtualAlloc ( aligned_base , size , flags , protect ) ) ; if ( base != nullptr ) break ; } DCHECK_IMPLIES ( base , base == aligned_base ) ; return reinterpret_cast < void * > ( base ) ; }
void EnqueueTask ( int aDelayMs , CancelableTask * aTask ) { MessageLoopForIO * ioLoop = MessageLoopForIO :: current ( ) ; if ( ! ioLoop ) { NS_WARNING ( "No IOLoop to attach to, cancelling self!" ) ; return ; } if ( mTask ) { return ; } if ( IsCanceled ( ) ) { return ; } mTask = aTask ; if ( aDelayMs ) { ioLoop -> PostDelayedTask ( FROM_HERE , mTask , aDelayMs ) ; } else { ioLoop -> PostTask ( FROM_HERE , mTask ) ; } }
Handle < PrototypeInfo > Factory :: NewPrototypeInfo ( ) { Handle < PrototypeInfo > result = Handle < PrototypeInfo > :: cast ( NewStruct ( PROTOTYPE_INFO_TYPE , TENURED ) ) ; result -> set_prototype_users ( * empty_weak_array_list ( ) ) ; result -> set_registry_slot ( PrototypeInfo :: UNREGISTERED ) ; result -> set_bit_field ( 0 ) ; result -> set_module_namespace ( * undefined_value ( ) ) ; return result ; }
nsRootPresContext :: nsRootPresContext ( nsIDocument * aDocument , nsPresContextType aType ) : nsPresContext ( aDocument , aType ) , mUpdatePluginGeometryForFrame ( nullptr ) , mDOMGeneration ( 0 ) , mNeedsToUpdatePluginGeometry ( false ) { mRegisteredPlugins . Init ( ) ; }
LookupStatus generateStub ( uint32 initialShape , const Shape * shape , bool adding , bool inlineSlot ) { Vector < Jump , 8 > slowExits ( cx ) ; Vector < Jump , 8 > otherGuards ( cx ) ; Assembler masm ; if ( pic . shapeNeedsRemat ( ) ) { masm . loadShape ( pic . objReg , pic . shapeReg ) ; pic . shapeRegHasBaseShape = true ; } Label start = masm . label ( ) ; Jump shapeGuard = masm . branch32FixedLength ( Assembler :: NotEqual , pic . shapeReg , Imm32 ( initialShape ) ) ; Label stubShapeJumpLabel = masm . label ( ) ; pic . setPropLabels ( ) . setStubShapeJump ( masm , start , stubShapeJumpLabel ) ; JS_ASSERT_IF ( ! shape -> hasDefaultSetter ( ) , obj -> getClass ( ) == & js_CallClass ) ; MaybeJump skipOver ; if ( adding ) { JS_ASSERT ( shape -> hasSlot ( ) ) ; pic . shapeRegHasBaseShape = false ; JSObject * proto = obj -> getProto ( ) ; RegisterID lastReg = pic . objReg ; while ( proto ) { masm . loadPtr ( Address ( lastReg , offsetof ( JSObject , proto ) ) , pic . shapeReg ) ; Jump protoGuard = masm . guardShape ( pic . shapeReg , proto ) ; if ( ! otherGuards . append ( protoGuard ) ) return error ( ) ; proto = proto -> getProto ( ) ; lastReg = pic . shapeReg ; } if ( pic . kind == ic :: PICInfo :: SETMETHOD ) { JS_ASSERT ( shape -> isMethod ( ) ) ; JSObject * funobj = & shape -> methodObject ( ) ; if ( pic . u . vr . isConstant ( ) ) { JS_ASSERT ( funobj == & pic . u . vr . value ( ) . toObject ( ) ) ; } else { Jump mismatchedFunction = masm . branchPtr ( Assembler :: NotEqual , pic . u . vr . dataReg ( ) , ImmPtr ( funobj ) ) ; if ( ! slowExits . append ( mismatchedFunction ) ) return error ( ) ; } } if ( inlineSlot ) { Address address ( pic . objReg , JSObject :: getFixedSlotOffset ( shape -> slot ) ) ; masm . storeValue ( pic . u . vr , address ) ; } else { Address capacity ( pic . objReg , offsetof ( JSObject , capacity ) ) ; masm . load32 ( capacity , pic . shapeReg ) ; Jump overCapacity = masm . branch32 ( Assembler :: LessThanOrEqual , pic . shapeReg , Imm32 ( shape -> slot ) ) ; if ( ! slowExits . append ( overCapacity ) ) return error ( ) ; masm . loadPtr ( Address ( pic . objReg , offsetof ( JSObject , slots ) ) , pic . shapeReg ) ; Address address ( pic . shapeReg , shape -> slot * sizeof ( Value ) ) ; masm . storeValue ( pic . u . vr , address ) ; } uint32 newShape = obj -> shape ( ) ; JS_ASSERT ( newShape != initialShape ) ; masm . storePtr ( ImmPtr ( shape ) , Address ( pic . objReg , offsetof ( JSObject , lastProp ) ) ) ; masm . store32 ( Imm32 ( newShape ) , Address ( pic . objReg , offsetof ( JSObject , objShape ) ) ) ; if ( shape -> isMethod ( ) ) { Address flags ( pic . objReg , offsetof ( JSObject , flags ) ) ; masm . load32 ( flags , pic . shapeReg ) ; masm . or32 ( Imm32 ( JSObject :: METHOD_BARRIER ) , pic . shapeReg ) ; masm . store32 ( pic . shapeReg , flags ) ; } } else if ( shape -> hasDefaultSetter ( ) ) { Address address ( pic . objReg , JSObject :: getFixedSlotOffset ( shape -> slot ) ) ; if ( ! inlineSlot ) { masm . loadPtr ( Address ( pic . objReg , offsetof ( JSObject , slots ) ) , pic . objReg ) ; address = Address ( pic . objReg , shape -> slot * sizeof ( Value ) ) ; } if ( obj -> brandedOrHasMethodBarrier ( ) ) { masm . loadTypeTag ( address , pic . shapeReg ) ; Jump skip = masm . testObject ( Assembler :: NotEqual , pic . shapeReg ) ; masm . loadPayload ( address , pic . shapeReg ) ; Jump rebrand = masm . testFunction ( Assembler :: Equal , pic . shapeReg ) ; if ( ! slowExits . append ( rebrand ) ) return error ( ) ; skip . linkTo ( masm . label ( ) , & masm ) ; pic . shapeRegHasBaseShape = false ; } masm . storeValue ( pic . u . vr , address ) ; } else { JSFunction * fun = obj -> getCallObjCalleeFunction ( ) ; uint16 slot = uint16 ( shape -> shortid ) ; masm . loadObjPrivate ( pic . objReg , pic . shapeReg ) ; Jump escapedFrame = masm . branchTestPtr ( Assembler :: Zero , pic . shapeReg , pic . shapeReg ) ; { Address addr ( pic . shapeReg , shape -> setterOp ( ) == SetCallArg ? StackFrame :: offsetOfFormalArg ( fun , slot ) : StackFrame :: offsetOfFixed ( slot ) ) ; masm . storeValue ( pic . u . vr , addr ) ; skipOver = masm . jump ( ) ; } escapedFrame . linkTo ( masm . label ( ) , & masm ) ; { if ( shape -> setterOp ( ) == SetCallVar ) slot += fun -> nargs ; masm . loadPtr ( Address ( pic . objReg , offsetof ( JSObject , slots ) ) , pic . objReg ) ; Address dslot ( pic . objReg , ( slot + JSObject :: CALL_RESERVED_SLOTS ) * sizeof ( Value ) ) ; masm . storeValue ( pic . u . vr , dslot ) ; } pic . shapeRegHasBaseShape = false ; } Jump done = masm . jump ( ) ; MaybeJump slowExit ; if ( otherGuards . length ( ) ) { for ( Jump * pj = otherGuards . begin ( ) ; pj != otherGuards . end ( ) ; ++ pj ) pj -> linkTo ( masm . label ( ) , & masm ) ; slowExit = masm . jump ( ) ; pic . secondShapeGuard = masm . distanceOf ( masm . label ( ) ) - masm . distanceOf ( start ) ; } else { pic . secondShapeGuard = 0 ; } PICLinker buffer ( masm , pic ) ; if ( ! buffer . init ( cx ) ) return error ( ) ; if ( ! buffer . verifyRange ( pic . lastCodeBlock ( f . jit ( ) ) ) || ! buffer . verifyRange ( f . jit ( ) ) ) { return disable ( "code memory is out of range" ) ; } buffer . link ( shapeGuard , pic . slowPathStart ) ; if ( slowExit . isSet ( ) ) buffer . link ( slowExit . get ( ) , pic . slowPathStart ) ; for ( Jump * pj = slowExits . begin ( ) ; pj != slowExits . end ( ) ; ++ pj ) buffer . link ( * pj , pic . slowPathStart ) ; buffer . link ( done , pic . fastPathRejoin ) ; if ( skipOver . isSet ( ) ) buffer . link ( skipOver . get ( ) , pic . fastPathRejoin ) ; CodeLocationLabel cs = buffer . finalize ( ) ; JaegerSpew ( JSpew_PICs , "generate setprop stub %p %d %d at %p\n" , ( void * ) & pic , initialShape , pic . stubsGenerated , cs . executableAddress ( ) ) ; patchPreviousToHere ( cs ) ; pic . stubsGenerated ++ ; pic . updateLastPath ( buffer , start ) ; if ( pic . stubsGenerated == MAX_PIC_STUBS ) disable ( "max stubs reached" ) ; return Lookup_Cacheable ; }
. SetShapeFn ( [ ] ( InferenceContext * c ) { int axis ; TF_RETURN_IF_ERROR ( c -> GetAttr ( "axis" , & axis ) ) ; const int minmax_rank = ( axis == - 1 ) ? 0 : 1 ; ShapeHandle minmax ; TF_RETURN_IF_ERROR ( c -> WithRank ( c -> input ( 2 ) , minmax_rank , & minmax ) ) ; TF_RETURN_IF_ERROR ( c -> Merge ( c -> input ( 3 ) , minmax , & minmax ) ) ; if ( axis != - 1 ) { ShapeHandle input ; TF_RETURN_IF_ERROR ( c -> WithRankAtLeast ( c -> input ( 0 ) , axis + 1 , & input ) ) ; DimensionHandle depth ; TF_RETURN_IF_ERROR ( c -> Merge ( c -> Dim ( minmax , 0 ) , c -> Dim ( input , axis ) , & depth ) ) ; } ShapeHandle inputs ; TF_RETURN_IF_ERROR ( c -> Merge ( c -> input ( 0 ) , c -> input ( 1 ) , & inputs ) ) ; c -> set_output ( 0 , inputs ) ; c -> set_output ( 1 , minmax ) ; c -> set_output ( 2 , minmax ) ; return Status :: OK ( ) ; } ) ;
WasmModuleBuilder :: WasmModuleBuilder ( Zone * zone ) : zone_ ( zone ) , signatures_ ( zone ) , function_imports_ ( zone ) , function_exports_ ( zone ) , global_imports_ ( zone ) , functions_ ( zone ) , data_segments_ ( zone ) , indirect_functions_ ( zone ) , globals_ ( zone ) , signature_map_ ( zone ) , start_function_index_ ( - 1 ) , min_memory_size_ ( 16 ) , max_memory_size_ ( 0 ) , has_max_memory_size_ ( false ) , has_shared_memory_ ( false ) { }
void DeclarationScope :: DeclareThis ( AstValueFactory * ast_value_factory ) { DCHECK ( ! already_resolved_ ) ; DCHECK ( is_declaration_scope ( ) ) ; DCHECK ( has_this_declaration ( ) ) ; bool derived_constructor = IsDerivedConstructor ( function_kind_ ) ; Variable * var = Declare ( zone ( ) , ast_value_factory -> this_string ( ) , derived_constructor ? VariableMode :: kConst : VariableMode :: kVar , THIS_VARIABLE , derived_constructor ? kNeedsInitialization : kCreatedInitialized ) ; receiver_ = var ; }
Status ArrayFromMemory ( int dim_size , npy_intp * dims , void * data , DataType dtype , std :: function < void ( ) > destructor , PyObject * * result ) { if ( dtype == DT_STRING || dtype == DT_RESOURCE ) { return errors :: FailedPrecondition ( "Cannot convert string or resource Tensors." ) ; } int type_num = - 1 ; Status s = TF_DataType_to_PyArray_TYPE ( static_cast < TF_DataType > ( dtype ) , & type_num ) ; if ( ! s . ok ( ) ) { return s ; } if ( dim_size > NPY_MAXDIMS ) { return errors :: InvalidArgument ( "Cannot convert tensor with " , dim_size , " dimensions to NumPy array. NumPy arrays can have at most " , NPY_MAXDIMS , " dimensions" ) ; } auto * np_array = reinterpret_cast < PyArrayObject * > ( PyArray_SimpleNewFromData ( dim_size , dims , type_num , data ) ) ; PyArray_CLEARFLAGS ( np_array , NPY_ARRAY_OWNDATA ) ; if ( PyType_Ready ( & TensorReleaserType ) == - 1 ) { return errors :: Unknown ( "Python type initialization failed." ) ; } auto * releaser = reinterpret_cast < TensorReleaser * > ( TensorReleaserType . tp_alloc ( & TensorReleaserType , 0 ) ) ; releaser -> destructor = new std :: function < void ( ) > ( std :: move ( destructor ) ) ; if ( PyArray_SetBaseObject ( np_array , reinterpret_cast < PyObject * > ( releaser ) ) == - 1 ) { Py_DECREF ( releaser ) ; return errors :: Unknown ( "Python array refused to use memory." ) ; } * result = reinterpret_cast < PyObject * > ( np_array ) ; return OkStatus ( ) ; }
void EffectControlLinearizer :: LowerStoreDataViewElement ( Node * node ) { ExternalArrayType element_type = ExternalArrayTypeOf ( node -> op ( ) ) ; Node * buffer = node -> InputAt ( 0 ) ; Node * storage = node -> InputAt ( 1 ) ; Node * index = node -> InputAt ( 2 ) ; Node * value = node -> InputAt ( 3 ) ; Node * is_little_endian = node -> InputAt ( 4 ) ; if ( machine ( ) -> Is64 ( ) ) { index = __ ChangeUint32ToUint64 ( index ) ; } __ Retain ( buffer ) ; MachineType const machine_type = AccessBuilder :: ForTypedArrayElement ( element_type , true ) . machine_type ; auto big_endian = __ MakeLabel ( ) ; auto done = __ MakeLabel ( machine_type . representation ( ) ) ; __ GotoIfNot ( is_little_endian , & big_endian ) ; { #if V8_TARGET_LITTLE_ENDIAN __ Goto ( & done , value ) ; #else __ Goto ( & done , BuildReverseBytes ( element_type , value ) ) ; #endif // V8_TARGET_LITTLE_ENDIAN } __ Bind ( & big_endian ) ; { #if V8_TARGET_LITTLE_ENDIAN __ Goto ( & done , BuildReverseBytes ( element_type , value ) ) ; #else __ Goto ( & done , value ) ; #endif // V8_TARGET_LITTLE_ENDIAN } __ Bind ( & done ) ; __ StoreUnaligned ( machine_type . representation ( ) , storage , index , done . PhiAt ( 0 ) ) ; }
static int llc_ui_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddrlen , int peer ) { struct sockaddr_llc sllc ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; int rc = 0 ; memset ( & sllc , 0 , sizeof ( sllc ) ) ; lock_sock ( sk ) ; if ( sock_flag ( sk , SOCK_ZAPPED ) ) goto out ; * uaddrlen = sizeof ( sllc ) ; memset ( uaddr , 0 , * uaddrlen ) ; if ( peer ) { rc = - ENOTCONN ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; if ( llc -> dev ) sllc . sllc_arphrd = llc -> dev -> type ; sllc . sllc_sap = llc -> daddr . lsap ; memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ) ; } else { rc = - EINVAL ; if ( ! llc -> sap ) goto out ; sllc . sllc_sap = llc -> sap -> laddr . lsap ; if ( llc -> dev ) { sllc . sllc_arphrd = llc -> dev -> type ; memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ) ; } } rc = 0 ; sllc . sllc_family = AF_LLC ; memcpy ( uaddr , & sllc , sizeof ( sllc ) ) ; out : release_sock ( sk ) ; return rc ; }
const Operator * MachineOperatorBuilder :: StackSlot ( int size , int alignment ) { DCHECK_LE ( 0 , size ) ; DCHECK ( alignment == 0 || alignment == 4 || alignment == 8 || alignment == 16 ) ; #define CASE_CACHED_SIZE(Size, Alignment)                          \  if (size == Size && alignment == Alignment) {                    \  return &cache_.kStackSlotOfSize##Size##OfAlignment##Alignment; \  } STACK_SLOT_CACHED_SIZES_ALIGNMENTS_LIST ( CASE_CACHED_SIZE ) #undef CASE_CACHED_SIZE return new ( zone_ ) StackSlotOperator ( size , alignment ) ; }
Variant HHVM_FUNCTION ( fwrite , const Resource & handle , const String & data , int64_t length ) { CHECK_HANDLE ( handle , f ) ; int64_t ret = f -> write ( data , length ) ; if ( ret < 0 ) { raise_notice ( "fwrite(): send of %d bytes failed with errno=%d %s" , data . size ( ) , errno , folly :: errnoStr ( errno ) . c_str ( ) ) ; ret = 0 ; } return ret ; }
void DefaultWorkerThreadsTaskRunner :: Terminate ( ) { base :: LockGuard < base :: Mutex > guard ( & lock_ ) ; terminated_ = true ; queue_ . Terminate ( ) ; thread_pool_ . clear ( ) ; }
static int tap_if_down ( const char * devname ) { struct ifreq ifr ; int sk ; sk = socket ( AF_INET , SOCK_DGRAM , 0 ) ; if ( sk < 0 ) return - 1 ; memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , devname , IF_NAMESIZE - 1 ) ; ifr . ifr_flags &= ~ IFF_UP ; ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; close ( sk ) ; return 0 ; }
nsDocShell :: AddToSessionHistory ( nsIURI * aURI , nsIChannel * aChannel , nsISupports * aOwner , bool aCloneChildren , nsISHEntry * * aNewEntry ) { NS_PRECONDITION ( aURI , "uri is null" ) ; NS_PRECONDITION ( ! aChannel || ! aOwner , "Shouldn't have both set" ) ; #if defined(DEBUG) if ( MOZ_LOG_TEST ( gDocShellLog , LogLevel :: Debug ) ) { nsAutoCString spec ; aURI -> GetSpec ( spec ) ; nsAutoCString chanName ; if ( aChannel ) { aChannel -> GetName ( chanName ) ; } else { chanName . AssignLiteral ( "<no channel>" ) ; } MOZ_LOG ( gDocShellLog , LogLevel :: Debug , ( "nsDocShell[%p]::AddToSessionHistory(\"%s\", [%s])\n" , this , spec . get ( ) , chanName . get ( ) ) ) ; } #endif nsresult rv = NS_OK ; nsCOMPtr < nsISHEntry > entry ; bool shouldPersist ; shouldPersist = ShouldAddToSessionHistory ( aURI ) ; nsCOMPtr < nsIDocShellTreeItem > root ; GetSameTypeRootTreeItem ( getter_AddRefs ( root ) ) ; if ( LOAD_TYPE_HAS_FLAGS ( mLoadType , LOAD_FLAGS_REPLACE_HISTORY ) && root != static_cast < nsIDocShellTreeItem * > ( this ) ) { entry = mOSHE ; nsCOMPtr < nsISHContainer > shContainer ( do_QueryInterface ( entry ) ) ; if ( shContainer ) { int32_t childCount = 0 ; shContainer -> GetChildCount ( & childCount ) ; for ( int32_t i = childCount - 1 ; i >= 0 ; i -- ) { nsCOMPtr < nsISHEntry > child ; shContainer -> GetChildAt ( i , getter_AddRefs ( child ) ) ; shContainer -> RemoveChild ( child ) ; } entry -> AbandonBFCacheEntry ( ) ; } } if ( ! entry ) { entry = do_CreateInstance ( NS_SHENTRY_CONTRACTID ) ; if ( ! entry ) { return NS_ERROR_OUT_OF_MEMORY ; } } nsCOMPtr < nsIInputStream > inputStream ; nsCOMPtr < nsIURI > referrerURI ; uint32_t referrerPolicy = mozilla :: net :: RP_Default ; nsCOMPtr < nsISupports > cacheKey ; nsCOMPtr < nsISupports > owner = aOwner ; bool expired = false ; bool discardLayoutState = false ; nsCOMPtr < nsICacheInfoChannel > cacheChannel ; if ( aChannel ) { cacheChannel = do_QueryInterface ( aChannel ) ; if ( cacheChannel ) { cacheChannel -> GetCacheKey ( getter_AddRefs ( cacheKey ) ) ; } nsCOMPtr < nsIHttpChannel > httpChannel ( do_QueryInterface ( aChannel ) ) ; if ( ! httpChannel ) { GetHttpChannel ( aChannel , getter_AddRefs ( httpChannel ) ) ; } if ( httpChannel ) { nsCOMPtr < nsIUploadChannel > uploadChannel ( do_QueryInterface ( httpChannel ) ) ; if ( uploadChannel ) { uploadChannel -> GetUploadStream ( getter_AddRefs ( inputStream ) ) ; } httpChannel -> GetReferrer ( getter_AddRefs ( referrerURI ) ) ; httpChannel -> GetReferrerPolicy ( & referrerPolicy ) ; discardLayoutState = ShouldDiscardLayoutState ( httpChannel ) ; } aChannel -> GetOwner ( getter_AddRefs ( owner ) ) ; if ( ! owner ) { nsCOMPtr < nsILoadInfo > loadInfo ; aChannel -> GetLoadInfo ( getter_AddRefs ( loadInfo ) ) ; if ( loadInfo ) { if ( loadInfo -> GetLoadingSandboxed ( ) ) { owner = nsNullPrincipal :: CreateWithInheritedAttributes ( loadInfo -> LoadingPrincipal ( ) ) ; NS_ENSURE_TRUE ( owner , NS_ERROR_FAILURE ) ; } else if ( loadInfo -> GetForceInheritPrincipal ( ) ) { owner = loadInfo -> TriggeringPrincipal ( ) ; } } } } entry -> Create ( aURI , EmptyString ( ) , inputStream , nullptr , cacheKey , mContentTypeHint , owner , mHistoryID , mDynamicallyCreated ) ; entry -> SetReferrerURI ( referrerURI ) ; entry -> SetReferrerPolicy ( referrerPolicy ) ; nsCOMPtr < nsIInputStreamChannel > inStrmChan = do_QueryInterface ( aChannel ) ; if ( inStrmChan ) { bool isSrcdocChannel ; inStrmChan -> GetIsSrcdocChannel ( & isSrcdocChannel ) ; if ( isSrcdocChannel ) { nsAutoString srcdoc ; inStrmChan -> GetSrcdocData ( srcdoc ) ; entry -> SetSrcdocData ( srcdoc ) ; nsCOMPtr < nsILoadInfo > loadInfo ; aChannel -> GetLoadInfo ( getter_AddRefs ( loadInfo ) ) ; nsCOMPtr < nsIURI > baseURI ; inStrmChan -> GetBaseURI ( getter_AddRefs ( baseURI ) ) ; entry -> SetBaseURI ( baseURI ) ; } } if ( discardLayoutState ) { entry -> SetSaveLayoutStateFlag ( false ) ; } if ( cacheChannel ) { uint32_t expTime = 0 ; cacheChannel -> GetCacheTokenExpirationTime ( & expTime ) ; uint32_t now = PRTimeToSeconds ( PR_Now ( ) ) ; if ( expTime <= now ) { expired = true ; } } if ( expired ) { entry -> SetExpirationStatus ( true ) ; } if ( root == static_cast < nsIDocShellTreeItem * > ( this ) && mSessionHistory ) { if ( aCloneChildren && mOSHE ) { uint32_t cloneID ; mOSHE -> GetID ( & cloneID ) ; nsCOMPtr < nsISHEntry > newEntry ; CloneAndReplace ( mOSHE , this , cloneID , entry , true , getter_AddRefs ( newEntry ) ) ; NS_ASSERTION ( entry == newEntry , "The new session history should be in the new entry" ) ; } if ( LOAD_TYPE_HAS_FLAGS ( mLoadType , LOAD_FLAGS_REPLACE_HISTORY ) ) { int32_t index = 0 ; mSessionHistory -> GetIndex ( & index ) ; nsCOMPtr < nsISHistoryInternal > shPrivate = do_QueryInterface ( mSessionHistory ) ; if ( shPrivate ) { rv = shPrivate -> ReplaceEntry ( index , entry ) ; } } else { nsCOMPtr < nsISHistoryInternal > shPrivate = do_QueryInterface ( mSessionHistory ) ; NS_ENSURE_TRUE ( shPrivate , NS_ERROR_FAILURE ) ; mSessionHistory -> GetIndex ( & mPreviousTransIndex ) ; rv = shPrivate -> AddEntry ( entry , shouldPersist ) ; mSessionHistory -> GetIndex ( & mLoadedTransIndex ) ; #ifdef DEBUG_PAGE_CACHE printf ( "Previous index: %d, Loaded index: %d\n\n" , mPreviousTransIndex , mLoadedTransIndex ) ; #endif } } else { if ( ! mOSHE || ! LOAD_TYPE_HAS_FLAGS ( mLoadType , LOAD_FLAGS_REPLACE_HISTORY ) ) { rv = AddChildSHEntryToParent ( entry , mChildOffset , aCloneChildren ) ; } } if ( aNewEntry ) { * aNewEntry = nullptr ; if ( NS_SUCCEEDED ( rv ) ) { entry . forget ( aNewEntry ) ; } } return rv ; }
IncrementalMarking :: IncrementalMarking ( Heap * heap , MarkCompactCollector :: MarkingWorklist * marking_worklist , WeakObjects * weak_objects ) : heap_ ( heap ) , marking_worklist_ ( marking_worklist ) , weak_objects_ ( weak_objects ) , initial_old_generation_size_ ( 0 ) , bytes_marked_ahead_of_schedule_ ( 0 ) , bytes_marked_concurrently_ ( 0 ) , unscanned_bytes_of_large_object_ ( 0 ) , is_compacting_ ( false ) , should_hurry_ ( false ) , was_activated_ ( false ) , black_allocation_ ( false ) , finalize_marking_completed_ ( false ) , trace_wrappers_toggle_ ( false ) , request_type_ ( NONE ) , new_generation_observer_ ( * this , kYoungGenerationAllocatedThreshold ) , old_generation_observer_ ( * this , kOldGenerationAllocatedThreshold ) { DCHECK_NOT_NULL ( marking_worklist_ ) ; SetState ( STOPPED ) ; }
void CompilerEnvironment :: computeParameters ( Decoder & d ) { MOZ_ASSERT ( ! isComputed ( ) ) ; if ( state_ == InitialWithModeTierDebug ) { computeParameters ( ) ; return ; } bool baselineEnabled = args_ -> baselineEnabled ; bool ionEnabled = args_ -> ionEnabled ; bool debugEnabled = args_ -> debugEnabled ; bool forceTiering = args_ -> forceTiering ; bool hasSecondTier = ionEnabled ; MOZ_ASSERT_IF ( debugEnabled , baselineEnabled ) ; MOZ_ASSERT_IF ( forceTiering , baselineEnabled && hasSecondTier ) ; MOZ_RELEASE_ASSERT ( baselineEnabled || ionEnabled ) ; uint32_t codeSectionSize = 0 ; SectionRange range ; if ( StartsCodeSection ( d . begin ( ) , d . end ( ) , & range ) ) { codeSectionSize = range . size ; } if ( baselineEnabled && hasSecondTier && CanUseExtraThreads ( ) && ( TieringBeneficial ( codeSectionSize ) || forceTiering ) && IsICacheSafe ( ) ) { mode_ = CompileMode :: Tier1 ; tier_ = Tier :: Baseline ; } else { mode_ = CompileMode :: Once ; tier_ = hasSecondTier ? Tier :: Optimized : Tier :: Baseline ; } optimizedBackend_ = OptimizedBackend :: Ion ; debug_ = debugEnabled ? DebugEnabled :: True : DebugEnabled :: False ; state_ = Computed ; }
_xfs_buf_find ( struct xfs_buftarg * btp , struct xfs_buf_map * map , int nmaps , xfs_buf_flags_t flags , xfs_buf_t * new_bp ) { size_t numbytes ; struct xfs_perag * pag ; struct rb_node * * rbp ; struct rb_node * parent ; xfs_buf_t * bp ; xfs_daddr_t blkno = map [ 0 ] . bm_bn ; int numblks = 0 ; int i ; for ( i = 0 ; i < nmaps ; i ++ ) numblks += map [ i ] . bm_len ; numbytes = BBTOB ( numblks ) ; ASSERT ( ! ( numbytes < ( 1 < < btp -> bt_sshift ) ) ) ; ASSERT ( ! ( BBTOB ( blkno ) & ( xfs_off_t ) btp -> bt_smask ) ) ; pag = xfs_perag_get ( btp -> bt_mount , xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ; spin_lock ( & pag -> pag_buf_lock ) ; rbp = & pag -> pag_buf_tree . rb_node ; parent = NULL ; bp = NULL ; while ( * rbp ) { parent = * rbp ; bp = rb_entry ( parent , struct xfs_buf , b_rbnode ) ; if ( blkno < bp -> b_bn ) rbp = & ( * rbp ) -> rb_left ; else if ( blkno > bp -> b_bn ) rbp = & ( * rbp ) -> rb_right ; else { if ( bp -> b_length != numblks ) { ASSERT ( bp -> b_flags & XBF_STALE ) ; rbp = & ( * rbp ) -> rb_right ; continue ; } atomic_inc ( & bp -> b_hold ) ; goto found ; } } if ( new_bp ) { rb_link_node ( & new_bp -> b_rbnode , parent , rbp ) ; rb_insert_color ( & new_bp -> b_rbnode , & pag -> pag_buf_tree ) ; new_bp -> b_pag = pag ; spin_unlock ( & pag -> pag_buf_lock ) ; } else { XFS_STATS_INC ( xb_miss_locked ) ; spin_unlock ( & pag -> pag_buf_lock ) ; xfs_perag_put ( pag ) ; } return new_bp ; found : spin_unlock ( & pag -> pag_buf_lock ) ; xfs_perag_put ( pag ) ; if ( ! xfs_buf_trylock ( bp ) ) { if ( flags & XBF_TRYLOCK ) { xfs_buf_rele ( bp ) ; XFS_STATS_INC ( xb_busy_locked ) ; return NULL ; } xfs_buf_lock ( bp ) ; XFS_STATS_INC ( xb_get_locked_waited ) ; } if ( bp -> b_flags & XBF_STALE ) { ASSERT ( ( bp -> b_flags & _XBF_DELWRI_Q ) == 0 ) ; ASSERT ( bp -> b_iodone == NULL ) ; bp -> b_flags &= _XBF_KMEM | _XBF_PAGES ; bp -> b_ops = NULL ; } trace_xfs_buf_find ( bp , flags , _RET_IP_ ) ; XFS_STATS_INC ( xb_get_locked ) ; return bp ; }
BUILTIN ( NumberFormatPrototypeFormatToParts ) { const char * const method = "Intl.NumberFormat.prototype.formatToParts" ; HandleScope handle_scope ( isolate ) ; CHECK_RECEIVER ( JSObject , number_format_holder , method ) ; if ( ! Intl :: IsObjectOfType ( isolate , number_format_holder , Intl :: Type :: kNumberFormat ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( MessageTemplate :: kIncompatibleMethodReceiver , isolate -> factory ( ) -> NewStringFromAsciiChecked ( method ) , number_format_holder ) ) ; } Handle < Object > x ; if ( args . length ( ) >= 2 ) { ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , x , Object :: ToNumber ( isolate , args . at ( 1 ) ) ) ; } else { x = isolate -> factory ( ) -> nan_value ( ) ; } icu :: DecimalFormat * number_format = NumberFormat :: UnpackNumberFormat ( number_format_holder ) ; CHECK_NOT_NULL ( number_format ) ; RETURN_RESULT_OR_FAILURE ( isolate , FormatNumberToParts ( isolate , number_format , x -> Number ( ) ) ) ; }
AccessInfoFactory :: AccessInfoFactory ( JSHeapBroker * js_heap_broker , CompilationDependencies * dependencies , Handle < Context > native_context , Zone * zone ) : js_heap_broker_ ( js_heap_broker ) , dependencies_ ( dependencies ) , native_context_ ( native_context ) , isolate_ ( native_context -> GetIsolate ( ) ) , type_cache_ ( TypeCache :: Get ( ) ) , zone_ ( zone ) { DCHECK ( native_context -> IsNativeContext ( ) ) ; }
png_write_filtered_row ( png_structrp png_ptr , png_bytep filtered_row , png_size_t full_row_length ) { png_debug ( 1 , "in png_write_filtered_row" ) ; png_debug1 ( 2 , "filter = %d" , filtered_row [ 0 ] ) ; png_compress_IDAT ( png_ptr , filtered_row , full_row_length , Z_NO_FLUSH ) ; if ( png_ptr -> prev_row != NULL ) { png_bytep tptr ; tptr = png_ptr -> prev_row ; png_ptr -> prev_row = png_ptr -> row_buf ; png_ptr -> row_buf = tptr ; } png_write_finish_row ( png_ptr ) ; #ifdef PNG_WRITE_FLUSH_SUPPORTED png_ptr -> flush_rows ++ ; if ( png_ptr -> flush_dist > 0 && png_ptr -> flush_rows >= png_ptr -> flush_dist ) { png_write_flush ( png_ptr ) ; } #endif }
void NodeProperties :: ReplaceValueInputs ( Node * node , Node * value ) { int value_input_count = node -> op ( ) -> ValueInputCount ( ) ; DCHECK_LE ( 1 , value_input_count ) ; node -> ReplaceInput ( 0 , value ) ; while ( -- value_input_count > 0 ) { node -> RemoveInput ( value_input_count ) ; } }
static void reassemble_and_dispatch ( UNUSED_ATTR BT_HDR * packet ) { if ( ( packet -> event & MSG_EVT_MASK ) == MSG_HC_TO_STACK_HCI_ACL ) { uint8_t * stream = packet -> data ; uint16_t handle ; uint16_t acl_length ; STREAM_TO_UINT16 ( handle , stream ) ; STREAM_TO_UINT16 ( acl_length , stream ) ; CHECK ( acl_length == packet -> len - HCI_ACL_PREAMBLE_SIZE ) ; uint8_t boundary_flag = GET_BOUNDARY_FLAG ( handle ) ; handle = handle & HANDLE_MASK ; if ( boundary_flag == START_PACKET_BOUNDARY ) { if ( acl_length < 2 ) { LOG_WARN ( LOG_TAG , "%s invalid acl_length %d" , __func__ , acl_length ) ; buffer_allocator -> free ( packet ) ; return ; } uint16_t l2cap_length ; STREAM_TO_UINT16 ( l2cap_length , stream ) ; auto map_iter = partial_packets . find ( handle ) ; if ( map_iter != partial_packets . end ( ) ) { LOG_WARN ( LOG_TAG , "%s found unfinished packet for handle with start packet. " "Dropping old." , __func__ ) ; BT_HDR * hdl = map_iter -> second ; partial_packets . erase ( map_iter ) ; buffer_allocator -> free ( hdl ) ; } if ( acl_length < L2CAP_HEADER_PDU_LEN_SIZE ) { LOG_WARN ( LOG_TAG , "%s L2CAP packet too small (%d < %d). Dropping it." , __func__ , packet -> len , L2CAP_HEADER_PDU_LEN_SIZE ) ; buffer_allocator -> free ( packet ) ; return ; } uint16_t full_length = l2cap_length + L2CAP_HEADER_SIZE + HCI_ACL_PREAMBLE_SIZE ; if ( check_uint16_overflow ( l2cap_length , ( L2CAP_HEADER_SIZE + HCI_ACL_PREAMBLE_SIZE ) ) || ( ( full_length + sizeof ( BT_HDR ) ) > BT_DEFAULT_BUFFER_SIZE ) ) { LOG_ERROR ( LOG_TAG , "%s Dropping L2CAP packet with invalid length (%d)." , __func__ , l2cap_length ) ; buffer_allocator -> free ( packet ) ; return ; } if ( full_length <= packet -> len ) { if ( full_length < packet -> len ) LOG_WARN ( LOG_TAG , "%s found l2cap full length %d less than the hci length %d." , __func__ , l2cap_length , packet -> len ) ; callbacks -> reassembled ( packet ) ; return ; } BT_HDR * partial_packet = ( BT_HDR * ) buffer_allocator -> alloc ( full_length + sizeof ( BT_HDR ) ) ; partial_packet -> event = packet -> event ; partial_packet -> len = full_length ; partial_packet -> offset = packet -> len ; memcpy ( partial_packet -> data , packet -> data , packet -> len ) ; stream = partial_packet -> data ; STREAM_SKIP_UINT16 ( stream ) ; UINT16_TO_STREAM ( stream , full_length - HCI_ACL_PREAMBLE_SIZE ) ; partial_packets [ handle ] = partial_packet ; buffer_allocator -> free ( packet ) ; } else { auto map_iter = partial_packets . find ( handle ) ; if ( map_iter == partial_packets . end ( ) ) { LOG_WARN ( LOG_TAG , "%s got continuation for unknown packet. Dropping it." , __func__ ) ; buffer_allocator -> free ( packet ) ; return ; } BT_HDR * partial_packet = map_iter -> second ; packet -> offset = HCI_ACL_PREAMBLE_SIZE ; uint16_t projected_offset = partial_packet -> offset + ( packet -> len - HCI_ACL_PREAMBLE_SIZE ) ; if ( projected_offset > partial_packet -> len ) { LOG_WARN ( LOG_TAG , "%s got packet which would exceed expected length of %d. " "Truncating." , __func__ , partial_packet -> len ) ; packet -> len = partial_packet -> len - partial_packet -> offset ; projected_offset = partial_packet -> len ; } memcpy ( partial_packet -> data + partial_packet -> offset , packet -> data + packet -> offset , packet -> len - packet -> offset ) ; buffer_allocator -> free ( packet ) ; partial_packet -> offset = projected_offset ; if ( partial_packet -> offset == partial_packet -> len ) { partial_packets . erase ( handle ) ; partial_packet -> offset = 0 ; callbacks -> reassembled ( partial_packet ) ; } } } else { callbacks -> reassembled ( packet ) ; } }
MediaEngineGonkVideoSource :: Shutdown ( ) { LOG ( ( __FUNCTION__ ) ) ; if ( ! mInitDone ) { return ; } ReentrantMonitorAutoEnter sync ( mCallbackMonitor ) ; if ( mState == kStarted ) { while ( ! mSources . IsEmpty ( ) ) { Stop ( mSources [ 0 ] , kVideoTrack ) ; } MOZ_ASSERT ( mState == kStopped ) ; } if ( mState == kAllocated || mState == kStopped ) { Deallocate ( ) ; } mState = kReleased ; mInitDone = false ; }
status_t SampleTable :: setSyncSampleParams ( off64_t data_offset , size_t data_size ) { if ( mSyncSampleOffset >= 0 || data_size < 8 ) { return ERROR_MALFORMED ; } mSyncSampleOffset = data_offset ; uint8_t header [ 8 ] ; if ( mDataSource -> readAt ( data_offset , header , sizeof ( header ) ) < ( ssize_t ) sizeof ( header ) ) { return ERROR_IO ; } if ( U32_AT ( header ) != 0 ) { return ERROR_MALFORMED ; } mNumSyncSamples = U32_AT ( & header [ 4 ] ) ; if ( mNumSyncSamples < 2 ) { ALOGV ( "Table of sync samples is empty or has only a single entry!" ) ; } mSyncSamples = new uint32_t [ mNumSyncSamples ] ; size_t size = mNumSyncSamples * sizeof ( uint32_t ) ; if ( mDataSource -> readAt ( mSyncSampleOffset + 8 , mSyncSamples , size ) != ( ssize_t ) size ) { return ERROR_IO ; } for ( size_t i = 0 ; i < mNumSyncSamples ; ++ i ) { mSyncSamples [ i ] = ntohl ( mSyncSamples [ i ] ) - 1 ; } return OK ; }
TF_BUILTIN ( TypedArrayPrototypeLength , TypedArrayBuiltinsAssembler ) { Node * context = Parameter ( Descriptor :: kContext ) ; Node * receiver = Parameter ( Descriptor :: kReceiver ) ; GenerateTypedArrayPrototypeGetter ( context , receiver , "get TypedArray.prototype.length" , JSTypedArray :: kLengthOffset ) ; }
void gdx2d_clear ( const gdx2d_pixmap * pixmap , uint32_t col ) { col = to_format ( pixmap -> format , col ) ; switch ( pixmap -> format ) { case GDX2D_FORMAT_ALPHA : clear_alpha ( pixmap , col ) ; break ; case GDX2D_FORMAT_LUMINANCE_ALPHA : clear_luminance_alpha ( pixmap , col ) ; break ; case GDX2D_FORMAT_RGB888 : clear_RGB888 ( pixmap , col ) ; break ; case GDX2D_FORMAT_RGBA8888 : clear_RGBA8888 ( pixmap , col ) ; break ; case GDX2D_FORMAT_RGB565 : clear_RGB565 ( pixmap , col ) ; break ; case GDX2D_FORMAT_RGBA4444 : clear_RGBA4444 ( pixmap , col ) ; break ; default : break ; } }
CycleCollectedJSRuntime :: CycleCollectedJSRuntime ( JSContext * aCx ) : mGCThingCycleCollectorGlobal ( sGCThingCycleCollectorGlobal ) , mJSZoneCycleCollectorGlobal ( sJSZoneCycleCollectorGlobal ) , mJSRuntime ( JS_GetRuntime ( aCx ) ) , mHasPendingIdleGCTask ( false ) , mPrevGCSliceCallback ( nullptr ) , mPrevGCNurseryCollectionCallback ( nullptr ) , mJSHolderMap ( 256 ) , mOutOfMemoryState ( OOMState :: OK ) , mLargeAllocationFailureState ( OOMState :: OK ) #ifdef DEBUG , mShutdownCalled ( false ) #endif { MOZ_COUNT_CTOR ( CycleCollectedJSRuntime ) ; MOZ_ASSERT ( aCx ) ; MOZ_ASSERT ( mJSRuntime ) ; if ( ! JS_AddExtraGCRootsTracer ( aCx , TraceBlackJS , this ) ) { MOZ_CRASH ( "JS_AddExtraGCRootsTracer failed" ) ; } JS_SetGrayGCRootsTracer ( aCx , TraceGrayJS , this ) ; JS_SetGCCallback ( aCx , GCCallback , this ) ; mPrevGCSliceCallback = JS :: SetGCSliceCallback ( aCx , GCSliceCallback ) ; if ( NS_IsMainThread ( ) ) { mPrevGCNurseryCollectionCallback = JS :: SetGCNurseryCollectionCallback ( aCx , GCNurseryCollectionCallback ) ; } JS_SetObjectsTenuredCallback ( aCx , JSObjectsTenuredCb , this ) ; JS :: SetOutOfMemoryCallback ( aCx , OutOfMemoryCallback , this ) ; JS_SetExternalStringSizeofCallback ( aCx , SizeofExternalStringCallback ) ; JS :: SetWarningReporter ( aCx , MozCrashWarningReporter ) ; js :: AutoEnterOOMUnsafeRegion :: setAnnotateOOMAllocationSizeCallback ( CrashReporter :: AnnotateOOMAllocationSize ) ; static js :: DOMCallbacks DOMcallbacks = { InstanceClassHasProtoAtDepth } ; SetDOMCallbacks ( aCx , & DOMcallbacks ) ; js :: SetScriptEnvironmentPreparer ( aCx , & mEnvironmentPreparer ) ; JS :: dbg :: SetDebuggerMallocSizeOf ( aCx , moz_malloc_size_of ) ; #ifdef MOZ_JS_DEV_ERROR_INTERCEPTOR JS_SetErrorInterceptorCallback ( mJSRuntime , & mErrorInterceptor ) ; #endif  // MOZ_JS_DEV_ERROR_INTERCEPTOR }
make_transform_image ( png_store * PNG_CONST ps , png_byte PNG_CONST colour_type , png_byte PNG_CONST bit_depth , unsigned int palette_number , int interlace_type , png_const_charp name ) { context ( ps , fault ) ; check_interlace_type ( interlace_type ) ; Try { png_infop pi ; png_structp pp = set_store_for_write ( ps , & pi , name ) ; png_uint_32 h ; if ( pp == NULL ) Throw ps ; h = transform_height ( pp , colour_type , bit_depth ) ; png_set_IHDR ( pp , pi , transform_width ( pp , colour_type , bit_depth ) , h , bit_depth , colour_type , interlace_type , PNG_COMPRESSION_TYPE_BASE , PNG_FILTER_TYPE_BASE ) ; #ifdef PNG_TEXT_SUPPORTED #  if defined(PNG_READ_zTXt_SUPPORTED) && defined(PNG_WRITE_zTXt_SUPPORTED) #     define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_zTXt #  else #     define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_NONE #  endif { static char key [ ] = "image name" ; size_t pos ; png_text text ; char copy [ FILE_NAME_SIZE ] ; text . compression = TEXT_COMPRESSION ; text . key = key ; pos = safecat ( copy , sizeof copy , 0 , ps -> wname ) ; text . text = copy ; text . text_length = pos ; text . itxt_length = 0 ; text . lang = 0 ; text . lang_key = 0 ; png_set_text ( pp , pi , & text , 1 ) ; } #endif if ( colour_type == 3 ) init_standard_palette ( ps , pp , pi , 1U < < bit_depth , 1 ) ; png_write_info ( pp , pi ) ; if ( png_get_rowbytes ( pp , pi ) != transform_rowsize ( pp , colour_type , bit_depth ) ) png_error ( pp , "row size incorrect" ) ; else { int npasses = png_set_interlace_handling ( pp ) ; int pass ; if ( npasses != npasses_from_interlace_type ( pp , interlace_type ) ) png_error ( pp , "write: png_set_interlace_handling failed" ) ; for ( pass = 0 ; pass < npasses ; ++ pass ) { png_uint_32 y ; for ( y = 0 ; y < h ; ++ y ) { png_byte buffer [ TRANSFORM_ROWMAX ] ; transform_row ( pp , buffer , colour_type , bit_depth , y ) ; png_write_row ( pp , buffer ) ; } } } #ifdef PNG_TEXT_SUPPORTED { static char key [ ] = "end marker" ; static char comment [ ] = "end" ; png_text text ; text . compression = TEXT_COMPRESSION ; text . key = key ; text . text = comment ; text . text_length = ( sizeof comment ) - 1 ; text . itxt_length = 0 ; text . lang = 0 ; text . lang_key = 0 ; png_set_text ( pp , pi , & text , 1 ) ; } #endif png_write_end ( pp , pi ) ; store_storefile ( ps , FILEID ( colour_type , bit_depth , palette_number , interlace_type , 0 , 0 , 0 ) ) ; store_write_reset ( ps ) ; } Catch ( fault ) { store_write_reset ( fault ) ; } }
static noinline struct btrfs_device * device_list_add ( const char * path , struct btrfs_super_block * disk_super , bool * new_device_added ) { struct btrfs_device * device ; struct btrfs_fs_devices * fs_devices = NULL ; struct rcu_string * name ; u64 found_transid = btrfs_super_generation ( disk_super ) ; u64 devid = btrfs_stack_device_id ( & disk_super -> dev_item ) ; bool has_metadata_uuid = ( btrfs_super_incompat_flags ( disk_super ) & BTRFS_FEATURE_INCOMPAT_METADATA_UUID ) ; bool fsid_change_in_progress = ( btrfs_super_flags ( disk_super ) & BTRFS_SUPER_FLAG_CHANGING_FSID_V2 ) ; if ( fsid_change_in_progress ) { if ( ! has_metadata_uuid ) { fs_devices = find_fsid_inprogress ( disk_super ) ; if ( ! fs_devices ) fs_devices = find_fsid ( disk_super -> fsid , NULL ) ; } else { fs_devices = find_fsid_changed ( disk_super ) ; } } else if ( has_metadata_uuid ) { fs_devices = find_fsid ( disk_super -> fsid , disk_super -> metadata_uuid ) ; } else { fs_devices = find_fsid ( disk_super -> fsid , NULL ) ; } if ( ! fs_devices ) { if ( has_metadata_uuid ) fs_devices = alloc_fs_devices ( disk_super -> fsid , disk_super -> metadata_uuid ) ; else fs_devices = alloc_fs_devices ( disk_super -> fsid , NULL ) ; if ( IS_ERR ( fs_devices ) ) return ERR_CAST ( fs_devices ) ; fs_devices -> fsid_change = fsid_change_in_progress ; mutex_lock ( & fs_devices -> device_list_mutex ) ; list_add ( & fs_devices -> fs_list , & fs_uuids ) ; device = NULL ; } else { mutex_lock ( & fs_devices -> device_list_mutex ) ; device = find_device ( fs_devices , devid , disk_super -> dev_item . uuid ) ; if ( has_metadata_uuid && fs_devices -> fsid_change && found_transid > fs_devices -> latest_generation ) { memcpy ( fs_devices -> fsid , disk_super -> fsid , BTRFS_FSID_SIZE ) ; memcpy ( fs_devices -> metadata_uuid , disk_super -> metadata_uuid , BTRFS_FSID_SIZE ) ; fs_devices -> fsid_change = false ; } } if ( ! device ) { if ( fs_devices -> opened ) { mutex_unlock ( & fs_devices -> device_list_mutex ) ; return ERR_PTR ( - EBUSY ) ; } device = btrfs_alloc_device ( NULL , & devid , disk_super -> dev_item . uuid ) ; if ( IS_ERR ( device ) ) { mutex_unlock ( & fs_devices -> device_list_mutex ) ; return device ; } name = rcu_string_strdup ( path , GFP_NOFS ) ; if ( ! name ) { btrfs_free_device ( device ) ; mutex_unlock ( & fs_devices -> device_list_mutex ) ; return ERR_PTR ( - ENOMEM ) ; } rcu_assign_pointer ( device -> name , name ) ; list_add_rcu ( & device -> dev_list , & fs_devices -> devices ) ; fs_devices -> num_devices ++ ; device -> fs_devices = fs_devices ; * new_device_added = true ; if ( disk_super -> label [ 0 ] ) pr_info ( "BTRFS: device label %s devid %llu transid %llu %s\n" , disk_super -> label , devid , found_transid , path ) ; else pr_info ( "BTRFS: device fsid %pU devid %llu transid %llu %s\n" , disk_super -> fsid , devid , found_transid , path ) ; } else if ( ! device -> name || strcmp ( device -> name -> str , path ) ) { if ( ! fs_devices -> opened && found_transid < device -> generation ) { mutex_unlock ( & fs_devices -> device_list_mutex ) ; return ERR_PTR ( - EEXIST ) ; } if ( device -> bdev ) { struct block_device * path_bdev ; path_bdev = lookup_bdev ( path ) ; if ( IS_ERR ( path_bdev ) ) { mutex_unlock ( & fs_devices -> device_list_mutex ) ; return ERR_CAST ( path_bdev ) ; } if ( device -> bdev != path_bdev ) { bdput ( path_bdev ) ; mutex_unlock ( & fs_devices -> device_list_mutex ) ; btrfs_warn_in_rcu ( device -> fs_info , "duplicate device fsid:devid for %pU:%llu old:%s new:%s" , disk_super -> fsid , devid , rcu_str_deref ( device -> name ) , path ) ; return ERR_PTR ( - EEXIST ) ; } bdput ( path_bdev ) ; btrfs_info_in_rcu ( device -> fs_info , "device fsid %pU devid %llu moved old:%s new:%s" , disk_super -> fsid , devid , rcu_str_deref ( device -> name ) , path ) ; } name = rcu_string_strdup ( path , GFP_NOFS ) ; if ( ! name ) { mutex_unlock ( & fs_devices -> device_list_mutex ) ; return ERR_PTR ( - ENOMEM ) ; } rcu_string_free ( device -> name ) ; rcu_assign_pointer ( device -> name , name ) ; if ( test_bit ( BTRFS_DEV_STATE_MISSING , & device -> dev_state ) ) { fs_devices -> missing_devices -- ; clear_bit ( BTRFS_DEV_STATE_MISSING , & device -> dev_state ) ; } } if ( ! fs_devices -> opened ) { device -> generation = found_transid ; fs_devices -> latest_generation = max_t ( u64 , found_transid , fs_devices -> latest_generation ) ; } fs_devices -> total_devices = btrfs_super_num_devices ( disk_super ) ; mutex_unlock ( & fs_devices -> device_list_mutex ) ; return device ; }
status_t BnMediaExtractor :: onTransact ( uint32_t code , const Parcel & data , Parcel * reply , uint32_t flags ) { switch ( code ) { case COUNTTRACKS : { ALOGV ( "countTracks" ) ; CHECK_INTERFACE ( IMediaExtractor , data , reply ) ; size_t numTracks = countTracks ( ) ; if ( numTracks > INT32_MAX ) { numTracks = 0 ; } reply -> writeUint32 ( uint32_t ( numTracks ) ) ; return NO_ERROR ; } case GETTRACK : { ALOGV ( "getTrack()" ) ; CHECK_INTERFACE ( IMediaExtractor , data , reply ) ; uint32_t idx ; if ( data . readUint32 ( & idx ) == NO_ERROR ) { const sp < IMediaSource > track = getTrack ( size_t ( idx ) ) ; registerMediaSource ( this , track ) ; return reply -> writeStrongBinder ( IInterface :: asBinder ( track ) ) ; } return UNKNOWN_ERROR ; } case GETTRACKMETADATA : { ALOGV ( "getTrackMetaData" ) ; CHECK_INTERFACE ( IMediaExtractor , data , reply ) ; uint32_t idx ; uint32_t flags ; if ( data . readUint32 ( & idx ) == NO_ERROR && data . readUint32 ( & flags ) == NO_ERROR ) { sp < MetaData > meta = getTrackMetaData ( idx , flags ) ; meta -> writeToParcel ( * reply ) ; return NO_ERROR ; } return UNKNOWN_ERROR ; } case GETMETADATA : { ALOGV ( "getMetaData" ) ; CHECK_INTERFACE ( IMediaExtractor , data , reply ) ; sp < MetaData > meta = getMetaData ( ) ; if ( meta != NULL ) { meta -> writeToParcel ( * reply ) ; return NO_ERROR ; } return UNKNOWN_ERROR ; } default : return BBinder :: onTransact ( code , data , reply , flags ) ; } }
void CNB :: DoIPHdrCSO ( PVOID IpHeader , ULONG EthPayloadLength ) const { ParaNdis_CheckSumVerifyFlat ( IpHeader , EthPayloadLength , pcrIpChecksum | pcrFixIPChecksum , __FUNCTION__ ) ; }
Address Zone :: NewExpand ( size_t size ) { DCHECK_EQ ( size , RoundDown ( size , kAlignmentInBytes ) ) ; DCHECK ( limit_ - position_ < size ) ; Segment * head = segment_head_ ; const size_t old_size = ( head == nullptr ) ? 0 : head -> size ( ) ; static const size_t kSegmentOverhead = sizeof ( Segment ) + kAlignmentInBytes ; const size_t new_size_no_overhead = size + ( old_size < < 1 ) ; size_t new_size = kSegmentOverhead + new_size_no_overhead ; const size_t min_new_size = kSegmentOverhead + size ; if ( new_size_no_overhead < size || new_size < kSegmentOverhead ) { V8 :: FatalProcessOutOfMemory ( nullptr , "Zone" ) ; return kNullAddress ; } if ( segment_size_ == SegmentSize :: kLarge ) { new_size = kMaximumSegmentSize ; } if ( new_size < kMinimumSegmentSize ) { new_size = kMinimumSegmentSize ; } else if ( new_size > kMaximumSegmentSize ) { new_size = Max ( min_new_size , kMaximumSegmentSize ) ; } if ( new_size > INT_MAX ) { V8 :: FatalProcessOutOfMemory ( nullptr , "Zone" ) ; return kNullAddress ; } Segment * segment = NewSegment ( new_size ) ; if ( segment == nullptr ) { V8 :: FatalProcessOutOfMemory ( nullptr , "Zone" ) ; return kNullAddress ; } Address result = RoundUp ( segment -> start ( ) , kAlignmentInBytes ) ; position_ = result + size ; DCHECK ( position_ >= result ) ; limit_ = segment -> end ( ) ; DCHECK ( position_ <= limit_ ) ; return result ; }
% % o image : The image . % % o exception : return any errors or warnings in this structure . % * / static MagickBooleanType WriteRGFImage ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { MagickBooleanType status ; int bit ; register const PixelPacket * p ; register ssize_t x ; ssize_t y ; unsigned char byte ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; status = OpenBlob ( image_info , image , WriteBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( status ) ; ( void ) TransformImageColorspace ( image , sRGBColorspace ) ; if ( ( image -> columns > 255L ) || ( image -> rows > 255L ) ) ThrowWriterException ( ImageError , "Dimensions must be less than 255x255" ) ; ( void ) WriteBlobByte ( image , image -> columns & 0xff ) ; ( void ) WriteBlobByte ( image , image -> rows & 0xff ) ; ( void ) SetImageType ( image , BilevelType ) ; x = 0 ; y = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = GetVirtualPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte >>= 1 ; if ( GetPixelLuma ( image , p ) < ( QuantumRange / 2.0 ) ) byte |= 0x80 ; bit ++ ; if ( bit == 8 ) { ( void ) WriteBlobByte ( image , byte ) ; bit = 0 ; byte = 0 ; } p ++ ; } if ( bit != 0 ) ( void ) WriteBlobByte ( image , byte ) ; status = SetImageProgress ( image , SaveImageTag , ( MagickOffsetType ) y , image -> rows ) ;
void CoreUserInputHandler :: putPrivmsg ( const QByteArray & target , const QByteArray & message , Cipher * cipher ) { static const char * cmd = "PRIVMSG" ; static const char * splitter = " .,-!?" ; int maxSplitPos = message . count ( ) ; int splitPos = maxSplitPos ; forever { QByteArray crypted = message . left ( splitPos ) ; bool isEncrypted = false ; #ifdef HAVE_QCA2 if ( cipher && ! cipher -> key ( ) . isEmpty ( ) && ! message . isEmpty ( ) ) { isEncrypted = cipher -> encrypt ( crypted ) ; } #endif int overrun = lastParamOverrun ( cmd , QList < QByteArray > ( ) < < target < < crypted ) ; if ( overrun ) { if ( ! isEncrypted ) maxSplitPos = message . count ( ) - overrun ; splitPos = - 1 ; for ( const char * splitChar = splitter ; * splitChar != 0 ; splitChar ++ ) { splitPos = qMax ( splitPos , message . lastIndexOf ( * splitChar , maxSplitPos ) + 1 ) ; } if ( splitPos <= 0 || splitPos > maxSplitPos ) splitPos = maxSplitPos ; maxSplitPos = splitPos - 1 ; if ( maxSplitPos <= 0 ) { qWarning ( ) < < tr ( "[Error] Could not encrypt your message: %1" ) . arg ( message . data ( ) ) ; return ; } continue ; } putCmd ( cmd , QList < QByteArray > ( ) < < target < < crypted ) ; if ( splitPos < message . count ( ) ) putPrivmsg ( target , message . mid ( splitPos ) , cipher ) ; return ; } }
static void endTimer ( void ) { if ( enableTimer ) { struct rusage sEnd ; sqlite3_int64 iEnd = timeOfDay ( ) ; getrusage ( RUSAGE_SELF , & sEnd ) ; printf ( "Run Time: real %.3f user %f sys %f\n" , ( iEnd - iBegin ) * 0.001 , timeDiff ( & sBegin . ru_utime , & sEnd . ru_utime ) , timeDiff ( & sBegin . ru_stime , & sEnd . ru_stime ) ) ; } }
void RedundantStoreFinder :: VisitEffectfulNode ( Node * node ) { if ( HasBeenVisited ( node ) ) { TRACE ( "- Revisiting: #%d:%s" , node -> id ( ) , node -> op ( ) -> mnemonic ( ) ) ; } UnobservablesSet after_set = RecomputeUseIntersection ( node ) ; UnobservablesSet before_set = RecomputeSet ( node , after_set ) ; DCHECK ( ! before_set . IsUnvisited ( ) ) ; UnobservablesSet stored_for_node = unobservable_for_id ( node -> id ( ) ) ; bool cur_set_changed = ( stored_for_node . IsUnvisited ( ) || stored_for_node != before_set ) ; if ( ! cur_set_changed ) { TRACE ( "+ No change: stabilized. Not visiting effect inputs." ) ; } else { unobservable_for_id ( node -> id ( ) ) = before_set ; for ( int i = 0 ; i < node -> op ( ) -> EffectInputCount ( ) ; i ++ ) { Node * input = NodeProperties :: GetEffectInput ( node , i ) ; TRACE ( "    marking #%d:%s for revisit" , input -> id ( ) , input -> op ( ) -> mnemonic ( ) ) ; MarkForRevisit ( input ) ; } } }
Node * InterpreterAssembler :: BytecodeOperandSignedShort ( int operand_index , LoadSensitivity needs_poisoning ) { DCHECK_LT ( operand_index , Bytecodes :: NumberOfOperands ( bytecode_ ) ) ; DCHECK_EQ ( OperandSize :: kShort , Bytecodes :: GetOperandSize ( bytecode_ , operand_index , operand_scale ( ) ) ) ; int operand_offset = Bytecodes :: GetOperandOffset ( bytecode_ , operand_index , operand_scale ( ) ) ; if ( TargetSupportsUnalignedAccess ( ) ) { return Load ( MachineType :: Int16 ( ) , BytecodeArrayTaggedPointer ( ) , IntPtrAdd ( BytecodeOffset ( ) , IntPtrConstant ( operand_offset ) ) , needs_poisoning ) ; } else { return BytecodeOperandReadUnaligned ( operand_offset , MachineType :: Int16 ( ) , needs_poisoning ) ; } }
static void GenerateTailCallToReturnedCode ( MacroAssembler * masm , Runtime :: FunctionId function_id ) { { FrameScope scope ( masm , StackFrame :: INTERNAL ) ; __ SmiTag ( rax , rax ) ; __ Push ( rax ) ; __ Push ( rdi ) ; __ Push ( rdx ) ; __ Push ( rdi ) ; __ CallRuntime ( function_id , 1 ) ; __ movp ( rcx , rax ) ; __ Pop ( rdx ) ; __ Pop ( rdi ) ; __ Pop ( rax ) ; __ SmiUntag ( rax , rax ) ; } static_assert ( kJavaScriptCallCodeStartRegister == rcx , "ABI mismatch" ) ; __ leap ( rcx , FieldOperand ( rcx , Code :: kHeaderSize ) ) ; __ jmp ( rcx ) ; }
status_t MediaHTTP :: connect ( const char * uri , const KeyedVector < String8 , String8 > * headers , off64_t ) { if ( mInitCheck != OK ) { return mInitCheck ; } KeyedVector < String8 , String8 > extHeaders ; if ( headers != NULL ) { extHeaders = * headers ; } if ( extHeaders . indexOfKey ( String8 ( "User-Agent" ) ) < 0 ) { extHeaders . add ( String8 ( "User-Agent" ) , String8 ( MakeUserAgent ( ) . c_str ( ) ) ) ; } bool success = mHTTPConnection -> connect ( uri , & extHeaders ) ; mLastHeaders = extHeaders ; mLastURI = uri ; mCachedSizeValid = false ; if ( success ) { AString sanitized = uriDebugString ( uri ) ; mName = String8 :: format ( "MediaHTTP(%s)" , sanitized . c_str ( ) ) ; } return success ? OK : UNKNOWN_ERROR ; }
static pyc_object * get_array_object_generic ( RBuffer * buffer , ut32 size ) { pyc_object * tmp = NULL ; pyc_object * ret = NULL ; ut32 i = 0 ; ret = R_NEW0 ( pyc_object ) ; if ( ! ret ) { return NULL ; } ret -> data = r_list_newf ( ( RListFree ) free_object ) ; if ( ! ret -> data ) { free ( ret ) ; return NULL ; } for ( i = 0 ; i < size ; i ++ ) { tmp = get_object ( buffer ) ; if ( ! tmp ) { r_list_free ( ret -> data ) ; R_FREE ( ret ) ; return NULL ; } if ( ! r_list_append ( ret -> data , tmp ) ) { free_object ( tmp ) ; r_list_free ( ret -> data ) ; free ( ret ) ; return NULL ; } } return ret ; }
bool JSNativeContextSpecialization :: InferReceiverMaps ( Node * receiver , Node * effect , MapHandles * receiver_maps ) { ZoneHandleSet < Map > maps ; NodeProperties :: InferReceiverMapsResult result = NodeProperties :: InferReceiverMaps ( isolate ( ) , receiver , effect , & maps ) ; if ( result == NodeProperties :: kReliableReceiverMaps ) { for ( size_t i = 0 ; i < maps . size ( ) ; ++ i ) { receiver_maps -> push_back ( maps [ i ] ) ; } return true ; } else if ( result == NodeProperties :: kUnreliableReceiverMaps ) { for ( size_t i = 0 ; i < maps . size ( ) ; ++ i ) { if ( ! maps [ i ] -> is_stable ( ) ) return false ; } for ( size_t i = 0 ; i < maps . size ( ) ; ++ i ) { receiver_maps -> push_back ( maps [ i ] ) ; } return true ; } return false ; }
Response V8ProfilerAgentImpl :: takeTypeProfile ( std :: unique_ptr < protocol :: Array < protocol :: Profiler :: ScriptTypeProfile > > * out_result ) { if ( ! m_state -> booleanProperty ( ProfilerAgentState :: typeProfileStarted , false ) ) { return Response :: Error ( "Type profile has not been started." ) ; } v8 :: HandleScope handle_scope ( m_isolate ) ; v8 :: debug :: TypeProfile type_profile = v8 :: debug :: TypeProfile :: Collect ( m_isolate ) ; * out_result = typeProfileToProtocol ( m_session -> inspector ( ) , type_profile ) ; return Response :: OK ( ) ; }
static struct mnt_namespace * alloc_mnt_ns ( struct user_namespace * user_ns ) { struct mnt_namespace * new_ns ; struct ucounts * ucounts ; int ret ; ucounts = inc_mnt_namespaces ( user_ns ) ; if ( ! ucounts ) return ERR_PTR ( - ENOSPC ) ; new_ns = kmalloc ( sizeof ( struct mnt_namespace ) , GFP_KERNEL ) ; if ( ! new_ns ) { dec_mnt_namespaces ( ucounts ) ; return ERR_PTR ( - ENOMEM ) ; } ret = ns_alloc_inum ( & new_ns -> ns ) ; if ( ret ) { kfree ( new_ns ) ; dec_mnt_namespaces ( ucounts ) ; return ERR_PTR ( ret ) ; } new_ns -> ns . ops = & mntns_operations ; new_ns -> seq = atomic64_add_return ( 1 , & mnt_ns_seq ) ; atomic_set ( & new_ns -> count , 1 ) ; new_ns -> root = NULL ; INIT_LIST_HEAD ( & new_ns -> list ) ; init_waitqueue_head ( & new_ns -> poll ) ; new_ns -> event = 0 ; new_ns -> user_ns = get_user_ns ( user_ns ) ; new_ns -> ucounts = ucounts ; return new_ns ; }
ctcompare ( const char * a , const char * b ) { int result = 0 ; while ( * a && * b ) { result |= * a ^ * b ; a ++ ; b ++ ; } return ( result ) ; }
XPCCallContext :: ~ XPCCallContext ( ) { if ( mXPCContext ) { mXPCContext -> SetCallingLangType ( mPrevCallerLanguage ) ; #ifdef DEBUG XPCCallContext * old = mThreadData -> SetCallContext ( mPrevCallContext ) ; NS_ASSERTION ( old == this , "bad pop from per thread data" ) ; #else ( void ) mThreadData -> SetCallContext ( mPrevCallContext ) ; #endif } if ( mContextPopRequired ) { XPCJSContextStack * stack = mThreadData -> GetJSContextStack ( ) ; NS_ASSERTION ( stack , "bad!" ) ; if ( stack ) { #ifdef DEBUG JSContext * poppedCX ; nsresult rv = stack -> Pop ( & poppedCX ) ; NS_ASSERTION ( NS_SUCCEEDED ( rv ) && poppedCX == mJSContext , "bad pop" ) ; #else ( void ) stack -> Pop ( nsnull ) ; #endif } } if ( mJSContext ) { if ( mCallerLanguage == NATIVE_CALLER ) JS_EndRequest ( mJSContext ) ; if ( mDestroyJSContextInDestructor ) { #ifdef DEBUG_xpc_hacker printf ( "!xpc - doing deferred destruction of JSContext @ %0x\n" , mJSContext ) ; #endif NS_ASSERTION ( ! mThreadData -> GetJSContextStack ( ) || ! mThreadData -> GetJSContextStack ( ) -> DEBUG_StackHasJSContext ( mJSContext ) , "JSContext still in threadjscontextstack!" ) ; JS_DestroyContext ( mJSContext ) ; } else { if ( ! JS_IsRunning ( mJSContext ) ) JS_ClearNewbornRoots ( mJSContext ) ; } } #ifdef DEBUG { StringWrapperEntry * se = reinterpret_cast < StringWrapperEntry * > ( & mStringWrapperData ) ; PRUint32 i ; for ( i = 0 ; i < XPCCCX_STRING_CACHE_SIZE ; ++ i ) { NS_ASSERTION ( ! se [ i ] . mInUse , "Uh, string wrapper still in use!" ) ; } } #endif NS_IF_RELEASE ( mXPC ) ; }
static void copyMono16 ( short * dst , const int * const * src , unsigned nSamples , unsigned ) { for ( unsigned i = 0 ; i < nSamples ; ++ i ) { * dst ++ = src [ 0 ] [ i ] ; } }
nsHTMLEditor :: PreDestroy ( bool aDestroyingFrames ) { if ( mDidPreDestroy ) { return NS_OK ; } nsCOMPtr < nsINode > document = do_QueryReferent ( mDocWeak ) ; if ( document ) { document -> RemoveMutationObserver ( this ) ; } while ( mStyleSheetURLs . Length ( ) ) { RemoveOverrideStyleSheet ( mStyleSheetURLs [ 0 ] ) ; } return nsPlaintextEditor :: PreDestroy ( aDestroyingFrames ) ; }
UDPSocketChild :: Bind ( nsIUDPSocketInternal * aSocket , nsIPrincipal * aPrincipal , const nsACString & aHost , uint16_t aPort , bool aAddressReuse , bool aLoopback , uint32_t recvBufferSize , uint32_t sendBufferSize , nsIEventTarget * aMainThreadEventTarget ) { UDPSOCKET_LOG ( ( "%s: %s:%u" , __FUNCTION__ , PromiseFlatCString ( aHost ) . get ( ) , aPort ) ) ; NS_ENSURE_ARG ( aSocket ) ; mSocket = aSocket ; AddIPDLReference ( ) ; if ( mBackgroundManager ) { MOZ_ASSERT ( ! aPrincipal ) ; mBackgroundManager -> SendPUDPSocketConstructor ( this , Nothing ( ) , mFilterName ) ; } else { if ( aMainThreadEventTarget ) { gNeckoChild -> SetEventTargetForActor ( this , aMainThreadEventTarget ) ; } gNeckoChild -> SendPUDPSocketConstructor ( this , IPC :: Principal ( aPrincipal ) , mFilterName ) ; } SendBind ( UDPAddressInfo ( nsCString ( aHost ) , aPort ) , aAddressReuse , aLoopback , recvBufferSize , sendBufferSize ) ; return NS_OK ; }
MaybeHandle < String > StringReplaceOneCharWithString ( Isolate * isolate , Handle < String > subject , Handle < String > search , Handle < String > replace , bool * found , int recursion_limit ) { StackLimitCheck stackLimitCheck ( isolate ) ; if ( stackLimitCheck . HasOverflowed ( ) || ( recursion_limit == 0 ) ) { return MaybeHandle < String > ( ) ; } recursion_limit -- ; if ( subject -> IsConsString ( ) ) { ConsString * cons = ConsString :: cast ( * subject ) ; Handle < String > first = handle ( cons -> first ( ) , isolate ) ; Handle < String > second = handle ( cons -> second ( ) , isolate ) ; Handle < String > new_first ; if ( ! StringReplaceOneCharWithString ( isolate , first , search , replace , found , recursion_limit ) . ToHandle ( & new_first ) ) { return MaybeHandle < String > ( ) ; } if ( * found ) return isolate -> factory ( ) -> NewConsString ( new_first , second ) ; Handle < String > new_second ; if ( ! StringReplaceOneCharWithString ( isolate , second , search , replace , found , recursion_limit ) . ToHandle ( & new_second ) ) { return MaybeHandle < String > ( ) ; } if ( * found ) return isolate -> factory ( ) -> NewConsString ( first , new_second ) ; return subject ; } else { int index = String :: IndexOf ( isolate , subject , search , 0 ) ; if ( index == - 1 ) return subject ; * found = true ; Handle < String > first = isolate -> factory ( ) -> NewSubString ( subject , 0 , index ) ; Handle < String > cons1 ; ASSIGN_RETURN_ON_EXCEPTION ( isolate , cons1 , isolate -> factory ( ) -> NewConsString ( first , replace ) , String ) ; Handle < String > second = isolate -> factory ( ) -> NewSubString ( subject , index + 1 , subject -> length ( ) ) ; return isolate -> factory ( ) -> NewConsString ( cons1 , second ) ; } }
nsHTMLEditRules :: AfterEditInner ( nsEditor :: OperationID action , nsIEditor :: EDirection aDirection ) { ConfirmSelectionInBody ( ) ; if ( action == nsEditor :: kOpIgnore ) return NS_OK ; nsCOMPtr < nsISelection > selection ; nsresult res = mHTMLEditor -> GetSelection ( getter_AddRefs ( selection ) ) ; NS_ENSURE_SUCCESS ( res , res ) ; nsCOMPtr < nsIDOMNode > rangeStartParent , rangeEndParent ; PRInt32 rangeStartOffset = 0 , rangeEndOffset = 0 ; bool bDamagedRange = false ; if ( mDocChangeRange ) { mDocChangeRange -> GetStartContainer ( getter_AddRefs ( rangeStartParent ) ) ; mDocChangeRange -> GetEndContainer ( getter_AddRefs ( rangeEndParent ) ) ; mDocChangeRange -> GetStartOffset ( & rangeStartOffset ) ; mDocChangeRange -> GetEndOffset ( & rangeEndOffset ) ; if ( rangeStartParent && rangeEndParent ) bDamagedRange = true ; } if ( bDamagedRange && ! ( ( action == nsEditor :: kOpUndo ) || ( action == nsEditor :: kOpRedo ) ) ) { nsAutoTxnsConserveSelection dontSpazMySelection ( mHTMLEditor ) ; res = PromoteRange ( mDocChangeRange , action ) ; NS_ENSURE_SUCCESS ( res , res ) ; if ( ( action == nsEditor :: kOpDeleteSelection ) && mDidRangedDelete ) { res = InsertBRIfNeeded ( selection ) ; NS_ENSURE_SUCCESS ( res , res ) ; } res = AdjustSpecialBreaks ( ) ; NS_ENSURE_SUCCESS ( res , res ) ; if ( ( action != nsEditor :: kOpInsertText && action != nsEditor :: kOpInsertIMEText ) ) { res = mHTMLEditor -> CollapseAdjacentTextNodes ( mDocChangeRange ) ; NS_ENSURE_SUCCESS ( res , res ) ; } res = RemoveEmptyNodes ( ) ; NS_ENSURE_SUCCESS ( res , res ) ; if ( ( action == nsEditor :: kOpInsertText ) || ( action == nsEditor :: kOpInsertIMEText ) || ( action == nsEditor :: kOpDeleteSelection ) || ( action == nsEditor :: kOpInsertBreak ) || ( action == nsHTMLEditor :: kOpHTMLPaste || ( action == nsHTMLEditor :: kOpLoadHTML ) ) ) { res = AdjustWhitespace ( selection ) ; NS_ENSURE_SUCCESS ( res , res ) ; nsWSRunObject ( mHTMLEditor , mRangeItem . startNode , mRangeItem . startOffset ) . AdjustWhitespace ( ) ; if ( ( mRangeItem . startNode != mRangeItem . endNode ) || ( mRangeItem . startOffset != mRangeItem . endOffset ) ) { nsWSRunObject ( mHTMLEditor , mRangeItem . endNode , mRangeItem . endOffset ) . AdjustWhitespace ( ) ; } } if ( mNewBlock ) { res = PinSelectionToNewBlock ( selection ) ; mNewBlock = 0 ; } if ( ( action == nsEditor :: kOpInsertText ) || ( action == nsEditor :: kOpInsertIMEText ) || ( action == nsEditor :: kOpDeleteSelection ) || ( action == nsEditor :: kOpInsertBreak ) || ( action == nsHTMLEditor :: kOpHTMLPaste || ( action == nsHTMLEditor :: kOpLoadHTML ) ) ) { res = AdjustSelection ( selection , aDirection ) ; NS_ENSURE_SUCCESS ( res , res ) ; } if ( action == nsEditor :: kOpInsertText || action == nsEditor :: kOpInsertIMEText || action == nsEditor :: kOpDeleteSelection || IsStyleCachePreservingAction ( action ) ) { mHTMLEditor -> mTypeInState -> UpdateSelState ( selection ) ; res = ReapplyCachedStyles ( ) ; NS_ENSURE_SUCCESS ( res , res ) ; res = ClearCachedStyles ( ) ; NS_ENSURE_SUCCESS ( res , res ) ; } } res = mHTMLEditor -> HandleInlineSpellCheck ( action , selection , mRangeItem . startNode , mRangeItem . startOffset , rangeStartParent , rangeStartOffset , rangeEndParent , rangeEndOffset ) ; NS_ENSURE_SUCCESS ( res , res ) ; res = CreateBogusNodeIfNeeded ( selection ) ; NS_ENSURE_SUCCESS ( res , res ) ; if ( ! mDidExplicitlySetInterline ) { res = CheckInterlinePosition ( selection ) ; } return res ; }
TfLiteRegistration AddOpRegistration ( ) { TfLiteRegistration reg = { nullptr , nullptr , nullptr , nullptr } ; reg . custom_name = "my_add" ; reg . builtin_code = tflite :: BuiltinOperator_CUSTOM ; reg . prepare = [ ] ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteTensor * input1 = GetInput ( context , node , 0 ) ; const TfLiteTensor * input2 = GetInput ( context , node , 1 ) ; TfLiteTensor * output = GetOutput ( context , node , 0 ) ; TF_LITE_ENSURE_EQ ( context , input1 -> dims -> size , input2 -> dims -> size ) ; for ( int i = 0 ; i < input1 -> dims -> size ; ++ i ) { TF_LITE_ENSURE_EQ ( context , input1 -> dims -> data [ i ] , input2 -> dims -> data [ i ] ) ; } TF_LITE_ENSURE_STATUS ( context -> ResizeTensor ( context , output , TfLiteIntArrayCopy ( input1 -> dims ) ) ) ; return kTfLiteOk ; } ; reg . invoke = [ ] ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteTensor * a0 = GetInput ( context , node , 0 ) ; TF_LITE_ENSURE ( context , a0 ) ; TF_LITE_ENSURE ( context , a0 -> data . f ) ; const TfLiteTensor * a1 = GetInput ( context , node , 1 ) ; TF_LITE_ENSURE ( context , a1 ) ; TF_LITE_ENSURE ( context , a1 -> data . f ) ; TfLiteTensor * out = GetOutput ( context , node , 0 ) ; TF_LITE_ENSURE ( context , out ) ; TF_LITE_ENSURE ( context , out -> data . f ) ; int num = a0 -> dims -> data [ 0 ] ; for ( int i = 0 ; i < num ; i ++ ) { out -> data . f [ i ] = a0 -> data . f [ i ] + a1 -> data . f [ i ] ; } return kTfLiteOk ; } ; return reg ; }
static void sdp_copy_raw_data ( tCONN_CB * p_ccb , bool offset ) { unsigned int cpy_len , rem_len ; uint32_t list_len ; uint8_t * p ; uint8_t type ; #if (SDP_DEBUG_RAW == TRUE) uint8_t num_array [ SDP_MAX_LIST_BYTE_COUNT ] ; uint32_t i ; for ( i = 0 ; i < p_ccb -> list_len ; i ++ ) { snprintf ( ( char * ) & num_array [ i * 2 ] , sizeof ( num_array ) - i * 2 , "%02X" , ( uint8_t ) ( p_ccb -> rsp_list [ i ] ) ) ; } SDP_TRACE_WARNING ( "result :%s" , num_array ) ; #endif if ( p_ccb -> p_db -> raw_data ) { cpy_len = p_ccb -> p_db -> raw_size - p_ccb -> p_db -> raw_used ; list_len = p_ccb -> list_len ; p = & p_ccb -> rsp_list [ 0 ] ; if ( offset ) { cpy_len -= 1 ; type = * p ++ ; uint8_t * old_p = p ; p = sdpu_get_len_from_type ( p , type , & list_len ) ; if ( ( int ) cpy_len < ( p - old_p ) ) { SDP_TRACE_WARNING ( "%s: no bytes left for data" , __func__ ) ; return ; } cpy_len -= ( p - old_p ) ; } if ( list_len < cpy_len ) { cpy_len = list_len ; } rem_len = SDP_MAX_LIST_BYTE_COUNT - ( unsigned int ) ( p - & p_ccb -> rsp_list [ 0 ] ) ; if ( cpy_len > rem_len ) { SDP_TRACE_WARNING ( "rem_len :%d less than cpy_len:%d" , rem_len , cpy_len ) ; cpy_len = rem_len ; } SDP_TRACE_WARNING ( "%s: list_len:%d cpy_len:%d p:%p p_ccb:%p p_db:%p raw_size:%d " "raw_used:%d raw_data:%p" , __func__ , list_len , cpy_len , p , p_ccb , p_ccb -> p_db , p_ccb -> p_db -> raw_size , p_ccb -> p_db -> raw_used , p_ccb -> p_db -> raw_data ) ; memcpy ( & p_ccb -> p_db -> raw_data [ p_ccb -> p_db -> raw_used ] , p , cpy_len ) ; p_ccb -> p_db -> raw_used += cpy_len ; } }
skip_string ( char_u * p ) { int i ; for ( ; ; ++ p ) { if ( p [ 0 ] == '\'' ) { if ( p [ 1 ] == NUL ) break ; i = 2 ; if ( p [ 1 ] == '\\' && p [ 2 ] != NUL ) { ++ i ; while ( vim_isdigit ( p [ i - 1 ] ) ) ++ i ; } if ( p [ i ] == '\'' ) { p += i ; continue ; } } else if ( p [ 0 ] == '"' ) { for ( ++ p ; p [ 0 ] ; ++ p ) { if ( p [ 0 ] == '\\' && p [ 1 ] != NUL ) ++ p ; else if ( p [ 0 ] == '"' ) break ; } if ( p [ 0 ] == '"' ) continue ; } else if ( p [ 0 ] == 'R' && p [ 1 ] == '"' ) { char_u * delim = p + 2 ; char_u * paren = vim_strchr ( delim , '(' ) ; if ( paren != NULL ) { size_t delim_len = paren - delim ; for ( p += 3 ; * p ; ++ p ) if ( p [ 0 ] == ')' && STRNCMP ( p + 1 , delim , delim_len ) == 0 && p [ delim_len + 1 ] == '"' ) { p += delim_len + 1 ; break ; } if ( p [ 0 ] == '"' ) continue ; } } break ; } if ( ! * p ) -- p ; return p ; }
tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ; tok -> level = 0 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; #ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; #endif return tok ; }
void AddNamedProperty ( Isolate * isolate , Handle < Name > name , ClassBoilerplate :: ValueKind value_kind , int value_index ) { Smi * value = Smi :: FromInt ( value_index ) ; if ( HasDictionaryProperties ( ) ) { UpdateNextEnumerationIndex ( value_index ) ; AddToDictionaryTemplate ( isolate , properties_dictionary_template_ , name , value_index , value_kind , value ) ; } else { * temp_handle_ . location ( ) = value ; AddToDescriptorArrayTemplate ( isolate , descriptor_array_template_ , name , value_kind , temp_handle_ ) ; } }
Node * InterpreterAssembler :: DispatchToBytecode ( Node * target_bytecode , Node * new_bytecode_offset ) { if ( FLAG_trace_ignition_dispatches ) { TraceBytecodeDispatch ( target_bytecode ) ; } Node * target_code_entry = Load ( MachineType :: Pointer ( ) , DispatchTableRawPointer ( ) , TimesPointerSize ( target_bytecode ) ) ; return DispatchToBytecodeHandlerEntry ( target_code_entry , new_bytecode_offset , target_bytecode ) ; }
void IncrementalMarking :: UpdateMarkingWorklistAfterScavenge ( ) { if ( ! IsMarking ( ) ) return ; Map * filler_map = ReadOnlyRoots ( heap_ ) . one_pointer_filler_map ( ) ; #ifdef ENABLE_MINOR_MC MinorMarkCompactCollector :: MarkingState * minor_marking_state = heap ( ) -> minor_mark_compact_collector ( ) -> marking_state ( ) ; #else void * minor_marking_state = nullptr ; #endif // ENABLE_MINOR_MC marking_worklist ( ) -> Update ( [ this , filler_map , minor_marking_state ] ( HeapObject * obj , HeapObject * * out ) -> bool { DCHECK ( obj -> IsHeapObject ( ) ) ; if ( Heap :: InFromSpace ( obj ) ) { MapWord map_word = obj -> map_word ( ) ; if ( ! map_word . IsForwardingAddress ( ) ) { return false ; } HeapObject * dest = map_word . ToForwardingAddress ( ) ; DCHECK_IMPLIES ( marking_state ( ) -> IsWhite ( obj ) , obj -> IsFiller ( ) ) ; * out = dest ; return true ; } else if ( Heap :: InToSpace ( obj ) ) { DCHECK ( Page :: FromAddress ( obj -> address ( ) ) -> IsFlagSet ( Page :: SWEEP_TO_ITERATE ) ) ; #ifdef ENABLE_MINOR_MC if ( minor_marking_state -> IsGrey ( obj ) ) { * out = obj ; return true ; } #endif // ENABLE_MINOR_MC return false ; } else { if ( Page :: FromAddress ( obj -> address ( ) ) -> IsFlagSet ( Page :: SWEEP_TO_ITERATE ) ) { #ifdef ENABLE_MINOR_MC if ( minor_marking_state -> IsGrey ( obj ) ) { * out = obj ; return true ; } #endif // ENABLE_MINOR_MC return false ; } DCHECK_IMPLIES ( marking_state ( ) -> IsWhite ( obj ) , obj -> IsFiller ( ) ) ; if ( obj -> map ( ) != filler_map ) { * out = obj ; return true ; } return false ; } } ) ; UpdateWeakReferencesAfterScavenge ( ) ; }
mptctl_fw_download ( unsigned long arg ) { struct mpt_fw_xfer __user * ufwdl = ( void __user * ) arg ; struct mpt_fw_xfer kfwdl ; if ( copy_from_user ( & kfwdl , ufwdl , sizeof ( struct mpt_fw_xfer ) ) ) { printk ( KERN_ERR MYNAM "%s@%d::_ioctl_fwdl - " "Unable to copy mpt_fw_xfer struct @ %p\n" , __FILE__ , __LINE__ , ufwdl ) ; return - EFAULT ; } return mptctl_do_fw_download ( kfwdl . iocnum , kfwdl . bufp , kfwdl . fwlen ) ; }
IGNITION_HANDLER ( Star , InterpreterAssembler ) { Node * accumulator = GetAccumulator ( ) ; StoreRegisterAtOperandIndex ( accumulator , 0 ) ; Dispatch ( ) ; }
void AutoCleanPng :: infoCallback ( size_t idatLength ) { png_uint_32 origWidth , origHeight ; int bitDepth , encodedColorType ; png_get_IHDR ( fPng_ptr , fInfo_ptr , & origWidth , & origHeight , & bitDepth , & encodedColorType , nullptr , nullptr , nullptr ) ; if ( bitDepth == 16 && ( PNG_COLOR_TYPE_GRAY == encodedColorType || PNG_COLOR_TYPE_GRAY_ALPHA == encodedColorType ) ) { bitDepth = 8 ; png_set_strip_16 ( fPng_ptr ) ; } SkEncodedInfo :: Color color ; SkEncodedInfo :: Alpha alpha ; switch ( encodedColorType ) { case PNG_COLOR_TYPE_PALETTE : if ( bitDepth < 8 ) { bitDepth = 8 ; png_set_packing ( fPng_ptr ) ; } color = SkEncodedInfo :: kPalette_Color ; alpha = png_get_valid ( fPng_ptr , fInfo_ptr , PNG_INFO_tRNS ) ? SkEncodedInfo :: kUnpremul_Alpha : SkEncodedInfo :: kOpaque_Alpha ; break ; case PNG_COLOR_TYPE_RGB : if ( png_get_valid ( fPng_ptr , fInfo_ptr , PNG_INFO_tRNS ) ) { png_set_tRNS_to_alpha ( fPng_ptr ) ; color = SkEncodedInfo :: kRGBA_Color ; alpha = SkEncodedInfo :: kBinary_Alpha ; } else { color = SkEncodedInfo :: kRGB_Color ; alpha = SkEncodedInfo :: kOpaque_Alpha ; } break ; case PNG_COLOR_TYPE_GRAY : if ( bitDepth < 8 ) { bitDepth = 8 ; png_set_expand_gray_1_2_4_to_8 ( fPng_ptr ) ; } if ( png_get_valid ( fPng_ptr , fInfo_ptr , PNG_INFO_tRNS ) ) { png_set_tRNS_to_alpha ( fPng_ptr ) ; color = SkEncodedInfo :: kGrayAlpha_Color ; alpha = SkEncodedInfo :: kBinary_Alpha ; } else { color = SkEncodedInfo :: kGray_Color ; alpha = SkEncodedInfo :: kOpaque_Alpha ; } break ; case PNG_COLOR_TYPE_GRAY_ALPHA : color = SkEncodedInfo :: kGrayAlpha_Color ; alpha = SkEncodedInfo :: kUnpremul_Alpha ; break ; case PNG_COLOR_TYPE_RGBA : color = SkEncodedInfo :: kRGBA_Color ; alpha = SkEncodedInfo :: kUnpremul_Alpha ; break ; default : SkASSERT ( false ) ; color = SkEncodedInfo :: kRGBA_Color ; alpha = SkEncodedInfo :: kUnpremul_Alpha ; } const int numberPasses = png_set_interlace_handling ( fPng_ptr ) ; if ( fOutCodec ) { SkASSERT ( nullptr == * fOutCodec ) ; auto profile = read_color_profile ( fPng_ptr , fInfo_ptr ) ; if ( profile ) { switch ( profile -> profile ( ) -> data_color_space ) { case skcms_Signature_CMYK : profile = nullptr ; break ; case skcms_Signature_Gray : if ( SkEncodedInfo :: kGray_Color != color && SkEncodedInfo :: kGrayAlpha_Color != color ) { profile = nullptr ; } break ; default : break ; } } if ( encodedColorType == PNG_COLOR_TYPE_GRAY_ALPHA ) { png_color_8p sigBits ; if ( png_get_sBIT ( fPng_ptr , fInfo_ptr , & sigBits ) ) { if ( 8 == sigBits -> alpha && kGraySigBit_GrayAlphaIsJustAlpha == sigBits -> gray ) { color = SkEncodedInfo :: kXAlpha_Color ; } } } else if ( SkEncodedInfo :: kOpaque_Alpha == alpha ) { png_color_8p sigBits ; if ( png_get_sBIT ( fPng_ptr , fInfo_ptr , & sigBits ) ) { if ( 5 == sigBits -> red && 6 == sigBits -> green && 5 == sigBits -> blue ) { color = SkEncodedInfo :: k565_Color ; } } } SkEncodedInfo encodedInfo = SkEncodedInfo :: Make ( origWidth , origHeight , color , alpha , bitDepth , std :: move ( profile ) ) ; if ( 1 == numberPasses ) { * fOutCodec = new SkPngNormalDecoder ( std :: move ( encodedInfo ) , std :: unique_ptr < SkStream > ( fStream ) , fChunkReader , fPng_ptr , fInfo_ptr , bitDepth ) ; } else { * fOutCodec = new SkPngInterlacedDecoder ( std :: move ( encodedInfo ) , std :: unique_ptr < SkStream > ( fStream ) , fChunkReader , fPng_ptr , fInfo_ptr , bitDepth , numberPasses ) ; } static_cast < SkPngCodec * > ( * fOutCodec ) -> setIdatLength ( idatLength ) ; } this -> releasePngPtrs ( ) ; }
bool V8HeapExplorer :: IsEssentialObject ( Object * object ) { ReadOnlyRoots roots ( heap_ ) ; return object -> IsHeapObject ( ) && ! object -> IsOddball ( ) && object != roots . empty_byte_array ( ) && object != roots . empty_fixed_array ( ) && object != roots . empty_weak_fixed_array ( ) && object != roots . empty_descriptor_array ( ) && object != roots . fixed_array_map ( ) && object != roots . cell_map ( ) && object != roots . global_property_cell_map ( ) && object != roots . shared_function_info_map ( ) && object != roots . free_space_map ( ) && object != roots . one_pointer_filler_map ( ) && object != roots . two_pointer_filler_map ( ) ; }
nsDOMDataTransfer :: CacheExternalClipboardFormats ( ) { NS_ASSERTION ( mEventType == NS_PASTE , "caching clipboard data for invalid event" ) ; nsCOMPtr < nsIClipboard > clipboard = do_GetService ( "@mozilla.org/widget/clipboard;1" ) ; if ( ! clipboard ) { return ; } nsIScriptSecurityManager * ssm = nsContentUtils :: GetSecurityManager ( ) ; nsCOMPtr < nsIPrincipal > sysPrincipal ; ssm -> GetSystemPrincipal ( getter_AddRefs ( sysPrincipal ) ) ; const char * formats [ ] = { kFileMime , kHTMLMime , kURLMime , kURLDataMime , kUnicodeMime } ; for ( uint32_t f = 0 ; f < mozilla :: ArrayLength ( formats ) ; ++ f ) { bool supported ; clipboard -> HasDataMatchingFlavors ( & ( formats [ f ] ) , 1 , nsIClipboard :: kGlobalClipboard , & supported ) ; if ( supported ) { CacheExternalData ( formats [ f ] , 0 , sysPrincipal ) ; } } }
bool RedundantStoreFinder :: CannotObserveStoreField ( Node * node ) { return node -> opcode ( ) == IrOpcode :: kLoadElement || node -> opcode ( ) == IrOpcode :: kLoad || node -> opcode ( ) == IrOpcode :: kStore || node -> opcode ( ) == IrOpcode :: kEffectPhi || node -> opcode ( ) == IrOpcode :: kStoreElement || node -> opcode ( ) == IrOpcode :: kUnsafePointerAdd || node -> opcode ( ) == IrOpcode :: kRetain ; }
static void command_port_read_callback ( struct urb * urb ) { struct usb_serial_port * command_port = urb -> context ; struct whiteheat_command_private * command_info ; int status = urb -> status ; unsigned char * data = urb -> transfer_buffer ; int result ; command_info = usb_get_serial_port_data ( command_port ) ; if ( ! command_info ) { dev_dbg ( & urb -> dev -> dev , "%s - command_info is NULL, exiting.\n" , __func__ ) ; return ; } if ( status ) { dev_dbg ( & urb -> dev -> dev , "%s - nonzero urb status: %d\n" , __func__ , status ) ; if ( status != - ENOENT ) command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; return ; } usb_serial_debug_data ( & command_port -> dev , __func__ , urb -> actual_length , data ) ; if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE ) { command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) { command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_EVENT ) { dev_dbg ( & urb -> dev -> dev , "%s - event received\n" , __func__ ) ; } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 ) ; command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else dev_dbg ( & urb -> dev -> dev , "%s - bad reply from firmware\n" , __func__ ) ; result = usb_submit_urb ( command_port -> read_urb , GFP_ATOMIC ) ; if ( result ) dev_dbg ( & urb -> dev -> dev , "%s - failed resubmitting read urb, error %d\n" , __func__ , result ) ; }
absl :: Status IsSupported ( const TfLiteContext * context , const TfLiteNode * tflite_node , const TfLiteRegistration * registration ) final { RETURN_IF_ERROR ( CheckMaxSupportedOpVersion ( registration , 3 ) ) ; if ( tflite_node -> inputs -> size != 2 ) { return absl :: UnimplementedError ( "MUL requires two input tensors." ) ; } auto input0 = tflite :: GetInput ( context , tflite_node , 0 ) ; auto input1 = tflite :: GetInput ( context , tflite_node , 1 ) ; if ( input0 -> dims -> size == input1 -> dims -> size ) { bool first_has_smaller_dim = false ; bool second_has_smaller_dim = false ; for ( int i = 0 ; i < input0 -> dims -> size ; ++ i ) { if ( input0 -> dims -> data [ i ] < input1 -> dims -> data [ i ] ) { first_has_smaller_dim = true ; } if ( input1 -> dims -> data [ i ] < input0 -> dims -> data [ i ] ) { second_has_smaller_dim = true ; } } if ( first_has_smaller_dim && second_has_smaller_dim ) { return absl :: UnimplementedError ( "MUL requires one tensor that not less than second in all " "dimensions." ) ; } } const TfLiteMulParams * tf_options ; RETURN_IF_ERROR ( RetrieveBuiltinData ( tflite_node , & tf_options ) ) ; return IsActivationSupported ( tf_options -> activation ) ; }
bool jit :: Bailout ( BailoutStack * sp , BaselineBailoutInfo * * bailoutInfo ) { JSContext * cx = TlsContext . get ( ) ; MOZ_ASSERT ( bailoutInfo ) ; MOZ_ASSERT ( IsInRange ( FAKE_EXITFP_FOR_BAILOUT , 0 , 0x1000 ) && IsInRange ( FAKE_EXITFP_FOR_BAILOUT + sizeof ( CommonFrameLayout ) , 0 , 0x1000 ) , "Fake exitfp pointer should be within the first page." ) ; cx -> activation ( ) -> asJit ( ) -> setJSExitFP ( FAKE_EXITFP_FOR_BAILOUT ) ; JitActivationIterator jitActivations ( cx ) ; BailoutFrameInfo bailoutData ( jitActivations , sp ) ; JSJitFrameIter frame ( jitActivations -> asJit ( ) ) ; MOZ_ASSERT ( ! frame . ionScript ( ) -> invalidated ( ) ) ; JitFrameLayout * currentFramePtr = frame . jsFrame ( ) ; JitSpew ( JitSpew_IonBailouts , "Took bailout! Snapshot offset: %u" , frame . snapshotOffset ( ) ) ; MOZ_ASSERT ( IsBaselineJitEnabled ( cx ) ) ; * bailoutInfo = nullptr ; bool success = BailoutIonToBaseline ( cx , bailoutData . activation ( ) , frame , bailoutInfo , nullptr , BailoutReason :: Normal ) ; MOZ_ASSERT_IF ( success , * bailoutInfo != nullptr ) ; if ( ! success ) { MOZ_ASSERT ( cx -> isExceptionPending ( ) ) ; JSScript * script = frame . script ( ) ; probes :: ExitScript ( cx , script , script -> function ( ) , false ) ; } if ( frame . ionScript ( ) -> invalidated ( ) ) { frame . ionScript ( ) -> decrementInvalidationCount ( cx -> gcContext ( ) ) ; } if ( cx -> runtime ( ) -> jitRuntime ( ) -> isProfilerInstrumentationEnabled ( cx -> runtime ( ) ) ) { cx -> jitActivation -> setLastProfilingFrame ( currentFramePtr ) ; } return success ; }
size_t EmitSection ( SectionCode code , ZoneBuffer & buffer ) { buffer . write_u8 ( code ) ; return buffer . reserve_u32v ( ) ; }
int main ( int argc , char * * argv ) { FILE * infile = NULL ; VpxVideoWriter * writer = NULL ; vpx_codec_ctx_t codec ; vpx_codec_enc_cfg_t cfg ; vpx_image_t raw ; vpx_codec_err_t res ; vpx_fixed_buf_t stats = { 0 } ; VpxVideoInfo info = { 0 } ; const VpxInterface * encoder = NULL ; int pass ; const int fps = 30 ; const int bitrate = 200 ; const char * const codec_arg = argv [ 1 ] ; const char * const width_arg = argv [ 2 ] ; const char * const height_arg = argv [ 3 ] ; const char * const infile_arg = argv [ 4 ] ; const char * const outfile_arg = argv [ 5 ] ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( "Invalid number of arguments." ) ; encoder = get_vpx_encoder_by_name ( codec_arg ) ; if ( ! encoder ) die ( "Unsupported codec." ) ; info . codec_fourcc = encoder -> fourcc ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; info . frame_width = strtol ( width_arg , NULL , 0 ) ; info . frame_height = strtol ( height_arg , NULL , 0 ) ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( "Invalid frame size: %dx%d" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( "Failed to allocate image" , info . frame_width , info . frame_height ) ; } writer = vpx_video_writer_open ( outfile_arg , kContainerIVF , & info ) ; if ( ! writer ) die ( "Failed to open %s for writing" , outfile_arg ) ; printf ( "Using %s\n" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , "Failed to get default codec config." ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; for ( pass = 0 ; pass < 2 ; ++ pass ) { int frame_count = 0 ; if ( pass == 0 ) { cfg . g_pass = VPX_RC_FIRST_PASS ; } else { cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; } if ( ! ( infile = fopen ( infile_arg , "rb" ) ) ) die ( "Failed to open %s for reading" , infile_arg ) ; if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) die_codec ( & codec , "Failed to initialize encoder" ) ; while ( vpx_img_read ( & raw , infile ) ) { ++ frame_count ; if ( pass == 0 ) { get_frame_stats ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { encode_frame ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ; } } if ( pass == 0 ) { get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { printf ( "\n" ) ; } fclose ( infile ) ; printf ( "Pass %d complete. Processed %d frames.\n" , pass + 1 , frame_count ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , "Failed to destroy codec." ) ; } vpx_img_free ( & raw ) ; free ( stats . buf ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }
GPMF_ERR IsValidSize ( GPMF_stream * ms , uint32_t size ) { if ( ms ) { int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ; if ( size + 2 <= nestsize ) return GPMF_OK ; } return GPMF_ERROR_BAD_STRUCTURE ; }
static int pagemap_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , struct mm_walk * walk ) { struct vm_area_struct * vma ; struct pagemapread * pm = walk -> private ; pte_t * pte ; int err = 0 ; split_huge_page_pmd ( walk -> mm , pmd ) ; vma = find_vma ( walk -> mm , addr ) ; for ( ; addr != end ; addr += PAGE_SIZE ) { u64 pfn = PM_NOT_PRESENT ; if ( vma && ( addr >= vma -> vm_end ) ) vma = find_vma ( walk -> mm , addr ) ; if ( vma && ( vma -> vm_start <= addr ) && ! is_vm_hugetlb_page ( vma ) ) { pte = pte_offset_map ( pmd , addr ) ; pfn = pte_to_pagemap_entry ( * pte ) ; pte_unmap ( pte ) ; } err = add_to_pagemap ( addr , pfn , pm ) ; if ( err ) return err ; } cond_resched ( ) ; return err ; }
gss_unwrap_iov ( minor_status , context_handle , conf_state , qop_state , iov , iov_count ) OM_uint32 * minor_status ; gss_ctx_id_t context_handle ; int * conf_state ; gss_qop_t * qop_state ; gss_iov_buffer_desc * iov ; int iov_count ; { OM_uint32 status ; gss_union_ctx_id_t ctx ; gss_mechanism mech ; status = val_unwrap_iov_args ( minor_status , context_handle , conf_state , qop_state , iov , iov_count ) ; if ( status != GSS_S_COMPLETE ) return ( status ) ; ctx = ( gss_union_ctx_id_t ) context_handle ; mech = gssint_get_mechanism ( ctx -> mech_type ) ; if ( mech ) { if ( mech -> gss_unwrap_iov ) { status = mech -> gss_unwrap_iov ( minor_status , ctx -> internal_ctx_id , conf_state , qop_state , iov , iov_count ) ; if ( status != GSS_S_COMPLETE ) map_error ( minor_status , mech ) ; } else status = GSS_S_UNAVAILABLE ; return ( status ) ; } return ( GSS_S_BAD_MECH ) ; }
static int php_mb_parse_encoding_list ( const char * value , int value_length , mbfl_encoding * * * return_list , int * return_size , int persistent ) { int n , l , size , bauto , ret = 1 ; char * p , * p1 , * p2 , * endp , * tmpstr ; mbfl_encoding * encoding ; mbfl_no_encoding * src ; mbfl_encoding * * entry , * * list ; list = nullptr ; if ( value == nullptr || value_length <= 0 ) { if ( return_list ) { * return_list = nullptr ; } if ( return_size ) { * return_size = 0 ; } return 0 ; } else { mbfl_no_encoding * identify_list ; int identify_list_size ; identify_list = MBSTRG ( default_detect_order_list ) ; identify_list_size = MBSTRG ( default_detect_order_list_size ) ; if ( value [ 0 ] == '"' && value [ value_length - 1 ] == '"' && value_length > 2 ) { tmpstr = ( char * ) strndup ( value + 1 , value_length - 2 ) ; value_length -= 2 ; } else tmpstr = ( char * ) strndup ( value , value_length ) ; if ( tmpstr == nullptr ) { return 0 ; } endp = tmpstr + value_length ; n = 1 ; p1 = tmpstr ; while ( ( p2 = ( char * ) string_memnstr ( p1 , "," , 1 , endp ) ) != nullptr ) { p1 = p2 + 1 ; n ++ ; } size = n + identify_list_size ; list = ( mbfl_encoding * * ) calloc ( size , sizeof ( mbfl_encoding * ) ) ; if ( list != nullptr ) { entry = list ; n = 0 ; bauto = 0 ; p1 = tmpstr ; do { p2 = p = ( char * ) string_memnstr ( p1 , "," , 1 , endp ) ; if ( p == nullptr ) { p = endp ; } * p = '\0' ; while ( p1 < p && ( * p1 == ' ' || * p1 == '\t' ) ) { p1 ++ ; } p -- ; while ( p > p1 && ( * p == ' ' || * p == '\t' ) ) { * p = '\0' ; p -- ; } if ( strcasecmp ( p1 , "auto" ) == 0 ) { if ( ! bauto ) { bauto = 1 ; l = identify_list_size ; src = identify_list ; for ( int i = 0 ; i < l ; i ++ ) { * entry ++ = ( mbfl_encoding * ) mbfl_no2encoding ( * src ++ ) ; n ++ ; } } } else { encoding = ( mbfl_encoding * ) mbfl_name2encoding ( p1 ) ; if ( encoding != nullptr ) { * entry ++ = encoding ; n ++ ; } else { ret = 0 ; } } p1 = p2 + 1 ; } while ( n < size && p2 != nullptr ) ; if ( n > 0 ) { if ( return_list ) { * return_list = list ; } else { free ( list ) ; } } else { free ( list ) ; if ( return_list ) { * return_list = nullptr ; } ret = 0 ; } if ( return_size ) { * return_size = n ; } } else { if ( return_list ) { * return_list = nullptr ; } if ( return_size ) { * return_size = 0 ; } ret = 0 ; } free ( tmpstr ) ; } return ret ; }
static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs , * src_reg = NULL ; u8 opcode = BPF_OP ( insn -> code ) ; bool is_jmp32 ; int pred = - 1 ; int err ; if ( opcode == BPF_JA || opcode > BPF_JSLE ) { verbose ( env , "invalid BPF_JMP/JMP32 opcode %x\n" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , "BPF_JMP/JMP32 uses reserved fields\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , "R%d pointer comparison prohibited\n" , insn -> src_reg ) ; return - EACCES ; } src_reg = & regs [ insn -> src_reg ] ; } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , "BPF_JMP/JMP32 uses reserved fields\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; is_jmp32 = BPF_CLASS ( insn -> code ) == BPF_JMP32 ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { pred = is_branch_taken ( dst_reg , insn -> imm , opcode , is_jmp32 ) ; } else if ( src_reg -> type == SCALAR_VALUE && is_jmp32 && tnum_is_const ( tnum_subreg ( src_reg -> var_off ) ) ) { pred = is_branch_taken ( dst_reg , tnum_subreg ( src_reg -> var_off ) . value , opcode , is_jmp32 ) ; } else if ( src_reg -> type == SCALAR_VALUE && ! is_jmp32 && tnum_is_const ( src_reg -> var_off ) ) { pred = is_branch_taken ( dst_reg , src_reg -> var_off . value , opcode , is_jmp32 ) ; } else if ( reg_is_pkt_pointer_any ( dst_reg ) && reg_is_pkt_pointer_any ( src_reg ) && ! is_jmp32 ) { pred = is_pkt_ptr_branch_taken ( dst_reg , src_reg , opcode ) ; } if ( pred >= 0 ) { if ( ! __is_pointer_value ( false , dst_reg ) ) err = mark_chain_precision ( env , insn -> dst_reg ) ; if ( BPF_SRC ( insn -> code ) == BPF_X && ! err && ! __is_pointer_value ( false , src_reg ) ) err = mark_chain_precision ( env , insn -> src_reg ) ; if ( err ) return err ; } if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx , false ) ; if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { struct bpf_reg_state * src_reg = & regs [ insn -> src_reg ] ; if ( dst_reg -> type == SCALAR_VALUE && src_reg -> type == SCALAR_VALUE ) { if ( tnum_is_const ( src_reg -> var_off ) || ( is_jmp32 && tnum_is_const ( tnum_subreg ( src_reg -> var_off ) ) ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , src_reg -> var_off . value , tnum_subreg ( src_reg -> var_off ) . value , opcode , is_jmp32 ) ; else if ( tnum_is_const ( dst_reg -> var_off ) || ( is_jmp32 && tnum_is_const ( tnum_subreg ( dst_reg -> var_off ) ) ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , src_reg , dst_reg -> var_off . value , tnum_subreg ( dst_reg -> var_off ) . value , opcode , is_jmp32 ) ; else if ( ! is_jmp32 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , src_reg , dst_reg , opcode ) ; if ( src_reg -> id && ! WARN_ON_ONCE ( src_reg -> id != other_branch_regs [ insn -> src_reg ] . id ) ) { find_equal_scalars ( this_branch , src_reg ) ; find_equal_scalars ( other_branch , & other_branch_regs [ insn -> src_reg ] ) ; } } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , ( u32 ) insn -> imm , opcode , is_jmp32 ) ; } if ( dst_reg -> type == SCALAR_VALUE && dst_reg -> id && ! WARN_ON_ONCE ( dst_reg -> id != other_branch_regs [ insn -> dst_reg ] . id ) ) { find_equal_scalars ( this_branch , dst_reg ) ; find_equal_scalars ( other_branch , & other_branch_regs [ insn -> dst_reg ] ) ; } if ( ! is_jmp32 && BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , "R%d pointer comparison prohibited\n" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level & BPF_LOG_LEVEL ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }
int sctp_verify_asconf ( const struct sctp_association * asoc , struct sctp_paramhdr * param_hdr , void * chunk_end , struct sctp_paramhdr * * errp ) { sctp_addip_param_t * asconf_param ; union sctp_params param ; int length , plen ; param . v = ( sctp_paramhdr_t * ) param_hdr ; while ( param . v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) { length = ntohs ( param . p -> length ) ; * errp = param . p ; if ( param . v > chunk_end - length || length < sizeof ( sctp_paramhdr_t ) ) return 0 ; switch ( param . p -> type ) { case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : asconf_param = ( sctp_addip_param_t * ) param . v ; plen = ntohs ( asconf_param -> param_hdr . length ) ; if ( plen < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return 0 ; break ; default : break ; } param . v += WORD_ROUND ( length ) ; } if ( param . v != chunk_end ) return 0 ; return 1 ; }
mark_desktop_file_trusted ( CommonJob * common , GCancellable * cancellable , GFile * file , gboolean interactive ) { char * contents , * new_contents ; gsize length , new_length ; GError * error ; guint32 current_perms , new_perms ; int response ; GFileInfo * info ; retry : error = NULL ; if ( ! g_file_load_contents ( file , cancellable , & contents , & length , NULL , & error ) ) { if ( interactive ) { response = run_error ( common , g_strdup ( _ ( "Unable to mark launcher trusted (executable)" ) ) , error -> message , NULL , FALSE , CANCEL , RETRY , NULL ) ; } else { response = 0 ; } if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( common ) ; } else if ( response == 1 ) { goto retry ; } else { g_assert_not_reached ( ) ; } goto out ; } if ( ! g_str_has_prefix ( contents , "#!" ) ) { new_length = length + strlen ( TRUSTED_SHEBANG ) ; new_contents = g_malloc ( new_length ) ; strcpy ( new_contents , TRUSTED_SHEBANG ) ; memcpy ( new_contents + strlen ( TRUSTED_SHEBANG ) , contents , length ) ; if ( ! g_file_replace_contents ( file , new_contents , new_length , NULL , FALSE , 0 , NULL , cancellable , & error ) ) { g_free ( contents ) ; g_free ( new_contents ) ; if ( interactive ) { response = run_error ( common , g_strdup ( _ ( "Unable to mark launcher trusted (executable)" ) ) , error -> message , NULL , FALSE , CANCEL , RETRY , NULL ) ; } else { response = 0 ; } if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( common ) ; } else if ( response == 1 ) { goto retry ; } else { g_assert_not_reached ( ) ; } goto out ; } g_free ( new_contents ) ; } g_free ( contents ) ; info = g_file_query_info ( file , G_FILE_ATTRIBUTE_STANDARD_TYPE "," G_FILE_ATTRIBUTE_UNIX_MODE , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , common -> cancellable , & error ) ; if ( info == NULL ) { if ( interactive ) { response = run_error ( common , g_strdup ( _ ( "Unable to mark launcher trusted (executable)" ) ) , error -> message , NULL , FALSE , CANCEL , RETRY , NULL ) ; } else { response = 0 ; } if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( common ) ; } else if ( response == 1 ) { goto retry ; } else { g_assert_not_reached ( ) ; } goto out ; } if ( g_file_info_has_attribute ( info , G_FILE_ATTRIBUTE_UNIX_MODE ) ) { current_perms = g_file_info_get_attribute_uint32 ( info , G_FILE_ATTRIBUTE_UNIX_MODE ) ; new_perms = current_perms | S_IXGRP | S_IXUSR | S_IXOTH ; if ( ( current_perms != new_perms ) && ! g_file_set_attribute_uint32 ( file , G_FILE_ATTRIBUTE_UNIX_MODE , new_perms , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , common -> cancellable , & error ) ) { g_object_unref ( info ) ; if ( interactive ) { response = run_error ( common , g_strdup ( _ ( "Unable to mark launcher trusted (executable)" ) ) , error -> message , NULL , FALSE , CANCEL , RETRY , NULL ) ; } else { response = 0 ; } if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( common ) ; } else if ( response == 1 ) { goto retry ; } else { g_assert_not_reached ( ) ; } goto out ; } } g_object_unref ( info ) ; out : ; }
nsPluginByteRangeStreamListener :: OnStartRequest ( nsIRequest * request , nsISupports * ctxt ) { nsresult rv ; nsCOMPtr < nsIStreamListener > finalStreamListener = do_QueryReferent ( mWeakPtrPluginStreamListenerPeer ) ; if ( ! finalStreamListener ) return NS_ERROR_FAILURE ; nsPluginStreamListenerPeer * pslp = static_cast < nsPluginStreamListenerPeer * > ( finalStreamListener . get ( ) ) ; NS_ASSERTION ( pslp -> mRequests . IndexOfObject ( GetBaseRequest ( request ) ) != - 1 , "Untracked byte-range request?" ) ; nsCOMPtr < nsIStreamConverterService > serv = do_GetService ( NS_STREAMCONVERTERSERVICE_CONTRACTID , & rv ) ; if ( NS_SUCCEEDED ( rv ) ) { rv = serv -> AsyncConvertData ( MULTIPART_BYTERANGES , "*/*" , finalStreamListener , nullptr , getter_AddRefs ( mStreamConverter ) ) ; if ( NS_SUCCEEDED ( rv ) ) { rv = mStreamConverter -> OnStartRequest ( request , ctxt ) ; if ( NS_SUCCEEDED ( rv ) ) return rv ; } } mStreamConverter = 0 ; nsCOMPtr < nsIHttpChannel > httpChannel ( do_QueryInterface ( request ) ) ; if ( ! httpChannel ) { return NS_ERROR_FAILURE ; } uint32_t responseCode = 0 ; rv = httpChannel -> GetResponseStatus ( & responseCode ) ; if ( NS_FAILED ( rv ) ) { return NS_ERROR_FAILURE ; } if ( responseCode != 200 ) { bool bWantsAllNetworkStreams = false ; rv = pslp -> GetPluginInstance ( ) -> GetValueFromPlugin ( NPPVpluginWantsAllNetworkStreams , & bWantsAllNetworkStreams ) ; if ( NS_FAILED ( rv ) ) { bWantsAllNetworkStreams = false ; } if ( ! bWantsAllNetworkStreams ) { return NS_ERROR_FAILURE ; } } mStreamConverter = finalStreamListener ; mRemoveMagicNumber = true ; rv = pslp -> ServeStreamAsFile ( request , ctxt ) ; return rv ; }
bool SharedBufferManagerParent :: RecvAllocateGrallocBuffer ( const IntSize & aSize , const uint32_t & aFormat , const uint32_t & aUsage , mozilla :: layers :: MaybeMagicGrallocBufferHandle * aHandle ) { #ifdef MOZ_HAVE_SURFACEDESCRIPTORGRALLOC * aHandle = null_t ( ) ; if ( aFormat == 0 || aUsage == 0 ) { printf_stderr ( "SharedBufferManagerParent::RecvAllocateGrallocBuffer -- format and usage must be non-zero" ) ; return true ; } if ( aSize . width > 4096 || aSize . height > 4096 ) { printf_stderr ( "SharedBufferManagerParent::RecvAllocateGrallocBuffer -- requested gralloc buffer is too big." ) ; return false ; } sp < GraphicBuffer > outgoingBuffer = new GraphicBuffer ( aSize . width , aSize . height , aFormat , aUsage ) ; if ( ! outgoingBuffer . get ( ) || outgoingBuffer -> initCheck ( ) != NO_ERROR ) { printf_stderr ( "SharedBufferManagerParent::RecvAllocateGrallocBuffer -- gralloc buffer allocation failed" ) ; return true ; } int64_t bufferKey ; { MonitorAutoLock lock ( * sManagerMonitor . get ( ) ) ; bufferKey = ++ sBufferKey ; } GrallocBufferRef ref ; ref . mOwner = mOwner ; ref . mKey = bufferKey ; * aHandle = MagicGrallocBufferHandle ( outgoingBuffer , ref ) ; { MutexAutoLock lock ( mLock ) ; mBuffers [ bufferKey ] = outgoingBuffer ; } #endif return true ; }
sctp_userspace_get_mtu_from_ifn ( uint32_t if_index , int af ) { #if defined(INET) || defined(INET6) PIP_ADAPTER_ADDRESSES pAdapterAddrs , pAdapt ; DWORD AdapterAddrsSize , Err ; #endif int mtu ; switch ( af ) { #if defined(INET) case AF_INET : #endif #if defined(INET6) case AF_INET6 : #endif #if defined(INET) || defined(INET6) mtu = 0 ; AdapterAddrsSize = 0 ; pAdapterAddrs = NULL ; if ( ( Err = GetAdaptersAddresses ( AF_UNSPEC , 0 , NULL , NULL , & AdapterAddrsSize ) ) != 0 ) { if ( ( Err != ERROR_BUFFER_OVERFLOW ) && ( Err != ERROR_INSUFFICIENT_BUFFER ) ) { SCTPDBG ( SCTP_DEBUG_USR , "GetAdaptersAddresses() sizing failed with error code %d, AdapterAddrsSize = %d\n" , Err , AdapterAddrsSize ) ; mtu = - 1 ; goto cleanup ; } } if ( ( pAdapterAddrs = ( PIP_ADAPTER_ADDRESSES ) GlobalAlloc ( GPTR , AdapterAddrsSize ) ) == NULL ) { SCTPDBG ( SCTP_DEBUG_USR , "Memory allocation error!\n" ) ; mtu = - 1 ; goto cleanup ; } if ( ( Err = GetAdaptersAddresses ( AF_UNSPEC , 0 , NULL , pAdapterAddrs , & AdapterAddrsSize ) ) != ERROR_SUCCESS ) { SCTPDBG ( SCTP_DEBUG_USR , "GetAdaptersAddresses() failed with error code %d\n" , Err ) ; mtu = - 1 ; goto cleanup ; } for ( pAdapt = pAdapterAddrs ; pAdapt ; pAdapt = pAdapt -> Next ) { if ( pAdapt -> IfIndex == if_index ) { mtu = pAdapt -> Mtu ; break ; } } cleanup : if ( pAdapterAddrs != NULL ) { GlobalFree ( pAdapterAddrs ) ; } break ; #endif case AF_CONN : mtu = 1280 ; break ; default : mtu = 0 ; break ; } return ( mtu ) ; }
void fe_netjoin_deinit ( void ) { while ( joinservers != NULL ) netjoin_server_remove ( joinservers -> data ) ; if ( join_tag != - 1 ) { g_source_remove ( join_tag ) ; signal_remove ( "print starting" , ( SIGNAL_FUNC ) sig_print_starting ) ; } signal_remove ( "setup changed" , ( SIGNAL_FUNC ) read_settings ) ; signal_remove ( "message quit" , ( SIGNAL_FUNC ) msg_quit ) ; signal_remove ( "message join" , ( SIGNAL_FUNC ) msg_join ) ; signal_remove ( "message irc mode" , ( SIGNAL_FUNC ) msg_mode ) ; }
void MarkCompactCollector :: ClearNonLiveReferences ( ) { TRACE_GC ( heap ( ) -> tracer ( ) , GCTracer :: Scope :: MC_CLEAR ) ; { TRACE_GC ( heap ( ) -> tracer ( ) , GCTracer :: Scope :: MC_CLEAR_STRING_TABLE ) ; StringTable * string_table = heap ( ) -> string_table ( ) ; InternalizedStringTableCleaner internalized_visitor ( heap ( ) , string_table ) ; string_table -> IterateElements ( & internalized_visitor ) ; string_table -> ElementsRemoved ( internalized_visitor . PointersRemoved ( ) ) ; ExternalStringTableCleaner external_visitor ( heap ( ) ) ; heap ( ) -> external_string_table_ . IterateAll ( & external_visitor ) ; heap ( ) -> external_string_table_ . CleanUpAll ( ) ; } { TRACE_GC ( heap ( ) -> tracer ( ) , GCTracer :: Scope :: MC_CLEAR_WEAK_LISTS ) ; MarkCompactWeakObjectRetainer mark_compact_object_retainer ( non_atomic_marking_state ( ) ) ; heap ( ) -> ProcessAllWeakReferences ( & mark_compact_object_retainer ) ; } { TRACE_GC ( heap ( ) -> tracer ( ) , GCTracer :: Scope :: MC_CLEAR_MAPS ) ; ClearFullMapTransitions ( ) ; } ClearWeakReferences ( ) ; MarkDependentCodeForDeoptimization ( ) ; ClearWeakCollections ( ) ; DCHECK ( weak_objects_ . transition_arrays . IsEmpty ( ) ) ; DCHECK ( weak_objects_ . weak_references . IsEmpty ( ) ) ; DCHECK ( weak_objects_ . weak_objects_in_code . IsEmpty ( ) ) ; }
static FLAC__bool bitwriter_grow_ ( FLAC__BitWriter * bw , unsigned bits_to_add ) { unsigned new_capacity ; bwword * new_buffer ; FLAC__ASSERT ( 0 != bw ) ; FLAC__ASSERT ( 0 != bw -> buffer ) ; new_capacity = bw -> words + ( ( bw -> bits + bits_to_add + FLAC__BITS_PER_WORD - 1 ) / FLAC__BITS_PER_WORD ) ; if ( bw -> capacity >= new_capacity ) return true ; if ( ( new_capacity - bw -> capacity ) % FLAC__BITWRITER_DEFAULT_INCREMENT ) new_capacity += FLAC__BITWRITER_DEFAULT_INCREMENT - ( ( new_capacity - bw -> capacity ) % FLAC__BITWRITER_DEFAULT_INCREMENT ) ; FLAC__ASSERT ( 0 == ( new_capacity - bw -> capacity ) % FLAC__BITWRITER_DEFAULT_INCREMENT ) ; FLAC__ASSERT ( new_capacity > bw -> capacity ) ; FLAC__ASSERT ( new_capacity >= bw -> words + ( ( bw -> bits + bits_to_add + FLAC__BITS_PER_WORD - 1 ) / FLAC__BITS_PER_WORD ) ) ; new_buffer = ( bwword * ) safe_realloc_mul_2op_ ( bw -> buffer , sizeof ( bwword ) , new_capacity ) ; if ( new_buffer == 0 ) return false ; bw -> buffer = new_buffer ; bw -> capacity = new_capacity ; return true ; }
void * MyMtpDatabase :: getThumbnail ( MtpObjectHandle handle , size_t & outThumbSize ) { MtpString path ; int64_t length ; MtpObjectFormat format ; void * result = NULL ; outThumbSize = 0 ; if ( getObjectFilePath ( handle , path , length , format ) == MTP_RESPONSE_OK ) { switch ( format ) { case MTP_FORMAT_EXIF_JPEG : case MTP_FORMAT_HEIF : case MTP_FORMAT_JFIF : { ExifData * exifdata = exif_data_new_from_file ( path ) ; if ( exifdata ) { if ( exifdata -> data ) { result = malloc ( exifdata -> size ) ; if ( result ) { memcpy ( result , exifdata -> data , exifdata -> size ) ; outThumbSize = exifdata -> size ; } } exif_data_unref ( exifdata ) ; } break ; } case MTP_FORMAT_DNG : case MTP_FORMAT_TIFF : case MTP_FORMAT_TIFF_EP : case MTP_FORMAT_DEFINED : { std :: unique_ptr < FileStream > stream ( new FileStream ( path ) ) ; piex :: PreviewImageData image_data ; if ( ! GetExifFromRawImage ( stream . get ( ) , path , image_data ) ) { break ; } if ( image_data . thumbnail . length == 0 || image_data . thumbnail . format != :: piex :: Image :: kJpegCompressed ) { break ; } result = malloc ( image_data . thumbnail . length ) ; if ( result ) { piex :: Error err = stream . get ( ) -> GetData ( image_data . thumbnail . offset , image_data . thumbnail . length , ( std :: uint8_t * ) result ) ; if ( err == piex :: Error :: kOk ) { outThumbSize = image_data . thumbnail . length ; } else { free ( result ) ; } } break ; } } } return result ; }
long mkvparser :: UnserializeInt ( IMkvReader * pReader , long long pos , long size , long long & result ) { assert ( pReader ) ; assert ( pos >= 0 ) ; assert ( size > 0 ) ; assert ( size <= 8 ) ; { signed char b ; const long status = pReader -> Read ( pos , 1 , ( unsigned char * ) & b ) ; if ( status < 0 ) return status ; result = b ; ++ pos ; } for ( long i = 1 ; i < size ; ++ i ) { unsigned char b ; const long status = pReader -> Read ( pos , 1 , & b ) ; if ( status < 0 ) return status ; result <<= 8 ; result |= b ; ++ pos ; } return 0 ; }
Type OperationTyper :: Rangify ( Type type ) { if ( type . IsRange ( ) ) return type ; if ( ! type . Is ( cache_ . kInteger ) ) { return type ; } return Type :: Range ( type . Min ( ) , type . Max ( ) , zone ( ) ) ; }
RUNTIME_FUNCTION ( Runtime_DebugAsyncFunctionSuspended ) { DCHECK_EQ ( 1 , args . length ( ) ) ; HandleScope scope ( isolate ) ; CONVERT_ARG_HANDLE_CHECKED ( JSPromise , promise , 0 ) ; isolate -> OnAsyncFunctionStateChanged ( promise , debug :: kAsyncFunctionSuspended ) ; return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
static void bnep_data_ind ( uint16_t l2cap_cid , BT_HDR * p_buf ) { tBNEP_CONN * p_bcb ; uint8_t * p = ( uint8_t * ) ( p_buf + 1 ) + p_buf -> offset ; uint16_t rem_len = p_buf -> len ; uint8_t type , ctrl_type , ext_type = 0 ; bool extension_present , fw_ext_present ; uint16_t protocol = 0 ; uint8_t * p_src_addr , * p_dst_addr ; p_bcb = bnepu_find_bcb_by_cid ( l2cap_cid ) ; if ( p_bcb == NULL ) { BNEP_TRACE_WARNING ( "BNEP - Rcvd L2CAP data, unknown CID: 0x%x" , l2cap_cid ) ; osi_free ( p_buf ) ; return ; } type = * p ++ ; extension_present = type > > 7 ; type &= 0x7f ; if ( ( rem_len <= bnep_frame_hdr_sizes [ type ] ) || ( rem_len > BNEP_MTU_SIZE ) ) { BNEP_TRACE_EVENT ( "BNEP - rcvd frame, bad len: %d  type: 0x%02x" , p_buf -> len , type ) ; osi_free ( p_buf ) ; return ; } rem_len -- ; if ( ( p_bcb -> con_state != BNEP_STATE_CONNECTED ) && ( ! ( p_bcb -> con_flags & BNEP_FLAGS_CONN_COMPLETED ) ) && ( type != BNEP_FRAME_CONTROL ) ) { BNEP_TRACE_WARNING ( "BNEP - Ignored L2CAP data while in state: %d, CID: 0x%x" , p_bcb -> con_state , l2cap_cid ) ; if ( extension_present ) { uint8_t ext , length ; uint16_t org_len , new_len ; org_len = rem_len ; new_len = 0 ; do { ext = * p ++ ; length = * p ++ ; p += length ; if ( ( ! ( ext & 0x7F ) ) && ( * p > BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG ) ) bnep_send_command_not_understood ( p_bcb , * p ) ; new_len += ( length + 2 ) ; if ( new_len > org_len ) break ; } while ( ext & 0x80 ) ; } osi_free ( p_buf ) ; return ; } if ( type > BNEP_FRAME_COMPRESSED_ETHERNET_DEST_ONLY ) { BNEP_TRACE_EVENT ( "BNEP - rcvd frame, unknown type: 0x%02x" , type ) ; osi_free ( p_buf ) ; return ; } BNEP_TRACE_DEBUG ( "BNEP - rcv frame, type: %d len: %d Ext: %d" , type , p_buf -> len , extension_present ) ; p_src_addr = p_dst_addr = NULL ; switch ( type ) { case BNEP_FRAME_GENERAL_ETHERNET : p_dst_addr = p ; p += BD_ADDR_LEN ; p_src_addr = p ; p += BD_ADDR_LEN ; BE_STREAM_TO_UINT16 ( protocol , p ) ; rem_len -= 14 ; break ; case BNEP_FRAME_CONTROL : ctrl_type = * p ; p = bnep_process_control_packet ( p_bcb , p , & rem_len , false ) ; if ( ctrl_type == BNEP_SETUP_CONNECTION_REQUEST_MSG && p_bcb -> con_state != BNEP_STATE_CONNECTED && extension_present && p && rem_len ) { p_bcb -> p_pending_data = ( BT_HDR * ) osi_malloc ( rem_len + sizeof ( BT_HDR ) ) ; memcpy ( ( uint8_t * ) ( p_bcb -> p_pending_data + 1 ) , p , rem_len ) ; p_bcb -> p_pending_data -> len = rem_len ; p_bcb -> p_pending_data -> offset = 0 ; } else { while ( extension_present && p && rem_len ) { ext_type = * p ++ ; extension_present = ext_type > > 7 ; ext_type &= 0x7F ; if ( ext_type ) break ; p = bnep_process_control_packet ( p_bcb , p , & rem_len , true ) ; } } osi_free ( p_buf ) ; return ; case BNEP_FRAME_COMPRESSED_ETHERNET : BE_STREAM_TO_UINT16 ( protocol , p ) ; rem_len -= 2 ; break ; case BNEP_FRAME_COMPRESSED_ETHERNET_SRC_ONLY : p_src_addr = p ; p += BD_ADDR_LEN ; BE_STREAM_TO_UINT16 ( protocol , p ) ; rem_len -= 8 ; break ; case BNEP_FRAME_COMPRESSED_ETHERNET_DEST_ONLY : p_dst_addr = p ; p += BD_ADDR_LEN ; BE_STREAM_TO_UINT16 ( protocol , p ) ; rem_len -= 8 ; break ; } while ( extension_present && p && rem_len ) { ext_type = * p ; extension_present = ext_type > > 7 ; ext_type &= 0x7F ; if ( ext_type ) { BNEP_TRACE_EVENT ( "Data extension type 0x%x found" , ext_type ) ; break ; } p ++ ; rem_len -- ; p = bnep_process_control_packet ( p_bcb , p , & rem_len , true ) ; } p_buf -> offset += p_buf -> len - rem_len ; p_buf -> len = rem_len ; if ( ! p_src_addr ) p_src_addr = ( uint8_t * ) p_bcb -> rem_bda ; if ( ! p_dst_addr ) p_dst_addr = ( uint8_t * ) controller_get_interface ( ) -> get_address ( ) ; if ( ext_type ) fw_ext_present = true ; else fw_ext_present = false ; if ( bnep_cb . p_data_buf_cb ) { ( * bnep_cb . p_data_buf_cb ) ( p_bcb -> handle , p_src_addr , p_dst_addr , protocol , p_buf , fw_ext_present ) ; } else if ( bnep_cb . p_data_ind_cb ) { ( * bnep_cb . p_data_ind_cb ) ( p_bcb -> handle , p_src_addr , p_dst_addr , protocol , p , rem_len , fw_ext_present ) ; osi_free ( p_buf ) ; } }
RemoveFile :: Parse ( NS_tchar * line ) { mFile = get_valid_path ( & line ) ; if ( ! mFile ) return PARSE_ERROR ; return OK ; }
JS :: ubi :: Concrete < JSString > :: size ( mozilla :: MallocSizeOf mallocSizeOf ) const { JSString & str = get ( ) ; size_t size = str . isFatInline ( ) ? sizeof ( JSFatInlineString ) : sizeof ( JSString ) ; MOZ_ASSERT ( ! IsInsideNursery ( & str ) ) ; size += str . sizeOfExcludingThis ( mallocSizeOf ) ; return size ; }
status_t AudioFlinger :: EffectHandle :: command ( uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { ALOGVV ( "command(), cmdCode: %d, mHasControl: %d, mEffect: %p" , cmdCode , mHasControl , mEffect . unsafe_get ( ) ) ; if ( cmdCode == EFFECT_CMD_ENABLE ) { if ( * replySize < sizeof ( int ) ) { android_errorWriteLog ( 0x534e4554 , "32095713" ) ; return BAD_VALUE ; } * ( int * ) pReplyData = NO_ERROR ; * replySize = sizeof ( int ) ; return enable ( ) ; } else if ( cmdCode == EFFECT_CMD_DISABLE ) { if ( * replySize < sizeof ( int ) ) { android_errorWriteLog ( 0x534e4554 , "32095713" ) ; return BAD_VALUE ; } * ( int * ) pReplyData = NO_ERROR ; * replySize = sizeof ( int ) ; return disable ( ) ; } AutoMutex _l ( mLock ) ; sp < EffectModule > effect = mEffect . promote ( ) ; if ( effect == 0 || mDisconnected ) { return DEAD_OBJECT ; } if ( ! mHasControl && cmdCode != EFFECT_CMD_GET_PARAM ) { return INVALID_OPERATION ; } if ( mClient == 0 ) { return INVALID_OPERATION ; } if ( cmdCode == EFFECT_CMD_SET_PARAM_COMMIT ) { if ( * replySize < sizeof ( int ) ) { android_errorWriteLog ( 0x534e4554 , "32095713" ) ; return BAD_VALUE ; } * ( int * ) pReplyData = NO_ERROR ; * replySize = sizeof ( int ) ; Mutex :: Autolock _l ( mCblk -> lock ) ; const uint32_t clientIndex = mCblk -> clientIndex ; const uint32_t serverIndex = mCblk -> serverIndex ; if ( clientIndex > EFFECT_PARAM_BUFFER_SIZE || serverIndex > EFFECT_PARAM_BUFFER_SIZE ) { mCblk -> serverIndex = 0 ; mCblk -> clientIndex = 0 ; return BAD_VALUE ; } status_t status = NO_ERROR ; effect_param_t * param = NULL ; for ( uint32_t index = serverIndex ; index < clientIndex ; ) { int * p = ( int * ) ( mBuffer + index ) ; const int size = * p ++ ; if ( size < 0 || size > EFFECT_PARAM_BUFFER_SIZE || ( ( uint8_t * ) p + size ) > mBuffer + clientIndex ) { ALOGW ( "command(): invalid parameter block size" ) ; status = BAD_VALUE ; break ; } param = ( effect_param_t * ) realloc ( param , size ) ; if ( param == NULL ) { ALOGW ( "command(): out of memory" ) ; status = NO_MEMORY ; break ; } memcpy ( param , p , size ) ; int reply = 0 ; uint32_t rsize = sizeof ( reply ) ; status_t ret = effect -> command ( EFFECT_CMD_SET_PARAM , size , param , & rsize , & reply ) ; if ( serverIndex != mCblk -> serverIndex || clientIndex > mCblk -> clientIndex ) { android_errorWriteLog ( 0x534e4554 , "32220769" ) ; status = BAD_VALUE ; break ; } if ( ret != NO_ERROR ) { status = ret ; * ( int * ) pReplyData = reply ; break ; } else if ( reply != NO_ERROR ) { * ( int * ) pReplyData = reply ; break ; } index += size ; } free ( param ) ; mCblk -> serverIndex = 0 ; mCblk -> clientIndex = 0 ; return status ; } return effect -> command ( cmdCode , cmdSize , pCmdData , replySize , pReplyData ) ; }
int mesg_make_query ( u_char * qname , uint16_t qtype , uint16_t qclass , uint32_t id , int rd , u_char * buf , int buflen ) { char * fn = "mesg_make_query()" ; u_char * ucp ; int i , written_len ; Mesg_Hdr * hdr ; if ( T . debug > 4 ) syslog ( LOG_DEBUG , "%s: (qtype: %s, id: %d): start" , fn , string_rtype ( qtype ) , id ) ; hdr = ( Mesg_Hdr * ) buf ; hdr -> id = id ; hdr -> opcode = OP_QUERY ; hdr -> rcode = RC_OK ; hdr -> rd = rd ; hdr -> qr = hdr -> aa = hdr -> tc = hdr -> ra = hdr -> zero = 0 ; hdr -> qdcnt = ntohs ( 1 ) ; hdr -> ancnt = hdr -> nscnt = hdr -> arcnt = ntohs ( 0 ) ; written_len = sizeof ( Mesg_Hdr ) ; ucp = ( u_char * ) ( hdr + 1 ) ; if ( T . debug > 4 ) syslog ( LOG_DEBUG , "%s: qname offset = %zd" , fn , ucp - buf ) ; i = dname_copy ( qname , ucp , buflen - written_len ) ; if ( i < 0 ) return - 1 ; written_len += i ; ucp += i ; if ( T . debug > 4 ) syslog ( LOG_DEBUG , "%s: qtype/qclass offset = %zd" , fn , ucp - buf ) ; written_len += sizeof ( uint16_t ) * 2 ; if ( written_len > buflen ) return - 1 ; PUTSHORT ( qtype , ucp ) ; PUTSHORT ( qclass , ucp ) ; return written_len ; }
static int handle_eac3 ( MOVMuxContext * mov , AVPacket * pkt , MOVTrack * track ) { GetBitContext gbc ; AC3HeaderInfo tmp , * hdr = & tmp ; struct eac3_info * info ; int num_blocks ; if ( ! track -> eac3_priv && ! ( track -> eac3_priv = av_mallocz ( sizeof ( * info ) ) ) ) return AVERROR ( ENOMEM ) ; info = track -> eac3_priv ; init_get_bits ( & gbc , pkt -> data , pkt -> size * 8 ) ; if ( avpriv_ac3_parse_header ( & gbc , & hdr ) < 0 ) { if ( ! track -> entry ) { av_log ( mov , AV_LOG_WARNING , "Dropping invalid packet from start of the stream\n" ) ; return 0 ; } return AVERROR_INVALIDDATA ; } info -> data_rate = FFMAX ( info -> data_rate , hdr -> bit_rate / 1000 ) ; num_blocks = hdr -> num_blocks ; if ( ! info -> ec3_done ) { if ( hdr -> bitstream_id <= 10 && hdr -> substreamid != 0 ) return AVERROR ( EINVAL ) ; if ( hdr -> frame_type == EAC3_FRAME_TYPE_INDEPENDENT ) { if ( hdr -> substreamid > info -> num_ind_sub + 1 ) return AVERROR ( EINVAL ) ; if ( hdr -> substreamid == info -> num_ind_sub + 1 ) { avpriv_request_sample ( track -> par , "Multiple independent substreams" ) ; return AVERROR_PATCHWELCOME ; } else if ( hdr -> substreamid < info -> num_ind_sub || hdr -> substreamid == 0 && info -> substream [ 0 ] . bsid ) { info -> ec3_done = 1 ; goto concatenate ; } } info -> substream [ hdr -> substreamid ] . fscod = hdr -> sr_code ; info -> substream [ hdr -> substreamid ] . bsid = hdr -> bitstream_id ; info -> substream [ hdr -> substreamid ] . bsmod = hdr -> bitstream_mode ; info -> substream [ hdr -> substreamid ] . acmod = hdr -> channel_mode ; info -> substream [ hdr -> substreamid ] . lfeon = hdr -> lfe_on ; if ( pkt -> size != hdr -> frame_size ) { int cumul_size = hdr -> frame_size ; int parent = hdr -> substreamid ; while ( cumul_size != pkt -> size ) { int i ; init_get_bits ( & gbc , pkt -> data + cumul_size , ( pkt -> size - cumul_size ) * 8 ) ; if ( avpriv_ac3_parse_header ( & gbc , & hdr ) < 0 ) return AVERROR_INVALIDDATA ; if ( hdr -> frame_type != EAC3_FRAME_TYPE_DEPENDENT ) return AVERROR ( EINVAL ) ; cumul_size += hdr -> frame_size ; info -> substream [ parent ] . num_dep_sub ++ ; skip_bits ( & gbc , 5 ) ; for ( i = 0 ; i < ( hdr -> channel_mode ? 1 : 2 ) ; i ++ ) { skip_bits ( & gbc , 5 ) ; if ( get_bits1 ( & gbc ) ) { skip_bits ( & gbc , 8 ) ; } } if ( get_bits1 ( & gbc ) ) info -> substream [ parent ] . chan_loc |= ( get_bits ( & gbc , 16 ) > > 5 ) & 0x1f ; else info -> substream [ parent ] . chan_loc |= hdr -> channel_mode ; } } } concatenate : if ( ! info -> num_blocks && num_blocks == 6 ) return pkt -> size ; else if ( info -> num_blocks + num_blocks > 6 ) return AVERROR_INVALIDDATA ; if ( ! info -> num_blocks ) { int ret ; if ( ( ret = av_copy_packet ( & info -> pkt , pkt ) ) < 0 ) return ret ; info -> num_blocks = num_blocks ; return 0 ; } else { int ret ; if ( ( ret = av_grow_packet ( & info -> pkt , pkt -> size ) ) < 0 ) return ret ; memcpy ( info -> pkt . data + info -> pkt . size - pkt -> size , pkt -> data , pkt -> size ) ; info -> num_blocks += num_blocks ; info -> pkt . duration += pkt -> duration ; if ( ( ret = av_copy_packet_side_data ( & info -> pkt , pkt ) ) < 0 ) return ret ; if ( info -> num_blocks != 6 ) return 0 ; av_packet_unref ( pkt ) ; if ( ( ret = av_copy_packet ( pkt , & info -> pkt ) ) < 0 ) return ret ; av_packet_unref ( & info -> pkt ) ; info -> num_blocks = 0 ; } return pkt -> size ; }
nsEventTargetChainItem :: PostHandleEvent ( nsEventChainPostVisitor & aVisitor ) { aVisitor . mItemFlags = mItemFlags ; aVisitor . mItemData = mItemData ; mTarget -> PostHandleEvent ( aVisitor ) ; return NS_OK ; }
open_log_file ( const char * name , const char * prog , const char * namespace , const char * instance ) { char * file_name ; if ( log_file ) { fclose ( log_file ) ; log_file = NULL ; } if ( ! name ) return ; file_name = make_file_name ( name , prog , namespace , instance ) ; log_file = fopen ( file_name , "a" ) ; if ( log_file ) { int n = fileno ( log_file ) ; fcntl ( n , F_SETFD , FD_CLOEXEC | fcntl ( n , F_GETFD ) ) ; fcntl ( n , F_SETFL , O_NONBLOCK | fcntl ( n , F_GETFL ) ) ; } FREE ( file_name ) ; }
RUNTIME_FUNCTION ( Runtime_InterpreterTraceUpdateFeedback ) { if ( ! FLAG_trace_feedback_updates ) { return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; } SealHandleScope shs ( isolate ) ; DCHECK_EQ ( 3 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSFunction , function , 0 ) ; CONVERT_SMI_ARG_CHECKED ( slot , 1 ) ; CONVERT_ARG_CHECKED ( String , reason , 2 ) ; int slot_count = function -> feedback_vector ( ) -> metadata ( ) -> slot_count ( ) ; StdoutStream os ; os < < "[Feedback slot " < < slot < < "/" < < slot_count < < " in " ; function -> shared ( ) -> ShortPrint ( os ) ; os < < " updated to " ; function -> feedback_vector ( ) -> FeedbackSlotPrint ( os , FeedbackSlot ( slot ) ) ; os < < " - " ; StringCharacterStream stream ( reason ) ; while ( stream . HasMore ( ) ) { uint16_t character = stream . GetNext ( ) ; PrintF ( "%c" , character ) ; } os < < "]" < < std :: endl ; return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
bool SetPropIRGenerator :: tryAttachAddSlotStub ( HandleObjectGroup oldGroup , HandleShape oldShape ) { ValOperandId objValId ( writer . setInputOperandId ( 0 ) ) ; ValOperandId rhsValId ; if ( cacheKind_ == CacheKind :: SetProp ) { rhsValId = ValOperandId ( writer . setInputOperandId ( 1 ) ) ; } else { MOZ_ASSERT ( cacheKind_ == CacheKind :: SetElem ) ; MOZ_ASSERT ( setElemKeyValueId ( ) . id ( ) == 1 ) ; writer . setInputOperandId ( 1 ) ; rhsValId = ValOperandId ( writer . setInputOperandId ( 2 ) ) ; } RootedId id ( cx_ ) ; bool nameOrSymbol ; if ( ! ValueToNameOrSymbolId ( cx_ , idVal_ , & id , & nameOrSymbol ) ) { cx_ -> clearPendingException ( ) ; return false ; } if ( ! lhsVal_ . isObject ( ) || ! nameOrSymbol ) { return false ; } RootedObject obj ( cx_ , & lhsVal_ . toObject ( ) ) ; PropertyResult prop ; JSObject * holder ; if ( ! LookupPropertyPure ( cx_ , obj , id , & holder , & prop ) ) { return false ; } if ( obj != holder ) { return false ; } Shape * propShape = nullptr ; NativeObject * holderOrExpando = nullptr ; if ( obj -> isNative ( ) ) { propShape = prop . shape ( ) ; holderOrExpando = & obj -> as < NativeObject > ( ) ; } else { if ( ! obj -> is < UnboxedPlainObject > ( ) ) { return false ; } UnboxedExpandoObject * expando = obj -> as < UnboxedPlainObject > ( ) . maybeExpando ( ) ; if ( ! expando ) { return false ; } propShape = expando -> lookupPure ( id ) ; if ( ! propShape ) { return false ; } holderOrExpando = expando ; } MOZ_ASSERT ( propShape ) ; if ( holderOrExpando -> lastProperty ( ) != propShape ) { return false ; } if ( ! obj -> nonProxyIsExtensible ( ) || propShape -> previous ( ) != oldShape ) { return false ; } if ( propShape -> inDictionary ( ) || ! propShape -> isDataProperty ( ) || ! propShape -> writable ( ) ) { return false ; } if ( ClassMayResolveId ( cx_ -> names ( ) , obj -> getClass ( ) , id , obj ) ) { if ( ! obj -> is < JSFunction > ( ) || ! JSID_IS_ATOM ( id , cx_ -> names ( ) . prototype ) || ! oldGroup -> maybeInterpretedFunction ( ) || ! obj -> as < JSFunction > ( ) . needsPrototypeProperty ( ) ) { return false ; } MOZ_ASSERT ( ! propShape -> configurable ( ) ) ; MOZ_ASSERT ( ! propShape -> enumerable ( ) ) ; } DebugOnly < uint32_t > index ; MOZ_ASSERT_IF ( obj -> is < ArrayObject > ( ) , ! IdIsIndex ( id , & index ) ) ; if ( ! obj -> is < ArrayObject > ( ) && obj -> getClass ( ) -> getAddProperty ( ) ) { return false ; } for ( JSObject * proto = obj -> staticPrototype ( ) ; proto ; proto = proto -> staticPrototype ( ) ) { if ( ! proto -> isNative ( ) ) { return false ; } Shape * protoShape = proto -> as < NativeObject > ( ) . lookup ( cx_ , id ) ; if ( protoShape && ! protoShape -> hasDefaultSetter ( ) ) { return false ; } if ( ClassMayResolveId ( cx_ -> names ( ) , proto -> getClass ( ) , id , proto ) && ! proto -> is < JSFunction > ( ) ) { return false ; } } ObjOperandId objId = writer . guardIsObject ( objValId ) ; maybeEmitIdGuard ( id ) ; MOZ_ASSERT ( ! oldGroup -> hasUncacheableClass ( ) || obj -> is < ShapedObject > ( ) ) ; writer . guardGroupForTypeBarrier ( objId , oldGroup ) ; AutoSweepObjectGroup sweep ( oldGroup ) ; if ( oldGroup -> newScript ( sweep ) && ! oldGroup -> newScript ( sweep ) -> analyzed ( ) ) { writer . guardGroupHasUnanalyzedNewScript ( oldGroup ) ; MOZ_ASSERT ( IsPreliminaryObject ( obj ) ) ; preliminaryObjectAction_ = PreliminaryObjectAction :: NotePreliminary ; } else { preliminaryObjectAction_ = PreliminaryObjectAction :: Unlink ; } ObjOperandId holderId = objId ; if ( ! obj -> isNative ( ) ) { MOZ_ASSERT ( obj -> as < UnboxedPlainObject > ( ) . maybeExpando ( ) ) ; holderId = writer . guardAndLoadUnboxedExpando ( objId ) ; } writer . guardShape ( holderId , oldShape ) ; ShapeGuardProtoChain ( writer , obj , objId ) ; ObjectGroup * newGroup = obj -> group ( ) ; bool changeGroup = oldGroup != newGroup ; MOZ_ASSERT_IF ( changeGroup , obj -> is < PlainObject > ( ) ) ; if ( holderOrExpando -> isFixedSlot ( propShape -> slot ( ) ) ) { size_t offset = NativeObject :: getFixedSlotOffset ( propShape -> slot ( ) ) ; writer . addAndStoreFixedSlot ( holderId , offset , rhsValId , propShape , changeGroup , newGroup ) ; trackAttached ( "AddSlot" ) ; } else { size_t offset = holderOrExpando -> dynamicSlotIndex ( propShape -> slot ( ) ) * sizeof ( Value ) ; uint32_t numOldSlots = NativeObject :: dynamicSlotsCount ( oldShape ) ; uint32_t numNewSlots = NativeObject :: dynamicSlotsCount ( propShape ) ; if ( numOldSlots == numNewSlots ) { writer . addAndStoreDynamicSlot ( holderId , offset , rhsValId , propShape , changeGroup , newGroup ) ; trackAttached ( "AddSlot" ) ; } else { MOZ_ASSERT ( numNewSlots > numOldSlots ) ; writer . allocateAndStoreDynamicSlot ( holderId , offset , rhsValId , propShape , changeGroup , newGroup , numNewSlots ) ; trackAttached ( "AllocateSlot" ) ; } } writer . returnFromIC ( ) ; typeCheckInfo_ . set ( oldGroup , id ) ; return true ; }
JS_XDRInitBase ( JSXDRState * xdr , JSXDRMode mode , JSContext * cx ) { xdr -> mode = mode ; xdr -> cx = cx ; xdr -> registry = NULL ; xdr -> numclasses = xdr -> maxclasses = 0 ; xdr -> reghash = NULL ; xdr -> userdata = NULL ; xdr -> script = NULL ; xdr -> filename = NULL ; xdr -> atoms = NULL ; xdr -> atomsMap = NULL ; }
static Jsi_RC jsi_ArrayMapCmd ( Jsi_Interp * interp , Jsi_Value * args , Jsi_Value * _this , Jsi_Value * * ret , Jsi_Func * funcPtr ) { if ( _this -> vt != JSI_VT_OBJECT || ! Jsi_ObjIsArray ( interp , _this -> d . obj ) ) return Jsi_LogError ( "expected array object" ) ; Jsi_RC rc = JSI_OK ; int curlen , nsiz , i , maa = 0 ; Jsi_Obj * obj , * nobj ; Jsi_Value * func , * vpargs , * nthis = NULL , * sthis ; Jsi_Func * fptr = NULL ; func = Jsi_ValueArrayIndex ( interp , args , 0 ) ; if ( ! Jsi_ValueIsFunction ( interp , func ) ) return Jsi_LogError ( "expected function" ) ; sthis = Jsi_ValueArrayIndex ( interp , args , 1 ) ; if ( ! sthis ) sthis = nthis = Jsi_ValueNew1 ( interp ) ; obj = _this -> d . obj ; curlen = Jsi_ObjGetLength ( interp , obj ) ; if ( curlen < 0 ) { Jsi_ObjSetLength ( interp , obj , 0 ) ; } Jsi_ObjListifyArray ( interp , obj ) ; nobj = Jsi_ObjNewType ( interp , JSI_OT_ARRAY ) ; nsiz = obj -> arrCnt ; if ( nsiz <= 0 ) nsiz = 1 ; if ( Jsi_ObjArraySizer ( interp , nobj , nsiz ) <= 0 ) { Jsi_LogError ( "index too large: %d" , nsiz ) ; rc = JSI_ERROR ; goto bail ; } Jsi_ValueMakeArrayObject ( interp , ret , nobj ) ; Jsi_Value * vobjs [ 3 ] ; fptr = func -> d . obj -> d . fobj -> func ; maa = ( fptr -> argnames ? fptr -> argnames -> argCnt : 0 ) ; if ( maa > 3 ) maa = 3 ; for ( i = 0 ; i < curlen ; i ++ ) { if ( ! obj -> arr [ i ] ) continue ; vobjs [ 0 ] = obj -> arr [ i ] ; vobjs [ 1 ] = ( maa > 1 ? Jsi_ValueNewNumber ( interp , i ) : NULL ) ; vobjs [ 2 ] = _this ; vpargs = Jsi_ValueMakeObject ( interp , NULL , Jsi_ObjNewArray ( interp , vobjs , maa , 0 ) ) ; Jsi_IncrRefCount ( interp , vpargs ) ; nobj -> arr [ i ] = Jsi_ValueNew1 ( interp ) ; rc = Jsi_FunctionInvoke ( interp , func , vpargs , nobj -> arr + i , sthis ) ; Jsi_DecrRefCount ( interp , vpargs ) ; if ( JSI_OK != rc ) { goto bail ; } } Jsi_ObjSetLength ( interp , nobj , curlen ) ; if ( nthis ) Jsi_DecrRefCount ( interp , nthis ) ; return JSI_OK ; bail : Jsi_ValueMakeNull ( interp , ret ) ; if ( nthis ) Jsi_DecrRefCount ( interp , nthis ) ; return rc ; }
void ObjectStatsCollectorImpl :: RecordVirtualExternalStringDetails ( ExternalString * string ) { Address resource = string -> resource_as_address ( ) ; size_t off_heap_size = string -> ExternalPayloadSize ( ) ; RecordExternalResourceStats ( resource , string -> IsOneByteRepresentation ( ) ? ObjectStats :: STRING_EXTERNAL_RESOURCE_ONE_BYTE_TYPE : ObjectStats :: STRING_EXTERNAL_RESOURCE_TWO_BYTE_TYPE , off_heap_size ) ; }
archive_read_format_rar_read_data ( struct archive_read * a , const void * * buff , size_t * size , int64_t * offset ) { struct rar * rar = ( struct rar * ) ( a -> format -> data ) ; int ret ; if ( rar -> has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW ) { rar -> has_encrypted_entries = 0 ; } if ( rar -> bytes_unconsumed > 0 ) { __archive_read_consume ( a , rar -> bytes_unconsumed ) ; rar -> bytes_unconsumed = 0 ; } * buff = NULL ; if ( rar -> entry_eof || rar -> offset_seek >= rar -> unp_size ) { * size = 0 ; * offset = rar -> offset ; if ( * offset < rar -> unp_size ) * offset = rar -> unp_size ; return ( ARCHIVE_EOF ) ; } switch ( rar -> compression_method ) { case COMPRESS_METHOD_STORE : ret = read_data_stored ( a , buff , size , offset ) ; break ; case COMPRESS_METHOD_FASTEST : case COMPRESS_METHOD_FAST : case COMPRESS_METHOD_NORMAL : case COMPRESS_METHOD_GOOD : case COMPRESS_METHOD_BEST : ret = read_data_compressed ( a , buff , size , offset ) ; if ( ret != ARCHIVE_OK && ret != ARCHIVE_WARN ) __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context ) ; break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Unsupported compression method for RAR file." ) ; ret = ARCHIVE_FATAL ; break ; } return ( ret ) ; }
% o exception : return any errors or warnings in this structure . % * / static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MaxTextExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; pwp_image = AcquireImage ( image_info ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , "SFW95" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for ( ; ; ) { for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) == 0 ) break ; } if ( c == EOF ) break ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowFileException ( exception , FileOpenError , "UnableToWriteFile" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( "SFW94A" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MaxTextExtent , "slide_%02ld.sfw" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; ( void ) CloseBlob ( pwp_image ) ; pwp_image = DestroyImage ( pwp_image ) ; if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , "UnexpectedEndOfFile" , "`%s': %s" , image -> filename , message ) ; message = DestroyString ( message ) ; }
static bool AllowedImageSize ( int32_t aWidth , int32_t aHeight ) { const int32_t k64KLimit = 0x0000FFFF ; if ( MOZ_UNLIKELY ( aWidth > k64KLimit || aHeight > k64KLimit ) ) { NS_WARNING ( "image too big" ) ; return false ; } if ( MOZ_UNLIKELY ( aHeight <= 0 || aWidth <= 0 ) ) { return false ; } int32_t tmp = aWidth * aHeight ; if ( MOZ_UNLIKELY ( tmp / aHeight != aWidth ) ) { NS_WARNING ( "width or height too large" ) ; return false ; } tmp = tmp * 4 ; if ( MOZ_UNLIKELY ( tmp / 4 != aWidth * aHeight ) ) { NS_WARNING ( "width or height too large" ) ; return false ; } #if defined(XP_MACOSX) if ( MOZ_UNLIKELY ( aHeight > SHRT_MAX ) ) { NS_WARNING ( "image too big" ) ; return false ; } #endif return true ; }
static void usage ( const char * name ) { printf ( "\ Usage : %s [options] catalogfile entities...\n\ \tParse the catalog file and query it for the entities\n\ \t--sgml : handle SGML Super catalogs for --add and --del\n\ \t--shell : run a shell allowing interactive queries\n\ \t--create : create a new catalog\n\ \t--add 'type' 'orig' 'replace' : add an XML entry\n\ \t--add 'entry' : add an SGML entry\n" , name ) ; printf ( "\ \t--del 'values' : remove values\n\ \t--noout: avoid dumping the result on stdout\n\ \t         used with --add or --del, it saves the catalog changes\n\ \t         and with --sgml it automatically updates the super catalog\n\ \t--no-super-update: do not update the SGML super catalog\n\ \t-v --verbose : provide debug informations\n" ) ; }
bool AsyncStreamingProcessor :: ProcessFunctionBody ( Vector < const uint8_t > bytes , uint32_t offset ) { TRACE_STREAMING ( "Process function body %d ...\n" , next_function_ ) ; decoder_ . DecodeFunctionBody ( next_function_ , static_cast < uint32_t > ( bytes . length ( ) ) , offset , false ) ; uint32_t index = next_function_ + decoder_ . module ( ) -> num_imported_functions ; const WasmFunction * func = & decoder_ . module ( ) -> functions [ index ] ; WasmName name = { nullptr , 0 } ; compilation_unit_builder_ -> AddUnit ( func , offset , bytes , name ) ; ++ next_function_ ; return true ; }
struct nlattr * nla_reserve ( struct nl_msg * msg , int attrtype , int attrlen ) { struct nlattr * nla ; int tlen ; tlen = NLMSG_ALIGN ( msg -> nm_nlh -> nlmsg_len ) + nla_total_size ( attrlen ) ; if ( ( tlen + msg -> nm_nlh -> nlmsg_len ) > msg -> nm_size ) return NULL ; nla = ( struct nlattr * ) nlmsg_tail ( msg -> nm_nlh ) ; nla -> nla_type = attrtype ; nla -> nla_len = nla_attr_size ( attrlen ) ; memset ( ( unsigned char * ) nla + nla -> nla_len , 0 , nla_padlen ( attrlen ) ) ; msg -> nm_nlh -> nlmsg_len = tlen ; NL_DBG ( 2 , "msg %p: Reserved %d bytes at offset +%td for attr %d " "nlmsg_len=%d\n" , msg , attrlen , ( void * ) nla - nlmsg_data ( msg -> nm_nlh ) , attrtype , msg -> nm_nlh -> nlmsg_len ) ; return nla ; }
ParallelGetPropertyIC :: canAttachReadSlot ( LockedJSContext & cx , JSObject * obj , MutableHandleObject holder , MutableHandleShape shape ) { if ( ! obj -> isNative ( ) ) return false ; if ( IsIdempotentAndMaybeHasHooks ( * this , obj ) ) return false ; if ( obj -> getOps ( ) -> lookupProperty || obj -> getOps ( ) -> lookupGeneric ) return false ; if ( ! js :: LookupPropertyPure ( obj , NameToId ( name ( ) ) , holder . address ( ) , shape . address ( ) ) ) return false ; bool readSlot ; bool callGetter ; if ( ! DetermineGetPropKind ( cx , * this , obj , obj , holder , shape , output ( ) , false , & readSlot , & callGetter ) || ! readSlot ) { return false ; } if ( IsIdempotentAndHasSingletonHolder ( * this , holder , shape ) ) return false ; return true ; }
static long __media_device_enum_links ( struct media_device * mdev , struct media_links_enum * links ) { struct media_entity * entity ; entity = find_entity ( mdev , links -> entity ) ; if ( entity == NULL ) return - EINVAL ; if ( links -> pads ) { unsigned int p ; for ( p = 0 ; p < entity -> num_pads ; p ++ ) { struct media_pad_desc pad ; media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ; } } if ( links -> links ) { struct media_link_desc __user * ulink ; unsigned int l ; for ( l = 0 , ulink = links -> links ; l < entity -> num_links ; l ++ ) { struct media_link_desc link ; if ( entity -> links [ l ] . source -> entity != entity ) continue ; media_device_kpad_to_upad ( entity -> links [ l ] . source , & link . source ) ; media_device_kpad_to_upad ( entity -> links [ l ] . sink , & link . sink ) ; link . flags = entity -> links [ l ] . flags ; if ( copy_to_user ( ulink , & link , sizeof ( * ulink ) ) ) return - EFAULT ; ulink ++ ; } } return 0 ; }
static void * bpf_obj_do_get ( const struct filename * pathname , enum bpf_type * type ) { struct inode * inode ; struct path path ; void * raw ; int ret ; ret = kern_path ( pathname -> name , LOOKUP_FOLLOW , & path ) ; if ( ret ) return ERR_PTR ( ret ) ; inode = d_backing_inode ( path . dentry ) ; ret = inode_permission ( inode , MAY_WRITE ) ; if ( ret ) goto out ; ret = bpf_inode_type ( inode , type ) ; if ( ret ) goto out ; raw = bpf_any_get ( inode -> i_private , * type ) ; touch_atime ( & path ) ; path_put ( & path ) ; return raw ; out : path_put ( & path ) ; return ERR_PTR ( ret ) ; }
void imap_quote_string ( char * dest , size_t dlen , const char * src ) { static const char quote [ ] = "\"\\" ; char * pt = dest ; const char * s = src ; * pt ++ = '"' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { dlen -= 2 ; if ( dlen == 0 ) break ; * pt ++ = '\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = '"' ; * pt = '\0' ; }
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
static inline int mount_entry_on_generic ( struct mntent * mntent , const char * path ) { unsigned long mntflags ; char * mntdata ; int ret ; bool optional = hasmntopt ( mntent , "optional" ) != NULL ; ret = mount_entry_create_dir_file ( mntent , path ) ; if ( ret < 0 ) return optional ? 0 : - 1 ; cull_mntent_opt ( mntent ) ; if ( parse_mntopts ( mntent -> mnt_opts , & mntflags , & mntdata ) < 0 ) { free ( mntdata ) ; return - 1 ; } ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type , mntflags , mntdata , optional ) ; free ( mntdata ) ; return ret ; }
js :: StartOffThreadParseScript ( JSContext * cx , const ReadOnlyCompileOptions & options , const char16_t * chars , size_t length , JS :: OffThreadCompileCallback callback , void * callbackData ) { gc :: AutoSuppressGC nogc ( cx ) ; gc :: AutoAssertNoNurseryAlloc noNurseryAlloc ( cx -> runtime ( ) ) ; JSObject * global = CreateGlobalForOffThreadParse ( cx , ParseTaskKind :: Script , nogc ) ; if ( ! global ) return false ; ScopedJSDeletePtr < ExclusiveContext > helpercx ( cx -> new_ < ExclusiveContext > ( cx -> runtime ( ) , ( PerThreadData * ) nullptr , ExclusiveContext :: Context_Exclusive ) ) ; if ( ! helpercx ) return false ; ScopedJSDeletePtr < ParseTask > task ( cx -> new_ < ScriptParseTask > ( helpercx . get ( ) , global , cx , chars , length , callback , callbackData ) ) ; if ( ! task ) return false ; helpercx . forget ( ) ; if ( ! task -> init ( cx , options ) || ! QueueOffThreadParseTask ( cx , task ) ) return false ; task . forget ( ) ; return true ; }
this ] ( RefPtr < MediaMgrError > && aResult ) { if ( mStopped ) { - return SourceListenerPromise :: CreateAndReject ( std :: move ( aResult ) , + return DeviceListenerPromise :: CreateAndReject ( std :: move ( aResult ) , __func__ ) ; } - for ( DeviceState * state : - { mAudioDeviceState . get ( ) , mVideoDeviceState . get ( ) } ) { - if ( ! state ) { - continue ; - } - MOZ_DIAGNOSTIC_ASSERT ( ! state -> mTrackEnabled ) ; - MOZ_DIAGNOSTIC_ASSERT ( ! state -> mDeviceEnabled ) ; - MOZ_DIAGNOSTIC_ASSERT ( ! state -> mStopped ) ; + MOZ_DIAGNOSTIC_ASSERT ( ! mDeviceState -> mTrackEnabled ) ; + MOZ_DIAGNOSTIC_ASSERT ( ! mDeviceState -> mDeviceEnabled ) ; + MOZ_DIAGNOSTIC_ASSERT ( ! mDeviceState -> mStopped ) ; - state -> mStopped = true ; - } - return SourceListenerPromise :: CreateAndReject ( std :: move ( aResult ) , + Stop ( ) ; + return DeviceListenerPromise :: CreateAndReject ( std :: move ( aResult ) , __func__ ) ; } ) ;
TEST ( VP8RoiMapTest , ParameterCheck ) { ACMRandom rnd ( ACMRandom :: DeterministicSeed ( ) ) ; int delta_q [ MAX_MB_SEGMENTS ] = { - 2 , - 25 , 0 , 31 } ; int delta_lf [ MAX_MB_SEGMENTS ] = { - 2 , - 25 , 0 , 31 } ; unsigned int threshold [ MAX_MB_SEGMENTS ] = { 0 , 100 , 200 , 300 } ; const int internalq_trans [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 7 , 8 , 9 , 10 , 12 , 13 , 15 , 17 , 18 , 19 , 20 , 21 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 33 , 35 , 37 , 39 , 41 , 43 , 45 , 47 , 49 , 51 , 53 , 55 , 57 , 59 , 61 , 64 , 67 , 70 , 73 , 76 , 79 , 82 , 85 , 88 , 91 , 94 , 97 , 100 , 103 , 106 , 109 , 112 , 115 , 118 , 121 , 124 , 127 , } ; VP8_COMP cpi ; cpi . mb . e_mbd . mb_segement_abs_delta = SEGMENT_DELTADATA ; cpi . cyclic_refresh_mode_enabled = 0 ; cpi . mb . e_mbd . segmentation_enabled = 0 ; cpi . mb . e_mbd . update_mb_segmentation_map = 0 ; cpi . mb . e_mbd . update_mb_segmentation_data = 0 ; cpi . common . mb_rows = 240 > > 4 ; cpi . common . mb_cols = 320 > > 4 ; const int mbs = ( cpi . common . mb_rows * cpi . common . mb_cols ) ; vpx_memset ( cpi . segment_feature_data , 0 , sizeof ( cpi . segment_feature_data ) ) ; cpi . segmentation_map = reinterpret_cast < unsigned char * > ( vpx_calloc ( mbs , 1 ) ) ; unsigned char * roi_map = reinterpret_cast < unsigned char * > ( vpx_calloc ( mbs , 1 ) ) ; vpx_memset ( & roi_map [ mbs > > 2 ] , 1 , ( mbs > > 2 ) ) ; vpx_memset ( & roi_map [ mbs > > 1 ] , 2 , ( mbs > > 2 ) ) ; vpx_memset ( & roi_map [ mbs - ( mbs > > 2 ) ] , 3 , ( mbs > > 2 ) ) ; int roi_retval = vp8_set_roimap ( & cpi , roi_map , cpi . common . mb_rows , cpi . common . mb_cols , delta_q , delta_lf , threshold ) ; EXPECT_EQ ( 0 , roi_retval ) < < "vp8_set_roimap roi failed with default test parameters" ; if ( roi_retval == 0 ) { const int mapcompare = memcmp ( roi_map , cpi . segmentation_map , mbs ) ; EXPECT_EQ ( 0 , mapcompare ) < < "segment map error" ; for ( int i = 0 ; i < MAX_MB_SEGMENTS ; ++ i ) { const int transq = internalq_trans [ abs ( delta_q [ i ] ) ] ; if ( abs ( cpi . segment_feature_data [ MB_LVL_ALT_Q ] [ i ] ) != transq ) { EXPECT_EQ ( transq , cpi . segment_feature_data [ MB_LVL_ALT_Q ] [ i ] ) < < "segment delta_q  error" ; break ; } } for ( int i = 0 ; i < MAX_MB_SEGMENTS ; ++ i ) { if ( cpi . segment_feature_data [ MB_LVL_ALT_LF ] [ i ] != delta_lf [ i ] ) { EXPECT_EQ ( delta_lf [ i ] , cpi . segment_feature_data [ MB_LVL_ALT_LF ] [ i ] ) < < "segment delta_lf error" ; break ; } } for ( int i = 0 ; i < MAX_MB_SEGMENTS ; ++ i ) { unsigned int breakout = static_cast < unsigned int > ( cpi . segment_encode_breakout [ i ] ) ; if ( threshold [ i ] != breakout ) { EXPECT_EQ ( threshold [ i ] , breakout ) < < "breakout threshold error" ; break ; } } EXPECT_EQ ( 1 , cpi . mb . e_mbd . segmentation_enabled ) < < "segmentation_enabled error" ; EXPECT_EQ ( 1 , cpi . mb . e_mbd . update_mb_segmentation_map ) < < "update_mb_segmentation_map error" ; EXPECT_EQ ( 1 , cpi . mb . e_mbd . update_mb_segmentation_data ) < < "update_mb_segmentation_data error" ; for ( int i = 0 ; i < 1000 ; ++ i ) { int rand_deltas [ 4 ] ; int deltas_valid ; rand_deltas [ 0 ] = rnd ( 160 ) - 80 ; rand_deltas [ 1 ] = rnd ( 160 ) - 80 ; rand_deltas [ 2 ] = rnd ( 160 ) - 80 ; rand_deltas [ 3 ] = rnd ( 160 ) - 80 ; deltas_valid = ( ( abs ( rand_deltas [ 0 ] ) <= 63 ) && ( abs ( rand_deltas [ 1 ] ) <= 63 ) && ( abs ( rand_deltas [ 2 ] ) <= 63 ) && ( abs ( rand_deltas [ 3 ] ) <= 63 ) ) ? 0 : - 1 ; roi_retval = vp8_set_roimap ( & cpi , roi_map , cpi . common . mb_rows , cpi . common . mb_cols , rand_deltas , delta_lf , threshold ) ; EXPECT_EQ ( deltas_valid , roi_retval ) < < "dq range check error" ; if ( deltas_valid != roi_retval ) break ; roi_retval = vp8_set_roimap ( & cpi , roi_map , cpi . common . mb_rows , cpi . common . mb_cols , delta_q , rand_deltas , threshold ) ; EXPECT_EQ ( deltas_valid , roi_retval ) < < "dlf range check error" ; if ( deltas_valid != roi_retval ) break ; } cpi . cyclic_refresh_mode_enabled = 1 ; roi_retval = vp8_set_roimap ( & cpi , roi_map , cpi . common . mb_rows , cpi . common . mb_cols , delta_q , delta_lf , threshold ) ; EXPECT_EQ ( - 1 , roi_retval ) < < "cyclic refresh check error" ; cpi . cyclic_refresh_mode_enabled = 0 ; roi_retval = vp8_set_roimap ( & cpi , roi_map , cpi . common . mb_rows + 1 , cpi . common . mb_cols , delta_q , delta_lf , threshold ) ; EXPECT_EQ ( - 1 , roi_retval ) < < "MB rows bounds check error" ; roi_retval = vp8_set_roimap ( & cpi , roi_map , cpi . common . mb_rows , cpi . common . mb_cols - 1 , delta_q , delta_lf , threshold ) ; EXPECT_EQ ( - 1 , roi_retval ) < < "MB cols bounds check error" ; } if ( cpi . segmentation_map ) vpx_free ( cpi . segmentation_map ) ; if ( roi_map ) vpx_free ( roi_map ) ; } ;
void vp9_idct32x32_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { if ( eob == 1 ) vp9_idct32x32_1_add ( input , dest , stride ) ; else if ( eob <= 34 ) vp9_idct32x32_34_add ( input , dest , stride ) ; else vp9_idct32x32_1024_add ( input , dest , stride ) ; }
DeviceStorageRequestParent :: ActorDestroy ( ActorDestroyReason ) { int32_t count = mRunnables . Length ( ) ; for ( int32_t index = 0 ; index < count ; index ++ ) { mRunnables [ index ] -> Cancel ( ) ; } }
handle_associated_event ( struct cpu_hw_events * cpuc , int idx , struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event * event = cpuc -> events [ idx ] ; struct hw_perf_event * hwc = & event -> hw ; mipspmu_event_update ( event , hwc , idx ) ; data -> period = event -> hw . last_period ; if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) return ; if ( perf_event_overflow ( event , 0 , data , regs ) ) mipspmu -> disable_event ( idx ) ; }
RUNTIME_FUNCTION ( Runtime_PromiseHookAfter ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 1 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSReceiver , maybe_promise , 0 ) ; if ( ! maybe_promise -> IsJSPromise ( ) ) return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; Handle < JSPromise > promise = Handle < JSPromise > :: cast ( maybe_promise ) ; if ( isolate -> debug ( ) -> is_active ( ) ) isolate -> PopPromise ( ) ; if ( promise -> IsJSPromise ( ) ) { isolate -> RunPromiseHook ( PromiseHookType :: kAfter , promise , isolate -> factory ( ) -> undefined_value ( ) ) ; } return ReadOnlyRoots ( isolate ) . undefined_value ( ) ; }
bool ProcessEntries ( v8 :: Platform * platform , HttpRequestProcessor * processor , int count , StringHttpRequest * reqs ) { for ( int i = 0 ; i < count ; i ++ ) { bool result = processor -> Process ( & reqs [ i ] ) ; while ( v8 :: platform :: PumpMessageLoop ( platform , Isolate :: GetCurrent ( ) ) ) continue ; if ( ! result ) return false ; } return true ; }
Node * InterpreterAssembler :: Construct ( Node * target , Node * context , Node * new_target , const RegListNodePair & args , Node * slot_id , Node * feedback_vector ) { DCHECK ( Bytecodes :: MakesCallAlongCriticalPath ( bytecode_ ) ) ; VARIABLE ( var_result , MachineRepresentation :: kTagged ) ; VARIABLE ( var_site , MachineRepresentation :: kTagged ) ; Label extra_checks ( this , Label :: kDeferred ) , return_result ( this , & var_result ) , construct ( this ) , construct_array ( this , & var_site ) ; IncrementCallCount ( feedback_vector , slot_id ) ; TNode < MaybeObject > feedback = LoadFeedbackVectorSlot ( feedback_vector , slot_id ) ; Branch ( IsWeakReferenceTo ( feedback , CAST ( new_target ) ) , & construct , & extra_checks ) ; BIND ( & extra_checks ) ; { Label check_allocation_site ( this ) , check_initialized ( this ) , initialize ( this ) , mark_megamorphic ( this ) ; Comment ( "check if megamorphic" ) ; Node * is_megamorphic = WordEqual ( feedback , HeapConstant ( FeedbackVector :: MegamorphicSentinel ( isolate ( ) ) ) ) ; GotoIf ( is_megamorphic , & construct ) ; Comment ( "check if weak reference" ) ; GotoIfNot ( IsWeakOrClearedHeapObject ( feedback ) , & check_allocation_site ) ; Comment ( "check if weak reference is cleared" ) ; Branch ( IsClearedWeakHeapObject ( feedback ) , & initialize , & mark_megamorphic ) ; BIND ( & check_allocation_site ) ; { Comment ( "check if allocation site" ) ; TNode < HeapObject > strong_feedback = CAST ( feedback ) ; GotoIfNot ( IsAllocationSite ( strong_feedback ) , & check_initialized ) ; Node * array_function = LoadContextElement ( LoadNativeContext ( context ) , Context :: ARRAY_FUNCTION_INDEX ) ; GotoIfNot ( WordEqual ( target , array_function ) , & mark_megamorphic ) ; GotoIfNot ( WordEqual ( new_target , array_function ) , & mark_megamorphic ) ; var_site . Bind ( strong_feedback ) ; Goto ( & construct_array ) ; } BIND ( & check_initialized ) ; { Comment ( "check if uninitialized" ) ; Node * is_uninitialized = WordEqual ( feedback , LoadRoot ( Heap :: kuninitialized_symbolRootIndex ) ) ; Branch ( is_uninitialized , & initialize , & mark_megamorphic ) ; } BIND ( & initialize ) ; { Comment ( "check if function in same native context" ) ; GotoIf ( TaggedIsSmi ( new_target ) , & mark_megamorphic ) ; VARIABLE ( var_current , MachineRepresentation :: kTagged , new_target ) ; Label loop ( this , & var_current ) , done_loop ( this ) ; Goto ( & loop ) ; BIND ( & loop ) ; { Label if_boundfunction ( this ) , if_function ( this ) ; Node * current = var_current . value ( ) ; CSA_ASSERT ( this , TaggedIsNotSmi ( current ) ) ; Node * current_instance_type = LoadInstanceType ( current ) ; GotoIf ( InstanceTypeEqual ( current_instance_type , JS_BOUND_FUNCTION_TYPE ) , & if_boundfunction ) ; Branch ( InstanceTypeEqual ( current_instance_type , JS_FUNCTION_TYPE ) , & if_function , & mark_megamorphic ) ; BIND ( & if_function ) ; { Node * current_context = LoadObjectField ( current , JSFunction :: kContextOffset ) ; Node * current_native_context = LoadNativeContext ( current_context ) ; Branch ( WordEqual ( LoadNativeContext ( context ) , current_native_context ) , & done_loop , & mark_megamorphic ) ; } BIND ( & if_boundfunction ) ; { var_current . Bind ( LoadObjectField ( current , JSBoundFunction :: kBoundTargetFunctionOffset ) ) ; Goto ( & loop ) ; } } BIND ( & done_loop ) ; Label create_allocation_site ( this ) , store_weak_reference ( this ) ; GotoIfNot ( WordEqual ( target , new_target ) , & store_weak_reference ) ; Node * array_function = LoadContextElement ( LoadNativeContext ( context ) , Context :: ARRAY_FUNCTION_INDEX ) ; Branch ( WordEqual ( target , array_function ) , & create_allocation_site , & store_weak_reference ) ; BIND ( & create_allocation_site ) ; { var_site . Bind ( CreateAllocationSiteInFeedbackVector ( feedback_vector , SmiTag ( slot_id ) ) ) ; ReportFeedbackUpdate ( feedback_vector , slot_id , "Construct:CreateAllocationSite" ) ; Goto ( & construct_array ) ; } BIND ( & store_weak_reference ) ; { StoreWeakReferenceInFeedbackVector ( feedback_vector , slot_id , CAST ( new_target ) ) ; ReportFeedbackUpdate ( feedback_vector , slot_id , "Construct:StoreWeakReference" ) ; Goto ( & construct ) ; } } BIND ( & mark_megamorphic ) ; { Comment ( "transition to megamorphic" ) ; DCHECK ( Heap :: RootIsImmortalImmovable ( Heap :: kmegamorphic_symbolRootIndex ) ) ; StoreFeedbackVectorSlot ( feedback_vector , slot_id , HeapConstant ( FeedbackVector :: MegamorphicSentinel ( isolate ( ) ) ) , SKIP_WRITE_BARRIER ) ; ReportFeedbackUpdate ( feedback_vector , slot_id , "Construct:TransitionMegamorphic" ) ; Goto ( & construct ) ; } } BIND ( & construct_array ) ; { Comment ( "call using ConstructArray builtin" ) ; Callable callable = CodeFactory :: InterpreterPushArgsThenConstruct ( isolate ( ) , InterpreterPushArgsMode :: kArrayFunction ) ; Node * code_target = HeapConstant ( callable . code ( ) ) ; var_result . Bind ( CallStub ( callable . descriptor ( ) , code_target , context , args . reg_count ( ) , new_target , target , var_site . value ( ) , args . base_reg_location ( ) ) ) ; Goto ( & return_result ) ; } BIND ( & construct ) ; { Comment ( "call using Construct builtin" ) ; Callable callable = CodeFactory :: InterpreterPushArgsThenConstruct ( isolate ( ) , InterpreterPushArgsMode :: kOther ) ; Node * code_target = HeapConstant ( callable . code ( ) ) ; var_result . Bind ( CallStub ( callable . descriptor ( ) , code_target , context , args . reg_count ( ) , new_target , target , UndefinedConstant ( ) , args . base_reg_location ( ) ) ) ; Goto ( & return_result ) ; } BIND ( & return_result ) ; return var_result . value ( ) ; }
static int __rds_rdma_map ( struct rds_sock * rs , struct rds_get_mr_args * args , u64 * cookie_ret , struct rds_mr * * mr_ret ) { struct rds_mr * mr = NULL , * found ; unsigned int nr_pages ; struct page * * pages = NULL ; struct scatterlist * sg ; void * trans_private ; unsigned long flags ; rds_rdma_cookie_t cookie ; unsigned int nents ; long i ; int ret ; if ( rs -> rs_bound_addr == 0 ) { ret = - ENOTCONN ; goto out ; } if ( ! rs -> rs_transport -> get_mr ) { ret = - EOPNOTSUPP ; goto out ; } nr_pages = rds_pages_in_vec ( & args -> vec ) ; if ( nr_pages == 0 ) { ret = - EINVAL ; goto out ; } if ( ( nr_pages - 1 ) > ( RDS_MAX_MSG_SIZE > > PAGE_SHIFT ) ) { ret = - EMSGSIZE ; goto out ; } rdsdebug ( "RDS: get_mr addr %llx len %llu nr_pages %u\n" , args -> vec . addr , args -> vec . bytes , nr_pages ) ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , GFP_KERNEL ) ; if ( ! pages ) { ret = - ENOMEM ; goto out ; } mr = kzalloc ( sizeof ( struct rds_mr ) , GFP_KERNEL ) ; if ( ! mr ) { ret = - ENOMEM ; goto out ; } refcount_set ( & mr -> r_refcount , 1 ) ; RB_CLEAR_NODE ( & mr -> r_rb_node ) ; mr -> r_trans = rs -> rs_transport ; mr -> r_sock = rs ; if ( args -> flags & RDS_RDMA_USE_ONCE ) mr -> r_use_once = 1 ; if ( args -> flags & RDS_RDMA_INVALIDATE ) mr -> r_invalidate = 1 ; if ( args -> flags & RDS_RDMA_READWRITE ) mr -> r_write = 1 ; ret = rds_pin_pages ( args -> vec . addr , nr_pages , pages , 1 ) ; if ( ret < 0 ) goto out ; nents = ret ; sg = kcalloc ( nents , sizeof ( * sg ) , GFP_KERNEL ) ; if ( ! sg ) { ret = - ENOMEM ; goto out ; } WARN_ON ( ! nents ) ; sg_init_table ( sg , nents ) ; for ( i = 0 ; i < nents ; i ++ ) sg_set_page ( & sg [ i ] , pages [ i ] , PAGE_SIZE , 0 ) ; rdsdebug ( "RDS: trans_private nents is %u\n" , nents ) ; trans_private = rs -> rs_transport -> get_mr ( sg , nents , rs , & mr -> r_key ) ; if ( IS_ERR ( trans_private ) ) { for ( i = 0 ; i < nents ; i ++ ) put_page ( sg_page ( & sg [ i ] ) ) ; kfree ( sg ) ; ret = PTR_ERR ( trans_private ) ; goto out ; } mr -> r_trans_private = trans_private ; rdsdebug ( "RDS: get_mr put_user key is %x cookie_addr %p\n" , mr -> r_key , ( void * ) ( unsigned long ) args -> cookie_addr ) ; cookie = rds_rdma_make_cookie ( mr -> r_key , args -> vec . addr & ~ PAGE_MASK ) ; if ( cookie_ret ) * cookie_ret = cookie ; if ( args -> cookie_addr && put_user ( cookie , ( u64 __user * ) ( unsigned long ) args -> cookie_addr ) ) { ret = - EFAULT ; goto out ; } spin_lock_irqsave ( & rs -> rs_rdma_lock , flags ) ; found = rds_mr_tree_walk ( & rs -> rs_rdma_keys , mr -> r_key , mr ) ; spin_unlock_irqrestore ( & rs -> rs_rdma_lock , flags ) ; BUG_ON ( found && found != mr ) ; rdsdebug ( "RDS: get_mr key is %x\n" , mr -> r_key ) ; if ( mr_ret ) { refcount_inc ( & mr -> r_refcount ) ; * mr_ret = mr ; } ret = 0 ; out : kfree ( pages ) ; if ( mr ) rds_mr_put ( mr ) ; return ret ; }
bool DebugEvaluate :: CallbackHasNoSideEffect ( Object * callback_info ) { DisallowHeapAllocation no_gc ; if ( callback_info -> IsAccessorInfo ( ) ) { AccessorInfo * info = AccessorInfo :: cast ( callback_info ) ; if ( info -> has_no_side_effect ( ) ) return true ; if ( FLAG_trace_side_effect_free_debug_evaluate ) { PrintF ( "[debug-evaluate] API Callback '" ) ; info -> name ( ) -> ShortPrint ( ) ; PrintF ( "' may cause side effect.\n" ) ; } } else if ( callback_info -> IsInterceptorInfo ( ) ) { InterceptorInfo * info = InterceptorInfo :: cast ( callback_info ) ; if ( info -> has_no_side_effect ( ) ) return true ; if ( FLAG_trace_side_effect_free_debug_evaluate ) { PrintF ( "[debug-evaluate] API Interceptor may cause side effect.\n" ) ; } } else if ( callback_info -> IsCallHandlerInfo ( ) ) { CallHandlerInfo * info = CallHandlerInfo :: cast ( callback_info ) ; if ( info -> IsSideEffectFreeCallHandlerInfo ( ) ) return true ; if ( FLAG_trace_side_effect_free_debug_evaluate ) { PrintF ( "[debug-evaluate] API CallHandlerInfo may cause side effect.\n" ) ; } } return false ; }
void Heap :: FinalizeIncrementalMarkingIncrementally ( GarbageCollectionReason gc_reason ) { if ( FLAG_trace_incremental_marking ) { isolate ( ) -> PrintWithTimestamp ( "[IncrementalMarking] (%s).\n" , Heap :: GarbageCollectionReasonToString ( gc_reason ) ) ; } HistogramTimerScope incremental_marking_scope ( isolate ( ) -> counters ( ) -> gc_incremental_marking_finalize ( ) ) ; TRACE_EVENT0 ( "v8" , "V8.GCIncrementalMarkingFinalize" ) ; TRACE_GC ( tracer ( ) , GCTracer :: Scope :: MC_INCREMENTAL_FINALIZE ) ; { GCCallbacksScope scope ( this ) ; if ( scope . CheckReenter ( ) ) { AllowHeapAllocation allow_allocation ; TRACE_GC ( tracer ( ) , GCTracer :: Scope :: MC_INCREMENTAL_EXTERNAL_PROLOGUE ) ; VMState < EXTERNAL > state ( isolate_ ) ; HandleScope handle_scope ( isolate_ ) ; CallGCPrologueCallbacks ( kGCTypeIncrementalMarking , kNoGCCallbackFlags ) ; } } incremental_marking ( ) -> FinalizeIncrementally ( ) ; { GCCallbacksScope scope ( this ) ; if ( scope . CheckReenter ( ) ) { AllowHeapAllocation allow_allocation ; TRACE_GC ( tracer ( ) , GCTracer :: Scope :: MC_INCREMENTAL_EXTERNAL_EPILOGUE ) ; VMState < EXTERNAL > state ( isolate_ ) ; HandleScope handle_scope ( isolate_ ) ; CallGCEpilogueCallbacks ( kGCTypeIncrementalMarking , kNoGCCallbackFlags ) ; } } }
AsmType * AsmJsParser :: AssignmentExpression ( ) { AsmType * ret ; if ( scanner_ . IsGlobal ( ) && GetVarInfo ( scanner_ . Token ( ) ) -> type -> IsA ( AsmType :: Heap ( ) ) ) { RECURSEn ( ret = ConditionalExpression ( ) ) ; if ( Peek ( '=' ) ) { if ( ! inside_heap_assignment_ ) { FAILn ( "Invalid assignment target" ) ; } inside_heap_assignment_ = false ; DCHECK_NOT_NULL ( heap_access_type_ ) ; AsmType * heap_type = heap_access_type_ ; EXPECT_TOKENn ( '=' ) ; AsmType * value ; RECURSEn ( value = AssignmentExpression ( ) ) ; if ( ! value -> IsA ( ret ) ) { FAILn ( "Illegal type stored to heap view" ) ; } if ( heap_type -> IsA ( AsmType :: Float32Array ( ) ) && value -> IsA ( AsmType :: Double ( ) ) ) { current_function_builder_ -> Emit ( kExprF32ConvertF64 ) ; } ret = value ; #define V(array_type, wasmload, wasmstore, type)                         \  if (heap_type->IsA(AsmType::array_type())) {                           \     current_function_builder_->Emit(kExpr##type##AsmjsStore##wasmstore); \  return ret;                                                          \  } STDLIB_ARRAY_TYPE_LIST ( V ) #undef V } } else if ( scanner_ . IsLocal ( ) || scanner_ . IsGlobal ( ) ) { bool is_local = scanner_ . IsLocal ( ) ; VarInfo * info = GetVarInfo ( scanner_ . Token ( ) ) ; USE ( is_local ) ; ret = info -> type ; scanner_ . Next ( ) ; if ( Check ( '=' ) ) { if ( info -> kind == VarKind :: kUnused ) { FAILn ( "Undeclared assignment target" ) ; } if ( ! info -> mutable_variable ) { FAILn ( "Expected mutable variable in assignment" ) ; } DCHECK ( is_local ? info -> kind == VarKind :: kLocal : info -> kind == VarKind :: kGlobal ) ; AsmType * value ; RECURSEn ( value = AssignmentExpression ( ) ) ; if ( ! value -> IsA ( ret ) ) { FAILn ( "Type mismatch in assignment" ) ; } if ( info -> kind == VarKind :: kLocal ) { current_function_builder_ -> EmitTeeLocal ( info -> index ) ; } else if ( info -> kind == VarKind :: kGlobal ) { current_function_builder_ -> EmitWithU32V ( kExprSetGlobal , VarIndex ( info ) ) ; current_function_builder_ -> EmitWithU32V ( kExprGetGlobal , VarIndex ( info ) ) ; } else { UNREACHABLE ( ) ; } return ret ; } scanner_ . Rewind ( ) ; RECURSEn ( ret = ConditionalExpression ( ) ) ; } else { RECURSEn ( ret = ConditionalExpression ( ) ) ; } return ret ; }
static int rds_loop_xmit ( struct rds_connection * conn , struct rds_message * rm , unsigned int hdr_off , unsigned int sg , unsigned int off ) { if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ; return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; } BUG_ON ( hdr_off || sg || off ) ; rds_inc_init ( & rm -> m_inc , conn , conn -> c_laddr ) ; rds_message_addref ( rm ) ; rds_recv_incoming ( conn , conn -> c_laddr , conn -> c_faddr , & rm -> m_inc , GFP_KERNEL , KM_USER0 ) ; rds_send_drop_acked ( conn , be64_to_cpu ( rm -> m_inc . i_hdr . h_sequence ) , NULL ) ; rds_inc_put ( & rm -> m_inc ) ; return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; }
int jas_stream_gobble ( jas_stream_t * stream , int n ) { int m ; m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_getc ( stream ) == EOF ) { return n - m ; } } return n ; }
static FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState * ds ) { int index ; JSUINT32 * escOffset ; JSUINT32 * escStart ; size_t escLen = ( ds -> escEnd - ds -> escStart ) ; JSUINT8 * inputOffset ; JSUTF16 ch = 0 ; JSUINT8 * lastHighSurrogate = NULL ; JSUINT8 oct ; JSUTF32 ucs ; ds -> lastType = JT_INVALID ; ds -> start ++ ; if ( ( size_t ) ( ds -> end - ds -> start ) > escLen ) { size_t newSize = ( ds -> end - ds -> start ) ; if ( ds -> escHeap ) { if ( newSize > ( SIZE_MAX / sizeof ( JSUINT32 ) ) ) { return SetError ( ds , - 1 , "Could not reserve memory block" ) ; } escStart = ( JSUINT32 * ) ds -> dec -> realloc ( ds -> escStart , newSize * sizeof ( JSUINT32 ) ) ; if ( ! escStart ) { ds -> dec -> free ( ds -> escStart ) ; return SetError ( ds , - 1 , "Could not reserve memory block" ) ; } ds -> escStart = escStart ; } else { JSUINT32 * oldStart = ds -> escStart ; if ( newSize > ( SIZE_MAX / sizeof ( JSUINT32 ) ) ) { return SetError ( ds , - 1 , "Could not reserve memory block" ) ; } ds -> escStart = ( JSUINT32 * ) ds -> dec -> malloc ( newSize * sizeof ( JSUINT32 ) ) ; if ( ! ds -> escStart ) { return SetError ( ds , - 1 , "Could not reserve memory block" ) ; } ds -> escHeap = 1 ; memcpy ( ds -> escStart , oldStart , escLen * sizeof ( JSUINT32 ) ) ; } ds -> escEnd = ds -> escStart + newSize ; } escOffset = ds -> escStart ; inputOffset = ( JSUINT8 * ) ds -> start ; for ( ; ; ) { switch ( g_decoderLookup [ ( JSUINT8 ) ( * inputOffset ) ] ) { case DS_ISNULL : { return SetError ( ds , - 1 , "Unmatched '\"' when decoding 'string'" ) ; } case DS_ISQUOTE : { ds -> lastType = JT_UTF8 ; inputOffset ++ ; ds -> start += ( ( char * ) inputOffset - ( ds -> start ) ) ; return ds -> dec -> newString ( ds -> prv , ds -> escStart , escOffset ) ; } case DS_UTFLENERROR : { return SetError ( ds , - 1 , "Invalid UTF-8 sequence length when decoding 'string'" ) ; } case DS_ISESCAPE : { inputOffset ++ ; switch ( * inputOffset ) { case '\\' : * ( escOffset ++ ) = '\\' ; inputOffset ++ ; continue ; case '\"' : * ( escOffset ++ ) = '\"' ; inputOffset ++ ; continue ; case '/' : * ( escOffset ++ ) = '/' ; inputOffset ++ ; continue ; case 'b' : * ( escOffset ++ ) = '\b' ; inputOffset ++ ; continue ; case 'f' : * ( escOffset ++ ) = '\f' ; inputOffset ++ ; continue ; case 'n' : * ( escOffset ++ ) = '\n' ; inputOffset ++ ; continue ; case 'r' : * ( escOffset ++ ) = '\r' ; inputOffset ++ ; continue ; case 't' : * ( escOffset ++ ) = '\t' ; inputOffset ++ ; continue ; case 'u' : { int index ; inputOffset ++ ; for ( index = 0 ; index < 4 ; index ++ ) { switch ( * inputOffset ) { case '\0' : return SetError ( ds , - 1 , "Unterminated unicode escape sequence when decoding 'string'" ) ; default : return SetError ( ds , - 1 , "Unexpected character in unicode escape sequence when decoding 'string'" ) ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : ch = ( ch < < 4 ) + ( JSUTF16 ) ( * inputOffset - '0' ) ; break ; case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : ch = ( ch < < 4 ) + 10 + ( JSUTF16 ) ( * inputOffset - 'a' ) ; break ; case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : ch = ( ch < < 4 ) + 10 + ( JSUTF16 ) ( * inputOffset - 'A' ) ; break ; } inputOffset ++ ; } if ( ( ch & 0xfc00 ) == 0xdc00 && lastHighSurrogate == inputOffset - 6 * sizeof ( * inputOffset ) ) { * ( escOffset - 1 ) = ( ( ( * ( escOffset - 1 ) - 0xd800 ) < < 10 ) | ( ch - 0xdc00 ) ) + 0x10000 ; } else { * ( escOffset ++ ) = ( JSUINT32 ) ch ; } if ( ( ch & 0xfc00 ) == 0xd800 ) { lastHighSurrogate = inputOffset ; } break ; } case '\0' : return SetError ( ds , - 1 , "Unterminated escape sequence when decoding 'string'" ) ; default : return SetError ( ds , - 1 , "Unrecognized escape sequence when decoding 'string'" ) ; } break ; } case 1 : { * ( escOffset ++ ) = ( JSUINT32 ) ( * inputOffset ++ ) ; break ; } case 2 : { ucs = ( * inputOffset ++ ) & 0x1f ; ucs <<= 6 ; if ( ( ( * inputOffset ) & 0x80 ) != 0x80 ) { return SetError ( ds , - 1 , "Invalid octet in UTF-8 sequence when decoding 'string'" ) ; } ucs |= ( * inputOffset ++ ) & 0x3f ; if ( ucs < 0x80 ) return SetError ( ds , - 1 , "Overlong 2 byte UTF-8 sequence detected when decoding 'string'" ) ; * ( escOffset ++ ) = ( JSUINT32 ) ucs ; break ; } case 3 : { JSUTF32 ucs = 0 ; ucs |= ( * inputOffset ++ ) & 0x0f ; for ( index = 0 ; index < 2 ; index ++ ) { ucs <<= 6 ; oct = ( * inputOffset ++ ) ; if ( ( oct & 0x80 ) != 0x80 ) { return SetError ( ds , - 1 , "Invalid octet in UTF-8 sequence when decoding 'string'" ) ; } ucs |= oct & 0x3f ; } if ( ucs < 0x800 ) return SetError ( ds , - 1 , "Overlong 3 byte UTF-8 sequence detected when encoding string" ) ; * ( escOffset ++ ) = ( JSUINT32 ) ucs ; break ; } case 4 : { JSUTF32 ucs = 0 ; ucs |= ( * inputOffset ++ ) & 0x07 ; for ( index = 0 ; index < 3 ; index ++ ) { ucs <<= 6 ; oct = ( * inputOffset ++ ) ; if ( ( oct & 0x80 ) != 0x80 ) { return SetError ( ds , - 1 , "Invalid octet in UTF-8 sequence when decoding 'string'" ) ; } ucs |= oct & 0x3f ; } if ( ucs < 0x10000 ) return SetError ( ds , - 1 , "Overlong 4 byte UTF-8 sequence detected when decoding 'string'" ) ; * ( escOffset ++ ) = ( JSUINT32 ) ucs ; break ; } } } }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; const TfLiteTensor * input1 = GetInput ( context , node , kInputTensor1 ) ; const TfLiteTensor * input2 = GetInput ( context , node , kInputTensor2 ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; switch ( output -> type ) { case kTfLiteInt32 : { TF_LITE_ENSURE_OK ( context , CheckValue ( context , input2 ) ) ; PowImpl < int32_t > ( input1 , input2 , output , data -> requires_broadcast ) ; break ; } case kTfLiteFloat32 : { PowImpl < float > ( input1 , input2 , output , data -> requires_broadcast ) ; break ; } default : { context -> ReportError ( context , "Unsupported data type: %d" , output -> type ) ; return kTfLiteError ; } } return kTfLiteOk ; }
static NFCSTATUS phNciNfc_RecvMfResp ( phNciNfc_Buff_t * RspBuffInfo , NFCSTATUS wStatus ) { NFCSTATUS status = NFCSTATUS_SUCCESS ; uint16_t wPldDataSize = 0 ; phNciNfc_ExtnRespId_t RecvdExtnRspId = phNciNfc_e_InvalidRsp ; if ( NULL == RspBuffInfo ) { status = NFCSTATUS_FAILED ; } else { if ( ( 0 == ( RspBuffInfo -> wLen ) ) || ( PH_NCINFC_STATUS_OK != wStatus ) || ( NULL == ( RspBuffInfo -> pBuff ) ) ) { status = NFCSTATUS_FAILED ; } else { RecvdExtnRspId = ( phNciNfc_ExtnRespId_t ) RspBuffInfo -> pBuff [ 0 ] ; switch ( RecvdExtnRspId ) { case phNciNfc_e_MfXchgDataRsp : { NFCSTATUS writeResponse = NFCSTATUS_SUCCESS ; if ( NFC_GetNCIVersion ( ) == NCI_VERSION_2_0 && ( NdefMap -> State == PH_FRINFC_NDEFMAP_STATE_WR_TLV || NdefMap -> State == PH_FRINFC_NDEFMAP_STATE_WRITE || NdefMap -> State == PH_FRINFC_NDEFMAP_STATE_WR_NDEF_LEN || NdefMap -> State == PH_FRINFC_NDEFMAP_STATE_INIT ) ) { if ( 2 > RspBuffInfo -> wLen ) { android_errorWriteLog ( 0x534e4554 , "181346550" ) ; return NFCSTATUS_FAILED ; } uint8_t rspAck = RspBuffInfo -> pBuff [ RspBuffInfo -> wLen - 2 ] ; uint8_t rspAckMask = ( ( RspBuffInfo -> pBuff [ RspBuffInfo -> wLen - 1 ] ) & MAX_NUM_VALID_BITS_FOR_ACK ) ; NCI_CALCULATE_ACK ( rspAck , rspAckMask ) ; writeResponse = ( rspAck == T2T_RSP_ACK ) ? NFCSTATUS_SUCCESS : NFC_STATUS_FAILED ; } else { writeResponse = RspBuffInfo -> pBuff [ RspBuffInfo -> wLen - 1 ] ; } if ( PH_NCINFC_STATUS_OK == writeResponse ) { status = NFCSTATUS_SUCCESS ; uint16_t wRecvDataSz = 0 ; if ( ( PHNCINFC_EXTNID_SIZE + PHNCINFC_EXTNSTATUS_SIZE ) > RspBuffInfo -> wLen ) { android_errorWriteLog ( 0x534e4554 , "181346550" ) ; return NFCSTATUS_FAILED ; } wPldDataSize = ( ( RspBuffInfo -> wLen ) - ( PHNCINFC_EXTNID_SIZE + PHNCINFC_EXTNSTATUS_SIZE ) ) ; wRecvDataSz = NCI_MAX_DATA_LEN ; if ( ( wPldDataSize ) <= wRecvDataSz ) { memcpy ( NdefMap -> SendRecvBuf , & ( RspBuffInfo -> pBuff [ 1 ] ) , ( wPldDataSize ) ) ; * ( NdefMap -> SendRecvLength ) = wPldDataSize ; } else { status = NFCSTATUS_FAILED ; } } else { status = NFCSTATUS_FAILED ; } } break ; case phNciNfc_e_MfcAuthRsp : { if ( PH_NCINFC_STATUS_OK == RspBuffInfo -> pBuff [ 1 ] ) { if ( gAuthCmdBuf . auth_sent == true ) { MfcPresenceCheckResult ( NFCSTATUS_SUCCESS ) ; return NFCSTATUS_SUCCESS ; } gAuthCmdBuf . auth_status = true ; status = NFCSTATUS_SUCCESS ; wPldDataSize = ( ( RspBuffInfo -> wLen ) - ( PHNCINFC_EXTNID_SIZE + PHNCINFC_EXTNSTATUS_SIZE ) ) ; memcpy ( NdefMap -> SendRecvBuf , & ( RspBuffInfo -> pBuff [ 2 ] ) , wPldDataSize ) ; * ( NdefMap -> SendRecvLength ) = wPldDataSize ; } else { if ( gAuthCmdBuf . auth_sent == true ) { gAuthCmdBuf . auth_status = false ; MfcPresenceCheckResult ( NFCSTATUS_FAILED ) ; return NFCSTATUS_SUCCESS ; } else { memset ( gAuthCmdBuf . pauth_cmd -> buffer , 0 , NCI_MAX_DATA_LEN ) ; gAuthCmdBuf . pauth_cmd -> length = 0 ; gAuthCmdBuf . auth_status = false ; } status = NFCSTATUS_FAILED ; } } break ; default : { status = NFCSTATUS_FAILED ; } break ; } } } return status ; }
cib_send_tls ( gnutls_session * session , xmlNode * msg ) { char * xml_text = NULL ; #  if 0 const char * name = crm_element_name ( msg ) ; if ( safe_str_neq ( name , "cib_command" ) ) { xmlNodeSetName ( msg , "cib_result" ) ; } #  endif xml_text = dump_xml_unformatted ( msg ) ; if ( xml_text != NULL ) { char * unsent = xml_text ; int len = strlen ( xml_text ) ; int rc = 0 ; len ++ ; crm_trace ( "Message size: %d" , len ) ; while ( TRUE ) { rc = gnutls_record_send ( * session , unsent , len ) ; crm_debug ( "Sent %d bytes" , rc ) ; if ( rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN ) { crm_debug ( "Retry" ) ; } else if ( rc < 0 ) { crm_debug ( "Connection terminated" ) ; break ; } else if ( rc < len ) { crm_debug ( "Only sent %d of %d bytes" , rc , len ) ; len -= rc ; unsent += rc ; } else { break ; } } } free ( xml_text ) ; return NULL ; }
SkCodec :: Result SkSampledCodec :: onGetAndroidPixels ( const SkImageInfo & info , void * pixels , size_t rowBytes , const AndroidOptions & options ) { SkCodec :: Options codecOptions ; codecOptions . fZeroInitialized = options . fZeroInitialized ; codecOptions . fPremulBehavior = SkTransferFunctionBehavior :: kIgnore ; SkIRect * subset = options . fSubset ; if ( ! subset || subset -> size ( ) == this -> codec ( ) -> getInfo ( ) . dimensions ( ) ) { if ( this -> codec ( ) -> dimensionsSupported ( info . dimensions ( ) ) ) { return this -> codec ( ) -> getPixels ( info , pixels , rowBytes , & codecOptions ) ; } return this -> sampledDecode ( info , pixels , rowBytes , options ) ; } int sampleSize = options . fSampleSize ; SkISize scaledSize = this -> getSampledDimensions ( sampleSize ) ; if ( ! this -> codec ( ) -> dimensionsSupported ( scaledSize ) ) { return this -> sampledDecode ( info , pixels , rowBytes , options ) ; } int scaledSubsetX = subset -> x ( ) / sampleSize ; int scaledSubsetY = subset -> y ( ) / sampleSize ; int scaledSubsetWidth = info . width ( ) ; int scaledSubsetHeight = info . height ( ) ; const SkImageInfo scaledInfo = info . makeWH ( scaledSize . width ( ) , scaledSize . height ( ) ) ; { SkIRect incrementalSubset = SkIRect :: MakeXYWH ( scaledSubsetX , scaledSubsetY , scaledSubsetWidth , scaledSubsetHeight ) ; codecOptions . fSubset = & incrementalSubset ; const SkCodec :: Result startResult = this -> codec ( ) -> startIncrementalDecode ( scaledInfo , pixels , rowBytes , & codecOptions ) ; if ( SkCodec :: kSuccess == startResult ) { int rowsDecoded ; const SkCodec :: Result incResult = this -> codec ( ) -> incrementalDecode ( & rowsDecoded ) ; if ( incResult == SkCodec :: kSuccess ) { return SkCodec :: kSuccess ; } SkASSERT ( SkCodec :: kIncompleteInput == incResult ) ; this -> codec ( ) -> fillIncompleteImage ( scaledInfo , pixels , rowBytes , options . fZeroInitialized , scaledSubsetHeight , rowsDecoded ) ; return SkCodec :: kIncompleteInput ; } else if ( startResult != SkCodec :: kUnimplemented ) { return startResult ; } } SkIRect scanlineSubset = SkIRect :: MakeXYWH ( scaledSubsetX , 0 , scaledSubsetWidth , scaledSize . height ( ) ) ; codecOptions . fSubset = & scanlineSubset ; SkCodec :: Result result = this -> codec ( ) -> startScanlineDecode ( scaledInfo , & codecOptions ) ; if ( SkCodec :: kSuccess != result ) { return result ; } SkASSERT ( this -> codec ( ) -> getScanlineOrder ( ) == SkCodec :: kTopDown_SkScanlineOrder ) ; if ( ! this -> codec ( ) -> skipScanlines ( scaledSubsetY ) ) { this -> codec ( ) -> fillIncompleteImage ( info , pixels , rowBytes , options . fZeroInitialized , scaledSubsetHeight , 0 ) ; return SkCodec :: kIncompleteInput ; } int decodedLines = this -> codec ( ) -> getScanlines ( pixels , scaledSubsetHeight , rowBytes ) ; if ( decodedLines != scaledSubsetHeight ) { return SkCodec :: kIncompleteInput ; } return SkCodec :: kSuccess ; }
fun_finalize ( JSContext * cx , JSObject * obj ) { JSFunction * fun = ( JSFunction * ) obj -> getPrivate ( ) ; if ( ! fun ) return ; if ( fun != obj ) { if ( FUN_FLAT_CLOSURE ( fun ) && fun -> u . i . nupvars != 0 ) cx -> free ( ( void * ) obj -> getFlatClosureUpvars ( ) ) ; return ; } if ( FUN_INTERPRETED ( fun ) && fun -> u . i . script ) js_DestroyScript ( cx , fun -> u . i . script ) ; }
Type OperationTyper :: NumberAdd ( Type lhs , Type rhs ) { DCHECK ( lhs . Is ( Type :: Number ( ) ) ) ; DCHECK ( rhs . Is ( Type :: Number ( ) ) ) ; if ( lhs . IsNone ( ) || rhs . IsNone ( ) ) return Type :: None ( ) ; bool maybe_nan = lhs . Maybe ( Type :: NaN ( ) ) || rhs . Maybe ( Type :: NaN ( ) ) ; bool maybe_minuszero = true ; if ( lhs . Maybe ( Type :: MinusZero ( ) ) ) { lhs = Type :: Union ( lhs , cache_ . kSingletonZero , zone ( ) ) ; } else { maybe_minuszero = false ; } if ( rhs . Maybe ( Type :: MinusZero ( ) ) ) { rhs = Type :: Union ( rhs , cache_ . kSingletonZero , zone ( ) ) ; } else { maybe_minuszero = false ; } Type type = Type :: None ( ) ; lhs = Type :: Intersect ( lhs , Type :: PlainNumber ( ) , zone ( ) ) ; rhs = Type :: Intersect ( rhs , Type :: PlainNumber ( ) , zone ( ) ) ; if ( ! lhs . IsNone ( ) && ! rhs . IsNone ( ) ) { if ( lhs . Is ( cache_ . kInteger ) && rhs . Is ( cache_ . kInteger ) ) { type = AddRanger ( lhs . Min ( ) , lhs . Max ( ) , rhs . Min ( ) , rhs . Max ( ) ) ; } else { if ( ( lhs . Maybe ( minus_infinity_ ) && rhs . Maybe ( infinity_ ) ) || ( rhs . Maybe ( minus_infinity_ ) && lhs . Maybe ( infinity_ ) ) ) { maybe_nan = true ; } type = Type :: PlainNumber ( ) ; } } if ( maybe_minuszero ) type = Type :: Union ( type , Type :: MinusZero ( ) , zone ( ) ) ; if ( maybe_nan ) type = Type :: Union ( type , Type :: NaN ( ) , zone ( ) ) ; return type ; }
void RunMemCheck ( ) { ACMRandom rnd ( ACMRandom :: DeterministicSeed ( ) ) ; const int count_test_block = 5000 ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , input_block , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , input_extreme_block , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , output_ref_block , kNumCoeffs ) ; DECLARE_ALIGNED_ARRAY ( 16 , int16_t , output_block , kNumCoeffs ) ; for ( int i = 0 ; i < count_test_block ; ++ i ) { for ( int j = 0 ; j < kNumCoeffs ; ++ j ) { input_block [ j ] = rnd . Rand8 ( ) - rnd . Rand8 ( ) ; input_extreme_block [ j ] = rnd . Rand8 ( ) % 2 ? 255 : - 255 ; } if ( i == 0 ) for ( int j = 0 ; j < kNumCoeffs ; ++ j ) input_extreme_block [ j ] = 255 ; if ( i == 1 ) for ( int j = 0 ; j < kNumCoeffs ; ++ j ) input_extreme_block [ j ] = - 255 ; fwd_txfm_ref ( input_extreme_block , output_ref_block , pitch_ , tx_type_ ) ; REGISTER_STATE_CHECK ( RunFwdTxfm ( input_extreme_block , output_block , pitch_ ) ) ; for ( int j = 0 ; j < kNumCoeffs ; ++ j ) { EXPECT_EQ ( output_block [ j ] , output_ref_block [ j ] ) ; EXPECT_GE ( 4 * DCT_MAX_VALUE , abs ( output_block [ j ] ) ) < < "Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE" ; } } }
js :: TryConvertToUnboxedLayout ( ExclusiveContext * cx , Shape * templateShape , ObjectGroup * group , PreliminaryObjectArray * objects ) { bool isArray = ! templateShape ; if ( isArray ) { #ifdef NIGHTLY_BUILD if ( ! getenv ( "JS_OPTION_USE_UNBOXED_ARRAYS" ) ) { if ( ! cx -> options ( ) . unboxedArrays ( ) ) return true ; } #else return true ; #endif } else { if ( jit :: JitOptions . disableUnboxedObjects ) return true ; } MOZ_ASSERT_IF ( templateShape , ! templateShape -> getObjectFlags ( ) ) ; if ( group -> runtimeFromAnyThread ( ) -> isSelfHostingGlobal ( cx -> global ( ) ) ) return true ; if ( ! isArray && templateShape -> slotSpan ( ) == 0 ) return true ; UnboxedLayout :: PropertyVector properties ; if ( ! isArray ) { if ( ! properties . appendN ( UnboxedLayout :: Property ( ) , templateShape -> slotSpan ( ) ) ) return false ; } JSValueType elementType = JSVAL_TYPE_MAGIC ; size_t objectCount = 0 ; for ( size_t i = 0 ; i < PreliminaryObjectArray :: COUNT ; i ++ ) { JSObject * obj = objects -> get ( i ) ; if ( ! obj ) continue ; if ( obj -> isSingleton ( ) || obj -> group ( ) != group ) return true ; objectCount ++ ; if ( isArray ) { if ( ! CombineArrayObjectElements ( cx , & obj -> as < ArrayObject > ( ) , & elementType ) ) return true ; } else { if ( ! CombinePlainObjectProperties ( & obj -> as < PlainObject > ( ) , templateShape , properties ) ) return true ; } } size_t layoutSize = 0 ; if ( isArray ) { if ( UnboxedTypeSize ( elementType ) == 0 ) return true ; } else { if ( objectCount <= 1 ) { return true ; } for ( size_t i = 0 ; i < templateShape -> slotSpan ( ) ; i ++ ) { if ( UnboxedTypeSize ( properties [ i ] . type ) == 0 ) return true ; } for ( Shape :: Range < NoGC > r ( templateShape ) ; ! r . empty ( ) ; r . popFront ( ) ) { jsid id = r . front ( ) . propid ( ) ; uint32_t dummy ; if ( ! JSID_IS_ATOM ( id ) || JSID_TO_ATOM ( id ) -> isIndex ( & dummy ) ) return true ; } layoutSize = ComputePlainObjectLayout ( cx , templateShape , properties ) ; if ( UnboxedPlainObject :: offsetOfData ( ) + layoutSize > JSObject :: MAX_BYTE_SIZE ) return true ; } AutoInitGCManagedObject < UnboxedLayout > layout ( group -> zone ( ) -> make_unique < UnboxedLayout > ( ) ) ; if ( ! layout ) return false ; if ( isArray ) { layout -> initArray ( elementType ) ; } else { if ( ! layout -> initProperties ( properties , layoutSize ) ) return false ; cx -> compartment ( ) -> unboxedLayouts . insertFront ( layout . get ( ) ) ; if ( ! SetLayoutTraceList ( cx , layout . get ( ) ) ) return false ; } const Class * clasp = isArray ? & UnboxedArrayObject :: class_ : & UnboxedPlainObject :: class_ ; Shape * newShape = EmptyShape :: getInitialShape ( cx , clasp , group -> proto ( ) , 0 ) ; if ( ! newShape ) { cx -> recoverFromOutOfMemory ( ) ; return false ; } Rooted < GCVector < Value > > values ( cx , GCVector < Value > ( cx ) ) ; for ( size_t i = 0 ; i < PreliminaryObjectArray :: COUNT ; i ++ ) { JSObject * obj = objects -> get ( i ) ; if ( ! obj ) continue ; bool ok ; if ( isArray ) ok = GetValuesFromPreliminaryArrayObject ( & obj -> as < ArrayObject > ( ) , & values ) ; else ok = GetValuesFromPreliminaryPlainObject ( & obj -> as < PlainObject > ( ) , & values ) ; if ( ! ok ) { cx -> recoverFromOutOfMemory ( ) ; return false ; } } if ( TypeNewScript * newScript = group -> newScript ( ) ) layout -> setNewScript ( newScript ) ; for ( size_t i = 0 ; i < PreliminaryObjectArray :: COUNT ; i ++ ) { if ( JSObject * obj = objects -> get ( i ) ) obj -> as < NativeObject > ( ) . setLastPropertyMakeNonNative ( newShape ) ; } group -> setClasp ( clasp ) ; group -> setUnboxedLayout ( layout . release ( ) ) ; size_t valueCursor = 0 ; for ( size_t i = 0 ; i < PreliminaryObjectArray :: COUNT ; i ++ ) { JSObject * obj = objects -> get ( i ) ; if ( ! obj ) continue ; if ( isArray ) obj -> as < UnboxedArrayObject > ( ) . fillAfterConvert ( cx , values , & valueCursor ) ; else obj -> as < UnboxedPlainObject > ( ) . fillAfterConvert ( cx , values , & valueCursor ) ; } MOZ_ASSERT ( valueCursor == values . length ( ) ) ; layout . release ( ) ; return true ; }
SharedFunctionInfoData ( JSHeapBroker * broker_ , Handle < SharedFunctionInfo > object_ , HeapObjectType type_ ) : HeapObjectData ( broker_ , object_ , type_ ) , builtin_id ( object_ -> HasBuiltinId ( ) ? object_ -> builtin_id ( ) : Builtins :: kNoBuiltinId ) , GetBytecodeArray ( object_ -> HasBytecodeArray ( ) ? GET_OR_CREATE ( GetBytecodeArray ) -> AsBytecodeArray ( ) : nullptr ) #define INIT_MEMBER(type, name) , name(object_->name()) BROKER_SFI_FIELDS ( INIT_MEMBER ) #undef INIT_MEMBER { DCHECK_EQ ( HasBuiltinId , builtin_id != Builtins :: kNoBuiltinId ) ; DCHECK_EQ ( HasBytecodeArray , GetBytecodeArray != nullptr ) ; }
ConvertIndex ( FallibleTArray < Index :: Indice > & aDest , const stagefright :: Vector < stagefright :: MediaSource :: Indice > & aIndex , int64_t aMediaTime ) { if ( ! aDest . SetCapacity ( aIndex . size ( ) , mozilla :: fallible ) ) { return false ; } for ( size_t i = 0 ; i < aIndex . size ( ) ; i ++ ) { Index :: Indice indice ; const stagefright :: MediaSource :: Indice & s_indice = aIndex [ i ] ; indice . start_offset = s_indice . start_offset ; indice . end_offset = s_indice . end_offset ; indice . start_composition = s_indice . start_composition - aMediaTime ; indice . end_composition = s_indice . end_composition - aMediaTime ; indice . sync = s_indice . sync ; MOZ_ALWAYS_TRUE ( aDest . AppendElement ( indice , mozilla :: fallible ) ) ; } return true ; }
void __init trap_init ( void ) { int i ; #ifdef CONFIG_EISA void __iomem * p = early_ioremap ( 0x0FFFD9 , 4 ) ; if ( readl ( p ) == 'E' + ( 'I' < < 8 ) + ( 'S' < < 16 ) + ( 'A' < < 24 ) ) EISA_bus = 1 ; early_iounmap ( p , 4 ) ; #endif set_intr_gate ( X86_TRAP_DE , divide_error ) ; set_intr_gate_ist ( X86_TRAP_NMI , & nmi , NMI_STACK ) ; set_system_intr_gate ( X86_TRAP_OF , & overflow ) ; set_intr_gate ( X86_TRAP_BR , bounds ) ; set_intr_gate ( X86_TRAP_UD , invalid_op ) ; set_intr_gate ( X86_TRAP_NM , device_not_available ) ; #ifdef CONFIG_X86_32 set_task_gate ( X86_TRAP_DF , GDT_ENTRY_DOUBLEFAULT_TSS ) ; #else set_intr_gate_ist ( X86_TRAP_DF , & double_fault , DOUBLEFAULT_STACK ) ; #endif set_intr_gate ( X86_TRAP_OLD_MF , coprocessor_segment_overrun ) ; set_intr_gate ( X86_TRAP_TS , invalid_TSS ) ; set_intr_gate ( X86_TRAP_NP , segment_not_present ) ; set_intr_gate_ist ( X86_TRAP_SS , & stack_segment , STACKFAULT_STACK ) ; set_intr_gate ( X86_TRAP_GP , general_protection ) ; set_intr_gate ( X86_TRAP_SPURIOUS , spurious_interrupt_bug ) ; set_intr_gate ( X86_TRAP_MF , coprocessor_error ) ; set_intr_gate ( X86_TRAP_AC , alignment_check ) ; #ifdef CONFIG_X86_MCE set_intr_gate_ist ( X86_TRAP_MC , & machine_check , MCE_STACK ) ; #endif set_intr_gate ( X86_TRAP_XF , simd_coprocessor_error ) ; for ( i = 0 ; i < FIRST_EXTERNAL_VECTOR ; i ++ ) set_bit ( i , used_vectors ) ; #ifdef CONFIG_IA32_EMULATION set_system_intr_gate ( IA32_SYSCALL_VECTOR , ia32_syscall ) ; set_bit ( IA32_SYSCALL_VECTOR , used_vectors ) ; #endif #ifdef CONFIG_X86_32 set_system_trap_gate ( SYSCALL_VECTOR , & system_call ) ; set_bit ( SYSCALL_VECTOR , used_vectors ) ; #endif __set_fixmap ( FIX_RO_IDT , __pa_symbol ( idt_table ) , PAGE_KERNEL_RO ) ; idt_descr . address = fix_to_virt ( FIX_RO_IDT ) ; cpu_init ( ) ; x86_init . irqs . trap_init ( ) ; #ifdef CONFIG_X86_64 memcpy ( & debug_idt_table , & idt_table , IDT_ENTRIES * 16 ) ; set_nmi_gate ( X86_TRAP_DB , & debug ) ; set_nmi_gate ( X86_TRAP_BP , & int3 ) ; #endif }
void Messageheader :: Parser :: checkHeaderspace ( unsigned chars ) const { if ( headerdataPtr + chars >= header . rawdata + sizeof ( header . rawdata ) ) throw HttpError ( HTTP_REQUEST_ENTITY_TOO_LARGE , "header too large" ) ; }
void nsDisplayList :: HitTest ( nsDisplayListBuilder * aBuilder , const nsRect & aRect , nsDisplayItem :: HitTestState * aState , nsTArray < nsIFrame * > * aOutFrames ) const { nsDisplayItem * item ; if ( aState -> mInPreserves3D ) { for ( item = GetBottom ( ) ; item ; item = item -> GetAbove ( ) ) { auto itemType = item -> GetType ( ) ; if ( itemType != nsDisplayItem :: TYPE_TRANSFORM || ! static_cast < nsDisplayTransform * > ( item ) -> IsLeafOf3DContext ( ) ) { item -> HitTest ( aBuilder , aRect , aState , aOutFrames ) ; } else { aState -> mItemBuffer . AppendElement ( item ) ; } } return ; } int32_t itemBufferStart = aState -> mItemBuffer . Length ( ) ; for ( item = GetBottom ( ) ; item ; item = item -> GetAbove ( ) ) { aState -> mItemBuffer . AppendElement ( item ) ; } AutoTArray < FramesWithDepth , 16 > temp ; for ( int32_t i = aState -> mItemBuffer . Length ( ) - 1 ; i >= itemBufferStart ; -- i ) { item = aState -> mItemBuffer [ i ] ; aState -> mItemBuffer . SetLength ( i ) ; bool snap ; nsRect r = item -> GetBounds ( aBuilder , & snap ) . Intersect ( aRect ) ; auto itemType = item -> GetType ( ) ; bool same3DContext = ( itemType == nsDisplayItem :: TYPE_TRANSFORM && static_cast < nsDisplayTransform * > ( item ) -> IsParticipating3DContext ( ) ) || ( ( itemType == nsDisplayItem :: TYPE_PERSPECTIVE || itemType == nsDisplayItem :: TYPE_OPACITY ) && static_cast < nsDisplayPerspective * > ( item ) -> Frame ( ) -> Extend3DContext ( ) ) ; if ( same3DContext && ! static_cast < nsDisplayTransform * > ( item ) -> IsLeafOf3DContext ( ) ) { if ( ! item -> GetClip ( ) . MayIntersect ( aRect ) ) { continue ; } AutoTArray < nsIFrame * , 1 > neverUsed ; aState -> mInPreserves3D = true ; item -> HitTest ( aBuilder , aRect , aState , & neverUsed ) ; aState -> mInPreserves3D = false ; i = aState -> mItemBuffer . Length ( ) ; continue ; } if ( same3DContext || item -> GetClip ( ) . MayIntersect ( r ) ) { AutoTArray < nsIFrame * , 16 > outFrames ; item -> HitTest ( aBuilder , aRect , aState , & outFrames ) ; nsTArray < nsIFrame * > * writeFrames = aOutFrames ; if ( item -> GetType ( ) == nsDisplayItem :: TYPE_TRANSFORM && static_cast < nsDisplayTransform * > ( item ) -> IsLeafOf3DContext ( ) ) { if ( outFrames . Length ( ) ) { nsDisplayTransform * transform = static_cast < nsDisplayTransform * > ( item ) ; nsPoint point = aRect . TopLeft ( ) ; if ( aRect . width != 1 || aRect . height != 1 ) { point = aRect . Center ( ) ; } temp . AppendElement ( FramesWithDepth ( transform -> GetHitDepthAtPoint ( aBuilder , point ) ) ) ; writeFrames = & temp [ temp . Length ( ) - 1 ] . mFrames ; } } else { FlushFramesArray ( temp , aOutFrames ) ; } for ( uint32_t j = 0 ; j < outFrames . Length ( ) ; j ++ ) { nsIFrame * f = outFrames . ElementAt ( j ) ; if ( ! GetMouseThrough ( f ) && IsFrameReceivingPointerEvents ( f ) ) { writeFrames -> AppendElement ( f ) ; } } } } FlushFramesArray ( temp , aOutFrames ) ; NS_ASSERTION ( aState -> mItemBuffer . Length ( ) == uint32_t ( itemBufferStart ) , "How did we forget to pop some elements?" ) ; }
void nsGfxScrollFrameInner :: CurPosAttributeChanged ( nsIContent * aContent ) { NS_ASSERTION ( aContent , "aContent must not be null" ) ; NS_ASSERTION ( ( mHScrollbarBox && mHScrollbarBox -> GetContent ( ) == aContent ) || ( mVScrollbarBox && mVScrollbarBox -> GetContent ( ) == aContent ) , "unexpected child" ) ; if ( mFrameIsUpdatingScrollbar ) return ; nsRect scrolledRect = GetScrolledRect ( ) ; nsPoint current = GetScrollPosition ( ) - scrolledRect . TopLeft ( ) ; nsPoint dest ; nsRect allowedRange ; dest . x = GetCoordAttribute ( mHScrollbarBox , nsGkAtoms :: curpos , current . x , & allowedRange . x , & allowedRange . width ) ; dest . y = GetCoordAttribute ( mVScrollbarBox , nsGkAtoms :: curpos , current . y , & allowedRange . y , & allowedRange . height ) ; current += scrolledRect . TopLeft ( ) ; dest += scrolledRect . TopLeft ( ) ; allowedRange += scrolledRect . TopLeft ( ) ; if ( allowedRange . ClampPoint ( current ) == current ) { return ; } if ( mScrollbarActivity ) { nsRefPtr < ScrollbarActivity > scrollbarActivity ( mScrollbarActivity ) ; scrollbarActivity -> ActivityOccurred ( ) ; } bool isSmooth = aContent -> HasAttr ( kNameSpaceID_None , nsGkAtoms :: smooth ) ; if ( isSmooth ) { UpdateScrollbarPosition ( ) ; } ScrollToWithOrigin ( dest , isSmooth ? nsIScrollableFrame :: SMOOTH : nsIScrollableFrame :: INSTANT , nsGkAtoms :: scrollbars , & allowedRange ) ; }
SourceDataCache :: purge ( ) { if ( ! map_ ) return ; for ( Map :: Range r = map_ -> all ( ) ; ! r . empty ( ) ; r . popFront ( ) ) js_delete ( const_cast < jschar * > ( r . front ( ) . value ) ) ; js_delete ( map_ ) ; map_ = nullptr ; }
pci_emul_dinit ( struct vmctx * ctx , struct pci_vdev * dev , char * opts ) { int error ; struct pci_emul_dummy * dummy ; dummy = calloc ( 1 , sizeof ( struct pci_emul_dummy ) ) ; dev -> arg = dummy ; pci_set_cfgdata16 ( dev , PCIR_DEVICE , 0x0001 ) ; pci_set_cfgdata16 ( dev , PCIR_VENDOR , 0x10DD ) ; pci_set_cfgdata8 ( dev , PCIR_CLASS , 0x02 ) ; error = pci_emul_add_msicap ( dev , PCI_EMUL_MSI_MSGS ) ; assert ( error == 0 ) ; error = pci_emul_alloc_bar ( dev , 0 , PCIBAR_IO , DIOSZ ) ; assert ( error == 0 ) ; error = pci_emul_alloc_bar ( dev , 1 , PCIBAR_MEM32 , DMEMSZ ) ; assert ( error == 0 ) ; error = pci_emul_alloc_bar ( dev , 2 , PCIBAR_MEM32 , DMEMSZ ) ; assert ( error == 0 ) ; return 0 ; }
Node * PromiseBuiltinsAssembler :: NewPromiseCapability ( Node * context , Node * constructor , Node * debug_event ) { if ( debug_event == nullptr ) { debug_event = TrueConstant ( ) ; } Node * native_context = LoadNativeContext ( context ) ; Node * map = LoadRoot ( Heap :: kJSPromiseCapabilityMapRootIndex ) ; Node * capability = AllocateJSObjectFromMap ( map ) ; StoreObjectFieldNoWriteBarrier ( capability , JSPromiseCapability :: kPromiseOffset , UndefinedConstant ( ) ) ; StoreObjectFieldNoWriteBarrier ( capability , JSPromiseCapability :: kResolveOffset , UndefinedConstant ( ) ) ; StoreObjectFieldNoWriteBarrier ( capability , JSPromiseCapability :: kRejectOffset , UndefinedConstant ( ) ) ; Variable var_result ( this , MachineRepresentation :: kTagged ) ; var_result . Bind ( capability ) ; Label if_builtin_promise ( this ) , if_custom_promise ( this , Label :: kDeferred ) , out ( this ) ; Branch ( WordEqual ( constructor , LoadContextElement ( native_context , Context :: PROMISE_FUNCTION_INDEX ) ) , & if_builtin_promise , & if_custom_promise ) ; Bind ( & if_builtin_promise ) ; { Node * promise = AllocateJSPromise ( context ) ; PromiseInit ( promise ) ; StoreObjectFieldNoWriteBarrier ( capability , JSPromiseCapability :: kPromiseOffset , promise ) ; Node * resolve = nullptr ; Node * reject = nullptr ; std :: tie ( resolve , reject ) = CreatePromiseResolvingFunctions ( promise , debug_event , native_context ) ; StoreObjectField ( capability , JSPromiseCapability :: kResolveOffset , resolve ) ; StoreObjectField ( capability , JSPromiseCapability :: kRejectOffset , reject ) ; GotoIfNot ( IsPromiseHookEnabledOrDebugIsActive ( ) , & out ) ; CallRuntime ( Runtime :: kPromiseHookInit , context , promise , UndefinedConstant ( ) ) ; Goto ( & out ) ; } Bind ( & if_custom_promise ) ; { Label if_notcallable ( this , Label :: kDeferred ) ; Node * executor_context = CreatePromiseGetCapabilitiesExecutorContext ( capability , native_context ) ; Node * executor_info = LoadContextElement ( native_context , Context :: PROMISE_GET_CAPABILITIES_EXECUTOR_SHARED_FUN ) ; Node * function_map = LoadContextElement ( native_context , Context :: STRICT_FUNCTION_WITHOUT_PROTOTYPE_MAP_INDEX ) ; Node * executor = AllocateFunctionWithMapAndContext ( function_map , executor_info , executor_context ) ; Node * promise = ConstructJS ( CodeFactory :: Construct ( isolate ( ) ) , context , constructor , executor ) ; Node * resolve = LoadObjectField ( capability , JSPromiseCapability :: kResolveOffset ) ; GotoIf ( TaggedIsSmi ( resolve ) , & if_notcallable ) ; GotoIfNot ( IsCallableMap ( LoadMap ( resolve ) ) , & if_notcallable ) ; Node * reject = LoadObjectField ( capability , JSPromiseCapability :: kRejectOffset ) ; GotoIf ( TaggedIsSmi ( reject ) , & if_notcallable ) ; GotoIfNot ( IsCallableMap ( LoadMap ( reject ) ) , & if_notcallable ) ; StoreObjectField ( capability , JSPromiseCapability :: kPromiseOffset , promise ) ; Goto ( & out ) ; Bind ( & if_notcallable ) ; Node * message = SmiConstant ( MessageTemplate :: kPromiseNonCallable ) ; StoreObjectField ( capability , JSPromiseCapability :: kPromiseOffset , UndefinedConstant ( ) ) ; StoreObjectField ( capability , JSPromiseCapability :: kResolveOffset , UndefinedConstant ( ) ) ; StoreObjectField ( capability , JSPromiseCapability :: kRejectOffset , UndefinedConstant ( ) ) ; CallRuntime ( Runtime :: kThrowTypeError , context , message ) ; Unreachable ( ) ; } Bind ( & out ) ; return var_result . value ( ) ; }
TF_BUILTIN ( ArrayIncludes , ArrayIncludesIndexofAssembler ) { TNode < IntPtrT > argc = ChangeInt32ToIntPtr ( Parameter ( Descriptor :: kJSActualArgumentsCount ) ) ; TNode < Context > context = CAST ( Parameter ( Descriptor :: kContext ) ) ; Generate ( kIncludes , argc , context ) ; }
mrb_remove_method ( mrb_state * mrb , struct RClass * c , mrb_sym mid ) { mt_tbl * h ; MRB_CLASS_ORIGIN ( c ) ; h = c -> mt ; if ( h && mt_del ( mrb , h , mid ) ) return ; mrb_name_error ( mrb , mid , "method '%n' not defined in %C" , mid , c ) ; }
nsGlobalChromeWindow :: GetMessageManager ( nsIMessageBroadcaster * * aManager ) { FORWARD_TO_INNER_CHROME ( GetMessageManager , ( aManager ) , NS_ERROR_FAILURE ) ; if ( ! mMessageManager ) { nsIScriptContext * scx = GetContextInternal ( ) ; NS_ENSURE_STATE ( scx ) ; JSContext * cx = scx -> GetNativeContext ( ) ; NS_ENSURE_STATE ( cx ) ; nsCOMPtr < nsIMessageBroadcaster > globalMM = do_GetService ( "@mozilla.org/globalmessagemanager;1" ) ; mMessageManager = new nsFrameMessageManager ( nullptr , static_cast < nsFrameMessageManager * > ( globalMM . get ( ) ) , cx , MM_CHROME | MM_BROADCASTER ) ; NS_ENSURE_TRUE ( mMessageManager , NS_ERROR_OUT_OF_MEMORY ) ; } CallQueryInterface ( mMessageManager , aManager ) ; return NS_OK ; }
nsDocumentViewer :: InitPresentationStuff ( bool aDoInitialReflow ) { if ( GetIsPrintPreview ( ) ) return NS_OK ; NS_ASSERTION ( ! mPresShell , "Someone should have destroyed the presshell!" ) ; StyleSetHandle styleSet = CreateStyleSet ( mDocument ) ; mPresShell = mDocument -> CreateShell ( mPresContext , mViewManager , styleSet ) ; if ( ! mPresShell ) { styleSet -> Delete ( ) ; return NS_ERROR_FAILURE ; } styleSet -> EndUpdate ( ) ; if ( aDoInitialReflow ) { mDocument -> FlushPendingNotifications ( FlushType :: ContentAndNotify ) ; } mPresShell -> BeginObservingDocument ( ) ; int32_t p2a = mPresContext -> AppUnitsPerDevPixel ( ) ; MOZ_ASSERT ( p2a == mPresContext -> DeviceContext ( ) -> AppUnitsPerDevPixelAtUnitFullZoom ( ) ) ; nscoord width = p2a * mBounds . width ; nscoord height = p2a * mBounds . height ; mViewManager -> SetWindowDimensions ( width , height ) ; mPresContext -> SetTextZoom ( mTextZoom ) ; mPresContext -> SetFullZoom ( mPageZoom ) ; mPresContext -> SetOverrideDPPX ( mOverrideDPPX ) ; mPresContext -> SetBaseMinFontSize ( mMinFontSize ) ; p2a = mPresContext -> AppUnitsPerDevPixel ( ) ; width = p2a * mBounds . width ; height = p2a * mBounds . height ; if ( aDoInitialReflow ) { nsCOMPtr < nsIPresShell > shell = mPresShell ; shell -> Initialize ( width , height ) ; } else { mPresContext -> SetVisibleArea ( nsRect ( 0 , 0 , width , height ) ) ; } if ( ! mSelectionListener ) { nsDocViewerSelectionListener * selectionListener = new nsDocViewerSelectionListener ( ) ; selectionListener -> Init ( this ) ; mSelectionListener = selectionListener ; } RefPtr < mozilla :: dom :: Selection > selection = GetDocumentSelection ( ) ; if ( ! selection ) { return NS_ERROR_FAILURE ; } nsresult rv = selection -> AddSelectionListener ( mSelectionListener ) ; if ( NS_FAILED ( rv ) ) return rv ; RefPtr < nsDocViewerFocusListener > oldFocusListener = mFocusListener ; nsDocViewerFocusListener * focusListener = new nsDocViewerFocusListener ( ) ; focusListener -> Init ( this ) ; mFocusListener = focusListener ; if ( mDocument ) { mDocument -> AddEventListener ( NS_LITERAL_STRING ( "focus" ) , mFocusListener , false , false ) ; mDocument -> AddEventListener ( NS_LITERAL_STRING ( "blur" ) , mFocusListener , false , false ) ; if ( oldFocusListener ) { mDocument -> RemoveEventListener ( NS_LITERAL_STRING ( "focus" ) , oldFocusListener , false ) ; mDocument -> RemoveEventListener ( NS_LITERAL_STRING ( "blur" ) , oldFocusListener , false ) ; } } if ( aDoInitialReflow && mDocument ) { mDocument -> ScrollToRef ( ) ; } return NS_OK ; }
png_handle_pHYs ( png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) { png_byte buf [ 9 ] ; png_uint_32 res_x , res_y ; int unit_type ; png_debug ( 1 , "in png_handle_pHYs" ) ; if ( ! ( png_ptr -> mode & PNG_HAVE_IHDR ) ) png_chunk_error ( png_ptr , "missing IHDR" ) ; else if ( png_ptr -> mode & PNG_HAVE_IDAT ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "out of place" ) ; return ; } else if ( info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_pHYs ) ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "duplicate" ) ; return ; } if ( length != 9 ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "invalid" ) ; return ; } png_crc_read ( png_ptr , buf , 9 ) ; if ( png_crc_finish ( png_ptr , 0 ) ) return ; res_x = png_get_uint_32 ( buf ) ; res_y = png_get_uint_32 ( buf + 4 ) ; unit_type = buf [ 8 ] ; png_set_pHYs ( png_ptr , info_ptr , res_x , res_y , unit_type ) ; }
ScriptExecutorRunnable :: ShutdownScriptLoader ( JSContext * aCx , WorkerPrivate * aWorkerPrivate , bool aResult ) { MOZ_ASSERT ( mLastIndex == mScriptLoader . mLoadInfos . Length ( ) - 1 ) ; if ( mIsWorkerScript && aWorkerPrivate -> IsServiceWorker ( ) ) { aWorkerPrivate -> SetLoadingWorkerScript ( false ) ; } aWorkerPrivate -> RemoveFeature ( aCx , & mScriptLoader ) ; aWorkerPrivate -> StopSyncLoop ( mSyncLoopTarget , aResult ) ; }
const Operator * CommonOperatorBuilder :: PointerConstant ( intptr_t value ) { return new ( zone ( ) ) Operator1 < intptr_t > ( IrOpcode :: kPointerConstant , Operator :: kPure , "PointerConstant" , 0 , 0 , 0 , 1 , 0 , 0 , value ) ; }
YCbCrImageDataDeserializerBase :: ComputeMinBufferSize ( const gfx :: IntSize & aYSize , uint32_t aYStride , const gfx :: IntSize & aCbCrSize , uint32_t aCbCrStride ) { return ComputeOffset ( aYSize . height , aYStride ) + 2 * ComputeOffset ( aCbCrSize . height , aCbCrStride ) + MOZ_ALIGN_WORD ( sizeof ( YCbCrBufferInfo ) ) ; }
BUILTIN ( ObjectGetOwnPropertyDescriptors ) { HandleScope scope ( isolate ) ; Handle < Object > object = args . atOrUndefined ( isolate , 1 ) ; Handle < JSReceiver > receiver ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , receiver , Object :: ToObject ( isolate , object ) ) ; Handle < FixedArray > keys ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , keys , KeyAccumulator :: GetKeys ( receiver , KeyCollectionMode :: kOwnOnly , ALL_PROPERTIES , GetKeysConversion :: kConvertToString ) ) ; Handle < JSObject > descriptors = isolate -> factory ( ) -> NewJSObject ( isolate -> object_function ( ) ) ; for ( int i = 0 ; i < keys -> length ( ) ; ++ i ) { Handle < Name > key = Handle < Name > :: cast ( FixedArray :: get ( * keys , i , isolate ) ) ; PropertyDescriptor descriptor ; Maybe < bool > did_get_descriptor = JSReceiver :: GetOwnPropertyDescriptor ( isolate , receiver , key , & descriptor ) ; MAYBE_RETURN ( did_get_descriptor , ReadOnlyRoots ( isolate ) . exception ( ) ) ; if ( ! did_get_descriptor . FromJust ( ) ) continue ; Handle < Object > from_descriptor = descriptor . ToObject ( isolate ) ; Maybe < bool > success = JSReceiver :: CreateDataProperty ( isolate , descriptors , key , from_descriptor , kDontThrow ) ; CHECK ( success . FromJust ( ) ) ; } return * descriptors ; }
Navigator :: SendBeacon ( const nsAString & aUrl , const Nullable < ArrayBufferViewOrBlobOrStringOrFormData > & aData , ErrorResult & aRv ) { if ( ! mWindow ) { aRv . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return false ; } nsCOMPtr < nsIDocument > doc = mWindow -> GetDoc ( ) ; if ( ! doc ) { aRv . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return false ; } nsIURI * documentURI = doc -> GetDocumentURI ( ) ; if ( ! documentURI ) { aRv . Throw ( NS_ERROR_DOM_INVALID_STATE_ERR ) ; return false ; } nsCOMPtr < nsIURI > uri ; nsresult rv = nsContentUtils :: NewURIWithDocumentCharset ( getter_AddRefs ( uri ) , aUrl , doc , doc -> GetDocBaseURI ( ) ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_DOM_URL_MISMATCH_ERR ) ; return false ; } nsCOMPtr < nsIPrincipal > principal = doc -> NodePrincipal ( ) ; nsCOMPtr < nsIScriptSecurityManager > secMan = nsContentUtils :: GetSecurityManager ( ) ; uint32_t flags = nsIScriptSecurityManager :: DISALLOW_INHERIT_PRINCIPAL & nsIScriptSecurityManager :: DISALLOW_SCRIPT ; rv = secMan -> CheckLoadURIWithPrincipal ( principal , uri , flags ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( rv ) ; return false ; } int16_t shouldLoad = nsIContentPolicy :: ACCEPT ; rv = NS_CheckContentLoadPolicy ( nsIContentPolicy :: TYPE_BEACON , uri , principal , doc , EmptyCString ( ) , nullptr , & shouldLoad , nsContentUtils :: GetContentPolicy ( ) , nsContentUtils :: GetSecurityManager ( ) ) ; if ( NS_FAILED ( rv ) || NS_CP_REJECTED ( shouldLoad ) ) { aRv . Throw ( NS_ERROR_CONTENT_BLOCKED ) ; return false ; } nsCOMPtr < nsIChannel > channel ; rv = NS_NewChannel ( getter_AddRefs ( channel ) , uri , doc , nsILoadInfo :: SEC_NORMAL , nsIContentPolicy :: TYPE_BEACON ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( rv ) ; return false ; } nsCOMPtr < nsIPrivateBrowsingChannel > pbChannel = do_QueryInterface ( channel ) ; if ( pbChannel ) { nsIDocShell * docShell = mWindow -> GetDocShell ( ) ; nsCOMPtr < nsILoadContext > loadContext = do_QueryInterface ( docShell ) ; if ( loadContext ) { rv = pbChannel -> SetPrivate ( loadContext -> UsePrivateBrowsing ( ) ) ; if ( NS_FAILED ( rv ) ) { NS_WARNING ( "Setting the privacy status on the beacon channel failed" ) ; } } } nsCOMPtr < nsIHttpChannel > httpChannel = do_QueryInterface ( channel ) ; if ( ! httpChannel ) { aRv . Throw ( NS_ERROR_DOM_BAD_URI ) ; return false ; } httpChannel -> SetReferrer ( documentURI ) ; nsCOMPtr < nsIHttpChannelInternal > httpChannelInternal ( do_QueryInterface ( channel ) ) ; nsCOMPtr < mozIThirdPartyUtil > thirdPartyUtil = do_GetService ( THIRDPARTYUTIL_CONTRACTID ) ; if ( ! httpChannelInternal ) { aRv . Throw ( NS_ERROR_DOM_BAD_URI ) ; return false ; } bool isForeign = true ; thirdPartyUtil -> IsThirdPartyWindow ( mWindow , uri , & isForeign ) ; uint32_t thirdPartyFlags = isForeign ? 0 : nsIHttpChannelInternal :: THIRD_PARTY_FORCE_ALLOW ; httpChannelInternal -> SetThirdPartyFlags ( thirdPartyFlags ) ; nsCString mimeType ; if ( ! aData . IsNull ( ) ) { nsCOMPtr < nsIInputStream > in ; if ( aData . Value ( ) . IsString ( ) ) { nsCString stringData = NS_ConvertUTF16toUTF8 ( aData . Value ( ) . GetAsString ( ) ) ; nsCOMPtr < nsIStringInputStream > strStream = do_CreateInstance ( NS_STRINGINPUTSTREAM_CONTRACTID , & rv ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } rv = strStream -> SetData ( stringData . BeginReading ( ) , stringData . Length ( ) ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } mimeType . AssignLiteral ( "text/plain;charset=UTF-8" ) ; in = strStream ; } else if ( aData . Value ( ) . IsArrayBufferView ( ) ) { nsCOMPtr < nsIStringInputStream > strStream = do_CreateInstance ( NS_STRINGINPUTSTREAM_CONTRACTID , & rv ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } const ArrayBufferView & view = aData . Value ( ) . GetAsArrayBufferView ( ) ; view . ComputeLengthAndData ( ) ; rv = strStream -> SetData ( reinterpret_cast < char * > ( view . Data ( ) ) , view . Length ( ) ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } mimeType . AssignLiteral ( "application/octet-stream" ) ; in = strStream ; } else if ( aData . Value ( ) . IsBlob ( ) ) { File & blob = aData . Value ( ) . GetAsBlob ( ) ; rv = blob . GetInternalStream ( getter_AddRefs ( in ) ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } nsAutoString type ; rv = blob . GetType ( type ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } mimeType = NS_ConvertUTF16toUTF8 ( type ) ; } else if ( aData . Value ( ) . IsFormData ( ) ) { nsFormData & form = aData . Value ( ) . GetAsFormData ( ) ; uint64_t len ; nsAutoCString charset ; form . GetSendInfo ( getter_AddRefs ( in ) , & len , mimeType , charset ) ; } else { MOZ_ASSERT ( false , "switch statements not in sync" ) ; aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } nsCOMPtr < nsIUploadChannel2 > uploadChannel = do_QueryInterface ( channel ) ; if ( ! uploadChannel ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return false ; } uploadChannel -> ExplicitSetUploadStream ( in , mimeType , - 1 , NS_LITERAL_CSTRING ( "POST" ) , false ) ; } else { httpChannel -> SetRequestMethod ( NS_LITERAL_CSTRING ( "POST" ) ) ; } nsCOMPtr < nsISupportsPriority > p = do_QueryInterface ( channel ) ; if ( p ) { p -> SetPriority ( nsISupportsPriority :: PRIORITY_LOWEST ) ; } nsCOMPtr < nsIClassOfService > cos ( do_QueryInterface ( channel ) ) ; if ( cos ) { cos -> AddClassFlags ( nsIClassOfService :: Background ) ; } nsRefPtr < nsCORSListenerProxy > cors = new nsCORSListenerProxy ( new BeaconStreamListener ( ) , principal , true ) ; rv = secMan -> CheckSameOriginURI ( documentURI , uri , false ) ; bool crossOrigin = NS_FAILED ( rv ) ; nsAutoCString contentType , parsedCharset ; rv = NS_ParseContentType ( mimeType , contentType , parsedCharset ) ; if ( crossOrigin && contentType . Length ( ) > 0 && ! contentType . Equals ( APPLICATION_WWW_FORM_URLENCODED ) && ! contentType . Equals ( MULTIPART_FORM_DATA ) && ! contentType . Equals ( TEXT_PLAIN ) ) { nsCOMPtr < nsIChannel > preflightChannel ; nsTArray < nsCString > unsafeHeaders ; unsafeHeaders . AppendElement ( NS_LITERAL_CSTRING ( "Content-Type" ) ) ; rv = NS_StartCORSPreflight ( channel , cors , principal , true , unsafeHeaders , getter_AddRefs ( preflightChannel ) ) ; } else { rv = channel -> AsyncOpen ( cors , nullptr ) ; } if ( NS_FAILED ( rv ) ) { aRv . Throw ( rv ) ; return false ; } return true ; }
xmlXPathCompOpEvalLast ( xmlXPathParserContextPtr ctxt , xmlXPathStepOpPtr op , xmlNodePtr * last ) { int total = 0 , cur ; xmlXPathCompExprPtr comp ; xmlXPathObjectPtr arg1 , arg2 ; xmlNodePtr bak ; xmlDocPtr bakd ; int pp ; int cs ; CHECK_ERROR0 ; comp = ctxt -> comp ; switch ( op -> op ) { case XPATH_OP_END : return ( 0 ) ; case XPATH_OP_UNION : bakd = ctxt -> context -> doc ; bak = ctxt -> context -> node ; pp = ctxt -> context -> proximityPosition ; cs = ctxt -> context -> contextSize ; total = xmlXPathCompOpEvalLast ( ctxt , & comp -> steps [ op -> ch1 ] , last ) ; CHECK_ERROR0 ; if ( ( ctxt -> value != NULL ) && ( ctxt -> value -> type == XPATH_NODESET ) && ( ctxt -> value -> nodesetval != NULL ) && ( ctxt -> value -> nodesetval -> nodeNr >= 1 ) ) { if ( ctxt -> value -> nodesetval -> nodeNr > 1 ) xmlXPathNodeSetSort ( ctxt -> value -> nodesetval ) ; * last = ctxt -> value -> nodesetval -> nodeTab [ ctxt -> value -> nodesetval -> nodeNr - 1 ] ; } ctxt -> context -> doc = bakd ; ctxt -> context -> node = bak ; ctxt -> context -> proximityPosition = pp ; ctxt -> context -> contextSize = cs ; cur = xmlXPathCompOpEvalLast ( ctxt , & comp -> steps [ op -> ch2 ] , last ) ; CHECK_ERROR0 ; if ( ( ctxt -> value != NULL ) && ( ctxt -> value -> type == XPATH_NODESET ) && ( ctxt -> value -> nodesetval != NULL ) && ( ctxt -> value -> nodesetval -> nodeNr >= 1 ) ) { } CHECK_TYPE0 ( XPATH_NODESET ) ; arg2 = valuePop ( ctxt ) ; CHECK_TYPE0 ( XPATH_NODESET ) ; arg1 = valuePop ( ctxt ) ; arg1 -> nodesetval = xmlXPathNodeSetMerge ( arg1 -> nodesetval , arg2 -> nodesetval ) ; valuePush ( ctxt , arg1 ) ; xmlXPathReleaseObject ( ctxt -> context , arg2 ) ; if ( total > cur ) xmlXPathCompSwap ( op ) ; return ( total + cur ) ; case XPATH_OP_ROOT : xmlXPathRoot ( ctxt ) ; return ( 0 ) ; case XPATH_OP_NODE : if ( op -> ch1 != - 1 ) total += xmlXPathCompOpEval ( ctxt , & comp -> steps [ op -> ch1 ] ) ; CHECK_ERROR0 ; if ( op -> ch2 != - 1 ) total += xmlXPathCompOpEval ( ctxt , & comp -> steps [ op -> ch2 ] ) ; CHECK_ERROR0 ; valuePush ( ctxt , xmlXPathCacheNewNodeSet ( ctxt -> context , ctxt -> context -> node ) ) ; return ( total ) ; case XPATH_OP_RESET : if ( op -> ch1 != - 1 ) total += xmlXPathCompOpEval ( ctxt , & comp -> steps [ op -> ch1 ] ) ; CHECK_ERROR0 ; if ( op -> ch2 != - 1 ) total += xmlXPathCompOpEval ( ctxt , & comp -> steps [ op -> ch2 ] ) ; CHECK_ERROR0 ; ctxt -> context -> node = NULL ; return ( total ) ; case XPATH_OP_COLLECT : { if ( op -> ch1 == - 1 ) return ( 0 ) ; total += xmlXPathCompOpEval ( ctxt , & comp -> steps [ op -> ch1 ] ) ; CHECK_ERROR0 ; total += xmlXPathNodeCollectAndTest ( ctxt , op , NULL , last , 0 ) ; return ( total ) ; } case XPATH_OP_VALUE : valuePush ( ctxt , xmlXPathCacheObjectCopy ( ctxt -> context , ( xmlXPathObjectPtr ) op -> value4 ) ) ; return ( 0 ) ; case XPATH_OP_SORT : if ( op -> ch1 != - 1 ) total += xmlXPathCompOpEvalLast ( ctxt , & comp -> steps [ op -> ch1 ] , last ) ; CHECK_ERROR0 ; if ( ( ctxt -> value != NULL ) && ( ctxt -> value -> type == XPATH_NODESET ) && ( ctxt -> value -> nodesetval != NULL ) && ( ctxt -> value -> nodesetval -> nodeNr > 1 ) ) xmlXPathNodeSetSort ( ctxt -> value -> nodesetval ) ; return ( total ) ; default : return ( xmlXPathCompOpEval ( ctxt , op ) ) ; } }
static void get_over ( struct SYMBOL * s ) { struct VOICE_S * p_voice , * p_voice2 , * p_voice3 ; int range , voice , voice2 , voice3 ; static char tx_wrong_dur [ ] = "Wrong duration in voice overlay" ; static char txt_no_note [ ] = "No note in voice overlay" ; p_voice = curvoice ; if ( p_voice -> ignore ) return ; if ( s -> abc_type == ABC_T_BAR || s -> u . v_over . type == V_OVER_E ) { if ( ! p_voice -> last_sym ) { error ( 1 , s , txt_no_note ) ; return ; } p_voice -> last_sym -> sflags |= S_BEAM_END ; over_bar = 0 ; if ( over_time < 0 ) { error ( 1 , s , "Erroneous end of voice overlap" ) ; return ; } if ( p_voice -> time != over_mxtime ) error ( 1 , s , tx_wrong_dur ) ; curvoice = & voice_tb [ over_voice ] ; over_mxtime = 0 ; over_voice = - 1 ; over_time = - 1 ; return ; } if ( s -> u . v_over . type == V_OVER_S ) { over_voice = p_voice - voice_tb ; over_time = p_voice -> time ; return ; } if ( ! p_voice -> last_sym ) { error ( 1 , s , txt_no_note ) ; return ; } p_voice -> last_sym -> sflags |= S_BEAM_END ; voice2 = s -> u . v_over . voice ; p_voice2 = & voice_tb [ voice2 ] ; if ( parsys -> voice [ voice2 ] . range < 0 ) { int clone ; if ( cfmt . abc2pscompat ) { error ( 1 , s , "Cannot have %%%%abc2pscompat" ) ; cfmt . abc2pscompat = 0 ; } clone = p_voice -> clone >= 0 ; p_voice2 -> id [ 0 ] = '&' ; p_voice2 -> id [ 1 ] = '\0' ; p_voice2 -> second = 1 ; parsys -> voice [ voice2 ] . second = 1 ; p_voice2 -> scale = p_voice -> scale ; p_voice2 -> octave = p_voice -> octave ; p_voice2 -> transpose = p_voice -> transpose ; memcpy ( & p_voice2 -> key , & p_voice -> key , sizeof p_voice2 -> key ) ; memcpy ( & p_voice2 -> ckey , & p_voice -> ckey , sizeof p_voice2 -> ckey ) ; memcpy ( & p_voice2 -> okey , & p_voice -> okey , sizeof p_voice2 -> okey ) ; p_voice2 -> posit = p_voice -> posit ; p_voice2 -> staff = p_voice -> staff ; p_voice2 -> cstaff = p_voice -> cstaff ; p_voice2 -> color = p_voice -> color ; p_voice2 -> map_name = p_voice -> map_name ; range = parsys -> voice [ p_voice - voice_tb ] . range ; for ( voice = 0 ; voice < MAXVOICE ; voice ++ ) { if ( parsys -> voice [ voice ] . range > range ) parsys -> voice [ voice ] . range += clone + 1 ; } parsys -> voice [ voice2 ] . range = range + 1 ; voice_link ( p_voice2 ) ; if ( clone ) { for ( voice3 = MAXVOICE ; -- voice3 >= 0 ; ) { if ( parsys -> voice [ voice3 ] . range < 0 ) break ; } if ( voice3 > 0 ) { p_voice3 = & voice_tb [ voice3 ] ; strcpy ( p_voice3 -> id , p_voice2 -> id ) ; p_voice3 -> second = 1 ; parsys -> voice [ voice3 ] . second = 1 ; p_voice3 -> scale = voice_tb [ p_voice -> clone ] . scale ; parsys -> voice [ voice3 ] . range = range + 2 ; voice_link ( p_voice3 ) ; p_voice2 -> clone = voice3 ; } else { error ( 1 , s , "Too many voices for overlay cloning" ) ; } } } voice = p_voice - voice_tb ; if ( over_time < 0 ) { int time ; over_bar = 1 ; over_mxtime = p_voice -> time ; over_voice = voice ; time = p_voice2 -> time ; for ( s = p_voice -> last_sym ; ; s = s -> prev ) { if ( s -> type == BAR || s -> time <= time ) break ; } over_time = s -> time ; } else { if ( over_mxtime == 0 ) over_mxtime = p_voice -> time ; else if ( p_voice -> time != over_mxtime ) error ( 1 , s , tx_wrong_dur ) ; } p_voice2 -> time = over_time ; curvoice = p_voice2 ; }
FindReplaceLength ( JSContext * cx , RegExpStatics * res , ReplaceData & rdata , size_t * sizep ) { RootedObject base ( cx , rdata . elembase ) ; if ( base ) { JS_ASSERT ( rdata . lambda ) ; JS_ASSERT ( ! base -> getOps ( ) -> lookupProperty ) ; JS_ASSERT ( ! base -> getOps ( ) -> getProperty ) ; Value match ; if ( ! res -> createLastMatch ( cx , & match ) ) return false ; JSString * str = match . toString ( ) ; JSAtom * atom ; if ( str -> isAtom ( ) ) { atom = & str -> asAtom ( ) ; } else { atom = AtomizeString ( cx , str ) ; if ( ! atom ) return false ; } Value v ; if ( HasDataProperty ( cx , base , AtomToId ( atom ) , & v ) && v . isString ( ) ) { rdata . repstr = v . toString ( ) -> ensureLinear ( cx ) ; if ( ! rdata . repstr ) return false ; * sizep = rdata . repstr -> length ( ) ; return true ; } rdata . elembase = NULL ; } if ( JSObject * lambda = rdata . lambda ) { PreserveRegExpStatics staticsGuard ( cx , res ) ; if ( ! staticsGuard . init ( cx ) ) return false ; unsigned p = res -> parenCount ( ) ; unsigned argc = 1 + p + 2 ; InvokeArgsGuard & args = rdata . fig . args ( ) ; if ( ! args . pushed ( ) && ! cx -> stack . pushInvokeArgs ( cx , argc , & args ) ) return false ; args . setCallee ( ObjectValue ( * lambda ) ) ; args . setThis ( UndefinedValue ( ) ) ; unsigned argi = 0 ; if ( ! res -> createLastMatch ( cx , & args [ argi ++ ] ) ) return false ; for ( size_t i = 0 ; i < res -> parenCount ( ) ; ++ i ) { if ( ! res -> createParen ( cx , i + 1 , & args [ argi ++ ] ) ) return false ; } args [ argi ++ ] . setInt32 ( res -> matchStart ( ) ) ; args [ argi ] . setString ( rdata . str ) ; if ( ! rdata . fig . invoke ( cx ) ) return false ; JSString * repstr = ToString ( cx , args . rval ( ) ) ; if ( ! repstr ) return false ; rdata . repstr = repstr -> ensureLinear ( cx ) ; if ( ! rdata . repstr ) return false ; * sizep = rdata . repstr -> length ( ) ; return true ; } JSString * repstr = rdata . repstr ; size_t replen = repstr -> length ( ) ; for ( const jschar * dp = rdata . dollar , * ep = rdata . dollarEnd ; dp ; dp = js_strchr_limit ( dp , '$' , ep ) ) { JSSubString sub ; size_t skip ; if ( InterpretDollar ( res , dp , ep , rdata , & sub , & skip ) ) { replen += sub . length - skip ; dp += skip ; } else { dp ++ ; } } * sizep = replen ; return true ; }
TF_BUILTIN ( RegExpConstructor , RegExpBuiltinsAssembler ) { TNode < Object > pattern = CAST ( Parameter ( Descriptor :: kPattern ) ) ; TNode < Object > flags = CAST ( Parameter ( Descriptor :: kFlags ) ) ; TNode < Object > new_target = CAST ( Parameter ( Descriptor :: kJSNewTarget ) ) ; TNode < Context > context = CAST ( Parameter ( Descriptor :: kContext ) ) ; Isolate * isolate = this -> isolate ( ) ; VARIABLE ( var_flags , MachineRepresentation :: kTagged , flags ) ; VARIABLE ( var_pattern , MachineRepresentation :: kTagged , pattern ) ; VARIABLE ( var_new_target , MachineRepresentation :: kTagged , new_target ) ; Node * const native_context = LoadNativeContext ( context ) ; Node * const regexp_function = LoadContextElement ( native_context , Context :: REGEXP_FUNCTION_INDEX ) ; Node * const pattern_is_regexp = IsRegExp ( context , pattern ) ; { Label next ( this ) ; GotoIfNot ( IsUndefined ( new_target ) , & next ) ; var_new_target . Bind ( regexp_function ) ; GotoIfNot ( pattern_is_regexp , & next ) ; GotoIfNot ( IsUndefined ( flags ) , & next ) ; Node * const value = GetProperty ( context , pattern , isolate -> factory ( ) -> constructor_string ( ) ) ; GotoIfNot ( WordEqual ( value , regexp_function ) , & next ) ; Return ( pattern ) ; BIND ( & next ) ; } { Label next ( this ) , if_patternisfastregexp ( this ) , if_patternisslowregexp ( this ) ; GotoIf ( TaggedIsSmi ( pattern ) , & next ) ; GotoIf ( IsJSRegExp ( CAST ( pattern ) ) , & if_patternisfastregexp ) ; Branch ( pattern_is_regexp , & if_patternisslowregexp , & next ) ; BIND ( & if_patternisfastregexp ) ; { Node * const source = LoadObjectField ( CAST ( pattern ) , JSRegExp :: kSourceOffset ) ; var_pattern . Bind ( source ) ; { Label inner_next ( this ) ; GotoIfNot ( IsUndefined ( flags ) , & inner_next ) ; Node * const value = FlagsGetter ( context , pattern , true ) ; var_flags . Bind ( value ) ; Goto ( & inner_next ) ; BIND ( & inner_next ) ; } Goto ( & next ) ; } BIND ( & if_patternisslowregexp ) ; { { Node * const value = GetProperty ( context , pattern , isolate -> factory ( ) -> source_string ( ) ) ; var_pattern . Bind ( value ) ; } { Label inner_next ( this ) ; GotoIfNot ( IsUndefined ( flags ) , & inner_next ) ; Node * const value = GetProperty ( context , pattern , isolate -> factory ( ) -> flags_string ( ) ) ; var_flags . Bind ( value ) ; Goto ( & inner_next ) ; BIND ( & inner_next ) ; } Goto ( & next ) ; } BIND ( & next ) ; } VARIABLE ( var_regexp , MachineRepresentation :: kTagged ) ; { Label allocate_jsregexp ( this ) , allocate_generic ( this , Label :: kDeferred ) , next ( this ) ; Branch ( WordEqual ( var_new_target . value ( ) , regexp_function ) , & allocate_jsregexp , & allocate_generic ) ; BIND ( & allocate_jsregexp ) ; { Node * const initial_map = LoadObjectField ( regexp_function , JSFunction :: kPrototypeOrInitialMapOffset ) ; Node * const regexp = AllocateJSObjectFromMap ( initial_map ) ; var_regexp . Bind ( regexp ) ; Goto ( & next ) ; } BIND ( & allocate_generic ) ; { ConstructorBuiltinsAssembler constructor_assembler ( this -> state ( ) ) ; Node * const regexp = constructor_assembler . EmitFastNewObject ( context , regexp_function , var_new_target . value ( ) ) ; var_regexp . Bind ( regexp ) ; Goto ( & next ) ; } BIND ( & next ) ; } Node * const result = RegExpInitialize ( context , var_regexp . value ( ) , var_pattern . value ( ) , var_flags . value ( ) ) ; Return ( result ) ; }
int _belle_sip_dialog_match ( belle_sip_dialog_t * obj , const char * call_id , const char * local_tag , const char * remote_tag ) { const char * dcid ; dcid = belle_sip_header_call_id_get_call_id ( obj -> call_id ) ; return strcmp ( dcid , call_id ) == 0 && strcmp ( obj -> local_tag , local_tag ) == 0 && obj -> remote_tag && remote_tag && strcmp ( obj -> remote_tag , remote_tag ) == 0 ; }
static inline int round_biased_to_int ( SkScalar x , SkScalar bias ) { double xx = x ; xx += 0.5 + bias ; return ( int ) floor ( xx ) ; }
int visualizer_command ( effect_context_t * context , uint32_t cmdCode , uint32_t cmdSize __unused , void * pCmdData __unused , uint32_t * replySize , void * pReplyData ) { visualizer_context_t * visu_ctxt = ( visualizer_context_t * ) context ; switch ( cmdCode ) { case VISUALIZER_CMD_CAPTURE : if ( pReplyData == NULL || * replySize != visu_ctxt -> capture_size ) { ALOGV ( "%s VISUALIZER_CMD_CAPTURE error *replySize %d context->capture_size %d" , __func__ , * replySize , visu_ctxt -> capture_size ) ; return - EINVAL ; } if ( ! context -> offload_enabled ) break ; if ( context -> state == EFFECT_STATE_ACTIVE ) { int32_t latency_ms = visu_ctxt -> latency ; const uint32_t delta_ms = visualizer_get_delta_time_ms_from_updated_time ( visu_ctxt ) ; latency_ms -= delta_ms ; if ( latency_ms < 0 ) { latency_ms = 0 ; } const uint32_t delta_smp = context -> config . inputCfg . samplingRate * latency_ms / 1000 ; int32_t capture_point = visu_ctxt -> capture_idx - visu_ctxt -> capture_size - delta_smp ; int32_t capture_size = visu_ctxt -> capture_size ; if ( capture_point < 0 ) { int32_t size = - capture_point ; if ( size > capture_size ) size = capture_size ; memcpy ( pReplyData , visu_ctxt -> capture_buf + CAPTURE_BUF_SIZE + capture_point , size ) ; pReplyData = ( void * ) ( ( size_t ) pReplyData + size ) ; capture_size -= size ; capture_point = 0 ; } memcpy ( pReplyData , visu_ctxt -> capture_buf + capture_point , capture_size ) ; if ( ( visu_ctxt -> last_capture_idx == visu_ctxt -> capture_idx ) && ( visu_ctxt -> buffer_update_time . tv_sec != 0 ) ) { if ( delta_ms > MAX_STALL_TIME_MS ) { ALOGV ( "%s capture going to idle" , __func__ ) ; visu_ctxt -> buffer_update_time . tv_sec = 0 ; memset ( pReplyData , 0x80 , visu_ctxt -> capture_size ) ; } } visu_ctxt -> last_capture_idx = visu_ctxt -> capture_idx ; } else { memset ( pReplyData , 0x80 , visu_ctxt -> capture_size ) ; } break ; case VISUALIZER_CMD_MEASURE : { uint16_t peak_u16 = 0 ; float sum_rms_squared = 0.0f ; uint8_t nb_valid_meas = 0 ; const int32_t delay_ms = visualizer_get_delta_time_ms_from_updated_time ( visu_ctxt ) ; if ( delay_ms > DISCARD_MEASUREMENTS_TIME_MS ) { uint32_t i ; ALOGV ( "Discarding measurements, last measurement is %dms old" , delay_ms ) ; for ( i = 0 ; i < visu_ctxt -> meas_wndw_size_in_buffers ; i ++ ) { visu_ctxt -> past_meas [ i ] . is_valid = false ; visu_ctxt -> past_meas [ i ] . peak_u16 = 0 ; visu_ctxt -> past_meas [ i ] . rms_squared = 0 ; } visu_ctxt -> meas_buffer_idx = 0 ; } else { uint32_t i ; for ( i = 0 ; i < visu_ctxt -> meas_wndw_size_in_buffers ; i ++ ) { if ( visu_ctxt -> past_meas [ i ] . is_valid ) { if ( visu_ctxt -> past_meas [ i ] . peak_u16 > peak_u16 ) { peak_u16 = visu_ctxt -> past_meas [ i ] . peak_u16 ; } sum_rms_squared += visu_ctxt -> past_meas [ i ] . rms_squared ; nb_valid_meas ++ ; } } } float rms = nb_valid_meas == 0 ? 0.0f : sqrtf ( sum_rms_squared / nb_valid_meas ) ; int32_t * p_int_reply_data = ( int32_t * ) pReplyData ; if ( rms < 0.000016f ) { p_int_reply_data [ MEASUREMENT_IDX_RMS ] = - 9600 ; } else { p_int_reply_data [ MEASUREMENT_IDX_RMS ] = ( int32_t ) ( 2000 * log10 ( rms / 32767.0f ) ) ; } if ( peak_u16 == 0 ) { p_int_reply_data [ MEASUREMENT_IDX_PEAK ] = - 9600 ; } else { p_int_reply_data [ MEASUREMENT_IDX_PEAK ] = ( int32_t ) ( 2000 * log10 ( peak_u16 / 32767.0f ) ) ; } ALOGV ( "VISUALIZER_CMD_MEASURE peak=%d (%dmB), rms=%.1f (%dmB)" , peak_u16 , p_int_reply_data [ MEASUREMENT_IDX_PEAK ] , rms , p_int_reply_data [ MEASUREMENT_IDX_RMS ] ) ; } break ; default : ALOGW ( "%s invalid command %d" , __func__ , cmdCode ) ; return - EINVAL ; } return 0 ; }
Return < Status > CasImpl :: processEmm ( const HidlCasData & emm ) { ALOGV ( "%s" , __FUNCTION__ ) ; sp < PluginHolder > holder = mPluginHolder ; if ( holder == NULL ) { return toStatus ( INVALID_OPERATION ) ; } return toStatus ( holder -> get ( ) -> processEmm ( emm ) ) ; }
void AstRawString :: Internalize ( Isolate * isolate ) { DCHECK ( ! has_string_ ) ; if ( literal_bytes_ . length ( ) == 0 ) { set_string ( isolate -> factory ( ) -> empty_string ( ) ) ; } else { AstRawStringInternalizationKey key ( this ) ; set_string ( StringTable :: LookupKey ( isolate , & key ) ) ; } }
static void write_frame_size ( const VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ; vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ; write_display_size ( cm , wb ) ; }
WasmTableObject :: setImpl ( JSContext * cx , const CallArgs & args ) { RootedWasmTableObject tableObj ( cx , & args . thisv ( ) . toObject ( ) . as < WasmTableObject > ( ) ) ; Table & table = tableObj -> table ( ) ; if ( ! args . requireAtLeast ( cx , "set" , 2 ) ) return false ; uint32_t index ; if ( ! EnforceRangeU32 ( cx , args . get ( 0 ) , table . length ( ) - 1 , "Table" , "set index" , & index ) ) return false ; RootedFunction value ( cx ) ; if ( ! IsExportedFunction ( args [ 1 ] , & value ) && ! args [ 1 ] . isNull ( ) ) { JS_ReportErrorNumberUTF8 ( cx , GetErrorMessage , nullptr , JSMSG_WASM_BAD_TABLE_VALUE ) ; return false ; } if ( value ) { RootedWasmInstanceObject instanceObj ( cx , ExportedFunctionToInstanceObject ( value ) ) ; uint32_t funcIndex = ExportedFunctionToFuncIndex ( value ) ; #ifdef DEBUG RootedFunction f ( cx ) ; MOZ_ASSERT ( instanceObj -> getExportedFunction ( cx , instanceObj , funcIndex , & f ) ) ; MOZ_ASSERT ( value == f ) ; #endif Instance & instance = instanceObj -> instance ( ) ; Tier tier = instance . code ( ) . bestTier ( ) ; const FuncExport & funcExport = instance . metadata ( tier ) . lookupFuncExport ( funcIndex ) ; const CodeRange & codeRange = instance . metadata ( tier ) . codeRanges [ funcExport . codeRangeIndex ( ) ] ; void * code = instance . codeBase ( tier ) + codeRange . funcTableEntry ( ) ; table . set ( index , code , instance ) ; } else { table . setNull ( index ) ; } args . rval ( ) . setUndefined ( ) ; return true ; }
js :: jit :: AllocateExecutableMemory ( void * addr , size_t bytes , unsigned permissions , const char * tag , size_t pageSize ) { MOZ_ASSERT ( bytes % pageSize == 0 ) ; #ifdef HAVE_64BIT_BUILD if ( sJitExceptionHandler ) bytes += pageSize ; #endif void * p = VirtualAlloc ( addr , bytes , MEM_COMMIT | MEM_RESERVE , permissions ) ; if ( ! p ) return nullptr ; #ifdef HAVE_64BIT_BUILD if ( sJitExceptionHandler ) { if ( ! RegisterExecutableMemory ( p , bytes , pageSize ) ) { VirtualFree ( p , 0 , MEM_RELEASE ) ; return nullptr ; } p = ( uint8_t * ) p + pageSize ; } #endif return p ; }
TNode < Object > ConstructArrayLike ( TNode < Context > context , TNode < Object > receiver , TNode < Number > length ) { TVARIABLE ( Object , array ) ; Label is_constructor ( this ) , is_not_constructor ( this ) , done ( this ) ; CSA_ASSERT ( this , IsNumberNormalized ( length ) ) ; GotoIf ( TaggedIsSmi ( receiver ) , & is_not_constructor ) ; Branch ( IsConstructor ( CAST ( receiver ) ) , & is_constructor , & is_not_constructor ) ; BIND ( & is_constructor ) ; { array = CAST ( ConstructJS ( CodeFactory :: Construct ( isolate ( ) ) , context , receiver , length ) ) ; Goto ( & done ) ; } BIND ( & is_not_constructor ) ; { Label allocate_js_array ( this ) ; Label next ( this ) , runtime ( this , Label :: kDeferred ) ; TNode < Smi > limit = SmiConstant ( JSArray :: kInitialMaxFastElementArray ) ; CSA_ASSERT_BRANCH ( this , [ = ] ( Label * ok , Label * not_ok ) { BranchIfNumberRelationalComparison ( Operation :: kGreaterThanOrEqual , length , SmiConstant ( 0 ) , ok , not_ok ) ; } ) ; BranchIfNumberRelationalComparison ( Operation :: kGreaterThanOrEqual , length , limit , & runtime , & next ) ; BIND ( & runtime ) ; { TNode < Context > native_context = LoadNativeContext ( context ) ; TNode < JSFunction > array_function = CAST ( LoadContextElement ( native_context , Context :: ARRAY_FUNCTION_INDEX ) ) ; array = CallRuntime ( Runtime :: kNewArray , context , array_function , length , array_function , UndefinedConstant ( ) ) ; Goto ( & done ) ; } BIND ( & next ) ; CSA_ASSERT ( this , TaggedIsSmi ( length ) ) ; TNode < Map > array_map = CAST ( LoadContextElement ( context , Context :: JS_ARRAY_PACKED_SMI_ELEMENTS_MAP_INDEX ) ) ; array = CAST ( AllocateJSArray ( PACKED_SMI_ELEMENTS , array_map , length , SmiConstant ( 0 ) , nullptr , ParameterMode :: SMI_PARAMETERS ) ) ; Goto ( & done ) ; } BIND ( & done ) ; return array . value ( ) ; }
njs_vmcode_await ( njs_vm_t * vm , njs_vmcode_await_t * await ) { size_t size ; njs_int_t ret ; njs_frame_t * frame ; njs_value_t ctor , val , on_fulfilled , on_rejected , * value ; njs_promise_t * promise ; njs_function_t * fulfilled , * rejected ; njs_async_ctx_t * ctx ; njs_native_frame_t * active ; active = & vm -> active_frame -> native ; value = njs_scope_valid_value ( vm , await -> retval ) ; if ( njs_slow_path ( value == NULL ) ) { return NJS_ERROR ; } njs_set_function ( & ctor , & vm -> constructors [ NJS_OBJ_TYPE_PROMISE ] ) ; promise = njs_promise_resolve ( vm , & ctor , value ) ; if ( njs_slow_path ( promise == NULL ) ) { return NJS_ERROR ; } ctx = active -> function -> await ; if ( ctx == NULL ) { ctx = njs_mp_alloc ( vm -> mem_pool , sizeof ( njs_async_ctx_t ) ) ; if ( njs_slow_path ( ctx == NULL ) ) { njs_memory_error ( vm ) ; return NJS_ERROR ; } size = njs_function_frame_size ( active ) ; fulfilled = njs_promise_create_function ( vm , size ) ; if ( njs_slow_path ( fulfilled == NULL ) ) { return NJS_ERROR ; } ctx -> await = fulfilled -> context ; ctx -> capability = active -> function -> context ; active -> function -> context = NULL ; ret = njs_function_frame_save ( vm , ctx -> await , NULL ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return NJS_ERROR ; } } else { fulfilled = njs_promise_create_function ( vm , 0 ) ; if ( njs_slow_path ( fulfilled == NULL ) ) { return NJS_ERROR ; } } ctx -> pc = ( u_char * ) await + sizeof ( njs_vmcode_await_t ) ; ctx -> index = await -> retval ; frame = ( njs_frame_t * ) active ; if ( frame -> exception . catch != NULL ) { ctx -> await -> native . pc = frame -> exception . catch ; } else { ctx -> await -> native . pc = ctx -> pc ; } fulfilled -> context = ctx ; fulfilled -> args_count = 1 ; fulfilled -> u . native = njs_await_fulfilled ; rejected = njs_promise_create_function ( vm , 0 ) ; if ( njs_slow_path ( rejected == NULL ) ) { return NJS_ERROR ; } rejected -> context = ctx ; rejected -> args_count = 1 ; rejected -> u . native = njs_await_rejected ; njs_set_object ( & val , & promise -> object ) ; njs_set_function ( & on_fulfilled , fulfilled ) ; njs_set_function ( & on_rejected , rejected ) ; ret = njs_promise_perform_then ( vm , & val , & on_fulfilled , & on_rejected , NULL ) ; if ( njs_slow_path ( ret != NJS_OK ) ) { return NJS_ERROR ; } ( void ) njs_vmcode_return ( vm , NULL , & vm -> retval ) ; return NJS_AGAIN ; }
Variable * DeclarationScope :: DeclareGeneratorObjectVar ( const AstRawString * name ) { DCHECK ( is_function_scope ( ) || is_module_scope ( ) ) ; DCHECK_NULL ( generator_object_var ( ) ) ; Variable * result = EnsureRareData ( ) -> generator_object = NewTemporary ( name , kNotAssigned ) ; result -> set_is_used ( ) ; return result ; }
Symbol * Lexer :: MatchToken ( InputPosition * pos , InputPosition end ) { InputPosition token_start = * pos ; Symbol * symbol = nullptr ; for ( std :: pair < const PatternFunction , Symbol > & pair : patterns_ ) { InputPosition token_end = token_start ; PatternFunction matchPattern = pair . first ; if ( matchPattern ( & token_end ) && token_end > * pos ) { * pos = token_end ; symbol = & pair . second ; } } if ( * pos != token_start ) { auto found_keyword = keywords_ . find ( std :: string ( token_start , * pos ) ) ; if ( found_keyword != keywords_ . end ( ) ) { return & found_keyword -> second ; } return symbol ; } for ( auto it = keywords_ . rbegin ( ) ; it != keywords_ . rend ( ) ; ++ it ) { const std :: string & keyword = it -> first ; if ( static_cast < size_t > ( end - * pos ) < keyword . size ( ) ) continue ; if ( keyword == std :: string ( * pos , * pos + keyword . size ( ) ) ) { * pos += keyword . size ( ) ; return & it -> second ; } } return nullptr ; }
void RemoteFsDevice :: unmount ( ) { if ( details . isLocalFile ( ) ) { return ; } if ( ! isConnected ( ) || proc ) { return ; } if ( messageSent ) { return ; } if ( constSambaProtocol == details . url . scheme ( ) || constSambaAvahiProtocol == details . url . scheme ( ) ) { mounter ( ) -> umount ( mountPoint ( details , false ) , getpid ( ) ) ; setStatusMessage ( tr ( "Disconnecting..." ) ) ; messageSent = true ; return ; } QString cmd ; QStringList args ; if ( ! details . isLocalFile ( ) ) { QString mp = mountPoint ( details , false ) ; if ( ! mp . isEmpty ( ) ) { cmd = Utils :: findExe ( "fusermount" ) ; if ( ! cmd . isEmpty ( ) ) { args < < QLatin1String ( "-u" ) < < QLatin1String ( "-z" ) < < mp ; } else { emit error ( tr ( "\"fusermount\" is not installed!" ) ) ; } } } if ( ! cmd . isEmpty ( ) ) { setStatusMessage ( tr ( "Disconnecting..." ) ) ; proc = new QProcess ( this ) ; proc -> setProperty ( "unmount" , true ) ; connect ( proc , SIGNAL ( finished ( int ) ) , SLOT ( procFinished ( int ) ) ) ; proc -> start ( cmd , args , QIODevice :: ReadOnly ) ; } }
AbortReasonOr < Ok > IonBuilder :: improveTypesAtNullOrUndefinedCompare ( MCompare * ins , bool trueBranch , MTest * test ) { MOZ_ASSERT ( ins -> compareType ( ) == MCompare :: Compare_Undefined || ins -> compareType ( ) == MCompare :: Compare_Null ) ; bool altersUndefined , altersNull ; JSOp op = ins -> jsop ( ) ; switch ( op ) { case JSOp :: StrictNe : case JSOp :: StrictEq : altersUndefined = ins -> compareType ( ) == MCompare :: Compare_Undefined ; altersNull = ins -> compareType ( ) == MCompare :: Compare_Null ; break ; case JSOp :: Ne : case JSOp :: Eq : altersUndefined = altersNull = true ; break ; default : MOZ_CRASH ( "Relational compares not supported" ) ; } MDefinition * subject = ins -> lhs ( ) ; TemporaryTypeSet * inputTypes = subject -> resultTypeSet ( ) ; MOZ_ASSERT ( IsNullOrUndefined ( ins -> rhs ( ) -> type ( ) ) ) ; TemporaryTypeSet tmp ; if ( ! inputTypes ) { if ( subject -> type ( ) == MIRType :: Value ) { return Ok ( ) ; } inputTypes = & tmp ; tmp . addType ( TypeSet :: PrimitiveOrAnyObjectType ( subject -> type ( ) ) , alloc_ -> lifoAlloc ( ) ) ; } if ( inputTypes -> unknown ( ) ) { return Ok ( ) ; } TemporaryTypeSet * type ; if ( ( op == JSOp :: StrictEq || op == JSOp :: Eq ) ^ trueBranch ) { TemporaryTypeSet remove ; if ( altersUndefined ) { remove . addType ( TypeSet :: UndefinedType ( ) , alloc_ -> lifoAlloc ( ) ) ; } if ( altersNull ) { remove . addType ( TypeSet :: NullType ( ) , alloc_ -> lifoAlloc ( ) ) ; } type = TypeSet :: removeSet ( inputTypes , & remove , alloc_ -> lifoAlloc ( ) ) ; } else { TemporaryTypeSet base ; if ( altersUndefined ) { base . addType ( TypeSet :: UndefinedType ( ) , alloc_ -> lifoAlloc ( ) ) ; if ( inputTypes -> maybeEmulatesUndefined ( constraints ( ) ) ) { base . addType ( TypeSet :: AnyObjectType ( ) , alloc_ -> lifoAlloc ( ) ) ; } } if ( altersNull ) { base . addType ( TypeSet :: NullType ( ) , alloc_ -> lifoAlloc ( ) ) ; } type = TypeSet :: intersectSets ( & base , inputTypes , alloc_ -> lifoAlloc ( ) ) ; } if ( ! type ) { return abort ( AbortReason :: Alloc ) ; } return replaceTypeSet ( subject , type , test ) ; }
RemotePeer * PeerFactory :: createPeer ( const ProtoList & protocols , AuthHandler * authHandler , QTcpSocket * socket , Compressor :: CompressionLevel level , QObject * parent ) { foreach ( const ProtoDescriptor & protodesc , protocols ) { Protocol :: Type proto = protodesc . first ; quint16 features = protodesc . second ; switch ( proto ) { case Protocol :: LegacyProtocol : return new LegacyPeer ( authHandler , socket , level , parent ) ; case Protocol :: DataStreamProtocol : if ( DataStreamPeer :: acceptsFeatures ( features ) ) return new DataStreamPeer ( authHandler , socket , features , level , parent ) ; break ; default : break ; } } return 0 ; }
WorkerRun ( JSContext * aCx , WorkerPrivate * aWorkerPrivate ) override { if ( mReason == FetchDriverObserver :: eAborted ) { RefPtr < Promise > promise = mResolver -> mPromiseProxy -> WorkerPromise ( ) ; promise -> MaybeReject ( NS_ERROR_DOM_ABORT_ERR ) ; } WorkerRunInternal ( aWorkerPrivate ) ; return true ; }
FLAC__StreamDecoderWriteStatus FLACParser :: writeCallback ( const FLAC__Frame * frame , const FLAC__int32 * const buffer [ ] ) { if ( mWriteRequested ) { mWriteRequested = false ; mWriteHeader = frame -> header ; mWriteBuffer = buffer ; mWriteCompleted = true ; return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ; } else { ALOGE ( "FLACParser::writeCallback unexpected" ) ; return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT ; } }
static void pdf_parseobj ( struct pdf_struct * pdf , struct pdf_obj * obj ) { char pdfname [ 64 ] ; const char * q2 , * q3 ; const char * q = obj -> start + pdf -> map ; const char * dict , * start ; off_t dict_length ; off_t bytesleft = obj_size ( pdf , obj , 1 ) ; unsigned i , filters = 0 ; enum objstate objstate = STATE_NONE ; if ( bytesleft < 0 ) return ; start = q ; do { q2 = pdf_nextobject ( q , bytesleft ) ; bytesleft -= q2 - q ; if ( ! q2 || bytesleft < 0 ) { return ; } q3 = memchr ( q - 1 , '<' , q2 - q + 1 ) ; q2 ++ ; bytesleft -- ; q = q2 ; } while ( ! q3 || q3 [ 1 ] != '<' ) ; dict = q3 + 2 ; q = dict ; bytesleft = obj_size ( pdf , obj , 1 ) - ( q - start ) ; do { q2 = pdf_nextobject ( q , bytesleft ) ; bytesleft -= q2 - q ; if ( ! q2 || bytesleft < 0 ) { return ; } q3 = memchr ( q - 1 , '>' , q2 - q + 1 ) ; q2 ++ ; bytesleft -- ; q = q2 ; } while ( ! q3 || q3 [ 1 ] != '>' ) ; obj -> flags |= 1 < < OBJ_DICT ; dict_length = q3 - dict ; for ( q = dict ; dict_length > 0 ; ) { int escapes = 0 ; q2 = memchr ( q , '/' , dict_length ) ; if ( ! q2 ) break ; dict_length -= q2 - q ; q = q2 ; for ( i = 0 ; dict_length > 0 && ( i < sizeof ( pdfname ) - 1 ) ; i ++ ) { q ++ ; dict_length -- ; if ( * q == '#' ) { if ( cli_hex2str_to ( q + 1 , pdfname + i , 2 ) == - 1 ) break ; q += 2 ; dict_length -= 2 ; escapes = 1 ; continue ; } if ( * q == ' ' || * q == '\t' || * q == '\r' || * q == '\n' || * q == '/' || * q == '>' || * q == ']' || * q == '[' || * q == '<' || * q == '(' ) break ; pdfname [ i ] = * q ; } pdfname [ i ] = '\0' ; handle_pdfname ( pdf , obj , pdfname , escapes , & objstate ) ; if ( objstate == STATE_LINEARIZED ) { long trailer_end , trailer ; pdfobj_flag ( pdf , obj , LINEARIZED_PDF ) ; objstate = STATE_NONE ; trailer_end = pdf_readint ( q , dict_length , "/H" ) ; if ( trailer_end > 0 && trailer_end < pdf -> size ) { trailer = trailer_end - 1024 ; if ( trailer < 0 ) trailer = 0 ; q2 = pdf -> map + trailer ; cli_dbgmsg ( "cli_pdf: looking for trailer in linearized pdf: %ld - %ld\n" , trailer , trailer_end ) ; pdf_parse_trailer ( pdf , q2 , trailer_end - trailer ) ; if ( pdf -> fileID ) cli_dbgmsg ( "cli_pdf: found fileID\n" ) ; } } if ( objstate == STATE_LAUNCHACTION ) pdfobj_flag ( pdf , obj , HAS_LAUNCHACTION ) ; if ( dict_length > 0 && ( objstate == STATE_JAVASCRIPT || objstate == STATE_OPENACTION ) ) { if ( objstate == STATE_OPENACTION ) pdfobj_flag ( pdf , obj , HAS_OPENACTION ) ; q2 = pdf_nextobject ( q , dict_length ) ; if ( q2 && isdigit ( * q2 ) ) { uint32_t objid = atoi ( q2 ) < < 8 ; while ( isdigit ( * q2 ) ) q2 ++ ; q2 = pdf_nextobject ( q2 , dict_length ) ; if ( q2 && isdigit ( * q2 ) ) { objid |= atoi ( q2 ) & 0xff ; q2 = pdf_nextobject ( q2 , dict_length ) ; if ( q2 && * q2 == 'R' ) { struct pdf_obj * obj2 ; cli_dbgmsg ( "cli_pdf: found %s stored in indirect object %u %u\n" , pdfname , objid > > 8 , objid & 0xff ) ; obj2 = find_obj ( pdf , obj , objid ) ; if ( obj2 ) { enum pdf_objflags flag = objstate == STATE_JAVASCRIPT ? OBJ_JAVASCRIPT : OBJ_OPENACTION ; obj2 -> flags |= 1 < < flag ; obj -> flags &= ~ ( 1 < < flag ) ; } else { pdfobj_flag ( pdf , obj , BAD_INDOBJ ) ; } } } } objstate = STATE_NONE ; } } for ( i = 0 ; i < sizeof ( pdfname_actions ) / sizeof ( pdfname_actions [ 0 ] ) ; i ++ ) { const struct pdfname_action * act = & pdfname_actions [ i ] ; if ( ( obj -> flags & ( 1 < < act -> set_objflag ) ) && act -> from_state == STATE_FILTER && act -> to_state == STATE_FILTER && act -> set_objflag != OBJ_FILTER_CRYPT && act -> set_objflag != OBJ_FILTER_STANDARD ) { filters ++ ; } } if ( filters > 2 ) { pdfobj_flag ( pdf , obj , MANY_FILTERS ) ; } if ( obj -> flags & ( ( 1 < < OBJ_SIGNED ) | KNOWN_FILTERS ) ) obj -> flags &= ~ ( 1 < < OBJ_FILTER_UNKNOWN ) ; if ( obj -> flags & ( 1 < < OBJ_FILTER_UNKNOWN ) ) pdfobj_flag ( pdf , obj , UNKNOWN_FILTER ) ; cli_dbgmsg ( "cli_pdf: %u %u obj flags: %02x\n" , obj -> id > > 8 , obj -> id & 0xff , obj -> flags ) ; }
void Schedule :: AddReturn ( BasicBlock * block , Node * input ) { DCHECK_EQ ( BasicBlock :: kNone , block -> control ( ) ) ; block -> set_control ( BasicBlock :: kReturn ) ; SetControlInput ( block , input ) ; if ( block != end ( ) ) AddSuccessor ( block , end ( ) ) ; }
png_handle_sPLT ( png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) { png_bytep entry_start , buffer ; png_sPLT_t new_palette ; png_sPLT_entryp pp ; png_uint_32 data_length ; int entry_size , i ; png_uint_32 skip = 0 ; png_uint_32 dl ; png_size_t max_dl ; png_debug ( 1 , "in png_handle_sPLT" ) ; #ifdef PNG_USER_LIMITS_SUPPORTED if ( png_ptr -> user_chunk_cache_max != 0 ) { if ( png_ptr -> user_chunk_cache_max == 1 ) { png_crc_finish ( png_ptr , length ) ; return ; } if ( -- png_ptr -> user_chunk_cache_max == 1 ) { png_warning ( png_ptr , "No space in chunk cache for sPLT" ) ; png_crc_finish ( png_ptr , length ) ; return ; } } #endif if ( ! ( png_ptr -> mode & PNG_HAVE_IHDR ) ) png_chunk_error ( png_ptr , "missing IHDR" ) ; else if ( png_ptr -> mode & PNG_HAVE_IDAT ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "out of place" ) ; return ; } #ifdef PNG_MAX_MALLOC_64K if ( length > 65535U ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "too large to fit in memory" ) ; return ; } #endif buffer = png_read_buffer ( png_ptr , length + 1 , 2 ) ; if ( buffer == NULL ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "out of memory" ) ; return ; } png_crc_read ( png_ptr , buffer , length ) ; if ( png_crc_finish ( png_ptr , skip ) ) return ; buffer [ length ] = 0 ; for ( entry_start = buffer ; * entry_start ; entry_start ++ ) ; ++ entry_start ; if ( entry_start > buffer + length - 2 ) { png_warning ( png_ptr , "malformed sPLT chunk" ) ; return ; } new_palette . depth = * entry_start ++ ; entry_size = ( new_palette . depth == 8 ? 6 : 10 ) ; data_length = length - ( png_uint_32 ) ( entry_start - buffer ) ; if ( data_length % entry_size ) { png_warning ( png_ptr , "sPLT chunk has bad length" ) ; return ; } dl = ( png_int_32 ) ( data_length / entry_size ) ; max_dl = PNG_SIZE_MAX / ( sizeof ( png_sPLT_entry ) ) ; if ( dl > max_dl ) { png_warning ( png_ptr , "sPLT chunk too long" ) ; return ; } new_palette . nentries = ( png_int_32 ) ( data_length / entry_size ) ; new_palette . entries = ( png_sPLT_entryp ) png_malloc_warn ( png_ptr , new_palette . nentries * ( sizeof ( png_sPLT_entry ) ) ) ; if ( new_palette . entries == NULL ) { png_warning ( png_ptr , "sPLT chunk requires too much memory" ) ; return ; } #ifdef PNG_POINTER_INDEXING_SUPPORTED for ( i = 0 ; i < new_palette . nentries ; i ++ ) { pp = new_palette . entries + i ; if ( new_palette . depth == 8 ) { pp -> red = * entry_start ++ ; pp -> green = * entry_start ++ ; pp -> blue = * entry_start ++ ; pp -> alpha = * entry_start ++ ; } else { pp -> red = png_get_uint_16 ( entry_start ) ; entry_start += 2 ; pp -> green = png_get_uint_16 ( entry_start ) ; entry_start += 2 ; pp -> blue = png_get_uint_16 ( entry_start ) ; entry_start += 2 ; pp -> alpha = png_get_uint_16 ( entry_start ) ; entry_start += 2 ; } pp -> frequency = png_get_uint_16 ( entry_start ) ; entry_start += 2 ; } #else pp = new_palette . entries ; for ( i = 0 ; i < new_palette . nentries ; i ++ ) { if ( new_palette . depth == 8 ) { pp [ i ] . red = * entry_start ++ ; pp [ i ] . green = * entry_start ++ ; pp [ i ] . blue = * entry_start ++ ; pp [ i ] . alpha = * entry_start ++ ; } else { pp [ i ] . red = png_get_uint_16 ( entry_start ) ; entry_start += 2 ; pp [ i ] . green = png_get_uint_16 ( entry_start ) ; entry_start += 2 ; pp [ i ] . blue = png_get_uint_16 ( entry_start ) ; entry_start += 2 ; pp [ i ] . alpha = png_get_uint_16 ( entry_start ) ; entry_start += 2 ; } pp [ i ] . frequency = png_get_uint_16 ( entry_start ) ; entry_start += 2 ; } #endif new_palette . name = ( png_charp ) buffer ; png_set_sPLT ( png_ptr , info_ptr , & new_palette , 1 ) ; png_free ( png_ptr , new_palette . entries ) ; }
Status Examples :: Initialize ( OpKernelContext * const context , const ModelWeights & weights , const int num_sparse_features , const int num_sparse_features_with_values , const int num_dense_features ) { num_features_ = num_sparse_features + num_dense_features ; OpInputList sparse_example_indices_inputs ; TF_RETURN_IF_ERROR ( context -> input_list ( "sparse_example_indices" , & sparse_example_indices_inputs ) ) ; OpInputList sparse_feature_indices_inputs ; TF_RETURN_IF_ERROR ( context -> input_list ( "sparse_feature_indices" , & sparse_feature_indices_inputs ) ) ; OpInputList sparse_feature_values_inputs ; if ( num_sparse_features_with_values > 0 ) { TF_RETURN_IF_ERROR ( context -> input_list ( "sparse_feature_values" , & sparse_feature_values_inputs ) ) ; } const Tensor * example_weights_t ; TF_RETURN_IF_ERROR ( context -> input ( "example_weights" , & example_weights_t ) ) ; auto example_weights = example_weights_t -> flat < float > ( ) ; if ( example_weights . size ( ) >= std :: numeric_limits < int > :: max ( ) ) { return errors :: InvalidArgument ( strings :: Printf ( "Too many examples in a mini-batch: %zu > %d" , example_weights . size ( ) , std :: numeric_limits < int > :: max ( ) ) ) ; } const int num_examples = static_cast < int > ( example_weights . size ( ) ) ; const Tensor * example_labels_t ; TF_RETURN_IF_ERROR ( context -> input ( "example_labels" , & example_labels_t ) ) ; auto example_labels = example_labels_t -> flat < float > ( ) ; OpInputList dense_features_inputs ; TF_RETURN_IF_ERROR ( context -> input_list ( "dense_features" , & dense_features_inputs ) ) ; examples_ . clear ( ) ; examples_ . resize ( num_examples ) ; probabilities_ . resize ( num_examples ) ; sampled_index_ . resize ( num_examples ) ; sampled_count_ . resize ( num_examples ) ; for ( int example_id = 0 ; example_id < num_examples ; ++ example_id ) { Example * const example = & examples_ [ example_id ] ; example -> sparse_features_ . resize ( num_sparse_features ) ; example -> dense_vectors_ . resize ( num_dense_features ) ; example -> example_weight_ = example_weights ( example_id ) ; example -> example_label_ = example_labels ( example_id ) ; } const DeviceBase :: CpuWorkerThreads & worker_threads = * context -> device ( ) -> tensorflow_cpu_worker_threads ( ) ; TF_RETURN_IF_ERROR ( CreateSparseFeatureRepresentation ( worker_threads , num_examples , num_sparse_features , weights , sparse_example_indices_inputs , sparse_feature_indices_inputs , sparse_feature_values_inputs , & examples_ ) ) ; TF_RETURN_IF_ERROR ( CreateDenseFeatureRepresentation ( worker_threads , num_examples , num_dense_features , weights , dense_features_inputs , & examples_ ) ) ; TF_RETURN_IF_ERROR ( ComputeSquaredNormPerExample ( worker_threads , num_examples , num_sparse_features , num_dense_features , & examples_ ) ) ; return Status :: OK ( ) ; }
void BytecodeGraphBuilder :: VisitCallProperty1 ( ) { Node * callee = environment ( ) -> LookupRegister ( bytecode_iterator ( ) . GetRegisterOperand ( 0 ) ) ; Node * receiver = environment ( ) -> LookupRegister ( bytecode_iterator ( ) . GetRegisterOperand ( 1 ) ) ; Node * arg0 = environment ( ) -> LookupRegister ( bytecode_iterator ( ) . GetRegisterOperand ( 2 ) ) ; int const slot_id = bytecode_iterator ( ) . GetIndexOperand ( 3 ) ; BuildCall ( ConvertReceiverMode :: kNotNullOrUndefined , { callee , receiver , arg0 } , slot_id ) ; }
WebSocket :: Constructor ( const GlobalObject & aGlobal , const nsAString & aUrl , const Sequence < nsString > & aProtocols , ErrorResult & aRv ) { nsCOMPtr < nsIPrincipal > principal ; nsCOMPtr < nsPIDOMWindow > ownerWindow ; if ( NS_IsMainThread ( ) ) { nsCOMPtr < nsIScriptObjectPrincipal > scriptPrincipal = do_QueryInterface ( aGlobal . GetAsSupports ( ) ) ; if ( ! scriptPrincipal ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return nullptr ; } principal = scriptPrincipal -> GetPrincipal ( ) ; if ( ! principal ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return nullptr ; } nsCOMPtr < nsIScriptGlobalObject > sgo = do_QueryInterface ( aGlobal . GetAsSupports ( ) ) ; if ( ! sgo ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return nullptr ; } ownerWindow = do_QueryInterface ( aGlobal . GetAsSupports ( ) ) ; if ( ! ownerWindow ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return nullptr ; } } nsTArray < nsString > protocolArray ; for ( uint32_t index = 0 , len = aProtocols . Length ( ) ; index < len ; ++ index ) { const nsString & protocolElement = aProtocols [ index ] ; if ( protocolElement . IsEmpty ( ) ) { aRv . Throw ( NS_ERROR_DOM_SYNTAX_ERR ) ; return nullptr ; } if ( protocolArray . Contains ( protocolElement ) ) { aRv . Throw ( NS_ERROR_DOM_SYNTAX_ERR ) ; return nullptr ; } if ( protocolElement . FindChar ( ',' ) != - 1 ) { aRv . Throw ( NS_ERROR_DOM_SYNTAX_ERR ) ; return nullptr ; } protocolArray . AppendElement ( protocolElement ) ; } nsRefPtr < WebSocket > webSocket = new WebSocket ( ownerWindow ) ; nsRefPtr < WebSocketImpl > kungfuDeathGrip = webSocket -> mImpl ; bool connectionFailed = true ; if ( NS_IsMainThread ( ) ) { webSocket -> mImpl -> Init ( aGlobal . Context ( ) , principal , aUrl , protocolArray , EmptyCString ( ) , 0 , aRv , & connectionFailed ) ; } else { if ( ! webSocket -> mImpl -> RegisterFeature ( ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return nullptr ; } unsigned lineno ; JS :: AutoFilename file ; if ( ! JS :: DescribeScriptedCaller ( aGlobal . Context ( ) , & file , & lineno ) ) { NS_WARNING ( "Failed to get line number and filename in workers." ) ; } nsRefPtr < InitRunnable > runnable = new InitRunnable ( webSocket -> mImpl , aUrl , protocolArray , nsAutoCString ( file . get ( ) ) , lineno , aRv , & connectionFailed ) ; runnable -> Dispatch ( aGlobal . Context ( ) ) ; } if ( NS_WARN_IF ( aRv . Failed ( ) ) ) { return nullptr ; } if ( ! webSocket -> mImpl ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return nullptr ; } if ( connectionFailed ) { webSocket -> mImpl -> FailConnection ( nsIWebSocketChannel :: CLOSE_ABNORMAL ) ; } if ( ! webSocket -> mImpl -> mChannel ) { return webSocket . forget ( ) ; } class MOZ_STACK_CLASS ClearWebSocket { public : explicit ClearWebSocket ( WebSocketImpl * aWebSocketImpl ) : mWebSocketImpl ( aWebSocketImpl ) , mDone ( false ) { } void Done ( ) { mDone = true ; } ~ ClearWebSocket ( ) { if ( ! mDone ) { mWebSocketImpl -> mChannel = nullptr ; mWebSocketImpl -> FailConnection ( nsIWebSocketChannel :: CLOSE_ABNORMAL ) ; } } WebSocketImpl * mWebSocketImpl ; bool mDone ; } ; ClearWebSocket cws ( webSocket -> mImpl ) ; aRv = webSocket -> mImpl -> mChannel -> SetNotificationCallbacks ( webSocket -> mImpl ) ; if ( NS_WARN_IF ( aRv . Failed ( ) ) ) { return nullptr ; } if ( NS_IsMainThread ( ) ) { webSocket -> mImpl -> AsyncOpen ( aRv ) ; } else { nsRefPtr < AsyncOpenRunnable > runnable = new AsyncOpenRunnable ( webSocket -> mImpl , aRv ) ; runnable -> Dispatch ( aGlobal . Context ( ) ) ; } if ( NS_WARN_IF ( aRv . Failed ( ) ) ) { return nullptr ; } if ( ! webSocket -> mImpl ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return nullptr ; } cws . Done ( ) ; return webSocket . forget ( ) ; }
void V8DebuggerAgentImpl :: reset ( ) { if ( ! enabled ( ) ) return ; m_blackboxedPositions . clear ( ) ; resetBlackboxedStateCache ( ) ; m_scripts . clear ( ) ; m_breakpointIdToDebuggerBreakpointIds . clear ( ) ; }
int vp9_decode_frame ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end , const uint8_t * * p_data_end ) { VP9_COMMON * const cm = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; struct vp9_read_bit_buffer rb = { data , data_end , 0 , cm , error_handler } ; const size_t first_partition_size = read_uncompressed_header ( pbi , & rb ) ; const int keyframe = cm -> frame_type == KEY_FRAME ; const int tile_rows = 1 < < cm -> log2_tile_rows ; const int tile_cols = 1 < < cm -> log2_tile_cols ; YV12_BUFFER_CONFIG * const new_fb = get_frame_new_buffer ( cm ) ; xd -> cur_buf = new_fb ; if ( ! first_partition_size ) { * p_data_end = data + 1 ; return 0 ; } if ( ! pbi -> decoded_key_frame && ! keyframe ) return - 1 ; data += vp9_rb_bytes_read ( & rb ) ; if ( ! read_is_valid ( data , first_partition_size , data_end ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , "Truncated packet or corrupt header length" ) ; pbi -> do_loopfilter_inline = ( cm -> log2_tile_rows | cm -> log2_tile_cols ) == 0 && cm -> lf . filter_level ; if ( pbi -> do_loopfilter_inline && pbi -> lf_worker . data1 == NULL ) { CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ; pbi -> lf_worker . hook = ( VP9WorkerHook ) vp9_loop_filter_worker ; if ( pbi -> oxcf . max_threads > 1 && ! vp9_worker_reset ( & pbi -> lf_worker ) ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , "Loop filter thread creation failed" ) ; } } init_macroblockd ( cm , & pbi -> mb ) ; cm -> prev_mi = get_prev_mi ( cm ) ; setup_plane_dequants ( cm , xd , cm -> base_qindex ) ; vp9_setup_block_planes ( xd , cm -> subsampling_x , cm -> subsampling_y ) ; cm -> fc = cm -> frame_contexts [ cm -> frame_context_idx ] ; vp9_zero ( cm -> counts ) ; vp9_zero ( xd -> dqcoeff ) ; xd -> corrupted = 0 ; new_fb -> corrupted = read_compressed_header ( pbi , data , first_partition_size ) ; if ( pbi -> oxcf . max_threads > 1 && tile_rows == 1 && tile_cols > 1 && cm -> frame_parallel_decoding_mode ) { * p_data_end = decode_tiles_mt ( pbi , data + first_partition_size , data_end ) ; } else { * p_data_end = decode_tiles ( pbi , data + first_partition_size , data_end ) ; } new_fb -> corrupted |= xd -> corrupted ; if ( ! pbi -> decoded_key_frame ) { if ( keyframe && ! new_fb -> corrupted ) pbi -> decoded_key_frame = 1 ; else vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , "A stream must start with a complete key frame" ) ; } if ( ! cm -> error_resilient_mode && ! cm -> frame_parallel_decoding_mode ) { vp9_adapt_coef_probs ( cm ) ; if ( ! frame_is_intra_only ( cm ) ) { vp9_adapt_mode_probs ( cm ) ; vp9_adapt_mv_probs ( cm , cm -> allow_high_precision_mv ) ; } } else { debug_check_frame_counts ( cm ) ; } if ( cm -> refresh_frame_context ) cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ; return 0 ; }
TfLiteTensor * GetTempLhs ( TfLiteContext * context , TfLiteNode * node , const TfLiteTensor * lhs ) { TfLiteTensor * transposed_lhs = GetTemporary ( context , node , 0 ) ; if ( lhs -> type == kTfLiteInt8 ) { transposed_lhs -> params . scale = lhs -> params . scale ; transposed_lhs -> params . zero_point = lhs -> params . zero_point ; } return transposed_lhs ; }
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
IMPEG2D_ERROR_CODES_T impeg2d_process_video_bit_stream ( dec_state_t * ps_dec ) { stream_t * ps_stream ; UWORD32 u4_next_bits , u4_start_code_found ; IMPEG2D_ERROR_CODES_T e_error ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_next_start_code ( ps_dec ) ; u4_start_code_found = 0 ; if ( ps_dec -> u2_is_mpeg2 ) { while ( ( u4_start_code_found == 0 ) && ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) ) { u4_next_bits = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; if ( u4_next_bits == SEQUENCE_HEADER_CODE ) { if ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) { e_error = impeg2d_dec_seq_hdr ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } u4_start_code_found = 0 ; } else { return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR ; } if ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_dec_seq_ext ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } u4_start_code_found = 0 ; } else { return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR ; } } else if ( ( u4_next_bits == USER_DATA_START_CODE ) || ( u4_next_bits == EXTENSION_START_CODE ) ) { if ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) { impeg2d_dec_seq_ext_data ( ps_dec ) ; u4_start_code_found = 0 ; } } else if ( ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) && ( u4_next_bits == GOP_START_CODE ) ) { impeg2d_dec_grp_of_pic_hdr ( ps_dec ) ; impeg2d_dec_user_data ( ps_dec ) ; u4_start_code_found = 0 ; } else if ( ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) && ( u4_next_bits == PICTURE_START_CODE ) ) { e_error = impeg2d_dec_pic_hdr ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } e_error = impeg2d_dec_pic_coding_ext ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } e_error = impeg2d_dec_pic_ext_data ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } impeg2d_pre_pic_dec_proc ( ps_dec ) ; impeg2d_dec_pic_data ( ps_dec ) ; impeg2d_post_pic_dec_proc ( ps_dec ) ; u4_start_code_found = 1 ; } else { FLUSH_BITS ( ps_dec -> s_bit_stream . u4_offset , ps_dec -> s_bit_stream . u4_buf , ps_dec -> s_bit_stream . u4_buf_nxt , 8 , ps_dec -> s_bit_stream . pu4_buf_aligned ) ; } if ( u4_start_code_found == 0 ) { impeg2d_next_start_code ( ps_dec ) ; ps_dec -> i4_bytes_consumed = ( ps_dec -> s_bit_stream . u4_offset + 7 ) > > 3 ; ps_dec -> i4_bytes_consumed -= ( ( size_t ) ps_dec -> s_bit_stream . pv_bs_buf & 3 ) ; } } if ( ( u4_start_code_found == 0 ) && ( ps_dec -> s_bit_stream . u4_offset > ps_dec -> s_bit_stream . u4_max_offset ) ) { return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } } else { while ( ( u4_start_code_found == 0 ) && ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) ) { u4_next_bits = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) == SEQUENCE_HEADER_CODE ) { if ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) { e_error = impeg2d_dec_seq_hdr ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } u4_start_code_found = 0 ; } else { return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR ; } } else if ( ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) && ( u4_next_bits == EXTENSION_START_CODE || u4_next_bits == USER_DATA_START_CODE ) ) { impeg2d_flush_ext_and_user_data ( ps_dec ) ; u4_start_code_found = 0 ; } else if ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) == GOP_START_CODE ) && ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) ) { impeg2d_dec_grp_of_pic_hdr ( ps_dec ) ; impeg2d_flush_ext_and_user_data ( ps_dec ) ; u4_start_code_found = 0 ; } else if ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) == PICTURE_START_CODE ) && ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) ) { e_error = impeg2d_dec_pic_hdr ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } impeg2d_flush_ext_and_user_data ( ps_dec ) ; impeg2d_pre_pic_dec_proc ( ps_dec ) ; impeg2d_dec_pic_data ( ps_dec ) ; impeg2d_post_pic_dec_proc ( ps_dec ) ; u4_start_code_found = 1 ; } else { FLUSH_BITS ( ps_dec -> s_bit_stream . u4_offset , ps_dec -> s_bit_stream . u4_buf , ps_dec -> s_bit_stream . u4_buf_nxt , 8 , ps_dec -> s_bit_stream . pu4_buf_aligned ) ; } impeg2d_next_start_code ( ps_dec ) ; if ( 0 == u4_start_code_found ) { ps_dec -> i4_bytes_consumed = ( ps_dec -> s_bit_stream . u4_offset + 7 ) > > 3 ; ps_dec -> i4_bytes_consumed -= ( ( size_t ) ps_dec -> s_bit_stream . pv_bs_buf & 3 ) ; } } if ( ( u4_start_code_found == 0 ) && ( ps_dec -> s_bit_stream . u4_offset > ps_dec -> s_bit_stream . u4_max_offset ) ) { return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } } return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
freeimage ( Image * image ) { freebuffer ( image ) ; png_image_free ( & image -> image ) ; if ( image -> input_file != NULL ) { fclose ( image -> input_file ) ; image -> input_file = NULL ; } if ( image -> input_memory != NULL ) { free ( image -> input_memory ) ; image -> input_memory = NULL ; image -> input_memory_size = 0 ; } if ( image -> tmpfile_name [ 0 ] != 0 && ( image -> opts & KEEP_TMPFILES ) == 0 ) { remove ( image -> tmpfile_name ) ; image -> tmpfile_name [ 0 ] = 0 ; } }
bool IsBlacklistedArg ( const base :: CommandLine :: CharType * arg ) { #if defined(OS_WIN) const auto converted = base :: WideToUTF8 ( arg ) ; const char * a = converted . c_str ( ) ; #else const char * a = arg ; #endif static const char * prefixes [ ] = { "--" , "-" , "/" } ; int prefix_length = 0 ; for ( auto & prefix : prefixes ) { if ( base :: StartsWith ( a , prefix , base :: CompareCase :: SENSITIVE ) ) { prefix_length = strlen ( prefix ) ; break ; } } if ( prefix_length > 0 ) { a += prefix_length ; std :: string switch_name ( a , strcspn ( a , "=" ) ) ; auto * iter = std :: lower_bound ( std :: begin ( kBlacklist ) , std :: end ( kBlacklist ) , switch_name ) ; if ( iter != std :: end ( kBlacklist ) && switch_name == * iter ) { return true ; } } return false ; }
static int irda_recvmsg_dgram ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; struct sk_buff * skb ; size_t copied ; int err ; IRDA_DEBUG ( 4 , "%s()\n" , __func__ ) ; msg -> msg_namelen = 0 ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { IRDA_DEBUG ( 2 , "%s(), Received truncated frame (%zd < %zd)!\n" , __func__ , copied , size ) ; copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) < < 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , "%s(), Starting IrTTP\n" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }
CallDescriptor * Linkage :: ComputeIncoming ( Zone * zone , OptimizedCompilationInfo * info ) { DCHECK ( ! info -> IsStub ( ) ) ; if ( ! info -> closure ( ) . is_null ( ) ) { SharedFunctionInfo * shared = info -> closure ( ) -> shared ( ) ; return GetJSCallDescriptor ( zone , info -> is_osr ( ) , 1 + shared -> internal_formal_parameter_count ( ) , CallDescriptor :: kNoFlags ) ; } return nullptr ; }
sctp_pathmtu_adjustment ( struct sctp_tcb * stcb , uint16_t nxtsz ) { struct sctp_tmit_chunk * chk ; uint16_t overhead ; stcb -> asoc . smallest_mtu = nxtsz ; overhead = IP_HDR_SIZE + sizeof ( struct sctphdr ) ; if ( sctp_auth_is_required_chunk ( SCTP_DATA , stcb -> asoc . peer_auth_chunks ) ) { overhead += sctp_get_auth_chunk_len ( stcb -> asoc . peer_hmac_id ) ; } TAILQ_FOREACH ( chk , & stcb -> asoc . send_queue , sctp_next ) { if ( ( chk -> send_size + overhead ) > nxtsz ) { chk -> flags |= CHUNK_FLAGS_FRAGMENT_OK ; } } TAILQ_FOREACH ( chk , & stcb -> asoc . sent_queue , sctp_next ) { if ( ( chk -> send_size + overhead ) > nxtsz ) { chk -> flags |= CHUNK_FLAGS_FRAGMENT_OK ; if ( chk -> sent < SCTP_DATAGRAM_RESEND ) { sctp_flight_size_decrease ( chk ) ; sctp_total_flight_decrease ( stcb , chk ) ; chk -> sent = SCTP_DATAGRAM_RESEND ; sctp_ucount_incr ( stcb -> asoc . sent_queue_retran_cnt ) ; chk -> rec . data . doing_fast_retransmit = 0 ; if ( SCTP_BASE_SYSCTL ( sctp_logging_level ) & SCTP_FLIGHT_LOGGING_ENABLE ) { sctp_misc_ints ( SCTP_FLIGHT_LOG_DOWN_PMTU , chk -> whoTo -> flight_size , chk -> book_size , ( uint32_t ) ( uintptr_t ) chk -> whoTo , chk -> rec . data . tsn ) ; } if ( chk -> do_rtt == 1 ) { chk -> do_rtt = 0 ; chk -> whoTo -> rto_needed = 1 ; } } } } }
AudioContext :: CreatePeriodicWave ( const Float32Array & aRealData , const Float32Array & aImagData , ErrorResult & aRv ) { if ( aRealData . Length ( ) != aImagData . Length ( ) || aRealData . Length ( ) == 0 || aRealData . Length ( ) > 4096 ) { aRv . Throw ( NS_ERROR_DOM_NOT_SUPPORTED_ERR ) ; return nullptr ; } nsRefPtr < PeriodicWave > periodicWave = new PeriodicWave ( this , aRealData . Data ( ) , aImagData . Data ( ) , aImagData . Length ( ) , aRv ) ; if ( aRv . Failed ( ) ) { return nullptr ; } return periodicWave . forget ( ) ; }
nsresult XRE_InitCommandLine ( int aArgc , char * aArgv [ ] ) { nsresult rv = NS_OK ; #if defined(OS_WIN) CommandLine :: Init ( aArgc , aArgv ) ; #else char * * canonArgs = new char * [ aArgc ] ; nsCOMPtr < nsIFile > binFile ; rv = XRE_GetBinaryPath ( getter_AddRefs ( binFile ) ) ; if ( NS_FAILED ( rv ) ) return NS_ERROR_FAILURE ; nsAutoCString canonBinPath ; rv = binFile -> GetNativePath ( canonBinPath ) ; if ( NS_FAILED ( rv ) ) return NS_ERROR_FAILURE ; canonArgs [ 0 ] = strdup ( canonBinPath . get ( ) ) ; for ( int i = 1 ; i < aArgc ; ++ i ) { if ( aArgv [ i ] ) { canonArgs [ i ] = strdup ( aArgv [ i ] ) ; } } NS_ASSERTION ( ! CommandLine :: IsInitialized ( ) , "Bad news!" ) ; CommandLine :: Init ( aArgc , canonArgs ) ; for ( int i = 0 ; i < aArgc ; ++ i ) free ( canonArgs [ i ] ) ; delete [ ] canonArgs ; #endif recordreplay :: parent :: InitializeUIProcess ( gArgc , gArgv ) ; const char * path = nullptr ; ArgResult ar = CheckArg ( "greomni" , & path ) ; if ( ar == ARG_BAD ) { PR_fprintf ( PR_STDERR , "Error: argument --greomni requires a path argument\n" ) ; return NS_ERROR_FAILURE ; } if ( ! path ) return rv ; nsCOMPtr < nsIFile > greOmni ; rv = XRE_GetFileFromPath ( path , getter_AddRefs ( greOmni ) ) ; if ( NS_FAILED ( rv ) ) { PR_fprintf ( PR_STDERR , "Error: argument --greomni requires a valid path\n" ) ; return rv ; } ar = CheckArg ( "appomni" , & path ) ; if ( ar == ARG_BAD ) { PR_fprintf ( PR_STDERR , "Error: argument --appomni requires a path argument\n" ) ; return NS_ERROR_FAILURE ; } nsCOMPtr < nsIFile > appOmni ; if ( path ) { rv = XRE_GetFileFromPath ( path , getter_AddRefs ( appOmni ) ) ; if ( NS_FAILED ( rv ) ) { PR_fprintf ( PR_STDERR , "Error: argument --appomni requires a valid path\n" ) ; return rv ; } } mozilla :: Omnijar :: Init ( greOmni , appOmni ) ; return rv ; }
UnixSocketConsumer :: CloseSocket ( ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; if ( ! mImpl ) { return ; } UnixSocketImpl * impl = mImpl ; mImpl = nullptr ; impl -> mConsumer . forget ( ) ; impl -> CancelTask ( ) ; XRE_GetIOMessageLoop ( ) -> PostTask ( FROM_HERE , new SocketCloseTask ( impl ) ) ; NotifyDisconnect ( ) ; }
Assembler :: as_b ( Label * l , Condition c , bool isPatchable ) { if ( m_buffer . oom ( ) ) { BufferOffset ret ; return ret ; } m_buffer . markNextAsBranch ( ) ; if ( l -> bound ( ) ) { BufferOffset ret = as_nop ( ) ; as_b ( BufferOffset ( l ) . diffB < BOffImm > ( ret ) , c , ret ) ; return ret ; } int32_t old ; BufferOffset ret ; if ( l -> used ( ) ) { old = l -> offset ( ) ; if ( ! BOffImm :: isInRange ( old ) ) { m_buffer . bail ( ) ; return ret ; } ret = as_b ( BOffImm ( old ) , c , isPatchable ) ; } else { old = LabelBase :: INVALID_OFFSET ; BOffImm inv ; ret = as_b ( inv , c , isPatchable ) ; } DebugOnly < int32_t > check = l -> use ( ret . getOffset ( ) ) ; JS_ASSERT ( check == old ) ; return ret ; }
void Builtins :: Generate_InterpreterPushArgsThenConstructImpl ( MacroAssembler * masm , InterpreterPushArgsMode mode ) { Label stack_overflow ; Generate_StackOverflowCheck ( masm , rax , r8 , & stack_overflow ) ; __ PopReturnAddressTo ( kScratchRegister ) ; __ Push ( Immediate ( 0 ) ) ; Generate_InterpreterPushArgs ( masm , rax , rcx , r8 ) ; if ( mode == InterpreterPushArgsMode :: kWithFinalSpread ) { __ Pop ( rbx ) ; __ decl ( rax ) ; __ PushReturnAddressFrom ( kScratchRegister ) ; } else { __ PushReturnAddressFrom ( kScratchRegister ) ; __ AssertUndefinedOrAllocationSite ( rbx ) ; } if ( mode == InterpreterPushArgsMode :: kArrayFunction ) { __ AssertFunction ( rdi ) ; Handle < Code > code = BUILTIN_CODE ( masm -> isolate ( ) , ArrayConstructorImpl ) ; __ Jump ( code , RelocInfo :: CODE_TARGET ) ; } else if ( mode == InterpreterPushArgsMode :: kWithFinalSpread ) { __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , ConstructWithSpread ) , RelocInfo :: CODE_TARGET ) ; } else { DCHECK_EQ ( InterpreterPushArgsMode :: kOther , mode ) ; __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , Construct ) , RelocInfo :: CODE_TARGET ) ; } __ bind ( & stack_overflow ) ; { __ TailCallRuntime ( Runtime :: kThrowStackOverflow ) ; __ int3 ( ) ; } }
TRANSPORTDEC_ERROR transportDec_OutOfBandConfig ( HANDLE_TRANSPORTDEC hTp , UCHAR * conf , const UINT length , UINT layer ) { int i ; TRANSPORTDEC_ERROR err = TRANSPORTDEC_OK ; FDK_BITSTREAM bs ; HANDLE_FDK_BITSTREAM hBs = & bs ; int fConfigFound = 0 ; UCHAR configChanged = 0 ; UCHAR configMode = AC_CM_DET_CFG_CHANGE ; UCHAR tmpConf [ 1024 ] = { 0 } ; if ( length > 1024 ) { return TRANSPORTDEC_UNSUPPORTED_FORMAT ; } FDKmemcpy ( tmpConf , conf , length ) ; FDKinitBitStream ( hBs , tmpConf , 1024 , length < < 3 , BS_READER ) ; for ( i = 0 ; i < 2 ; i ++ ) { if ( i > 0 ) { FDKpushBack ( hBs , ( INT ) length * 8 - ( INT ) FDKgetValidBits ( hBs ) ) ; configMode = AC_CM_ALLOC_MEM ; } switch ( hTp -> transportFmt ) { case TT_MP4_LATM_MCP0 : case TT_MP4_LATM_MCP1 : case TT_MP4_LOAS : { if ( layer != 0 ) { return TRANSPORTDEC_INVALID_PARAMETER ; } CLatmDemux * pLatmDemux = & hTp -> parser . latm ; err = CLatmDemux_ReadStreamMuxConfig ( hBs , pLatmDemux , & hTp -> callbacks , hTp -> asc , & fConfigFound , configMode , configChanged ) ; if ( err != TRANSPORTDEC_OK ) { return err ; } } break ; default : fConfigFound = 1 ; err = AudioSpecificConfig_Parse ( & hTp -> asc [ ( 1 * 1 ) ] , hBs , 1 , & hTp -> callbacks , configMode , configChanged , AOT_NULL_OBJECT ) ; if ( err == TRANSPORTDEC_OK ) { int errC ; hTp -> asc [ layer ] = hTp -> asc [ ( 1 * 1 ) ] ; errC = hTp -> callbacks . cbUpdateConfig ( hTp -> callbacks . cbUpdateConfigData , & hTp -> asc [ layer ] , hTp -> asc [ layer ] . configMode , & hTp -> asc [ layer ] . AacConfigChanged ) ; if ( errC != 0 ) { err = TRANSPORTDEC_PARSE_ERROR ; } } break ; case TT_DRM : fConfigFound = 1 ; err = DrmRawSdcAudioConfig_Parse ( & hTp -> asc [ layer ] , hBs , & hTp -> callbacks , configMode , configChanged ) ; if ( err == TRANSPORTDEC_OK ) { int errC ; errC = hTp -> callbacks . cbUpdateConfig ( hTp -> callbacks . cbUpdateConfigData , & hTp -> asc [ layer ] , hTp -> asc [ layer ] . configMode , & hTp -> asc [ layer ] . AacConfigChanged ) ; if ( errC != 0 ) { err = TRANSPORTDEC_PARSE_ERROR ; } } break ; } if ( err == TRANSPORTDEC_OK ) { if ( ( i == 0 ) && ( hTp -> asc [ layer ] . AacConfigChanged || hTp -> asc [ layer ] . SbrConfigChanged || hTp -> asc [ layer ] . SacConfigChanged ) ) { int errC ; configChanged = 1 ; errC = hTp -> callbacks . cbFreeMem ( hTp -> callbacks . cbFreeMemData , & hTp -> asc [ layer ] ) ; if ( errC != 0 ) { err = TRANSPORTDEC_PARSE_ERROR ; } } } } if ( err == TRANSPORTDEC_OK && fConfigFound ) { hTp -> flags |= TPDEC_CONFIG_FOUND ; } return err ; }
NativeObject :: shrinkElements ( JSContext * cx , uint32_t reqCapacity ) { MOZ_ASSERT ( canHaveNonEmptyElements ( ) ) ; if ( denseElementsAreCopyOnWrite ( ) ) MOZ_CRASH ( ) ; if ( ! hasDynamicElements ( ) ) return ; uint32_t numShifted = getElementsHeader ( ) -> numShiftedElements ( ) ; if ( numShifted > 0 ) { maybeMoveShiftedElements ( ) ; numShifted = getElementsHeader ( ) -> numShiftedElements ( ) ; } uint32_t oldCapacity = getDenseCapacity ( ) ; MOZ_ASSERT ( reqCapacity < oldCapacity ) ; uint32_t newAllocated = 0 ; MOZ_ALWAYS_TRUE ( goodElementsAllocationAmount ( cx , reqCapacity + numShifted , 0 , & newAllocated ) ) ; MOZ_ASSERT ( oldCapacity <= MAX_DENSE_ELEMENTS_COUNT ) ; uint32_t oldAllocated = oldCapacity + ObjectElements :: VALUES_PER_HEADER + numShifted ; if ( newAllocated == oldAllocated ) return ; MOZ_ASSERT ( newAllocated > ObjectElements :: VALUES_PER_HEADER ) ; uint32_t newCapacity = newAllocated - ObjectElements :: VALUES_PER_HEADER - numShifted ; MOZ_ASSERT ( newCapacity <= MAX_DENSE_ELEMENTS_COUNT ) ; HeapSlot * oldHeaderSlots = reinterpret_cast < HeapSlot * > ( getUnshiftedElementsHeader ( ) ) ; HeapSlot * newHeaderSlots = ReallocateObjectBuffer < HeapSlot > ( cx , this , oldHeaderSlots , oldAllocated , newAllocated ) ; if ( ! newHeaderSlots ) { cx -> recoverFromOutOfMemory ( ) ; return ; } ObjectElements * newheader = reinterpret_cast < ObjectElements * > ( newHeaderSlots ) ; elements_ = newheader -> elements ( ) + numShifted ; getElementsHeader ( ) -> capacity = newCapacity ; }
nsresult nsZipDataStream :: ProcessData ( nsIRequest * aRequest , nsISupports * aContext , char * aBuffer , uint64_t aOffset , uint32_t aCount ) { mHeader -> mCRC = crc32 ( mHeader -> mCRC , reinterpret_cast < const unsigned char * > ( aBuffer ) , aCount ) ; MOZ_ASSERT ( aCount <= INT32_MAX ) ; nsCOMPtr < nsIInputStream > stream ; nsresult rv = NS_NewByteInputStream ( getter_AddRefs ( stream ) , aBuffer , aCount ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; rv = mOutput -> OnDataAvailable ( aRequest , aContext , stream , aOffset , aCount ) ; mHeader -> mUSize += aCount ; return rv ; }
nsresult ProxyAutoConfig :: SetupJS ( ) { mJSNeedsSetup = false ; MOZ_ASSERT ( ! GetRunning ( ) , "JIT is running" ) ; delete mJSContext ; mJSContext = nullptr ; if ( mConcatenatedPACData . IsEmpty ( ) ) return NS_ERROR_FAILURE ; NS_GetCurrentThread ( ) -> SetCanInvokeJS ( true ) ; mJSContext = JSContextWrapper :: Create ( mExtraHeapSize ) ; if ( ! mJSContext ) return NS_ERROR_FAILURE ; JSContext * cx = mJSContext -> Context ( ) ; JSAutoRealm ar ( cx , mJSContext -> Global ( ) ) ; AutoPACErrorReporter aper ( cx ) ; bool isDataURI = nsDependentCSubstring ( mPACURI , 0 , 5 ) . LowerCaseEqualsASCII ( "data:" , 5 ) ; SetRunning ( this ) ; JS :: Rooted < JSObject * > global ( cx , mJSContext -> Global ( ) ) ; auto CompilePACScript = [ this ] ( JSContext * cx ) -> JSScript * { JS :: CompileOptions options ( cx ) ; options . setFileAndLine ( this -> mPACURI . get ( ) , 1 ) ; const char * scriptData = this -> mConcatenatedPACData . get ( ) ; size_t scriptLength = this -> mConcatenatedPACData . Length ( ) ; if ( mozilla :: IsValidUtf8 ( scriptData , scriptLength ) ) { JS :: SourceText < Utf8Unit > srcBuf ; if ( ! srcBuf . init ( cx , scriptData , scriptLength , JS :: SourceOwnership :: Borrowed ) ) { return nullptr ; } return JS :: CompileDontInflate ( cx , options , srcBuf ) ; } NS_ConvertASCIItoUTF16 inflated ( this -> mConcatenatedPACData ) ; JS :: SourceText < char16_t > source ; if ( ! source . init ( cx , inflated . get ( ) , inflated . Length ( ) , JS :: SourceOwnership :: Borrowed ) ) { return nullptr ; } return JS :: Compile ( cx , options , source ) ; } ; JS :: Rooted < JSScript * > script ( cx , CompilePACScript ( cx ) ) ; if ( ! script || ! JS_ExecuteScript ( cx , script ) ) { nsString alertMessage ( NS_LITERAL_STRING ( "PAC file failed to install from " ) ) ; if ( isDataURI ) { alertMessage += NS_LITERAL_STRING ( "data: URI" ) ; } else { alertMessage += NS_ConvertUTF8toUTF16 ( mPACURI ) ; } PACLogToConsole ( alertMessage ) ; SetRunning ( nullptr ) ; return NS_ERROR_FAILURE ; } SetRunning ( nullptr ) ; mJSContext -> SetOK ( ) ; nsString alertMessage ( NS_LITERAL_STRING ( "PAC file installed from " ) ) ; if ( isDataURI ) { alertMessage += NS_LITERAL_STRING ( "data: URI" ) ; } else { alertMessage += NS_ConvertUTF8toUTF16 ( mPACURI ) ; } PACLogToConsole ( alertMessage ) ; mConcatenatedPACData . Truncate ( ) ; mPACURI . Truncate ( ) ; return NS_OK ; }
mozilla :: ipc :: IPCResult BrowserParent :: RecvRequestFocus ( const bool & aCanRaise ) { LOGBROWSERFOCUS ( ( "RecvRequestFocus %p, aCanRaise: %d" , this , aCanRaise ) ) ; if ( BrowserBridgeParent * bridgeParent = GetBrowserBridgeParent ( ) ) { mozilla :: Unused < < bridgeParent -> SendRequestFocus ( aCanRaise ) ; return IPC_OK ( ) ; } if ( ! mFrameElement ) { return IPC_OK ( ) ; } nsContentUtils :: RequestFrameFocus ( * mFrameElement , aCanRaise ) ; return IPC_OK ( ) ; }
IGNITION_HANDLER ( Construct , InterpreterAssembler ) { Node * new_target = GetAccumulator ( ) ; Node * constructor = LoadRegisterAtOperandIndex ( 0 ) ; RegListNodePair args = GetRegisterListAtOperandIndex ( 1 ) ; Node * slot_id = BytecodeOperandIdx ( 3 ) ; Node * feedback_vector = LoadFeedbackVector ( ) ; Node * context = GetContext ( ) ; Node * result = Construct ( constructor , context , new_target , args , slot_id , feedback_vector ) ; SetAccumulator ( result ) ; Dispatch ( ) ; }
base :: Optional < ParseResult > MakeParameterListFromTypes ( ParseResultIterator * child_results ) { auto types = child_results -> NextAs < TypeList > ( ) ; ParameterList result ; result . types = std :: move ( types ) ; result . has_varargs = has_varargs ; return ParseResult { std :: move ( result ) } ; }
void InterpreterAssembler :: ToNumberOrNumeric ( Object :: Conversion mode ) { Node * object = GetAccumulator ( ) ; Node * context = GetContext ( ) ; Variable var_type_feedback ( this , MachineRepresentation :: kTaggedSigned ) ; Variable var_result ( this , MachineRepresentation :: kTagged ) ; Label if_done ( this ) , if_objectissmi ( this ) , if_objectisheapnumber ( this ) , if_objectisother ( this , Label :: kDeferred ) ; GotoIf ( TaggedIsSmi ( object ) , & if_objectissmi ) ; Branch ( IsHeapNumber ( object ) , & if_objectisheapnumber , & if_objectisother ) ; BIND ( & if_objectissmi ) ; { var_result . Bind ( object ) ; var_type_feedback . Bind ( SmiConstant ( BinaryOperationFeedback :: kSignedSmall ) ) ; Goto ( & if_done ) ; } BIND ( & if_objectisheapnumber ) ; { var_result . Bind ( object ) ; var_type_feedback . Bind ( SmiConstant ( BinaryOperationFeedback :: kNumber ) ) ; Goto ( & if_done ) ; } BIND ( & if_objectisother ) ; { auto builtin = Builtins :: kNonNumberToNumber ; if ( mode == Object :: Conversion :: kToNumeric ) { builtin = Builtins :: kNonNumberToNumeric ; Label not_bigint ( this ) ; GotoIfNot ( IsBigInt ( object ) , & not_bigint ) ; { var_result . Bind ( object ) ; var_type_feedback . Bind ( SmiConstant ( BinaryOperationFeedback :: kBigInt ) ) ; Goto ( & if_done ) ; } BIND ( & not_bigint ) ; } var_result . Bind ( CallBuiltin ( builtin , context , object ) ) ; var_type_feedback . Bind ( SmiConstant ( BinaryOperationFeedback :: kAny ) ) ; Goto ( & if_done ) ; } BIND ( & if_done ) ; Node * slot_index = BytecodeOperandIdx ( 0 ) ; Node * feedback_vector = LoadFeedbackVector ( ) ; UpdateFeedback ( var_type_feedback . value ( ) , feedback_vector , slot_index ) ; SetAccumulator ( var_result . value ( ) ) ; Dispatch ( ) ; }
void nsGlobalWindowOuter :: SetCursorOuter ( const nsAString & aCursor , ErrorResult & aError ) { StyleCursorKind cursor ; if ( aCursor . EqualsLiteral ( "auto" ) ) { cursor = StyleCursorKind :: Auto ; } else { nsCSSKeyword keyword = nsCSSKeywords :: LookupKeyword ( aCursor ) ; int32_t c ; if ( ! nsCSSProps :: FindKeyword ( keyword , nsCSSProps :: kCursorKTable , c ) ) { return ; } cursor = static_cast < StyleCursorKind > ( c ) ; } RefPtr < nsPresContext > presContext ; if ( mDocShell ) { presContext = mDocShell -> GetPresContext ( ) ; } if ( presContext ) { nsCOMPtr < nsIPresShell > presShell = mDocShell -> GetPresShell ( ) ; if ( ! presShell ) { aError . Throw ( NS_ERROR_FAILURE ) ; return ; } nsViewManager * vm = presShell -> GetViewManager ( ) ; if ( ! vm ) { aError . Throw ( NS_ERROR_FAILURE ) ; return ; } nsView * rootView = vm -> GetRootView ( ) ; if ( ! rootView ) { aError . Throw ( NS_ERROR_FAILURE ) ; return ; } nsIWidget * widget = rootView -> GetNearestWidget ( nullptr ) ; if ( ! widget ) { aError . Throw ( NS_ERROR_FAILURE ) ; return ; } aError = presContext -> EventStateManager ( ) -> SetCursor ( cursor , nullptr , false , 0.0f , 0.0f , widget , true ) ; } }
% % o image : The image . % % o exception : return any errors or warnings in this structure . % * / static MagickBooleanType WriteMAPImage ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { MagickBooleanType status ; register const Quantum * p ; register ssize_t i , x ; register unsigned char * q ; size_t depth , packet_size ; ssize_t y ; unsigned char * colormap , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; status = OpenBlob ( image_info , image , WriteBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( status ) ; ( void ) TransformImageColorspace ( image , sRGBColorspace , exception ) ; if ( IsPaletteImage ( image ) == MagickFalse ) ( void ) SetImageType ( image , PaletteType , exception ) ; depth = GetImageQuantumDepth ( image , MagickTrue ) ; packet_size = ( size_t ) ( depth / 8 ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , packet_size * sizeof ( * pixels ) ) ; packet_size = ( size_t ) ( image -> colors > 256 ? 6UL : 3UL ) ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , packet_size * sizeof ( * colormap ) ) ; if ( ( pixels == ( unsigned char * ) NULL ) || ( colormap == ( unsigned char * ) NULL ) ) ThrowWriterException ( ResourceLimitError , "MemoryAllocationFailed" ) ; q = colormap ; q = colormap ; if ( image -> colors <= 256 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { * q ++ = ( unsigned char ) ScaleQuantumToChar ( image -> colormap [ i ] . red ) ; * q ++ = ( unsigned char ) ScaleQuantumToChar ( image -> colormap [ i ] . green ) ; * q ++ = ( unsigned char ) ScaleQuantumToChar ( image -> colormap [ i ] . blue ) ; } else for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { * q ++ = ( unsigned char ) ( ScaleQuantumToShort ( image -> colormap [ i ] . red ) > > 8 ) ; * q ++ = ( unsigned char ) ( ScaleQuantumToShort ( image -> colormap [ i ] . red ) & 0xff ) ; * q ++ = ( unsigned char ) ( ScaleQuantumToShort ( image -> colormap [ i ] . green ) > > 8 ) ; * q ++ = ( unsigned char ) ( ScaleQuantumToShort ( image -> colormap [ i ] . green ) & 0xff ) ; ; * q ++ = ( unsigned char ) ( ScaleQuantumToShort ( image -> colormap [ i ] . blue ) > > 8 ) ; * q ++ = ( unsigned char ) ( ScaleQuantumToShort ( image -> colormap [ i ] . blue ) & 0xff ) ; } ( void ) WriteBlob ( image , packet_size * image -> colors , colormap ) ; colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = GetVirtualPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( p == ( const Quantum * ) NULL ) break ; q = pixels ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> colors > 256 ) * q ++ = ( unsigned char ) ( ( size_t ) GetPixelIndex ( image , p ) > > 8 ) ; * q ++ = ( unsigned char ) GetPixelIndex ( image , p ) ; p += GetPixelChannels ( image ) ; }
nsContentUtils :: IsAllowedNonCorsContentType ( const nsACString & aHeaderValue ) { nsAutoCString contentType ; nsAutoCString unused ; nsresult rv = NS_ParseContentType ( aHeaderValue , contentType , unused ) ; if ( NS_FAILED ( rv ) ) { return false ; } return contentType . LowerCaseEqualsLiteral ( "text/plain" ) || contentType . LowerCaseEqualsLiteral ( "application/x-www-form-urlencoded" ) || contentType . LowerCaseEqualsLiteral ( "multipart/form-data" ) ; }
cib_remote_msg ( gpointer data ) { const char * value = NULL ; xmlNode * command = NULL ; cib_client_t * client = data ; crm_trace ( "%s callback" , client -> encrypted ? "secure" : "clear-text" ) ; command = crm_recv_remote_msg ( client -> session , client -> encrypted ) ; if ( command == NULL ) { return - 1 ; } value = crm_element_name ( command ) ; if ( safe_str_neq ( value , "cib_command" ) ) { crm_log_xml_trace ( command , "Bad command: " ) ; goto bail ; } if ( client -> name == NULL ) { value = crm_element_value ( command , F_CLIENTNAME ) ; if ( value == NULL ) { client -> name = strdup ( client -> id ) ; } else { client -> name = strdup ( value ) ; } } if ( client -> callback_id == NULL ) { value = crm_element_value ( command , F_CIB_CALLBACK_TOKEN ) ; if ( value != NULL ) { client -> callback_id = strdup ( value ) ; crm_trace ( "Callback channel for %s is %s" , client -> id , client -> callback_id ) ; } else { client -> callback_id = strdup ( client -> id ) ; } } xml_remove_prop ( command , F_ORIG ) ; xml_remove_prop ( command , F_CIB_HOST ) ; xml_remove_prop ( command , F_CIB_GLOBAL_UPDATE ) ; crm_xml_add ( command , F_TYPE , T_CIB ) ; crm_xml_add ( command , F_CIB_CLIENTID , client -> id ) ; crm_xml_add ( command , F_CIB_CLIENTNAME , client -> name ) ; #if ENABLE_ACL crm_xml_add ( command , F_CIB_USER , client -> user ) ; #endif if ( crm_element_value ( command , F_CIB_CALLID ) == NULL ) { char * call_uuid = crm_generate_uuid ( ) ; crm_xml_add ( command , F_CIB_CALLID , call_uuid ) ; free ( call_uuid ) ; } if ( crm_element_value ( command , F_CIB_CALLOPTS ) == NULL ) { crm_xml_add_int ( command , F_CIB_CALLOPTS , 0 ) ; } crm_log_xml_trace ( command , "Remote command: " ) ; cib_common_callback_worker ( 0 , 0 , command , client , TRUE ) ; bail : free_xml ( command ) ; command = NULL ; return 0 ; }
void rfbScaledScreenUpdateRect ( rfbScreenInfoPtr screen , rfbScreenInfoPtr ptr , int x0 , int y0 , int w0 , int h0 ) { int x , y , w , v , z ; int x1 , y1 , w1 , h1 ; int bitsPerPixel , bytesPerPixel , bytesPerLine , areaX , areaY , area2 ; unsigned char * srcptr , * dstptr ; if ( screen == ptr ) return ; x1 = x0 ; y1 = y0 ; w1 = w0 ; h1 = h0 ; rfbScaledCorrection ( screen , ptr , & x1 , & y1 , & w1 , & h1 , "rfbScaledScreenUpdateRect" ) ; x0 = ScaleX ( ptr , screen , x1 ) ; y0 = ScaleY ( ptr , screen , y1 ) ; w0 = ScaleX ( ptr , screen , w1 ) ; h0 = ScaleY ( ptr , screen , h1 ) ; bitsPerPixel = screen -> bitsPerPixel ; bytesPerPixel = bitsPerPixel / 8 ; bytesPerLine = w1 * bytesPerPixel ; srcptr = ( unsigned char * ) ( screen -> frameBuffer + ( y0 * screen -> paddedWidthInBytes + x0 * bytesPerPixel ) ) ; dstptr = ( unsigned char * ) ( ptr -> frameBuffer + ( y1 * ptr -> paddedWidthInBytes + x1 * bytesPerPixel ) ) ; areaX = ScaleX ( ptr , screen , 1 ) ; areaY = ScaleY ( ptr , screen , 1 ) ; area2 = areaX * areaY ; if ( ( x1 + w1 ) > ( ptr -> width ) ) { if ( x1 == 0 ) w1 = ptr -> width ; else x1 = ptr -> width - w1 ; } if ( ( y1 + h1 ) > ( ptr -> height ) ) { if ( y1 == 0 ) h1 = ptr -> height ; else y1 = ptr -> height - h1 ; } if ( screen -> serverFormat . trueColour ) { unsigned char * srcptr2 ; unsigned long pixel_value , red , green , blue ; unsigned int redShift = screen -> serverFormat . redShift ; unsigned int greenShift = screen -> serverFormat . greenShift ; unsigned int blueShift = screen -> serverFormat . blueShift ; unsigned long redMax = screen -> serverFormat . redMax ; unsigned long greenMax = screen -> serverFormat . greenMax ; unsigned long blueMax = screen -> serverFormat . blueMax ; for ( y = 0 ; y < h1 ; y ++ ) { for ( x = 0 ; x < w1 ; x ++ ) { red = green = blue = 0 ; for ( w = 0 ; w < areaX ; w ++ ) { for ( v = 0 ; v < areaY ; v ++ ) { srcptr2 = & srcptr [ ( ( ( x * areaX ) + w ) * bytesPerPixel ) + ( v * screen -> paddedWidthInBytes ) ] ; pixel_value = 0 ; switch ( bytesPerPixel ) { case 4 : pixel_value = * ( ( unsigned int * ) srcptr2 ) ; break ; case 2 : pixel_value = * ( ( unsigned short * ) srcptr2 ) ; break ; case 1 : pixel_value = * ( ( unsigned char * ) srcptr2 ) ; break ; default : for ( z = 0 ; z < bytesPerPixel ; z ++ ) pixel_value += ( srcptr2 [ z ] < < ( 8 * z ) ) ; break ; } red += ( ( pixel_value > > redShift ) & redMax ) ; green += ( ( pixel_value > > greenShift ) & greenMax ) ; blue += ( ( pixel_value > > blueShift ) & blueMax ) ; } } red /= area2 ; green /= area2 ; blue /= area2 ; pixel_value = ( ( red & redMax ) < < redShift ) | ( ( green & greenMax ) < < greenShift ) | ( ( blue & blueMax ) < < blueShift ) ; switch ( bytesPerPixel ) { case 4 : * ( ( unsigned int * ) dstptr ) = ( unsigned int ) pixel_value ; break ; case 2 : * ( ( unsigned short * ) dstptr ) = ( unsigned short ) pixel_value ; break ; case 1 : * ( ( unsigned char * ) dstptr ) = ( unsigned char ) pixel_value ; break ; default : for ( z = 0 ; z < bytesPerPixel ; z ++ ) dstptr [ z ] = ( pixel_value > > ( 8 * z ) ) & 0xff ; break ; } dstptr += bytesPerPixel ; } srcptr += ( screen -> paddedWidthInBytes * areaY ) ; dstptr += ( ptr -> paddedWidthInBytes - bytesPerLine ) ; } } else { for ( y = y1 ; y < ( y1 + h1 ) ; y ++ ) { for ( x = x1 ; x < ( x1 + w1 ) ; x ++ ) memcpy ( & ptr -> frameBuffer [ ( y * ptr -> paddedWidthInBytes ) + ( x * bytesPerPixel ) ] , & screen -> frameBuffer [ ( y * areaY * screen -> paddedWidthInBytes ) + ( x * areaX * bytesPerPixel ) ] , bytesPerPixel ) ; } } }
size_t EstimateNativeAllocationsSize ( const WasmModule * module ) { size_t estimate = sizeof ( WasmInstanceNativeAllocations ) + ( 1 * kPointerSize * module -> num_imported_mutable_globals ) + ( 2 * kPointerSize * module -> num_imported_functions ) ; for ( auto & table : module -> tables ) { estimate += 3 * kPointerSize * table . initial_size ; } return estimate ; }
ElementAccess AccessBuilder :: ForFixedDoubleArrayElement ( ) { ElementAccess access = { kTaggedBase , FixedDoubleArray :: kHeaderSize , TypeCache :: Get ( ) . kFloat64 , MachineType :: Float64 ( ) , kNoWriteBarrier } ; return access ; }
uint32_t sftp_parse_handle ( struct sftpjob * job , struct handleid * id ) { uint32_t len , rc ; if ( ( rc = sftp_parse_uint32 ( job , & len ) ) != SSH_FX_OK || len != 8 || ( rc = sftp_parse_uint32 ( job , & id -> id ) ) != SSH_FX_OK || ( rc = sftp_parse_uint32 ( job , & id -> tag ) != SSH_FX_OK ) ) return rc ; return SSH_FX_OK ; }
void Compute ( OpKernelContext * ctx ) override { StagingMap < Ordered > * map = nullptr ; OP_REQUIRES_OK ( ctx , GetStagingMap ( ctx , def ( ) , & map ) ) ; core :: ScopedUnref scope ( map ) ; typename StagingMap < Ordered > :: OptionalTuple tuple ; const Tensor * key_tensor ; const Tensor * indices_tensor ; OpInputList values_tensor ; OP_REQUIRES_OK ( ctx , ctx -> input ( "key" , & key_tensor ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( "indices" , & indices_tensor ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input_list ( "values" , & values_tensor ) ) ; Tensor key ( * key_tensor ) ; for ( std :: size_t i = 0 ; i < values_tensor . size ( ) ; ++ i ) { tuple . push_back ( values_tensor [ i ] ) ; } OP_REQUIRES_OK ( ctx , map -> put ( & key , indices_tensor , & tuple ) ) ; }
int bus_verify_polkit_async ( sd_bus_message * call , int capability , const char * action , const char * * details , bool interactive , uid_t good_user , Hashmap * * registry , sd_bus_error * error ) { #if ENABLE_POLKIT _cleanup_ ( sd_bus_message_unrefp ) sd_bus_message * pk = NULL ; AsyncPolkitQuery * q ; const char * sender , * * k , * * v ; sd_bus_message_handler_t callback ; void * userdata ; int c ; #endif int r ; assert ( call ) ; assert ( action ) ; assert ( registry ) ; r = check_good_user ( call , good_user ) ; if ( r != 0 ) return r ; #if ENABLE_POLKIT q = hashmap_get ( * registry , call ) ; if ( q ) { int authorized , challenge ; assert ( q -> reply ) ; if ( sd_bus_message_is_method_error ( q -> reply , NULL ) ) { const sd_bus_error * e ; e = sd_bus_message_get_error ( q -> reply ) ; if ( sd_bus_error_has_name ( e , SD_BUS_ERROR_SERVICE_UNKNOWN ) || sd_bus_error_has_name ( e , SD_BUS_ERROR_NAME_HAS_NO_OWNER ) ) return - EACCES ; sd_bus_error_copy ( error , e ) ; return - sd_bus_error_get_errno ( e ) ; } r = sd_bus_message_enter_container ( q -> reply , 'r' , "bba{ss}" ) ; if ( r >= 0 ) r = sd_bus_message_read ( q -> reply , "bb" , & authorized , & challenge ) ; if ( r < 0 ) return r ; if ( authorized ) return 1 ; if ( challenge ) return sd_bus_error_set ( error , SD_BUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED , "Interactive authentication required." ) ; return - EACCES ; } #endif r = sd_bus_query_sender_privilege ( call , capability ) ; if ( r < 0 ) return r ; else if ( r > 0 ) return 1 ; #if ENABLE_POLKIT if ( sd_bus_get_current_message ( call -> bus ) != call ) return - EINVAL ; callback = sd_bus_get_current_handler ( call -> bus ) ; if ( ! callback ) return - EINVAL ; userdata = sd_bus_get_current_userdata ( call -> bus ) ; sender = sd_bus_message_get_sender ( call ) ; if ( ! sender ) return - EBADMSG ; c = sd_bus_message_get_allow_interactive_authorization ( call ) ; if ( c < 0 ) return c ; if ( c > 0 ) interactive = true ; r = hashmap_ensure_allocated ( registry , NULL ) ; if ( r < 0 ) return r ; r = sd_bus_message_new_method_call ( call -> bus , & pk , "org.freedesktop.PolicyKit1" , "/org/freedesktop/PolicyKit1/Authority" , "org.freedesktop.PolicyKit1.Authority" , "CheckAuthorization" ) ; if ( r < 0 ) return r ; r = sd_bus_message_append ( pk , "(sa{sv})s" , "system-bus-name" , 1 , "name" , "s" , sender , action ) ; if ( r < 0 ) return r ; r = sd_bus_message_open_container ( pk , 'a' , "{ss}" ) ; if ( r < 0 ) return r ; STRV_FOREACH_PAIR ( k , v , details ) { r = sd_bus_message_append ( pk , "{ss}" , * k , * v ) ; if ( r < 0 ) return r ; } r = sd_bus_message_close_container ( pk ) ; if ( r < 0 ) return r ; r = sd_bus_message_append ( pk , "us" , interactive , NULL ) ; if ( r < 0 ) return r ; q = new0 ( AsyncPolkitQuery , 1 ) ; if ( ! q ) return - ENOMEM ; q -> request = sd_bus_message_ref ( call ) ; q -> callback = callback ; q -> userdata = userdata ; r = hashmap_put ( * registry , call , q ) ; if ( r < 0 ) { async_polkit_query_free ( q ) ; return r ; } q -> registry = * registry ; r = sd_bus_call_async ( call -> bus , & q -> slot , pk , async_polkit_callback , q , 0 ) ; if ( r < 0 ) { async_polkit_query_free ( q ) ; return r ; } return 0 ; #endif return - EACCES ; }
static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { struct flowi6 fl6 ; dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; if ( ! dst ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; dccp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req && ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
static int adts_decode_extradata ( AVFormatContext * s , ADTSContext * adts , const uint8_t * buf , int size ) { GetBitContext gb ; PutBitContext pb ; MPEG4AudioConfig m4ac ; int off ; init_get_bits ( & gb , buf , size * 8 ) ; off = avpriv_mpeg4audio_get_config2 ( & m4ac , buf , size , 1 , s ) ; if ( off < 0 ) return off ; skip_bits_long ( & gb , off ) ; adts -> objecttype = m4ac . object_type - 1 ; adts -> sample_rate_index = m4ac . sampling_index ; adts -> channel_conf = m4ac . chan_config ; if ( adts -> objecttype > 3U ) { av_log ( s , AV_LOG_ERROR , "MPEG-4 AOT %d is not allowed in ADTS\n" , adts -> objecttype + 1 ) ; return AVERROR_INVALIDDATA ; } if ( adts -> sample_rate_index == 15 ) { av_log ( s , AV_LOG_ERROR , "Escape sample rate index illegal in ADTS\n" ) ; return AVERROR_INVALIDDATA ; } if ( get_bits ( & gb , 1 ) ) { av_log ( s , AV_LOG_ERROR , "960/120 MDCT window is not allowed in ADTS\n" ) ; return AVERROR_INVALIDDATA ; } if ( get_bits ( & gb , 1 ) ) { av_log ( s , AV_LOG_ERROR , "Scalable configurations are not allowed in ADTS\n" ) ; return AVERROR_INVALIDDATA ; } if ( get_bits ( & gb , 1 ) ) { av_log ( s , AV_LOG_ERROR , "Extension flag is not allowed in ADTS\n" ) ; return AVERROR_INVALIDDATA ; } if ( ! adts -> channel_conf ) { init_put_bits ( & pb , adts -> pce_data , MAX_PCE_SIZE ) ; put_bits ( & pb , 3 , 5 ) ; adts -> pce_size = ( ff_copy_pce_data ( & pb , & gb ) + 3 ) / 8 ; flush_put_bits ( & pb ) ; } adts -> write_adts = 1 ; return 0 ; }
static OPJ_BOOL opj_j2k_is_cinema_compliant ( opj_image_t * image , OPJ_UINT16 rsiz , opj_event_mgr_t * p_manager ) { OPJ_UINT32 i ; if ( image -> numcomps != 3 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-3 (2k dc profile) requires:\n" "3 components" "-> Number of components of input image (%d) is not compliant\n" "-> Non-profile-3 codestream will be generated\n" , image -> numcomps ) ; return OPJ_FALSE ; } for ( i = 0 ; i < image -> numcomps ; i ++ ) { if ( ( image -> comps [ i ] . bpp != 12 ) | ( image -> comps [ i ] . sgnd ) ) { char signed_str [ ] = "signed" ; char unsigned_str [ ] = "unsigned" ; char * tmp_str = image -> comps [ i ] . sgnd ? signed_str : unsigned_str ; opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-3 (2k dc profile) requires:\n" "Precision of each component shall be 12 bits unsigned" "-> At least component %d of input image (%d bits, %s) is not compliant\n" "-> Non-profile-3 codestream will be generated\n" , i , image -> comps [ i ] . bpp , tmp_str ) ; return OPJ_FALSE ; } } switch ( rsiz ) { case OPJ_PROFILE_CINEMA_2K : if ( ( ( image -> comps [ 0 ] . w > 2048 ) | ( image -> comps [ 0 ] . h > 1080 ) ) ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-3 (2k dc profile) requires:\n" "width <= 2048 and height <= 1080\n" "-> Input image size %d x %d is not compliant\n" "-> Non-profile-3 codestream will be generated\n" , image -> comps [ 0 ] . w , image -> comps [ 0 ] . h ) ; return OPJ_FALSE ; } break ; case OPJ_PROFILE_CINEMA_4K : if ( ( ( image -> comps [ 0 ] . w > 4096 ) | ( image -> comps [ 0 ] . h > 2160 ) ) ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG 2000 Profile-4 (4k dc profile) requires:\n" "width <= 4096 and height <= 2160\n" "-> Image size %d x %d is not compliant\n" "-> Non-profile-4 codestream will be generated\n" , image -> comps [ 0 ] . w , image -> comps [ 0 ] . h ) ; return OPJ_FALSE ; } break ; default : break ; } return OPJ_TRUE ; }
static double get_rate_correction_factor ( const VP9_COMP * cpi ) { if ( cpi -> common . frame_type == KEY_FRAME ) { return cpi -> rc . key_frame_rate_correction_factor ; } else { if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) && ! cpi -> rc . is_src_frame_alt_ref && ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) return cpi -> rc . gf_rate_correction_factor ; else return cpi -> rc . rate_correction_factor ; } }
Function * ESTreeIRGen :: genES5Function ( Identifier originalName , Variable * lazyClosureAlias , ESTree :: FunctionLikeNode * functionNode , bool isGeneratorInnerFunction ) { assert ( functionNode && "Function AST cannot be null" ) ; auto * body = ESTree :: getBlockStatement ( functionNode ) ; assert ( body && "body of ES5 function cannot be null" ) ; Function * newFunction = isGeneratorInnerFunction ? Builder . createGeneratorInnerFunction ( originalName , Function :: DefinitionKind :: ES5Function , ESTree :: isStrict ( functionNode -> strictness ) , functionNode -> getSourceRange ( ) , nullptr ) : Builder . createFunction ( originalName , Function :: DefinitionKind :: ES5Function , ESTree :: isStrict ( functionNode -> strictness ) , functionNode -> getSourceRange ( ) , false , nullptr ) ; newFunction -> setLazyClosureAlias ( lazyClosureAlias ) ; if ( auto * bodyBlock = llvh :: dyn_cast < ESTree :: BlockStatementNode > ( body ) ) { if ( bodyBlock -> isLazyFunctionBody ) { newFunction -> setLazyScope ( saveCurrentScope ( ) ) ; auto & lazySource = newFunction -> getLazySource ( ) ; lazySource . bufferId = bodyBlock -> bufferId ; lazySource . nodeKind = getLazyFunctionKind ( functionNode ) ; lazySource . functionRange = functionNode -> getSourceRange ( ) ; newFunction -> setExpectedParamCountIncludingThis ( countExpectedArgumentsIncludingThis ( functionNode ) ) ; return newFunction ; } } FunctionContext newFunctionContext { this , newFunction , functionNode -> getSemInfo ( ) } ; if ( isGeneratorInnerFunction ) { auto * initGenBB = Builder . createBasicBlock ( newFunction ) ; Builder . setInsertionBlock ( initGenBB ) ; Builder . createStartGeneratorInst ( ) ; auto * prologueBB = Builder . createBasicBlock ( newFunction ) ; auto * prologueResumeIsReturn = Builder . createAllocStackInst ( genAnonymousLabelName ( "isReturn_prologue" ) ) ; genResumeGenerator ( nullptr , prologueResumeIsReturn , prologueBB ) ; if ( hasSimpleParams ( functionNode ) ) { Builder . setInsertionBlock ( prologueBB ) ; emitFunctionPrologue ( functionNode , prologueBB , InitES5CaptureState :: Yes , DoEmitParameters :: Yes ) ; } else { auto * entryPointBB = Builder . createBasicBlock ( newFunction ) ; auto * entryPointResumeIsReturn = Builder . createAllocStackInst ( genAnonymousLabelName ( "isReturn_entry" ) ) ; Builder . setInsertionBlock ( prologueBB ) ; emitFunctionPrologue ( functionNode , prologueBB , InitES5CaptureState :: Yes , DoEmitParameters :: Yes ) ; Builder . createSaveAndYieldInst ( Builder . getLiteralUndefined ( ) , entryPointBB ) ; Builder . setInsertionBlock ( entryPointBB ) ; genResumeGenerator ( nullptr , entryPointResumeIsReturn , Builder . createBasicBlock ( newFunction ) ) ; } } else { emitFunctionPrologue ( functionNode , Builder . createBasicBlock ( newFunction ) , InitES5CaptureState :: Yes , DoEmitParameters :: Yes ) ; } genStatement ( body ) ; emitFunctionEpilogue ( Builder . getLiteralUndefined ( ) ) ; return curFunction ( ) -> function ; }
void CheckTreeContainsValues ( Node * tree , Node * * values , size_t count , const BitVector * liveness , int liveness_offset ) { DCHECK_EQ ( count , StateValuesAccess ( tree ) . size ( ) ) ; int i ; auto access = StateValuesAccess ( tree ) ; auto it = access . begin ( ) ; auto itend = access . end ( ) ; for ( i = 0 ; it != itend ; ++ it , ++ i ) { if ( liveness == nullptr || liveness -> Contains ( liveness_offset + i ) ) { DCHECK_EQ ( ( * it ) . node , values [ i ] ) ; } else { DCHECK_NULL ( ( * it ) . node ) ; } } DCHECK_EQ ( static_cast < size_t > ( i ) , count ) ; }
AsyncBindingParams :: BindByIndex ( uint32_t aIndex , nsIVariant * aValue ) { NS_ENSURE_FALSE ( mLocked , NS_ERROR_UNEXPECTED ) ; NS_ENSURE_TRUE ( mParameters . ReplaceObjectAt ( aValue , aIndex ) , NS_ERROR_OUT_OF_MEMORY ) ; return NS_OK ; }
GCRuntime :: sweepBackgroundThings ( ZoneList & zones , LifoAlloc & freeBlocks , ThreadType threadType ) { freeBlocks . freeAll ( ) ; if ( zones . isEmpty ( ) ) return ; ArenaHeader * emptyArenas = nullptr ; FreeOp fop ( rt , threadType ) ; for ( unsigned phase = 0 ; phase < ArrayLength ( BackgroundFinalizePhases ) ; ++ phase ) { for ( Zone * zone = zones . front ( ) ; zone ; zone = zone -> nextZone ( ) ) { for ( unsigned index = 0 ; index < BackgroundFinalizePhases [ phase ] . length ; ++ index ) { AllocKind kind = BackgroundFinalizePhases [ phase ] . kinds [ index ] ; ArenaHeader * arenas = zone -> arenas . arenaListsToSweep [ kind ] ; if ( arenas ) ArenaLists :: backgroundFinalize ( & fop , arenas , & emptyArenas ) ; } } } AutoLockGC lock ( rt ) ; ReleaseArenaList ( rt , emptyArenas , lock ) ; while ( ! zones . isEmpty ( ) ) zones . removeFront ( ) ; }
init_connection_options ( MYSQL * mysql ) { #if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY) if ( opt_use_ssl ) { mysql_ssl_set ( mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ; #endif if ( opt_protocol ) mysql_options ( mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; #ifdef HAVE_SMEM if ( shared_memory_base_name ) mysql_options ( mysql , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; #endif }
nsDirIndexParser :: ParseFormat ( const char * aFormatStr ) { const char * pos = aFormatStr ; unsigned int num = 0 ; do { while ( * pos && nsCRT :: IsAsciiSpace ( char16_t ( * pos ) ) ) ++ pos ; ++ num ; if ( num > ( 2 * ArrayLength ( gFieldTable ) ) ) return NS_ERROR_UNEXPECTED ; if ( ! * pos ) break ; while ( * pos && ! nsCRT :: IsAsciiSpace ( char16_t ( * pos ) ) ) ++ pos ; } while ( * pos ) ; delete [ ] mFormat ; mFormat = new int [ num + 1 ] ; if ( mFormat == nullptr ) return NS_ERROR_OUT_OF_MEMORY ; mFormat [ num ] = - 1 ; int formatNum = 0 ; do { while ( * aFormatStr && nsCRT :: IsAsciiSpace ( char16_t ( * aFormatStr ) ) ) ++ aFormatStr ; if ( ! * aFormatStr ) break ; nsAutoCString name ; int32_t len = 0 ; while ( aFormatStr [ len ] && ! nsCRT :: IsAsciiSpace ( char16_t ( aFormatStr [ len ] ) ) ) ++ len ; name . SetCapacity ( len + 1 ) ; name . Append ( aFormatStr , len ) ; aFormatStr += len ; name . SetLength ( nsUnescapeCount ( name . BeginWriting ( ) ) ) ; if ( name . LowerCaseEqualsLiteral ( "description" ) ) mHasDescription = true ; for ( Field * i = gFieldTable ; i -> mName ; ++ i ) { if ( name . EqualsIgnoreCase ( i -> mName ) ) { mFormat [ formatNum ] = i -> mType ; ++ formatNum ; break ; } } } while ( * aFormatStr ) ; return NS_OK ; }
RUNTIME_FUNCTION ( Runtime_TypedArraySpeciesProtector ) { SealHandleScope shs ( isolate ) ; DCHECK_EQ ( 0 , args . length ( ) ) ; return isolate -> heap ( ) -> ToBoolean ( isolate -> IsTypedArraySpeciesLookupChainIntact ( ) ) ; }
static void pack_tokens_into_partitions_c ( VP8_COMP * cpi , unsigned char * cx_data , unsigned char * cx_data_end , int num_part ) { int i ; unsigned char * ptr = cx_data ; unsigned char * ptr_end = cx_data_end ; vp8_writer * w ; for ( i = 0 ; i < num_part ; i ++ ) { int mb_row ; w = cpi -> bc + i + 1 ; vp8_start_encode ( w , ptr , ptr_end ) ; for ( mb_row = i ; mb_row < cpi -> common . mb_rows ; mb_row += num_part ) { const TOKENEXTRA * p = cpi -> tplist [ mb_row ] . start ; const TOKENEXTRA * stop = cpi -> tplist [ mb_row ] . stop ; int tokens = ( int ) ( stop - p ) ; vp8_pack_tokens_c ( w , p , tokens ) ; } vp8_stop_encode ( w ) ; ptr += w -> pos ; } }
getWrapper ( JSContext * cx , JSObject * obj , XPCWrappedNative * * wrapper , JSObject * * cur , XPCWrappedNativeTearOff * * tearoff ) { if ( js :: IsWrapper ( obj ) ) { JSObject * inner = js :: CheckedUnwrap ( obj , false ) ; if ( ! inner && MOZ_UNLIKELY ( xpc :: WrapperFactory :: IsCOW ( obj ) ) ) inner = js :: UncheckedUnwrap ( obj ) ; if ( ! inner ) return NS_ERROR_XPC_SECURITY_MANAGER_VETO ; MOZ_ASSERT ( ! js :: IsWrapper ( inner ) ) ; obj = inner ; } * wrapper = nullptr ; * cur = nullptr ; * tearoff = nullptr ; if ( dom :: IsDOMObject ( obj ) ) { * cur = obj ; return NS_OK ; } const js :: Class * clasp = js :: GetObjectClass ( obj ) ; if ( clasp == & XPC_WN_Tearoff_JSClass ) { * tearoff = ( XPCWrappedNativeTearOff * ) js :: GetObjectPrivate ( obj ) ; obj = js :: GetObjectParent ( obj ) ; } if ( IS_WN_CLASS ( clasp ) ) * wrapper = XPCWrappedNative :: Get ( obj ) ; return NS_OK ; }
xfs_attr3_leaf_getvalue ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; int valuelen ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; ASSERT ( args -> index < ichdr . count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; ASSERT ( name_loc -> namelen == args -> namelen ) ; ASSERT ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) == 0 ) ; valuelen = be16_to_cpu ( name_loc -> valuelen ) ; if ( args -> flags & ATTR_KERNOVAL ) { args -> valuelen = valuelen ; return 0 ; } if ( args -> valuelen < valuelen ) { args -> valuelen = valuelen ; return XFS_ERROR ( ERANGE ) ; } args -> valuelen = valuelen ; memcpy ( args -> value , & name_loc -> nameval [ args -> namelen ] , valuelen ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; ASSERT ( name_rmt -> namelen == args -> namelen ) ; ASSERT ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) == 0 ) ; valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , valuelen ) ; if ( args -> flags & ATTR_KERNOVAL ) { args -> valuelen = valuelen ; return 0 ; } if ( args -> valuelen < valuelen ) { args -> valuelen = valuelen ; return XFS_ERROR ( ERANGE ) ; } args -> valuelen = valuelen ; } return 0 ; }
void AsyncFromSyncBuiltinsAssembler :: ThrowIfNotAsyncFromSyncIterator ( Node * const context , Node * const object , Label * if_exception , Variable * var_exception , const char * method_name ) { Label if_receiverisincompatible ( this , Label :: kDeferred ) , done ( this ) ; GotoIf ( TaggedIsSmi ( object ) , & if_receiverisincompatible ) ; Branch ( HasInstanceType ( object , JS_ASYNC_FROM_SYNC_ITERATOR_TYPE ) , & done , & if_receiverisincompatible ) ; BIND ( & if_receiverisincompatible ) ; { Node * const error = MakeTypeError ( MessageTemplate :: kIncompatibleMethodReceiver , context , StringConstant ( method_name ) , object ) ; var_exception -> Bind ( error ) ; Goto ( if_exception ) ; } BIND ( & done ) ; }
UnixSocketConsumer :: SendSocketData ( UnixSocketRawData * aData ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; if ( ! mImpl ) { return false ; } XRE_GetIOMessageLoop ( ) -> PostTask ( FROM_HERE , new SocketSendTask ( this , mImpl , aData ) ) ; return true ; }
nsFrameLoader :: LoadURI ( nsIURI * aURI , nsIPrincipal * aTriggeringPrincipal ) { if ( ! aURI ) return NS_ERROR_INVALID_POINTER ; NS_ENSURE_STATE ( ! mDestroyCalled && mOwnerContent ) ; nsCOMPtr < nsIDocument > doc = mOwnerContent -> OwnerDoc ( ) ; nsresult rv ; if ( ! IsForJSPlugin ( ) ) { rv = CheckURILoad ( aURI , aTriggeringPrincipal ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; } mURIToLoad = aURI ; mTriggeringPrincipal = aTriggeringPrincipal ; rv = doc -> InitializeFrameLoader ( this ) ; if ( NS_FAILED ( rv ) ) { mURIToLoad = nullptr ; mTriggeringPrincipal = nullptr ; } return rv ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TF_LITE_ENSURE_EQ ( context , NumInputs ( node ) , 2 ) ; TF_LITE_ENSURE_EQ ( context , NumOutputs ( node ) , 1 ) ; OpData * data = reinterpret_cast < OpData * > ( node -> user_data ) ; const TfLiteTensor * input1 = GetInput ( context , node , kInputTensor1 ) ; const TfLiteTensor * input2 = GetInput ( context , node , kInputTensor2 ) ; TfLiteTensor * output = GetOutput ( context , node , kOutputTensor ) ; TF_LITE_ENSURE_TYPES_EQ ( context , input1 -> type , input2 -> type ) ; const TfLiteType type = input1 -> type ; switch ( type ) { case kTfLiteFloat32 : case kTfLiteInt32 : break ; default : context -> ReportError ( context , "Type '%s' is not supported by floor_div." , TfLiteTypeGetName ( type ) ) ; return kTfLiteError ; } output -> type = type ; data -> requires_broadcast = ! HaveSameShapes ( input1 , input2 ) ; TfLiteIntArray * output_size = nullptr ; if ( data -> requires_broadcast ) { TF_LITE_ENSURE_OK ( context , CalculateShapeForBroadcast ( context , input1 , input2 , & output_size ) ) ; } else { output_size = TfLiteIntArrayCopy ( input1 -> dims ) ; } return context -> ResizeTensor ( context , output , output_size ) ; }
static bool states_equal ( struct bpf_verifier_env * env , struct bpf_verifier_state * old , struct bpf_verifier_state * cur ) { int i ; if ( old -> curframe != cur -> curframe ) return false ; for ( i = 0 ; i <= old -> curframe ; i ++ ) { if ( old -> frame [ i ] -> callsite != cur -> frame [ i ] -> callsite ) return false ; if ( ! func_states_equal ( old -> frame [ i ] , cur -> frame [ i ] ) ) return false ; } return true ; }
void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( "usage: condump <filename>\n" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , ".txt" ) ; f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( "ERROR: couldn't open %s.\n" , filename ) ; return ; } Com_Printf ( "Dumped console text to %s.\n" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != ' ' ) { break ; } if ( x != con . linewidth ) { break ; } } #ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; #else bufferlen = con . linewidth + 2 * sizeof ( char ) ; #endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == ' ' ) { buffer [ x ] = 0 ; } else { break ; } } #ifdef _WIN32 Q_strcat ( buffer , bufferlen , "\r\n" ) ; #else Q_strcat ( buffer , bufferlen , "\n" ) ; #endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }
void Builtins :: Generate_ConstructFunction ( MacroAssembler * masm ) { __ AssertConstructor ( a1 ) ; __ AssertFunction ( a1 ) ; __ LoadRoot ( a2 , Heap :: kUndefinedValueRootIndex ) ; Label call_generic_stub ; __ lw ( t0 , FieldMemOperand ( a1 , JSFunction :: kSharedFunctionInfoOffset ) ) ; __ lw ( t0 , FieldMemOperand ( t0 , SharedFunctionInfo :: kFlagsOffset ) ) ; __ And ( t0 , t0 , Operand ( SharedFunctionInfo :: ConstructAsBuiltinBit :: kMask ) ) ; __ Branch ( & call_generic_stub , eq , t0 , Operand ( zero_reg ) ) ; __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , JSBuiltinsConstructStub ) , RelocInfo :: CODE_TARGET ) ; __ bind ( & call_generic_stub ) ; __ Jump ( BUILTIN_CODE ( masm -> isolate ( ) , JSConstructStubGeneric ) , RelocInfo :: CODE_TARGET ) ; }
bool WebrtcAudioPrivateGetActiveSinkFunction :: RunAsync ( ) { DCHECK_CURRENTLY_ON ( BrowserThread :: UI ) ; InitDeviceIDSalt ( ) ; scoped_ptr < wap :: GetActiveSink :: Params > params ( wap :: GetActiveSink :: Params :: Create ( * args_ ) ) ; EXTENSION_FUNCTION_VALIDATE ( params . get ( ) ) ; return GetControllerList ( params -> request ) ; }
skip_expr_concatenate ( char_u * * arg , char_u * * start , char_u * * end , evalarg_T * evalarg ) { typval_T rettv ; int res ; int vim9script = in_vim9script ( ) ; garray_T * gap = evalarg == NULL ? NULL : & evalarg -> eval_ga ; garray_T * freegap = evalarg == NULL ? NULL : & evalarg -> eval_freega ; int save_flags = evalarg == NULL ? 0 : evalarg -> eval_flags ; int evaluate = evalarg == NULL ? FALSE : ( evalarg -> eval_flags & EVAL_EVALUATE ) ; if ( vim9script && evaluate && ( evalarg -> eval_cookie != NULL || evalarg -> eval_cctx != NULL ) ) { ga_init2 ( gap , sizeof ( char_u * ) , 10 ) ; if ( ga_grow ( gap , 1 ) == OK ) ++ gap -> ga_len ; ga_init2 ( freegap , sizeof ( char_u * ) , 10 ) ; } * start = * arg ; if ( evalarg != NULL ) evalarg -> eval_flags &= ~ EVAL_EVALUATE ; * arg = skipwhite ( * arg ) ; res = eval1 ( arg , & rettv , evalarg ) ; * end = * arg ; if ( evalarg != NULL ) evalarg -> eval_flags = save_flags ; if ( vim9script && evaluate && ( evalarg -> eval_cookie != NULL || evalarg -> eval_cctx != NULL ) ) { if ( evalarg -> eval_ga . ga_len == 1 ) { ga_clear ( gap ) ; gap -> ga_itemsize = 0 ; } else { char_u * p ; size_t endoff = STRLEN ( * arg ) ; * ( ( char_u * * ) gap -> ga_data ) = * start ; p = ga_concat_strings ( gap , " " ) ; if ( evalarg -> eval_cookie != NULL ) { * ( ( char_u * * ) gap -> ga_data ) = NULL ; vim_free ( evalarg -> eval_tofree ) ; evalarg -> eval_tofree = ( ( char_u * * ) gap -> ga_data ) [ gap -> ga_len - 1 ] ; ( ( char_u * * ) gap -> ga_data ) [ gap -> ga_len - 1 ] = NULL ; ga_clear_strings ( gap ) ; } else { ga_clear ( gap ) ; ga_clear_strings ( freegap ) ; } gap -> ga_itemsize = 0 ; if ( p == NULL ) return FAIL ; * start = p ; vim_free ( evalarg -> eval_tofree_lambda ) ; evalarg -> eval_tofree_lambda = p ; * end = * start + STRLEN ( * start ) - endoff ; } } return res ; }
void vp8_dequant_idct_add_y_block_mmx ( short * q , short * dq , unsigned char * dst , int stride , char * eobs ) { int i ; for ( i = 0 ; i < 4 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dst , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ; vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dst + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dst + 4 , stride , dst + 4 , stride ) ; vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; } if ( eobs [ 2 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 32 , dq , dst + 8 , stride ) ; else if ( eobs [ 2 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 32 ] * dq [ 0 ] , dst + 8 , stride , dst + 8 , stride ) ; vpx_memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; } if ( eobs [ 3 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 48 , dq , dst + 12 , stride ) ; else if ( eobs [ 3 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 48 ] * dq [ 0 ] , dst + 12 , stride , dst + 12 , stride ) ; vpx_memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; } q += 64 ; dst += 4 * stride ; eobs += 4 ; } }
void Generate_JSBuiltinsConstructStubHelper ( MacroAssembler * masm ) { { FrameScope scope ( masm , StackFrame :: CONSTRUCT ) ; __ SmiTag ( eax ) ; __ push ( esi ) ; __ push ( eax ) ; __ SmiUntag ( eax ) ; __ PushRoot ( Heap :: kTheHoleValueRootIndex ) ; __ lea ( ebx , Operand ( ebp , StandardFrameConstants :: kCallerSPOffset ) ) ; Label loop , entry ; __ mov ( ecx , eax ) ; __ jmp ( & entry ) ; __ bind ( & loop ) ; __ push ( Operand ( ebx , ecx , times_4 , 0 ) ) ; __ bind ( & entry ) ; __ dec ( ecx ) ; __ j ( greater_equal , & loop ) ; ParameterCount actual ( eax ) ; __ InvokeFunction ( edi , edx , actual , CALL_FUNCTION ) ; __ mov ( esi , Operand ( ebp , ConstructFrameConstants :: kContextOffset ) ) ; __ mov ( ebx , Operand ( ebp , ConstructFrameConstants :: kLengthOffset ) ) ; } STATIC_ASSERT ( kSmiTagSize == 1 && kSmiTag == 0 ) ; __ pop ( ecx ) ; __ lea ( esp , Operand ( esp , ebx , times_2 , 1 * kPointerSize ) ) ; __ push ( ecx ) ; __ ret ( 0 ) ; }
static int mpeg4_decode_studio_block ( MpegEncContext * s , int32_t block [ 64 ] , int n ) { Mpeg4DecContext * ctx = s -> avctx -> priv_data ; int cc , dct_dc_size , dct_diff , code , j , idx = 1 , group = 0 , run = 0 , additional_code_len , sign , mismatch ; VLC * cur_vlc = & ctx -> studio_intra_tab [ 0 ] ; uint8_t * const scantable = s -> intra_scantable . permutated ; const uint16_t * quant_matrix ; uint32_t flc ; const int min = - 1 * ( 1 < < ( s -> avctx -> bits_per_raw_sample + 6 ) ) ; const int max = ( ( 1 < < ( s -> avctx -> bits_per_raw_sample + 6 ) ) - 1 ) ; mismatch = 1 ; memset ( block , 0 , 64 * sizeof ( int32_t ) ) ; if ( n < 4 ) { cc = 0 ; dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> intra_matrix ; } else { cc = ( n & 1 ) + 1 ; if ( ctx -> rgb ) dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; else dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_chroma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> chroma_intra_matrix ; } if ( dct_dc_size < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "illegal dct_dc_size vlc\n" ) ; return AVERROR_INVALIDDATA ; } else if ( dct_dc_size == 0 ) { dct_diff = 0 ; } else { dct_diff = get_xbits ( & s -> gb , dct_dc_size ) ; if ( dct_dc_size > 8 ) { if ( ! check_marker ( s -> avctx , & s -> gb , "dct_dc_size > 8" ) ) return AVERROR_INVALIDDATA ; } } s -> last_dc [ cc ] += dct_diff ; if ( s -> mpeg_quant ) block [ 0 ] = s -> last_dc [ cc ] * ( 8 > > s -> intra_dc_precision ) ; else block [ 0 ] = s -> last_dc [ cc ] * ( 8 > > s -> intra_dc_precision ) * ( 8 > > s -> dct_precision ) ; block [ 0 ] = av_clip ( block [ 0 ] , min , max ) ; mismatch ^= block [ 0 ] ; while ( 1 ) { group = get_vlc2 ( & s -> gb , cur_vlc -> table , STUDIO_INTRA_BITS , 2 ) ; if ( group < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "illegal ac coefficient group vlc\n" ) ; return AVERROR_INVALIDDATA ; } additional_code_len = ac_state_tab [ group ] [ 0 ] ; cur_vlc = & ctx -> studio_intra_tab [ ac_state_tab [ group ] [ 1 ] ] ; if ( group == 0 ) { break ; } else if ( group >= 1 && group <= 6 ) { run = 1 < < additional_code_len ; if ( additional_code_len ) run += get_bits ( & s -> gb , additional_code_len ) ; idx += run ; continue ; } else if ( group >= 7 && group <= 12 ) { code = get_bits ( & s -> gb , additional_code_len ) ; sign = code & 1 ; code >>= 1 ; run = ( 1 < < ( additional_code_len - 1 ) ) + code ; idx += run ; j = scantable [ idx ++ ] ; block [ j ] = sign ? 1 : - 1 ; } else if ( group >= 13 && group <= 20 ) { j = scantable [ idx ++ ] ; block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ; } else if ( group == 21 ) { j = scantable [ idx ++ ] ; additional_code_len = s -> avctx -> bits_per_raw_sample + s -> dct_precision + 4 ; flc = get_bits ( & s -> gb , additional_code_len ) ; if ( flc > > ( additional_code_len - 1 ) ) block [ j ] = - 1 * ( ( flc ^ ( ( 1 < < additional_code_len ) - 1 ) ) + 1 ) ; else block [ j ] = flc ; } block [ j ] = ( ( 8 * 2 * block [ j ] * quant_matrix [ j ] * s -> qscale ) > > s -> dct_precision ) / 32 ; block [ j ] = av_clip ( block [ j ] , min , max ) ; mismatch ^= block [ j ] ; } block [ 63 ] ^= mismatch & 1 ; return 0 ; }
nsDOMMessageEvent :: GetData ( jsval * aData ) { * aData = mData ; return NS_OK ; }
static void accumulate_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) { section -> frame += frame -> frame ; section -> spatial_layer_id = frame -> spatial_layer_id ; section -> intra_error += frame -> intra_error ; section -> coded_error += frame -> coded_error ; section -> sr_coded_error += frame -> sr_coded_error ; section -> ssim_weighted_pred_err += frame -> ssim_weighted_pred_err ; section -> pcnt_inter += frame -> pcnt_inter ; section -> pcnt_motion += frame -> pcnt_motion ; section -> pcnt_second_ref += frame -> pcnt_second_ref ; section -> pcnt_neutral += frame -> pcnt_neutral ; section -> MVr += frame -> MVr ; section -> mvr_abs += frame -> mvr_abs ; section -> MVc += frame -> MVc ; section -> mvc_abs += frame -> mvc_abs ; section -> MVrv += frame -> MVrv ; section -> MVcv += frame -> MVcv ; section -> mv_in_out_count += frame -> mv_in_out_count ; section -> new_mv_count += frame -> new_mv_count ; section -> count += frame -> count ; section -> duration += frame -> duration ; }
bool AddTable ( WasmModule * module ) { if ( enabled_features_ . anyref ) return true ; if ( module -> tables . size ( ) > 0 ) { error ( "At most one table is supported" ) ; return false ; } else { return true ; } }
Status operator ( ) ( OpKernelContext * context , typename TTypes < Tindex > :: ConstVec reverse_index_map , typename TTypes < T > :: ConstVec grad_values , typename TTypes < T > :: Vec d_values , typename TTypes < T > :: Scalar d_default_value ) { const GPUDevice & device = context -> eigen_device < GPUDevice > ( ) ; const Tindex N = reverse_index_map . dimension ( 0 ) ; const Tindex N_full = grad_values . dimension ( 0 ) ; Tensor visited_t ; TF_RETURN_IF_ERROR ( context -> allocate_temp ( DT_BOOL , TensorShape ( { N_full } ) , & visited_t ) ) ; auto visited = visited_t . vec < bool > ( ) ; visited . device ( device ) = visited . constant ( false ) ; TF_RETURN_IF_ERROR ( wrap_kernel_call ( GatherOriginalGradValuesKernel < T , Tindex > , device , N , reverse_index_map , grad_values , d_values , visited ) ) ; gpuprim :: CountingInputIterator < Tindex , Tindex > counting_iterator ( Tindex ( 0 ) ) ; ZeroMaskedValues < T , Tindex > mask_values_fn ( visited . data ( ) , grad_values . data ( ) ) ; gpuprim :: TransformInputIterator < T , decltype ( mask_values_fn ) , decltype ( counting_iterator ) , Tindex > transform_iterator ( counting_iterator , mask_values_fn ) ; std :: size_t temp_storage_bytes = 0 ; auto gpuprim_status = gpuprim :: DeviceReduce :: Sum ( nullptr , temp_storage_bytes , transform_iterator , d_default_value . data ( ) , N_full , device . stream ( ) ) ; if ( gpuprim_status != gpuSuccess ) { return errors :: Internal ( "SparseFillEmptyRowsGrad: Could not launch " "gpuprim::DeviceReduce::Sum to calculate temp_storage_bytes, " "status: " , GpuGetErrorString ( gpuprim_status ) ) ; } Tensor temp_storage ; TF_RETURN_IF_ERROR ( context -> allocate_temp ( DT_INT8 , TensorShape ( { static_cast < int64_t > ( temp_storage_bytes ) } ) , & temp_storage ) ) ; gpuprim_status = gpuprim :: DeviceReduce :: Sum ( temp_storage . flat < int8 > ( ) . data ( ) , temp_storage_bytes , transform_iterator , d_default_value . data ( ) , N_full , device . stream ( ) ) ; if ( gpuprim_status != gpuSuccess ) { return errors :: Internal ( "SparseFillEmptyRowsGrad: Could not launch " "gpuprim::DeviceReduce::Sum to sum values from originally-empty " "rows. temp_storage_bytes: " , temp_storage_bytes , ", status: " , GpuGetErrorString ( gpuprim_status ) ) ; } return OkStatus ( ) ; }
js_InitRegExpClass ( JSContext * cx , HandleObject obj ) { JS_ASSERT ( obj -> isNative ( ) ) ; Rooted < GlobalObject * > global ( cx , & obj -> asGlobal ( ) ) ; RootedObject proto ( cx , global -> createBlankPrototype ( cx , & RegExpClass ) ) ; if ( ! proto ) return NULL ; proto -> setPrivate ( NULL ) ; HandlePropertyName empty = cx -> names ( ) . empty ; RegExpObjectBuilder builder ( cx , & proto -> asRegExp ( ) ) ; if ( ! builder . build ( empty , RegExpFlag ( 0 ) ) ) return NULL ; if ( ! DefinePropertiesAndBrand ( cx , proto , NULL , regexp_methods ) ) return NULL ; RootedFunction ctor ( cx ) ; ctor = global -> createConstructor ( cx , regexp_construct , cx -> names ( ) . RegExp , 2 ) ; if ( ! ctor ) return NULL ; if ( ! LinkConstructorAndPrototype ( cx , ctor , proto ) ) return NULL ; if ( ! JS_DefineProperties ( cx , ctor , regexp_static_props ) ) return NULL ; TypeObject * type = proto -> getNewType ( cx ) ; if ( ! type ) return NULL ; AddTypeProperty ( cx , type , "source" , Type :: StringType ( ) ) ; AddTypeProperty ( cx , type , "global" , Type :: BooleanType ( ) ) ; AddTypeProperty ( cx , type , "ignoreCase" , Type :: BooleanType ( ) ) ; AddTypeProperty ( cx , type , "multiline" , Type :: BooleanType ( ) ) ; AddTypeProperty ( cx , type , "sticky" , Type :: BooleanType ( ) ) ; AddTypeProperty ( cx , type , "lastIndex" , Type :: Int32Type ( ) ) ; if ( ! DefineConstructorAndPrototype ( cx , global , JSProto_RegExp , ctor , proto ) ) return NULL ; return proto ; }
jit :: LazyLinkTopActivation ( JSContext * cx ) { JitActivationIterator iter ( cx -> runtime ( ) ) ; JitFrameIterator it ( iter . jitTop ( ) , SequentialExecution ) ; MOZ_ASSERT ( it . type ( ) == JitFrame_Exit ) ; ++ it ; MOZ_ASSERT ( it . type ( ) == JitFrame_IonJS ) ; IonBuilder * builder = it . script ( ) -> ionScript ( ) -> pendingBuilder ( ) ; it . script ( ) -> setPendingIonBuilder ( cx , nullptr ) ; types :: AutoEnterAnalysis enterTypes ( cx ) ; RootedScript script ( cx , builder -> script ( ) ) ; builder -> remove ( ) ; if ( CodeGenerator * codegen = builder -> backgroundCodegen ( ) ) { js :: TraceLogger * logger = TraceLoggerForMainThread ( cx -> runtime ( ) ) ; AutoTraceLog logScript ( logger , TraceLogCreateTextId ( logger , script ) ) ; AutoTraceLog logLink ( logger , TraceLogger :: IonLinking ) ; IonContext ictx ( cx , & builder -> alloc ( ) ) ; codegen -> masm . constructRoot ( cx ) ; if ( ! codegen -> link ( cx , builder -> constraints ( ) ) ) { cx -> clearPendingException ( ) ; } } FinishOffThreadBuilder ( cx , builder ) ; MOZ_ASSERT ( script -> hasBaselineScript ( ) ) ; MOZ_ASSERT ( script -> baselineOrIonRawPointer ( ) ) ; return script -> baselineOrIonRawPointer ( ) ; }
PluginAsyncSurrogate :: NPP_Destroy ( NPSavedData * * aSave ) { NotifyDestroyPending ( ) ; if ( ! WaitForInit ( ) ) { return NPERR_GENERIC_ERROR ; } return PluginModuleParent :: NPP_Destroy ( mInstance , aSave ) ; }
TfLiteStatus Eval ( TfLiteContext * context , TfLiteNode * node ) { const TfLiteTensor * params ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kParams , & params ) ) ; const TfLiteTensor * indices ; TF_LITE_ENSURE_OK ( context , GetInputSafe ( context , node , kIndices , & indices ) ) ; TfLiteTensor * output ; TF_LITE_ENSURE_OK ( context , GetOutputSafe ( context , node , kOutputTensor , & output ) ) ; switch ( indices -> type ) { case kTfLiteInt32 : return EvalGatherNd < int32_t > ( context , params , indices , output ) ; case kTfLiteInt64 : return EvalGatherNd < int64_t > ( context , params , indices , output ) ; default : context -> ReportError ( context , "Indices of type '%s' are not supported by gather_nd." , TfLiteTypeGetName ( indices -> type ) ) ; return kTfLiteError ; } }
nsLayoutUtils :: SurfaceFromElement ( HTMLImageElement * aElement , uint32_t aSurfaceFlags , DrawTarget * aTarget ) { return SurfaceFromElement ( static_cast < nsIImageLoadingContent * > ( aElement ) , aSurfaceFlags , aTarget ) ; }
CYCLIC_REFRESH * vp9_cyclic_refresh_alloc ( int mi_rows , int mi_cols ) { CYCLIC_REFRESH * const cr = vpx_calloc ( 1 , sizeof ( * cr ) ) ; if ( cr == NULL ) return NULL ; cr -> map = vpx_calloc ( mi_rows * mi_cols , sizeof ( * cr -> map ) ) ; if ( cr -> map == NULL ) { vpx_free ( cr ) ; return NULL ; } return cr ; }
TF_BUILTIN ( GrowFastDoubleElements , CodeStubAssembler ) { Node * object = Parameter ( Descriptor :: kObject ) ; Node * key = Parameter ( Descriptor :: kKey ) ; Node * context = Parameter ( Descriptor :: kContext ) ; Label runtime ( this , Label :: kDeferred ) ; Node * elements = LoadElements ( object ) ; elements = TryGrowElementsCapacity ( object , elements , PACKED_DOUBLE_ELEMENTS , key , & runtime ) ; Return ( elements ) ; BIND ( & runtime ) ; TailCallRuntime ( Runtime :: kGrowArrayElements , context , object , key ) ; }
nsXMLHttpRequest :: AppendToResponseText ( const char * aSrcBuffer , uint32_t aSrcBufferLen ) { NS_ENSURE_STATE ( mDecoder ) ; int32_t destBufferLen ; nsresult rv = mDecoder -> GetMaxLength ( aSrcBuffer , aSrcBufferLen , & destBufferLen ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; if ( ! mResponseText . SetCapacity ( mResponseText . Length ( ) + destBufferLen , fallible ) ) { return NS_ERROR_OUT_OF_MEMORY ; } char16_t * destBuffer = mResponseText . BeginWriting ( ) + mResponseText . Length ( ) ; int32_t totalChars = mResponseText . Length ( ) ; int32_t srclen = ( int32_t ) aSrcBufferLen ; int32_t destlen = ( int32_t ) destBufferLen ; rv = mDecoder -> Convert ( aSrcBuffer , & srclen , destBuffer , & destlen ) ; MOZ_ASSERT ( NS_SUCCEEDED ( rv ) ) ; totalChars += destlen ; mResponseText . SetLength ( totalChars ) ; return NS_OK ; }
static int lookup1_values ( int entries , int dim ) { int r = ( int ) floor ( exp ( ( float ) log ( ( float ) entries ) / dim ) ) ; if ( ( int ) floor ( pow ( ( float ) r + 1 , dim ) ) <= entries ) ++ r ; assert ( pow ( ( float ) r + 1 , dim ) > entries ) ; assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ; return r ; }
js :: Nursery :: sweep ( ) { for ( CellsWithUniqueIdSet :: Enum e ( cellsWithUid_ ) ; ! e . empty ( ) ; e . popFront ( ) ) { JSObject * obj = static_cast < JSObject * > ( e . front ( ) ) ; if ( ! IsForwarded ( obj ) ) obj -> zone ( ) -> removeUniqueId ( obj ) ; else MOZ_ASSERT ( Forwarded ( obj ) -> zone ( ) -> hasUniqueId ( Forwarded ( obj ) ) ) ; } cellsWithUid_ . clear ( ) ; #ifdef JS_GC_ZEAL JS_POISON ( ( void * ) start ( ) , JS_SWEPT_NURSERY_PATTERN , nurserySize ( ) ) ; for ( int i = 0 ; i < numNurseryChunks_ ; ++ i ) initChunk ( i ) ; if ( runtime ( ) -> hasZealMode ( ZealMode :: GenerationalGC ) ) { MOZ_ASSERT ( numActiveChunks_ == numNurseryChunks_ ) ; if ( currentChunk_ + 1 == numNurseryChunks_ ) setCurrentChunk ( 0 ) ; } else #endif { #ifdef JS_CRASH_DIAGNOSTICS JS_POISON ( ( void * ) start ( ) , JS_SWEPT_NURSERY_PATTERN , allocationEnd ( ) - start ( ) ) ; for ( int i = 0 ; i < numActiveChunks_ ; ++ i ) initChunk ( i ) ; #endif setCurrentChunk ( 0 ) ; } currentStart_ = position ( ) ; MemProfiler :: SweepNursery ( runtime ( ) ) ; }
TextureClient :: CreateForDrawing ( CompositableForwarder * aAllocator , gfx :: SurfaceFormat aFormat , gfx :: IntSize aSize , BackendSelector aSelector , TextureFlags aTextureFlags , TextureAllocationFlags aAllocFlags ) { LayersBackend parentBackend = aAllocator -> GetCompositorBackendType ( ) ; gfx :: BackendType moz2DBackend = BackendTypeForBackendSelector ( parentBackend , aSelector ) ; RefPtr < TextureClient > texture ; #if defined(MOZ_WIDGET_GONK) || defined(XP_WIN) int32_t maxTextureSize = aAllocator -> GetMaxTextureSize ( ) ; #endif #ifdef XP_WIN if ( parentBackend == LayersBackend :: LAYERS_D3D11 && ( moz2DBackend == gfx :: BackendType :: DIRECT2D || moz2DBackend == gfx :: BackendType :: DIRECT2D1_1 ) && aSize . width <= maxTextureSize && aSize . height <= maxTextureSize ) { texture = new TextureClientD3D11 ( aAllocator , aFormat , aTextureFlags ) ; } if ( parentBackend == LayersBackend :: LAYERS_D3D9 && moz2DBackend == gfx :: BackendType :: CAIRO && aAllocator -> IsSameProcess ( ) && aSize . width <= maxTextureSize && aSize . height <= maxTextureSize && NS_IsMainThread ( ) ) { if ( gfxWindowsPlatform :: GetPlatform ( ) -> GetD3D9Device ( ) ) { texture = new TextureClientD3D9 ( aAllocator , aFormat , aTextureFlags ) ; } } if ( ! texture && aFormat == SurfaceFormat :: B8G8R8X8 && aAllocator -> IsSameProcess ( ) && moz2DBackend == gfx :: BackendType :: CAIRO && NS_IsMainThread ( ) ) { if ( aAllocator -> IsSameProcess ( ) ) { texture = new TextureClientMemoryDIB ( aAllocator , aFormat , aTextureFlags ) ; } else { texture = new TextureClientShmemDIB ( aAllocator , aFormat , aTextureFlags ) ; } } #endif #ifdef MOZ_X11 gfxSurfaceType type = gfxPlatform :: GetPlatform ( ) -> ScreenReferenceSurface ( ) -> GetType ( ) ; if ( parentBackend == LayersBackend :: LAYERS_BASIC && moz2DBackend == gfx :: BackendType :: CAIRO && type == gfxSurfaceType :: Xlib ) { texture = new TextureClientX11 ( aAllocator , aFormat , aTextureFlags ) ; } #ifdef GL_PROVIDER_GLX if ( parentBackend == LayersBackend :: LAYERS_OPENGL && type == gfxSurfaceType :: Xlib && aFormat != SurfaceFormat :: A8 && gl :: sGLXLibrary . UseTextureFromPixmap ( ) ) { texture = new TextureClientX11 ( aAllocator , aFormat , aTextureFlags ) ; } #endif #endif #ifdef MOZ_WIDGET_GONK if ( ! DisableGralloc ( aFormat , aSize ) ) { if ( aSize . width <= maxTextureSize && aSize . height <= maxTextureSize ) { texture = new GrallocTextureClientOGL ( aAllocator , aFormat , moz2DBackend , aTextureFlags ) ; } } #endif MOZ_ASSERT ( ! texture || texture -> CanExposeDrawTarget ( ) , "texture cannot expose a DrawTarget?" ) ; if ( texture && texture -> AllocateForSurface ( aSize , aAllocFlags ) ) { return texture . forget ( ) ; } if ( aAllocFlags & ALLOC_DISALLOW_BUFFERTEXTURECLIENT ) { return nullptr ; } if ( texture ) { NS_WARNING ( "Failed to allocate a TextureClient, falling back to BufferTextureClient." ) ; } texture = CreateBufferTextureClient ( aAllocator , aFormat , aTextureFlags , moz2DBackend ) ; if ( ! texture -> AllocateForSurface ( aSize , aAllocFlags ) ) { return nullptr ; } return texture . forget ( ) ; }
template < class T > void testFeatTable ( const T & table , const char * testName ) { FeatureMap testFeatureMap ; dummyFace . replace_table ( TtfUtil :: Tag :: Feat , & table , sizeof ( T ) ) ; gr_face * face = gr_make_face_with_ops ( & dummyFace , & face_handle :: ops , gr_face_dumbRendering ) ; if ( ! face ) throw std :: runtime_error ( "failed to load font" ) ; bool readStatus = testFeatureMap . readFeats ( * face ) ; testAssert ( "readFeats" , readStatus ) ; fprintf ( stderr , testName , NULL ) ; testAssertEqual ( "test num features %hu,%hu\n" , testFeatureMap . numFeats ( ) , table . m_header . m_numFeat ) ; for ( size_t i = 0 ; i < sizeof ( table . m_defs ) / sizeof ( FeatDefn ) ; i ++ ) { const FeatureRef * ref = testFeatureMap . findFeatureRef ( table . m_defs [ i ] . m_featId ) ; testAssert ( "test feat\n" , ref ) ; testAssertEqual ( "test feat settings %hu %hu\n" , ref -> getNumSettings ( ) , table . m_defs [ i ] . m_numFeatSettings ) ; testAssertEqual ( "test feat label %hu %hu\n" , ref -> getNameId ( ) , table . m_defs [ i ] . m_label ) ; size_t settingsIndex = ( table . m_defs [ i ] . m_settingsOffset - sizeof ( FeatHeader ) - ( sizeof ( FeatDefn ) * table . m_header . m_numFeat ) ) / sizeof ( FeatSetting ) ; for ( size_t j = 0 ; j < table . m_defs [ i ] . m_numFeatSettings ; j ++ ) { testAssertEqual ( "setting label %hu %hu\n" , ref -> getSettingName ( j ) , table . m_settings [ settingsIndex + j ] . m_label ) ; } } gr_face_destroy ( face ) ; }
const BlockEntry * Cues :: GetBlock ( const CuePoint * pCP , const CuePoint :: TrackPosition * pTP ) const { if ( pCP == NULL ) return NULL ; if ( pTP == NULL ) return NULL ; return m_pSegment -> GetBlock ( * pCP , * pTP ) ; }
void ScheduleVerifier :: Run ( Schedule * schedule ) { const size_t count = schedule -> BasicBlockCount ( ) ; Zone tmp_zone ( schedule -> zone ( ) -> allocator ( ) , ZONE_NAME ) ; Zone * zone = & tmp_zone ; BasicBlock * start = schedule -> start ( ) ; BasicBlockVector * rpo_order = schedule -> rpo_order ( ) ; CHECK_GE ( count , rpo_order -> size ( ) ) ; for ( BasicBlockVector :: iterator b = rpo_order -> begin ( ) ; b != rpo_order -> end ( ) ; ++ b ) { CHECK_EQ ( ( * b ) , schedule -> GetBlockById ( ( * b ) -> id ( ) ) ) ; for ( BasicBlock const * predecessor : ( * b ) -> predecessors ( ) ) { CHECK_GE ( predecessor -> rpo_number ( ) , 0 ) ; CHECK_EQ ( predecessor , schedule -> GetBlockById ( predecessor -> id ( ) ) ) ; } for ( BasicBlock const * successor : ( * b ) -> successors ( ) ) { CHECK_GE ( successor -> rpo_number ( ) , 0 ) ; CHECK_EQ ( successor , schedule -> GetBlockById ( successor -> id ( ) ) ) ; } } CHECK_EQ ( start , rpo_order -> at ( 0 ) ) ; for ( size_t b = 0 ; b < rpo_order -> size ( ) ; b ++ ) { BasicBlock * block = rpo_order -> at ( b ) ; CHECK_EQ ( static_cast < int > ( b ) , block -> rpo_number ( ) ) ; BasicBlock * dom = block -> dominator ( ) ; if ( b == 0 ) { CHECK_NULL ( dom ) ; } else { CHECK_NOT_NULL ( dom ) ; CHECK_LT ( dom -> rpo_number ( ) , block -> rpo_number ( ) ) ; } } BoolVector marked ( static_cast < int > ( count ) , false , zone ) ; { ZoneQueue < BasicBlock * > queue ( zone ) ; queue . push ( start ) ; marked [ start -> id ( ) . ToSize ( ) ] = true ; while ( ! queue . empty ( ) ) { BasicBlock * block = queue . front ( ) ; queue . pop ( ) ; for ( size_t s = 0 ; s < block -> SuccessorCount ( ) ; s ++ ) { BasicBlock * succ = block -> SuccessorAt ( s ) ; if ( ! marked [ succ -> id ( ) . ToSize ( ) ] ) { marked [ succ -> id ( ) . ToSize ( ) ] = true ; queue . push ( succ ) ; } } } } for ( size_t i = 0 ; i < count ; i ++ ) { BasicBlock * block = schedule -> GetBlockById ( BasicBlock :: Id :: FromSize ( i ) ) ; if ( marked [ i ] ) { CHECK_GE ( block -> rpo_number ( ) , 0 ) ; CHECK_EQ ( block , rpo_order -> at ( block -> rpo_number ( ) ) ) ; } } for ( size_t b = 0 ; b < rpo_order -> size ( ) ; b ++ ) { CHECK ( marked [ rpo_order -> at ( b ) -> id ( ) . ToSize ( ) ] ) ; } { ZoneVector < BitVector * > dominators ( zone ) ; dominators . resize ( count , nullptr ) ; ZoneQueue < BasicBlock * > queue ( zone ) ; queue . push ( start ) ; dominators [ start -> id ( ) . ToSize ( ) ] = new ( zone ) BitVector ( static_cast < int > ( count ) , zone ) ; while ( ! queue . empty ( ) ) { BasicBlock * block = queue . front ( ) ; queue . pop ( ) ; BitVector * block_doms = dominators [ block -> id ( ) . ToSize ( ) ] ; BasicBlock * idom = block -> dominator ( ) ; if ( idom != nullptr && ! block_doms -> Contains ( idom -> id ( ) . ToInt ( ) ) ) { FATAL ( "Block B%d is not dominated by B%d" , block -> rpo_number ( ) , idom -> rpo_number ( ) ) ; } for ( size_t s = 0 ; s < block -> SuccessorCount ( ) ; s ++ ) { BasicBlock * succ = block -> SuccessorAt ( s ) ; BitVector * succ_doms = dominators [ succ -> id ( ) . ToSize ( ) ] ; if ( succ_doms == nullptr ) { succ_doms = new ( zone ) BitVector ( static_cast < int > ( count ) , zone ) ; succ_doms -> CopyFrom ( * block_doms ) ; succ_doms -> Add ( block -> id ( ) . ToInt ( ) ) ; dominators [ succ -> id ( ) . ToSize ( ) ] = succ_doms ; queue . push ( succ ) ; } else { bool had = succ_doms -> Contains ( block -> id ( ) . ToInt ( ) ) ; if ( had ) succ_doms -> Remove ( block -> id ( ) . ToInt ( ) ) ; if ( succ_doms -> IntersectIsChanged ( * block_doms ) ) queue . push ( succ ) ; if ( had ) succ_doms -> Add ( block -> id ( ) . ToInt ( ) ) ; } } } for ( BasicBlockVector :: iterator b = rpo_order -> begin ( ) ; b != rpo_order -> end ( ) ; ++ b ) { BasicBlock * block = * b ; BasicBlock * idom = block -> dominator ( ) ; if ( idom == nullptr ) continue ; BitVector * block_doms = dominators [ block -> id ( ) . ToSize ( ) ] ; for ( BitVector :: Iterator it ( block_doms ) ; ! it . Done ( ) ; it . Advance ( ) ) { BasicBlock * dom = schedule -> GetBlockById ( BasicBlock :: Id :: FromInt ( it . Current ( ) ) ) ; if ( dom != idom && ! dominators [ idom -> id ( ) . ToSize ( ) ] -> Contains ( dom -> id ( ) . ToInt ( ) ) ) { FATAL ( "Block B%d is not immediately dominated by B%d" , block -> rpo_number ( ) , idom -> rpo_number ( ) ) ; } } } } for ( BasicBlockVector :: iterator b = rpo_order -> begin ( ) ; b != rpo_order -> end ( ) ; ++ b ) { for ( BasicBlock :: const_iterator i = ( * b ) -> begin ( ) ; i != ( * b ) -> end ( ) ; ++ i ) { Node * phi = * i ; if ( phi -> opcode ( ) != IrOpcode :: kPhi ) continue ; if ( phi -> InputCount ( ) > phi -> op ( ) -> ValueInputCount ( ) ) { Node * control = NodeProperties :: GetControlInput ( phi ) ; CHECK ( control -> opcode ( ) == IrOpcode :: kMerge || control -> opcode ( ) == IrOpcode :: kLoop ) ; CHECK_EQ ( ( * b ) , schedule -> block ( control ) ) ; } } } for ( BasicBlockVector :: iterator b = rpo_order -> begin ( ) ; b != rpo_order -> end ( ) ; ++ b ) { BasicBlock * block = * b ; Node * control = block -> control_input ( ) ; if ( control != nullptr ) { CHECK_EQ ( block , schedule -> block ( control ) ) ; CheckInputsDominate ( schedule , block , control , static_cast < int > ( block -> NodeCount ( ) ) - 1 ) ; } for ( size_t i = 0 ; i < block -> NodeCount ( ) ; i ++ ) { Node * node = block -> NodeAt ( i ) ; CheckInputsDominate ( schedule , block , node , static_cast < int > ( i ) - 1 ) ; } } }
Run ( ) override { return mDocShell -> InternalLoad ( mURI , mOriginalURI , mResultPrincipalURI , mLoadReplace , mReferrer , mReferrerPolicy , mTriggeringPrincipal , mPrincipalToInherit , mFlags , EmptyString ( ) , mTypeHint . IsVoid ( ) ? nullptr : mTypeHint . get ( ) , VoidString ( ) , mPostData , mHeadersData , mLoadType , mSHEntry , mFirstParty , mSrcdoc , mSourceDocShell , mBaseURI , nullptr , nullptr ) ; }
void Schedule :: AddCall ( BasicBlock * block , Node * call , BasicBlock * success_block , BasicBlock * exception_block ) { DCHECK_EQ ( BasicBlock :: kNone , block -> control ( ) ) ; DCHECK ( IsPotentiallyThrowingCall ( call -> opcode ( ) ) ) ; block -> set_control ( BasicBlock :: kCall ) ; AddSuccessor ( block , success_block ) ; AddSuccessor ( block , exception_block ) ; SetControlInput ( block , call ) ; }
GF_Box * mp4s_box_new ( ) { ISOM_DECL_BOX_ALLOC ( GF_MPEGSampleEntryBox , GF_ISOM_BOX_TYPE_MP4S ) ; gf_isom_sample_entry_init ( ( GF_SampleEntryBox * ) tmp ) ; tmp -> internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S ; return ( GF_Box * ) tmp ; }
Reduction JSNativeContextSpecialization :: ReduceJSHasInPrototypeChain ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSHasInPrototypeChain , node -> opcode ( ) ) ; Node * value = NodeProperties :: GetValueInput ( node , 0 ) ; Node * prototype = NodeProperties :: GetValueInput ( node , 1 ) ; Node * effect = NodeProperties :: GetEffectInput ( node ) ; HeapObjectMatcher m ( prototype ) ; if ( m . HasValue ( ) ) { InferHasInPrototypeChainResult result = InferHasInPrototypeChain ( value , effect , m . Value ( ) ) ; if ( result != kMayBeInPrototypeChain ) { Node * value = jsgraph ( ) -> BooleanConstant ( result == kIsInPrototypeChain ) ; ReplaceWithValue ( node , value ) ; return Replace ( value ) ; } } return NoChange ( ) ; }
static void alarm_ready_generic ( alarm_t * alarm , std :: unique_lock < std :: mutex > & lock ) { if ( alarm == NULL ) { return ; } alarm_callback_t callback = alarm -> callback ; void * data = alarm -> data ; period_ms_t deadline = alarm -> deadline ; if ( alarm -> is_periodic ) { deadline = alarm -> prev_deadline ; } else { alarm -> deadline = 0 ; alarm -> callback = NULL ; alarm -> data = NULL ; alarm -> queue = NULL ; } std :: lock_guard < std :: recursive_mutex > cb_lock ( * alarm -> callback_mutex ) ; lock . unlock ( ) ; update_scheduling_stats ( & alarm -> stats , now ( ) , deadline ) ; callback ( data ) ; }
static int scm_fp_copy ( struct cmsghdr * cmsg , struct scm_fp_list * * fplp ) { int * fdp = ( int * ) CMSG_DATA ( cmsg ) ; struct scm_fp_list * fpl = * fplp ; struct file * * fpp ; int i , num ; num = ( cmsg -> cmsg_len - CMSG_ALIGN ( sizeof ( struct cmsghdr ) ) ) / sizeof ( int ) ; if ( num <= 0 ) return 0 ; if ( num > SCM_MAX_FD ) return - EINVAL ; if ( ! fpl ) { fpl = kmalloc ( sizeof ( struct scm_fp_list ) , GFP_KERNEL ) ; if ( ! fpl ) return - ENOMEM ; * fplp = fpl ; fpl -> count = 0 ; fpl -> max = SCM_MAX_FD ; } fpp = & fpl -> fp [ fpl -> count ] ; if ( fpl -> count + num > fpl -> max ) return - EINVAL ; for ( i = 0 ; i < num ; i ++ ) { int fd = fdp [ i ] ; struct file * file ; if ( fd < 0 || ! ( file = fget_raw ( fd ) ) ) return - EBADF ; * fpp ++ = file ; fpl -> count ++ ; } return num ; }
static s32 avc_parse_slice ( GF_BitStream * bs , AVCState * avc , Bool svc_idr_flag , AVCSliceInfo * si ) { s32 pps_id , num_ref_idx_l0_active_minus1 = 0 , num_ref_idx_l1_active_minus1 = 0 ; gf_bs_read_ue_log ( bs , "first_mb_in_slice" ) ; si -> slice_type = gf_bs_read_ue_log ( bs , "slice_type" ) ; if ( si -> slice_type > 9 ) return - 1 ; pps_id = gf_bs_read_ue_log ( bs , "pps_id" ) ; if ( pps_id > 255 ) return - 1 ; si -> pps = & avc -> pps [ pps_id ] ; if ( ! si -> pps -> slice_group_count ) return - 2 ; si -> sps = & avc -> sps [ si -> pps -> sps_id ] ; if ( ! si -> sps -> log2_max_frame_num ) return - 2 ; avc -> sps_active_idx = si -> pps -> sps_id ; avc -> pps_active_idx = pps_id ; si -> frame_num = gf_bs_read_int_log ( bs , si -> sps -> log2_max_frame_num , "frame_num" ) ; si -> field_pic_flag = 0 ; si -> bottom_field_flag = 0 ; if ( ! si -> sps -> frame_mbs_only_flag ) { si -> field_pic_flag = gf_bs_read_int_log ( bs , 1 , "field_pic_flag" ) ; if ( si -> field_pic_flag ) si -> bottom_field_flag = gf_bs_read_int_log ( bs , 1 , "bottom_field_flag" ) ; } if ( ( si -> nal_unit_type == GF_AVC_NALU_IDR_SLICE ) || svc_idr_flag ) si -> idr_pic_id = gf_bs_read_ue_log ( bs , "idr_pic_id" ) ; if ( si -> sps -> poc_type == 0 ) { si -> poc_lsb = gf_bs_read_int_log ( bs , si -> sps -> log2_max_poc_lsb , "poc_lsb" ) ; if ( si -> pps -> pic_order_present && ! si -> field_pic_flag ) { si -> delta_poc_bottom = gf_bs_read_se_log ( bs , "poc_lsb" ) ; } } else if ( ( si -> sps -> poc_type == 1 ) && ! si -> sps -> delta_pic_order_always_zero_flag ) { si -> delta_poc [ 0 ] = gf_bs_read_se_log ( bs , "delta_poc0" ) ; if ( ( si -> pps -> pic_order_present == 1 ) && ! si -> field_pic_flag ) si -> delta_poc [ 1 ] = gf_bs_read_se_log ( bs , "delta_poc1" ) ; } if ( si -> pps -> redundant_pic_cnt_present ) { si -> redundant_pic_cnt = gf_bs_read_ue_log ( bs , "redundant_pic_cnt" ) ; } if ( si -> slice_type % 5 == GF_AVC_TYPE_B ) { gf_bs_read_int_log ( bs , 1 , "direct_spatial_mv_pred_flag" ) ; } num_ref_idx_l0_active_minus1 = si -> pps -> num_ref_idx_l0_default_active_minus1 ; num_ref_idx_l1_active_minus1 = si -> pps -> num_ref_idx_l1_default_active_minus1 ; if ( si -> slice_type % 5 == GF_AVC_TYPE_P || si -> slice_type % 5 == GF_AVC_TYPE_SP || si -> slice_type % 5 == GF_AVC_TYPE_B ) { Bool num_ref_idx_active_override_flag = gf_bs_read_int_log ( bs , 1 , "num_ref_idx_active_override_flag" ) ; if ( num_ref_idx_active_override_flag ) { num_ref_idx_l0_active_minus1 = gf_bs_read_ue_log ( bs , "num_ref_idx_l0_active_minus1" ) ; if ( si -> slice_type % 5 == GF_AVC_TYPE_B ) { num_ref_idx_l1_active_minus1 = gf_bs_read_ue_log ( bs , "num_ref_idx_l1_active_minus1" ) ; } } } if ( si -> nal_unit_type == 20 || si -> nal_unit_type == 21 ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( "[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\n" ) ) ; assert ( 0 ) ; return - 1 ; } else { ref_pic_list_modification ( bs , si -> slice_type ) ; } if ( ( si -> pps -> weighted_pred_flag && ( si -> slice_type % 5 == GF_AVC_TYPE_P || si -> slice_type % 5 == GF_AVC_TYPE_SP ) ) || ( si -> pps -> weighted_bipred_idc == 1 && si -> slice_type % 5 == GF_AVC_TYPE_B ) ) { pred_weight_table ( bs , si -> slice_type , si -> sps -> ChromaArrayType , num_ref_idx_l0_active_minus1 , num_ref_idx_l1_active_minus1 ) ; } if ( si -> nal_ref_idc != 0 ) { dec_ref_pic_marking ( bs , ( si -> nal_unit_type == GF_AVC_NALU_IDR_SLICE ) ) ; } if ( si -> pps -> entropy_coding_mode_flag && si -> slice_type % 5 != GF_AVC_TYPE_I && si -> slice_type % 5 != GF_AVC_TYPE_SI ) { gf_bs_read_ue_log ( bs , "cabac_init_idc" ) ; } gf_bs_read_se ( bs ) ; if ( si -> slice_type % 5 == GF_AVC_TYPE_SP || si -> slice_type % 5 == GF_AVC_TYPE_SI ) { if ( si -> slice_type % 5 == GF_AVC_TYPE_SP ) { gf_bs_read_int_log ( bs , 1 , "sp_for_switch_flag" ) ; } gf_bs_read_se_log ( bs , "slice_qs_delta" ) ; } if ( si -> pps -> deblocking_filter_control_present_flag ) { if ( gf_bs_read_ue_log ( bs , "disable_deblocking_filter_idc" ) != 1 ) { gf_bs_read_se_log ( bs , "slice_alpha_c0_offset_div2" ) ; gf_bs_read_se_log ( bs , "slice_beta_offset_div2" ) ; } } if ( si -> pps -> slice_group_count > 1 && si -> pps -> mb_slice_group_map_type >= 3 && si -> pps -> mb_slice_group_map_type <= 5 ) { gf_bs_read_int_log ( bs , ( u32 ) ceil ( log1p ( ( si -> pps -> pic_size_in_map_units_minus1 + 1 ) / ( si -> pps -> slice_group_change_rate_minus1 + 1 ) ) / log ( 2 ) ) , "slice_group_change_cycle" ) ; } return 0 ; }
cupsSetDests2 ( http_t * http , int num_dests , cups_dest_t * dests ) { int i , j ; int wrote ; cups_dest_t * dest ; cups_option_t * option ; _ipp_option_t * match ; FILE * fp ; #ifndef WIN32 const char * home ; #endif /* WIN32 */ char filename [ 1024 ] ; int num_temps ; cups_dest_t * temps = NULL , * temp ; const char * val ; _cups_globals_t * cg = _cupsGlobals ( ) ; if ( ! num_dests || ! dests ) return ( - 1 ) ; num_temps = _cupsGetDests ( http , IPP_OP_CUPS_GET_PRINTERS , NULL , & temps , 0 , 0 ) ; if ( cupsLastError ( ) >= IPP_STATUS_REDIRECTION_OTHER_SITE ) { cupsFreeDests ( num_temps , temps ) ; return ( - 1 ) ; } snprintf ( filename , sizeof ( filename ) , "%s/lpoptions" , cg -> cups_serverroot ) ; #ifndef WIN32 if ( getuid ( ) ) { num_temps = cups_get_dests ( filename , NULL , NULL , 0 , num_temps , & temps ) ; if ( ( home = getenv ( "HOME" ) ) != NULL ) { snprintf ( filename , sizeof ( filename ) , "%s/.cups" , home ) ; if ( access ( filename , 0 ) ) mkdir ( filename , 0700 ) ; snprintf ( filename , sizeof ( filename ) , "%s/.cups/lpoptions" , home ) ; } } #endif /* !WIN32 */ if ( ( fp = fopen ( filename , "w" ) ) == NULL ) { cupsFreeDests ( num_temps , temps ) ; return ( - 1 ) ; } #ifndef WIN32 if ( ! getuid ( ) ) fchmod ( fileno ( fp ) , 0644 ) ; #endif /* !WIN32 */ for ( i = num_dests , dest = dests ; i > 0 ; i -- , dest ++ ) if ( dest -> instance != NULL || dest -> num_options != 0 || dest -> is_default ) { if ( dest -> is_default ) { fprintf ( fp , "Default %s" , dest -> name ) ; if ( dest -> instance ) fprintf ( fp , "/%s" , dest -> instance ) ; wrote = 1 ; } else wrote = 0 ; if ( ( temp = cupsGetDest ( dest -> name , dest -> instance , num_temps , temps ) ) == NULL ) temp = cupsGetDest ( dest -> name , NULL , num_temps , temps ) ; for ( j = dest -> num_options , option = dest -> options ; j > 0 ; j -- , option ++ ) { if ( ( match = _ippFindOption ( option -> name ) ) != NULL && match -> group_tag == IPP_TAG_PRINTER ) continue ; if ( temp && ( val = cupsGetOption ( option -> name , temp -> num_options , temp -> options ) ) != NULL && ! _cups_strcasecmp ( val , option -> value ) ) continue ; if ( ! wrote ) { fprintf ( fp , "Dest %s" , dest -> name ) ; if ( dest -> instance ) fprintf ( fp , "/%s" , dest -> instance ) ; wrote = 1 ; } if ( option -> value [ 0 ] ) { if ( strchr ( option -> value , ' ' ) || strchr ( option -> value , '\\' ) || strchr ( option -> value , '\"' ) || strchr ( option -> value , '\'' ) ) { fprintf ( fp , " %s=\"" , option -> name ) ; for ( val = option -> value ; * val ; val ++ ) { if ( strchr ( "\"\'\\" , * val ) ) putc ( '\\' , fp ) ; putc ( * val , fp ) ; } putc ( '\"' , fp ) ; } else { fprintf ( fp , " %s=%s" , option -> name , option -> value ) ; } } else fprintf ( fp , " %s" , option -> name ) ; } if ( wrote ) fputs ( "\n" , fp ) ; } cupsFreeDests ( num_temps , temps ) ; fclose ( fp ) ; #ifdef __APPLE__ if ( ( dest = cupsGetDest ( NULL , NULL , num_dests , dests ) ) != NULL ) { CFStringRef name = CFStringCreateWithCString ( kCFAllocatorDefault , dest -> name , kCFStringEncodingUTF8 ) ; if ( name ) { _cupsAppleSetDefaultPrinter ( name ) ; CFRelease ( name ) ; } } #endif /* __APPLE__ */ #ifdef HAVE_NOTIFY_POST notify_post ( "com.apple.printerListChange" ) ; #endif /* HAVE_NOTIFY_POST */ return ( 0 ) ; }
static const Operator * PointerConstant ( CommonOperatorBuilder * common , intptr_t ptr ) { return kPointerSize == 8 ? common -> Int64Constant ( ptr ) : common -> Int32Constant ( static_cast < int32_t > ( ptr ) ) ; }
InitTextures ( IDirect3DDevice9 * aDevice , const IntSize & aSize , _D3DFORMAT aFormat , RefPtr < IDirect3DSurface9 > & aSurface , HANDLE & aHandle , D3DLOCKED_RECT & aLockedRect ) { if ( ! aDevice ) { return nullptr ; } RefPtr < IDirect3DTexture9 > result ; if ( FAILED ( aDevice -> CreateTexture ( aSize . width , aSize . height , 1 , 0 , aFormat , D3DPOOL_DEFAULT , byRef ( result ) , & aHandle ) ) ) { return nullptr ; } if ( ! result ) { return nullptr ; } RefPtr < IDirect3DTexture9 > tmpTexture ; if ( FAILED ( aDevice -> CreateTexture ( aSize . width , aSize . height , 1 , 0 , aFormat , D3DPOOL_SYSTEMMEM , byRef ( tmpTexture ) , nullptr ) ) ) { return nullptr ; } if ( ! tmpTexture ) { return nullptr ; } tmpTexture -> GetSurfaceLevel ( 0 , byRef ( aSurface ) ) ; aSurface -> LockRect ( & aLockedRect , nullptr , 0 ) ; if ( ! aLockedRect . pBits ) { NS_WARNING ( "Could not lock surface" ) ; return nullptr ; } return result . forget ( ) ; }
CycleCollectedJSRuntime :: CycleCollectedJSRuntime ( JSContext * aCx ) : mGCThingCycleCollectorGlobal ( sGCThingCycleCollectorGlobal ) , mJSZoneCycleCollectorGlobal ( sJSZoneCycleCollectorGlobal ) , mJSRuntime ( JS_GetRuntime ( aCx ) ) , mHasPendingIdleGCTask ( false ) , mPrevGCSliceCallback ( nullptr ) , mPrevGCNurseryCollectionCallback ( nullptr ) , mJSHolderMap ( 256 ) , mOutOfMemoryState ( OOMState :: OK ) , mLargeAllocationFailureState ( OOMState :: OK ) #ifdef DEBUG , mShutdownCalled ( false ) #endif { MOZ_COUNT_CTOR ( CycleCollectedJSRuntime ) ; MOZ_ASSERT ( aCx ) ; MOZ_ASSERT ( mJSRuntime ) ; if ( ! JS_AddExtraGCRootsTracer ( aCx , TraceBlackJS , this ) ) { MOZ_CRASH ( "JS_AddExtraGCRootsTracer failed" ) ; } JS_SetGrayGCRootsTracer ( aCx , TraceGrayJS , this ) ; JS_SetGCCallback ( aCx , GCCallback , this ) ; mPrevGCSliceCallback = JS :: SetGCSliceCallback ( aCx , GCSliceCallback ) ; if ( NS_IsMainThread ( ) ) { mPrevGCNurseryCollectionCallback = JS :: SetGCNurseryCollectionCallback ( aCx , GCNurseryCollectionCallback ) ; } JS_SetObjectsTenuredCallback ( aCx , JSObjectsTenuredCb , this ) ; JS :: SetOutOfMemoryCallback ( aCx , OutOfMemoryCallback , this ) ; JS_SetExternalStringSizeofCallback ( aCx , SizeofExternalStringCallback ) ; JS :: SetWarningReporter ( aCx , MozCrashWarningReporter ) ; js :: AutoEnterOOMUnsafeRegion :: setAnnotateOOMAllocationSizeCallback ( CrashReporter :: AnnotateOOMAllocationSize ) ; static js :: DOMCallbacks DOMcallbacks = { InstanceClassHasProtoAtDepth } ; SetDOMCallbacks ( aCx , & DOMcallbacks ) ; js :: SetScriptEnvironmentPreparer ( aCx , & mEnvironmentPreparer ) ; JS :: dbg :: SetDebuggerMallocSizeOf ( aCx , moz_malloc_size_of ) ; #ifdef MOZ_JS_DEV_ERROR_INTERCEPTOR JS_SetErrorInterceptorCallback ( mJSRuntime , & mErrorInterceptor ) ; #endif  // MOZ_JS_DEV_ERROR_INTERCEPTOR }
enum sctp_disposition sctp_sf_shutdown_pending_abort ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const union sctp_subtype type , void * arg , struct sctp_cmd_seq * commands ) { struct sctp_chunk * chunk = arg ; if ( ! sctp_vtag_verify_either ( chunk , asoc ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( struct sctp_abort_chunk ) ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; if ( SCTP_ADDR_DEL == sctp_bind_addr_state ( & asoc -> base . bind_addr , & chunk -> dest ) ) return sctp_sf_discard_chunk ( net , ep , asoc , type , arg , commands ) ; if ( ! sctp_err_chunk_valid ( chunk ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; return __sctp_sf_do_9_1_abort ( net , ep , asoc , type , arg , commands ) ; }
void FXJS_DefineObjProperty ( v8 :: Isolate * pIsolate , int nObjDefnID , const wchar_t * sPropName , v8 :: AccessorGetterCallback pPropGet , v8 :: AccessorSetterCallback pPropPut ) { v8 :: Isolate :: Scope isolate_scope ( pIsolate ) ; v8 :: HandleScope handle_scope ( pIsolate ) ; CFX_ByteString bsPropertyName = CFX_WideString ( sPropName ) . UTF8Encode ( ) ; CFXJS_ObjDefinition * pObjDef = CFXJS_ObjDefinition :: ForID ( pIsolate , nObjDefnID ) ; pObjDef -> GetInstanceTemplate ( ) -> SetAccessor ( v8 :: String :: NewFromUtf8 ( pIsolate , bsPropertyName . c_str ( ) , v8 :: NewStringType :: kNormal ) . ToLocalChecked ( ) , pPropGet , pPropPut ) ; }
nsXBLBinding :: ChangeDocument ( nsIDocument * aOldDocument , nsIDocument * aNewDocument ) { if ( aOldDocument != aNewDocument ) { if ( mIsStyleBinding ) { if ( mPrototypeBinding -> HasImplementation ( ) ) { nsIScriptGlobalObject * global = aOldDocument -> GetScopeObject ( ) ; if ( global ) { JSObject * scope = global -> GetGlobalJSObject ( ) ; nsCOMPtr < nsIScriptContext > context = global -> GetContext ( ) ; if ( context && scope ) { JSContext * cx = context -> GetNativeContext ( ) ; nsCxPusher pusher ; pusher . Push ( cx , nsCxPusher :: ASSERT_SCRIPT_CONTEXT ) ; JSObject * scriptObject = mBoundElement -> GetWrapper ( ) ; if ( scriptObject ) { JSObject * base = scriptObject ; JSObject * proto ; JSAutoRequest ar ( cx ) ; JSAutoCompartment ac ( cx , scriptObject ) ; for ( ; true ; base = proto ) { if ( ! JS_GetPrototype ( cx , base , & proto ) ) { return ; } if ( ! proto ) { break ; } JSClass * clazz = :: JS_GetClass ( proto ) ; if ( ! clazz || ( ~ clazz -> flags & ( JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS ) ) || JSCLASS_RESERVED_SLOTS ( clazz ) != 1 || clazz -> finalize != XBLFinalize ) { continue ; } nsRefPtr < nsXBLDocumentInfo > docInfo = static_cast < nsXBLDocumentInfo * > ( :: JS_GetPrivate ( proto ) ) ; if ( ! docInfo ) { continue ; } jsval protoBinding = :: JS_GetReservedSlot ( proto , 0 ) ; if ( JSVAL_TO_PRIVATE ( protoBinding ) != mPrototypeBinding ) { continue ; } JSObject * grandProto ; if ( ! JS_GetPrototype ( cx , proto , & grandProto ) ) { return ; } :: JS_SetPrototype ( cx , base , grandProto ) ; break ; } mPrototypeBinding -> UndefineFields ( cx , scriptObject ) ; } } } } UnhookEventHandlers ( ) ; } { nsAutoScriptBlocker scriptBlocker ; if ( mNextBinding ) { mNextBinding -> ChangeDocument ( aOldDocument , aNewDocument ) ; } nsIContent * anonymous = mContent ; if ( anonymous ) { if ( mInsertionPointTable ) mInsertionPointTable -> Enumerate ( ChangeDocumentForDefaultContent , nullptr ) ; nsXBLBinding :: UninstallAnonymousContent ( aOldDocument , anonymous ) ; } nsBindingManager * bindingManager = aOldDocument -> BindingManager ( ) ; for ( nsIContent * child = mBoundElement -> GetLastChild ( ) ; child ; child = child -> GetPreviousSibling ( ) ) { bindingManager -> SetInsertionParent ( child , nullptr ) ; } } } }
dump_keywords ( vector_t * keydump , int level , FILE * fp ) { unsigned int i ; keyword_t * keyword_vec ; char file_name [ 21 ] ; if ( ! level ) { snprintf ( file_name , sizeof ( file_name ) , "/tmp/keywords.%d" , getpid ( ) ) ; fp = fopen ( file_name , "w" ) ; if ( ! fp ) return ; } for ( i = 0 ; i < vector_size ( keydump ) ; i ++ ) { keyword_vec = vector_slot ( keydump , i ) ; fprintf ( fp , "%*sKeyword : %s (%s)\n" , level * 2 , "" , keyword_vec -> string , keyword_vec -> active ? "active" : "disabled" ) ; if ( keyword_vec -> sub ) dump_keywords ( keyword_vec -> sub , level + 1 , fp ) ; } if ( ! level ) fclose ( fp ) ; }
static int read_compressed_header ( VP9Decoder * pbi , const uint8_t * data , size_t partition_size ) { VP9_COMMON * const cm = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; FRAME_CONTEXT * const fc = & cm -> fc ; vp9_reader r ; int k ; if ( vp9_reader_init ( & r , data , partition_size ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , "Failed to allocate bool decoder 0" ) ; cm -> tx_mode = xd -> lossless ? ONLY_4X4 : read_tx_mode ( & r ) ; if ( cm -> tx_mode == TX_MODE_SELECT ) read_tx_mode_probs ( & fc -> tx_probs , & r ) ; read_coef_probs ( fc , cm -> tx_mode , & r ) ; for ( k = 0 ; k < SKIP_CONTEXTS ; ++ k ) vp9_diff_update_prob ( & r , & fc -> skip_probs [ k ] ) ; if ( ! frame_is_intra_only ( cm ) ) { nmv_context * const nmvc = & fc -> nmvc ; int i , j ; read_inter_mode_probs ( fc , & r ) ; if ( cm -> interp_filter == SWITCHABLE ) read_switchable_interp_probs ( fc , & r ) ; for ( i = 0 ; i < INTRA_INTER_CONTEXTS ; i ++ ) vp9_diff_update_prob ( & r , & fc -> intra_inter_prob [ i ] ) ; cm -> reference_mode = read_frame_reference_mode ( cm , & r ) ; if ( cm -> reference_mode != SINGLE_REFERENCE ) setup_compound_reference_mode ( cm ) ; read_frame_reference_mode_probs ( cm , & r ) ; for ( j = 0 ; j < BLOCK_SIZE_GROUPS ; j ++ ) for ( i = 0 ; i < INTRA_MODES - 1 ; ++ i ) vp9_diff_update_prob ( & r , & fc -> y_mode_prob [ j ] [ i ] ) ; for ( j = 0 ; j < PARTITION_CONTEXTS ; ++ j ) for ( i = 0 ; i < PARTITION_TYPES - 1 ; ++ i ) vp9_diff_update_prob ( & r , & fc -> partition_prob [ j ] [ i ] ) ; read_mv_probs ( nmvc , cm -> allow_high_precision_mv , & r ) ; } return vp9_reader_has_error ( & r ) ; }
js :: UnwindForUncatchableException ( JSContext * cx , const InterpreterRegs & regs ) { for ( TryNoteIter tni ( cx , regs ) ; ! tni . done ( ) ; ++ tni ) { JSTryNote * tn = * tni ; if ( tn -> kind == JSTRY_ITER ) { Value * sp = regs . spForStackDepth ( tn -> stackDepth ) ; UnwindIteratorForUncatchableException ( cx , & sp [ - 1 ] . toObject ( ) ) ; } } }
FieldAccess AccessBuilder :: ForOrderedHashTableBaseNumberOfBuckets ( ) { FieldAccess const access = { kTaggedBase , OrderedHashTableBase :: kNumberOfBucketsOffset , MaybeHandle < Name > ( ) , MaybeHandle < Map > ( ) , TypeCache :: Get ( ) . kFixedArrayLengthType , MachineType :: TaggedSigned ( ) , kNoWriteBarrier } ; return access ; }
png_do_rgb_to_gray ( png_structrp png_ptr , png_row_infop row_info , png_bytep row ) { int rgb_error = 0 ; png_debug ( 1 , "in png_do_rgb_to_gray" ) ; if ( ! ( row_info -> color_type & PNG_COLOR_MASK_PALETTE ) && ( row_info -> color_type & PNG_COLOR_MASK_COLOR ) ) { PNG_CONST png_uint_32 rc = png_ptr -> rgb_to_gray_red_coeff ; PNG_CONST png_uint_32 gc = png_ptr -> rgb_to_gray_green_coeff ; PNG_CONST png_uint_32 bc = 32768 - rc - gc ; PNG_CONST png_uint_32 row_width = row_info -> width ; PNG_CONST int have_alpha = ( row_info -> color_type & PNG_COLOR_MASK_ALPHA ) != 0 ; if ( row_info -> bit_depth == 8 ) { #ifdef PNG_READ_GAMMA_SUPPORTED if ( png_ptr -> gamma_from_1 != NULL && png_ptr -> gamma_to_1 != NULL ) { png_bytep sp = row ; png_bytep dp = row ; png_uint_32 i ; for ( i = 0 ; i < row_width ; i ++ ) { png_byte red = * ( sp ++ ) ; png_byte green = * ( sp ++ ) ; png_byte blue = * ( sp ++ ) ; if ( red != green || red != blue ) { red = png_ptr -> gamma_to_1 [ red ] ; green = png_ptr -> gamma_to_1 [ green ] ; blue = png_ptr -> gamma_to_1 [ blue ] ; rgb_error |= 1 ; * ( dp ++ ) = png_ptr -> gamma_from_1 [ ( rc * red + gc * green + bc * blue + 16384 ) > > 15 ] ; } else { if ( png_ptr -> gamma_table != NULL ) red = png_ptr -> gamma_table [ red ] ; * ( dp ++ ) = red ; } if ( have_alpha ) * ( dp ++ ) = * ( sp ++ ) ; } } else #endif { png_bytep sp = row ; png_bytep dp = row ; png_uint_32 i ; for ( i = 0 ; i < row_width ; i ++ ) { png_byte red = * ( sp ++ ) ; png_byte green = * ( sp ++ ) ; png_byte blue = * ( sp ++ ) ; if ( red != green || red != blue ) { rgb_error |= 1 ; * ( dp ++ ) = ( png_byte ) ( ( rc * red + gc * green + bc * blue ) > > 15 ) ; } else * ( dp ++ ) = red ; if ( have_alpha ) * ( dp ++ ) = * ( sp ++ ) ; } } } else { #ifdef PNG_READ_GAMMA_SUPPORTED if ( png_ptr -> gamma_16_to_1 != NULL && png_ptr -> gamma_16_from_1 != NULL ) { png_bytep sp = row ; png_bytep dp = row ; png_uint_32 i ; for ( i = 0 ; i < row_width ; i ++ ) { png_uint_16 red , green , blue , w ; red = ( png_uint_16 ) ( ( ( * ( sp ) ) < < 8 ) | * ( sp + 1 ) ) ; sp += 2 ; green = ( png_uint_16 ) ( ( ( * ( sp ) ) < < 8 ) | * ( sp + 1 ) ) ; sp += 2 ; blue = ( png_uint_16 ) ( ( ( * ( sp ) ) < < 8 ) | * ( sp + 1 ) ) ; sp += 2 ; if ( red == green && red == blue ) { if ( png_ptr -> gamma_16_table != NULL ) w = png_ptr -> gamma_16_table [ ( red & 0xff ) > > png_ptr -> gamma_shift ] [ red > > 8 ] ; else w = red ; } else { png_uint_16 red_1 = png_ptr -> gamma_16_to_1 [ ( red & 0xff ) > > png_ptr -> gamma_shift ] [ red > > 8 ] ; png_uint_16 green_1 = png_ptr -> gamma_16_to_1 [ ( green & 0xff ) > > png_ptr -> gamma_shift ] [ green > > 8 ] ; png_uint_16 blue_1 = png_ptr -> gamma_16_to_1 [ ( blue & 0xff ) > > png_ptr -> gamma_shift ] [ blue > > 8 ] ; png_uint_16 gray16 = ( png_uint_16 ) ( ( rc * red_1 + gc * green_1 + bc * blue_1 + 16384 ) > > 15 ) ; w = png_ptr -> gamma_16_from_1 [ ( gray16 & 0xff ) > > png_ptr -> gamma_shift ] [ gray16 > > 8 ] ; rgb_error |= 1 ; } * ( dp ++ ) = ( png_byte ) ( ( w > > 8 ) & 0xff ) ; * ( dp ++ ) = ( png_byte ) ( w & 0xff ) ; if ( have_alpha ) { * ( dp ++ ) = * ( sp ++ ) ; * ( dp ++ ) = * ( sp ++ ) ; } } } else #endif { png_bytep sp = row ; png_bytep dp = row ; png_uint_32 i ; for ( i = 0 ; i < row_width ; i ++ ) { png_uint_16 red , green , blue , gray16 ; red = ( png_uint_16 ) ( ( ( * ( sp ) ) < < 8 ) | * ( sp + 1 ) ) ; sp += 2 ; green = ( png_uint_16 ) ( ( ( * ( sp ) ) < < 8 ) | * ( sp + 1 ) ) ; sp += 2 ; blue = ( png_uint_16 ) ( ( ( * ( sp ) ) < < 8 ) | * ( sp + 1 ) ) ; sp += 2 ; if ( red != green || red != blue ) rgb_error |= 1 ; gray16 = ( png_uint_16 ) ( ( rc * red + gc * green + bc * blue + 16384 ) > > 15 ) ; * ( dp ++ ) = ( png_byte ) ( ( gray16 > > 8 ) & 0xff ) ; * ( dp ++ ) = ( png_byte ) ( gray16 & 0xff ) ; if ( have_alpha ) { * ( dp ++ ) = * ( sp ++ ) ; * ( dp ++ ) = * ( sp ++ ) ; } } } } row_info -> channels = ( png_byte ) ( row_info -> channels - 2 ) ; row_info -> color_type = ( png_byte ) ( row_info -> color_type & ~ PNG_COLOR_MASK_COLOR ) ; row_info -> pixel_depth = ( png_byte ) ( row_info -> channels * row_info -> bit_depth ) ; row_info -> rowbytes = PNG_ROWBYTES ( row_info -> pixel_depth , row_width ) ; } return rgb_error ; }
png_push_read_IDAT ( png_structrp png_ptr ) { if ( ! ( png_ptr -> mode & PNG_HAVE_CHUNK_HEADER ) ) { png_byte chunk_length [ 4 ] ; png_byte chunk_tag [ 4 ] ; if ( png_ptr -> buffer_size < 8 ) { png_push_save_buffer ( png_ptr ) ; return ; } png_push_fill_buffer ( png_ptr , chunk_length , 4 ) ; png_ptr -> push_length = png_get_uint_31 ( png_ptr , chunk_length ) ; png_reset_crc ( png_ptr ) ; png_crc_read ( png_ptr , chunk_tag , 4 ) ; png_ptr -> chunk_name = PNG_CHUNK_FROM_STRING ( chunk_tag ) ; png_ptr -> mode |= PNG_HAVE_CHUNK_HEADER ; if ( png_ptr -> chunk_name != png_IDAT ) { png_ptr -> process_mode = PNG_READ_CHUNK_MODE ; if ( ! ( png_ptr -> flags & PNG_FLAG_ZSTREAM_ENDED ) ) png_error ( png_ptr , "Not enough compressed data" ) ; return ; } png_ptr -> idat_size = png_ptr -> push_length ; } if ( png_ptr -> idat_size && png_ptr -> save_buffer_size ) { png_size_t save_size = png_ptr -> save_buffer_size ; png_uint_32 idat_size = png_ptr -> idat_size ; if ( idat_size < save_size ) save_size = ( png_size_t ) idat_size ; else idat_size = ( png_uint_32 ) save_size ; png_calculate_crc ( png_ptr , png_ptr -> save_buffer_ptr , save_size ) ; png_process_IDAT_data ( png_ptr , png_ptr -> save_buffer_ptr , save_size ) ; png_ptr -> idat_size -= idat_size ; png_ptr -> buffer_size -= save_size ; png_ptr -> save_buffer_size -= save_size ; png_ptr -> save_buffer_ptr += save_size ; } if ( png_ptr -> idat_size && png_ptr -> current_buffer_size ) { png_size_t save_size = png_ptr -> current_buffer_size ; png_uint_32 idat_size = png_ptr -> idat_size ; if ( idat_size < save_size ) save_size = ( png_size_t ) idat_size ; else idat_size = ( png_uint_32 ) save_size ; png_calculate_crc ( png_ptr , png_ptr -> current_buffer_ptr , save_size ) ; png_process_IDAT_data ( png_ptr , png_ptr -> current_buffer_ptr , save_size ) ; png_ptr -> idat_size -= idat_size ; png_ptr -> buffer_size -= save_size ; png_ptr -> current_buffer_size -= save_size ; png_ptr -> current_buffer_ptr += save_size ; } if ( ! png_ptr -> idat_size ) { if ( png_ptr -> buffer_size < 4 ) { png_push_save_buffer ( png_ptr ) ; return ; } png_crc_finish ( png_ptr , 0 ) ; png_ptr -> mode &= ~ PNG_HAVE_CHUNK_HEADER ; png_ptr -> mode |= PNG_AFTER_IDAT ; png_ptr -> zowner = 0 ; } }
bool ReadFontCollection ( const uint8_t * data , size_t len , FontCollection * font_collection ) { Buffer file ( data , len ) ; uint32_t flavor ; if ( ! file . ReadU32 ( & flavor ) ) { return FONT_COMPRESSION_FAILURE ( ) ; } if ( flavor != kTtcFontFlavor ) { font_collection -> fonts . resize ( 1 ) ; Font & font = font_collection -> fonts [ 0 ] ; font . flavor = flavor ; return ReadTrueTypeFont ( & file , data , len , & font ) ; } return ReadTrueTypeCollection ( & file , data , len , font_collection ) ; }
Response V8DebuggerAgentImpl :: stepInto ( Maybe < bool > inBreakOnAsyncCall ) { if ( ! isPaused ( ) ) return Response :: Error ( kDebuggerNotPaused ) ; m_session -> releaseObjectGroup ( kBacktraceObjectGroup ) ; m_debugger -> stepIntoStatement ( m_session -> contextGroupId ( ) , inBreakOnAsyncCall . fromMaybe ( false ) ) ; return Response :: OK ( ) ; }
nsFrameLoader :: LoadFrame ( ErrorResult & aRv ) { nsresult rv = LoadFrame ( ) ; if ( NS_FAILED ( rv ) ) { aRv . Throw ( rv ) ; } }
ssize_t socket_read ( const socket_t * socket , void * buf , size_t count ) { assert ( socket != NULL ) ; assert ( buf != NULL ) ; return recv ( socket -> fd , buf , count , MSG_DONTWAIT ) ; }
nsHttpChannel :: AsyncProcessRedirection ( uint32_t redirectType ) { LOG ( ( "nsHttpChannel::AsyncProcessRedirection [this=%p type=%u]\n" , this , redirectType ) ) ; const char * location = mResponseHead -> PeekHeader ( nsHttp :: Location ) ; if ( ! location ) return NS_ERROR_FAILURE ; nsAutoCString locationBuf ; if ( NS_EscapeURL ( location , - 1 , esc_OnlyNonASCII , locationBuf ) ) location = locationBuf . get ( ) ; if ( mRedirectionLimit == 0 ) { LOG ( ( "redirection limit reached!\n" ) ) ; return NS_ERROR_REDIRECT_LOOP ; } mRedirectType = redirectType ; LOG ( ( "redirecting to: %s [redirection-limit=%u]\n" , location , uint32_t ( mRedirectionLimit ) ) ) ; nsresult rv = CreateNewURI ( location , getter_AddRefs ( mRedirectURI ) ) ; if ( NS_FAILED ( rv ) ) { LOG ( ( "Invalid URI for redirect: Location: %s\n" , location ) ) ; return NS_ERROR_CORRUPTED_CONTENT ; } nsAutoCString redirectHost ; mRedirectURI -> GetHost ( redirectHost ) ; nsAutoCString currentHost ; mURI -> GetHost ( currentHost ) ; if ( redirectHost != currentHost ) { nsAutoCString unescapedHost ; if ( NS_UnescapeURL ( redirectHost . BeginReading ( ) , redirectHost . Length ( ) , 0 , unescapedHost ) ) { if ( IsUTF8 ( unescapedHost ) ) { mRedirectURI -> SetHost ( unescapedHost ) ; } } } if ( mApplicationCache ) { if ( ! NS_SecurityCompareURIs ( mURI , mRedirectURI , false ) ) { PushRedirectAsyncFunc ( & nsHttpChannel :: ContinueProcessRedirectionAfterFallback ) ; bool waitingForRedirectCallback ; ( void ) ProcessFallback ( & waitingForRedirectCallback ) ; if ( waitingForRedirectCallback ) return NS_OK ; PopRedirectAsyncFunc ( & nsHttpChannel :: ContinueProcessRedirectionAfterFallback ) ; } } return ContinueProcessRedirectionAfterFallback ( NS_OK ) ; }
% % o exception : return any errors or warnings in this structure . % * / static Image * ReadCALSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] , header [ MagickPathExtent ] , message [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register ssize_t i ; unsigned long density , direction , height , orientation , pel_path , type , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( header , 0 , sizeof ( header ) ) ; density = 0 ; direction = 0 ; orientation = 1 ; pel_path = 0 ; type = 1 ; width = 0 ; height = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) break ; switch ( * header ) { case 'R' : case 'r' : { if ( LocaleNCompare ( header , "rdensty:" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , "%lu" , & density ) ; break ; } if ( LocaleNCompare ( header , "rpelcnt:" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , "%lu,%lu" , & width , & height ) ; break ; } if ( LocaleNCompare ( header , "rorient:" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , "%lu,%lu" , & pel_path , & direction ) ; if ( pel_path == 90 ) orientation = 5 ; else if ( pel_path == 180 ) orientation = 3 ; else if ( pel_path == 270 ) orientation = 7 ; if ( direction == 90 ) orientation ++ ; break ; } if ( LocaleNCompare ( header , "rtype:" , 6 ) == 0 ) { ( void ) sscanf ( header + 6 , "%lu" , & type ) ; break ; } break ; } } } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) ThrowImageException ( FileOpenError , "UnableToCreateTemporaryFile" ) ; while ( ( c = ReadBlobByte ( image ) ) != EOF ) ( void ) fputc ( c , file ) ; ( void ) fclose ( file ) ; ( void ) CloseBlob ( image ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "group4:%s" , filename ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , "%lux%lu" , width , height ) ; ( void ) CloneString ( & read_info -> size , message ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , "%lu" , density ) ; ( void ) CloneString ( & read_info -> density , message ) ; read_info -> orientation = ( OrientationType ) orientation ; image = ReadImage ( read_info , exception ) ; if ( image != ( Image * ) NULL ) { ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick , "CALS" , MagickPathExtent ) ; }
bool ResourceHandle :: ParseFromString ( const string & s ) { ResourceHandleProto proto ; const bool status = proto . ParseFromString ( s ) ; if ( status ) FromProto ( proto ) ; return status ; }
void jpeg_decoder :: make_huff_table ( int index , huff_tables * pH ) { int p , i , l , si ; uint8 huffsize [ 257 ] ; uint huffcode [ 257 ] ; uint code ; uint subtree ; int code_size ; int lastp ; int nextfreeentry ; int currententry ; pH -> ac_table = m_huff_ac [ index ] != 0 ; p = 0 ; for ( l = 1 ; l <= 16 ; l ++ ) { for ( i = 1 ; i <= m_huff_num [ index ] [ l ] ; i ++ ) huffsize [ p ++ ] = static_cast < uint8 > ( l ) ; } huffsize [ p ] = 0 ; lastp = p ; code = 0 ; si = huffsize [ 0 ] ; p = 0 ; while ( huffsize [ p ] ) { while ( huffsize [ p ] == si ) { huffcode [ p ++ ] = code ; code ++ ; } code <<= 1 ; si ++ ; } memset ( pH -> look_up , 0 , sizeof ( pH -> look_up ) ) ; memset ( pH -> look_up2 , 0 , sizeof ( pH -> look_up2 ) ) ; memset ( pH -> tree , 0 , sizeof ( pH -> tree ) ) ; memset ( pH -> code_size , 0 , sizeof ( pH -> code_size ) ) ; nextfreeentry = - 1 ; p = 0 ; while ( p < lastp ) { i = m_huff_val [ index ] [ p ] ; code = huffcode [ p ] ; code_size = huffsize [ p ] ; pH -> code_size [ i ] = static_cast < uint8 > ( code_size ) ; if ( code_size <= 8 ) { code <<= ( 8 - code_size ) ; for ( l = 1 < < ( 8 - code_size ) ; l > 0 ; l -- ) { JPGD_ASSERT ( i < 256 ) ; pH -> look_up [ code ] = i ; bool has_extrabits = false ; int extra_bits = 0 ; int num_extra_bits = i & 15 ; int bits_to_fetch = code_size ; if ( num_extra_bits ) { int total_codesize = code_size + num_extra_bits ; if ( total_codesize <= 8 ) { has_extrabits = true ; extra_bits = ( ( 1 < < num_extra_bits ) - 1 ) & ( code > > ( 8 - total_codesize ) ) ; JPGD_ASSERT ( extra_bits <= 0x7FFF ) ; bits_to_fetch += num_extra_bits ; } } if ( ! has_extrabits ) pH -> look_up2 [ code ] = i | ( bits_to_fetch < < 8 ) ; else pH -> look_up2 [ code ] = i | 0x8000 | ( extra_bits < < 16 ) | ( bits_to_fetch < < 8 ) ; code ++ ; } } else { subtree = ( code > > ( code_size - 8 ) ) & 0xFF ; currententry = pH -> look_up [ subtree ] ; if ( currententry == 0 ) { pH -> look_up [ subtree ] = currententry = nextfreeentry ; pH -> look_up2 [ subtree ] = currententry = nextfreeentry ; nextfreeentry -= 2 ; } code <<= ( 16 - ( code_size - 8 ) ) ; for ( l = code_size ; l > 9 ; l -- ) { if ( ( code & 0x8000 ) == 0 ) currententry -- ; if ( pH -> tree [ - currententry - 1 ] == 0 ) { pH -> tree [ - currententry - 1 ] = nextfreeentry ; currententry = nextfreeentry ; nextfreeentry -= 2 ; } else currententry = pH -> tree [ - currententry - 1 ] ; code <<= 1 ; } if ( ( code & 0x8000 ) == 0 ) currententry -- ; pH -> tree [ - currententry - 1 ] = i ; } p ++ ; } }
GlyphCache :: GlyphCache ( const Face & face , const uint32 face_options ) : _glyph_loader ( new Loader ( face , bool ( face_options & gr_face_dumbRendering ) ) ) , _glyphs ( _glyph_loader && * _glyph_loader && _glyph_loader -> num_glyphs ( ) ? grzeroalloc < const GlyphFace * > ( _glyph_loader -> num_glyphs ( ) ) : 0 ) , _boxes ( _glyph_loader && _glyph_loader -> has_boxes ( ) && _glyph_loader -> num_glyphs ( ) ? grzeroalloc < GlyphBox * > ( _glyph_loader -> num_glyphs ( ) ) : 0 ) , _num_glyphs ( _glyphs ? _glyph_loader -> num_glyphs ( ) : 0 ) , _num_attrs ( _glyphs ? _glyph_loader -> num_attrs ( ) : 0 ) , _upem ( _glyphs ? _glyph_loader -> units_per_em ( ) : 0 ) { if ( ( face_options & gr_face_preloadGlyphs ) && _glyph_loader && _glyphs ) { int numsubs = 0 ; GlyphFace * const glyphs = new GlyphFace [ _num_glyphs ] ; if ( ! glyphs ) return ; _glyphs [ 0 ] = _glyph_loader -> read_glyph ( 0 , glyphs [ 0 ] , & numsubs ) ; const GlyphFace * loaded = _glyphs [ 0 ] ; for ( uint16 gid = 1 ; loaded && gid != _num_glyphs ; ++ gid ) _glyphs [ gid ] = loaded = _glyph_loader -> read_glyph ( gid , glyphs [ gid ] , & numsubs ) ; if ( ! loaded ) { _glyphs [ 0 ] = 0 ; delete [ ] glyphs ; } else if ( numsubs > 0 && _boxes ) { GlyphBox * boxes = ( GlyphBox * ) gralloc < char > ( _num_glyphs * sizeof ( GlyphBox ) + numsubs * 8 * sizeof ( float ) ) ; GlyphBox * currbox = boxes ; for ( uint16 gid = 0 ; currbox && gid != _num_glyphs ; ++ gid ) { _boxes [ gid ] = currbox ; currbox = _glyph_loader -> read_box ( gid , currbox , * _glyphs [ gid ] ) ; } if ( ! currbox ) { free ( boxes ) ; _boxes [ 0 ] = 0 ; } } delete _glyph_loader ; _glyph_loader = 0 ; } if ( _glyphs && glyph ( 0 ) == 0 ) { free ( _glyphs ) ; _glyphs = 0 ; if ( _boxes ) { free ( _boxes ) ; _boxes = 0 ; } _num_glyphs = _num_attrs = _upem = 0 ; } }
MaybeHandle < String > WasmModuleObject :: GetModuleNameOrNull ( Isolate * isolate , Handle < WasmModuleObject > module_object ) { const WasmModule * module = module_object -> module ( ) ; if ( ! module -> name . is_set ( ) ) return { } ; return ExtractUtf8StringFromModuleBytes ( isolate , module_object , module -> name ) ; }
int ScopeInfo :: ContextSlotIndex ( Handle < ScopeInfo > scope_info , Handle < String > name , VariableMode * mode , InitializationFlag * init_flag , MaybeAssignedFlag * maybe_assigned_flag ) { DCHECK ( name -> IsInternalizedString ( ) ) ; DCHECK_NOT_NULL ( mode ) ; DCHECK_NOT_NULL ( init_flag ) ; DCHECK_NOT_NULL ( maybe_assigned_flag ) ; if ( scope_info -> length ( ) == 0 ) return - 1 ; Isolate * isolate = Heap :: FromWritableHeapObject ( * scope_info ) -> isolate ( ) ; ContextSlotCache * context_slot_cache = isolate -> context_slot_cache ( ) ; int result = context_slot_cache -> Lookup ( * scope_info , * name , mode , init_flag , maybe_assigned_flag ) ; if ( result != ContextSlotCache :: kNotFound ) { DCHECK_LT ( result , scope_info -> ContextLength ( ) ) ; return result ; } int start = scope_info -> ContextLocalNamesIndex ( ) ; int end = start + scope_info -> ContextLocalCount ( ) ; for ( int i = start ; i < end ; ++ i ) { if ( * name == scope_info -> get ( i ) ) { int var = i - start ; * mode = scope_info -> ContextLocalMode ( var ) ; * init_flag = scope_info -> ContextLocalInitFlag ( var ) ; * maybe_assigned_flag = scope_info -> ContextLocalMaybeAssignedFlag ( var ) ; result = Context :: MIN_CONTEXT_SLOTS + var ; context_slot_cache -> Update ( scope_info , name , * mode , * init_flag , * maybe_assigned_flag , result ) ; DCHECK_LT ( result , scope_info -> ContextLength ( ) ) ; return result ; } } context_slot_cache -> Update ( scope_info , name , VariableMode :: kTemporary , kNeedsInitialization , kNotAssigned , - 1 ) ; return - 1 ; }
uint32_t nsGIFDecoder2 :: OutputRow ( ) { int drow_start , drow_end ; drow_start = drow_end = mGIFStruct . irow ; if ( ( unsigned ) drow_start >= mGIFStruct . height ) { NS_WARNING ( "GIF2.cpp::OutputRow - too much image data" ) ; return 0 ; } if ( ! mGIFStruct . images_decoded ) { if ( mGIFStruct . progressive_display && mGIFStruct . interlaced && ( mGIFStruct . ipass < 4 ) ) { const uint32_t row_dup = 15 > > mGIFStruct . ipass ; const uint32_t row_shift = row_dup > > 1 ; drow_start -= row_shift ; drow_end = drow_start + row_dup ; if ( ( ( mGIFStruct . height - 1 ) - drow_end ) <= row_shift ) drow_end = mGIFStruct . height - 1 ; if ( drow_start < 0 ) drow_start = 0 ; if ( ( unsigned ) drow_end >= mGIFStruct . height ) drow_end = mGIFStruct . height - 1 ; } const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; uint8_t * from = rowp + mGIFStruct . width ; uint32_t * to = ( ( uint32_t * ) rowp ) + mGIFStruct . width ; uint32_t * cmap = mColormap ; if ( mColorMask == 0xFF ) { for ( uint32_t c = mGIFStruct . width ; c > 0 ; c -- ) { * -- to = cmap [ * -- from ] ; } } else { uint8_t mask = mColorMask ; for ( uint32_t c = mGIFStruct . width ; c > 0 ; c -- ) { * -- to = cmap [ ( * -- from ) & mask ] ; } } if ( mGIFStruct . is_transparent && ! mSawTransparency ) { const uint32_t * rgb = ( uint32_t * ) rowp ; for ( uint32_t i = mGIFStruct . width ; i > 0 ; i -- ) { if ( * rgb ++ == 0 ) { mSawTransparency = true ; break ; } } } if ( drow_end > drow_start ) { for ( int r = drow_start ; r <= drow_end ; r ++ ) { if ( r != int ( mGIFStruct . irow ) ) { memcpy ( mImageData + ( r * bpr ) , rowp , bpr ) ; } } } } mCurrentRow = drow_end ; mCurrentPass = mGIFStruct . ipass ; if ( mGIFStruct . ipass == 1 ) mLastFlushedPass = mGIFStruct . ipass ; if ( ! mGIFStruct . interlaced ) { mGIFStruct . irow ++ ; } else { static const uint8_t kjump [ 5 ] = { 1 , 8 , 8 , 4 , 2 } ; do { mGIFStruct . irow += kjump [ mGIFStruct . ipass ] ; if ( mGIFStruct . irow >= mGIFStruct . height ) { mGIFStruct . irow = 8 > > mGIFStruct . ipass ; mGIFStruct . ipass ++ ; } } while ( mGIFStruct . irow >= mGIFStruct . height ) ; } return -- mGIFStruct . rows_remaining ; }
static void pdfobj_flag ( struct pdf_struct * pdf , struct pdf_obj * obj , enum pdf_flag flag ) { const char * s = "" ; pdf -> flags |= 1 < < flag ; if ( ! cli_debug_flag ) return ; switch ( flag ) { case UNTERMINATED_OBJ_DICT : s = "dictionary not terminated" ; break ; case ESCAPED_COMMON_PDFNAME : s = "escaped common pdfname" ; break ; case BAD_STREAM_FILTERS : s = "duplicate stream filters" ; break ; case BAD_PDF_VERSION : s = "bad pdf version" ; break ; case BAD_PDF_HEADERPOS : s = "bad pdf header position" ; break ; case BAD_PDF_TRAILER : s = "bad pdf trailer" ; break ; case BAD_PDF_TOOMANYOBJS : s = "too many pdf objs" ; break ; case BAD_FLATE : s = "bad deflate stream" ; break ; case BAD_FLATESTART : s = "bad deflate stream start" ; break ; case BAD_STREAMSTART : s = "bad stream start" ; break ; case UNKNOWN_FILTER : s = "unknown filter used" ; break ; case BAD_ASCIIDECODE : s = "bad ASCII decode" ; break ; case HEX_JAVASCRIPT : s = "hex javascript" ; break ; case BAD_INDOBJ : s = "referencing nonexistent obj" ; break ; case HAS_OPENACTION : s = "has /OpenAction" ; break ; case HAS_LAUNCHACTION : s = "has /LaunchAction" ; break ; case BAD_STREAMLEN : s = "bad /Length, too small" ; break ; case ENCRYPTED_PDF : s = "PDF is encrypted" ; break ; case LINEARIZED_PDF : s = "linearized PDF" ; break ; case MANY_FILTERS : s = "more than 2 filters per obj" ; break ; } cli_dbgmsg ( "cli_pdf: %s flagged in object %u %u\n" , s , obj -> id > > 8 , obj -> id & 0xff ) ; }
bool WasmMemoryObject :: has_full_guard_region ( Isolate * isolate ) { const wasm :: WasmMemoryTracker :: AllocationData * allocation = isolate -> wasm_engine ( ) -> memory_tracker ( ) -> FindAllocationData ( array_buffer ( ) -> backing_store ( ) ) ; CHECK_NOT_NULL ( allocation ) ; Address allocation_base = reinterpret_cast < Address > ( allocation -> allocation_base ) ; Address buffer_start = reinterpret_cast < Address > ( allocation -> buffer_start ) ; return buffer_start + wasm :: kWasmMaxHeapOffset <= allocation_base + allocation -> allocation_length ; }
af_latin_metrics_init_widths ( AF_LatinMetrics metrics , FT_Face face ) { AF_GlyphHintsRec hints [ 1 ] ; FT_TRACE5 ( ( "\n" "latin standard widths computation (style `%s')\n" "=====================================================\n" "\n" , af_style_names [ metrics -> root . style_class -> style ] ) ) ; af_glyph_hints_init ( hints , face -> memory ) ; metrics -> axis [ AF_DIMENSION_HORZ ] . width_count = 0 ; metrics -> axis [ AF_DIMENSION_VERT ] . width_count = 0 ; { FT_Error error ; FT_ULong glyph_index ; FT_Long y_offset ; int dim ; AF_LatinMetricsRec dummy [ 1 ] ; AF_Scaler scaler = & dummy -> root . scaler ; #ifdef FT_CONFIG_OPTION_PIC AF_FaceGlobals globals = metrics -> root . globals ; #endif AF_StyleClass style_class = metrics -> root . style_class ; AF_ScriptClass script_class = AF_SCRIPT_CLASSES_GET [ style_class -> script ] ; FT_UInt32 standard_char ; standard_char = script_class -> standard_char1 ; af_get_char_index ( & metrics -> root , standard_char , & glyph_index , & y_offset ) ; if ( ! glyph_index ) { if ( script_class -> standard_char2 ) { standard_char = script_class -> standard_char2 ; af_get_char_index ( & metrics -> root , standard_char , & glyph_index , & y_offset ) ; if ( ! glyph_index ) { if ( script_class -> standard_char3 ) { standard_char = script_class -> standard_char3 ; af_get_char_index ( & metrics -> root , standard_char , & glyph_index , & y_offset ) ; if ( ! glyph_index ) goto Exit ; } else goto Exit ; } } else goto Exit ; } FT_TRACE5 ( ( "standard character: U+%04lX (glyph index %d)\n" , standard_char , glyph_index ) ) ; error = FT_Load_Glyph ( face , glyph_index , FT_LOAD_NO_SCALE ) ; if ( error || face -> glyph -> outline . n_points <= 0 ) goto Exit ; FT_ZERO ( dummy ) ; dummy -> units_per_em = metrics -> units_per_em ; scaler -> x_scale = 0x10000L ; scaler -> y_scale = 0x10000L ; scaler -> x_delta = 0 ; scaler -> y_delta = 0 ; scaler -> face = face ; scaler -> render_mode = FT_RENDER_MODE_NORMAL ; scaler -> flags = 0 ; af_glyph_hints_rescale ( hints , ( AF_StyleMetrics ) dummy ) ; error = af_glyph_hints_reload ( hints , & face -> glyph -> outline ) ; if ( error ) goto Exit ; for ( dim = 0 ; dim < AF_DIMENSION_MAX ; dim ++ ) { AF_LatinAxis axis = & metrics -> axis [ dim ] ; AF_AxisHints axhints = & hints -> axis [ dim ] ; AF_Segment seg , limit , link ; FT_UInt num_widths = 0 ; error = af_latin_hints_compute_segments ( hints , ( AF_Dimension ) dim ) ; if ( error ) goto Exit ; af_latin_hints_link_segments ( hints , 0 , NULL , ( AF_Dimension ) dim ) ; seg = axhints -> segments ; limit = seg + axhints -> num_segments ; for ( ; seg < limit ; seg ++ ) { link = seg -> link ; if ( link && link -> link == seg && link > seg ) { FT_Pos dist ; dist = seg -> pos - link -> pos ; if ( dist < 0 ) dist = - dist ; if ( num_widths < AF_LATIN_MAX_WIDTHS ) axis -> widths [ num_widths ++ ] . org = dist ; } } af_sort_and_quantize_widths ( & num_widths , axis -> widths , dummy -> units_per_em / 100 ) ; axis -> width_count = num_widths ; } Exit : for ( dim = 0 ; dim < AF_DIMENSION_MAX ; dim ++ ) { AF_LatinAxis axis = & metrics -> axis [ dim ] ; FT_Pos stdw ; stdw = ( axis -> width_count > 0 ) ? axis -> widths [ 0 ] . org : AF_LATIN_CONSTANT ( metrics , 50 ) ; axis -> edge_distance_threshold = stdw / 5 ; axis -> standard_width = stdw ; axis -> extra_light = 0 ; #ifdef FT_DEBUG_LEVEL_TRACE { FT_UInt i ; FT_TRACE5 ( ( "%s widths:\n" , dim == AF_DIMENSION_VERT ? "horizontal" : "vertical" ) ) ; FT_TRACE5 ( ( "  %d (standard)" , axis -> standard_width ) ) ; for ( i = 1 ; i < axis -> width_count ; i ++ ) FT_TRACE5 ( ( " %d" , axis -> widths [ i ] . org ) ) ; FT_TRACE5 ( ( "\n" ) ) ; } #endif } } FT_TRACE5 ( ( "\n" ) ) ; af_glyph_hints_done ( hints ) ; }
void EffectControlLinearizer :: LowerTransitionAndStoreNumberElement ( Node * node ) { Node * array = node -> InputAt ( 0 ) ; Node * index = node -> InputAt ( 1 ) ; Node * value = node -> InputAt ( 2 ) ; Node * map = __ LoadField ( AccessBuilder :: ForMap ( ) , array ) ; Node * kind ; { Node * bit_field2 = __ LoadField ( AccessBuilder :: ForMapBitField2 ( ) , map ) ; Node * mask = __ Int32Constant ( Map :: ElementsKindBits :: kMask ) ; Node * andit = __ Word32And ( bit_field2 , mask ) ; Node * shift = __ Int32Constant ( Map :: ElementsKindBits :: kShift ) ; kind = __ Word32Shr ( andit , shift ) ; } auto do_store = __ MakeLabel ( ) ; auto transition_smi_array = __ MakeDeferredLabel ( ) ; { __ GotoIfNot ( IsElementsKindGreaterThan ( kind , HOLEY_SMI_ELEMENTS ) , & transition_smi_array ) ; __ GotoIf ( __ Word32Equal ( kind , __ Int32Constant ( HOLEY_DOUBLE_ELEMENTS ) ) , & do_store ) ; __ DebugBreak ( ) ; __ Goto ( & do_store ) ; } __ Bind ( & transition_smi_array ) ; { TransitionElementsTo ( node , array , HOLEY_SMI_ELEMENTS , HOLEY_DOUBLE_ELEMENTS ) ; __ Goto ( & do_store ) ; } __ Bind ( & do_store ) ; Node * elements = __ LoadField ( AccessBuilder :: ForJSObjectElements ( ) , array ) ; __ StoreElement ( AccessBuilder :: ForFixedDoubleArrayElement ( ) , elements , index , value ) ; }
MaybeHandle < WasmModuleObject > WasmEngine :: SyncCompileTranslatedAsmJs ( Isolate * isolate , ErrorThrower * thrower , const ModuleWireBytes & bytes , Handle < Script > asm_js_script , Vector < const byte > asm_js_offset_table_bytes ) { ModuleResult result = DecodeWasmModule ( kAsmjsWasmFeatures , bytes . start ( ) , bytes . end ( ) , false , kAsmJsOrigin , isolate -> counters ( ) , allocator ( ) ) ; CHECK ( ! result . failed ( ) ) ; return CompileToModuleObject ( isolate , kAsmjsWasmFeatures , thrower , std :: move ( result . val ) , bytes , asm_js_script , asm_js_offset_table_bytes ) ; }
ScriptData * CodeSerializer :: SerializeSharedFunctionInfo ( Handle < SharedFunctionInfo > info ) { DisallowHeapAllocation no_gc ; VisitRootPointer ( Root :: kHandleScope , nullptr , Handle < Object > :: cast ( info ) . location ( ) ) ; SerializeDeferredObjects ( ) ; Pad ( ) ; SerializedCodeData data ( sink_ . data ( ) , this ) ; return data . GetScriptData ( ) ; }
nsresult nsZipArchive :: BuildSynthetics ( ) { if ( mBuiltSynthetics ) return NS_OK ; mBuiltSynthetics = true ; MOZ_WIN_MEM_TRY_BEGIN for ( int i = 0 ; i < ZIP_TABSIZE ; ++ i ) { for ( nsZipItem * item = mFiles [ i ] ; item != 0 ; item = item -> next ) { if ( item -> isSynthetic ) continue ; uint16_t namelen = item -> nameLength ; const char * name = item -> Name ( ) ; for ( uint16_t dirlen = namelen - 1 ; dirlen > 0 ; dirlen -- ) { if ( name [ dirlen - 1 ] != '/' ) continue ; uint32_t hash = HashName ( item -> Name ( ) , dirlen ) ; bool found = false ; for ( nsZipItem * zi = mFiles [ hash ] ; zi != NULL ; zi = zi -> next ) { if ( ( dirlen == zi -> nameLength ) && ( 0 == memcmp ( item -> Name ( ) , zi -> Name ( ) , dirlen ) ) ) { found = true ; break ; } } if ( found ) break ; nsZipItem * diritem = CreateZipItem ( ) ; if ( ! diritem ) return NS_ERROR_OUT_OF_MEMORY ; diritem -> central = item -> central ; diritem -> nameLength = dirlen ; diritem -> isSynthetic = true ; diritem -> next = mFiles [ hash ] ; mFiles [ hash ] = diritem ; } } } MOZ_WIN_MEM_TRY_CATCH ( return NS_ERROR_FAILURE ) return NS_OK ; }
void InterpreterAssembler :: SetAccumulator ( Node * value ) { DCHECK ( Bytecodes :: WritesAccumulator ( bytecode_ ) ) ; accumulator_use_ = accumulator_use_ | AccumulatorUse :: kWrite ; accumulator_ . Bind ( value ) ; }
BOOL security_fips_decrypt ( BYTE * data , size_t length , rdpRdp * rdp ) { size_t olen ; if ( ! winpr_Cipher_Update ( rdp -> fips_decrypt , data , length , data , & olen ) ) return FALSE ; return TRUE ; }
AsmType * AsmJsParser :: ConditionalExpression ( ) { AsmType * test = nullptr ; RECURSEn ( test = BitwiseORExpression ( ) ) ; if ( Check ( '?' ) ) { if ( ! test -> IsA ( AsmType :: Int ( ) ) ) { FAILn ( "Expected int in condition of ternary operator." ) ; } current_function_builder_ -> EmitWithU8 ( kExprIf , kLocalI32 ) ; size_t fixup = current_function_builder_ -> GetPosition ( ) - 1 ; AsmType * cons = nullptr ; RECURSEn ( cons = AssignmentExpression ( ) ) ; current_function_builder_ -> Emit ( kExprElse ) ; EXPECT_TOKENn ( ':' ) ; AsmType * alt = nullptr ; RECURSEn ( alt = AssignmentExpression ( ) ) ; current_function_builder_ -> Emit ( kExprEnd ) ; if ( cons -> IsA ( AsmType :: Int ( ) ) && alt -> IsA ( AsmType :: Int ( ) ) ) { current_function_builder_ -> FixupByte ( fixup , kLocalI32 ) ; return AsmType :: Int ( ) ; } else if ( cons -> IsA ( AsmType :: Double ( ) ) && alt -> IsA ( AsmType :: Double ( ) ) ) { current_function_builder_ -> FixupByte ( fixup , kLocalF64 ) ; return AsmType :: Double ( ) ; } else if ( cons -> IsA ( AsmType :: Float ( ) ) && alt -> IsA ( AsmType :: Float ( ) ) ) { current_function_builder_ -> FixupByte ( fixup , kLocalF32 ) ; return AsmType :: Float ( ) ; } else { FAILn ( "Type mismatch in ternary operator." ) ; } } else { return test ; } }
int sock_send_all ( int sock_fd , const uint8_t * buf , int len ) { int s = len ; int ret ; while ( s ) { do ret = send ( sock_fd , buf , s , 0 ) ; while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) { BTIF_TRACE_ERROR ( "sock fd:%d send errno:%d, ret:%d" , sock_fd , errno , ret ) ; return - 1 ; } buf += ret ; s -= ret ; } return len ; }
long long Block :: GetTimeCode ( const Cluster * pCluster ) const { if ( pCluster == 0 ) return m_timecode ; const long long tc0 = pCluster -> GetTimeCode ( ) ; assert ( tc0 >= 0 ) ; const long long tc = tc0 + m_timecode ; return tc ; }
void PacketReader :: getLabelFromContent ( const vector < uint8_t > & content , uint16_t & frompos , string & ret , int recurs ) { if ( recurs > 100 ) throw MOADNSException ( "Loop" ) ; int pos = frompos ; for ( ; ; ) { unsigned char labellen = content . at ( frompos ++ ) ; if ( ! labellen ) { if ( ret . empty ( ) ) ret . append ( 1 , '.' ) ; break ; } else if ( ( labellen & 0xc0 ) == 0xc0 ) { uint16_t offset = 256 * ( labellen & ~ 0xc0 ) + ( unsigned int ) content . at ( frompos ++ ) - sizeof ( dnsheader ) ; if ( offset >= pos ) throw MOADNSException ( "forward reference during label decompression" ) ; return getLabelFromContent ( content , offset , ret , ++ recurs ) ; } else if ( labellen > 63 ) throw MOADNSException ( "Overly long label during label decompression (" + lexical_cast < string > ( ( unsigned int ) labellen ) + ")" ) ; else { for ( string :: size_type n = 0 ; n < labellen ; ++ n , frompos ++ ) { if ( content . at ( frompos ) == '.' || content . at ( frompos ) == '\\' ) { ret . append ( 1 , '\\' ) ; ret . append ( 1 , content [ frompos ] ) ; } else if ( content . at ( frompos ) == ' ' ) { ret += "\\032" ; } else ret . append ( 1 , content [ frompos ] ) ; } ret . append ( 1 , '.' ) ; } if ( ret . length ( ) > 1024 ) throw MOADNSException ( "Total name too long" ) ; } }
Reduction JSCreateLowering :: ReduceJSCreateFunctionContext ( Node * node ) { DCHECK_EQ ( IrOpcode :: kJSCreateFunctionContext , node -> opcode ( ) ) ; const CreateFunctionContextParameters & parameters = CreateFunctionContextParametersOf ( node -> op ( ) ) ; ScopeInfoRef scope_info ( js_heap_broker ( ) , parameters . scope_info ( ) ) ; int slot_count = parameters . slot_count ( ) ; ScopeType scope_type = parameters . scope_type ( ) ; if ( slot_count < kFunctionContextAllocationLimit ) { Node * effect = NodeProperties :: GetEffectInput ( node ) ; Node * control = NodeProperties :: GetControlInput ( node ) ; Node * context = NodeProperties :: GetContextInput ( node ) ; Node * extension = jsgraph ( ) -> TheHoleConstant ( ) ; AllocationBuilder a ( jsgraph ( ) , effect , control ) ; STATIC_ASSERT ( Context :: MIN_CONTEXT_SLOTS == 4 ) ; int context_length = slot_count + Context :: MIN_CONTEXT_SLOTS ; Handle < Map > map ; switch ( scope_type ) { case EVAL_SCOPE : map = factory ( ) -> eval_context_map ( ) ; break ; case FUNCTION_SCOPE : map = factory ( ) -> function_context_map ( ) ; break ; default : UNREACHABLE ( ) ; } a . AllocateContext ( context_length , map ) ; a . Store ( AccessBuilder :: ForContextSlot ( Context :: SCOPE_INFO_INDEX ) , scope_info ) ; a . Store ( AccessBuilder :: ForContextSlot ( Context :: PREVIOUS_INDEX ) , context ) ; a . Store ( AccessBuilder :: ForContextSlot ( Context :: EXTENSION_INDEX ) , extension ) ; a . Store ( AccessBuilder :: ForContextSlot ( Context :: NATIVE_CONTEXT_INDEX ) , jsgraph ( ) -> HeapConstant ( native_context ( ) ) ) ; for ( int i = Context :: MIN_CONTEXT_SLOTS ; i < context_length ; ++ i ) { a . Store ( AccessBuilder :: ForContextSlot ( i ) , jsgraph ( ) -> UndefinedConstant ( ) ) ; } RelaxControls ( node ) ; a . FinishAndChange ( node ) ; return Changed ( node ) ; } return NoChange ( ) ; }
static void bgp_packet_mpattr_tea ( struct bgp * bgp , struct peer * peer , struct stream * s , struct attr * attr , uint8_t attrtype ) { unsigned int attrlenfield = 0 ; unsigned int attrhdrlen = 0 ; struct bgp_attr_encap_subtlv * subtlvs ; struct bgp_attr_encap_subtlv * st ; const char * attrname ; if ( ! attr || ( attrtype == BGP_ATTR_ENCAP && ( ! attr -> encap_tunneltype || attr -> encap_tunneltype == BGP_ENCAP_TYPE_MPLS ) ) ) return ; switch ( attrtype ) { case BGP_ATTR_ENCAP : attrname = "Tunnel Encap" ; subtlvs = attr -> encap_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 2 + 2 ; attrhdrlen = 1 + 1 ; break ; #if ENABLE_BGP_VNC case BGP_ATTR_VNC : attrname = "VNC" ; subtlvs = attr -> vnc_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 0 ; attrhdrlen = 2 + 2 ; break ; #endif default : assert ( 0 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { attrlenfield += ( attrhdrlen + st -> length ) ; } if ( attrlenfield > 0xffff ) { zlog_info ( "%s attribute is too long (length=%d), can't send it" , attrname , attrlenfield ) ; return ; } if ( attrlenfield > 0xff ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , attrtype ) ; stream_putw ( s , attrlenfield & 0xffff ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , attrtype ) ; stream_putc ( s , attrlenfield & 0xff ) ; } if ( attrtype == BGP_ATTR_ENCAP ) { stream_putw ( s , attr -> encap_tunneltype ) ; stream_putw ( s , attrlenfield - 4 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { if ( attrtype == BGP_ATTR_ENCAP ) { stream_putc ( s , st -> type ) ; stream_putc ( s , st -> length ) ; #if ENABLE_BGP_VNC } else { stream_putw ( s , st -> type ) ; stream_putw ( s , st -> length ) ; #endif } stream_put ( s , st -> value , st -> length ) ; } }
GenerateNormal ( float * N , const PRUint8 * data , PRInt32 stride , PRInt32 surfaceWidth , PRInt32 surfaceHeight , PRInt32 x , PRInt32 y , float surfaceScale ) { static const PRInt8 Kx [ 3 ] [ 3 ] [ 3 ] [ 3 ] = { { { { 0 , 0 , 0 } , { 0 , - 2 , 2 } , { 0 , - 1 , 1 } } , { { 0 , 0 , 0 } , { - 2 , 0 , 2 } , { - 1 , 0 , 1 } } , { { 0 , 0 , 0 } , { - 2 , 2 , 0 } , { - 1 , 1 , 0 } } } , { { { 0 , - 1 , 1 } , { 0 , - 2 , 2 } , { 0 , - 1 , 1 } } , { { - 1 , 0 , 1 } , { - 2 , 0 , 2 } , { - 1 , 0 , 1 } } , { { - 1 , 1 , 0 } , { - 2 , 2 , 0 } , { - 1 , 1 , 0 } } } , { { { 0 , - 1 , 1 } , { 0 , - 2 , 2 } , { 0 , 0 , 0 } } , { { - 1 , 0 , 1 } , { - 2 , 0 , 2 } , { 0 , 0 , 0 } } , { { - 1 , 1 , 0 } , { - 2 , 2 , 0 } , { 0 , 0 , 0 } } } } ; static const PRInt8 Ky [ 3 ] [ 3 ] [ 3 ] [ 3 ] = { { { { 0 , 0 , 0 } , { 0 , - 2 , - 1 } , { 0 , 2 , 1 } } , { { 0 , 0 , 0 } , { - 1 , - 2 , - 1 } , { 1 , 2 , 1 } } , { { 0 , 0 , 0 } , { - 1 , - 2 , 1 } , { 1 , 2 , 0 } } } , { { { 0 , - 2 , - 1 } , { 0 , 0 , 0 } , { 0 , 2 , 1 } } , { { - 1 , - 2 , - 1 } , { 0 , 0 , 0 } , { 1 , 2 , 1 } } , { { - 1 , - 2 , 0 } , { 0 , 0 , 0 } , { 1 , 2 , 0 } } } , { { { 0 , - 2 , - 1 } , { 0 , 2 , 1 } , { 0 , 0 , 0 } } , { { - 1 , - 2 , - 1 } , { 1 , 2 , 1 } , { 0 , 0 , 0 } } , { { - 1 , - 2 , 0 } , { 1 , 2 , 0 } , { 0 , 0 , 0 } } } } ; static const float FACTORx [ 3 ] [ 3 ] = { { 2.0 / 3.0 , 1.0 / 3.0 , 2.0 / 3.0 } , { 1.0 / 2.0 , 1.0 / 4.0 , 1.0 / 2.0 } , { 2.0 / 3.0 , 1.0 / 3.0 , 2.0 / 3.0 } } ; static const float FACTORy [ 3 ] [ 3 ] = { { 2.0 / 3.0 , 1.0 / 2.0 , 2.0 / 3.0 } , { 1.0 / 3.0 , 1.0 / 4.0 , 1.0 / 3.0 } , { 2.0 / 3.0 , 1.0 / 2.0 , 2.0 / 3.0 } } ; PRInt8 xflag , yflag ; if ( x == 0 ) { xflag = 0 ; } else if ( x == surfaceWidth - 1 ) { xflag = 2 ; } else { xflag = 1 ; } if ( y == 0 ) { yflag = 0 ; } else if ( y == surfaceHeight - 1 ) { yflag = 2 ; } else { yflag = 1 ; } const PRUint8 * index = data + y * stride + 4 * x + GFX_ARGB32_OFFSET_A ; N [ 0 ] = - surfaceScale * FACTORx [ yflag ] [ xflag ] * Convolve3x3 ( index , stride , Kx [ yflag ] [ xflag ] ) ; N [ 1 ] = - surfaceScale * FACTORy [ yflag ] [ xflag ] * Convolve3x3 ( index , stride , Ky [ yflag ] [ xflag ] ) ; N [ 2 ] = 255 ; NORMALIZE ( N ) ; }
status_t MPEG4Source :: parseChunk ( off64_t * offset ) { uint32_t hdr [ 2 ] ; if ( mDataSource -> readAt ( * offset , hdr , 8 ) < 8 ) { return ERROR_IO ; } uint64_t chunk_size = ntohl ( hdr [ 0 ] ) ; uint32_t chunk_type = ntohl ( hdr [ 1 ] ) ; off64_t data_offset = * offset + 8 ; if ( chunk_size == 1 ) { if ( mDataSource -> readAt ( * offset + 8 , & chunk_size , 8 ) < 8 ) { return ERROR_IO ; } chunk_size = ntoh64 ( chunk_size ) ; data_offset += 8 ; if ( chunk_size < 16 ) { return ERROR_MALFORMED ; } } else if ( chunk_size < 8 ) { return ERROR_MALFORMED ; } char chunk [ 5 ] ; MakeFourCCString ( chunk_type , chunk ) ; ALOGV ( "MPEG4Source chunk %s @ %llx" , chunk , * offset ) ; off64_t chunk_data_size = * offset + chunk_size - data_offset ; switch ( chunk_type ) { case FOURCC ( 't' , 'r' , 'a' , 'f' ) : case FOURCC ( 'm' , 'o' , 'o' , 'f' ) : { off64_t stop_offset = * offset + chunk_size ; * offset = data_offset ; while ( * offset < stop_offset ) { status_t err = parseChunk ( offset ) ; if ( err != OK ) { return err ; } } if ( chunk_type == FOURCC ( 'm' , 'o' , 'o' , 'f' ) ) { parseChunk ( offset ) ; mNextMoofOffset = * offset ; } break ; } case FOURCC ( 't' , 'f' , 'h' , 'd' ) : { status_t err ; if ( ( err = parseTrackFragmentHeader ( data_offset , chunk_data_size ) ) != OK ) { return err ; } * offset += chunk_size ; break ; } case FOURCC ( 't' , 'f' , 'd' , 't' ) : { status_t err ; if ( mLastParsedTrackId == mTrackId ) { if ( ( err = parseTrackFragmentData ( data_offset , chunk_data_size ) ) != OK ) { return err ; } } * offset += chunk_size ; break ; } case FOURCC ( 't' , 'r' , 'u' , 'n' ) : { status_t err ; if ( mLastParsedTrackId == mTrackId ) { if ( ( err = parseTrackFragmentRun ( data_offset , chunk_data_size ) ) != OK ) { return err ; } } * offset += chunk_size ; break ; } case FOURCC ( 's' , 'a' , 'i' , 'z' ) : { status_t err ; if ( mLastParsedTrackId == mTrackId ) { if ( ( err = parseSampleAuxiliaryInformationSizes ( data_offset , chunk_data_size ) ) != OK ) { return err ; } } * offset += chunk_size ; break ; } case FOURCC ( 's' , 'a' , 'i' , 'o' ) : { status_t err ; if ( mLastParsedTrackId == mTrackId ) { if ( ( err = parseSampleAuxiliaryInformationOffsets ( data_offset , chunk_data_size ) ) != OK ) { return err ; } } * offset += chunk_size ; break ; } case FOURCC ( 'm' , 'd' , 'a' , 't' ) : { ALOGV ( "MPEG4Source::parseChunk mdat" ) ; * offset += chunk_size ; break ; } default : { * offset += chunk_size ; break ; } } return OK ; }
DefragDoSturgesNovakTest ( int policy , u_char * expected , size_t expected_len ) { int i ; int ret = 0 ; DefragInit ( ) ; int id = 1 ; Packet * packets [ 17 ] ; memset ( packets , 0x00 , sizeof ( packets ) ) ; packets [ 0 ] = BuildTestPacket ( id , 0 , 1 , 'A' , 24 ) ; packets [ 1 ] = BuildTestPacket ( id , 32 > > 3 , 1 , 'B' , 16 ) ; packets [ 2 ] = BuildTestPacket ( id , 48 > > 3 , 1 , 'C' , 24 ) ; packets [ 3 ] = BuildTestPacket ( id , 80 > > 3 , 1 , 'D' , 8 ) ; packets [ 4 ] = BuildTestPacket ( id , 104 > > 3 , 1 , 'E' , 16 ) ; packets [ 5 ] = BuildTestPacket ( id , 120 > > 3 , 1 , 'F' , 24 ) ; packets [ 6 ] = BuildTestPacket ( id , 144 > > 3 , 1 , 'G' , 16 ) ; packets [ 7 ] = BuildTestPacket ( id , 160 > > 3 , 1 , 'H' , 16 ) ; packets [ 8 ] = BuildTestPacket ( id , 176 > > 3 , 1 , 'I' , 8 ) ; packets [ 9 ] = BuildTestPacket ( id , 8 > > 3 , 1 , 'J' , 32 ) ; packets [ 10 ] = BuildTestPacket ( id , 48 > > 3 , 1 , 'K' , 24 ) ; packets [ 11 ] = BuildTestPacket ( id , 72 > > 3 , 1 , 'L' , 24 ) ; packets [ 12 ] = BuildTestPacket ( id , 96 > > 3 , 1 , 'M' , 24 ) ; packets [ 13 ] = BuildTestPacket ( id , 128 > > 3 , 1 , 'N' , 8 ) ; packets [ 14 ] = BuildTestPacket ( id , 152 > > 3 , 1 , 'O' , 8 ) ; packets [ 15 ] = BuildTestPacket ( id , 160 > > 3 , 1 , 'P' , 8 ) ; packets [ 16 ] = BuildTestPacket ( id , 176 > > 3 , 0 , 'Q' , 16 ) ; default_policy = policy ; for ( i = 0 ; i < 9 ; i ++ ) { Packet * tp = Defrag ( NULL , NULL , packets [ i ] , NULL ) ; if ( tp != NULL ) { SCFree ( tp ) ; goto end ; } if ( ENGINE_ISSET_EVENT ( packets [ i ] , IPV4_FRAG_OVERLAP ) ) { goto end ; } } int overlap = 0 ; for ( ; i < 16 ; i ++ ) { Packet * tp = Defrag ( NULL , NULL , packets [ i ] , NULL ) ; if ( tp != NULL ) { SCFree ( tp ) ; goto end ; } if ( ENGINE_ISSET_EVENT ( packets [ i ] , IPV4_FRAG_OVERLAP ) ) { overlap ++ ; } } if ( ! overlap ) { goto end ; } Packet * reassembled = Defrag ( NULL , NULL , packets [ 16 ] , NULL ) ; if ( reassembled == NULL ) { goto end ; } if ( IPV4_GET_HLEN ( reassembled ) != 20 ) { goto end ; } if ( IPV4_GET_IPLEN ( reassembled ) != 20 + 192 ) { goto end ; } if ( memcmp ( GET_PKT_DATA ( reassembled ) + 20 , expected , expected_len ) != 0 ) { goto end ; } SCFree ( reassembled ) ; if ( defrag_context -> frag_pool -> outstanding != 0 ) { goto end ; } ret = 1 ; end : for ( i = 0 ; i < 17 ; i ++ ) { SCFree ( packets [ i ] ) ; } DefragDestroy ( ) ; return ret ; }
nsMultiplexInputStream :: ReadSegments ( nsWriteSegmentFun aWriter , void * aClosure , uint32_t aCount , uint32_t * aResult ) { if ( mStatus == NS_BASE_STREAM_CLOSED ) { * aResult = 0 ; return NS_OK ; } if ( NS_FAILED ( mStatus ) ) { return mStatus ; } NS_ASSERTION ( aWriter , "missing aWriter" ) ; nsresult rv = NS_OK ; ReadSegmentsState state ; state . mThisStream = this ; state . mOffset = 0 ; state . mWriter = aWriter ; state . mClosure = aClosure ; state . mDone = false ; uint32_t len = mStreams . Length ( ) ; while ( mCurrentStream < len && aCount ) { uint32_t read ; rv = mStreams [ mCurrentStream ] -> ReadSegments ( ReadSegCb , & state , aCount , & read ) ; if ( rv == NS_BASE_STREAM_CLOSED ) { NS_NOTREACHED ( "Input stream's Read method returned NS_BASE_STREAM_CLOSED" ) ; rv = NS_OK ; read = 0 ; } if ( state . mDone || NS_FAILED ( rv ) ) { break ; } if ( read == 0 ) { ++ mCurrentStream ; mStartedReadingCurrent = false ; } else { NS_ASSERTION ( aCount >= read , "Read more than requested" ) ; state . mOffset += read ; aCount -= read ; mStartedReadingCurrent = true ; } } * aResult = state . mOffset ; return state . mOffset ? NS_OK : rv ; }
static int p4_pmu_handle_irq ( struct pt_regs * regs ) { struct perf_sample_data data ; struct cpu_hw_events * cpuc ; struct perf_event * event ; struct hw_perf_event * hwc ; int idx , handled = 0 ; u64 val ; perf_sample_data_init ( & data , 0 ) ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; for ( idx = 0 ; idx < x86_pmu . num_counters ; idx ++ ) { int overflow ; if ( ! test_bit ( idx , cpuc -> active_mask ) ) { if ( __test_and_clear_bit ( idx , cpuc -> running ) ) handled ++ ; continue ; } event = cpuc -> events [ idx ] ; hwc = & event -> hw ; WARN_ON_ONCE ( hwc -> idx != idx ) ; overflow = p4_pmu_clear_cccr_ovf ( hwc ) ; val = x86_perf_event_update ( event ) ; if ( ! overflow && ( val & ( 1ULL < < ( x86_pmu . cntval_bits - 1 ) ) ) ) continue ; handled += overflow ; data . period = event -> hw . last_period ; if ( ! x86_perf_event_set_period ( event ) ) continue ; if ( perf_event_overflow ( event , 1 , & data , regs ) ) x86_pmu_stop ( event , 0 ) ; } if ( handled ) inc_irq_stat ( apic_perf_irqs ) ; apic_write ( APIC_LVTPC , APIC_DM_NMI ) ; return handled ; }
png_write_destroy ( png_structrp png_ptr ) { png_debug ( 1 , "in png_write_destroy" ) ; if ( png_ptr -> flags & PNG_FLAG_ZSTREAM_INITIALIZED ) deflateEnd ( & png_ptr -> zstream ) ; png_free_buffer_list ( png_ptr , & png_ptr -> zbuffer_list ) ; png_free ( png_ptr , png_ptr -> row_buf ) ; #ifdef PNG_WRITE_FILTER_SUPPORTED png_free ( png_ptr , png_ptr -> prev_row ) ; png_free ( png_ptr , png_ptr -> sub_row ) ; png_free ( png_ptr , png_ptr -> up_row ) ; png_free ( png_ptr , png_ptr -> avg_row ) ; png_free ( png_ptr , png_ptr -> paeth_row ) ; #endif #ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED png_reset_filter_heuristics ( png_ptr ) ; png_free ( png_ptr , png_ptr -> filter_costs ) ; png_free ( png_ptr , png_ptr -> inv_filter_costs ) ; #endif #ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED png_free ( png_ptr , png_ptr -> chunk_list ) ; #endif }
static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { unsigned x , y ; AVFilterContext * ctx = inlink -> dst ; VignetteContext * s = ctx -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; if ( s -> eval_mode == EVAL_MODE_FRAME ) update_context ( s , inlink , in ) ; if ( s -> desc -> flags & AV_PIX_FMT_FLAG_RGB ) { uint8_t * dst = out -> data [ 0 ] ; const uint8_t * src = in -> data [ 0 ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ 0 ] ; const int src_linesize = in -> linesize [ 0 ] ; const int fmap_linesize = s -> fmap_linesize ; for ( y = 0 ; y < inlink -> h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < inlink -> w ; x ++ , dstp += 3 , srcp += 3 ) { const float f = fmap [ x ] ; dstp [ 0 ] = av_clip_uint8 ( srcp [ 0 ] * f + get_dither_value ( s ) ) ; dstp [ 1 ] = av_clip_uint8 ( srcp [ 1 ] * f + get_dither_value ( s ) ) ; dstp [ 2 ] = av_clip_uint8 ( srcp [ 2 ] * f + get_dither_value ( s ) ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize ; } } else { int plane ; for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { uint8_t * dst = out -> data [ plane ] ; const uint8_t * src = in -> data [ plane ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ plane ] ; const int src_linesize = in -> linesize [ plane ] ; const int fmap_linesize = s -> fmap_linesize ; const int chroma = plane == 1 || plane == 2 ; const int hsub = chroma ? s -> desc -> log2_chroma_w : 0 ; const int vsub = chroma ? s -> desc -> log2_chroma_h : 0 ; const int w = FF_CEIL_RSHIFT ( inlink -> w , hsub ) ; const int h = FF_CEIL_RSHIFT ( inlink -> h , vsub ) ; for ( y = 0 ; y < h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < w ; x ++ ) { const double dv = get_dither_value ( s ) ; if ( chroma ) * dstp ++ = av_clip_uint8 ( fmap [ x < < hsub ] * ( * srcp ++ - 127 ) + 127 + dv ) ; else * dstp ++ = av_clip_uint8 ( fmap [ x ] * * srcp ++ + dv ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize < < vsub ; } } } return ff_filter_frame ( outlink , out ) ; }
XMLHttpRequest :: SendInternal ( const nsAString & aStringBody , JSAutoStructuredCloneBuffer && aBody , nsTArray < nsCOMPtr < nsISupports > > & aClonedObjects , ErrorResult & aRv ) { mWorkerPrivate -> AssertIsOnWorkerThread ( ) ; bool hasUploadListeners = mUpload ? mUpload -> HasListeners ( ) : false ; MaybePin ( aRv ) ; if ( aRv . Failed ( ) ) { return ; } AutoUnpinXHR autoUnpin ( this ) ; Maybe < AutoSyncLoopHolder > autoSyncLoop ; nsCOMPtr < nsIEventTarget > syncLoopTarget ; bool isSyncXHR = mProxy -> mIsSyncXHR ; if ( isSyncXHR ) { autoSyncLoop . emplace ( mWorkerPrivate ) ; syncLoopTarget = autoSyncLoop -> EventTarget ( ) ; } mProxy -> mOuterChannelId ++ ; JSContext * cx = mWorkerPrivate -> GetJSContext ( ) ; nsRefPtr < SendRunnable > runnable = new SendRunnable ( mWorkerPrivate , mProxy , aStringBody , Move ( aBody ) , aClonedObjects , syncLoopTarget , hasUploadListeners ) ; if ( ! runnable -> Dispatch ( cx ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; return ; } if ( ! isSyncXHR ) { autoUnpin . Clear ( ) ; MOZ_ASSERT ( ! autoSyncLoop ) ; return ; } autoUnpin . Clear ( ) ; if ( ! autoSyncLoop -> Run ( ) ) { aRv . Throw ( NS_ERROR_FAILURE ) ; } }
FLAC__double FLAC__lpc_compute_expected_bits_per_residual_sample ( FLAC__double lpc_error , unsigned total_samples ) { FLAC__double error_scale ; FLAC__ASSERT ( total_samples > 0 ) ; error_scale = 0.5 * M_LN2 * M_LN2 / ( FLAC__double ) total_samples ; return FLAC__lpc_compute_expected_bits_per_residual_sample_with_error_scale ( lpc_error , error_scale ) ; }
SYSCALL_DEFINE6 ( move_pages , pid_t , pid , unsigned long , nr_pages , const void __user * __user * , pages , const int __user * , nodes , int __user * , status , int , flags ) { const struct cred * cred = current_cred ( ) , * tcred ; struct task_struct * task ; struct mm_struct * mm ; int err ; nodemask_t task_nodes ; if ( flags & ~ ( MPOL_MF_MOVE | MPOL_MF_MOVE_ALL ) ) return - EINVAL ; if ( ( flags & MPOL_MF_MOVE_ALL ) && ! capable ( CAP_SYS_NICE ) ) return - EPERM ; rcu_read_lock ( ) ; task = pid ? find_task_by_vpid ( pid ) : current ; if ( ! task ) { rcu_read_unlock ( ) ; return - ESRCH ; } get_task_struct ( task ) ; tcred = __task_cred ( task ) ; if ( ! uid_eq ( cred -> euid , tcred -> suid ) && ! uid_eq ( cred -> euid , tcred -> uid ) && ! uid_eq ( cred -> uid , tcred -> suid ) && ! uid_eq ( cred -> uid , tcred -> uid ) && ! capable ( CAP_SYS_NICE ) ) { rcu_read_unlock ( ) ; err = - EPERM ; goto out ; } rcu_read_unlock ( ) ; err = security_task_movememory ( task ) ; if ( err ) goto out ; task_nodes = cpuset_mems_allowed ( task ) ; mm = get_task_mm ( task ) ; put_task_struct ( task ) ; if ( ! mm ) return - EINVAL ; if ( nodes ) err = do_pages_move ( mm , task_nodes , nr_pages , pages , nodes , status , flags ) ; else err = do_pages_stat ( mm , nr_pages , pages , status ) ; mmput ( mm ) ; return err ; out : put_task_struct ( task ) ; return err ; }
void Compute ( OpKernelContext * context ) override { const Tensor & data = context -> input ( 0 ) ; const Tensor & weights = context -> input ( 1 ) ; bool use_weights = weights . NumElements ( ) > 0 ; OP_REQUIRES ( context , TensorShapeUtils :: IsVector ( data . shape ( ) ) || TensorShapeUtils :: IsMatrix ( data . shape ( ) ) , errors :: InvalidArgument ( "Input must be a 1 or 2-dimensional tensor. Got: " , data . shape ( ) . DebugString ( ) ) ) ; if ( use_weights ) { OP_REQUIRES ( context , weights . shape ( ) == data . shape ( ) , errors :: InvalidArgument ( "Weights and data must have the same shape. Weight shape: " , weights . shape ( ) . DebugString ( ) , "; data shape: " , data . shape ( ) . DebugString ( ) ) ) ; } bool is_1d = TensorShapeUtils :: IsVector ( data . shape ( ) ) ; int negative_valued_axis = - 1 ; int num_batch_dimensions = ( data . shape ( ) . dims ( ) + negative_valued_axis ) ; int num_batch_elements = 1 ; for ( int i = 0 ; i < num_batch_dimensions ; ++ i ) { num_batch_elements *= data . shape ( ) . dim_size ( i ) ; } int num_value_elements = data . shape ( ) . num_elements ( ) / num_batch_elements ; auto per_batch_counts = BatchedMap < W > ( num_batch_elements ) ; T max_value = 0 ; const auto data_values = data . flat < T > ( ) ; const auto weight_values = weights . flat < W > ( ) ; int i = 0 ; for ( int b = 0 ; b < num_batch_elements ; ++ b ) { for ( int v = 0 ; v < num_value_elements ; ++ v ) { const auto & value = data_values ( i ) ; if ( value >= 0 && ( maxlength_ <= 0 || value < maxlength_ ) ) { if ( binary_output_ ) { per_batch_counts [ b ] [ value ] = 1 ; } else if ( use_weights ) { per_batch_counts [ b ] [ value ] += weight_values ( i ) ; } else { per_batch_counts [ b ] [ value ] ++ ; } if ( value > max_value ) { max_value = value ; } } ++ i ; } } int num_output_values = GetOutputSize ( max_value , maxlength_ , minlength_ ) ; OP_REQUIRES_OK ( context , OutputSparse < W > ( per_batch_counts , num_output_values , is_1d , context ) ) ; }
void Sensor :: flattenString8 ( void * & buffer , size_t & size , const String8 & string8 ) { uint32_t len = static_cast < uint32_t > ( string8 . length ( ) ) ; FlattenableUtils :: write ( buffer , size , len ) ; memcpy ( static_cast < char * > ( buffer ) , string8 . string ( ) , len ) ; FlattenableUtils :: advance ( buffer , size , FlattenableUtils :: align < 4 > ( len ) ) ; }
static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ; if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }
colors . param , colors . end , a -> fin_hard_timeout ) ; } ds_chomp ( fp -> s , ',' ) ; ds_put_format ( fp -> s , "%s)%s" , colors . paren , colors . end ) ; } static enum ofperr check_FIN_TIMEOUT ( const struct ofpact_fin_timeout * a OVS_UNUSED , struct ofpact_check_params * cp ) { if ( cp -> match -> flow . nw_proto != IPPROTO_TCP ) { inconsistent_match ( & cp -> usable_protocols ) ; } return 0 ; } struct nx_action_encap { ovs_be16 type ; ovs_be16 len ; ovs_be32 vendor ; ovs_be16 subtype ; ovs_be16 hdr_size ; ovs_be32 new_pkt_type ; struct ofp_ed_prop_header props [ ] ; } ; OFP_ASSERT ( sizeof ( struct nx_action_encap ) == 16 ) ; static enum ofperr decode_NXAST_RAW_ENCAP ( const struct nx_action_encap * nae , enum ofp_version ofp_version OVS_UNUSED , struct ofpbuf * out ) { struct ofpact_encap * encap ; const struct ofp_ed_prop_header * ofp_prop ; size_t props_len ; uint16_t n_props = 0 ;
mozJSComponentLoader :: NoteSubScript ( HandleScript aScript , HandleObject aThisObject ) { if ( ! mInitialized && NS_FAILED ( ReallyInit ( ) ) ) { MOZ_CRASH ( ) ; } mThisObjects . Put ( aScript , aThisObject ) ; }
static ssize_t _epoll_write ( oe_fd_t * epoll_ , const void * buf , size_t count ) { ssize_t ret = - 1 ; epoll_t * epoll = _cast_epoll ( epoll_ ) ; oe_errno = 0 ; if ( oe_syscall_write_ocall ( & ret , epoll -> host_fd , buf , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; done : return ret ; }
bool BytecodeAnalysis :: ResumeJumpTargetsAreValid ( ) { bool valid = true ; interpreter :: BytecodeArrayRandomIterator iterator ( bytecode_array ( ) , zone ( ) ) ; for ( iterator . GoToStart ( ) ; iterator . IsValid ( ) ; ++ iterator ) { if ( iterator . current_bytecode ( ) == Bytecode :: kSwitchOnGeneratorState ) { break ; } } if ( ! iterator . IsValid ( ) || HasOsrEntryPoint ( ) ) { if ( ! resume_jump_targets ( ) . empty ( ) ) { PrintF ( stderr , "Found %zu top-level resume targets but no resume switch\n" , resume_jump_targets ( ) . size ( ) ) ; valid = false ; } for ( const std :: pair < int , LoopInfo > & loop_info : header_to_info_ ) { if ( ! loop_info . second . resume_jump_targets ( ) . empty ( ) ) { PrintF ( stderr , "Found %zu resume targets at loop at offset %d, but no resume " "switch\n" , loop_info . second . resume_jump_targets ( ) . size ( ) , loop_info . first ) ; valid = false ; } } return valid ; } std :: map < int , int > unresolved_suspend_ids ; for ( const interpreter :: JumpTableTargetOffset & offset : iterator . GetJumpTableTargetOffsets ( ) ) { int suspend_id = offset . case_value ; int resume_offset = offset . target_offset ; unresolved_suspend_ids [ suspend_id ] = resume_offset ; } if ( ! ResumeJumpTargetLeavesResolveSuspendIds ( - 1 , resume_jump_targets ( ) , & unresolved_suspend_ids ) ) { valid = false ; } for ( const std :: pair < int , LoopInfo > & loop_info : header_to_info_ ) { if ( ! ResumeJumpTargetLeavesResolveSuspendIds ( loop_info . first , loop_info . second . resume_jump_targets ( ) , & unresolved_suspend_ids ) ) { valid = false ; } } if ( ! unresolved_suspend_ids . empty ( ) ) { PrintF ( stderr , "Found suspend ids that are not resolved by a final leaf resume " "jump:\n" ) ; for ( const std :: pair < int , int > & target : unresolved_suspend_ids ) { PrintF ( stderr , "  %d -> %d\n" , target . first , target . second ) ; } valid = false ; } return valid ; }
static int handle_input_expect_headers ( struct st_h2o_http3_server_stream_t * stream , const uint8_t * * src , const uint8_t * src_end , const char * * err_desc ) { struct st_h2o_http3_server_conn_t * conn = get_conn ( stream ) ; h2o_http3_read_frame_t frame ; int header_exists_map = 0 , ret ; uint8_t header_ack [ H2O_HPACK_ENCODE_INT_MAX_LENGTH ] ; size_t header_ack_len ; if ( ( ret = h2o_http3_read_frame ( & frame , 0 , H2O_HTTP3_STREAM_TYPE_REQUEST , src , src_end , err_desc ) ) != 0 ) return ret ; if ( frame . type != H2O_HTTP3_FRAME_TYPE_HEADERS ) { switch ( frame . type ) { case H2O_HTTP3_FRAME_TYPE_DATA : return H2O_HTTP3_ERROR_FRAME_UNEXPECTED ; default : break ; } return 0 ; } stream -> recvbuf . handle_input = handle_input_expect_data ; if ( ( ret = h2o_qpack_parse_request ( & stream -> req . pool , get_conn ( stream ) -> h3 . qpack . dec , stream -> quic -> stream_id , & stream -> req . input . method , & stream -> req . input . scheme , & stream -> req . input . authority , & stream -> req . input . path , & stream -> req . headers , & header_exists_map , & stream -> req . content_length , NULL , header_ack , & header_ack_len , frame . payload , frame . length , err_desc ) ) != 0 && ret != H2O_HTTP2_ERROR_INVALID_HEADER_CHAR ) return ret ; if ( header_ack_len != 0 ) h2o_http3_send_qpack_header_ack ( & conn -> h3 , header_ack , header_ack_len ) ; if ( stream -> req . input . scheme == NULL ) stream -> req . input . scheme = & H2O_URL_SCHEME_HTTPS ; h2o_probe_log_request ( & stream -> req , stream -> quic -> stream_id ) ; int is_connect = h2o_memis ( stream -> req . input . method . base , stream -> req . input . method . len , H2O_STRLIT ( "CONNECT" ) ) ; int expected_map = H2O_HPACK_PARSE_HEADERS_METHOD_EXISTS | H2O_HPACK_PARSE_HEADERS_AUTHORITY_EXISTS ; if ( ! is_connect ) expected_map |= H2O_HPACK_PARSE_HEADERS_SCHEME_EXISTS | H2O_HPACK_PARSE_HEADERS_PATH_EXISTS ; if ( header_exists_map != expected_map ) { shutdown_stream ( stream , H2O_HTTP3_ERROR_GENERAL_PROTOCOL , H2O_HTTP3_ERROR_GENERAL_PROTOCOL , 0 ) ; return 0 ; } if ( ret == H2O_HTTP2_ERROR_INVALID_HEADER_CHAR ) return handle_input_expect_headers_send_http_error ( stream , h2o_send_error_400 , "Invalid Request" , * err_desc , err_desc ) ; if ( stream -> req . content_length != SIZE_MAX && stream -> req . content_length > conn -> super . ctx -> globalconf -> max_request_entity_size ) return handle_input_expect_headers_send_http_error ( stream , h2o_send_error_413 , "Request Entity Too Large" , "request entity is too large" , err_desc ) ; assert ( ! h2o_linklist_is_linked ( & stream -> scheduler . link ) ) ; if ( ! stream -> received_priority_update ) { ssize_t index ; if ( ( index = h2o_find_header ( & stream -> req . headers , H2O_TOKEN_PRIORITY , - 1 ) ) != - 1 ) { h2o_iovec_t * value = & stream -> req . headers . entries [ index ] . value ; h2o_absprio_parse_priority ( value -> base , value -> len , & stream -> scheduler . priority ) ; } } if ( is_connect ) { if ( stream -> req . content_length != SIZE_MAX ) return handle_input_expect_headers_send_http_error ( stream , h2o_send_error_400 , "Invalid Request" , "CONNECT request cannot have request body" , err_desc ) ; set_state ( stream , H2O_HTTP3_SERVER_STREAM_STATE_SEND_HEADERS , 0 ) ; stream -> tunnel = h2o_mem_alloc ( sizeof ( * stream -> tunnel ) ) ; stream -> tunnel -> tunnel = NULL ; stream -> tunnel -> stream = stream ; stream -> tunnel -> up . is_inflight = 0 ; stream -> tunnel -> up . delayed_write = ( h2o_timer_t ) { . cb = tunnel_write_delayed } ; h2o_process_request ( & stream -> req ) ; return 0 ; } set_state ( stream , H2O_HTTP3_SERVER_STREAM_STATE_RECV_BODY_BEFORE_BLOCK , 0 ) ; return 0 ; }
nsCSSFrameConstructor :: GetAnonymousContent ( nsIContent * aParent , nsIFrame * aParentFrame , nsTArray < nsIAnonymousContentCreator :: ContentInfo > & aContent ) { nsIAnonymousContentCreator * creator = do_QueryFrame ( aParentFrame ) ; if ( ! creator ) return NS_OK ; nsresult rv = creator -> CreateAnonymousContent ( aContent ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; uint32_t count = aContent . Length ( ) ; for ( uint32_t i = 0 ; i < count ; i ++ ) { nsIContent * content = aContent [ i ] . mContent ; NS_ASSERTION ( content , "null anonymous content?" ) ; if ( aParent && aParent -> NodeInfo ( ) -> Equals ( nsGkAtoms :: use , kNameSpaceID_SVG ) ) { content -> SetFlags ( NODE_IS_ANONYMOUS ) ; } else { content -> SetNativeAnonymous ( ) ; } bool anonContentIsEditable = content -> HasFlag ( NODE_IS_EDITABLE ) ; rv = content -> BindToTree ( mDocument , aParent , aParent , true ) ; if ( anonContentIsEditable ) { NS_ASSERTION ( aParentFrame -> GetType ( ) == nsGkAtoms :: textInputFrame , "We only expect this for anonymous content under a text control frame" ) ; SetFlagsOnSubtree ( content , NODE_IS_EDITABLE ) ; } if ( NS_FAILED ( rv ) ) { content -> UnbindFromTree ( ) ; return rv ; } } return NS_OK ; }
BUILTIN ( ObjectPrototypePropertyIsEnumerable ) { HandleScope scope ( isolate ) ; Handle < JSReceiver > object ; Handle < Name > name ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , name , Object :: ToName ( isolate , args . atOrUndefined ( isolate , 1 ) ) ) ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , object , JSReceiver :: ToObject ( isolate , args . receiver ( ) ) ) ; Maybe < PropertyAttributes > maybe = JSReceiver :: GetOwnPropertyAttributes ( object , name ) ; if ( maybe . IsNothing ( ) ) return ReadOnlyRoots ( isolate ) . exception ( ) ; if ( maybe . FromJust ( ) == ABSENT ) return ReadOnlyRoots ( isolate ) . false_value ( ) ; return isolate -> heap ( ) -> ToBoolean ( ( maybe . FromJust ( ) & DONT_ENUM ) == 0 ) ; }
write_stacktrace ( const char * file_name , const char * str ) { int fd ; void * buffer [ 100 ] ; int nptrs ; int i ; char * * strs ; nptrs = backtrace ( buffer , 100 ) ; if ( file_name ) { fd = open ( file_name , O_WRONLY | O_APPEND | O_CREAT , 0644 ) ; if ( str ) dprintf ( fd , "%s\n" , str ) ; backtrace_symbols_fd ( buffer , nptrs , fd ) ; if ( write ( fd , "\n" , 1 ) != 1 ) { } close ( fd ) ; } else { if ( str ) log_message ( LOG_INFO , "%s" , str ) ; strs = backtrace_symbols ( buffer , nptrs ) ; if ( strs == NULL ) { log_message ( LOG_INFO , "Unable to get stack backtrace" ) ; return ; } for ( i = 1 ; i < nptrs - 2 ; i ++ ) log_message ( LOG_INFO , "  %s" , strs [ i ] ) ; free ( strs ) ; } }
Response V8ProfilerAgentImpl :: startTypeProfile ( ) { m_state -> setBoolean ( ProfilerAgentState :: typeProfileStarted , true ) ; v8 :: debug :: TypeProfile :: SelectMode ( m_isolate , v8 :: debug :: TypeProfile :: kCollect ) ; return Response :: OK ( ) ; }
archive_write_disk_set_acls ( struct archive * a , int fd , const char * name , struct archive_acl * abstract_acl , __LA_MODE_T mode ) { int ret = ARCHIVE_OK ; ( void ) mode ; if ( ( archive_acl_types ( abstract_acl ) & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E ) != 0 ) { if ( ( archive_acl_types ( abstract_acl ) & ARCHIVE_ENTRY_ACL_TYPE_ACCESS ) != 0 ) { ret = set_acl ( a , fd , name , abstract_acl , ARCHIVE_ENTRY_ACL_TYPE_ACCESS , "access" ) ; if ( ret != ARCHIVE_OK ) return ( ret ) ; } if ( ( archive_acl_types ( abstract_acl ) & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT ) != 0 ) ret = set_acl ( a , fd , name , abstract_acl , ARCHIVE_ENTRY_ACL_TYPE_DEFAULT , "default" ) ; return ( ret ) ; } #if ARCHIVE_ACL_FREEBSD_NFS4 else if ( ( archive_acl_types ( abstract_acl ) & ARCHIVE_ENTRY_ACL_TYPE_NFS4 ) != 0 ) { ret = set_acl ( a , fd , name , abstract_acl , ARCHIVE_ENTRY_ACL_TYPE_NFS4 , "nfs4" ) ; } #endif return ( ret ) ; }
create_principal_2_svc ( cprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; gss_buffer_desc client_name , service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; restriction_t * rp ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> rec . principal , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_ADD , arg -> rec . principal , & rp ) || kadm5int_acl_impose_restrictions ( handle -> context , & arg -> rec , & arg -> mask , rp ) ) { ret . code = KADM5_AUTH_ADD ; log_unauth ( "kadm5_create_principal" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_create_principal ( ( void * ) handle , & arg -> rec , arg -> mask , arg -> passwd ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( "kadm5_create_principal" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
TfLiteStatus Prepare ( TfLiteContext * context , TfLiteNode * node ) { TFLITE_DCHECK ( node -> user_data != nullptr ) ; OpData * data = static_cast < OpData * > ( node -> user_data ) ; const TfLiteTensor * input1 = GetInput ( context , node , kInputTensor1 ) ; const TfLiteTensor * input2 = GetInput ( context , node , kInputTensor2 ) ; if ( input1 -> type == kTfLiteUInt8 || input1 -> type == kTfLiteInt8 ) { auto input1_offset = - input1 -> params . zero_point ; auto input2_offset = - input2 -> params . zero_point ; const int kLeftShift = 8 ; int32_t input1_multiplier ; int input1_shift ; QuantizeMultiplierSmallerThanOneExp ( static_cast < double > ( input1 -> params . scale ) , & input1_multiplier , & input1_shift ) ; int32_t input2_multiplier ; int input2_shift ; QuantizeMultiplierSmallerThanOneExp ( static_cast < double > ( input2 -> params . scale ) , & input2_multiplier , & input2_shift ) ; data -> params . left_shift = kLeftShift ; data -> params . input1_offset = input1_offset ; data -> params . input1_multiplier = input1_multiplier ; data -> params . input1_shift = input1_shift ; data -> params . input2_offset = input2_offset ; data -> params . input2_multiplier = input2_multiplier ; data -> params . input2_shift = input2_shift ; } return kTfLiteOk ; }
void PrintMap ( int indent , const char * label , VariableMap * map , bool locals , Variable * function_var ) { bool printed_label = false ; for ( VariableMap :: Entry * p = map -> Start ( ) ; p != nullptr ; p = map -> Next ( p ) ) { Variable * var = reinterpret_cast < Variable * > ( p -> value ) ; if ( var == function_var ) continue ; if ( var == kDummyPreParserVariable || var == kDummyPreParserLexicalVariable ) { continue ; } bool local = ! IsDynamicVariableMode ( var -> mode ( ) ) ; if ( ( locals ? local : ! local ) && ( var -> is_used ( ) || ! var -> IsUnallocated ( ) ) ) { if ( ! printed_label ) { Indent ( indent , label ) ; printed_label = true ; } PrintVar ( indent , var ) ; } } }
void InterpreterAssembler :: UpdateInterruptBudgetOnReturn ( ) { const int kFirstBytecodeOffset = BytecodeArray :: kHeaderSize - kHeapObjectTag ; Node * profiling_weight = Int32Sub ( TruncateIntPtrToInt32 ( BytecodeOffset ( ) ) , Int32Constant ( kFirstBytecodeOffset ) ) ; UpdateInterruptBudget ( profiling_weight , true ) ; }
int btsock_thread_add_fd ( int h , int fd , int type , int flags , uint32_t user_id ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( "invalid bt thread handle:%d" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( "cmd socket is not created. socket thread may not initialized" ) ; return FALSE ; } if ( flags & SOCK_THREAD_ADD_FD_SYNC ) { if ( ts [ h ] . thread_id == pthread_self ( ) ) { flags &= ~ SOCK_THREAD_ADD_FD_SYNC ; add_poll ( h , fd , type , flags , user_id ) ; return TRUE ; } APPL_TRACE_DEBUG ( "THREAD_ADD_FD_SYNC is not called in poll thread, fallback to async" ) ; } sock_cmd_t cmd = { CMD_ADD_FD , fd , type , flags , user_id } ; APPL_TRACE_DEBUG ( "adding fd:%d, flags:0x%x" , fd , flags ) ; return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; }
ScriptAnalysis :: killVariable ( JSContext * cx , LifetimeVariable & var , unsigned offset , LifetimeVariable * * & saved , unsigned & savedCount ) { if ( ! var . lifetime ) { if ( ! var . saved ) saved [ savedCount ++ ] = & var ; var . saved = cx -> typeLifoAlloc ( ) . new_ < Lifetime > ( offset , var . savedEnd , var . saved ) ; if ( ! var . saved ) { setOOM ( cx ) ; return ; } var . saved -> write = true ; var . savedEnd = 0 ; return ; } JS_ASSERT_IF ( ! var . ensured , offset < var . lifetime -> start ) ; unsigned start = var . lifetime -> start ; var . lifetime -> start = offset ; var . lifetime -> write = true ; if ( var . ensured ) { var . lifetime = cx -> typeLifoAlloc ( ) . new_ < Lifetime > ( start , offset , var . lifetime ) ; if ( ! var . lifetime ) { setOOM ( cx ) ; return ; } } else { var . saved = var . lifetime ; var . savedEnd = 0 ; var . lifetime = NULL ; saved [ savedCount ++ ] = & var ; } }
void DoSample ( const v8 :: RegisterState & state ) { AtomicGuard atomic_guard ( & SamplerManager :: samplers_access_counter_ , false ) ; if ( ! atomic_guard . is_success ( ) ) return ; pthread_t thread_id = pthread_self ( ) ; base :: HashMap :: Entry * entry = sampler_map_ . Lookup ( ThreadKey ( thread_id ) , ThreadHash ( thread_id ) ) ; if ( ! entry ) return ; SamplerList & samplers = * static_cast < SamplerList * > ( entry -> value ) ; for ( size_t i = 0 ; i < samplers . size ( ) ; ++ i ) { Sampler * sampler = samplers [ i ] ; Isolate * isolate = sampler -> isolate ( ) ; if ( isolate == nullptr || ! isolate -> IsInUse ( ) ) continue ; if ( v8 :: Locker :: IsActive ( ) && ! Locker :: IsLocked ( isolate ) ) continue ; sampler -> SampleStack ( state ) ; } }
CheckSetDeviceIndicators ( char * wire , DeviceIntPtr dev , int num , int * status_rtrn , ClientPtr client ) { xkbDeviceLedsWireDesc * ledWire ; int i ; XkbSrvLedInfoPtr sli ; ledWire = ( xkbDeviceLedsWireDesc * ) wire ; for ( i = 0 ; i < num ; i ++ ) { if ( client -> swapped ) { swaps ( & ledWire -> ledClass ) ; swaps ( & ledWire -> ledID ) ; swapl ( & ledWire -> namesPresent ) ; swapl ( & ledWire -> mapsPresent ) ; swapl ( & ledWire -> physIndicators ) ; } sli = XkbFindSrvLedInfo ( dev , ledWire -> ledClass , ledWire -> ledID , XkbXI_IndicatorsMask ) ; if ( sli != NULL ) { register int n ; register unsigned bit ; int nMaps , nNames ; CARD32 * atomWire ; xkbIndicatorMapWireDesc * mapWire ; nMaps = nNames = 0 ; for ( n = 0 , bit = 1 ; n < XkbNumIndicators ; n ++ , bit <<= 1 ) { if ( ledWire -> namesPresent & bit ) nNames ++ ; if ( ledWire -> mapsPresent & bit ) nMaps ++ ; } atomWire = ( CARD32 * ) & ledWire [ 1 ] ; if ( nNames > 0 ) { for ( n = 0 ; n < nNames ; n ++ ) { if ( client -> swapped ) { swapl ( atomWire ) ; } CHK_ATOM_OR_NONE3 ( ( ( Atom ) ( * atomWire ) ) , client -> errorValue , * status_rtrn , NULL ) ; atomWire ++ ; } } mapWire = ( xkbIndicatorMapWireDesc * ) atomWire ; if ( nMaps > 0 ) { for ( n = 0 ; n < nMaps ; n ++ ) { if ( client -> swapped ) { swaps ( & mapWire -> virtualMods ) ; swapl ( & mapWire -> ctrls ) ; } CHK_MASK_LEGAL3 ( 0x21 , mapWire -> whichGroups , XkbIM_UseAnyGroup , client -> errorValue , * status_rtrn , NULL ) ; CHK_MASK_LEGAL3 ( 0x22 , mapWire -> whichMods , XkbIM_UseAnyMods , client -> errorValue , * status_rtrn , NULL ) ; mapWire ++ ; } } ledWire = ( xkbDeviceLedsWireDesc * ) mapWire ; } else { return ( char * ) ledWire ; } } return ( char * ) ledWire ; }
MaybeHandle < MutableBigInt > MutableBigInt :: AbsoluteAddOne ( Isolate * isolate , Handle < BigIntBase > x , bool sign , MutableBigInt * result_storage ) { int input_length = x -> length ( ) ; bool will_overflow = true ; for ( int i = 0 ; i < input_length ; i ++ ) { if ( ! digit_ismax ( x -> digit ( i ) ) ) { will_overflow = false ; break ; } } int result_length = input_length + will_overflow ; Handle < MutableBigInt > result ( result_storage , isolate ) ; if ( result_storage == nullptr ) { if ( ! New ( isolate , result_length ) . ToHandle ( & result ) ) { return MaybeHandle < MutableBigInt > ( ) ; } } else { DCHECK ( result -> length ( ) == result_length ) ; } digit_t carry = 1 ; for ( int i = 0 ; i < input_length ; i ++ ) { digit_t new_carry = 0 ; result -> set_digit ( i , digit_add ( x -> digit ( i ) , carry , & new_carry ) ) ; carry = new_carry ; } if ( result_length > input_length ) { result -> set_digit ( input_length , carry ) ; } else { DCHECK_EQ ( carry , 0 ) ; } result -> set_sign ( sign ) ; return result ; }
static int try_smi_init ( struct smi_info * new_smi ) { int rv = 0 ; int i ; char * init_name = NULL ; pr_info ( "Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n" , ipmi_addr_src_to_str ( new_smi -> io . addr_source ) , si_to_str [ new_smi -> io . si_type ] , addr_space_to_str [ new_smi -> io . addr_type ] , new_smi -> io . addr_data , new_smi -> io . slave_addr , new_smi -> io . irq ) ; switch ( new_smi -> io . si_type ) { case SI_KCS : new_smi -> handlers = & kcs_smi_handlers ; break ; case SI_SMIC : new_smi -> handlers = & smic_smi_handlers ; break ; case SI_BT : new_smi -> handlers = & bt_smi_handlers ; break ; default : rv = - EIO ; goto out_err ; } new_smi -> si_num = smi_num ; if ( ! new_smi -> io . dev ) { init_name = kasprintf ( GFP_KERNEL , "ipmi_si.%d" , new_smi -> si_num ) ; new_smi -> pdev = platform_device_alloc ( "ipmi_si" , new_smi -> si_num ) ; if ( ! new_smi -> pdev ) { pr_err ( "Unable to allocate platform device\n" ) ; rv = - ENOMEM ; goto out_err ; } new_smi -> io . dev = & new_smi -> pdev -> dev ; new_smi -> io . dev -> driver = & ipmi_platform_driver . driver ; new_smi -> io . dev -> init_name = init_name ; } new_smi -> si_sm = kmalloc ( new_smi -> handlers -> size ( ) , GFP_KERNEL ) ; if ( ! new_smi -> si_sm ) { rv = - ENOMEM ; goto out_err ; } new_smi -> io . io_size = new_smi -> handlers -> init_data ( new_smi -> si_sm , & new_smi -> io ) ; rv = new_smi -> io . io_setup ( & new_smi -> io ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Could not set up I/O space\n" ) ; goto out_err ; } if ( new_smi -> handlers -> detect ( new_smi -> si_sm ) ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , "Interface detection failed\n" ) ; rv = - ENODEV ; goto out_err ; } rv = try_get_dev_id ( new_smi ) ; if ( rv ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , "There appears to be no BMC at this location\n" ) ; goto out_err ; } setup_oem_data_handler ( new_smi ) ; setup_xaction_handlers ( new_smi ) ; check_for_broken_irqs ( new_smi ) ; new_smi -> waiting_msg = NULL ; new_smi -> curr_msg = NULL ; atomic_set ( & new_smi -> req_events , 0 ) ; new_smi -> run_to_completion = false ; for ( i = 0 ; i < SI_NUM_STATS ; i ++ ) atomic_set ( & new_smi -> stats [ i ] , 0 ) ; new_smi -> interrupt_disabled = true ; atomic_set ( & new_smi -> need_watch , 0 ) ; rv = try_enable_event_buffer ( new_smi ) ; if ( rv == 0 ) new_smi -> has_event_buffer = true ; start_clear_flags ( new_smi ) ; if ( new_smi -> io . irq ) { new_smi -> interrupt_disabled = false ; atomic_set ( & new_smi -> req_events , 1 ) ; } if ( new_smi -> pdev && ! new_smi -> pdev_registered ) { rv = platform_device_add ( new_smi -> pdev ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable to register system interface device: %d\n" , rv ) ; goto out_err ; } new_smi -> pdev_registered = true ; } dev_set_drvdata ( new_smi -> io . dev , new_smi ) ; rv = device_add_group ( new_smi -> io . dev , & ipmi_si_dev_attr_group ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable to add device attributes: error %d\n" , rv ) ; goto out_err ; } new_smi -> dev_group_added = true ; rv = ipmi_register_smi ( & handlers , new_smi , new_smi -> io . dev , new_smi -> io . slave_addr ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable to register device: error %d\n" , rv ) ; goto out_err ; } smi_num ++ ; dev_info ( new_smi -> io . dev , "IPMI %s interface initialized\n" , si_to_str [ new_smi -> io . si_type ] ) ; WARN_ON ( new_smi -> io . dev -> init_name != NULL ) ; out_err : kfree ( init_name ) ; return rv ; }
WORD32 ih264d_parse_islice_data_cavlc ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice < < u1_mbaff ; do { UWORD8 u1_mb_type ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs > > u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; { UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; UWORD32 u4_word , u4_ldz , u4_temp ; NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_ldz = CLZ ( u4_word ) ; u4_bitstream_offset += ( u4_ldz + 1 ) ; u4_word = 0 ; if ( u4_ldz ) GETBITS ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf , u4_ldz ) ; * pu4_bitstrm_ofst = u4_bitstream_offset ; u4_temp = ( ( 1 < < u4_ldz ) + u4_word - 1 ) ; if ( u4_temp > 25 ) return ERROR_MB_TYPE ; u1_mb_type = u4_temp ; } ps_cur_mb_info -> u1_mb_type = u1_mb_type ; COPYTHECONTEXT ( "u1_mb_type" , u1_mb_type ) ; if ( 25 == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = 0 ; } else { ret = ih264d_parse_imb_cavlc ( ps_dec , ps_cur_mb_info , u1_num_mbs , u1_mb_type ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; uc_more_data_flag = MORE_RBSP_DATA ( ps_bitstrm ) ; { mv_pred_t * ps_mv_nmb_start = ps_dec -> ps_mv_cur + ( u1_num_mbs < < 4 ) ; mv_pred_t s_mvPred = { { 0 , 0 , 0 , 0 } , { - 1 , - 1 } , 0 , 0 } ; ih264d_rep_mv_colz ( ps_dec , & s_mvPred , ps_mv_nmb_start , 0 , ( UWORD8 ) ( ps_dec -> u1_cur_mb_fld_dec_flag < < 1 ) , 4 , 4 ) ; } if ( ps_dec -> u4_num_cores < 3 ) { if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ps_dec -> pf_compute_bs ( ps_dec , ps_cur_mb_info , ( UWORD16 ) ( u1_num_mbs > > u1_mbaff ) ) ; } u1_num_mbs ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || ( ! uc_more_data_flag ) ; ps_cur_mb_info -> u1_end_of_slice = ( ! uc_more_data_flag ) ; if ( u1_tfr_n_mb || ( ! uc_more_data_flag ) ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } while ( uc_more_data_flag ) ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice < < u1_mbaff ) ; return ret ; }
static struct rmap_item * scan_get_next_rmap_item ( struct page * * page ) { struct mm_struct * mm ; struct mm_slot * slot ; struct vm_area_struct * vma ; struct rmap_item * rmap_item ; if ( list_empty ( & ksm_mm_head . mm_list ) ) return NULL ; slot = ksm_scan . mm_slot ; if ( slot == & ksm_mm_head ) { lru_add_drain_all ( ) ; root_unstable_tree = RB_ROOT ; spin_lock ( & ksm_mmlist_lock ) ; slot = list_entry ( slot -> mm_list . next , struct mm_slot , mm_list ) ; ksm_scan . mm_slot = slot ; spin_unlock ( & ksm_mmlist_lock ) ; next_mm : ksm_scan . address = 0 ; ksm_scan . rmap_list = & slot -> rmap_list ; } mm = slot -> mm ; down_read ( & mm -> mmap_sem ) ; if ( ksm_test_exit ( mm ) ) vma = NULL ; else vma = find_vma ( mm , ksm_scan . address ) ; for ( ; vma ; vma = vma -> vm_next ) { if ( ! ( vma -> vm_flags & VM_MERGEABLE ) ) continue ; if ( ksm_scan . address < vma -> vm_start ) ksm_scan . address = vma -> vm_start ; if ( ! vma -> anon_vma ) ksm_scan . address = vma -> vm_end ; while ( ksm_scan . address < vma -> vm_end ) { if ( ksm_test_exit ( mm ) ) break ; * page = follow_page ( vma , ksm_scan . address , FOLL_GET ) ; if ( IS_ERR_OR_NULL ( * page ) ) { ksm_scan . address += PAGE_SIZE ; cond_resched ( ) ; continue ; } if ( PageAnon ( * page ) || page_trans_compound_anon ( * page ) ) { flush_anon_page ( vma , * page , ksm_scan . address ) ; flush_dcache_page ( * page ) ; rmap_item = get_next_rmap_item ( slot , ksm_scan . rmap_list , ksm_scan . address ) ; if ( rmap_item ) { ksm_scan . rmap_list = & rmap_item -> rmap_list ; ksm_scan . address += PAGE_SIZE ; } else put_page ( * page ) ; up_read ( & mm -> mmap_sem ) ; return rmap_item ; } put_page ( * page ) ; ksm_scan . address += PAGE_SIZE ; cond_resched ( ) ; } } if ( ksm_test_exit ( mm ) ) { ksm_scan . address = 0 ; ksm_scan . rmap_list = & slot -> rmap_list ; } remove_trailing_rmap_items ( slot , ksm_scan . rmap_list ) ; spin_lock ( & ksm_mmlist_lock ) ; ksm_scan . mm_slot = list_entry ( slot -> mm_list . next , struct mm_slot , mm_list ) ; if ( ksm_scan . address == 0 ) { hlist_del ( & slot -> link ) ; list_del ( & slot -> mm_list ) ; spin_unlock ( & ksm_mmlist_lock ) ; free_mm_slot ( slot ) ; clear_bit ( MMF_VM_MERGEABLE , & mm -> flags ) ; up_read ( & mm -> mmap_sem ) ; mmdrop ( mm ) ; } else { spin_unlock ( & ksm_mmlist_lock ) ; up_read ( & mm -> mmap_sem ) ; } slot = ksm_scan . mm_slot ; if ( slot != & ksm_mm_head ) goto next_mm ; ksm_scan . seqnr ++ ; return NULL ; }
static void ext4_invalidatepage ( struct page * page , unsigned long offset ) { journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ; if ( offset == 0 ) ClearPageChecked ( page ) ; if ( journal ) jbd2_journal_invalidatepage ( journal , page , offset ) ; else block_invalidatepage ( page , offset ) ; }
nsBlockFrame :: AppendFrames ( ChildListID aListID , nsFrameList & aFrameList ) { if ( aFrameList . IsEmpty ( ) ) { return ; } if ( aListID != kPrincipalList ) { if ( kFloatList == aListID ) { mFloats . AppendFrames ( nullptr , aFrameList ) ; return ; } MOZ_ASSERT ( kNoReflowPrincipalList == aListID , "unexpected child list" ) ; } nsIFrame * lastKid = mFrames . LastChild ( ) ; NS_ASSERTION ( ( mLines . empty ( ) ? nullptr : mLines . back ( ) -> LastChild ( ) ) == lastKid , "out-of-sync mLines / mFrames" ) ; #ifdef NOISY_REFLOW_REASON ListTag ( stdout ) ; printf ( ": append " ) ; nsFrame :: ListTag ( stdout , aFrameList ) ; if ( lastKid ) { printf ( " after " ) ; nsFrame :: ListTag ( stdout , lastKid ) ; } printf ( "\n" ) ; #endif AddFrames ( aFrameList , lastKid ) ; if ( aListID != kNoReflowPrincipalList ) { PresContext ( ) -> PresShell ( ) -> FrameNeedsReflow ( this , nsIPresShell :: eTreeChange , NS_FRAME_HAS_DIRTY_CHILDREN ) ; } }
void PropertiesWidget :: loadTorrentInfos ( BitTorrent :: TorrentHandle * const torrent ) { clear ( ) ; m_torrent = torrent ; downloaded_pieces -> setTorrent ( m_torrent ) ; pieces_availability -> setTorrent ( m_torrent ) ; if ( ! m_torrent ) return ; updateSavePath ( m_torrent ) ; hash_lbl -> setText ( m_torrent -> hash ( ) ) ; PropListModel -> model ( ) -> clear ( ) ; if ( m_torrent -> hasMetadata ( ) ) { lbl_creationDate -> setText ( m_torrent -> creationDate ( ) . toString ( Qt :: DefaultLocaleShortDate ) ) ; label_total_size_val -> setText ( Utils :: Misc :: friendlyUnit ( m_torrent -> totalSize ( ) ) ) ; comment_text -> setText ( Utils :: Misc :: parseHtmlLinks ( m_torrent -> comment ( ) ) ) ; loadUrlSeeds ( ) ; label_created_by_val -> setText ( m_torrent -> creator ( ) ) ; PropListModel -> model ( ) -> setupModelData ( m_torrent -> info ( ) ) ; filesList -> setExpanded ( PropListModel -> index ( 0 , 0 ) , true ) ; PropListModel -> model ( ) -> updateFilesPriorities ( m_torrent -> filePriorities ( ) ) ; } loadDynamicData ( ) ; }
void BytecodeGraphBuilder :: BuildLoopExitsForBranch ( int target_offset ) { int origin_offset = bytecode_iterator ( ) . current_offset ( ) ; if ( target_offset > origin_offset ) { BuildLoopExitsUntilLoop ( bytecode_analysis ( ) -> GetLoopOffsetFor ( target_offset ) , bytecode_analysis ( ) -> GetInLivenessFor ( target_offset ) ) ; } }
WORD32 ih264d_end_of_pic_processing ( dec_struct_t * ps_dec ) { UWORD8 u1_pic_type , u1_nal_ref_idc ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; WORD32 ret ; u1_pic_type = 0 ; u1_nal_ref_idc = ps_cur_slice -> u1_nal_ref_idc ; if ( u1_nal_ref_idc ) { if ( ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { if ( ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag == 0 ) { ih264d_reset_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; { ret = ih264d_insert_st_node ( ps_dec -> ps_dpb_mgr , ps_dec -> ps_cur_pic , ps_dec -> u1_pic_buf_id , ps_cur_slice -> u2_frame_num ) ; if ( ret != OK ) return ret ; } } else { { ret = ih264d_insert_st_node ( ps_dec -> ps_dpb_mgr , ps_dec -> ps_cur_pic , ps_dec -> u1_pic_buf_id , ps_cur_slice -> u2_frame_num ) ; if ( ret != OK ) return ret ; ret = ih264d_delete_st_node_or_make_lt ( ps_dec -> ps_dpb_mgr , ps_cur_slice -> u2_frame_num , 0 , ps_cur_slice -> u1_field_pic_flag ) ; if ( ret != OK ) return ret ; ps_dec -> ps_dpb_mgr -> u1_max_lt_pic_idx_plus1 = 1 ; } } } else { { UWORD16 u2_pic_num = ps_cur_slice -> u2_frame_num ; ret = ih264d_do_mmco_buffer ( ps_dec -> ps_dpb_cmds , ps_dec -> ps_dpb_mgr , ps_dec -> ps_cur_sps -> u1_num_ref_frames , u2_pic_num , ( ps_dec -> ps_cur_sps -> u2_u4_max_pic_num_minus1 ) , ps_dec -> u1_nal_unit_type , ps_dec -> ps_cur_pic , ps_dec -> u1_pic_buf_id , ps_cur_slice -> u1_field_pic_flag , ps_dec -> e_dec_status ) ; if ( ret != OK ) return ret ; } } ih264d_update_default_index_list ( ps_dec -> ps_dpb_mgr ) ; } if ( ps_cur_slice -> u1_field_pic_flag ) { if ( ps_cur_slice -> u1_bottom_field_flag ) { if ( u1_nal_ref_idc ) u1_pic_type = u1_pic_type | BOT_REF ; u1_pic_type = u1_pic_type | BOT_FLD ; } else { if ( u1_nal_ref_idc ) u1_pic_type = u1_pic_type | TOP_REF ; u1_pic_type = u1_pic_type | TOP_FLD ; } } else u1_pic_type = TOP_REF | BOT_REF ; ps_dec -> ps_cur_pic -> u1_pic_type |= u1_pic_type ; #if ROW_ACCESSES_STAT { H264_DEC_DEBUG_PRINT ( "Row_Accesses_BeforeBB = %6d, Row_Accesses_AfterBB = %6d \n\n" , gui_Row_Accesses_BeforeBB , gui_Row_Accesses_AfterBB ) ; gui_Row_Accesses_BeforeBBTotal += gui_Row_Accesses_BeforeBB ; gui_Row_Accesses_AfterBBTotal += gui_Row_Accesses_AfterBB ; gui_Row_Accesses_AfterBB = 0 ; gui_Row_Accesses_BeforeBB = 0 ; } #endif if ( ps_cur_slice -> u1_field_pic_flag ) { H264_DEC_DEBUG_PRINT ( "Toggling secondField\n" ) ; ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; } return OK ; }
RUNTIME_FUNCTION ( Runtime_CompileOptimized_Concurrent ) { HandleScope scope ( isolate ) ; DCHECK_EQ ( 1 , args . length ( ) ) ; CONVERT_ARG_HANDLE_CHECKED ( JSFunction , function , 0 ) ; StackLimitCheck check ( isolate ) ; if ( check . JsHasOverflowed ( kStackSpaceRequiredForCompilation * KB ) ) { return isolate -> StackOverflow ( ) ; } if ( ! Compiler :: CompileOptimized ( function , ConcurrencyMode :: kConcurrent ) ) { return ReadOnlyRoots ( isolate ) . exception ( ) ; } DCHECK ( function -> is_compiled ( ) ) ; return function -> code ( ) ; }
ScriptExecutorRunnable :: Cancel ( ) { if ( mLastIndex == mScriptLoader . mLoadInfos . Length ( ) - 1 ) { ShutdownScriptLoader ( mWorkerPrivate -> GetJSContext ( ) , mWorkerPrivate , false ) ; } return MainThreadWorkerSyncRunnable :: Cancel ( ) ; }
void GetSettings ( MediaTrackSettings & aOutSettings ) override { if ( mListener ) { mListener -> GetSettingsFor ( mTrack , aOutSettings ) ; } }
void Document :: OnParsingCompleted ( ) { OnL10nResourceContainerParsed ( ) ; if ( mDocumentL10n ) { mDocumentL10n -> TriggerInitialTranslation ( ) ; } }
static int posix_lock_inode_wait ( struct inode * inode , struct file_lock * fl ) { int error ; might_sleep ( ) ; for ( ; ; ) { error = posix_lock_inode ( inode , fl , NULL ) ; if ( error != FILE_LOCK_DEFERRED ) break ; error = wait_event_interruptible ( fl -> fl_wait , ! fl -> fl_blocker ) ; if ( error ) break ; } locks_delete_block ( fl ) ; return error ; }
int ip_options_get_from_user ( struct net * net , struct ip_options * * optp , unsigned char __user * data , int optlen ) { struct ip_options * opt = ip_options_get_alloc ( optlen ) ; if ( ! opt ) return - ENOMEM ; if ( optlen && copy_from_user ( opt -> __data , data , optlen ) ) { kfree ( opt ) ; return - EFAULT ; } return ip_options_get_finish ( net , optp , opt , optlen ) ; }
RUNTIME_FUNCTION ( Runtime_TypedArraySet ) { HandleScope scope ( isolate ) ; Handle < JSTypedArray > target = args . at < JSTypedArray > ( 0 ) ; Handle < Object > obj = args . at ( 1 ) ; Handle < Smi > offset = args . at < Smi > ( 2 ) ; DCHECK ( ! target -> WasNeutered ( ) ) ; DCHECK ( ! obj -> IsJSTypedArray ( ) ) ; DCHECK_LE ( 0 , offset -> value ( ) ) ; const uint32_t uint_offset = static_cast < uint32_t > ( offset -> value ( ) ) ; if ( obj -> IsNumber ( ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewTypeError ( MessageTemplate :: kInvalidArgument ) ) ; } ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , obj , Object :: ToObject ( isolate , obj ) ) ; Handle < Object > len ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , len , Object :: GetProperty ( isolate , obj , isolate -> factory ( ) -> length_string ( ) ) ) ; ASSIGN_RETURN_FAILURE_ON_EXCEPTION ( isolate , len , Object :: ToLength ( isolate , len ) ) ; if ( uint_offset + len -> Number ( ) > target -> length_value ( ) ) { THROW_NEW_ERROR_RETURN_FAILURE ( isolate , NewRangeError ( MessageTemplate :: kTypedArraySetSourceTooLarge ) ) ; } uint32_t int_l ; CHECK ( DoubleToUint32IfEqualToSelf ( len -> Number ( ) , & int_l ) ) ; Handle < JSReceiver > source = Handle < JSReceiver > :: cast ( obj ) ; ElementsAccessor * accessor = target -> GetElementsAccessor ( ) ; return accessor -> CopyElements ( source , target , int_l , uint_offset ) ; }
void Debug :: DeoptimizeFunction ( Handle < SharedFunctionInfo > shared ) { isolate_ -> AbortConcurrentOptimization ( BlockingBehavior :: kBlock ) ; isolate_ -> heap ( ) -> CollectAllGarbage ( Heap :: kMakeHeapIterableMask , GarbageCollectionReason :: kDebugger ) ; bool found_something = false ; Code :: OptimizedCodeIterator iterator ( isolate_ ) ; while ( Code * code = iterator . Next ( ) ) { if ( code -> Inlines ( * shared ) ) { code -> set_marked_for_deoptimization ( true ) ; found_something = true ; } } if ( found_something ) { Deoptimizer :: DeoptimizeMarkedCode ( isolate_ ) ; } }
sctp_ss_fb_clear ( struct sctp_tcb * stcb , struct sctp_association * asoc , int clear_values , int holds_lock ) { if ( holds_lock == 0 ) { SCTP_TCB_SEND_LOCK ( stcb ) ; } while ( ! TAILQ_EMPTY ( & asoc -> ss_data . out . wheel ) ) { struct sctp_stream_out * strq ; strq = TAILQ_FIRST ( & asoc -> ss_data . out . wheel ) ; if ( clear_values ) { strq -> ss_params . fb . rounds = - 1 ; } TAILQ_REMOVE ( & asoc -> ss_data . out . wheel , strq , ss_params . fb . next_spoke ) ; strq -> ss_params . fb . next_spoke . tqe_next = NULL ; strq -> ss_params . fb . next_spoke . tqe_prev = NULL ; } asoc -> ss_data . last_out_stream = NULL ; if ( holds_lock == 0 ) { SCTP_TCB_SEND_UNLOCK ( stcb ) ; } return ; }
WasmCode * WasmCompilationUnit :: CompileWasmFunction ( Isolate * isolate , NativeModule * native_module , WasmFeatures * detected , ErrorThrower * thrower , ModuleEnv * env , const WasmFunction * function , ExecutionTier mode ) { ModuleWireBytes wire_bytes ( native_module -> wire_bytes ( ) ) ; FunctionBody function_body { function -> sig , function -> code . offset ( ) , wire_bytes . start ( ) + function -> code . offset ( ) , wire_bytes . start ( ) + function -> code . end_offset ( ) } ; WasmCompilationUnit unit ( isolate -> wasm_engine ( ) , env , native_module , function_body , wire_bytes . GetNameOrNull ( function , env -> module ) , function -> func_index , isolate -> counters ( ) , mode ) ; unit . ExecuteCompilation ( detected ) ; return unit . FinishCompilation ( thrower ) ; }
InitArgsFromArrayLike ( JSContext * cx , HandleValue v , InvokeArgs * args ) { RootedObject obj ( cx , NonNullObject ( cx , v ) ) ; if ( ! obj ) return false ; uint32_t len ; if ( ! GetLengthProperty ( cx , obj , & len ) ) return false ; if ( len > ARGS_LENGTH_MAX ) { JS_ReportErrorNumberASCII ( cx , GetErrorMessage , nullptr , JSMSG_TOO_MANY_FUN_APPLY_ARGS ) ; return false ; } if ( ! args -> init ( len ) ) return false ; for ( uint32_t index = 0 ; index < len ; index ++ ) { if ( ! GetElement ( cx , obj , obj , index , ( * args ) [ index ] ) ) return false ; } return true ; }
void BigInt :: SerializeDigits ( uint8_t * storage ) { void * digits = reinterpret_cast < void * > ( reinterpret_cast < Address > ( this ) + kDigitsOffset - kHeapObjectTag ) ; #if defined(V8_TARGET_LITTLE_ENDIAN) int bytelength = length ( ) * kDigitSize ; memcpy ( storage , digits , bytelength ) ; #elif defined(V8_TARGET_BIG_ENDIAN) digit_t * digit_storage = reinterpret_cast < digit_t * > ( storage ) ; const digit_t * digit = reinterpret_cast < const digit_t * > ( digits ) ; for ( int i = 0 ; i < length ( ) ; i ++ ) { * digit_storage = ByteReverse ( * digit ) ; digit_storage ++ ; digit ++ ; } #endif // V8_TARGET_BIG_ENDIAN }
PREFIX ( scanCharRef ) ( const ENCODING * enc , const char * ptr , const char * end , const char * * nextTokPtr ) { if ( ptr != end ) { if ( CHAR_MATCHES ( enc , ptr , ASCII_x ) ) return PREFIX ( scanHexCharRef ) ( enc , ptr + MINBPC ( enc ) , end , nextTokPtr ) ; switch ( BYTE_TYPE ( enc , ptr ) ) { case BT_DIGIT : break ; default : * nextTokPtr = ptr ; return XML_TOK_INVALID ; } for ( ptr += MINBPC ( enc ) ; ptr != end ; ptr += MINBPC ( enc ) ) { switch ( BYTE_TYPE ( enc , ptr ) ) { case BT_DIGIT : break ; case BT_SEMI : * nextTokPtr = ptr + MINBPC ( enc ) ; return XML_TOK_CHAR_REF ; default : * nextTokPtr = ptr ; return XML_TOK_INVALID ; } } } return XML_TOK_PARTIAL ; }
txStylesheetCompilerState :: pushPtr ( void * aPtr ) { #ifdef TX_DEBUG_STACK PR_LOG ( txLog :: xslt , PR_LOG_DEBUG , ( "pushPtr: %d\n" , aPtr ) ) ; #endif return mOtherStack . push ( aPtr ) ; }
static void tm_reclaim_thread ( struct thread_struct * thr , struct thread_info * ti , uint8_t cause ) { unsigned long msr_diff = 0 ; if ( test_ti_thread_flag ( ti , TIF_RESTORE_TM ) ) { msr_diff = thr -> ckpt_regs . msr & ~ thr -> regs -> msr ; if ( msr_diff & MSR_FP ) memcpy ( & thr -> transact_fp , & thr -> fp_state , sizeof ( struct thread_fp_state ) ) ; if ( msr_diff & MSR_VEC ) memcpy ( & thr -> transact_vr , & thr -> vr_state , sizeof ( struct thread_vr_state ) ) ; clear_ti_thread_flag ( ti , TIF_RESTORE_TM ) ; msr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1 ; } tm_reclaim ( thr , thr -> regs -> msr , cause ) ; thr -> regs -> msr |= msr_diff ; }
status_t MediaPlayer :: setDataSource ( int fd , int64_t offset , int64_t length ) { ALOGV ( "setDataSource(%d, %" PRId64 ", %" PRId64 ")" , fd , offset , length ) ; status_t err = UNKNOWN_ERROR ; const sp < IMediaPlayerService > & service ( getMediaPlayerService ( ) ) ; if ( service != 0 ) { sp < IMediaPlayer > player ( service -> create ( this , mAudioSessionId ) ) ; if ( ( NO_ERROR != doSetRetransmitEndpoint ( player ) ) || ( NO_ERROR != player -> setDataSource ( fd , offset , length ) ) ) { player . clear ( ) ; } err = attachNewPlayer ( player ) ; } return err ; }
nsGlobalWindow :: DefineArgumentsProperty ( nsIArray * aArguments ) { JSContext * cx ; nsIScriptContext * ctx = GetOuterWindowInternal ( ) -> mContext ; NS_ENSURE_TRUE ( aArguments && ctx && ( cx = ctx -> GetNativeContext ( ) ) , NS_ERROR_NOT_INITIALIZED ) ; if ( mIsModalContentWindow ) { return NS_OK ; } return GetContextInternal ( ) -> SetProperty ( mJSObject , "arguments" , aArguments ) ; }
opj_image_t * pgxtoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f = NULL ; int w , h , prec ; int i , numcomps , max ; OPJ_COLOR_SPACE color_space ; opj_image_cmptparm_t cmptparm ; opj_image_t * image = NULL ; int adjustS , ushift , dshift , force8 ; char endian1 , endian2 , sign ; char signtmp [ 32 ] ; char temp [ 32 ] ; int bigendian ; opj_image_comp_t * comp = NULL ; numcomps = 1 ; color_space = OPJ_CLRSPC_GRAY ; memset ( & cmptparm , 0 , sizeof ( opj_image_cmptparm_t ) ) ; max = 0 ; f = fopen ( filename , "rb" ) ; if ( ! f ) { fprintf ( stderr , "Failed to open %s for reading !\n" , filename ) ; return NULL ; } fseek ( f , 0 , SEEK_SET ) ; if ( fscanf ( f , "PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d" , temp , & endian1 , & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) { fclose ( f ) ; fprintf ( stderr , "ERROR: Failed to read the right number of element from the fscanf() function!\n" ) ; return NULL ; } i = 0 ; sign = '+' ; while ( signtmp [ i ] != '\0' ) { if ( signtmp [ i ] == '-' ) { sign = '-' ; } i ++ ; } fgetc ( f ) ; if ( endian1 == 'M' && endian2 == 'L' ) { bigendian = 1 ; } else if ( endian2 == 'M' && endian1 == 'L' ) { bigendian = 0 ; } else { fclose ( f ) ; fprintf ( stderr , "Bad pgx header, please check input file\n" ) ; return NULL ; } cmptparm . x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; cmptparm . y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; cmptparm . w = ! cmptparm . x0 ? ( OPJ_UINT32 ) ( ( w - 1 ) * parameters -> subsampling_dx + 1 ) : cmptparm . x0 + ( OPJ_UINT32 ) ( w - 1 ) * ( OPJ_UINT32 ) parameters -> subsampling_dx + 1 ; cmptparm . h = ! cmptparm . y0 ? ( OPJ_UINT32 ) ( ( h - 1 ) * parameters -> subsampling_dy + 1 ) : cmptparm . y0 + ( OPJ_UINT32 ) ( h - 1 ) * ( OPJ_UINT32 ) parameters -> subsampling_dy + 1 ; if ( sign == '-' ) { cmptparm . sgnd = 1 ; } else { cmptparm . sgnd = 0 ; } if ( prec < 8 ) { force8 = 1 ; ushift = 8 - prec ; dshift = prec - ushift ; if ( cmptparm . sgnd ) { adjustS = ( 1 < < ( prec - 1 ) ) ; } else { adjustS = 0 ; } cmptparm . sgnd = 0 ; prec = 8 ; } else { ushift = dshift = force8 = adjustS = 0 ; } cmptparm . prec = ( OPJ_UINT32 ) prec ; cmptparm . bpp = ( OPJ_UINT32 ) prec ; cmptparm . dx = ( OPJ_UINT32 ) parameters -> subsampling_dx ; cmptparm . dy = ( OPJ_UINT32 ) parameters -> subsampling_dy ; image = opj_image_create ( ( OPJ_UINT32 ) numcomps , & cmptparm , color_space ) ; if ( ! image ) { fclose ( f ) ; return NULL ; } image -> x0 = cmptparm . x0 ; image -> y0 = cmptparm . x0 ; image -> x1 = cmptparm . w ; image -> y1 = cmptparm . h ; comp = & image -> comps [ 0 ] ; for ( i = 0 ; i < w * h ; i ++ ) { int v ; if ( force8 ) { v = readuchar ( f ) + adjustS ; v = ( v < < ushift ) + ( v > > dshift ) ; comp -> data [ i ] = ( unsigned char ) v ; if ( v > max ) { max = v ; } continue ; } if ( comp -> prec == 8 ) { if ( ! comp -> sgnd ) { v = readuchar ( f ) ; } else { v = ( char ) readuchar ( f ) ; } } else if ( comp -> prec <= 16 ) { if ( ! comp -> sgnd ) { v = readushort ( f , bigendian ) ; } else { v = ( short ) readushort ( f , bigendian ) ; } } else { if ( ! comp -> sgnd ) { v = ( int ) readuint ( f , bigendian ) ; } else { v = ( int ) readuint ( f , bigendian ) ; } } if ( v > max ) { max = v ; } comp -> data [ i ] = v ; } fclose ( f ) ; comp -> bpp = ( OPJ_UINT32 ) int_floorlog2 ( max ) + 1 ; return image ; }
fiber_switch ( mrb_state * mrb , mrb_value self , mrb_int len , const mrb_value * a , mrb_bool resume , mrb_bool vmexec ) { struct mrb_context * c = fiber_check ( mrb , self ) ; struct mrb_context * old_c = mrb -> c ; mrb_value value ; fiber_check_cfunc ( mrb , c ) ; if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) { mrb_raise ( mrb , E_FIBER_ERROR , "resuming transferred fiber" ) ; } if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) { mrb_raise ( mrb , E_FIBER_ERROR , "double resume (fib)" ) ; } if ( c -> status == MRB_FIBER_TERMINATED ) { mrb_raise ( mrb , E_FIBER_ERROR , "resuming dead fiber" ) ; } mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ; if ( c -> status == MRB_FIBER_CREATED ) { mrb_value * b , * e ; if ( len >= c -> stend - c -> stack ) { mrb_raise ( mrb , E_FIBER_ERROR , "too many arguments to fiber" ) ; } b = c -> stack + 1 ; e = b + len ; while ( b < e ) { * b ++ = * a ++ ; } c -> cibase -> argc = ( int ) len ; value = c -> stack [ 0 ] = MRB_PROC_ENV ( c -> ci -> proc ) -> stack [ 0 ] ; } else { value = fiber_result ( mrb , a , len ) ; } fiber_switch_context ( mrb , c ) ; if ( vmexec ) { c -> vmexec = TRUE ; value = mrb_vm_exec ( mrb , c -> ci [ - 1 ] . proc , c -> ci -> pc ) ; mrb -> c = old_c ; } else { MARK_CONTEXT_MODIFY ( c ) ; } return value ; }
int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src , int64_t ts_start , int64_t ts_end , unsigned int flags ) { struct lookahead_entry * buf ; #if USE_PARTIAL_COPY int row , col , active_end ; int mb_rows = ( src -> y_height + 15 ) > > 4 ; int mb_cols = ( src -> y_width + 15 ) > > 4 ; #endif if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ; ctx -> sz ++ ; buf = pop ( ctx , & ctx -> write_idx ) ; #if USE_PARTIAL_COPY if ( ctx -> max_sz == 1 && active_map && ! flags ) { for ( row = 0 ; row < mb_rows ; ++ row ) { col = 0 ; while ( 1 ) { for ( ; col < mb_cols ; ++ col ) { if ( active_map [ col ] ) break ; } if ( col == mb_cols ) break ; active_end = col ; for ( ; active_end < mb_cols ; ++ active_end ) { if ( ! active_map [ active_end ] ) break ; } vp9_copy_and_extend_frame_with_rect ( src , & buf -> img , row < < 4 , col < < 4 , 16 , ( active_end - col ) < < 4 ) ; col = active_end ; } active_map += mb_cols ; } } else { vp9_copy_and_extend_frame ( src , & buf -> img ) ; } #else vp9_copy_and_extend_frame ( src , & buf -> img ) ; #endif buf -> ts_start = ts_start ; buf -> ts_end = ts_end ; buf -> flags = flags ; return 0 ; }
JSHeapBroker :: JSHeapBroker ( Isolate * isolate , Zone * zone ) : isolate_ ( isolate ) , zone_ ( zone ) , refs_ ( zone ) , mode_ ( FLAG_concurrent_compiler_frontend ? kSerializing : kDisabled ) { Trace ( "%s" , "Constructing heap broker.\n" ) ; }
ISurfaceAllocator :: AllocSurfaceDescriptor ( const gfx :: IntSize & aSize , gfxContentType aContent , SurfaceDescriptor * aBuffer ) { return AllocSurfaceDescriptorWithCaps ( aSize , aContent , DEFAULT_BUFFER_CAPS , aBuffer ) ; }
* xmlUnicodeLookup ( xmlUnicodeNameTable * tptr , const char * tname ) { int low , high , mid , cmp ; xmlUnicodeRange * sptr ; if ( ( tptr == NULL ) || ( tname == NULL ) ) return ( NULL ) ; low = 0 ; high = tptr -> numentries - 1 ; sptr = tptr -> table ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( ( cmp = strcmp ( tname , sptr [ mid ] . rangename ) ) == 0 ) return ( sptr [ mid ] . func ) ; if ( cmp < 0 ) high = mid - 1 ; else low = mid + 1 ; } return ( NULL ) ; }
void Compute ( OpKernelContext * ctx ) override { const Tensor * inputs ; const Tensor * labels_indices ; const Tensor * labels_values ; const Tensor * seq_len ; OP_REQUIRES_OK ( ctx , ctx -> input ( "inputs" , & inputs ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( "labels_indices" , & labels_indices ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( "labels_values" , & labels_values ) ) ; OP_REQUIRES_OK ( ctx , ctx -> input ( "sequence_length" , & seq_len ) ) ; OP_REQUIRES ( ctx , inputs -> shape ( ) . dims ( ) == 3 , errors :: InvalidArgument ( "inputs is not a 3-Tensor" ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsVector ( seq_len -> shape ( ) ) , errors :: InvalidArgument ( "sequence_length is not a vector" ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsMatrix ( labels_indices -> shape ( ) ) , errors :: InvalidArgument ( "labels_indices is not a matrix" ) ) ; OP_REQUIRES ( ctx , TensorShapeUtils :: IsVector ( labels_values -> shape ( ) ) , errors :: InvalidArgument ( "labels_values is not a vector" ) ) ; const TensorShape & inputs_shape = inputs -> shape ( ) ; const int64 max_time = inputs_shape . dim_size ( 0 ) ; const int64 batch_size = inputs_shape . dim_size ( 1 ) ; const int64 num_classes_raw = inputs_shape . dim_size ( 2 ) ; OP_REQUIRES ( ctx , FastBoundsCheck ( num_classes_raw , std :: numeric_limits < int > :: max ( ) ) , errors :: InvalidArgument ( "num_classes cannot exceed max int" ) ) ; const int num_classes = static_cast < const int > ( num_classes_raw ) ; OP_REQUIRES ( ctx , batch_size == seq_len -> dim_size ( 0 ) , errors :: InvalidArgument ( "len(sequence_length) != batch_size.  " , "len(sequence_length):  " , seq_len -> dim_size ( 0 ) , " batch_size: " , batch_size ) ) ; auto seq_len_t = seq_len -> vec < int32 > ( ) ; OP_REQUIRES ( ctx , labels_indices -> dim_size ( 0 ) == labels_values -> dim_size ( 0 ) , errors :: InvalidArgument ( "labels_indices and labels_values must contain the " "same number of rows, but saw shapes: " , labels_indices -> shape ( ) . DebugString ( ) , " vs. " , labels_values -> shape ( ) . DebugString ( ) ) ) ; OP_REQUIRES ( ctx , batch_size != 0 , errors :: InvalidArgument ( "batch_size must not be 0" ) ) ; auto labels_indices_t = labels_indices -> matrix < int64 > ( ) ; int64 max_label_len = 0 ; for ( int i = 0 ; i < labels_indices -> dim_size ( 0 ) ; i ++ ) { max_label_len = std :: max ( max_label_len , labels_indices_t ( i , 1 ) + 1 ) ; } TensorShape labels_shape ( { batch_size , max_label_len } ) ; std :: vector < int64 > order { 0 , 1 } ; sparse :: SparseTensor labels_sp ; OP_REQUIRES_OK ( ctx , sparse :: SparseTensor :: Create ( * labels_indices , * labels_values , labels_shape , order , & labels_sp ) ) ; Status labels_sp_valid = labels_sp . IndicesValid ( ) ; OP_REQUIRES ( ctx , labels_sp_valid . ok ( ) , errors :: InvalidArgument ( "label SparseTensor is not valid: " , labels_sp_valid . error_message ( ) ) ) ; typename ctc :: CTCLossCalculator < T > :: LabelSequences labels_t ( batch_size ) ; for ( const auto & g : labels_sp . group ( { 0 } ) ) { const int64 batch_indices = g . group ( ) [ 0 ] ; OP_REQUIRES ( ctx , FastBoundsCheck ( batch_indices , batch_size ) , errors :: InvalidArgument ( "labels batch index must be between " , 0 , " and " , batch_size , " but saw: " , batch_indices ) ) ; auto values = g . values < int32 > ( ) ; std :: vector < int > * b_values = & labels_t [ batch_indices ] ; b_values -> resize ( values . size ( ) ) ; for ( int i = 0 ; i < values . size ( ) ; ++ i ) ( * b_values ) [ i ] = values ( i ) ; } OP_REQUIRES ( ctx , static_cast < size_t > ( batch_size ) == labels_t . size ( ) , errors :: InvalidArgument ( "len(labels) != batch_size.  " , "len(labels):  " , labels_t . size ( ) , " batch_size: " , batch_size ) ) ; for ( int64 b = 0 ; b < batch_size ; ++ b ) { OP_REQUIRES ( ctx , seq_len_t ( b ) <= max_time , errors :: InvalidArgument ( "sequence_length(" , b , ") <= " , max_time ) ) ; } Tensor * loss = nullptr ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( "loss" , seq_len -> shape ( ) , & loss ) ) ; auto loss_t = loss -> vec < T > ( ) ; Tensor * gradient ; OP_REQUIRES_OK ( ctx , ctx -> allocate_output ( "gradient" , inputs_shape , & gradient ) ) ; auto gradient_t = gradient -> tensor < T , 3 > ( ) ; auto inputs_t = inputs -> tensor < T , 3 > ( ) ; std :: vector < OutputMap > gradient_list_t ; std :: vector < InputMap > input_list_t ; for ( std :: size_t t = 0 ; t < max_time ; ++ t ) { input_list_t . emplace_back ( inputs_t . data ( ) + t * batch_size * num_classes , batch_size , num_classes ) ; gradient_list_t . emplace_back ( gradient_t . data ( ) + t * batch_size * num_classes , batch_size , num_classes ) ; } gradient_t . setZero ( ) ; ctc :: CTCLossCalculator < T > ctc_loss_calculator ( num_classes - 1 , 0 ) ; DeviceBase :: CpuWorkerThreads workers = * ctx -> device ( ) -> tensorflow_cpu_worker_threads ( ) ; OP_REQUIRES_OK ( ctx , ctc_loss_calculator . CalculateLoss ( seq_len_t , labels_t , input_list_t , preprocess_collapse_repeated_ , ctc_merge_repeated_ , ignore_longer_outputs_than_inputs_ , & loss_t , & gradient_list_t , & workers ) ) ; }
struct lib_t * MACH0_ ( get_libs ) ( struct MACH0_ ( obj_t ) * bin ) { struct lib_t * libs ; int i ; if ( ! bin -> nlibs ) return NULL ; if ( ! ( libs = calloc ( ( bin -> nlibs + 1 ) , sizeof ( struct lib_t ) ) ) ) return NULL ; for ( i = 0 ; i < bin -> nlibs ; i ++ ) { strncpy ( libs [ i ] . name , bin -> libs [ i ] , R_BIN_MACH0_STRING_LENGTH ) ; libs [ i ] . name [ R_BIN_MACH0_STRING_LENGTH - 1 ] = '\0' ; libs [ i ] . last = 0 ; } libs [ i ] . last = 1 ; return libs ; }
void Builtins :: Generate_ArgumentsAdaptorTrampoline ( MacroAssembler * masm ) { Label invoke , dont_adapt_arguments , stack_overflow ; Label enough , too_few ; __ Branch ( & dont_adapt_arguments , eq , a2 , Operand ( SharedFunctionInfo :: kDontAdaptArgumentsSentinel ) ) ; __ Branch ( & too_few , Uless , a0 , Operand ( a2 ) ) ; { __ bind ( & enough ) ; EnterArgumentsAdaptorFrame ( masm ) ; Generate_StackOverflowCheck ( masm , a2 , a5 , kScratchReg , & stack_overflow ) ; __ SmiScale ( a0 , a0 , kPointerSizeLog2 ) ; __ Daddu ( a0 , fp , a0 ) ; __ Daddu ( a0 , a0 , Operand ( 2 * kPointerSize ) ) ; __ dsll ( a4 , a2 , kPointerSizeLog2 ) ; __ dsubu ( a4 , a0 , a4 ) ; Label copy ; __ bind ( & copy ) ; __ Ld ( a5 , MemOperand ( a0 ) ) ; __ push ( a5 ) ; __ Branch ( USE_DELAY_SLOT , & copy , ne , a0 , Operand ( a4 ) ) ; __ daddiu ( a0 , a0 , - kPointerSize ) ; __ jmp ( & invoke ) ; } { __ bind ( & too_few ) ; EnterArgumentsAdaptorFrame ( masm ) ; Generate_StackOverflowCheck ( masm , a2 , a5 , kScratchReg , & stack_overflow ) ; __ SmiScale ( a0 , a0 , kPointerSizeLog2 ) ; __ Daddu ( a0 , fp , a0 ) ; __ Daddu ( a0 , a0 , Operand ( 2 * kPointerSize ) ) ; __ Daddu ( a7 , fp , kPointerSize ) ; Label copy ; __ bind ( & copy ) ; __ Ld ( a4 , MemOperand ( a0 ) ) ; __ Dsubu ( sp , sp , kPointerSize ) ; __ Dsubu ( a0 , a0 , kPointerSize ) ; __ Branch ( USE_DELAY_SLOT , & copy , ne , a0 , Operand ( a7 ) ) ; __ Sd ( a4 , MemOperand ( sp ) ) ; __ LoadRoot ( a5 , Heap :: kUndefinedValueRootIndex ) ; __ dsll ( a6 , a2 , kPointerSizeLog2 ) ; __ Dsubu ( a4 , fp , Operand ( a6 ) ) ; __ Dsubu ( a4 , a4 , Operand ( ArgumentsAdaptorFrameConstants :: kFixedFrameSizeFromFp + kPointerSize ) ) ; Label fill ; __ bind ( & fill ) ; __ Dsubu ( sp , sp , kPointerSize ) ; __ Branch ( USE_DELAY_SLOT , & fill , ne , sp , Operand ( a4 ) ) ; __ Sd ( a5 , MemOperand ( sp ) ) ; } __ bind ( & invoke ) ; __ mov ( a0 , a2 ) ; static_assert ( kJavaScriptCallCodeStartRegister == a2 , "ABI mismatch" ) ; __ Ld ( a2 , FieldMemOperand ( a1 , JSFunction :: kCodeOffset ) ) ; __ Daddu ( a2 , a2 , Operand ( Code :: kHeaderSize - kHeapObjectTag ) ) ; __ Call ( a2 ) ; masm -> isolate ( ) -> heap ( ) -> SetArgumentsAdaptorDeoptPCOffset ( masm -> pc_offset ( ) ) ; LeaveArgumentsAdaptorFrame ( masm ) ; __ Ret ( ) ; __ bind ( & dont_adapt_arguments ) ; static_assert ( kJavaScriptCallCodeStartRegister == a2 , "ABI mismatch" ) ; __ Ld ( a2 , FieldMemOperand ( a1 , JSFunction :: kCodeOffset ) ) ; __ Daddu ( a2 , a2 , Operand ( Code :: kHeaderSize - kHeapObjectTag ) ) ; __ Jump ( a2 ) ; __ bind ( & stack_overflow ) ; { FrameScope frame ( masm , StackFrame :: MANUAL ) ; __ CallRuntime ( Runtime :: kThrowStackOverflow ) ; __ break_ ( 0xCC ) ; } }
nsSHistory :: InitiateLoad ( nsISHEntry * aFrameEntry , nsIDocShell * aFrameDS , long aLoadType ) { NS_ENSURE_STATE ( aFrameDS && aFrameEntry ) ; nsCOMPtr < nsIDocShellLoadInfo > loadInfo ; aFrameEntry -> SetLoadType ( aLoadType ) ; aFrameDS -> CreateLoadInfo ( getter_AddRefs ( loadInfo ) ) ; loadInfo -> SetLoadType ( aLoadType ) ; loadInfo -> SetSHEntry ( aFrameEntry ) ; nsCOMPtr < nsIURI > nextURI ; aFrameEntry -> GetURI ( getter_AddRefs ( nextURI ) ) ; return aFrameDS -> LoadURI ( nextURI , loadInfo , nsIWebNavigation :: LOAD_FLAGS_NONE , false ) ; }
spnego_gss_wrap_aead ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int conf_req_flag , gss_qop_t qop_req , gss_buffer_t input_assoc_buffer , gss_buffer_t input_payload_buffer , int * conf_state , gss_buffer_t output_message_buffer ) { OM_uint32 ret ; ret = gss_wrap_aead ( minor_status , context_handle , conf_req_flag , qop_req , input_assoc_buffer , input_payload_buffer , conf_state , output_message_buffer ) ; return ( ret ) ; }
JSRuntime :: JSRuntime ( JSRuntime * parentRuntime ) : mainThread ( this ) , jitTop ( nullptr ) , jitActivation ( nullptr ) , jitStackLimit_ ( 0xbad ) , jitStackLimitNoInterrupt_ ( 0xbad ) , #ifdef DEBUG ionBailAfter_ ( 0 ) , #endif activation_ ( nullptr ) , profilingActivation_ ( nullptr ) , profilerSampleBufferGen_ ( 0 ) , profilerSampleBufferLapCount_ ( 1 ) , wasmActivationStack_ ( nullptr ) , asyncStackForNewActivations ( this ) , asyncCauseForNewActivations ( nullptr ) , asyncCallIsExplicit ( false ) , entryMonitor ( nullptr ) , noExecuteDebuggerTop ( nullptr ) , parentRuntime ( parentRuntime ) , #ifdef DEBUG updateChildRuntimeCount ( parentRuntime ) , #endif interrupt_ ( false ) , telemetryCallback ( nullptr ) , handlingSegFault ( false ) , handlingJitInterrupt_ ( false ) , interruptCallback ( nullptr ) , getIncumbentGlobalCallback ( nullptr ) , enqueuePromiseJobCallback ( nullptr ) , enqueuePromiseJobCallbackData ( nullptr ) , promiseRejectionTrackerCallback ( nullptr ) , promiseRejectionTrackerCallbackData ( nullptr ) , #ifdef DEBUG exclusiveAccessOwner ( nullptr ) , mainThreadHasExclusiveAccess ( false ) , #endif numExclusiveThreads ( 0 ) , numCompartments ( 0 ) , localeCallbacks ( nullptr ) , defaultLocale ( nullptr ) , defaultVersion_ ( JSVERSION_DEFAULT ) , ownerThread_ ( nullptr ) , ownerThreadNative_ ( 0 ) , tempLifoAlloc ( TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE ) , jitRuntime_ ( nullptr ) , selfHostingGlobal_ ( nullptr ) , nativeStackBase ( GetNativeStackBase ( ) ) , destroyCompartmentCallback ( nullptr ) , sizeOfIncludingThisCompartmentCallback ( nullptr ) , destroyZoneCallback ( nullptr ) , sweepZoneCallback ( nullptr ) , compartmentNameCallback ( nullptr ) , activityCallback ( nullptr ) , activityCallbackArg ( nullptr ) , requestDepth ( 0 ) , #ifdef DEBUG checkRequestDepth ( 0 ) , #endif gc ( thisFromCtor ( ) ) , gcInitialized ( false ) , #ifdef JS_SIMULATOR simulator_ ( nullptr ) , #endif scriptAndCountsVector ( nullptr ) , lcovOutput ( ) , NaNValue ( DoubleNaNValue ( ) ) , negativeInfinityValue ( DoubleValue ( NegativeInfinity < double > ( ) ) ) , positiveInfinityValue ( DoubleValue ( PositiveInfinity < double > ( ) ) ) , emptyString ( nullptr ) , spsProfiler ( thisFromCtor ( ) ) , profilingScripts ( false ) , suppressProfilerSampling ( false ) , hadOutOfMemory ( false ) , #ifdef DEBUG handlingInitFailure ( false ) , #endif #if defined(DEBUG) || defined(JS_OOM_BREAKPOINT) runningOOMTest ( false ) , #endif allowRelazificationForTesting ( false ) , defaultFreeOp_ ( thisFromCtor ( ) ) , debuggerMutations ( 0 ) , securityCallbacks ( & NullSecurityCallbacks ) , DOMcallbacks ( nullptr ) , destroyPrincipals ( nullptr ) , readPrincipals ( nullptr ) , warningReporter ( nullptr ) , buildIdOp ( nullptr ) , propertyRemovals ( 0 ) , #if !EXPOSE_INTL_API thousandsSeparator ( 0 ) , decimalSeparator ( 0 ) , numGrouping ( 0 ) , #endif activeCompilations_ ( 0 ) , keepAtoms_ ( 0 ) , trustedPrincipals_ ( nullptr ) , beingDestroyed_ ( false ) , atoms_ ( nullptr ) , atomsCompartment_ ( nullptr ) , staticStrings ( nullptr ) , commonNames ( nullptr ) , permanentAtoms ( nullptr ) , wellKnownSymbols ( nullptr ) , wrapObjectCallbacks ( & DefaultWrapObjectCallbacks ) , preserveWrapperCallback ( nullptr ) , jitSupportsFloatingPoint ( false ) , jitSupportsUnalignedAccesses ( false ) , jitSupportsSimd ( false ) , ionPcScriptCache ( nullptr ) , scriptEnvironmentPreparer ( nullptr ) , ctypesActivityCallback ( nullptr ) , windowProxyClass_ ( nullptr ) , offthreadIonCompilationEnabled_ ( true ) , parallelParsingEnabled_ ( true ) , autoWritableJitCodeActive_ ( false ) , #ifdef DEBUG enteredPolicy ( nullptr ) , #endif largeAllocationFailureCallback ( nullptr ) , oomCallback ( nullptr ) , debuggerMallocSizeOf ( ReturnZeroSize ) , lastAnimationTime ( 0 ) , performanceMonitoring ( thisFromCtor ( ) ) , ionLazyLinkListSize_ ( 0 ) { setGCStoreBufferPtr ( & gc . storeBuffer ) ; liveRuntimesCount ++ ; JS_INIT_CLIST ( & onNewGlobalObjectWatchers ) ; PodArrayZero ( nativeStackQuota ) ; PodZero ( & asmJSCacheOps ) ; lcovOutput . init ( ) ; }
static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; defaultoptions ( & h ) ; lua_settop ( L , 2 ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; luaL_argcheck ( L , pos + size <= ld , 2 , "data string too short" ) ; luaL_checkstack ( L , 1 , "too many results" ) ; switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; lua_pushnumber ( L , res ) ; break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; lua_pushnumber ( L , f ) ; break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; lua_pushnumber ( L , d ) ; break ; } case 'c' : { if ( size == 0 ) { if ( ! lua_isnumber ( L , - 1 ) ) luaL_error ( L , "format `c0' needs a previous size" ) ; size = lua_tonumber ( L , - 1 ) ; lua_pop ( L , 1 ) ; luaL_argcheck ( L , pos + size <= ld , 2 , "data string too short" ) ; } lua_pushlstring ( L , data + pos , size ) ; break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , "unfinished string in data" ) ; size = ( e - ( data + pos ) ) + 1 ; lua_pushlstring ( L , data + pos , size - 1 ) ; break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; return lua_gettop ( L ) - 2 ; }
static void ConvertLoopSlice ( ModSample & src , ModSample & dest , SmpLength start , SmpLength len , bool loop ) { if ( ! src . HasSampleData ( ) ) return ; dest . FreeSample ( ) ; dest = src ; dest . nLength = len ; dest . pSample = nullptr ; if ( ! dest . AllocateSample ( ) ) { return ; } if ( len != src . nLength ) MemsetZero ( dest . cues ) ; std :: memcpy ( dest . pSample8 , src . pSample8 + start , len ) ; dest . uFlags . set ( CHN_LOOP , loop ) ; if ( loop ) { dest . nLoopStart = 0 ; dest . nLoopEnd = len ; } else { dest . nLoopStart = 0 ; dest . nLoopEnd = 0 ; } }
v8 :: Local < v8 :: Object > FXJS_NewFxDynamicObj ( v8 :: Isolate * pIsolate , IFXJS_Context * pJSContext , int nObjDefnID ) { v8 :: Isolate :: Scope isolate_scope ( pIsolate ) ; v8 :: Local < v8 :: Context > context = pIsolate -> GetCurrentContext ( ) ; if ( nObjDefnID == - 1 ) { v8 :: Local < v8 :: ObjectTemplate > objTempl = v8 :: ObjectTemplate :: New ( pIsolate ) ; v8 :: Local < v8 :: Object > obj ; if ( ! objTempl -> NewInstance ( context ) . ToLocal ( & obj ) ) return v8 :: Local < v8 :: Object > ( ) ; return obj ; } FXJS_PerIsolateData * pData = FXJS_PerIsolateData :: Get ( pIsolate ) ; if ( ! pData ) return v8 :: Local < v8 :: Object > ( ) ; if ( nObjDefnID < 0 || nObjDefnID >= CFXJS_ObjDefinition :: MaxID ( pIsolate ) ) return v8 :: Local < v8 :: Object > ( ) ; CFXJS_ObjDefinition * pObjDef = CFXJS_ObjDefinition :: ForID ( pIsolate , nObjDefnID ) ; v8 :: Local < v8 :: Object > obj ; if ( ! pObjDef -> GetInstanceTemplate ( ) -> NewInstance ( context ) . ToLocal ( & obj ) ) return v8 :: Local < v8 :: Object > ( ) ; obj -> SetAlignedPointerInInternalField ( 0 , new CFXJS_PrivateData ( nObjDefnID ) ) ; if ( pObjDef -> m_pConstructor ) pObjDef -> m_pConstructor ( pJSContext , obj , context -> Global ( ) -> GetPrototype ( ) -> ToObject ( context ) . ToLocalChecked ( ) ) ; return obj ; }
bool M3UParser :: getTypeURI ( size_t index , const char * key , AString * uri ) const { if ( ! mIsVariantPlaylist ) { if ( uri != NULL ) { * uri = mBaseURI ; } return ! strcmp ( "audio" , key ) || ! strcmp ( "video" , key ) ; } CHECK_LT ( index , mItems . size ( ) ) ; sp < AMessage > meta = mItems . itemAt ( index ) . mMeta ; AString groupID ; if ( ! meta -> findString ( key , & groupID ) ) { if ( uri != NULL ) { * uri = mItems . itemAt ( index ) . mURI ; } AString codecs ; if ( ! meta -> findString ( "codecs" , & codecs ) ) { return ! strcmp ( "audio" , key ) || ! strcmp ( "video" , key ) ; } else { size_t offset = 0 ; ssize_t commaPos = - 1 ; codecs . append ( ',' ) ; while ( ( commaPos = codecs . find ( "," , offset ) ) >= 0 ) { AString codec ( codecs , offset , commaPos - offset ) ; codec . trim ( ) ; if ( codecIsType ( codec , key ) ) { return true ; } offset = commaPos + 1 ; } return false ; } } if ( uri != NULL ) { sp < MediaGroup > group = mMediaGroups . valueFor ( groupID ) ; if ( ! group -> getActiveURI ( uri ) ) { return false ; } if ( ( * uri ) . empty ( ) ) { * uri = mItems . itemAt ( index ) . mURI ; } } return true ; }
nsCSSFrameConstructor :: LazyGenerateChildrenEvent :: Run ( ) { mPresShell -> GetDocument ( ) -> FlushPendingNotifications ( Flush_Layout ) ; nsIFrame * frame = mPresShell -> GetPrimaryFrameFor ( mContent ) ; if ( frame && frame -> GetType ( ) == nsGkAtoms :: menuPopupFrame ) { #ifdef MOZ_XUL nsMenuPopupFrame * menuPopupFrame = static_cast < nsMenuPopupFrame * > ( frame ) ; if ( menuPopupFrame -> HasGeneratedChildren ( ) ) { if ( mCallback ) mCallback ( mContent , frame , mArg ) ; return NS_OK ; } menuPopupFrame -> SetGeneratedChildren ( ) ; #endif { nsAutoScriptBlocker scriptBlocker ; nsCSSFrameConstructor * fc = mPresShell -> FrameConstructor ( ) ; fc -> BeginUpdate ( ) ; nsFrameItems childItems ; nsFrameConstructorState state ( mPresShell , nsnull , nsnull , nsnull ) ; nsresult rv = fc -> ProcessChildren ( state , mContent , frame -> GetStyleContext ( ) , frame , PR_FALSE , childItems , PR_FALSE ) ; if ( NS_FAILED ( rv ) ) return rv ; frame -> SetInitialChildList ( nsnull , childItems . childList ) ; fc -> EndUpdate ( ) ; } if ( mCallback ) mCallback ( mContent , frame , mArg ) ; mPresShell -> GetDocument ( ) -> BindingManager ( ) -> ProcessAttachedQueue ( ) ; } return NS_OK ; }
void nsThread :: ThreadFunc ( void * aArg ) { using mozilla :: ipc :: BackgroundChild ; UniquePtr < ThreadInitData > initData ( static_cast < ThreadInitData * > ( aArg ) ) ; nsThread * self = initData -> thread ; MOZ_ASSERT ( self -> mEventTarget ) ; MOZ_ASSERT ( self -> mEvents ) ; DebugOnly < PRThread * > prev = self -> mThread . exchange ( PR_GetCurrentThread ( ) ) ; MOZ_ASSERT ( ! prev || prev == PR_GetCurrentThread ( ) ) ; self -> mEventTarget -> SetCurrentThread ( self -> mThread ) ; SetupCurrentThreadForChaosMode ( ) ; if ( ! initData -> name . IsEmpty ( ) ) { NS_SetCurrentThreadName ( initData -> name . BeginReading ( ) ) ; } self -> InitCommon ( ) ; nsThreadManager :: get ( ) . RegisterCurrentThread ( * self ) ; mozilla :: IOInterposer :: RegisterCurrentThread ( ) ; const bool registerWithProfiler = ! initData -> name . IsEmpty ( ) ; if ( registerWithProfiler ) { PROFILER_REGISTER_THREAD ( initData -> name . BeginReading ( ) ) ; } { MessageLoop loop ( MessageLoop :: TYPE_MOZILLA_NONMAINTHREAD , self ) ; loop . Run ( ) ; BackgroundChild :: CloseForCurrentThread ( ) ; while ( true ) { self -> WaitForAllAsynchronousShutdowns ( ) ; if ( self -> mEvents -> ShutdownIfNoPendingEvents ( ) ) { break ; } NS_ProcessPendingEvents ( self ) ; } } mozilla :: IOInterposer :: UnregisterCurrentThread ( ) ; nsThreadManager :: get ( ) . UnregisterCurrentThread ( * self ) ; if ( registerWithProfiler ) { PROFILER_UNREGISTER_THREAD ( ) ; } NotNull < nsThreadShutdownContext * > context = WrapNotNull ( self -> mShutdownContext ) ; MOZ_ASSERT ( context -> mTerminatingThread == self ) ; nsCOMPtr < nsIRunnable > event = do_QueryObject ( new nsThreadShutdownAckEvent ( context ) ) ; if ( context -> mIsMainThreadJoining ) { DebugOnly < nsresult > dispatch_ack_rv = SchedulerGroup :: Dispatch ( TaskCategory :: Other , event . forget ( ) ) ; #ifdef DEBUG if ( NS_FAILED ( dispatch_ack_rv ) ) { NS_WARNING ( "Thread shudown ack dispatch failed, the main thread may no longer " "be waiting." ) ; } #endif } else { nsresult dispatch_ack_rv = context -> mJoiningThread -> Dispatch ( event , NS_DISPATCH_NORMAL ) ; MOZ_RELEASE_ASSERT ( NS_SUCCEEDED ( dispatch_ack_rv ) ) ; } self -> SetObserver ( nullptr ) ; self -> mThread = nullptr ; self -> mEventTarget -> ClearCurrentThread ( ) ; NS_RELEASE ( self ) ; }
void SimdScalarLowering :: LowerPack ( Node * node , SimdType input_rep_type , SimdType output_rep_type , bool is_signed ) { DCHECK_EQ ( 2 , node -> InputCount ( ) ) ; Node * * rep_left = GetReplacementsWithType ( node -> InputAt ( 0 ) , input_rep_type ) ; Node * * rep_right = GetReplacementsWithType ( node -> InputAt ( 1 ) , input_rep_type ) ; const Operator * less_op = is_signed ? machine ( ) -> Int32LessThan ( ) : machine ( ) -> Uint32LessThan ( ) ; Node * min = nullptr ; Node * max = nullptr ; int32_t shift_val = 0 ; MachineRepresentation phi_rep ; if ( output_rep_type == SimdType :: kInt16x8 ) { DCHECK ( input_rep_type == SimdType :: kInt32x4 ) ; if ( is_signed ) { min = mcgraph_ -> Int32Constant ( std :: numeric_limits < int16_t > :: min ( ) ) ; max = mcgraph_ -> Int32Constant ( std :: numeric_limits < int16_t > :: max ( ) ) ; } else { max = mcgraph_ -> Uint32Constant ( std :: numeric_limits < uint16_t > :: max ( ) ) ; shift_val = kShift16 ; } phi_rep = MachineRepresentation :: kWord16 ; } else { DCHECK ( output_rep_type == SimdType :: kInt8x16 && input_rep_type == SimdType :: kInt16x8 ) ; if ( is_signed ) { min = mcgraph_ -> Int32Constant ( std :: numeric_limits < int8_t > :: min ( ) ) ; max = mcgraph_ -> Int32Constant ( std :: numeric_limits < int8_t > :: max ( ) ) ; } else { max = mcgraph_ -> Uint32Constant ( std :: numeric_limits < uint8_t > :: max ( ) ) ; shift_val = kShift8 ; } phi_rep = MachineRepresentation :: kWord8 ; } int num_lanes = NumLanes ( output_rep_type ) ; Node * * rep_node = zone ( ) -> NewArray < Node * > ( num_lanes ) ; for ( int i = 0 ; i < num_lanes ; ++ i ) { Node * input = nullptr ; if ( i < num_lanes / 2 ) input = rep_left [ i ] ; else input = rep_right [ i - num_lanes / 2 ] ; if ( is_signed ) { Diamond d_min ( graph ( ) , common ( ) , graph ( ) -> NewNode ( less_op , input , min ) ) ; input = d_min . Phi ( phi_rep , min , input ) ; } Diamond d_max ( graph ( ) , common ( ) , graph ( ) -> NewNode ( less_op , max , input ) ) ; rep_node [ i ] = d_max . Phi ( phi_rep , max , input ) ; rep_node [ i ] = is_signed ? rep_node [ i ] : FixUpperBits ( rep_node [ i ] , shift_val ) ; } ReplaceNode ( node , rep_node , num_lanes ) ; }
png_app_warning ( png_const_structrp png_ptr , png_const_charp error_message ) { if ( png_ptr -> flags & PNG_FLAG_APP_WARNINGS_WARN ) png_warning ( png_ptr , error_message ) ; else png_error ( png_ptr , error_message ) ; #  ifndef PNG_ERROR_TEXT_SUPPORTED PNG_UNUSED ( error_message ) #  endif }
base :: Optional < ParseResult > MakeCall ( ParseResultIterator * child_results ) { auto callee = child_results -> NextAs < std :: string > ( ) ; auto generic_args = child_results -> NextAs < TypeList > ( ) ; auto args = child_results -> NextAs < std :: vector < Expression * > > ( ) ; auto labels = child_results -> NextAs < std :: vector < std :: string > > ( ) ; Expression * result = MakeNode < CallExpression > ( callee , false , generic_args , args , labels ) ; return ParseResult { result } ; }
int m_authenticate ( struct Client * cptr , struct Client * sptr , int parc , char * parv [ ] ) { struct Client * acptr ; int first = 0 ; char realhost [ HOSTLEN + 3 ] ; char * hoststr = ( cli_sockhost ( cptr ) ? cli_sockhost ( cptr ) : cli_sock_ip ( cptr ) ) ; if ( ! CapActive ( cptr , CAP_SASL ) ) return 0 ; if ( parc < 2 ) return need_more_params ( cptr , "AUTHENTICATE" ) ; if ( strlen ( parv [ 1 ] ) > 400 ) return send_reply ( cptr , ERR_SASLTOOLONG ) ; if ( IsSASLComplete ( cptr ) ) return send_reply ( cptr , ERR_SASLALREADY ) ; if ( ! ( acptr = cli_saslagent ( cptr ) ) ) { if ( strcmp ( feature_str ( FEAT_SASL_SERVER ) , "*" ) ) acptr = find_match_server ( ( char * ) feature_str ( FEAT_SASL_SERVER ) ) ; else acptr = NULL ; } if ( ! acptr && strcmp ( feature_str ( FEAT_SASL_SERVER ) , "*" ) ) return send_reply ( cptr , ERR_SASLFAIL , ": service unavailable" ) ; if ( acptr && IsMe ( acptr ) ) return 0 ; if ( ! cli_saslcookie ( cptr ) ) { do { cli_saslcookie ( cptr ) = ircrandom ( ) & 0x7fffffff ; } while ( ! cli_saslcookie ( cptr ) ) ; first = 1 ; } if ( strchr ( hoststr , ':' ) != NULL ) ircd_snprintf ( 0 , realhost , sizeof ( realhost ) , "[%s]" , hoststr ) ; else ircd_strncpy ( realhost , hoststr , sizeof ( realhost ) ) ; if ( acptr ) { if ( first ) { if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_one ( & me , CMD_SASL , acptr , "%C %C!%u.%u S %s :%s" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_one ( & me , CMD_SASL , acptr , "%C %C!%u.%u S :%s" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_one ( & me , CMD_SASL , acptr , "%C %C!%u.%u H :%s@%s:%s" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_one ( & me , CMD_SASL , acptr , "%C %C!%u.%u C :%s" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } else { if ( first ) { if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , "* %C!%u.%u S %s :%s" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_serv_butone ( & me , CMD_SASL , cptr , "* %C!%u.%u S :%s" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , "* %C!%u.%u H :%s@%s:%s" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_serv_butone ( & me , CMD_SASL , cptr , "* %C!%u.%u C :%s" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } if ( ! t_active ( & cli_sasltimeout ( cptr ) ) ) timer_add ( timer_init ( & cli_sasltimeout ( cptr ) ) , sasl_timeout_callback , ( void * ) cptr , TT_RELATIVE , feature_int ( FEAT_SASL_TIMEOUT ) ) ; return 0 ; }
int RegExpMacroAssembler :: CaseInsensitiveCompareUC16 ( Address byte_offset1 , Address byte_offset2 , size_t byte_length , Isolate * isolate ) { unibrow :: Mapping < unibrow :: Ecma262Canonicalize > * canonicalize = isolate -> regexp_macro_assembler_canonicalize ( ) ; DCHECK_EQ ( 0 , byte_length % 2 ) ; uc16 * substring1 = reinterpret_cast < uc16 * > ( byte_offset1 ) ; uc16 * substring2 = reinterpret_cast < uc16 * > ( byte_offset2 ) ; size_t length = byte_length > > 1 ; #ifdef V8_INTL_SUPPORT if ( isolate == nullptr ) { for ( size_t i = 0 ; i < length ; i ++ ) { uc32 c1 = substring1 [ i ] ; uc32 c2 = substring2 [ i ] ; if ( unibrow :: Utf16 :: IsLeadSurrogate ( c1 ) ) { if ( ! unibrow :: Utf16 :: IsLeadSurrogate ( c2 ) ) return 0 ; if ( i + 1 < length ) { uc16 c1t = substring1 [ i + 1 ] ; uc16 c2t = substring2 [ i + 1 ] ; if ( unibrow :: Utf16 :: IsTrailSurrogate ( c1t ) && unibrow :: Utf16 :: IsTrailSurrogate ( c2t ) ) { c1 = unibrow :: Utf16 :: CombineSurrogatePair ( c1 , c1t ) ; c2 = unibrow :: Utf16 :: CombineSurrogatePair ( c2 , c2t ) ; i ++ ; } } } c1 = u_foldCase ( c1 , U_FOLD_CASE_DEFAULT ) ; c2 = u_foldCase ( c2 , U_FOLD_CASE_DEFAULT ) ; if ( c1 != c2 ) return 0 ; } return 1 ; } #endif // V8_INTL_SUPPORT DCHECK_NOT_NULL ( isolate ) ; for ( size_t i = 0 ; i < length ; i ++ ) { unibrow :: uchar c1 = substring1 [ i ] ; unibrow :: uchar c2 = substring2 [ i ] ; if ( c1 != c2 ) { unibrow :: uchar s1 [ 1 ] = { c1 } ; canonicalize -> get ( c1 , '\0' , s1 ) ; if ( s1 [ 0 ] != c2 ) { unibrow :: uchar s2 [ 1 ] = { c2 } ; canonicalize -> get ( c2 , '\0' , s2 ) ; if ( s1 [ 0 ] != s2 [ 0 ] ) { return 0 ; } } } } return 1 ; }
static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; unsigned int copied , rlen ; struct sk_buff * skb , * cskb ; int err = 0 ; pr_debug ( "%p %zu\n" , sk , len ) ; lock_sock ( sk ) ; if ( sk -> sk_state == LLCP_CLOSED && skb_queue_empty ( & sk -> sk_receive_queue ) ) { release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { pr_err ( "Recv datagram failed state %d %d %d" , sk -> sk_state , err , sock_error ( sk ) ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } sock_recv_timestamp ( msg , sk , skb ) ; if ( sk -> sk_type == SOCK_DGRAM && msg -> msg_name ) { struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; struct sockaddr_nfc_llcp * sockaddr = ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; pr_debug ( "Datagram socket %d %d\n" , ui_cb -> dsap , ui_cb -> ssap ) ; sockaddr -> sa_family = AF_NFC ; sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ; sockaddr -> dsap = ui_cb -> dsap ; sockaddr -> ssap = ui_cb -> ssap ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
long arch_ptrace ( struct task_struct * child , long request , unsigned long addr , unsigned long data ) { int ret ; unsigned long __user * datap = ( unsigned long __user * ) data ; switch ( request ) { case PTRACE_PEEKUSR : ret = ptrace_read_user ( child , addr , datap ) ; break ; case PTRACE_POKEUSR : ret = ptrace_write_user ( child , addr , data ) ; break ; case PTRACE_GETREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_SETREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_GETFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; case PTRACE_SETFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; #ifdef CONFIG_IWMMXT case PTRACE_GETWMMXREGS : ret = ptrace_getwmmxregs ( child , datap ) ; break ; case PTRACE_SETWMMXREGS : ret = ptrace_setwmmxregs ( child , datap ) ; break ; #endif case PTRACE_GET_THREAD_AREA : ret = put_user ( task_thread_info ( child ) -> tp_value , datap ) ; break ; case PTRACE_SET_SYSCALL : task_thread_info ( child ) -> syscall = data ; ret = 0 ; break ; #ifdef CONFIG_CRUNCH case PTRACE_GETCRUNCHREGS : ret = ptrace_getcrunchregs ( child , datap ) ; break ; case PTRACE_SETCRUNCHREGS : ret = ptrace_setcrunchregs ( child , datap ) ; break ; #endif #ifdef CONFIG_VFP case PTRACE_GETVFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; case PTRACE_SETVFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; #endif #ifdef CONFIG_HAVE_HW_BREAKPOINT case PTRACE_GETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_gethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; case PTRACE_SETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_sethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; #endif default : ret = ptrace_request ( child , request , addr , data ) ; break ; } return ret ; }
static OPJ_BOOL opj_jp2_read_jp ( opj_jp2_t * jp2 , OPJ_BYTE * p_header_data , OPJ_UINT32 p_header_size , opj_event_mgr_t * p_manager ) { OPJ_UINT32 l_magic_number ; assert ( p_header_data != 00 ) ; assert ( jp2 != 00 ) ; assert ( p_manager != 00 ) ; if ( jp2 -> jp2_state != JP2_STATE_NONE ) { opj_event_msg ( p_manager , EVT_ERROR , "The signature box must be the first box in the file.\n" ) ; return OPJ_FALSE ; } if ( p_header_size != 4 ) { opj_event_msg ( p_manager , EVT_ERROR , "Error with JP signature Box size\n" ) ; return OPJ_FALSE ; } opj_read_bytes ( p_header_data , & l_magic_number , 4 ) ; if ( l_magic_number != 0x0d0a870a ) { opj_event_msg ( p_manager , EVT_ERROR , "Error with JP Signature : bad magic number\n" ) ; return OPJ_FALSE ; } jp2 -> jp2_state |= JP2_STATE_SIGNATURE ; return OPJ_TRUE ; }
static s32 gf_media_vvc_read_pps_bs_internal ( GF_BitStream * bs , VVCState * vvc ) { u32 i ; s32 pps_id ; VVC_PPS * pps ; pps_id = gf_bs_read_int_log ( bs , 6 , "pps_id" ) ; if ( ( pps_id < 0 ) || ( pps_id >= 64 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( "[VVC] wrong PPS ID %d in PPS\n" , pps_id ) ) ; return - 1 ; } pps = & vvc -> pps [ pps_id ] ; if ( ! pps -> state ) { pps -> id = pps_id ; pps -> state = 1 ; } pps -> sps_id = gf_bs_read_int_log ( bs , 4 , "sps_id" ) ; if ( pps -> sps_id >= 16 ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( "[VVC] wrong SPS ID %d in PPS\n" , pps -> sps_id ) ) ; pps -> sps_id = 0 ; return - 1 ; } vvc -> sps_active_idx = pps -> sps_id ; pps -> mixed_nal_types = gf_bs_read_int_log ( bs , 1 , "mixed_nal_types" ) ; pps -> width = gf_bs_read_ue_log ( bs , "width" ) ; pps -> height = gf_bs_read_ue_log ( bs , "height" ) ; pps -> conf_window = gf_bs_read_int_log ( bs , 1 , "conformance_window_flag" ) ; if ( pps -> conf_window ) { pps -> cw_left = gf_bs_read_ue_log ( bs , "conf_win_left_offset" ) ; pps -> cw_right = gf_bs_read_ue_log ( bs , "conf_win_right_offset" ) ; pps -> cw_top = gf_bs_read_ue_log ( bs , "conf_win_top_offset" ) ; pps -> cw_bottom = gf_bs_read_ue_log ( bs , "conf_win_bottom_offset" ) ; } if ( gf_bs_read_int_log ( bs , 1 , "scaling_window_explicit_signalling_flag" ) ) { gf_bs_read_se_log ( bs , "scaling_win_left_offset" ) ; gf_bs_read_se_log ( bs , "scaling_win_right_offset" ) ; gf_bs_read_se_log ( bs , "scaling_win_top_offset" ) ; gf_bs_read_se_log ( bs , "scaling_win_bottom_offset" ) ; } pps -> output_flag_present_flag = gf_bs_read_int_log ( bs , 1 , "output_flag_present_flag" ) ; pps -> no_pic_partition_flag = gf_bs_read_int_log ( bs , 1 , "no_pic_partition_flag" ) ; pps -> subpic_id_mapping_present_flag = gf_bs_read_int_log ( bs , 1 , "subpic_id_mapping_present_flag" ) ; if ( pps -> subpic_id_mapping_present_flag ) { u32 pps_subpic_id_len , pps_num_subpics = 0 ; if ( ! pps -> no_pic_partition_flag ) { pps_num_subpics = 1 + gf_bs_read_ue_log ( bs , "pps_num_subpics_minus1" ) ; } pps_subpic_id_len = 1 + gf_bs_read_ue ( bs ) ; for ( i = 0 ; i < pps_num_subpics ; i ++ ) { gf_bs_read_int_log_idx ( bs , pps_subpic_id_len , "subpic_id" , i ) ; } } if ( ! pps -> no_pic_partition_flag ) { gf_bs_read_int_log ( bs , 2 , "pps_log2_ctu_size_minus5" ) ; u32 num_exp_tile_columns = 1 + gf_bs_read_ue_log ( bs , "num_exp_tile_columns_minus1" ) ; u32 num_exp_tile_rows = 1 + gf_bs_read_ue_log ( bs , "num_exp_tile_rows_minus1" ) ; for ( i = 0 ; i < num_exp_tile_columns ; i ++ ) gf_bs_read_ue_log_idx ( bs , "tile_column_width_minus1" , i ) ; for ( i = 0 ; i < num_exp_tile_rows ; i ++ ) gf_bs_read_ue_log_idx ( bs , "tile_row_height_minus1" , i ) ; return pps_id ; } return pps_id ; }
void snd_msndmidi_input_read ( void * mpuv ) { unsigned long flags ; struct snd_msndmidi * mpu = mpuv ; void * pwMIDQData = mpu -> dev -> mappedbase + MIDQ_DATA_BUFF ; spin_lock_irqsave ( & mpu -> input_lock , flags ) ; while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) != readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) { u16 wTmp , val ; val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ; wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ; if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ; else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ; } spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ; }
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
TEST_F ( SvcTest , InitTwoLayers ) { svc_ . spatial_layers = 2 ; vpx_svc_set_scale_factors ( & svc_ , "4/16,16*16" ) ; vpx_codec_err_t res = vpx_svc_init ( & svc_ , & codec_ , codec_iface_ , & codec_enc_ ) ; EXPECT_EQ ( VPX_CODEC_INVALID_PARAM , res ) ; vpx_svc_set_scale_factors ( & svc_ , "4/16,16/16" ) ; res = vpx_svc_init ( & svc_ , & codec_ , codec_iface_ , & codec_enc_ ) ; EXPECT_EQ ( VPX_CODEC_OK , res ) ; codec_initialized_ = true ; }
QPDFObjectHandle :: parse ( PointerHolder < InputSource > input , std :: string const & object_description , QPDFTokenizer & tokenizer , bool & empty , StringDecrypter * decrypter , QPDF * context ) { return parseInternal ( input , object_description , tokenizer , empty , decrypter , context , false , false , false ) ; }
Token :: Value Scanner :: ScanString ( ) { uc32 quote = c0_ ; Advance ( ) ; LiteralScope literal ( this ) ; while ( true ) { if ( c0_ == quote ) { literal . Complete ( ) ; Advance ( ) ; return Token :: STRING ; } if ( c0_ == kEndOfInput || unibrow :: IsStringLiteralLineTerminator ( c0_ ) ) { return Token :: ILLEGAL ; } if ( c0_ == '\\' ) { Advance ( ) ; if ( c0_ == kEndOfInput || ! ScanEscape < false > ( ) ) { return Token :: ILLEGAL ; } continue ; } AddLiteralCharAdvance ( ) ; } }
build_unc_path_to_root ( const struct smb_vol * vol , const struct cifs_sb_info * cifs_sb ) { char * full_path , * pos ; unsigned int pplen = vol -> prepath ? strlen ( vol -> prepath ) + 1 : 0 ; unsigned int unc_len = strnlen ( vol -> UNC , MAX_TREE_SIZE + 1 ) ; full_path = kmalloc ( unc_len + pplen + 1 , GFP_KERNEL ) ; if ( full_path == NULL ) return ERR_PTR ( - ENOMEM ) ; strncpy ( full_path , vol -> UNC , unc_len ) ; pos = full_path + unc_len ; if ( pplen ) { * pos ++ = CIFS_DIR_SEP ( cifs_sb ) ; strncpy ( pos , vol -> prepath , pplen ) ; pos += pplen ; } * pos = '\0' ; convert_delimiter ( full_path , CIFS_DIR_SEP ( cifs_sb ) ) ; cifs_dbg ( FYI , "%s: full_path=%s\n" , __func__ , full_path ) ; return full_path ; }
toomany ( struct magic_set * ms , const char * name , uint16_t num ) { if ( file_printf ( ms , ", too many %s header sections (%u)" , name , num ) == - 1 ) return - 1 ; return 0 ; }
static void set_source_var_based_partition ( VP9_COMP * cpi , const TileInfo * const tile , MODE_INFO * * mi_8x8 , int mi_row , int mi_col ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCK * x = & cpi -> mb ; const int mis = cm -> mi_stride ; int row8x8_remaining = tile -> mi_row_end - mi_row ; int col8x8_remaining = tile -> mi_col_end - mi_col ; int r , c ; MODE_INFO * mi_upper_left = cm -> mi + mi_row * mis + mi_col ; assert ( ( row8x8_remaining > 0 ) && ( col8x8_remaining > 0 ) ) ; if ( ( col8x8_remaining >= MI_BLOCK_SIZE ) && ( row8x8_remaining >= MI_BLOCK_SIZE ) ) { const int src_stride = x -> plane [ 0 ] . src . stride ; const int pre_stride = cpi -> Last_Source -> y_stride ; const uint8_t * src = x -> plane [ 0 ] . src . buf ; const int pre_offset = ( mi_row * MI_SIZE ) * pre_stride + ( mi_col * MI_SIZE ) ; const uint8_t * pre_src = cpi -> Last_Source -> y_buffer + pre_offset ; const int thr_32x32 = cpi -> sf . source_var_thresh ; const int thr_64x64 = thr_32x32 < < 1 ; int i , j ; int index ; diff d32 [ 4 ] ; int use16x16 = 0 ; for ( i = 0 ; i < 4 ; i ++ ) { diff d16 [ 4 ] ; for ( j = 0 ; j < 4 ; j ++ ) { int b_mi_row = coord_lookup [ i * 4 + j ] . row ; int b_mi_col = coord_lookup [ i * 4 + j ] . col ; int b_offset = b_mi_row * MI_SIZE * src_stride + b_mi_col * MI_SIZE ; vp9_get_sse_sum_16x16 ( src + b_offset , src_stride , pre_src + b_offset , pre_stride , & d16 [ j ] . sse , & d16 [ j ] . sum ) ; d16 [ j ] . var = d16 [ j ] . sse - ( ( ( uint32_t ) d16 [ j ] . sum * d16 [ j ] . sum ) > > 8 ) ; index = b_mi_row * mis + b_mi_col ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = BLOCK_16X16 ; } if ( d16 [ 0 ] . var < thr_32x32 && d16 [ 1 ] . var < thr_32x32 && d16 [ 2 ] . var < thr_32x32 && d16 [ 3 ] . var < thr_32x32 ) { d32 [ i ] . sse = d16 [ 0 ] . sse ; d32 [ i ] . sum = d16 [ 0 ] . sum ; for ( j = 1 ; j < 4 ; j ++ ) { d32 [ i ] . sse += d16 [ j ] . sse ; d32 [ i ] . sum += d16 [ j ] . sum ; } d32 [ i ] . var = d32 [ i ] . sse - ( ( ( int64_t ) d32 [ i ] . sum * d32 [ i ] . sum ) > > 10 ) ; index = coord_lookup [ i * 4 ] . row * mis + coord_lookup [ i * 4 ] . col ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = BLOCK_32X32 ; if ( ! ( ( cm -> current_video_frame - 1 ) % cpi -> sf . search_type_check_frequency ) ) cpi -> use_large_partition_rate += 1 ; } else { use16x16 = 1 ; } } if ( ! use16x16 ) { if ( d32 [ 0 ] . var < thr_64x64 && d32 [ 1 ] . var < thr_64x64 && d32 [ 2 ] . var < thr_64x64 && d32 [ 3 ] . var < thr_64x64 ) { mi_8x8 [ 0 ] = mi_upper_left ; mi_8x8 [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ; } } } else { BLOCK_SIZE bsize = BLOCK_16X16 ; int bh = num_8x8_blocks_high_lookup [ bsize ] ; int bw = num_8x8_blocks_wide_lookup [ bsize ] ; for ( r = 0 ; r < MI_BLOCK_SIZE ; r += bh ) { for ( c = 0 ; c < MI_BLOCK_SIZE ; c += bw ) { int index = r * mis + c ; bsize = find_partition_size ( bsize , ( row8x8_remaining - r ) , ( col8x8_remaining - c ) , & bh , & bw ) ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = bsize ; } } } }
uint32_t GetProtectionFromMemoryPermission ( OS :: MemoryPermission access ) { switch ( access ) { case OS :: MemoryPermission :: kNoAccess : return 0 ; case OS :: MemoryPermission :: kRead : return ZX_VM_FLAG_PERM_READ ; case OS :: MemoryPermission :: kReadWrite : return ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE ; case OS :: MemoryPermission :: kReadWriteExecute : return ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE | ZX_VM_FLAG_PERM_EXECUTE ; case OS :: MemoryPermission :: kReadExecute : return ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_EXECUTE ; } UNREACHABLE ( ) ; }
nsJSContext :: EvaluateString ( const nsAString & aScript , JSObject & aScopeObject , JS :: CompileOptions & aOptions , bool aCoerceToString , JS :: Value * aRetValue ) { SAMPLE_LABEL ( "JS" , "EvaluateString" ) ; MOZ_ASSERT_IF ( aOptions . versionSet , aOptions . version != JSVERSION_UNKNOWN ) ; MOZ_ASSERT_IF ( aCoerceToString , aRetValue ) ; NS_ENSURE_TRUE ( mIsInitialized , NS_ERROR_NOT_INITIALIZED ) ; if ( aRetValue ) { * aRetValue = JSVAL_VOID ; } if ( ! mScriptsEnabled ) { return NS_OK ; } nsCxPusher pusher ; if ( ! pusher . Push ( mContext ) ) return NS_ERROR_FAILURE ; xpc_UnmarkGrayObject ( & aScopeObject ) ; nsAutoMicroTask mt ; JSPrincipals * p = JS_GetCompartmentPrincipals ( js :: GetObjectCompartment ( & aScopeObject ) ) ; aOptions . setPrincipals ( p ) ; bool ok = false ; nsresult rv = sSecurityManager -> CanExecuteScripts ( mContext , nsJSPrincipals :: get ( p ) , & ok ) ; NS_ENSURE_SUCCESS ( rv , rv ) ; NS_ENSURE_TRUE ( ok , NS_OK ) ; nsJSContext :: TerminationFuncHolder holder ( this ) ; XPCAutoRequest ar ( mContext ) ; { JSAutoCompartment ac ( mContext , & aScopeObject ) ; ++ mExecuteDepth ; js :: RootedObject rootedScope ( mContext , & aScopeObject ) ; ok = JS :: Evaluate ( mContext , rootedScope , aOptions , PromiseFlatString ( aScript ) . get ( ) , aScript . Length ( ) , aRetValue ) ; if ( ok && aCoerceToString && ! aRetValue -> isUndefined ( ) ) { JSString * str = JS_ValueToString ( mContext , * aRetValue ) ; ok = ! ! str ; * aRetValue = ok ? JS :: StringValue ( str ) : JS :: UndefinedValue ( ) ; } -- mExecuteDepth ; } if ( ! ok ) { if ( aRetValue ) { * aRetValue = JS :: UndefinedValue ( ) ; } ReportPendingException ( ) ; } pusher . Pop ( ) ; ScriptEvaluated ( true ) ; if ( aRetValue && ! JS_WrapValue ( mContext , aRetValue ) ) return NS_ERROR_OUT_OF_MEMORY ; return NS_OK ; }
void NetworkUtils :: nextNetdCommand ( ) { if ( gCommandQueue . IsEmpty ( ) || gPending ) { return ; } gCurrentCommand . chain = GET_CURRENT_CHAIN ; gCurrentCommand . callback = GET_CURRENT_CALLBACK ; snprintf ( gCurrentCommand . command , MAX_COMMAND_SIZE - 1 , "%s" , GET_CURRENT_COMMAND ) ; NU_DBG ( "Sending \'%s\' command to netd." , gCurrentCommand . command ) ; SendNetdCommand ( GET_CURRENT_NETD_COMMAND ) ; gCommandQueue . RemoveElementAt ( 0 ) ; gPending = true ; }
writefile ( const char * name , struct string * s ) { FILE * f ; int ret ; f = fopen ( name , "w" ) ; if ( ! f ) { warn ( "open %s:" , name ) ; return - 1 ; } ret = 0 ; if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) { warn ( "write %s:" , name ) ; ret = - 1 ; } fclose ( f ) ; return ret ; }
static netdev_tx_t usb_8dev_start_xmit ( struct sk_buff * skb , struct net_device * netdev ) { struct usb_8dev_priv * priv = netdev_priv ( netdev ) ; struct net_device_stats * stats = & netdev -> stats ; struct can_frame * cf = ( struct can_frame * ) skb -> data ; struct usb_8dev_tx_msg * msg ; struct urb * urb ; struct usb_8dev_tx_urb_context * context = NULL ; u8 * buf ; int i , err ; size_t size = sizeof ( struct usb_8dev_tx_msg ) ; if ( can_dropped_invalid_skb ( netdev , skb ) ) return NETDEV_TX_OK ; urb = usb_alloc_urb ( 0 , GFP_ATOMIC ) ; if ( ! urb ) goto nomem ; buf = usb_alloc_coherent ( priv -> udev , size , GFP_ATOMIC , & urb -> transfer_dma ) ; if ( ! buf ) { netdev_err ( netdev , "No memory left for USB buffer\n" ) ; goto nomembuf ; } memset ( buf , 0 , size ) ; msg = ( struct usb_8dev_tx_msg * ) buf ; msg -> begin = USB_8DEV_DATA_START ; msg -> flags = 0x00 ; if ( cf -> can_id & CAN_RTR_FLAG ) msg -> flags |= USB_8DEV_RTR ; if ( cf -> can_id & CAN_EFF_FLAG ) msg -> flags |= USB_8DEV_EXTID ; msg -> id = cpu_to_be32 ( cf -> can_id & CAN_ERR_MASK ) ; msg -> dlc = can_get_cc_dlc ( cf , priv -> can . ctrlmode ) ; memcpy ( msg -> data , cf -> data , cf -> len ) ; msg -> end = USB_8DEV_DATA_END ; for ( i = 0 ; i < MAX_TX_URBS ; i ++ ) { if ( priv -> tx_contexts [ i ] . echo_index == MAX_TX_URBS ) { context = & priv -> tx_contexts [ i ] ; break ; } } if ( ! context ) goto nofreecontext ; context -> priv = priv ; context -> echo_index = i ; usb_fill_bulk_urb ( urb , priv -> udev , usb_sndbulkpipe ( priv -> udev , USB_8DEV_ENDP_DATA_TX ) , buf , size , usb_8dev_write_bulk_callback , context ) ; urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; usb_anchor_urb ( urb , & priv -> tx_submitted ) ; can_put_echo_skb ( skb , netdev , context -> echo_index , 0 ) ; atomic_inc ( & priv -> active_tx_urbs ) ; err = usb_submit_urb ( urb , GFP_ATOMIC ) ; if ( unlikely ( err ) ) goto failed ; else if ( atomic_read ( & priv -> active_tx_urbs ) >= MAX_TX_URBS ) netif_stop_queue ( netdev ) ; usb_free_urb ( urb ) ; return NETDEV_TX_OK ; nofreecontext : usb_free_coherent ( priv -> udev , size , buf , urb -> transfer_dma ) ; usb_free_urb ( urb ) ; netdev_warn ( netdev , "couldn't find free context" ) ; return NETDEV_TX_BUSY ; failed : can_free_echo_skb ( netdev , context -> echo_index , NULL ) ; usb_unanchor_urb ( urb ) ; usb_free_coherent ( priv -> udev , size , buf , urb -> transfer_dma ) ; atomic_dec ( & priv -> active_tx_urbs ) ; if ( err == - ENODEV ) netif_device_detach ( netdev ) ; else netdev_warn ( netdev , "failed tx_urb %d\n" , err ) ; nomembuf : usb_free_urb ( urb ) ; nomem : dev_kfree_skb ( skb ) ; stats -> tx_dropped ++ ; return NETDEV_TX_OK ; }
DEBUG_CheckUnwrapSafety ( JSObject * obj , js :: Wrapper * handler , JSCompartment * origin , JSCompartment * target ) { if ( AccessCheck :: isChrome ( target ) || xpc :: IsUniversalXPConnectEnabled ( target ) ) { MOZ_ASSERT ( handler -> isSafeToUnwrap ( ) ) ; } else if ( WrapperFactory :: IsComponentsObject ( obj ) ) { MOZ_ASSERT ( ! handler -> isSafeToUnwrap ( ) ) ; } else if ( AccessCheck :: needsSystemOnlyWrapper ( obj ) ) { } else { MOZ_ASSERT ( handler -> isSafeToUnwrap ( ) == AccessCheck :: subsumes ( target , origin ) ) ; } }
nsMultiplexInputStream :: nsMultiplexInputStream ( ) : mCurrentStream ( 0 ) , mStartedReadingCurrent ( false ) , mStatus ( NS_OK ) { }
void V8HeapExplorer :: SetDataOrAccessorPropertyReference ( PropertyKind kind , JSObject * parent_obj , int parent_entry , Name * reference_name , Object * child_obj , const char * name_format_string , int field_offset ) { if ( kind == kAccessor ) { ExtractAccessorPairProperty ( parent_obj , parent_entry , reference_name , child_obj , field_offset ) ; } else { SetPropertyReference ( parent_obj , parent_entry , reference_name , child_obj , name_format_string , field_offset ) ; } }
aaudio_result_t AAudioServiceStreamMMAP :: getFreeRunningPosition ( int64_t * positionFrames , int64_t * timeNanos ) { sp < AAudioServiceEndpointMMAP > serviceEndpointMMAP { static_cast < AAudioServiceEndpointMMAP * > ( mServiceEndpoint . get ( ) ) } ; aaudio_result_t result = serviceEndpointMMAP -> getFreeRunningPosition ( positionFrames , timeNanos ) ; if ( result == AAUDIO_OK ) { Timestamp timestamp ( * positionFrames , * timeNanos ) ; mAtomicTimestamp . write ( timestamp ) ; * positionFrames = timestamp . getPosition ( ) ; * timeNanos = timestamp . getNanoseconds ( ) ; } else if ( result != AAUDIO_ERROR_UNAVAILABLE ) { disconnect ( ) ; } return result ; }
static void srpt_handle_tsk_mgmt ( struct srpt_rdma_ch * ch , struct srpt_recv_ioctx * recv_ioctx , struct srpt_send_ioctx * send_ioctx ) { struct srp_tsk_mgmt * srp_tsk ; struct se_cmd * cmd ; struct se_session * sess = ch -> sess ; uint64_t unpacked_lun ; uint32_t tag = 0 ; int tcm_tmr ; int rc ; BUG_ON ( ! send_ioctx ) ; srp_tsk = recv_ioctx -> ioctx . buf ; cmd = & send_ioctx -> cmd ; pr_debug ( "recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld" " cm_id %p sess %p\n" , srp_tsk -> tsk_mgmt_func , srp_tsk -> task_tag , srp_tsk -> tag , ch -> cm_id , ch -> sess ) ; srpt_set_cmd_state ( send_ioctx , SRPT_STATE_MGMT ) ; send_ioctx -> cmd . tag = srp_tsk -> tag ; tcm_tmr = srp_tmr_to_tcm ( srp_tsk -> tsk_mgmt_func ) ; if ( tcm_tmr < 0 ) { send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED ; goto fail ; } unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; if ( srp_tsk -> tsk_mgmt_func == SRP_TSK_ABORT_TASK ) { rc = srpt_rx_mgmt_fn_tag ( send_ioctx , srp_tsk -> task_tag ) ; if ( rc < 0 ) { send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_DOES_NOT_EXIST ; goto fail ; } tag = srp_tsk -> task_tag ; } rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL , tag , TARGET_SCF_ACK_KREF ) ; if ( rc != 0 ) { send_ioctx -> cmd . se_tmr_req -> response = TMR_FUNCTION_REJECTED ; goto fail ; } return ; fail : transport_send_check_condition_and_sense ( cmd , 0 , 0 ) ; }
WebAudioDecodeJob :: FinalizeBufferData ( ) { MOZ_ASSERT ( NS_IsMainThread ( ) ) ; MOZ_ASSERT ( mOutput ) ; MOZ_ASSERT ( mChannels == mChannelBuffers . Length ( ) ) ; JSContext * cx = GetJSContext ( ) ; if ( ! cx ) { return false ; } for ( uint32_t i = 0 ; i < mChannels ; ++ i ) { mOutput -> SetChannelDataFromArrayBufferContents ( cx , i , mChannelBuffers [ i ] . first ) ; } return true ; }
nsListBoxBodyFrame :: VerticalScroll ( int32_t aPosition ) { nsIScrollableFrame * scrollFrame = nsLayoutUtils :: GetScrollableFrameFor ( this ) ; if ( ! scrollFrame ) { return ; } nsPoint scrollPosition = scrollFrame -> GetScrollPosition ( ) ; scrollFrame -> ScrollTo ( nsPoint ( scrollPosition . x , aPosition ) , nsIScrollableFrame :: INSTANT ) ; mYPosition = aPosition ; }
nsOverflowContinuationTracker :: Finish ( nsIFrame * aChild ) { NS_PRECONDITION ( aChild , "null ptr" ) ; NS_PRECONDITION ( aChild -> GetNextInFlow ( ) , "supposed to call Finish *before* deleting next-in-flow!" ) ; for ( nsIFrame * f = aChild ; f ; f = f -> GetNextInFlow ( ) ) { if ( mOverflowContList && mOverflowContList -> FirstChild ( ) == f -> GetNextInFlow ( ) && ! f -> GetNextInFlow ( ) -> GetNextSibling ( ) ) { mOverflowContList = nsnull ; mPrevOverflowCont = nsnull ; mSentry = nsnull ; mParent = static_cast < nsContainerFrame * > ( f -> GetParent ( ) ) ; break ; } if ( f == mSentry ) { nsIFrame * prevOverflowCont = mPrevOverflowCont ; StepForward ( ) ; if ( mPrevOverflowCont == f -> GetNextInFlow ( ) ) { mPrevOverflowCont = prevOverflowCont ; } } } }
static void task_fd_install ( struct binder_proc * proc , unsigned int fd , struct file * file ) { if ( proc -> files ) __fd_install ( proc -> files , fd , file ) ; }
status_t SurfaceFlinger :: captureScreenCommon ( RenderArea & renderArea , TraverseLayersFunction traverseLayers , sp < GraphicBuffer > * outBuffer , bool useIdentityTransform ) { ATRACE_CALL ( ) ; renderArea . updateDimensions ( mPrimaryDisplayOrientation ) ; const uint32_t usage = GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_TEXTURE ; * outBuffer = new GraphicBuffer ( renderArea . getReqWidth ( ) , renderArea . getReqHeight ( ) , HAL_PIXEL_FORMAT_RGBA_8888 , 1 , usage , "screenshot" ) ; std :: mutex captureMutex ; std :: condition_variable captureCondition ; std :: unique_lock < std :: mutex > captureLock ( captureMutex ) ; int syncFd = - 1 ; std :: optional < status_t > captureResult ; const int uid = IPCThreadState :: self ( ) -> getCallingUid ( ) ; const bool forSystem = uid == AID_GRAPHICS || uid == AID_SYSTEM ; sp < LambdaMessage > message = new LambdaMessage ( [ & ] ( ) { if ( mRefreshPending ) { ATRACE_NAME ( "Skipping screenshot for now" ) ; std :: unique_lock < std :: mutex > captureLock ( captureMutex ) ; captureResult = std :: make_optional < status_t > ( EAGAIN ) ; captureCondition . notify_one ( ) ; return ; } status_t result = NO_ERROR ; int fd = - 1 ; { Mutex :: Autolock _l ( mStateLock ) ; renderArea . render ( [ & ] ( ) { result = captureScreenImplLocked ( renderArea , traverseLayers , ( * outBuffer ) . get ( ) , useIdentityTransform , forSystem , & fd ) ; } ) ; } { std :: unique_lock < std :: mutex > captureLock ( captureMutex ) ; syncFd = fd ; captureResult = std :: make_optional < status_t > ( result ) ; captureCondition . notify_one ( ) ; } } ) ; status_t result = postMessageAsync ( message ) ; if ( result == NO_ERROR ) { captureCondition . wait ( captureLock , [ & ] ( ) { return captureResult ; } ) ; while ( * captureResult == EAGAIN ) { captureResult . reset ( ) ; result = postMessageAsync ( message ) ; if ( result != NO_ERROR ) { return result ; } captureCondition . wait ( captureLock , [ & ] ( ) { return captureResult ; } ) ; } result = * captureResult ; } if ( result == NO_ERROR ) { sync_wait ( syncFd , - 1 ) ; close ( syncFd ) ; } return result ; }
static int savu_probe ( struct hid_device * hdev , const struct hid_device_id * id ) { int retval ; retval = hid_parse ( hdev ) ; if ( retval ) { hid_err ( hdev , "parse failed\n" ) ; goto exit ; } retval = hid_hw_start ( hdev , HID_CONNECT_DEFAULT ) ; if ( retval ) { hid_err ( hdev , "hw start failed\n" ) ; goto exit ; } retval = savu_init_specials ( hdev ) ; if ( retval ) { hid_err ( hdev , "couldn't install mouse\n" ) ; goto exit_stop ; } return 0 ; exit_stop : hid_hw_stop ( hdev ) ; exit : return retval ; }
InterpreterAssembler :: GetRegisterListAtOperandIndex ( int operand_index ) { DCHECK ( Bytecodes :: IsRegisterListOperandType ( Bytecodes :: GetOperandType ( bytecode_ , operand_index ) ) ) ; DCHECK_EQ ( OperandType :: kRegCount , Bytecodes :: GetOperandType ( bytecode_ , operand_index + 1 ) ) ; Node * base_reg = RegisterLocation ( BytecodeOperandReg ( operand_index , LoadSensitivity :: kSafe ) ) ; Node * reg_count = BytecodeOperandCount ( operand_index + 1 ) ; return RegListNodePair ( base_reg , reg_count ) ; }
FoldMaskedArrayIndex ( FunctionCompiler & f , ParseNode * * indexExpr , int32_t * mask , NeedsBoundsCheck * needsBoundsCheck ) { MOZ_ASSERT ( ( * indexExpr ) -> isKind ( PNK_BITAND ) ) ; ParseNode * indexNode = BitwiseLeft ( * indexExpr ) ; ParseNode * maskNode = BitwiseRight ( * indexExpr ) ; uint32_t mask2 ; if ( IsLiteralOrConstInt ( f , maskNode , & mask2 ) ) { if ( mask2 == 0 || CountLeadingZeroes32 ( f . m ( ) . minHeapLength ( ) - 1 ) <= CountLeadingZeroes32 ( mask2 ) ) { * needsBoundsCheck = NO_BOUNDS_CHECK ; } * mask &= mask2 ; * indexExpr = indexNode ; return true ; } return false ; }
void set_constant_pool_entry ( size_t constant_pool_entry ) { DCHECK ( ! empty ( ) ) ; DCHECK ( ! has_constant_pool_entry_ ) ; constant_pool_entry_ = constant_pool_entry ; has_constant_pool_entry_ = true ; }
Statement :: internalFinalize ( bool aDestructing ) { if ( ! mDBStatement ) return NS_OK ; int srv = SQLITE_OK ; if ( ! mDBConnection -> isClosed ( ) ) { PR_LOG ( gStorageLog , PR_LOG_NOTICE , ( "Finalizing statement '%s' during garbage-collection" , :: sqlite3_sql ( mDBStatement ) ) ) ; srv = :: sqlite3_finalize ( mDBStatement ) ; } #ifdef DEBUG else { char * msg = :: PR_smprintf ( "SQL statement (%x) should have been finalized" " before garbage-collection. For more details on this statement, set" " NSPR_LOG_MESSAGES=mozStorage:5 ." , mDBStatement ) ; #if 0 NS_WARNING ( msg ) ; #endif // 0 PR_LOG ( gStorageLog , PR_LOG_WARNING , ( msg ) ) ; :: PR_smprintf_free ( msg ) ; } #endif mDBStatement = nullptr ; if ( mAsyncStatement ) { if ( aDestructing ) destructorAsyncFinalize ( ) ; else asyncFinalize ( ) ; } if ( mStatementParamsHolder ) { nsCOMPtr < nsIXPConnectWrappedNative > wrapper = do_QueryInterface ( mStatementParamsHolder ) ; nsCOMPtr < mozIStorageStatementParams > iParams = do_QueryWrappedNative ( wrapper ) ; StatementParams * params = static_cast < StatementParams * > ( iParams . get ( ) ) ; params -> mStatement = nullptr ; mStatementParamsHolder = nullptr ; } if ( mStatementRowHolder ) { nsCOMPtr < nsIXPConnectWrappedNative > wrapper = do_QueryInterface ( mStatementRowHolder ) ; nsCOMPtr < mozIStorageStatementRow > iRow = do_QueryWrappedNative ( wrapper ) ; StatementRow * row = static_cast < StatementRow * > ( iRow . get ( ) ) ; row -> mStatement = nullptr ; mStatementRowHolder = nullptr ; } return convertResultCode ( srv ) ; }
const Operator * CommonOperatorBuilder :: Call ( const CallDescriptor * call_descriptor ) { class CallOperator final : public Operator1 < const CallDescriptor * > { public : explicit CallOperator ( const CallDescriptor * call_descriptor ) : Operator1 < const CallDescriptor * > ( IrOpcode :: kCall , call_descriptor -> properties ( ) , "Call" , call_descriptor -> InputCount ( ) + call_descriptor -> FrameStateCount ( ) , Operator :: ZeroIfPure ( call_descriptor -> properties ( ) ) , Operator :: ZeroIfEliminatable ( call_descriptor -> properties ( ) ) , call_descriptor -> ReturnCount ( ) , Operator :: ZeroIfPure ( call_descriptor -> properties ( ) ) , Operator :: ZeroIfNoThrow ( call_descriptor -> properties ( ) ) , call_descriptor ) { } void PrintParameter ( std :: ostream & os , PrintVerbosity verbose ) const { os < < "[" < < * parameter ( ) < < "]" ; } } ; return new ( zone ( ) ) CallOperator ( call_descriptor ) ; }
Response V8DebuggerAgentImpl :: setScriptSource ( const String16 & scriptId , const String16 & newContent , Maybe < bool > dryRun , Maybe < protocol :: Array < protocol :: Debugger :: CallFrame > > * newCallFrames , Maybe < bool > * stackChanged , Maybe < protocol :: Runtime :: StackTrace > * asyncStackTrace , Maybe < protocol :: Runtime :: StackTraceId > * asyncStackTraceId , Maybe < protocol :: Runtime :: ExceptionDetails > * optOutCompileError ) { if ( ! enabled ( ) ) return Response :: Error ( kDebuggerNotEnabled ) ; ScriptsMap :: iterator it = m_scripts . find ( scriptId ) ; if ( it == m_scripts . end ( ) ) { return Response :: Error ( "No script with given id found" ) ; } if ( it -> second -> isModule ( ) ) { return Response :: Error ( "Editing module's script is not supported." ) ; } int contextId = it -> second -> executionContextId ( ) ; InspectedContext * inspected = m_inspector -> getContext ( contextId ) ; if ( ! inspected ) { return Response :: InternalError ( ) ; } v8 :: HandleScope handleScope ( m_isolate ) ; v8 :: Local < v8 :: Context > context = inspected -> context ( ) ; v8 :: Context :: Scope contextScope ( context ) ; v8 :: debug :: LiveEditResult result ; it -> second -> setSource ( newContent , dryRun . fromMaybe ( false ) , & result ) ; if ( result . status != v8 :: debug :: LiveEditResult :: OK ) { * optOutCompileError = protocol :: Runtime :: ExceptionDetails :: create ( ) . setExceptionId ( m_inspector -> nextExceptionId ( ) ) . setText ( toProtocolString ( m_isolate , result . message ) ) . setLineNumber ( result . line_number != - 1 ? result . line_number - 1 : 0 ) . setColumnNumber ( result . column_number != - 1 ? result . column_number : 0 ) . build ( ) ; return Response :: OK ( ) ; } else { * stackChanged = result . stack_changed ; } std :: unique_ptr < Array < CallFrame > > callFrames ; Response response = currentCallFrames ( & callFrames ) ; if ( ! response . isSuccess ( ) ) return response ; * newCallFrames = std :: move ( callFrames ) ; * asyncStackTrace = currentAsyncStackTrace ( ) ; * asyncStackTraceId = currentExternalStackTrace ( ) ; return Response :: OK ( ) ; }
bool AccessControl :: canGet ( const std :: string & fqName , pid_t pid ) { FQName fqIface ( fqName ) ; if ( ! fqIface . isValid ( ) ) { return false ; } const std :: string checkName = fqIface . package ( ) + "::" + fqIface . name ( ) ; return checkPermission ( pid , kPermissionGet , checkName . c_str ( ) ) ; }
GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ; char * tmp_str ; GF_Err e ; ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ; tmp_strsize = ( u32 ) ptr -> size - 8 ; tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ; } } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> quality_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ; } } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> drm_data = gf_strdup ( tmp_str ) ; } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> meta_data = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> segment_run_table_count ; i ++ ) { GF_AdobeSegmentRunTableBox * asrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & asrt , bs ) ; if ( e ) { if ( asrt ) gf_isom_box_del ( ( GF_Box * ) asrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> segment_run_table_entries , asrt ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> fragment_run_table_count ; i ++ ) { GF_AdobeFragmentRunTableBox * afrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & afrt , bs ) ; if ( e ) { if ( afrt ) gf_isom_box_del ( ( GF_Box * ) afrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; } gf_free ( tmp_str ) ; return GF_OK ; }
nsPresContext :: PrefChangedCallback ( const char * aPrefName , void * instance_data ) { nsPresContext * presContext = ( nsPresContext * ) instance_data ; NS_ASSERTION ( nullptr != presContext , "bad instance data" ) ; if ( nullptr != presContext ) { presContext -> PreferenceChanged ( aPrefName ) ; } return 0 ; }
donote ( struct magic_set * ms , void * vbuf , size_t offset , size_t size , int clazz , int swap , size_t align , int * flags , uint16_t * notecount ) { Elf32_Nhdr nh32 ; Elf64_Nhdr nh64 ; size_t noff , doff ; uint32_t namesz , descsz ; unsigned char * nbuf = CAST ( unsigned char * , vbuf ) ; if ( * notecount == 0 ) return 0 ; -- * notecount ; if ( xnh_sizeof + offset > size ) { return xnh_sizeof + offset ; } ( void ) memcpy ( xnh_addr , & nbuf [ offset ] , xnh_sizeof ) ; offset += xnh_sizeof ; namesz = xnh_namesz ; descsz = xnh_descsz ; if ( ( namesz == 0 ) && ( descsz == 0 ) ) { return ( offset >= size ) ? offset : size ; } if ( namesz & 0x80000000 ) { ( void ) file_printf ( ms , ", bad note name size 0x%lx" , ( unsigned long ) namesz ) ; return 0 ; } if ( descsz & 0x80000000 ) { ( void ) file_printf ( ms , ", bad note description size 0x%lx" , ( unsigned long ) descsz ) ; return 0 ; } noff = offset ; doff = ELF_ALIGN ( offset + namesz ) ; if ( offset + namesz > size ) { return doff ; } offset = ELF_ALIGN ( doff + descsz ) ; if ( doff + descsz > size ) { return ( offset >= size ) ? offset : size ; } if ( ( * flags & FLAGS_DID_OS_NOTE ) == 0 ) { if ( do_os_note ( ms , nbuf , xnh_type , swap , namesz , descsz , noff , doff , flags ) ) return size ; } if ( ( * flags & FLAGS_DID_BUILD_ID ) == 0 ) { if ( do_bid_note ( ms , nbuf , xnh_type , swap , namesz , descsz , noff , doff , flags ) ) return size ; } if ( ( * flags & FLAGS_DID_NETBSD_PAX ) == 0 ) { if ( do_pax_note ( ms , nbuf , xnh_type , swap , namesz , descsz , noff , doff , flags ) ) return size ; } if ( ( * flags & FLAGS_DID_CORE ) == 0 ) { if ( do_core_note ( ms , nbuf , xnh_type , swap , namesz , descsz , noff , doff , flags , size , clazz ) ) return size ; } if ( namesz == 7 && strcmp ( ( char * ) & nbuf [ noff ] , "NetBSD" ) == 0 ) { switch ( xnh_type ) { case NT_NETBSD_VERSION : return size ; case NT_NETBSD_MARCH : if ( * flags & FLAGS_DID_NETBSD_MARCH ) return size ; if ( file_printf ( ms , ", compiled for: %.*s" , ( int ) descsz , ( const char * ) & nbuf [ doff ] ) == - 1 ) return size ; break ; case NT_NETBSD_CMODEL : if ( * flags & FLAGS_DID_NETBSD_CMODEL ) return size ; if ( file_printf ( ms , ", compiler model: %.*s" , ( int ) descsz , ( const char * ) & nbuf [ doff ] ) == - 1 ) return size ; break ; default : if ( * flags & FLAGS_DID_NETBSD_UNKNOWN ) return size ; if ( file_printf ( ms , ", note=%u" , xnh_type ) == - 1 ) return size ; break ; } return size ; } return offset ; }
BOOL drive_file_query_directory ( DRIVE_FILE * file , UINT32 FsInformationClass , BYTE InitialQuery , const WCHAR * path , UINT32 PathLength , wStream * output ) { size_t length ; WCHAR * ent_path ; if ( ! file || ! path || ! output ) return FALSE ; if ( InitialQuery != 0 ) { if ( file -> find_handle != INVALID_HANDLE_VALUE ) FindClose ( file -> find_handle ) ; ent_path = drive_file_combine_fullpath ( file -> basepath , path , PathLength ) ; file -> find_handle = FindFirstFileW ( ent_path , & file -> find_data ) ; free ( ent_path ) ; if ( file -> find_handle == INVALID_HANDLE_VALUE ) goto out_fail ; } else if ( ! FindNextFileW ( file -> find_handle , & file -> find_data ) ) goto out_fail ; length = _wcslen ( file -> find_data . cFileName ) * 2 ; switch ( FsInformationClass ) { case FileDirectoryInformation : if ( ! Stream_EnsureRemainingCapacity ( output , 4 + 64 + length ) ) goto out_fail ; if ( length > UINT32_MAX - 64 ) goto out_fail ; Stream_Write_UINT32 ( output , ( UINT32 ) ( 64 + length ) ) ; Stream_Write_UINT32 ( output , 0 ) ; Stream_Write_UINT32 ( output , 0 ) ; Stream_Write_UINT32 ( output , file -> find_data . ftCreationTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftCreationTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastAccessTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastAccessTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeLow ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeHigh ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeLow ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeHigh ) ; Stream_Write_UINT32 ( output , file -> find_data . dwFileAttributes ) ; Stream_Write_UINT32 ( output , ( UINT32 ) length ) ; Stream_Write ( output , file -> find_data . cFileName , length ) ; break ; case FileFullDirectoryInformation : if ( ! Stream_EnsureRemainingCapacity ( output , 4 + 68 + length ) ) goto out_fail ; if ( length > UINT32_MAX - 68 ) goto out_fail ; Stream_Write_UINT32 ( output , ( UINT32 ) ( 68 + length ) ) ; Stream_Write_UINT32 ( output , 0 ) ; Stream_Write_UINT32 ( output , 0 ) ; Stream_Write_UINT32 ( output , file -> find_data . ftCreationTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftCreationTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastAccessTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastAccessTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeLow ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeHigh ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeLow ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeHigh ) ; Stream_Write_UINT32 ( output , file -> find_data . dwFileAttributes ) ; Stream_Write_UINT32 ( output , ( UINT32 ) length ) ; Stream_Write_UINT32 ( output , 0 ) ; Stream_Write ( output , file -> find_data . cFileName , length ) ; break ; case FileBothDirectoryInformation : if ( ! Stream_EnsureRemainingCapacity ( output , 4 + 93 + length ) ) goto out_fail ; if ( length > UINT32_MAX - 93 ) goto out_fail ; Stream_Write_UINT32 ( output , ( UINT32 ) ( 93 + length ) ) ; Stream_Write_UINT32 ( output , 0 ) ; Stream_Write_UINT32 ( output , 0 ) ; Stream_Write_UINT32 ( output , file -> find_data . ftCreationTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftCreationTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastAccessTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastAccessTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwLowDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . ftLastWriteTime . dwHighDateTime ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeLow ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeHigh ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeLow ) ; Stream_Write_UINT32 ( output , file -> find_data . nFileSizeHigh ) ; Stream_Write_UINT32 ( output , file -> find_data . dwFileAttributes ) ; Stream_Write_UINT32 ( output , ( UINT32 ) length ) ; Stream_Write_UINT32 ( output , 0 ) ; Stream_Write_UINT8 ( output , 0 ) ; Stream_Zero ( output , 24 ) ; Stream_Write ( output , file -> find_data . cFileName , length ) ; break ; case FileNamesInformation : if ( ! Stream_EnsureRemainingCapacity ( output , 4 + 12 + length ) ) goto out_fail ; if ( length > UINT32_MAX - 12 ) goto out_fail ; Stream_Write_UINT32 ( output , ( UINT32 ) ( 12 + length ) ) ; Stream_Write_UINT32 ( output , 0 ) ; Stream_Write_UINT32 ( output , 0 ) ; Stream_Write_UINT32 ( output , ( UINT32 ) length ) ; Stream_Write ( output , file -> find_data . cFileName , length ) ; break ; default : WLog_ERR ( TAG , "unhandled FsInformationClass %" PRIu32 , FsInformationClass ) ; goto out_fail ; } return TRUE ; out_fail : Stream_Write_UINT32 ( output , 0 ) ; Stream_Write_UINT8 ( output , 0 ) ; return FALSE ; }
const Operator * CommonOperatorBuilder :: TypeGuard ( Type type ) { return new ( zone ( ) ) Operator1 < Type > ( IrOpcode :: kTypeGuard , Operator :: kPure , "TypeGuard" , 1 , 1 , 1 , 1 , 1 , 0 , type ) ; }
Page * Page :: ConvertNewToOld ( Page * old_page ) { DCHECK ( old_page ) ; DCHECK ( old_page -> InNewSpace ( ) ) ; OldSpace * old_space = old_page -> heap ( ) -> old_space ( ) ; old_page -> set_owner ( old_space ) ; old_page -> SetFlags ( 0 , static_cast < uintptr_t > ( ~ 0 ) ) ; Page * new_page = old_space -> InitializePage ( old_page , NOT_EXECUTABLE ) ; old_space -> AddPage ( new_page ) ; return new_page ; }
void Parser :: RewriteCatchPattern ( CatchInfo * catch_info , bool * ok ) { if ( catch_info -> name == nullptr ) { DCHECK_NOT_NULL ( catch_info -> pattern ) ; catch_info -> name = ast_value_factory ( ) -> dot_catch_string ( ) ; } Variable * catch_variable = catch_info -> scope -> DeclareLocal ( catch_info -> name , VariableMode :: kVar ) ; if ( catch_info -> pattern != nullptr ) { DeclarationDescriptor descriptor ; descriptor . declaration_kind = DeclarationDescriptor :: NORMAL ; descriptor . scope = scope ( ) ; descriptor . mode = VariableMode :: kLet ; descriptor . declaration_pos = catch_info -> pattern -> position ( ) ; descriptor . initialization_pos = catch_info -> pattern -> position ( ) ; const int initializer_position = position ( ) ; DeclarationParsingResult :: Declaration decl ( catch_info -> pattern , initializer_position , factory ( ) -> NewVariableProxy ( catch_variable ) ) ; catch_info -> init_block = factory ( ) -> NewBlock ( 8 , true ) ; DeclareAndInitializeVariables ( catch_info -> init_block , & descriptor , & decl , & catch_info -> bound_names , ok ) ; } else { catch_info -> bound_names . Add ( catch_info -> name , zone ( ) ) ; } }
void CheckInputsToString ( ) { if ( ! left_type ( ) . Is ( Type :: String ( ) ) ) { Node * left_input = graph ( ) -> NewNode ( simplified ( ) -> CheckString ( VectorSlotPair ( ) ) , left ( ) , effect ( ) , control ( ) ) ; node_ -> ReplaceInput ( 0 , left_input ) ; update_effect ( left_input ) ; } if ( ! right_type ( ) . Is ( Type :: String ( ) ) ) { Node * right_input = graph ( ) -> NewNode ( simplified ( ) -> CheckString ( VectorSlotPair ( ) ) , right ( ) , effect ( ) , control ( ) ) ; node_ -> ReplaceInput ( 1 , right_input ) ; update_effect ( right_input ) ; } }
xmlXPtrNewRange ( xmlNodePtr start , int startindex , xmlNodePtr end , int endindex ) { xmlXPathObjectPtr ret ; if ( start == NULL ) return ( NULL ) ; if ( end == NULL ) return ( NULL ) ; if ( startindex < 0 ) return ( NULL ) ; if ( endindex < 0 ) return ( NULL ) ; ret = ( xmlXPathObjectPtr ) xmlMalloc ( sizeof ( xmlXPathObject ) ) ; if ( ret == NULL ) { xmlXPtrErrMemory ( "allocating range" ) ; return ( NULL ) ; } memset ( ret , 0 , ( size_t ) sizeof ( xmlXPathObject ) ) ; ret -> type = XPATH_RANGE ; ret -> user = start ; ret -> index = startindex ; ret -> user2 = end ; ret -> index2 = endindex ; xmlXPtrRangeCheckOrder ( ret ) ; return ( ret ) ; }
Node * CodeAssembler :: TailCallBytecodeDispatch ( const CallInterfaceDescriptor & descriptor , Node * target , TArgs ... args ) { DCHECK_EQ ( descriptor . GetParameterCount ( ) , sizeof ... ( args ) ) ; auto call_descriptor = Linkage :: GetBytecodeDispatchCallDescriptor ( zone ( ) , descriptor , descriptor . GetStackParameterCount ( ) ) ; Node * nodes [ ] = { target , args ... } ; CHECK_EQ ( descriptor . GetParameterCount ( ) + 1 , arraysize ( nodes ) ) ; return raw_assembler ( ) -> TailCallN ( call_descriptor , arraysize ( nodes ) , nodes ) ; }
vi_pci_write ( UNUSED int vcpu , struct pci_devinst * pi , int baridx , uint64_t offset , int size , uint64_t value ) { struct virtio_softc * vs = pi -> pi_arg ; struct vqueue_info * vq ; struct virtio_consts * vc ; struct config_reg * cr ; uint64_t virtio_config_size , max ; const char * name ; uint32_t newoff ; int error ; if ( vs -> vs_flags & VIRTIO_USE_MSIX ) { if ( baridx == pci_msix_table_bar ( pi ) || baridx == pci_msix_pba_bar ( pi ) ) { pci_emul_msix_twrite ( pi , offset , size , value ) ; return ; } } assert ( baridx == 0 ) ; if ( vs -> vs_mtx ) pthread_mutex_lock ( vs -> vs_mtx ) ; vc = vs -> vs_vc ; name = vc -> vc_name ; if ( size != 1 && size != 2 && size != 4 ) goto bad ; if ( pci_msix_enabled ( pi ) ) virtio_config_size = VTCFG_R_CFG1 ; else virtio_config_size = VTCFG_R_CFG0 ; if ( offset >= virtio_config_size ) { newoff = ( uint32_t ) ( offset - virtio_config_size ) ; max = vc -> vc_cfgsize ? vc -> vc_cfgsize : 0x100000000 ; if ( ( newoff + ( ( unsigned ) size ) ) > max ) goto bad ; error = ( * vc -> vc_cfgwrite ) ( DEV_SOFTC ( vs ) , ( ( int ) newoff ) , size , ( ( uint32_t ) value ) ) ; if ( ! error ) goto done ; } bad : cr = vi_find_cr ( ( int ) offset ) ; if ( cr == NULL || cr -> cr_size != size || cr -> cr_ro ) { if ( cr != NULL ) { if ( cr -> cr_size != size ) fprintf ( stderr , "%s: write to %s: bad size %d\r\n" , name , cr -> cr_name , size ) ; if ( cr -> cr_ro ) fprintf ( stderr , "%s: write to read-only reg %s\r\n" , name , cr -> cr_name ) ; } else { fprintf ( stderr , "%s: write to bad offset/size %jd/%d\r\n" , name , ( uintmax_t ) offset , size ) ; } goto done ; } switch ( offset ) { case VTCFG_R_GUESTCAP : vs -> vs_negotiated_caps = ( uint32_t ) ( value & vc -> vc_hv_caps ) ; if ( vc -> vc_apply_features ) ( * vc -> vc_apply_features ) ( DEV_SOFTC ( vs ) , vs -> vs_negotiated_caps ) ; break ; case VTCFG_R_PFN : if ( vs -> vs_curq >= vc -> vc_nvq ) goto bad_qindex ; vi_vq_init ( vs , ( ( uint32_t ) value ) ) ; break ; case VTCFG_R_QSEL : vs -> vs_curq = ( int ) value ; break ; case VTCFG_R_QNOTIFY : if ( value >= ( ( uint64_t ) vc -> vc_nvq ) ) { fprintf ( stderr , "%s: queue %d notify out of range\r\n" , name , ( int ) value ) ; goto done ; } vq = & vs -> vs_queues [ value ] ; if ( vq -> vq_notify ) ( * vq -> vq_notify ) ( DEV_SOFTC ( vs ) , vq ) ; else if ( vc -> vc_qnotify ) ( * vc -> vc_qnotify ) ( DEV_SOFTC ( vs ) , vq ) ; else fprintf ( stderr , "%s: qnotify queue %d: missing vq/vc notify\r\n" , name , ( int ) value ) ; break ; case VTCFG_R_STATUS : vs -> vs_status = ( uint8_t ) value ; if ( value == 0 ) ( * vc -> vc_reset ) ( DEV_SOFTC ( vs ) ) ; break ; case VTCFG_R_CFGVEC : vs -> vs_msix_cfg_idx = ( uint16_t ) value ; break ; case VTCFG_R_QVEC : if ( vs -> vs_curq >= vc -> vc_nvq ) goto bad_qindex ; vq = & vs -> vs_queues [ vs -> vs_curq ] ; vq -> vq_msix_idx = ( uint16_t ) value ; break ; } goto done ; bad_qindex : fprintf ( stderr , "%s: write config reg %s: curq %d >= max %d\r\n" , name , cr -> cr_name , vs -> vs_curq , vc -> vc_nvq ) ; done : if ( vs -> vs_mtx ) pthread_mutex_unlock ( vs -> vs_mtx ) ; }
SoftMPEG4Encoder :: ~ SoftMPEG4Encoder ( ) { ALOGV ( "Destruct SoftMPEG4Encoder" ) ; releaseEncoder ( ) ; List < BufferInfo * > & outQueue = getPortQueue ( 1 ) ; List < BufferInfo * > & inQueue = getPortQueue ( 0 ) ; CHECK ( outQueue . empty ( ) ) ; CHECK ( inQueue . empty ( ) ) ; }
void Compute ( OpKernelContext * context ) override { const Tensor & boxes = context -> input ( 0 ) ; const Tensor & scores = context -> input ( 1 ) ; OP_REQUIRES ( context , ( boxes . dim_size ( 0 ) == scores . dim_size ( 0 ) ) , errors :: InvalidArgument ( "boxes and scores must have same batch size" ) ) ; const Tensor & max_output_size = context -> input ( 2 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( max_output_size . shape ( ) ) , errors :: InvalidArgument ( "max_size_per_class must be 0-D, got shape " , max_output_size . shape ( ) . DebugString ( ) ) ) ; const int max_size_per_class = max_output_size . scalar < int > ( ) ( ) ; const Tensor & max_total_size = context -> input ( 3 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( max_total_size . shape ( ) ) , errors :: InvalidArgument ( "max_total_size must be 0-D, got shape " , max_total_size . shape ( ) . DebugString ( ) ) ) ; const int max_total_size_per_batch = max_total_size . scalar < int > ( ) ( ) ; OP_REQUIRES ( context , max_total_size_per_batch > 0 , errors :: InvalidArgument ( "max_total_size must be > 0" ) ) ; if ( max_total_size_per_batch > pow ( 10 , 6 ) ) { LOG ( WARNING ) < < "Detected a large value for `max_total_size`. This may " < < "cause OOM error. (max_total_size: " < < max_total_size . scalar < int > ( ) ( ) < < ")" ; } const Tensor & iou_threshold = context -> input ( 4 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( iou_threshold . shape ( ) ) , errors :: InvalidArgument ( "iou_threshold must be 0-D, got shape " , iou_threshold . shape ( ) . DebugString ( ) ) ) ; const float iou_threshold_val = iou_threshold . scalar < float > ( ) ( ) ; const Tensor & score_threshold = context -> input ( 5 ) ; OP_REQUIRES ( context , TensorShapeUtils :: IsScalar ( score_threshold . shape ( ) ) , errors :: InvalidArgument ( "score_threshold must be 0-D, got shape " , score_threshold . shape ( ) . DebugString ( ) ) ) ; const float score_threshold_val = score_threshold . scalar < float > ( ) ( ) ; OP_REQUIRES ( context , iou_threshold_val >= 0 && iou_threshold_val <= 1 , errors :: InvalidArgument ( "iou_threshold must be in [0, 1]" ) ) ; int num_boxes = 0 ; const int num_classes = scores . dim_size ( 2 ) ; ParseAndCheckCombinedNMSBoxSizes ( context , boxes , & num_boxes , num_classes ) ; CheckCombinedNMSScoreSizes ( context , num_boxes , scores ) ; if ( ! context -> status ( ) . ok ( ) ) { return ; } BatchedNonMaxSuppressionOp ( context , boxes , scores , num_boxes , max_size_per_class , max_total_size_per_batch , score_threshold_val , iou_threshold_val , pad_per_class_ , clip_boxes_ ) ; }
Skip the mipmap images for uncompressed ( RGB or RGBA ) dds files * / static MagickBooleanType SkipRGBMipmaps ( Image * image , DDSInfo * dds_info , int pixel_size , ExceptionInfo * exception ) { MagickOffsetType offset ; register ssize_t i ; size_t h , w ; if ( dds_info -> ddscaps1 & DDSCAPS_MIPMAP && ( dds_info -> ddscaps1 & DDSCAPS_TEXTURE || dds_info -> ddscaps2 & DDSCAPS2_CUBEMAP ) ) { if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; return ( MagickFalse ) ; } w = DIV2 ( dds_info -> width ) ; h = DIV2 ( dds_info -> height ) ; for ( i = 1 ; ( i < ( ssize_t ) dds_info -> mipmapcount ) && w && h ; i ++ ) { offset = ( MagickOffsetType ) w * h * pixel_size ; ( void ) SeekBlob ( image , offset , SEEK_CUR ) ; w = DIV2 ( w ) ; h = DIV2 ( h ) ; } }
int get_evtchn_to_irq ( evtchn_port_t evtchn ) { if ( evtchn >= xen_evtchn_max_channels ( ) ) return - 1 ; if ( evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] == NULL ) return - 1 ; return evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] [ EVTCHN_COL ( evtchn ) ] ; }
int rds_sendmsg ( struct socket * sock , struct msghdr * msg , size_t payload_len ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; __be32 daddr ; __be16 dport ; struct rds_message * rm = NULL ; struct rds_connection * conn ; int ret = 0 ; int queued = 0 , allocated_mr = 0 ; int nonblock = msg -> msg_flags & MSG_DONTWAIT ; long timeo = sock_sndtimeo ( sk , nonblock ) ; if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( msg -> msg_namelen ) { if ( msg -> msg_namelen < sizeof ( * usin ) || usin -> sin_family != AF_INET ) { ret = - EINVAL ; goto out ; } daddr = usin -> sin_addr . s_addr ; dport = usin -> sin_port ; } else { lock_sock ( sk ) ; daddr = rs -> rs_conn_addr ; dport = rs -> rs_conn_port ; release_sock ( sk ) ; } if ( daddr == 0 || rs -> rs_bound_addr == 0 ) { ret = - ENOTCONN ; goto out ; } if ( payload_len > rds_sk_sndbuf ( rs ) ) { ret = - EMSGSIZE ; goto out ; } ret = rds_rm_size ( msg , payload_len ) ; if ( ret < 0 ) goto out ; rm = rds_message_alloc ( ret , GFP_KERNEL ) ; if ( ! rm ) { ret = - ENOMEM ; goto out ; } if ( payload_len ) { rm -> data . op_sg = rds_message_alloc_sgs ( rm , ceil ( payload_len , PAGE_SIZE ) ) ; if ( ! rm -> data . op_sg ) { ret = - ENOMEM ; goto out ; } ret = rds_message_copy_from_user ( rm , & msg -> msg_iter ) ; if ( ret ) goto out ; } rm -> data . op_active = 1 ; rm -> m_daddr = daddr ; if ( rs -> rs_conn && rs -> rs_conn -> c_faddr == daddr ) conn = rs -> rs_conn ; else { conn = rds_conn_create_outgoing ( sock_net ( sock -> sk ) , rs -> rs_bound_addr , daddr , rs -> rs_transport , sock -> sk -> sk_allocation ) ; if ( IS_ERR ( conn ) ) { ret = PTR_ERR ( conn ) ; goto out ; } rs -> rs_conn = conn ; } ret = rds_cmsg_send ( rs , rm , msg , & allocated_mr ) ; if ( ret ) goto out ; if ( rm -> rdma . op_active && ! conn -> c_trans -> xmit_rdma ) { printk_ratelimited ( KERN_NOTICE "rdma_op %p conn xmit_rdma %p\n" , & rm -> rdma , conn -> c_trans -> xmit_rdma ) ; ret = - EOPNOTSUPP ; goto out ; } if ( rm -> atomic . op_active && ! conn -> c_trans -> xmit_atomic ) { printk_ratelimited ( KERN_NOTICE "atomic_op %p conn xmit_atomic %p\n" , & rm -> atomic , conn -> c_trans -> xmit_atomic ) ; ret = - EOPNOTSUPP ; goto out ; } rds_conn_connect_if_down ( conn ) ; ret = rds_cong_wait ( conn -> c_fcong , dport , nonblock , rs ) ; if ( ret ) { rs -> rs_seen_congestion = 1 ; goto out ; } while ( ! rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) ) { rds_stats_inc ( s_send_queue_full ) ; if ( nonblock ) { ret = - EAGAIN ; goto out ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) , timeo ) ; rdsdebug ( "sendmsg woke queued %d timeo %ld\n" , queued , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; goto out ; } rds_stats_inc ( s_send_queued ) ; ret = rds_send_xmit ( conn ) ; if ( ret == - ENOMEM || ret == - EAGAIN ) queue_delayed_work ( rds_wq , & conn -> c_send_w , 1 ) ; rds_message_put ( rm ) ; return payload_len ; out : if ( allocated_mr ) rds_rdma_unuse ( rs , rds_rdma_cookie_key ( rm -> m_rdma_cookie ) , 1 ) ; if ( rm ) rds_message_put ( rm ) ; return ret ; }
TfLiteStatus ResizeOutputTensor ( TfLiteContext * context , const TfLiteTensor * data , const TfLiteTensor * segment_ids , TfLiteTensor * output ) { int max_index = - 1 ; const int segment_id_size = segment_ids -> dims -> data [ 0 ] ; if ( segment_id_size > 0 ) { max_index = segment_ids -> data . i32 [ segment_id_size - 1 ] ; } const int data_rank = NumDimensions ( data ) ; TfLiteIntArray * output_shape = TfLiteIntArrayCreate ( NumDimensions ( data ) ) ; output_shape -> data [ 0 ] = max_index + 1 ; for ( int i = 1 ; i < data_rank ; ++ i ) { output_shape -> data [ i ] = data -> dims -> data [ i ] ; } return context -> ResizeTensor ( context , output , output_shape ) ; }
void Compute ( OpKernelContext * context ) override { const Tensor & tensor_in = context -> input ( 0 ) ; const Tensor & grad_in = context -> input ( 1 ) ; const Tensor & argmax = context -> input ( 2 ) ; PoolParameters params { context , ksize_ , stride_ , padding_ , { } , FORMAT_NHWC , tensor_in . shape ( ) } ; if ( ! context -> status ( ) . ok ( ) ) { return ; } TensorShape out_shape ( { params . tensor_in_batch , params . out_height , params . out_width , params . depth } ) ; Tensor * grad_out = nullptr ; OP_REQUIRES_OK ( context , context -> forward_input_or_allocate_output ( { 0 } , 0 , out_shape , & grad_out ) ) ; LaunchMaxPoolingGradGradWithArgmax < Device , T > :: launch ( context , params , grad_in , argmax , grad_out , include_batch_in_index_ ) ; }
builtin_compile_impl ( PyObject * module , PyObject * source , PyObject * filename , const char * mode , int flags , int dont_inherit , int optimize ) { PyObject * source_copy ; const char * str ; int compile_mode = - 1 ; int is_ast ; PyCompilerFlags cf ; int start [ ] = { Py_file_input , Py_eval_input , Py_single_input } ; PyObject * result ; cf . cf_flags = flags | PyCF_SOURCE_IS_UTF8 ; if ( flags & ~ ( PyCF_MASK | PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST ) ) { PyErr_SetString ( PyExc_ValueError , "compile(): unrecognised flags" ) ; goto error ; } if ( optimize < - 1 || optimize > 2 ) { PyErr_SetString ( PyExc_ValueError , "compile(): invalid optimize value" ) ; goto error ; } if ( ! dont_inherit ) { PyEval_MergeCompilerFlags ( & cf ) ; } if ( strcmp ( mode , "exec" ) == 0 ) compile_mode = 0 ; else if ( strcmp ( mode , "eval" ) == 0 ) compile_mode = 1 ; else if ( strcmp ( mode , "single" ) == 0 ) compile_mode = 2 ; else { PyErr_SetString ( PyExc_ValueError , "compile() mode must be 'exec', 'eval' or 'single'" ) ; goto error ; } is_ast = PyAST_Check ( source ) ; if ( is_ast == - 1 ) goto error ; if ( is_ast ) { if ( flags & PyCF_ONLY_AST ) { Py_INCREF ( source ) ; result = source ; } else { PyArena * arena ; mod_ty mod ; arena = PyArena_New ( ) ; if ( arena == NULL ) goto error ; mod = PyAST_obj2mod ( source , arena , compile_mode ) ; if ( mod == NULL ) { PyArena_Free ( arena ) ; goto error ; } if ( ! PyAST_Validate ( mod ) ) { PyArena_Free ( arena ) ; goto error ; } result = ( PyObject * ) PyAST_CompileObject ( mod , filename , & cf , optimize , arena ) ; PyArena_Free ( arena ) ; } goto finally ; } str = source_as_string ( source , "compile" , "string, bytes or AST" , & cf , & source_copy ) ; if ( str == NULL ) goto error ; result = Py_CompileStringObject ( str , filename , start [ compile_mode ] , & cf , optimize ) ; Py_XDECREF ( source_copy ) ; goto finally ; error : result = NULL ; finally : Py_DECREF ( filename ) ; return result ; }
WORD32 ixheaacd_real_synth_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD32 num_columns , FLOAT32 qmf_buf_real [ ] [ 64 ] , FLOAT32 qmf_buf_imag [ ] [ 64 ] ) { WORD32 i , j , k , l , idx ; FLOAT32 g [ 640 ] ; FLOAT32 w [ 640 ] ; FLOAT32 synth_out [ 128 ] ; FLOAT32 accu_r ; WORD32 synth_size = ptr_hbe_txposer -> synth_size ; FLOAT32 * ptr_cos_tab_trans_qmf = ( FLOAT32 * ) & ixheaacd_cos_table_trans_qmf [ 0 ] [ 0 ] + ptr_hbe_txposer -> k_start * 32 ; FLOAT32 * buffer = ptr_hbe_txposer -> synth_buf ; for ( idx = 0 ; idx < num_columns ; idx ++ ) { FLOAT32 loc_qmf_buf [ 64 ] ; FLOAT32 * synth_buf_r = loc_qmf_buf ; FLOAT32 * out_buf = ptr_hbe_txposer -> ptr_input_buf + ( idx + 1 ) * ptr_hbe_txposer -> synth_size ; FLOAT32 * synth_cos_tab = ptr_hbe_txposer -> synth_cos_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> synth_wind_coeff ; if ( ptr_hbe_txposer -> k_start < 0 ) return - 1 ; for ( k = 0 ; k < synth_size ; k ++ ) { WORD32 ki = ptr_hbe_txposer -> k_start + k ; synth_buf_r [ k ] = ( FLOAT32 ) ( ptr_cos_tab_trans_qmf [ ( k < < 1 ) + 0 ] * qmf_buf_real [ idx ] [ ki ] + ptr_cos_tab_trans_qmf [ ( k < < 1 ) + 1 ] * qmf_buf_imag [ idx ] [ ki ] ) ; synth_buf_r [ k + ptr_hbe_txposer -> synth_size ] = 0 ; } for ( l = ( 20 * synth_size - 1 ) ; l >= 2 * synth_size ; l -- ) { buffer [ l ] = buffer [ l - 2 * synth_size ] ; } if ( synth_size == 20 ) { FLOAT32 * psynth_cos_tab = synth_cos_tab ; for ( l = 0 ; l < ( synth_size + 1 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ synth_size - l ] = accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } for ( l = ( synth_size + 1 ) ; l < ( 2 * synth_size - synth_size / 2 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ 3 * synth_size - l ] = - accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 3 * synth_size > > 1 ] = accu_r ; } else { FLOAT32 tmp ; FLOAT32 * ptr_u = synth_out ; WORD32 kmax = ( synth_size > > 1 ) ; FLOAT32 * syn_buf = & buffer [ kmax ] ; kmax += synth_size ; if ( ixheaacd_real_synth_fft != NULL ) ( * ixheaacd_real_synth_fft ) ( synth_buf_r , synth_out , synth_size * 2 ) ; else return - 1 ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } syn_buf = & buffer [ 0 ] ; kmax -= synth_size ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } } for ( i = 0 ; i < 5 ; i ++ ) { memcpy ( & g [ ( 2 * i + 0 ) * synth_size ] , & buffer [ ( 4 * i + 0 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; memcpy ( & g [ ( 2 * i + 1 ) * synth_size ] , & buffer [ ( 4 * i + 3 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; } for ( k = 0 ; k < 10 * synth_size ; k ++ ) { w [ k ] = g [ k ] * interp_window_coeff [ k ] ; } for ( i = 0 ; i < synth_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 10 ; j ++ ) { accu_r = accu_r + w [ synth_size * j + i ] ; } out_buf [ i ] = ( FLOAT32 ) accu_r ; } } return 0 ; }
long dd_get_item_size ( struct dump_dir * dd , const char * name ) { long size = - 1 ; char * iname = concat_path_file ( dd -> dd_dirname , name ) ; struct stat statbuf ; if ( lstat ( iname , & statbuf ) == 0 && S_ISREG ( statbuf . st_mode ) ) size = statbuf . st_size ; else { if ( errno == ENOENT ) size = 0 ; else perror_msg ( "Can't get size of file '%s'" , iname ) ; } free ( iname ) ; return size ; }
png_handle_tIME ( png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) { png_byte buf [ 7 ] ; png_time mod_time ; png_debug ( 1 , "in png_handle_tIME" ) ; if ( ! ( png_ptr -> mode & PNG_HAVE_IHDR ) ) png_chunk_error ( png_ptr , "missing IHDR" ) ; else if ( info_ptr != NULL && ( info_ptr -> valid & PNG_INFO_tIME ) ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "duplicate" ) ; return ; } if ( png_ptr -> mode & PNG_HAVE_IDAT ) png_ptr -> mode |= PNG_AFTER_IDAT ; if ( length != 7 ) { png_crc_finish ( png_ptr , length ) ; png_chunk_benign_error ( png_ptr , "invalid" ) ; return ; } png_crc_read ( png_ptr , buf , 7 ) ; if ( png_crc_finish ( png_ptr , 0 ) ) return ; mod_time . second = buf [ 6 ] ; mod_time . minute = buf [ 5 ] ; mod_time . hour = buf [ 4 ] ; mod_time . day = buf [ 3 ] ; mod_time . month = buf [ 2 ] ; mod_time . year = png_get_uint_16 ( buf ) ; png_set_tIME ( png_ptr , info_ptr , & mod_time ) ; }
_dl_dst_count ( const char * name , int is_path ) { size_t cnt = 0 ; do { size_t len = 1 ; if ( ( ( ( ! __libc_enable_secure && strncmp ( & name [ 1 ] , "ORIGIN" , 6 ) == 0 && ( len = 7 ) != 0 ) || ( strncmp ( & name [ 1 ] , "PLATFORM" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == '\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( ! __libc_enable_secure && strncmp ( & name [ 2 ] , "ORIGIN}" , 7 ) == 0 && ( len = 9 ) != 0 ) || ( strncmp ( & name [ 2 ] , "PLATFORM}" , 9 ) == 0 && ( len = 11 ) != 0 ) ) ) ) ++ cnt ; name = strchr ( name + len , '$' ) ; } while ( name != NULL ) ; return cnt ; }
void AddressToTraceMap :: Print ( ) { PrintF ( "[AddressToTraceMap (%" PRIuS "): \n" , ranges_ . size ( ) ) ; for ( RangeMap :: iterator it = ranges_ . begin ( ) ; it != ranges_ . end ( ) ; ++ it ) { PrintF ( "[%p - %p] => %u\n" , reinterpret_cast < void * > ( it -> second . start ) , reinterpret_cast < void * > ( it -> first ) , it -> second . trace_node_id ) ; } PrintF ( "]\n" ) ; }
void VarianceTest < VarianceFunctionType > :: OneQuarterTest ( ) { memset ( src_ , 255 , block_size_ ) ; const int half = block_size_ / 2 ; memset ( ref_ , 255 , half ) ; memset ( ref_ + half , 0 , half ) ; unsigned int sse ; unsigned int var ; REGISTER_STATE_CHECK ( var = variance_ ( src_ , width_ , ref_ , width_ , & sse ) ) ; const unsigned int expected = block_size_ * 255 * 255 / 4 ; EXPECT_EQ ( expected , var ) ; }
JSObject :: removeProperty ( JSContext * cx , jsid id ) { Shape * * spp = nativeSearch ( id ) ; Shape * shape = SHAPE_FETCH ( spp ) ; if ( ! shape ) { METER ( uselessRemoves ) ; return true ; } bool addedToFreelist = false ; bool hadSlot = ! shape -> isAlias ( ) && shape -> hasSlot ( ) ; if ( hadSlot ) { addedToFreelist = freeSlot ( cx , shape -> slot ) ; JS_ATOMIC_INCREMENT ( & cx -> runtime -> propertyRemovals ) ; } if ( shape != lastProp && ! inDictionaryMode ( ) ) { if ( ! toDictionaryMode ( cx ) ) return false ; spp = nativeSearch ( shape -> propid ) ; shape = SHAPE_FETCH ( spp ) ; } if ( inDictionaryMode ( ) ) { PropertyTable * table = lastProp -> hasTable ( ) ? lastProp -> getTable ( ) : NULL ; if ( SHAPE_HAD_COLLISION ( * spp ) ) { JS_ASSERT ( table ) ; * spp = SHAPE_REMOVED ; ++ table -> removedCount ; -- table -> entryCount ; } else { METER ( removeFrees ) ; if ( table ) { * spp = NULL ; -- table -> entryCount ; #ifdef DEBUG const Shape * aprop = lastProp ; for ( int n = 50 ; -- n >= 0 && aprop -> parent ; aprop = aprop -> parent ) JS_ASSERT_IF ( aprop != shape , nativeContains ( * aprop ) ) ; #endif } } flags |= OWN_SHAPE ; Shape * oldLastProp = lastProp ; shape -> removeFromDictionary ( this ) ; if ( table ) { if ( shape == oldLastProp ) { JS_ASSERT ( shape -> getTable ( ) == table ) ; JS_ASSERT ( shape -> parent == lastProp ) ; JS_ASSERT ( shape -> slotSpan >= lastProp -> slotSpan ) ; JS_ASSERT_IF ( hadSlot , shape -> slot + 1 <= shape -> slotSpan ) ; if ( table -> freelist != SHAPE_INVALID_SLOT ) { lastProp -> slotSpan = shape -> slotSpan ; if ( hadSlot && ! addedToFreelist ) { getSlotRef ( shape -> slot ) . setPrivateUint32 ( table -> freelist ) ; table -> freelist = shape -> slot ; } } } oldLastProp -> setTable ( NULL ) ; lastProp -> setTable ( table ) ; } } else { JS_ASSERT ( shape == lastProp ) ; removeLastProperty ( ) ; size_t fixed = numFixedSlots ( ) ; if ( shape -> slot == fixed ) { JS_ASSERT_IF ( ! lastProp -> isEmptyShape ( ) && lastProp -> hasSlot ( ) , lastProp -> slot == fixed - 1 ) ; revertToFixedSlots ( cx ) ; } } updateShape ( cx ) ; if ( lastProp -> hasTable ( ) ) { PropertyTable * table = lastProp -> getTable ( ) ; uint32 size = table -> capacity ( ) ; if ( size > PropertyTable :: MIN_SIZE && table -> entryCount <= size > > 2 ) { METER ( shrinks ) ; ( void ) table -> change ( - 1 , cx ) ; } } if ( hasSlotsArray ( ) ) { JS_ASSERT ( slotSpan ( ) <= numSlots ( ) ) ; if ( ( slotSpan ( ) + ( slotSpan ( ) > > 2 ) ) < numSlots ( ) ) shrinkSlots ( cx , slotSpan ( ) ) ; } CHECK_SHAPE_CONSISTENCY ( this ) ; METER ( removes ) ; return true ; }
int main ( int , char * * ) { auto errorScopeGuard = [ ] ( ) { removeArtifacts ( ) ; SetProperty ( kOdsignKeyDoneProp , "1" ) ; SetProperty ( kOdsignVerificationStatusProp , kOdsignVerificationStatusError ) ; SetProperty ( kOdsignVerificationDoneProp , "1" ) ; SetProperty ( kStopServiceProp , "odsign" ) ; } ; auto scope_guard = android :: base :: make_scope_guard ( errorScopeGuard ) ; if ( ! android :: base :: GetBoolProperty ( "ro.apex.updatable" , false ) ) { LOG ( INFO ) < < "Device doesn't support updatable APEX, exiting." ; return 0 ; } auto keystoreResult = KeystoreKey :: getInstance ( ) ; if ( ! keystoreResult . ok ( ) ) { LOG ( ERROR ) < < "Could not create keystore key: " < < keystoreResult . error ( ) . message ( ) ; return - 1 ; } SigningKey * key = keystoreResult . value ( ) ; bool supportsFsVerity = access ( kFsVerityProcPath , F_OK ) == 0 ; if ( ! supportsFsVerity ) { LOG ( INFO ) < < "Device doesn't support fsverity. Falling back to full verification." ; } if ( supportsFsVerity ) { auto existing_cert = verifyExistingCert ( * key ) ; if ( ! existing_cert . ok ( ) ) { LOG ( WARNING ) < < existing_cert . error ( ) . message ( ) ; auto new_cert = createX509Cert ( * key , kSigningKeyCert ) ; if ( ! new_cert . ok ( ) ) { LOG ( ERROR ) < < "Failed to create X509 certificate: " < < new_cert . error ( ) . message ( ) ; return - 1 ; } } else { LOG ( INFO ) < < "Found and verified existing public key certificate: " < < kSigningKeyCert ; } auto cert_add_result = addCertToFsVerityKeyring ( kSigningKeyCert ) ; if ( ! cert_add_result . ok ( ) ) { LOG ( ERROR ) < < "Failed to add certificate to fs-verity keyring: " < < cert_add_result . error ( ) . message ( ) ; return - 1 ; } } art :: odrefresh :: ExitCode odrefresh_status = compileArtifacts ( kForceCompilation ) ; if ( odrefresh_status == art :: odrefresh :: ExitCode :: kOkay ) { LOG ( INFO ) < < "odrefresh said artifacts are VALID" ; int err = access ( kArtArtifactsDir . c_str ( ) , F_OK ) ; bool artifactsPresent = ( err == 0 ) || ( err < 0 && errno != ENOENT ) ; if ( artifactsPresent ) { auto verificationResult = verifyArtifacts ( * key , supportsFsVerity ) ; if ( ! verificationResult . ok ( ) ) { LOG ( ERROR ) < < verificationResult . error ( ) . message ( ) ; return - 1 ; } } } else if ( odrefresh_status == art :: odrefresh :: ExitCode :: kCompilationSuccess || odrefresh_status == art :: odrefresh :: ExitCode :: kCompilationFailed ) { const bool compiled_all = odrefresh_status == art :: odrefresh :: ExitCode :: kCompilationSuccess ; LOG ( INFO ) < < "odrefresh compiled " < < ( compiled_all ? "all" : "partial" ) < < " artifacts, returned " < < odrefresh_status ; Result < std :: map < std :: string , std :: string > > digests ; if ( supportsFsVerity ) { digests = addFilesToVerityRecursive ( kArtArtifactsDir , * key ) ; } else { digests = computeDigests ( kArtArtifactsDir ) ; } if ( ! digests . ok ( ) ) { LOG ( ERROR ) < < digests . error ( ) . message ( ) ; return - 1 ; } auto persistStatus = persistDigests ( * digests , * key ) ; if ( ! persistStatus . ok ( ) ) { LOG ( ERROR ) < < persistStatus . error ( ) . message ( ) ; return - 1 ; } } else if ( odrefresh_status == art :: odrefresh :: ExitCode :: kCleanupFailed ) { LOG ( ERROR ) < < "odrefresh failed cleaning up existing artifacts" ; return - 1 ; } else { LOG ( ERROR ) < < "odrefresh exited unexpectedly, returned " < < odrefresh_status ; return - 1 ; } LOG ( INFO ) < < "On-device signing done." ; scope_guard . Disable ( ) ; SetProperty ( kOdsignKeyDoneProp , "1" ) ; SetProperty ( kOdsignVerificationStatusProp , kOdsignVerificationStatusValid ) ; SetProperty ( kOdsignVerificationDoneProp , "1" ) ; SetProperty ( kStopServiceProp , "odsign" ) ; return 0 ; }
MaybeHandle < String > Factory :: NewExternalStringFromTwoByte ( const ExternalTwoByteString :: Resource * resource ) { size_t length = resource -> length ( ) ; if ( length > static_cast < size_t > ( String :: kMaxLength ) ) { THROW_NEW_ERROR ( isolate ( ) , NewInvalidStringLengthError ( ) , String ) ; } if ( length == 0 ) return empty_string ( ) ; static const size_t kOneByteCheckLengthLimit = 32 ; bool is_one_byte = length <= kOneByteCheckLengthLimit && String :: IsOneByte ( resource -> data ( ) , static_cast < int > ( length ) ) ; Handle < Map > map ; if ( resource -> IsCompressible ( ) ) { map = is_one_byte ? short_external_string_with_one_byte_data_map ( ) : short_external_string_map ( ) ; } else { map = is_one_byte ? external_string_with_one_byte_data_map ( ) : external_string_map ( ) ; } Handle < ExternalTwoByteString > external_string ( ExternalTwoByteString :: cast ( New ( map , TENURED ) ) , isolate ( ) ) ; external_string -> set_length ( static_cast < int > ( length ) ) ; external_string -> set_hash_field ( String :: kEmptyHashField ) ; external_string -> SetResource ( isolate ( ) , resource ) ; isolate ( ) -> heap ( ) -> RegisterExternalString ( * external_string ) ; return external_string ; }
int __sys_recvmmsg ( int fd , struct mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct timespec * timeout ) { int fput_needed , err , datagrams ; struct socket * sock ; struct mmsghdr __user * entry ; struct compat_mmsghdr __user * compat_entry ; struct msghdr msg_sys ; struct timespec end_time ; if ( timeout && poll_select_set_timeout ( & end_time , timeout -> tv_sec , timeout -> tv_nsec ) ) return - EINVAL ; datagrams = 0 ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) return err ; err = sock_error ( sock -> sk ) ; if ( err ) goto out_put ; entry = mmsg ; compat_entry = ( struct compat_mmsghdr __user * ) mmsg ; while ( datagrams < vlen ) { if ( MSG_CMSG_COMPAT & flags ) { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) compat_entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = __put_user ( err , & compat_entry -> msg_len ) ; ++ compat_entry ; } else { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = put_user ( err , & entry -> msg_len ) ; ++ entry ; } if ( err ) break ; ++ datagrams ; if ( flags & MSG_WAITFORONE ) flags |= MSG_DONTWAIT ; if ( timeout ) { ktime_get_ts ( timeout ) ; * timeout = timespec_sub ( end_time , * timeout ) ; if ( timeout -> tv_sec < 0 ) { timeout -> tv_sec = timeout -> tv_nsec = 0 ; break ; } if ( timeout -> tv_nsec == 0 && timeout -> tv_sec == 0 ) break ; } if ( msg_sys . msg_flags & MSG_OOB ) break ; cond_resched ( ) ; } out_put : fput_light ( sock -> file , fput_needed ) ; if ( err == 0 ) return datagrams ; if ( datagrams != 0 ) { if ( err != - EAGAIN ) { sock -> sk -> sk_err = - err ; } return datagrams ; } return err ; }
find_alternate_tgs ( kdc_realm_t * kdc_active_realm , krb5_principal princ , krb5_db_entry * * server_ptr , const char * * status ) { krb5_error_code retval ; krb5_principal * plist = NULL , * pl2 ; krb5_data tmp ; krb5_db_entry * server = NULL ; * server_ptr = NULL ; assert ( is_cross_tgs_principal ( princ ) ) ; if ( ( retval = krb5_walk_realm_tree ( kdc_context , krb5_princ_realm ( kdc_context , princ ) , krb5_princ_component ( kdc_context , princ , 1 ) , & plist , KRB5_REALM_BRANCH_CHAR ) ) ) { goto cleanup ; } for ( pl2 = plist ; * pl2 ; pl2 ++ ) ; while ( -- pl2 > plist ) { tmp = * krb5_princ_realm ( kdc_context , * pl2 ) ; krb5_princ_set_realm ( kdc_context , * pl2 , krb5_princ_realm ( kdc_context , tgs_server ) ) ; retval = db_get_svc_princ ( kdc_context , * pl2 , 0 , & server , status ) ; krb5_princ_set_realm ( kdc_context , * pl2 , & tmp ) ; if ( retval == KRB5_KDB_NOENTRY ) continue ; else if ( retval ) goto cleanup ; log_tgs_alt_tgt ( kdc_context , server -> princ ) ; * server_ptr = server ; server = NULL ; goto cleanup ; } cleanup : if ( retval != 0 ) * status = "UNKNOWN_SERVER" ; krb5_free_realm_tree ( kdc_context , plist ) ; krb5_db_free_principal ( kdc_context , server ) ; return retval ; }
inline void VisitPointer ( HeapObject * host , Object * * p ) final { DCHECK ( ! HasWeakHeapObjectTag ( * p ) ) ; RecordMigratedSlot ( host , reinterpret_cast < MaybeObject * > ( * p ) , reinterpret_cast < Address > ( p ) ) ; }
Node * SharedArrayBufferBuiltinsAssembler :: ConvertTaggedAtomicIndexToWord32 ( Node * tagged , Node * context , Node * * number_index ) { VARIABLE ( var_result , MachineRepresentation :: kWord32 ) ; Label done ( this ) , range_error ( this ) ; * number_index = ToSmiIndex ( CAST ( tagged ) , CAST ( context ) , & range_error ) ; var_result . Bind ( SmiToInt32 ( * number_index ) ) ; Goto ( & done ) ; BIND ( & range_error ) ; { ThrowRangeError ( context , MessageTemplate :: kInvalidAtomicAccessIndex ) ; } BIND ( & done ) ; return var_result . value ( ) ; }
void nsHtml5TreeOpExecutor :: SetSpeculationBase ( const nsAString & aURL ) { if ( mSpeculationBaseURI ) { return ; } auto encoding = mDocument -> GetDocumentCharacterSet ( ) ; DebugOnly < nsresult > rv = NS_NewURI ( getter_AddRefs ( mSpeculationBaseURI ) , aURL , encoding , mDocument -> GetDocumentURI ( ) ) ; NS_WARNING_ASSERTION ( NS_SUCCEEDED ( rv ) , "Failed to create a URI" ) ; mDocument -> Preloads ( ) . SetSpeculationBase ( mSpeculationBaseURI ) ; }
Node * JSNativeContextSpecialization :: InlineApiCall ( Node * receiver , Node * holder , Node * frame_state , Node * value , Node * * effect , Node * * control , Handle < SharedFunctionInfo > shared_info , Handle < FunctionTemplateInfo > function_template_info ) { Handle < CallHandlerInfo > call_handler_info = handle ( CallHandlerInfo :: cast ( function_template_info -> call_code ( ) ) , isolate ( ) ) ; Handle < Object > call_data_object ( call_handler_info -> data ( ) , isolate ( ) ) ; int const argc = value == nullptr ? 0 : 1 ; Callable call_api_callback = CodeFactory :: CallApiCallback ( isolate ( ) , argc ) ; CallInterfaceDescriptor call_interface_descriptor = call_api_callback . descriptor ( ) ; auto call_descriptor = Linkage :: GetStubCallDescriptor ( graph ( ) -> zone ( ) , call_interface_descriptor , call_interface_descriptor . GetStackParameterCount ( ) + argc + 1 , CallDescriptor :: kNeedsFrameState ) ; Node * data = jsgraph ( ) -> Constant ( call_data_object ) ; ApiFunction function ( v8 :: ToCData < Address > ( call_handler_info -> callback ( ) ) ) ; Node * function_reference = graph ( ) -> NewNode ( common ( ) -> ExternalConstant ( ExternalReference :: Create ( & function , ExternalReference :: DIRECT_API_CALL ) ) ) ; Node * code = jsgraph ( ) -> HeapConstant ( call_api_callback . code ( ) ) ; Node * context = jsgraph ( ) -> Constant ( native_context ( ) ) ; Node * inputs [ 10 ] = { code , context , data , holder , function_reference , receiver } ; int index = 6 + argc ; inputs [ index ++ ] = frame_state ; inputs [ index ++ ] = * effect ; inputs [ index ++ ] = * control ; if ( value != nullptr ) { inputs [ 6 ] = value ; } return * effect = * control = graph ( ) -> NewNode ( common ( ) -> Call ( call_descriptor ) , index , inputs ) ; }
nsGlobalWindow :: SetDocShell ( nsIDocShell * aDocShell ) { NS_ASSERTION ( IsOuterWindow ( ) , "Uh, SetDocShell() called on inner window!" ) ; if ( aDocShell == mDocShell ) return ; if ( ! aDocShell ) { NS_ASSERTION ( PR_CLIST_IS_EMPTY ( & mTimeouts ) , "Uh, outer window holds timeouts!" ) ; for ( nsRefPtr < nsGlobalWindow > inner = ( nsGlobalWindow * ) PR_LIST_HEAD ( this ) ; inner != this ; inner = ( nsGlobalWindow * ) PR_NEXT_LINK ( inner ) ) { NS_ASSERTION ( inner -> mOuterWindow == this , "bad outer window pointer" ) ; inner -> FreeInnerObjects ( PR_TRUE ) ; } NotifyDOMWindowDestroyed ( this ) ; NotifyWindowIDDestroyed ( "outer-window-destroyed" ) ; nsGlobalWindow * currentInner = GetCurrentInnerWindowInternal ( ) ; if ( currentInner ) { NS_ASSERTION ( mDoc , "Must have doc!" ) ; mDocumentPrincipal = mDoc -> NodePrincipal ( ) ; mDocument = nsnull ; mDoc = nsnull ; } if ( mContext ) { mContext -> ClearScope ( mJSObject , PR_TRUE ) ; } ClearControllers ( ) ; mChromeEventHandler = nsnull ; if ( mArguments ) { mArguments = nsnull ; mArgumentsLast = nsnull ; mArgumentsOrigin = nsnull ; } if ( mContext ) { mContext -> GC ( ) ; mContext -> FinalizeContext ( ) ; mContext = nsnull ; } #ifdef DEBUG nsCycleCollector_DEBUG_shouldBeFreed ( mContext ) ; nsCycleCollector_DEBUG_shouldBeFreed ( static_cast < nsIScriptGlobalObject * > ( this ) ) ; #endif } mDocShell = aDocShell ; if ( mNavigator ) mNavigator -> SetDocShell ( aDocShell ) ; if ( mHistory ) mHistory -> SetDocShell ( aDocShell ) ; if ( mFrames ) mFrames -> SetDocShell ( aDocShell ) ; if ( mScreen ) mScreen -> SetDocShell ( aDocShell ) ; if ( ! mDocShell ) { MaybeForgiveSpamCount ( ) ; CleanUp ( PR_FALSE ) ; } else { if ( mMenubar ) { nsCOMPtr < nsIWebBrowserChrome > browserChrome ; GetWebBrowserChrome ( getter_AddRefs ( browserChrome ) ) ; mMenubar -> SetWebBrowserChrome ( browserChrome ) ; } nsCOMPtr < nsIDOMEventTarget > chromeEventHandler ; mDocShell -> GetChromeEventHandler ( getter_AddRefs ( chromeEventHandler ) ) ; mChromeEventHandler = do_QueryInterface ( chromeEventHandler ) ; if ( ! mChromeEventHandler ) { nsCOMPtr < nsIDOMWindow > parentWindow ; GetParent ( getter_AddRefs ( parentWindow ) ) ; if ( parentWindow . get ( ) != static_cast < nsIDOMWindow * > ( this ) ) { nsCOMPtr < nsPIDOMWindow > piWindow ( do_QueryInterface ( parentWindow ) ) ; mChromeEventHandler = piWindow -> GetChromeEventHandler ( ) ; } else NS_NewWindowRoot ( this , getter_AddRefs ( mChromeEventHandler ) ) ; } } }
static int semctl_down ( struct ipc_namespace * ns , int semid , int cmd , int version , void __user * p ) { struct sem_array * sma ; int err ; struct semid64_ds semid64 ; struct kern_ipc_perm * ipcp ; if ( cmd == IPC_SET ) { if ( copy_semid_from_user ( & semid64 , p , version ) ) return - EFAULT ; } ipcp = ipcctl_pre_down_nolock ( ns , & sem_ids ( ns ) , semid , cmd , & semid64 . sem_perm , 0 ) ; if ( IS_ERR ( ipcp ) ) return PTR_ERR ( ipcp ) ; sma = container_of ( ipcp , struct sem_array , sem_perm ) ; err = security_sem_semctl ( sma , cmd ) ; if ( err ) { rcu_read_unlock ( ) ; goto out_unlock ; } switch ( cmd ) { case IPC_RMID : ipc_lock_object ( & sma -> sem_perm ) ; freeary ( ns , ipcp ) ; goto out_up ; case IPC_SET : ipc_lock_object ( & sma -> sem_perm ) ; err = ipc_update_perm ( & semid64 . sem_perm , ipcp ) ; if ( err ) goto out_unlock ; sma -> sem_ctime = get_seconds ( ) ; break ; default : rcu_read_unlock ( ) ; err = - EINVAL ; goto out_up ; } out_unlock : sem_unlock ( sma ) ; out_up : up_write ( & sem_ids ( ns ) . rw_mutex ) ; return err ; }
size_t jsvGetString ( const JsVar * v , char * str , size_t len ) { assert ( len > 0 ) ; const char * s = jsvGetConstString ( v ) ; if ( s ) { len -- ; int l = 0 ; while ( * s && l < len ) { str [ l ] = s [ l ] ; l ++ ; } str [ l ] = 0 ; return l ; } else if ( jsvIsInt ( v ) ) { itostr ( v -> varData . integer , str , 10 ) ; return strlen ( str ) ; } else if ( jsvIsFloat ( v ) ) { ftoa_bounded ( v -> varData . floating , str , len ) ; return strlen ( str ) ; } else if ( jsvHasCharacterData ( v ) ) { assert ( ! jsvIsStringExt ( v ) ) ; size_t l = len ; JsvStringIterator it ; jsvStringIteratorNewConst ( & it , v , 0 ) ; while ( jsvStringIteratorHasChar ( & it ) ) { if ( l -- <= 1 ) { * str = 0 ; jsvStringIteratorFree ( & it ) ; return len ; } * ( str ++ ) = jsvStringIteratorGetChar ( & it ) ; jsvStringIteratorNext ( & it ) ; } jsvStringIteratorFree ( & it ) ; * str = 0 ; return len - l ; } else { JsVar * stringVar = jsvAsString ( ( JsVar * ) v , false ) ; if ( stringVar ) { size_t l = jsvGetString ( stringVar , str , len ) ; jsvUnLock ( stringVar ) ; return l ; } else { str [ 0 ] = 0 ; jsExceptionHere ( JSET_INTERNALERROR , "Variable type cannot be converted to string" ) ; return 0 ; } } }
TEST_F ( SvcTest , SetScaleFactorsOption ) { svc_ . spatial_layers = 2 ; vpx_codec_err_t res = vpx_svc_set_options ( & svc_ , "scale-factors=not-scale-factors" ) ; EXPECT_EQ ( VPX_CODEC_OK , res ) ; res = vpx_svc_init ( & svc_ , & codec_ , vpx_codec_vp9_cx ( ) , & codec_enc_ ) ; EXPECT_EQ ( VPX_CODEC_INVALID_PARAM , res ) ; res = vpx_svc_set_options ( & svc_ , "scale-factors=1/3,2/3" ) ; EXPECT_EQ ( VPX_CODEC_OK , res ) ; res = vpx_svc_init ( & svc_ , & codec_ , vpx_codec_vp9_cx ( ) , & codec_enc_ ) ; EXPECT_EQ ( VPX_CODEC_OK , res ) ; codec_initialized_ = true ; }
void BytecodeGraphBuilder :: MergeIntoSuccessorEnvironment ( int target_offset ) { BuildLoopExitsForBranch ( target_offset ) ; Environment * & merge_environment = merge_environments_ [ target_offset ] ; if ( merge_environment == nullptr ) { NewMerge ( ) ; merge_environment = environment ( ) ; } else { merge_environment -> Merge ( environment ( ) , bytecode_analysis ( ) -> GetInLivenessFor ( target_offset ) ) ; } set_environment ( nullptr ) ; }
BOOL glyph_cache_put ( rdpGlyphCache * glyphCache , UINT32 id , UINT32 index , rdpGlyph * glyph ) { rdpGlyph * prevGlyph ; if ( id > 9 ) { WLog_ERR ( TAG , "invalid glyph cache id: %" PRIu32 "" , id ) ; return FALSE ; } if ( index > glyphCache -> glyphCache [ id ] . number ) { WLog_ERR ( TAG , "invalid glyph cache index: %" PRIu32 " in cache id: %" PRIu32 "" , index , id ) ; return FALSE ; } WLog_Print ( glyphCache -> log , WLOG_DEBUG , "GlyphCachePut: id: %" PRIu32 " index: %" PRIu32 "" , id , index ) ; prevGlyph = glyphCache -> glyphCache [ id ] . entries [ index ] ; if ( prevGlyph ) prevGlyph -> Free ( glyphCache -> context , prevGlyph ) ; glyphCache -> glyphCache [ id ] . entries [ index ] = glyph ; return TRUE ; }
SetUserAccessServiceDACL ( SC_HANDLE hService , PACL & pNewAcl , PSECURITY_DESCRIPTOR psd ) { DWORD needed = 0 ; if ( ! QueryServiceObjectSecurity ( hService , DACL_SECURITY_INFORMATION , & psd , 0 , & needed ) ) { if ( GetLastError ( ) != ERROR_INSUFFICIENT_BUFFER ) { LOG_WARN ( ( "Could not query service object security size.  (%d)" , GetLastError ( ) ) ) ; return GetLastError ( ) ; } DWORD size = needed ; psd = ( PSECURITY_DESCRIPTOR ) LocalAlloc ( LPTR , size ) ; if ( ! psd ) { LOG_WARN ( ( "Could not allocate security descriptor.  (%d)" , GetLastError ( ) ) ) ; return ERROR_INSUFFICIENT_BUFFER ; } if ( ! QueryServiceObjectSecurity ( hService , DACL_SECURITY_INFORMATION , psd , size , & needed ) ) { LOG_WARN ( ( "Could not allocate security descriptor.  (%d)" , GetLastError ( ) ) ) ; return GetLastError ( ) ; } } PACL pacl = NULL ; BOOL bDaclPresent = FALSE ; BOOL bDaclDefaulted = FALSE ; if ( ! GetSecurityDescriptorDacl ( psd , & bDaclPresent , & pacl , & bDaclDefaulted ) ) { LOG_WARN ( ( "Could not obtain DACL.  (%d)" , GetLastError ( ) ) ) ; return GetLastError ( ) ; } PSID sid ; DWORD SIDSize = SECURITY_MAX_SID_SIZE ; sid = LocalAlloc ( LMEM_FIXED , SIDSize ) ; if ( ! sid ) { LOG_WARN ( ( "Could not allocate SID memory.  (%d)" , GetLastError ( ) ) ) ; return GetLastError ( ) ; } if ( ! CreateWellKnownSid ( WinBuiltinUsersSid , NULL , sid , & SIDSize ) ) { DWORD lastError = GetLastError ( ) ; LOG_WARN ( ( "Could not create well known SID.  (%d)" , lastError ) ) ; LocalFree ( sid ) ; return lastError ; } SID_NAME_USE accountType ; WCHAR accountName [ UNLEN + 1 ] ; WCHAR domainName [ DNLEN + 1 ] ; DWORD accountNameSize = UNLEN + 1 ; DWORD domainNameSize = DNLEN + 1 ; if ( ! LookupAccountSidW ( NULL , sid , accountName , & accountNameSize , domainName , & domainNameSize , & accountType ) ) { LOG_WARN ( ( "Could not lookup account Sid, will try Users.  (%d)" , GetLastError ( ) ) ) ; wcscpy ( accountName , L"Users" ) ; } FreeSid ( sid ) ; sid = NULL ; EXPLICIT_ACCESS ea ; BuildExplicitAccessWithNameW ( & ea , accountName , SERVICE_START | SERVICE_STOP | GENERIC_READ , SET_ACCESS , NO_INHERITANCE ) ; DWORD lastError = SetEntriesInAclW ( 1 , ( PEXPLICIT_ACCESS ) & ea , pacl , & pNewAcl ) ; if ( ERROR_SUCCESS != lastError ) { LOG_WARN ( ( "Could not set entries in ACL.  (%d)" , lastError ) ) ; return lastError ; } SECURITY_DESCRIPTOR sd ; if ( ! InitializeSecurityDescriptor ( & sd , SECURITY_DESCRIPTOR_REVISION ) ) { LOG_WARN ( ( "Could not initialize security descriptor.  (%d)" , GetLastError ( ) ) ) ; return GetLastError ( ) ; } if ( ! SetSecurityDescriptorDacl ( & sd , TRUE , pNewAcl , FALSE ) ) { LOG_WARN ( ( "Could not set security descriptor DACL.  (%d)" , GetLastError ( ) ) ) ; return GetLastError ( ) ; } if ( ! SetServiceObjectSecurity ( hService , DACL_SECURITY_INFORMATION , & sd ) ) { LOG_WARN ( ( "Could not set object security.  (%d)" , GetLastError ( ) ) ) ; return GetLastError ( ) ; } LOG ( ( "User access was set successfully on the service." ) ) ; return ERROR_SUCCESS ; }
void Builtins :: Generate_CallFunction ( MacroAssembler * masm , ConvertReceiverMode mode ) { ASM_LOCATION ( "Builtins::Generate_CallFunction" ) ; __ AssertFunction ( x1 ) ; Label class_constructor ; __ Ldr ( x2 , FieldMemOperand ( x1 , JSFunction :: kSharedFunctionInfoOffset ) ) ; __ Ldr ( w3 , FieldMemOperand ( x2 , SharedFunctionInfo :: kFlagsOffset ) ) ; __ TestAndBranchIfAnySet ( w3 , SharedFunctionInfo :: IsClassConstructorBit :: kMask , & class_constructor ) ; __ Ldr ( cp , FieldMemOperand ( x1 , JSFunction :: kContextOffset ) ) ; Label done_convert ; __ TestAndBranchIfAnySet ( w3 , SharedFunctionInfo :: IsNativeBit :: kMask | SharedFunctionInfo :: IsStrictBit :: kMask , & done_convert ) ; { if ( mode == ConvertReceiverMode :: kNullOrUndefined ) { __ LoadGlobalProxy ( x3 ) ; } else { Label convert_to_object , convert_receiver ; __ Peek ( x3 , Operand ( x0 , LSL , kXRegSizeLog2 ) ) ; __ JumpIfSmi ( x3 , & convert_to_object ) ; STATIC_ASSERT ( LAST_JS_RECEIVER_TYPE == LAST_TYPE ) ; __ CompareObjectType ( x3 , x4 , x4 , FIRST_JS_RECEIVER_TYPE ) ; __ B ( hs , & done_convert ) ; if ( mode != ConvertReceiverMode :: kNotNullOrUndefined ) { Label convert_global_proxy ; __ JumpIfRoot ( x3 , Heap :: kUndefinedValueRootIndex , & convert_global_proxy ) ; __ JumpIfNotRoot ( x3 , Heap :: kNullValueRootIndex , & convert_to_object ) ; __ Bind ( & convert_global_proxy ) ; { __ LoadGlobalProxy ( x3 ) ; } __ B ( & convert_receiver ) ; } __ Bind ( & convert_to_object ) ; { FrameScope scope ( masm , StackFrame :: INTERNAL ) ; __ SmiTag ( x0 ) ; __ Push ( padreg , x0 , x1 , cp ) ; __ Mov ( x0 , x3 ) ; __ Call ( BUILTIN_CODE ( masm -> isolate ( ) , ToObject ) , RelocInfo :: CODE_TARGET ) ; __ Mov ( x3 , x0 ) ; __ Pop ( cp , x1 , x0 , padreg ) ; __ SmiUntag ( x0 ) ; } __ Ldr ( x2 , FieldMemOperand ( x1 , JSFunction :: kSharedFunctionInfoOffset ) ) ; __ Bind ( & convert_receiver ) ; } __ Poke ( x3 , Operand ( x0 , LSL , kXRegSizeLog2 ) ) ; } __ Bind ( & done_convert ) ; __ Ldrh ( x2 , FieldMemOperand ( x2 , SharedFunctionInfo :: kFormalParameterCountOffset ) ) ; ParameterCount actual ( x0 ) ; ParameterCount expected ( x2 ) ; __ InvokeFunctionCode ( x1 , no_reg , expected , actual , JUMP_FUNCTION ) ; __ Bind ( & class_constructor ) ; { FrameScope frame ( masm , StackFrame :: INTERNAL ) ; __ PushArgument ( x1 ) ; __ CallRuntime ( Runtime :: kThrowConstructorNonCallableError ) ; } }
DataSourceSurfaceD2D1 :: EnsureMapped ( ) { MOZ_ASSERT ( ! mIsMapped ) ; if ( mMapped ) { return ; } mBitmap -> Map ( D2D1_MAP_OPTIONS_READ , & mMap ) ; mMapped = true ; }
static struct phy * serdes_simple_xlate ( struct device * dev , struct of_phandle_args * args ) { struct serdes_ctrl * ctrl = dev_get_drvdata ( dev ) ; unsigned int port , idx , i ; if ( args -> args_count != 2 ) return ERR_PTR ( - EINVAL ) ; port = args -> args [ 0 ] ; idx = args -> args [ 1 ] ; for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ; if ( idx != macro -> idx ) continue ; if ( idx != SERDES6G ( 0 ) && macro -> port >= 0 ) return ERR_PTR ( - EBUSY ) ; macro -> port = port ; return ctrl -> phys [ i ] ; } return ERR_PTR ( - ENODEV ) ; }
Reduction TypedOptimization :: ReduceLoadField ( Node * node ) { Node * const object = NodeProperties :: GetValueInput ( node , 0 ) ; Type const object_type = NodeProperties :: GetType ( object ) ; FieldAccess const & access = FieldAccessOf ( node -> op ( ) ) ; if ( access . base_is_tagged == kTaggedBase && access . offset == HeapObject :: kMapOffset ) { base :: Optional < MapRef > object_map = GetStableMapFromObjectType ( js_heap_broker ( ) , object_type ) ; if ( object_map . has_value ( ) ) { dependencies ( ) -> DependOnStableMap ( * object_map ) ; Node * const value = jsgraph ( ) -> Constant ( * object_map ) ; ReplaceWithValue ( node , value ) ; return Replace ( value ) ; } } return NoChange ( ) ; }
int tcp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , const struct tcphdr * th , unsigned int len ) { struct tcp_sock * tp = tcp_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; int queued = 0 ; int res ; tp -> rx_opt . saw_tstamp = 0 ; switch ( sk -> sk_state ) { case TCP_CLOSE : goto discard ; case TCP_LISTEN : if ( th -> ack ) return 1 ; if ( th -> rst ) goto discard ; if ( th -> syn ) { if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) return 1 ; kfree_skb ( skb ) ; return 0 ; } goto discard ; case TCP_SYN_SENT : queued = tcp_rcv_synsent_state_process ( sk , skb , th , len ) ; if ( queued >= 0 ) return queued ; tcp_urg ( sk , skb , th ) ; __kfree_skb ( skb ) ; tcp_data_snd_check ( sk ) ; return 0 ; } res = tcp_validate_incoming ( sk , skb , th , 0 ) ; if ( res <= 0 ) return - res ; if ( th -> ack ) { int acceptable = tcp_ack ( sk , skb , FLAG_SLOWPATH ) > 0 ; switch ( sk -> sk_state ) { case TCP_SYN_RECV : if ( acceptable ) { tp -> copied_seq = tp -> rcv_nxt ; smp_mb ( ) ; tcp_set_state ( sk , TCP_ESTABLISHED ) ; sk -> sk_state_change ( sk ) ; if ( sk -> sk_socket ) sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; tp -> snd_una = TCP_SKB_CB ( skb ) -> ack_seq ; tp -> snd_wnd = ntohs ( th -> window ) < < tp -> rx_opt . snd_wscale ; tcp_init_wl ( tp , TCP_SKB_CB ( skb ) -> seq ) ; if ( tp -> rx_opt . tstamp_ok ) tp -> advmss -= TCPOLEN_TSTAMP_ALIGNED ; icsk -> icsk_af_ops -> rebuild_header ( sk ) ; tcp_init_metrics ( sk ) ; tcp_init_congestion_control ( sk ) ; tp -> lsndtime = tcp_time_stamp ; tcp_mtup_init ( sk ) ; tcp_initialize_rcv_mss ( sk ) ; tcp_init_buffer_space ( sk ) ; tcp_fast_path_on ( tp ) ; } else { return 1 ; } break ; case TCP_FIN_WAIT1 : if ( tp -> snd_una == tp -> write_seq ) { tcp_set_state ( sk , TCP_FIN_WAIT2 ) ; sk -> sk_shutdown |= SEND_SHUTDOWN ; dst_confirm ( __sk_dst_get ( sk ) ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_state_change ( sk ) ; else { int tmo ; if ( tp -> linger2 < 0 || ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) ) { tcp_done ( sk ) ; NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; return 1 ; } tmo = tcp_fin_time ( sk ) ; if ( tmo > TCP_TIMEWAIT_LEN ) { inet_csk_reset_keepalive_timer ( sk , tmo - TCP_TIMEWAIT_LEN ) ; } else if ( th -> fin || sock_owned_by_user ( sk ) ) { inet_csk_reset_keepalive_timer ( sk , tmo ) ; } else { tcp_time_wait ( sk , TCP_FIN_WAIT2 , tmo ) ; goto discard ; } } } break ; case TCP_CLOSING : if ( tp -> snd_una == tp -> write_seq ) { tcp_time_wait ( sk , TCP_TIME_WAIT , 0 ) ; goto discard ; } break ; case TCP_LAST_ACK : if ( tp -> snd_una == tp -> write_seq ) { tcp_update_metrics ( sk ) ; tcp_done ( sk ) ; goto discard ; } break ; } } else goto discard ; tcp_urg ( sk , skb , th ) ; switch ( sk -> sk_state ) { case TCP_CLOSE_WAIT : case TCP_CLOSING : case TCP_LAST_ACK : if ( ! before ( TCP_SKB_CB ( skb ) -> seq , tp -> rcv_nxt ) ) break ; case TCP_FIN_WAIT1 : case TCP_FIN_WAIT2 : if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { if ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; tcp_reset ( sk ) ; return 1 ; } } case TCP_ESTABLISHED : tcp_data_queue ( sk , skb ) ; queued = 1 ; break ; } if ( sk -> sk_state != TCP_CLOSE ) { tcp_data_snd_check ( sk ) ; tcp_ack_snd_check ( sk ) ; } if ( ! queued ) { discard : __kfree_skb ( skb ) ; } return 0 ; }
static gboolean key_value_ok ( gchar * key , gchar * value ) { char * i ; for ( i = key ; * i != 0 ; i ++ ) { if ( ! isalpha ( * i ) && ( * i != '-' ) && ( * i != '_' ) && ( * i != ' ' ) ) return FALSE ; } if ( strcmp ( key , "basename" ) == 0 || strcmp ( key , FILENAME_TYPE ) == 0 ) { if ( ! str_is_correct_filename ( value ) ) { error_msg ( "Value of '%s' ('%s') is not a valid directory name" , key , value ) ; return FALSE ; } } return TRUE ; }
mem_log_init ( const char * prog_name , const char * banner ) { size_t log_name_len ; char * log_name ; if ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) { log_op = stderr ; return ; } if ( log_op ) fclose ( log_op ) ; log_name_len = 5 + strlen ( prog_name ) + 5 + 7 + 4 + 1 ; log_name = malloc ( log_name_len ) ; if ( ! log_name ) { log_message ( LOG_INFO , "Unable to malloc log file name" ) ; log_op = stderr ; return ; } snprintf ( log_name , log_name_len , "/tmp/%s_mem.%d.log" , prog_name , getpid ( ) ) ; log_op = fopen ( log_name , "a" ) ; if ( log_op == NULL ) { log_message ( LOG_INFO , "Unable to open %s for appending" , log_name ) ; log_op = stderr ; } else { int fd = fileno ( log_op ) ; fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD ) | FD_CLOEXEC ) ; setlinebuf ( log_op ) ; fprintf ( log_op , "\n" ) ; } free ( log_name ) ; terminate_banner = banner ; }
void GCTracer :: AddAllocation ( double current_ms ) { allocation_time_ms_ = current_ms ; if ( allocation_duration_since_gc_ > 0 ) { recorded_new_generation_allocations_ . Push ( MakeBytesAndDuration ( new_space_allocation_in_bytes_since_gc_ , allocation_duration_since_gc_ ) ) ; recorded_old_generation_allocations_ . Push ( MakeBytesAndDuration ( old_generation_allocation_in_bytes_since_gc_ , allocation_duration_since_gc_ ) ) ; } allocation_duration_since_gc_ = 0 ; new_space_allocation_in_bytes_since_gc_ = 0 ; old_generation_allocation_in_bytes_since_gc_ = 0 ; }
OMX_ERRORTYPE SoftVPXEncoder :: internalSetParameter ( OMX_INDEXTYPE index , const OMX_PTR param ) { const int32_t indexFull = index ; switch ( indexFull ) { case OMX_IndexParamVideoBitrate : return internalSetBitrateParams ( ( const OMX_VIDEO_PARAM_BITRATETYPE * ) param ) ; case OMX_IndexParamVideoVp8 : return internalSetVp8Params ( ( const OMX_VIDEO_PARAM_VP8TYPE * ) param ) ; case OMX_IndexParamVideoAndroidVp8Encoder : return internalSetAndroidVp8Params ( ( const OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE * ) param ) ; default : return SoftVideoEncoderOMXComponent :: internalSetParameter ( index , param ) ; } }
nsContentUtils :: RemoveScriptBlocker ( ) { NS_ASSERTION ( sScriptBlockerCount != 0 , "Negative script blockers" ) ; -- sScriptBlockerCount ; if ( sScriptBlockerCount ) { return ; } uint32_t firstBlocker = sRunnersCountAtFirstBlocker ; uint32_t lastBlocker = sBlockedScriptRunners -> Length ( ) ; uint32_t originalFirstBlocker = firstBlocker ; uint32_t blockersCount = lastBlocker - firstBlocker ; sRunnersCountAtFirstBlocker = 0 ; NS_ASSERTION ( firstBlocker <= lastBlocker , "bad sRunnersCountAtFirstBlocker" ) ; while ( firstBlocker < lastBlocker ) { nsCOMPtr < nsIRunnable > runnable = ( * sBlockedScriptRunners ) [ firstBlocker ] ; ++ firstBlocker ; runnable -> Run ( ) ; NS_ASSERTION ( sRunnersCountAtFirstBlocker == 0 , "Bad count" ) ; NS_ASSERTION ( ! sScriptBlockerCount , "This is really bad" ) ; } sBlockedScriptRunners -> RemoveElementsAt ( originalFirstBlocker , blockersCount ) ; }
int ecryptfs_privileged_open ( struct file * * lower_file , struct dentry * lower_dentry , struct vfsmount * lower_mnt , const struct cred * cred ) { struct ecryptfs_open_req req ; int flags = O_LARGEFILE ; int rc = 0 ; init_completion ( & req . done ) ; req . lower_file = lower_file ; req . path . dentry = lower_dentry ; req . path . mnt = lower_mnt ; flags |= IS_RDONLY ( d_inode ( lower_dentry ) ) ? O_RDONLY : O_RDWR ; ( * lower_file ) = dentry_open ( & req . path , flags , cred ) ; if ( ! IS_ERR ( * lower_file ) ) goto out ; if ( ( flags & O_ACCMODE ) == O_RDONLY ) { rc = PTR_ERR ( ( * lower_file ) ) ; goto out ; } mutex_lock ( & ecryptfs_kthread_ctl . mux ) ; if ( ecryptfs_kthread_ctl . flags & ECRYPTFS_KTHREAD_ZOMBIE ) { rc = - EIO ; mutex_unlock ( & ecryptfs_kthread_ctl . mux ) ; printk ( KERN_ERR "%s: We are in the middle of shutting down; " "aborting privileged request to open lower file\n" , __func__ ) ; goto out ; } list_add_tail ( & req . kthread_ctl_list , & ecryptfs_kthread_ctl . req_list ) ; mutex_unlock ( & ecryptfs_kthread_ctl . mux ) ; wake_up ( & ecryptfs_kthread_ctl . wait ) ; wait_for_completion ( & req . done ) ; if ( IS_ERR ( * lower_file ) ) rc = PTR_ERR ( * lower_file ) ; out : return rc ; }
gfxPlatform :: Init ( ) { MOZ_RELEASE_ASSERT ( NS_IsMainThread ( ) ) ; if ( gEverInitialized ) { NS_RUNTIMEABORT ( "Already started???" ) ; } gEverInitialized = true ; CrashStatsLogForwarder * logForwarder = new CrashStatsLogForwarder ( "GraphicsCriticalError" ) ; mozilla :: gfx :: Factory :: SetLogForwarder ( logForwarder ) ; gfxPrefs :: GetSingleton ( ) ; logForwarder -> SetCircularBufferSize ( gfxPrefs :: GfxLoggingCrashLength ( ) ) ; gGfxPlatformPrefsLock = new Mutex ( "gfxPlatform::gGfxPlatformPrefsLock" ) ; nsCOMPtr < nsIGfxInfo > gfxInfo ; gfxInfo = do_GetService ( "@mozilla.org/gfx/info;1" ) ; #if defined(XP_WIN) gPlatform = new gfxWindowsPlatform ; #elif defined(XP_MACOSX) gPlatform = new gfxPlatformMac ; #elif defined(MOZ_WIDGET_GTK) gPlatform = new gfxPlatformGtk ; #elif defined(MOZ_WIDGET_QT) gPlatform = new gfxQtPlatform ; #elif defined(ANDROID) gPlatform = new gfxAndroidPlatform ; #else #error "No gfxPlatform implementation available" #endif #ifdef MOZ_GL_DEBUG mozilla :: gl :: GLContext :: StaticInit ( ) ; #endif InitLayersAccelerationPrefs ( ) ; InitLayersIPC ( ) ; nsresult rv ; bool usePlatformFontList = true ; #if defined(MOZ_WIDGET_GTK) usePlatformFontList = gfxPlatformGtk :: UseFcFontList ( ) ; #elif defined(MOZ_WIDGET_QT) usePlatformFontList = false ; #endif if ( usePlatformFontList ) { rv = gfxPlatformFontList :: Init ( ) ; if ( NS_FAILED ( rv ) ) { NS_RUNTIMEABORT ( "Could not initialize gfxPlatformFontList" ) ; } } gPlatform -> mScreenReferenceSurface = gPlatform -> CreateOffscreenSurface ( IntSize ( 1 , 1 ) , gfxContentType :: COLOR_ALPHA ) ; if ( ! gPlatform -> mScreenReferenceSurface ) { NS_RUNTIMEABORT ( "Could not initialize mScreenReferenceSurface" ) ; } gPlatform -> mScreenReferenceDrawTarget = gPlatform -> CreateOffscreenContentDrawTarget ( IntSize ( 1 , 1 ) , SurfaceFormat :: B8G8R8A8 ) ; if ( ! gPlatform -> mScreenReferenceDrawTarget ) { NS_RUNTIMEABORT ( "Could not initialize mScreenReferenceDrawTarget" ) ; } rv = gfxFontCache :: Init ( ) ; if ( NS_FAILED ( rv ) ) { NS_RUNTIMEABORT ( "Could not initialize gfxFontCache" ) ; } gPlatform -> mSRGBOverrideObserver = new SRGBOverrideObserver ( ) ; Preferences :: AddWeakObserver ( gPlatform -> mSRGBOverrideObserver , GFX_PREF_CMS_FORCE_SRGB ) ; gPlatform -> mFontPrefsObserver = new FontPrefsObserver ( ) ; Preferences :: AddStrongObservers ( gPlatform -> mFontPrefsObserver , kObservedPrefs ) ; mozilla :: gl :: GLContext :: PlatformStartup ( ) ; #ifdef MOZ_WIDGET_ANDROID mozilla :: gl :: TexturePoolOGL :: Init ( ) ; #endif #ifdef MOZ_WIDGET_GONK mozilla :: layers :: InitGralloc ( ) ; #endif Preferences :: RegisterCallbackAndCall ( RecordingPrefChanged , "gfx.2d.recording" , nullptr ) ; CreateCMSOutputProfile ( ) ; nsCOMPtr < nsIObserverService > obs = mozilla :: services :: GetObserverService ( ) ; if ( obs ) { gPlatform -> mMemoryPressureObserver = new MemoryPressureObserver ( ) ; obs -> AddObserver ( gPlatform -> mMemoryPressureObserver , "memory-pressure" , false ) ; } nsCOMPtr < imgITools > imgTools = do_GetService ( "@mozilla.org/image/tools;1" ) ; if ( ! imgTools ) { NS_RUNTIMEABORT ( "Could not initialize ImageLib" ) ; } RegisterStrongMemoryReporter ( new GfxMemoryImageReporter ( ) ) ; if ( XRE_IsParentProcess ( ) && gfxPrefs :: HardwareVsyncEnabled ( ) ) { gPlatform -> mVsyncSource = gPlatform -> CreateHardwareVsyncSource ( ) ; } }
std :: shared_ptr < AsyncStackTrace > AsyncStackTrace :: capture ( V8Debugger * debugger , int contextGroupId , const String16 & description , int maxStackSize ) { DCHECK ( debugger ) ; v8 :: Isolate * isolate = debugger -> isolate ( ) ; v8 :: HandleScope handleScope ( isolate ) ; std :: vector < std :: shared_ptr < StackFrame > > frames ; if ( isolate -> InContext ( ) ) { v8 :: Local < v8 :: StackTrace > v8StackTrace = v8 :: StackTrace :: CurrentStackTrace ( isolate , maxStackSize , stackTraceOptions ) ; frames = toFramesVector ( debugger , v8StackTrace , maxStackSize ) ; } std :: shared_ptr < AsyncStackTrace > asyncParent ; V8StackTraceId externalParent ; calculateAsyncChain ( debugger , contextGroupId , & asyncParent , & externalParent , nullptr ) ; if ( frames . empty ( ) && ! asyncParent && externalParent . IsInvalid ( ) ) return nullptr ; if ( asyncParent && frames . empty ( ) && ( asyncParent -> m_description == description || description . isEmpty ( ) ) ) { return asyncParent ; } DCHECK ( contextGroupId || asyncParent || ! externalParent . IsInvalid ( ) ) ; if ( ! contextGroupId && asyncParent ) { contextGroupId = asyncParent -> m_contextGroupId ; } return std :: shared_ptr < AsyncStackTrace > ( new AsyncStackTrace ( contextGroupId , description , std :: move ( frames ) , asyncParent , externalParent ) ) ; }
void UpdateLiveness ( Bytecode bytecode , BytecodeLiveness & liveness , BytecodeLivenessState * * next_bytecode_in_liveness , const interpreter :: BytecodeArrayAccessor & accessor , const BytecodeLivenessMap & liveness_map ) { UpdateOutLiveness ( bytecode , * liveness . out , * next_bytecode_in_liveness , accessor , liveness_map ) ; liveness . in -> CopyFrom ( * liveness . out ) ; UpdateInLiveness ( bytecode , * liveness . in , accessor ) ; * next_bytecode_in_liveness = liveness . in ; }
void SetScanResponseData ( uint8_t handle , uint8_t operation , uint8_t fragment_preference , uint8_t scan_response_data_length , uint8_t * scan_response_data , status_cb command_complete ) override { VLOG ( 1 ) < < __func__ ; uint8_t param [ HCIC_PARAM_SIZE_BLE_WRITE_ADV_DATA + 1 ] ; uint8_t * pp = param ; memset ( pp , 0 , HCIC_PARAM_SIZE_BLE_WRITE_ADV_DATA + 1 ) ; UINT8_TO_STREAM ( pp , scan_response_data_length ) ; ARRAY_TO_STREAM ( pp , scan_response_data , scan_response_data_length ) ; SendAdvCmd ( FROM_HERE , HCI_BLE_WRITE_SCAN_RSP_DATA , param , HCIC_PARAM_SIZE_BLE_WRITE_ADV_DATA + 1 , command_complete ) ; }
